# Comparing `tmp/pyunicorn-0.6.1.tar.gz` & `tmp/pyunicorn-0.7.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/pyunicorn-0.6.1.tar", last modified: Fri Jun 21 08:33:44 2019, max compression
+gzip compressed data, was "pyunicorn-0.7.0.tar", last modified: Fri Feb 23 14:31:20 2024, max compression
```

## Comparing `pyunicorn-0.6.1.tar` & `pyunicorn-0.7.0.tar`

### file list

```diff
@@ -1,197 +1,210 @@
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/
--rw-r--r--   0 donges     (502) staff       (20)     1122 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/PKG-INFO
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/
--rw-r--r--   0 donges     (502) staff       (20)     2189 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/conftest.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/core/
--rw-r--r--   0 donges     (502) staff       (20)    70248 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/interacting_networks.py
--rw-r--r--   0 donges     (502) staff       (20)    24100 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/grid.py
--rw-r--r--   0 donges     (502) staff       (20)    69255 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/geo_network.py
--rw-r--r--   0 donges     (502) staff       (20)    29584 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/pyunicorn/core/resistive_network.py
--rw-r--r--   0 donges     (502) staff       (20)     1513 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)   678183 2016-06-15 13:29:40.000000 pyunicorn-0.6.1/pyunicorn/core/numerics.c
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/core/_ext/
--rw-r--r--   0 donges     (502) staff       (20)      686 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/_ext/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)  1091918 2019-06-21 08:17:38.000000 pyunicorn-0.6.1/pyunicorn/core/_ext/numerics.c
--rw-r--r--   0 donges     (502) staff       (20)    13481 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/pyunicorn/core/_ext/src_numerics.c
--rw-r--r--   0 donges     (502) staff       (20)    35366 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/_ext/numerics.pyx
--rw-r--r--   0 donges     (502) staff       (20)     9812 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/netcdf_dictionary.py
--rw-r--r--   0 donges     (502) staff       (20)   203509 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/network.py
--rw-r--r--   0 donges     (502) staff       (20)    28528 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/core/data.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/timeseries/
--rw-r--r--   0 donges     (502) staff       (20)     9778 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/joint_recurrence_network.py
--rw-r--r--   0 donges     (502) staff       (20)    13931 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/recurrence_network.py
--rw-r--r--   0 donges     (502) staff       (20)    14821 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/cross_recurrence_plot.py
--rw-r--r--   0 donges     (502) staff       (20)    14743 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/joint_recurrence_plot.py
--rw-r--r--   0 donges     (502) staff       (20)     2260 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)   798082 2016-06-15 13:29:42.000000 pyunicorn-0.6.1/pyunicorn/timeseries/numerics.c
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/timeseries/_ext/
--rw-r--r--   0 donges     (502) staff       (20)      686 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/_ext/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)  1007910 2019-06-21 08:17:39.000000 pyunicorn-0.6.1/pyunicorn/timeseries/_ext/numerics.c
--rw-r--r--   0 donges     (502) staff       (20)     9468 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/_ext/src_numerics.c
--rw-r--r--   0 donges     (502) staff       (20)    31154 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/_ext/numerics.pyx
--rw-r--r--   0 donges     (502) staff       (20)    11810 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/visibility_graph.py
--rw-r--r--   0 donges     (502) staff       (20)    15414 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/inter_system_recurrence_network.py
--rw-r--r--   0 donges     (502) staff       (20)    28907 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/surrogates.py
--rw-r--r--   0 donges     (502) staff       (20)    54974 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/timeseries/recurrence_plot.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/eventseries/
--rw-r--r--   0 donges     (502) staff       (20)     3378 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/eventseries/eca.py
--rw-r--r--   0 donges     (502) staff       (20)     1444 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/__init__.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/utils/
--rw-r--r--   0 donges     (502) staff       (20)      793 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/__init__.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/utils/progressbar/
--rw-r--r--   0 donges     (502) staff       (20)     1460 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/progressbar/compat.py
--rw-r--r--   0 donges     (502) staff       (20)     1959 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/progressbar/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)    13501 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/progressbar/widgets.py
--rw-r--r--   0 donges     (502) staff       (20)     9454 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/progressbar/progressbar.py
--rw-r--r--   0 donges     (502) staff       (20)    66083 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/navigator.py
--rw-r--r--   0 donges     (502) staff       (20)    19778 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/utils/mpi.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/funcnet/
--rw-r--r--   0 donges     (502) staff       (20)     7116 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/funcnet/event_synchronization.py
--rw-r--r--   0 donges     (502) staff       (20)    27445 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/funcnet/coupling_analysis_pure_python.py
--rw-r--r--   0 donges     (502) staff       (20)      983 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/funcnet/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)    28894 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/funcnet/coupling_analysis.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/funcnet/_ext/
--rw-r--r--   0 donges     (502) staff       (20)      686 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/funcnet/_ext/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)   364918 2019-06-21 08:17:39.000000 pyunicorn-0.6.1/pyunicorn/funcnet/_ext/numerics.c
--rw-r--r--   0 donges     (502) staff       (20)     6972 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/pyunicorn/funcnet/_ext/src_numerics.c
--rw-r--r--   0 donges     (502) staff       (20)     5219 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/funcnet/_ext/numerics.pyx
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/climate/
--rw-r--r--   0 donges     (502) staff       (20)     5236 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/spearman.py
--rw-r--r--   0 donges     (502) staff       (20)    10503 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/rainfall.py
--rw-r--r--   0 donges     (502) staff       (20)     1816 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)     8255 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/hilbert.py
--rw-r--r--   0 donges     (502) staff       (20)    19474 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/climate_data.py
--rw-r--r--   0 donges     (502) staff       (20)    11573 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/tsonis.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn/climate/_ext/
--rw-r--r--   0 donges     (502) staff       (20)      686 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/_ext/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)   329198 2019-06-21 08:17:38.000000 pyunicorn-0.6.1/pyunicorn/climate/_ext/numerics.c
--rw-r--r--   0 donges     (502) staff       (20)     7401 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/pyunicorn/climate/_ext/src_numerics.c
--rw-r--r--   0 donges     (502) staff       (20)     3166 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/_ext/numerics.pyx
--rw-r--r--   0 donges     (502) staff       (20)    14446 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/mutual_info.py
--rw-r--r--   0 donges     (502) staff       (20)    11667 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/map_plots.py
--rw-r--r--   0 donges     (502) staff       (20)    24223 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/coupled_climate_network.py
--rw-r--r--   0 donges     (502) staff       (20)    13049 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/havlin.py
--rw-r--r--   0 donges     (502) staff       (20)    26913 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/climate_network.py
--rw-r--r--   0 donges     (502) staff       (20)     6055 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/eventsynchronization_climatenetwork.py
--rw-r--r--   0 donges     (502) staff       (20)     4702 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/partial_correlation.py
--rw-r--r--   0 donges     (502) staff       (20)     7387 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pyunicorn/climate/coupled_tsonis.py
--rw-r--r--   0 donges     (502) staff       (20)      668 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/pytest.ini
--rw-r--r--   0 donges     (502) staff       (20)       48 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/requirements.txt
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn.egg-info/
--rw-r--r--   0 donges     (502) staff       (20)     1122 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn.egg-info/PKG-INFO
--rw-r--r--   0 donges     (502) staff       (20)     5600 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn.egg-info/SOURCES.txt
--rw-r--r--   0 donges     (502) staff       (20)       48 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn.egg-info/requires.txt
--rw-r--r--   0 donges     (502) staff       (20)       10 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn.egg-info/top_level.txt
--rw-r--r--   0 donges     (502) staff       (20)        1 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/pyunicorn.egg-info/dependency_links.txt
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/tests/
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/tests/test_timeseries/
--rw-r--r--   0 donges     (502) staff       (20)     2347 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_timeseries/test_surrogates.py
--rw-r--r--   0 donges     (502) staff       (20)     5256 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_timeseries/test_timeseries.py
--rw-r--r--   0 donges     (502) staff       (20)      706 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_timeseries/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)      734 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)     2875 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_generic.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/tests/test_funcnet/
--rw-r--r--   0 donges     (502) staff       (20)      706 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_funcnet/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)     3713 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_funcnet/test_event_synchronization.py
--rw-r--r--   0 donges     (502) staff       (20)     4448 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_funcnet/test_coupling_analysis.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/tests/test_core/
--rw-r--r--   0 donges     (502) staff       (20)     5008 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/test_grid.py
--rw-r--r--   0 donges     (502) staff       (20)     6409 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-circuits.py
--rw-r--r--   0 donges     (502) staff       (20)     2021 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-cython.py
--rw-r--r--   0 donges     (502) staff       (20)      897 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)    10777 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/test_geo_network.py
--rw-r--r--   0 donges     (502) staff       (20)     1162 2015-06-17 07:37:30.000000 pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-complexInput.py
--rw-r--r--   0 donges     (502) staff       (20)    31028 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/test_network.py
--rw-r--r--   0 donges     (502) staff       (20)    15459 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/test_interacting_networks.py
--rw-r--r--   0 donges     (502) staff       (20)      424 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-types.py
--rw-r--r--   0 donges     (502) staff       (20)     5369 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/test_data.py
--rw-r--r--   0 donges     (502) staff       (20)     6768 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_core/test_resistive_networks.py
--rw-r--r--   0 donges     (502) staff       (20)     2513 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/tests/test_core/ResistiveNetwork_utils.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/tests/test_climate/
--rw-r--r--   0 donges     (502) staff       (20)      706 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_climate/__init__.py
--rw-r--r--   0 donges     (502) staff       (20)     4601 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_climate/test_climate_network.py
--rw-r--r--   0 donges     (502) staff       (20)     4321 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_climate/test_climate_data.py
--rw-r--r--   0 donges     (502) staff       (20)     2821 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_climate/test_eventsynchronization_climatenetwork.py
--rw-r--r--   0 donges     (502) staff       (20)     4132 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tests/test_climate/test_tsonis.py
--rw-r--r--   0 donges     (502) staff       (20)      253 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/MANIFEST.in
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/
--rwxr-xr-x   0 donges     (502) staff       (20)      608 2017-11-20 16:29:17.000000 pyunicorn-0.6.1/docs/Makefile
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/
--rw-r--r--   0 donges     (502) staff       (20)      237 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/download.rst
--rw-r--r--   0 donges     (502) staff       (20)      752 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/index.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/_templates/
--rw-r--r--   0 donges     (502) staff       (20)      462 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/docs/source/_templates/layout.html
--rw-r--r--   0 donges     (502) staff       (20)     5866 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/docs/source/conf.py
--rw-r--r--   0 donges     (502) staff       (20)      214 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/contact.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/_static/
--rw-r--r--   0 donges     (502) staff       (20)    14027 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/_static/logo.png
--rw-r--r--   0 donges     (502) staff       (20)     8170 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/_static/default.css
--rw-r--r--   0 donges     (502) staff       (20)   299147 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/_static/logo.psd
--rw-r--r--   0 donges     (502) staff       (20)      201 2015-06-04 12:08:15.000000 pyunicorn-0.6.1/docs/source/sitemap.rst
--rw-r--r--   0 donges     (502) staff       (20)      121 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/development.rst
--rw-r--r--   0 donges     (502) staff       (20)     1279 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/api_doc.rst
--rw-r--r--   0 donges     (502) staff       (20)      146 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/license.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/core/
--rw-r--r--   0 donges     (502) staff       (20)      248 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/grid.rst
--rw-r--r--   0 donges     (502) staff       (20)      219 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/resistive_network.rst
--rw-r--r--   0 donges     (502) staff       (20)      248 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/data.rst
--rw-r--r--   0 donges     (502) staff       (20)      296 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/interacting_networks.rst
--rw-r--r--   0 donges     (502) staff       (20)      243 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/netcdf_dictionary.rst
--rw-r--r--   0 donges     (502) staff       (20)      269 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/geo_network.rst
--rw-r--r--   0 donges     (502) staff       (20)      223 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/core/network.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/timeseries/
--rw-r--r--   0 donges     (502) staff       (20)      283 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/joint_recurrence_plot.rst
--rw-r--r--   0 donges     (502) staff       (20)      313 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/inter_system_recurrence_network.rst
--rw-r--r--   0 donges     (502) staff       (20)      274 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/recurrence_network.rst
--rw-r--r--   0 donges     (502) staff       (20)      276 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/surrogates.rst
--rw-r--r--   0 donges     (502) staff       (20)      265 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/recurrence_plot.rst
--rw-r--r--   0 donges     (502) staff       (20)      283 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/cross_recurrence_plot.rst
--rw-r--r--   0 donges     (502) staff       (20)      268 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/visibility_graph.rst
--rw-r--r--   0 donges     (502) staff       (20)      292 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/timeseries/joint_recurrence_network.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/eventseries/
--rw-r--r--   0 donges     (502) staff       (20)      185 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/api/eventseries/eca.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/utils/
--rw-r--r--   0 donges     (502) staff       (20)       33 2017-11-20 16:29:17.000000 pyunicorn-0.6.1/docs/source/api/utils/navigator.rst
--rw-r--r--   0 donges     (502) staff       (20)      183 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/utils/mpi.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/funcnet/
--rw-r--r--   0 donges     (502) staff       (20)      332 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/funcnet/coupling_analysis_pure_python.rst
--rw-r--r--   0 donges     (502) staff       (20)      296 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/funcnet/coupling_analysis.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/api/climate/
--rw-r--r--   0 donges     (502) staff       (20)      209 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/mutual_info.rst
--rw-r--r--   0 donges     (502) staff       (20)      212 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/climate_data.rst
--rw-r--r--   0 donges     (502) staff       (20)      226 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/coupled_tsonis.rst
--rw-r--r--   0 donges     (502) staff       (20)      221 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/climate_network.rst
--rw-r--r--   0 donges     (502) staff       (20)      253 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/coupled_climate_network.rst
--rw-r--r--   0 donges     (502) staff       (20)      200 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/spearman.rst
--rw-r--r--   0 donges     (502) staff       (20)      200 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/rainfall.rst
--rw-r--r--   0 donges     (502) staff       (20)      194 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/tsonis.rst
--rw-r--r--   0 donges     (502) staff       (20)      272 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/map_plots.rst
--rw-r--r--   0 donges     (502) staff       (20)      194 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/havlin.rst
--rw-r--r--   0 donges     (502) staff       (20)      233 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/partial_correlation.rst
--rw-r--r--   0 donges     (502) staff       (20)      197 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/api/climate/hilbert.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/docs/source/tutorials/
--rw-r--r--   0 donges     (502) staff       (20)      362 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/tutorials/recurrence_network_1.rst
--rw-r--r--   0 donges     (502) staff       (20)      913 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/docs/source/tutorials/climate_network_1.rst
--rw-r--r--   0 donges     (502) staff       (20)      262 2015-04-14 06:58:14.000000 pyunicorn-0.6.1/docs/source/tutorials.rst
--rw-r--r--   0 donges     (502) staff       (20)     1651 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/docs/source/changelog.rst
--rw-r--r--   0 donges     (502) staff       (20)     5720 2015-04-16 13:54:57.000000 pyunicorn-0.6.1/docs/source/methods.rst
--rw-r--r--   0 donges     (502) staff       (20)    23248 2016-06-03 10:17:27.000000 pyunicorn-0.6.1/docs/source/publications.rst
--rw-r--r--   0 donges     (502) staff       (20)     3578 2019-06-21 08:16:46.000000 pyunicorn-0.6.1/setup.py
--rw-r--r--   0 donges     (502) staff       (20)     2158 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/CONTRIBUTIONS.rst
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/examples/
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/examples/tutorials/
--rw-r--r--   0 donges     (502) staff       (20)     3704 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/examples/tutorials/recurrence_network.py
--rw-r--r--   0 donges     (502) staff       (20)     5044 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/examples/tutorials/climate_network.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/examples/modules/
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/examples/modules/timeseries/
--rw-r--r--   0 donges     (502) staff       (20)      191 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/examples/modules/timeseries/recurrence_network.py
-drwxr-xr-x   0 donges     (502) staff       (20)        0 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/examples/modules/mpi/
--rw-r--r--   0 donges     (502) staff       (20)      354 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/examples/modules/mpi/network_mc.py
--rw-r--r--   0 donges     (502) staff       (20)      244 2015-07-14 09:30:57.000000 pyunicorn-0.6.1/examples/modules/mpi/network_scan_no_comm.py
--rw-r--r--   0 donges     (502) staff       (20)      177 2018-09-07 12:05:40.000000 pyunicorn-0.6.1/examples/modules/mpi/network_large.py
--rw-r--r--   0 donges     (502) staff       (20)     1231 2019-06-20 14:28:38.000000 pyunicorn-0.6.1/tox.ini
--rw-r--r--   0 donges     (502) staff       (20)    13792 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/pylintrc
--rw-r--r--   0 donges     (502) staff       (20)       59 2019-06-21 08:33:44.000000 pyunicorn-0.6.1/setup.cfg
--rw-r--r--   0 donges     (502) staff       (20)     6711 2019-06-21 08:12:36.000000 pyunicorn-0.6.1/README.rst
--rw-r--r--   0 donges     (502) staff       (20)     1659 2019-03-27 09:27:20.000000 pyunicorn-0.6.1/LICENSE.txt
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.256504 pyunicorn-0.7.0/
+-rw-r--r--   0 fritz      (501) staff       (20)     5952 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/CHANGELOG.rst
+-rw-r--r--   0 fritz      (501) staff       (20)     3266 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/CONTRIBUTIONS.rst
+-rw-r--r--   0 fritz      (501) staff       (20)     1659 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/LICENSE.txt
+-rw-r--r--   0 fritz      (501) staff       (20)      314 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/MANIFEST.in
+-rw-r--r--   0 fritz      (501) staff       (20)     9502 2024-02-23 14:31:20.255982 pyunicorn-0.7.0/PKG-INFO
+-rw-r--r--   0 fritz      (501) staff       (20)     6740 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/README.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.950529 pyunicorn-0.7.0/docs/
+-rwxr-xr-x   0 fritz      (501) staff       (20)      608 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/Makefile
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.969452 pyunicorn-0.7.0/docs/source/
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.975534 pyunicorn-0.7.0/docs/source/_static/
+-rw-r--r--   0 fritz      (501) staff       (20)     8170 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/_static/default.css
+-rw-r--r--   0 fritz      (501) staff       (20)    14027 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/_static/logo.png
+-rw-r--r--   0 fritz      (501) staff       (20)   299147 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/_static/logo.psd
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.982437 pyunicorn-0.7.0/docs/source/_templates/
+-rw-r--r--   0 fritz      (501) staff       (20)      462 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/docs/source/_templates/layout.html
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.913235 pyunicorn-0.7.0/docs/source/api/
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.004821 pyunicorn-0.7.0/docs/source/api/climate/
+-rw-r--r--   0 fritz      (501) staff       (20)      212 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/climate_data.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      221 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/climate_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      253 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/coupled_climate_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      226 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/coupled_tsonis.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      194 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/havlin.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      197 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/hilbert.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      270 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/api/climate/map_plots.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      209 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/mutual_info.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      233 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/partial_correlation.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      200 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/rainfall.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      200 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/spearman.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      194 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/climate/tsonis.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.014432 pyunicorn-0.7.0/docs/source/api/core/
+-rw-r--r--   0 fritz      (501) staff       (20)      248 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/data.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      260 2023-12-05 14:52:41.000000 pyunicorn-0.7.0/docs/source/api/core/geo_grid.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      269 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/geo_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      248 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/grid.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      296 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/interacting_networks.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      243 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/netcdf_dictionary.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      223 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      219 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/core/resistive_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      281 2023-12-05 14:52:41.000000 pyunicorn-0.7.0/docs/source/api/core/spatial_network.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.015318 pyunicorn-0.7.0/docs/source/api/eventseries/
+-rw-r--r--   0 fritz      (501) staff       (20)      249 2023-12-05 14:52:41.000000 pyunicorn-0.7.0/docs/source/api/eventseries/event_series.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.020940 pyunicorn-0.7.0/docs/source/api/funcnet/
+-rw-r--r--   0 fritz      (501) staff       (20)      296 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/funcnet/coupling_analysis.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      332 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/funcnet/coupling_analysis_pure_python.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.028968 pyunicorn-0.7.0/docs/source/api/timeseries/
+-rw-r--r--   0 fritz      (501) staff       (20)      283 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/cross_recurrence_plot.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      313 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/inter_system_recurrence_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      292 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/joint_recurrence_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      283 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/joint_recurrence_plot.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      274 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/recurrence_network.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      265 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/recurrence_plot.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      276 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/surrogates.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      268 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/timeseries/visibility_graph.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.030640 pyunicorn-0.7.0/docs/source/api/utils/
+-rw-r--r--   0 fritz      (501) staff       (20)      183 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/utils/mpi.rst
+-rw-r--r--   0 fritz      (501) staff       (20)       33 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api/utils/navigator.rst
+-rw-r--r--   0 fritz      (501) staff       (20)     1279 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/docs/source/api_doc.rst
+-rw-r--r--   0 fritz      (501) staff       (20)       33 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/docs/source/changelog.rst
+-rw-r--r--   0 fritz      (501) staff       (20)     5883 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/docs/source/conf.py
+-rw-r--r--   0 fritz      (501) staff       (20)      182 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/contact.rst
+-rw-r--r--   0 fritz      (501) staff       (20)       85 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/development.rst
+-rw-r--r--   0 fritz      (501) staff       (20)       99 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/download.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      394 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/index.rst
+-rw-r--r--   0 fritz      (501) staff       (20)       55 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/license.rst
+-rw-r--r--   0 fritz      (501) staff       (20)     5618 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/methods.rst
+-rw-r--r--   0 fritz      (501) staff       (20)    22970 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/docs/source/publications.rst
+-rw-r--r--   0 fritz      (501) staff       (20)      181 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/sitemap.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.035232 pyunicorn-0.7.0/docs/source/tutorials/
+-rw-r--r--   0 fritz      (501) staff       (20)      130 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/tutorials/ClimateNetworks.nblink
+-rw-r--r--   0 fritz      (501) staff       (20)      137 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/tutorials/CoupledClimateNetworks.nblink
+-rw-r--r--   0 fritz      (501) staff       (20)      134 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/tutorials/EventSeriesAnalysis.nblink
+-rw-r--r--   0 fritz      (501) staff       (20)      133 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/tutorials/RecurrenceNetworks.nblink
+-rw-r--r--   0 fritz      (501) staff       (20)      131 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/tutorials/VisibilityGraphs.nblink
+-rw-r--r--   0 fritz      (501) staff       (20)      417 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/docs/source/tutorials.rst
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.915548 pyunicorn-0.7.0/examples/
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.915222 pyunicorn-0.7.0/examples/modules/
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.044998 pyunicorn-0.7.0/examples/modules/mpi/
+-rw-r--r--   0 fritz      (501) staff       (20)      177 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/examples/modules/mpi/network_large.py
+-rw-r--r--   0 fritz      (501) staff       (20)      354 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/examples/modules/mpi/network_mc.py
+-rw-r--r--   0 fritz      (501) staff       (20)      244 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/examples/modules/mpi/network_scan_no_comm.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.046466 pyunicorn-0.7.0/examples/modules/timeseries/
+-rw-r--r--   0 fritz      (501) staff       (20)      191 2023-05-05 09:08:57.000000 pyunicorn-0.7.0/examples/modules/timeseries/recurrence_network.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.070913 pyunicorn-0.7.0/examples/tutorials/
+-rw-r--r--   0 fritz      (501) staff       (20)   223163 2024-02-23 14:05:57.000000 pyunicorn-0.7.0/examples/tutorials/ClimateNetworks.ipynb
+-rw-r--r--   0 fritz      (501) staff       (20)   299196 2024-02-23 13:52:11.000000 pyunicorn-0.7.0/examples/tutorials/CoupledClimateNetworks.ipynb
+-rw-r--r--   0 fritz      (501) staff       (20)    21337 2024-02-23 13:14:35.000000 pyunicorn-0.7.0/examples/tutorials/EventSeriesAnalysis.ipynb
+-rw-r--r--   0 fritz      (501) staff       (20)   565551 2024-02-23 14:20:27.000000 pyunicorn-0.7.0/examples/tutorials/RecurrenceNetworks.ipynb
+-rw-r--r--   0 fritz      (501) staff       (20)   814386 2024-02-23 13:28:08.000000 pyunicorn-0.7.0/examples/tutorials/VisibilityGraphs.ipynb
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.101219 pyunicorn-0.7.0/examples/tutorials/images/
+-rw-r--r--   0 fritz      (501) staff       (20)    87634 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/examples/tutorials/images/Characteristics_rP.png
+-rw-r--r--   0 fritz      (501) staff       (20)    61668 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/examples/tutorials/images/ECA.png
+-rw-r--r--   0 fritz      (501) staff       (20)    27951 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/examples/tutorials/images/EventSynchronisation.png
+-rw-r--r--   0 fritz      (501) staff       (20)   316547 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/examples/tutorials/images/HVG.png
+-rw-r--r--   0 fritz      (501) staff       (20)   129654 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/examples/tutorials/images/REcurrencePlot_v2.png
+-rw-r--r--   0 fritz      (501) staff       (20)   143544 2024-02-22 09:36:09.000000 pyunicorn-0.7.0/examples/tutorials/images/SimpleVG.png
+-rw-r--r--   0 fritz      (501) staff       (20)     2037 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/pyproject.toml
+-rw-r--r--   0 fritz      (501) staff       (20)     3118 2024-02-23 14:31:20.258562 pyunicorn-0.7.0/setup.cfg
+-rw-r--r--   0 fritz      (501) staff       (20)     1773 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/setup.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:19.916985 pyunicorn-0.7.0/src/
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.105515 pyunicorn-0.7.0/src/pyunicorn/
+-rw-r--r--   0 fritz      (501) staff       (20)      951 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/__init__.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.135446 pyunicorn-0.7.0/src/pyunicorn/climate/
+-rw-r--r--   0 fritz      (501) staff       (20)     1681 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/__init__.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.146886 pyunicorn-0.7.0/src/pyunicorn/climate/_ext/
+-rw-r--r--   0 fritz      (501) staff       (20)      654 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/_ext/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)     2688 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/_ext/numerics.pyx
+-rw-r--r--   0 fritz      (501) staff       (20)     7726 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/_ext/src_numerics.c
+-rw-r--r--   0 fritz      (501) staff       (20)    17724 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/climate_data.py
+-rw-r--r--   0 fritz      (501) staff       (20)    27309 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/climate_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)    25177 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/coupled_climate_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)     7202 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/coupled_tsonis.py
+-rw-r--r--   0 fritz      (501) staff       (20)    11178 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/eventseries_climatenetwork.py
+-rw-r--r--   0 fritz      (501) staff       (20)    11306 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/havlin.py
+-rw-r--r--   0 fritz      (501) staff       (20)     8112 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/hilbert.py
+-rw-r--r--   0 fritz      (501) staff       (20)     4125 2024-02-23 11:59:20.000000 pyunicorn-0.7.0/src/pyunicorn/climate/map_plot.py
+-rw-r--r--   0 fritz      (501) staff       (20)    10985 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/mutual_info.py
+-rw-r--r--   0 fritz      (501) staff       (20)     4670 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/partial_correlation.py
+-rw-r--r--   0 fritz      (501) staff       (20)    10444 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/rainfall.py
+-rw-r--r--   0 fritz      (501) staff       (20)     5204 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/climate/spearman.py
+-rw-r--r--   0 fritz      (501) staff       (20)    11376 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/climate/tsonis.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.168924 pyunicorn-0.7.0/src/pyunicorn/core/
+-rw-r--r--   0 fritz      (501) staff       (20)     1417 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/__init__.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.174329 pyunicorn-0.7.0/src/pyunicorn/core/_ext/
+-rw-r--r--   0 fritz      (501) staff       (20)      654 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/core/_ext/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)    33117 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/core/_ext/numerics.pyx
+-rw-r--r--   0 fritz      (501) staff       (20)     6080 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/core/_ext/src_numerics.c
+-rw-r--r--   0 fritz      (501) staff       (20)     1214 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/core/_ext/types.pxd
+-rw-r--r--   0 fritz      (501) staff       (20)     1091 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/core/_ext/types.py
+-rw-r--r--   0 fritz      (501) staff       (20)     7768 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/cache.py
+-rw-r--r--   0 fritz      (501) staff       (20)    28272 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/data.py
+-rw-r--r--   0 fritz      (501) staff       (20)    18503 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/geo_grid.py
+-rw-r--r--   0 fritz      (501) staff       (20)    42697 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/geo_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)    13190 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/grid.py
+-rw-r--r--   0 fritz      (501) staff       (20)    74612 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/interacting_networks.py
+-rw-r--r--   0 fritz      (501) staff       (20)     9783 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/core/netcdf_dictionary.py
+-rw-r--r--   0 fritz      (501) staff       (20)   196921 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/network.py
+-rw-r--r--   0 fritz      (501) staff       (20)    29491 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/src/pyunicorn/core/resistive_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)    26833 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/core/spatial_network.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.176931 pyunicorn-0.7.0/src/pyunicorn/eventseries/
+-rw-r--r--   0 fritz      (501) staff       (20)     1078 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/eventseries/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)    48924 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/eventseries/event_series.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.183004 pyunicorn-0.7.0/src/pyunicorn/funcnet/
+-rw-r--r--   0 fritz      (501) staff       (20)      842 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/funcnet/__init__.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.185806 pyunicorn-0.7.0/src/pyunicorn/funcnet/_ext/
+-rw-r--r--   0 fritz      (501) staff       (20)      654 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/funcnet/_ext/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)     8068 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/funcnet/_ext/numerics.pyx
+-rw-r--r--   0 fritz      (501) staff       (20)    28268 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/funcnet/coupling_analysis.py
+-rw-r--r--   0 fritz      (501) staff       (20)    27304 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/funcnet/coupling_analysis_pure_python.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.197341 pyunicorn-0.7.0/src/pyunicorn/timeseries/
+-rw-r--r--   0 fritz      (501) staff       (20)     2228 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/__init__.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.200259 pyunicorn-0.7.0/src/pyunicorn/timeseries/_ext/
+-rw-r--r--   0 fritz      (501) staff       (20)      654 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/_ext/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)    30312 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/_ext/numerics.pyx
+-rw-r--r--   0 fritz      (501) staff       (20)     7657 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/_ext/src_numerics.c
+-rw-r--r--   0 fritz      (501) staff       (20)    13768 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/cross_recurrence_plot.py
+-rw-r--r--   0 fritz      (501) staff       (20)    15367 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/inter_system_recurrence_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)     9800 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/joint_recurrence_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)    13442 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/joint_recurrence_plot.py
+-rw-r--r--   0 fritz      (501) staff       (20)    13922 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/recurrence_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)    55524 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/recurrence_plot.py
+-rw-r--r--   0 fritz      (501) staff       (20)    28550 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/surrogates.py
+-rw-r--r--   0 fritz      (501) staff       (20)    10666 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/timeseries/visibility_graph.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.205379 pyunicorn-0.7.0/src/pyunicorn/utils/
+-rw-r--r--   0 fritz      (501) staff       (20)      708 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/utils/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)    19746 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/utils/mpi.py
+-rw-r--r--   0 fritz      (501) staff       (20)    69002 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/utils/navigator.py
+-rw-r--r--   0 fritz      (501) staff       (20)      731 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/src/pyunicorn/version.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.248919 pyunicorn-0.7.0/src/pyunicorn.egg-info/
+-rw-r--r--   0 fritz      (501) staff       (20)     9502 2024-02-23 14:31:19.000000 pyunicorn-0.7.0/src/pyunicorn.egg-info/PKG-INFO
+-rw-r--r--   0 fritz      (501) staff       (20)     6420 2024-02-23 14:31:19.000000 pyunicorn-0.7.0/src/pyunicorn.egg-info/SOURCES.txt
+-rw-r--r--   0 fritz      (501) staff       (20)        1 2024-02-23 14:31:19.000000 pyunicorn-0.7.0/src/pyunicorn.egg-info/dependency_links.txt
+-rw-r--r--   0 fritz      (501) staff       (20)        1 2023-05-05 10:21:33.000000 pyunicorn-0.7.0/src/pyunicorn.egg-info/not-zip-safe
+-rw-r--r--   0 fritz      (501) staff       (20)      480 2024-02-23 14:31:19.000000 pyunicorn-0.7.0/src/pyunicorn.egg-info/requires.txt
+-rw-r--r--   0 fritz      (501) staff       (20)       10 2024-02-23 14:31:19.000000 pyunicorn-0.7.0/src/pyunicorn.egg-info/top_level.txt
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.209493 pyunicorn-0.7.0/tests/
+-rw-r--r--   0 fritz      (501) staff       (20)     1938 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/conftest.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.218704 pyunicorn-0.7.0/tests/test_climate/
+-rw-r--r--   0 fritz      (501) staff       (20)        0 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/tests/test_climate/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)     4293 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_climate/test_climate_data.py
+-rw-r--r--   0 fritz      (501) staff       (20)     4615 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_climate/test_climate_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)     1088 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_climate/test_coupled_climate_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)     2979 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_climate/test_eventseries_climatenetwork.py
+-rw-r--r--   0 fritz      (501) staff       (20)     1929 2024-02-23 11:59:20.000000 pyunicorn-0.7.0/tests/test_climate/test_map_plot.py
+-rw-r--r--   0 fritz      (501) staff       (20)     4142 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_climate/test_tsonis.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.240240 pyunicorn-0.7.0/tests/test_core/
+-rw-r--r--   0 fritz      (501) staff       (20)     2466 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/tests/test_core/ResistiveNetwork_utils.py
+-rw-r--r--   0 fritz      (501) staff       (20)     6367 2024-01-30 13:48:48.000000 pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-circuits.py
+-rw-r--r--   0 fritz      (501) staff       (20)     1114 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-complexInput.py
+-rw-r--r--   0 fritz      (501) staff       (20)     1979 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-cython.py
+-rw-r--r--   0 fritz      (501) staff       (20)      376 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-types.py
+-rw-r--r--   0 fritz      (501) staff       (20)        0 2023-12-05 14:52:42.000000 pyunicorn-0.7.0/tests/test_core/__init__.py
+-rw-r--r--   0 fritz      (501) staff       (20)     9364 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/tests/test_core/test_cache.py
+-rw-r--r--   0 fritz      (501) staff       (20)     5327 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_data.py
+-rw-r--r--   0 fritz      (501) staff       (20)     4450 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_geo_grid.py
+-rw-r--r--   0 fritz      (501) staff       (20)    11259 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_geo_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)     3443 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_grid.py
+-rw-r--r--   0 fritz      (501) staff       (20)    16637 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_interacting_networks.py
+-rw-r--r--   0 fritz      (501) staff       (20)    32835 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_network.py
+-rw-r--r--   0 fritz      (501) staff       (20)     6767 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_resistive_networks.py
+-rw-r--r--   0 fritz      (501) staff       (20)     3968 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_core/test_spatial_network.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.241397 pyunicorn-0.7.0/tests/test_eventseries/
+-rw-r--r--   0 fritz      (501) staff       (20)    22518 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_eventseries/test_event_series.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.243841 pyunicorn-0.7.0/tests/test_funcnet/
+-rw-r--r--   0 fritz      (501) staff       (20)     4976 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_funcnet/test_coupling_analysis.py
+-rw-r--r--   0 fritz      (501) staff       (20)     3023 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_generic.py
+drwxr-xr-x   0 fritz      (501) staff       (20)        0 2024-02-23 14:31:20.247464 pyunicorn-0.7.0/tests/test_timeseries/
+-rw-r--r--   0 fritz      (501) staff       (20)     1385 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/tests/test_timeseries/test_joint_recurrence_plot.py
+-rwxr-xr-x   0 fritz      (501) staff       (20)     9729 2024-02-23 11:32:53.000000 pyunicorn-0.7.0/tests/test_timeseries/test_recurrence_plot.py
+-rw-r--r--   0 fritz      (501) staff       (20)     8494 2024-02-23 11:34:15.000000 pyunicorn-0.7.0/tests/test_timeseries/test_timeseries.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/interacting_networks.py` & `pyunicorn-0.7.0/src/pyunicorn/core/interacting_networks.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -16,30 +13,25 @@
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for analyzing spatially embedded complex networks, handling
 multivariate data and generating time series surrogates.
 """
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
 from numpy import random
 
+from ._ext.types import to_cy, ADJ, NODE, DWEIGHT, DFIELD
 from ._ext.numerics import _randomlySetCrossLinks, _randomlyRewireCrossLinks, \
     _cross_transitivity, _nsi_cross_transitivity, _cross_local_clustering, \
     _nsi_cross_local_clustering
 
-#  Import Network base class
 from .network import Network, NetworkError
 
 
-#
-#  Define class InteractingNetworks
-#
-
 class InteractingNetworks(Network):
 
     """
     Encapsulates an ensemble of interacting networks.
 
     Provides measures to analyze the interaction topology of different pairs of
     subnetworks (groups of vertices).
@@ -69,15 +61,14 @@
             as directed. If False, adjacency must be symmetric.
         :type node_weights: 1d numpy array or list [node] of floats >= 0
         :arg  node_weights: Optional array or list of node weights to be used
             for node splitting invariant network measures.  Entry [i] is the
             weight of node i.  (Default: list of ones)
         :arg int silence_level: The inverse level of verbosity of the object.
         """
-        #  Call constructor of parent class Network
         Network.__init__(self, adjacency=adjacency, directed=directed,
                          node_weights=node_weights,
                          silence_level=silence_level)
 
     def __str__(self):
         """
         Return a string representation of InteractingNetworks object.
@@ -172,20 +163,20 @@
             subnetwork
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :rtype:  :class:`InteractingNetworks`
         :return: The initial InteractingNetworks with random cross links
         """
         #  store node lists as arrays
-        nodes1 = np.array(node_list1, dtype=int)
-        nodes2 = np.array(node_list2, dtype=int)
+        nodes1 = np.array(node_list1, dtype=NODE)
+        nodes2 = np.array(node_list2, dtype=NODE)
         #  retrieve number of nodes
         N1, N2 = len(nodes1), len(nodes2)
         #  retrieve cross adjacency matrix
-        cross_A = network.cross_adjacency(nodes1, nodes2).astype(int)
+        cross_A = network.cross_adjacency(nodes1, nodes2).astype(ADJ)
 
         #  determine number of cross links
         if cross_link_density is not None:
             number_cross_links = int(cross_link_density * (N1 * N2))
             print("Setting number of cross links according to "
                   "chosen link density.")
         elif cross_link_density is None and number_cross_links is None:
@@ -194,17 +185,17 @@
         #  else: take the explicitly chosen number of cross links
         if number_cross_links > (N1 * N2):
             print("The number of cross links exceeds maximum.")
             print("Setting link density of initial interacting network.")
             number_cross_links = int(cross_A.sum())
 
         #  retrieve adjacency matrix of the full interacting network
-        A_new = network.adjacency.astype(int)
+        A_new = network.adjacency.astype(ADJ)
         #  create new empty cross adjacency matrix
-        cross_A_new = np.zeros((N1, N2))
+        cross_A_new = np.zeros((N1, N2), dtype=ADJ)
 
         _randomlySetCrossLinks(A_new, cross_A_new, number_cross_links,
                                nodes1, nodes2, N1, N2)
         return InteractingNetworks(adjacency=A_new,
                                    directed=network.directed,
                                    node_weights=network.node_weights,
                                    silence_level=network.silence_level)
@@ -343,26 +334,26 @@
         :arg float internal: Gives the fraction number_swaps /
             number_cross_links.
         :rtype:  :class:`InteractingNetworks`
         :return: The initial InteractingNetworks with swapped cross links
         """
         #  retrieve cross adjacency matrix of the considered interacting
         #  network
-        cross_A = network.cross_adjacency(node_list1, node_list2).astype(int)
+        cross_A = network.cross_adjacency(node_list1, node_list2).astype(ADJ)
         #  determine number of cross links
-        number_cross_links = int(cross_A.sum())
+        number_cross_links = cross_A.sum()
         #  Store node lists as arrays
-        nodes1 = np.array(node_list1, dtype=int)
-        nodes2 = np.array(node_list2, dtype=int)
+        nodes1 = np.array(node_list1, dtype=NODE)
+        nodes2 = np.array(node_list2, dtype=NODE)
         #  retrieve adjacency matrix of the full interacting network
-        A_new = network.adjacency.astype(int)
+        A_new = network.adjacency.astype(ADJ)
         #  determine number of cross link permutations that will be performed
-        number_swaps = int(swaps * number_cross_links)
+        number_swaps = NODE(swaps * number_cross_links)
         #  Create list of cross links
-        cross_links = np.array(cross_A.nonzero()).transpose()
+        cross_links = np.array(cross_A.nonzero(), dtype=NODE).transpose()
 
         _randomlyRewireCrossLinks(A_new, cross_A, cross_links, nodes1, nodes2,
                                   number_cross_links, number_swaps)
         return InteractingNetworks(adjacency=A_new,
                                    directed=network.directed,
                                    node_weights=network.node_weights,
                                    silence_level=network.silence_level)
@@ -620,14 +611,35 @@
             subnetworks.
         """
         if self.directed:
             raise NetworkError("Not implemented yet...")
 
         return self.cross_adjacency(node_list1, node_list2).sum()
 
+    def total_cross_degree(self, node_list1, node_list2):
+        """
+        Return the total cross degree of the two subnetworks.
+
+        **Examples:**
+
+        >>> InteractingNetworks.SmallTestNetwork().\
+                toal_cross_degree([0,3,5], [1,2,4])
+        1.0
+        >>> InteractingNetworks.SmallTestNetwork().\
+                total_cross_degree([0,5], [1,2,3,4]).round(4)
+        0.6667
+
+        :arg [int] node_list1: list of node indices describing the first
+            subnetwork
+        :arg [int] node_list2: list of node indices describing the second
+            subnetwork
+        :return int: the total cross degree.
+        """
+        return np.mean(self.cross_degree(node_list1, node_list2))
+
     def number_internal_links(self, node_list):
         """
         Return the number of links within an induced subnetwork.
 
         **Examples:**
 
         >>> InteractingNetworks.SmallTestNetwork().\
@@ -642,14 +654,39 @@
         """
         n_links = self.internal_adjacency(node_list).sum()
         if self.directed:
             return n_links
         else:
             return n_links // 2
 
+    def cross_degree_density(self, node_list1, node_list2):
+        """
+        Return the density of degrees, i.e., the cross degree sequence of the
+        first subnetwork normalized to the number of nodes in the second
+        subnetwork
+
+        **Example:**
+
+        >>> InteractingNetworks.SmallTestNetwork().\
+                cross_degree_density([0,3,5], [1,2,4])
+        array([0.33333333, 0.33333333, 0.        ])
+
+        :arg [int] node_list1: list of node indices describing the first
+                               subnetwork
+
+        :arg [int] node_list2: list of node indices describing the second
+                               subnetwork
+
+        :rtype: 1D array [node index]
+        :return: the cross degree sequence.
+        """
+
+        N2 = len(node_list2)
+        return self.cross_degree(node_list1, node_list2) / N2
+
     def cross_link_density(self, node_list1, node_list2):
         """
         Return the density of links between two subnetworks.
 
         **Examples:**
 
         >>> r(InteractingNetworks.SmallTestNetwork().\
@@ -685,15 +722,15 @@
                 internal_link_density([1,2,3,4]))
         0.6667
 
         :arg [int] node_list: list of node indices describing the subnetwork
         :return float: the density of links within a subnetwork.
         """
         N = len(node_list)
-        n_links = self.number_internal_links(node_list)
+        n_links = InteractingNetworks.number_internal_links(self, node_list)
         if self.directed:
             return float(n_links) / (N * (N - 1))
         else:
             return 2 * float(n_links) / (N * (N - 1))
 
     def internal_global_clustering(self, node_list):
         """
@@ -754,15 +791,16 @@
             subnetwork
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :return float: the cross global clustering coefficient for a pair of
             subnetworks.
         """
         #  Get cross local clustering sequences
-        cc = self.cross_local_clustering(node_list1, node_list2)
+        cc = InteractingNetworks.cross_local_clustering(self,
+                                                        node_list1, node_list2)
         return cc.mean()
 
     def cross_global_clustering_sparse(self, node_list1, node_list2):
         """
         Return global cross clustering for a pair of subnetworks.
 
         The global cross clustering coefficient C_v gives the average
@@ -819,16 +857,17 @@
 
         :arg [int] node_list1: list of node indices describing the first
             subnetwork
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :return float: the cross transitivity for a pair of subnetworks.
         """
-        return _cross_transitivity(self.adjacency.astype(int),
-                                   np.array(node_list1), np.array(node_list2))
+        return _cross_transitivity(
+            to_cy(self.adjacency, ADJ),
+            np.array(node_list1, dtype=NODE), np.array(node_list2, dtype=NODE))
 
     def cross_transitivity_sparse(self, node_list1, node_list2):
         """
         Return cross transitivity for a pair of subnetworks.
 
         The cross transitivity is the probability, that two randomly drawn
         neighbors in subnetwork 2 of node v in subnetwork 1 are also
@@ -941,18 +980,19 @@
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :arg str link_attribute: Optional name of the link attribute to be used
             as the links' length. If None, links have length 1. (Default: None)
         :return float: the cross average path length between a pair of
             subnetworks.
         """
-        path_lengths = self.cross_path_lengths(node_list1, node_list2,
-                                               link_attribute)
-        return self._calculate_general_average_path_length(path_lengths,
-                                                           internal=False)
+        path_lengths = InteractingNetworks.cross_path_lengths(
+            self, node_list1, node_list2, link_attribute)
+
+        return self._calculate_general_average_path_length(
+            path_lengths, internal=False)
 
     def internal_average_path_length(self, node_list, link_attribute=None):
         """
         Return internal average path length for an induced subnetwork.
 
         Return the average (weighted) shortest path length between all pairs
         of nodes within a subnetwork separately for which a path exists. Paths
@@ -982,14 +1022,58 @@
             as the links' length. If None, links have length 1. (Default: None)
         :return float: the internal average path length.
         """
         path_lengths = self.internal_path_lengths(node_list, link_attribute)
         return self._calculate_general_average_path_length(path_lengths,
                                                            internal=True)
 
+    def average_cross_closeness(self, node_list1, node_list2,
+                                link_attribute=None):
+        """
+        Return the average cross closeness.
+
+        **Example:**
+
+        >>> r(InteractingNetworks.SmallTestNetwork().\
+                average_cross_closeness([0,5], [1,2,3,4]))
+        1.7143
+
+        :arg [int] node_list1: list of node indices describing the first
+            subnetwork
+        :arg [int] node_list2: list of node indices describing the second
+            subnetwork
+        :arg str link_attribute: Optional name of the link attribute to be used
+            as the links' length. If None, links have length 1. (Default: None)
+        :return float: the average cross closeness.
+        """
+        return np.mean(self.cross_closeness(node_list1, node_list2,
+                                            link_attribute))
+
+    def global_efficiency(self, node_list1, node_list2, link_attribute=None):
+        """
+        Return the global efficiency.
+
+        **Example:**
+
+        >>> r(InteractingNetworks.SmallTestNetwork().\
+                global_efficiency([0,5], [1,2,3,4]))
+        1.7143
+
+        :arg [int] node_list1: list of node indices describing the first
+            subnetwork
+        :arg [int] node_list2: list of node indices describing the second
+            subnetwork
+        :arg str link_attribute: Optional name of the link attribute to be used
+            as the links' length. If None, links have length 1. (Default: None)
+        :return float: the global efficiency.
+        """
+        local_efficiency = self.local_efficiency(node_list1, node_list2,
+                                                 link_attribute)
+        return 1/np.mean(local_efficiency)
+
     #
     #  Define local measures for interacting networks
     #
 
     def cross_degree(self, node_list1, node_list2, link_attribute=None):
         """
         Return the cross degree sequence for one subnetwork with respect to a
@@ -1187,23 +1271,25 @@
         :arg [int] node_list1: list of node indices describing the first
             subnetwork
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :rtype: 1D array [node index]
         :return: the cross local clustering coefficient.
         """
-        nodes1, nodes2 = np.array(node_list1), np.array(node_list2)
+        nodes1 = np.array(node_list1, dtype=NODE)
+        nodes2 = np.array(node_list2, dtype=NODE)
         #  Get cross degree sequence
-        cross_degree = self.cross_degree(nodes1, nodes2)
+        cross_degree = InteractingNetworks.cross_degree(self, nodes1, nodes2)
         #  Prepare normalization factor
         norm = cross_degree * (cross_degree - 1) / 2.
         #  Initialize
-        cross_clustering = np.zeros_like(nodes1, dtype=np.float)
+        cross_clustering = np.zeros_like(nodes1, dtype=DFIELD)
 
-        _cross_local_clustering(self.adjacency.astype(int), norm,
+        _cross_local_clustering(to_cy(self.adjacency, ADJ),
+                                to_cy(norm, DFIELD),
                                 nodes1, nodes2, cross_clustering)
         return cross_clustering
 
     def cross_local_clustering_sparse(self, node_list1, node_list2):
         """
         Return local cross clustering for a pair of subnetworks.
 
@@ -1327,16 +1413,17 @@
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :arg str link_attribute: Optional name of the link attribute to be used
             as the links' length. If None, links have length 1. (Default: None)
         :rtype: 1D arrays [index]
         :return: the cross closeness sequence.
         """
-        path_lengths = self.cross_path_lengths(node_list1, node_list2,
-                                               link_attribute)
+        path_lengths = InteractingNetworks.cross_path_lengths(
+            self, node_list1, node_list2, link_attribute)
+
         return self._calculate_general_closeness(path_lengths, internal=False)
 
     def internal_closeness(self, node_list, link_attribute=None):
         """
         Return internal closeness sequence for an induced subnetwork.
 
         Gives the inverse average geodesic distance from a node to all other
@@ -1375,15 +1462,14 @@
         Gives the normalized number of shortest paths only between nodes from
         **two** subnetworks, in which a node :math:`i` is contained. This is
         equivalent to the inter-regional / inter-group betweenness with respect
         to subnetwork 1 and subnetwork 2.
 
         **Examples:**
 
-        >>> _i()
         >>> InteractingNetworks.SmallTestNetwork().\
                 cross_betweenness([2], [3,5])
         array([ 1.,  1.,  0.,  0.,  1.,  0.])
         >>> InteractingNetworks.SmallTestNetwork().\
                 cross_betweenness(range(0,6), range(0,6))
         array([ 9.,  3.,  0.,  2.,  6.,  0.])
 
@@ -1416,14 +1502,37 @@
         :arg [int] node_list: list of node indices describing the subnetwork
         :rtype: 1D array [node index]
         :return: the internal betweenness sequence for layer 1.
         """
         return self.interregional_betweenness(sources=node_list,
                                               targets=node_list)
 
+    def local_efficiency(self, node_list1, node_list2, link_attribute=None):
+        """
+        Return the local efficiency sequence for an induced subnetwork.
+
+        **Example:**
+
+        >>> InteractingNetworks.SmallTestNetwork().\
+                local_efficiency([0,5], [1,2,3,4])
+        array([0.75      , 0.41666667])
+
+        :arg [int] node_list1: list of node indices describing the first
+            subnetwork
+        :arg [int] node_list2: list of node indices describing the second
+            subnetwork
+        :arg str link_attribute: Optional name of the link attribute to be used
+            as the links' length. If None, links have length 1. (Default: None)
+        :rtype: 1D arrays [index]
+        :return: the local efficiency sequence.
+        """
+        path_lengths = self.cross_path_lengths(node_list1, node_list2,
+                                               link_attribute)
+        return np.mean(1/path_lengths, axis=1)
+
     def nsi_cross_degree(self, node_list1, node_list2):
         """
         Return the n.s.i. cross-degree for a pair of induced subnetworks.
 
         Gives an estimation about the quota of the whole domain of interest of
         the subnetwork 2 any node in the subnetwork 1 is connected to.
 
@@ -1501,20 +1610,20 @@
         array([ 1.,  1.,  0.])
 
         :arg [int] node_list1: list of node indices describing the subnetwork 1
         :arg [int] node_list2: list of node indices describing the subnetwork 2
         :rtype: 1D array [node index]
         :return: the n.s.i. cross-local clustering coefficient for layer 1.
         """
-        nodes1 = np.array(node_list1, dtype=int)
-        nodes2 = np.array(node_list2, dtype=int)
-        nsi_cc = np.zeros(nodes1.shape, dtype=np.float)
+        nodes1 = np.array(node_list1, dtype=NODE)
+        nodes2 = np.array(node_list2, dtype=NODE)
+        nsi_cc = np.zeros(nodes1.shape, dtype=DFIELD)
         _nsi_cross_local_clustering(
-            self.adjacency + np.eye(self.N, dtype=int),
-            nsi_cc, nodes1, nodes2, self.node_weights)
+            to_cy(self.adjacency + np.eye(self.N, dtype=ADJ), ADJ),
+            nsi_cc, nodes1, nodes2, to_cy(self.node_weights, DWEIGHT))
 
         norm = self.nsi_cross_degree(nodes1, nodes2) ** 2
         nsi_cc[norm != 0] = nsi_cc[norm != 0] / norm[norm != 0]
         nsi_cc[norm == 0] = 0
         return nsi_cc
 
     def nsi_cross_closeness_centrality(self, node_list1, node_list2):
@@ -1676,16 +1785,18 @@
             subnetwork
         :arg [int] node_list2: list of node indices describing the second
             subnetwork
         :return float: the n.s.i. cross transitivity for a pair of subnetworks
             1 and 2.
         """
         return _nsi_cross_transitivity(
-            self.adjacency + np.eye(self.N, dtype=int),
-            np.array(node_list1), np.array(node_list2), self.node_weights)
+            to_cy(self.adjacency + np.eye(self.N, dtype=ADJ), ADJ),
+            np.array(node_list1, dtype=NODE),
+            np.array(node_list2, dtype=NODE),
+            to_cy(self.node_weights, DWEIGHT))
 
     def nsi_cross_average_path_length(self, node_list1, node_list2):
         """
         Return n.s.i. cross average path length between two induced
         subnetworks.
 
         **Examples:**
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/grid.py` & `pyunicorn-0.7.0/src/pyunicorn/core/geo_grid.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,154 +1,93 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
-Provides classes for analyzing spatially embedded complex networks, handling
-multivariate data and generating time series surrogates.
+Provides class for horizontal two-dimensional spatio-temporal grid.
 """
 
-#
-#  Import essential packages
-#
-
-#  Import pickle for loading and saving Python objects
-import pickle
+from typing import Tuple
+from collections.abc import Hashable
 
-#  array object and fast numerics
 import numpy as np
-
 # Import package to calculate points inside a polygon
 try:
     from matplotlib import path
 except ImportError:
     print("An error occurred when importing matplotlib.path! "
-          "Some functionality in Grid class might not be available.")
-
-#  Cythonized functions
-from ._ext.numerics import _cy_calculate_angular_distance, _euclidean_distance
-
-#
-#  Define class Grid
-#
+          "Some functionality in GeoGrid class might not be available.")
 
+from ._ext.types import to_cy, FIELD
+from ._ext.numerics import _calculate_angular_distance
+from .cache import Cached
+from .grid import Grid
 
-class Grid:
 
+class GeoGrid(Grid):
     """
-    Encapsulates a horizontal spatio-temporal grid on the sphere.
+    Encapsulates a horizontal two-dimensional spatio-temporal grid on the
+    sphere.
 
     The spatial grid points can be arbitrarily distributed, which is useful
     for representing station data or geodesic grids.
     """
 
     #
     #  Definitions of internal methods
     #
 
-    def __init__(self, time_seq, lat_seq, lon_seq, silence_level=0):
+    def __init__(self, time_seq: np.ndarray,
+                 lat_seq: np.ndarray, lon_seq: np.ndarray,
+                 silence_level: int = 0):
         """
-        Initialize an instance of Grid.
+        Initialize an instance of GeoGrid.
 
         :type time_seq: 1D Numpy array [time]
         :arg time_seq: The increasing sequence of temporal sampling points.
 
         :type lat_seq: 1D Numpy array [index]
         :arg lat_seq: The sequence of latitudinal sampling points.
 
         :type lon_seq: 1D Numpy array [index]
         :arg lon_seq: The sequence of longitudinal sampling points.
 
         :type silence_level: number (int)
         :arg silence_level: The inverse level of verbosity of the object.
         """
-        #  Set basic dictionaries
-        self._grid = {"time": time_seq.astype("float32"),
-                      "lat": lat_seq.astype("float32"),
-                      "lon": lon_seq.astype("float32")}
-        self._grid_size = {"time": len(time_seq),
-                           "space": len(lat_seq)}
-        self._boundaries = {"time_min": time_seq.min(),
-                            "time_max": time_seq.max(),
-                            "lat_min": lat_seq.min(),
-                            "lat_max": lat_seq.max(),
-                            "lon_min": lon_seq.min(),
-                            "lon_max": lon_seq.max()}
-
-        #  Set silence level
-        self.silence_level = silence_level
-        """(number (int)) - The inverse level of verbosity of the object."""
-
-        #  Defines the number of spatial grid points / nodes at one instant
-        #  of time
-        self.N = self._grid_size["space"]
-        """(number (int)) - The number of spatial grid points / nodes."""
-
-        #  Defines the total number of data points / grid points / samples of
-        #  the corresponding data set.
-        self.n_grid_points = self._grid_size["time"] * self.N
-        """(number (int)) - The total number of data points / samples."""
-
-        #  Cache
-        self._angular_distance = None
-        self._angular_distance_cached = False
+        Grid.__init__(self, time_seq, np.vstack((lat_seq, lon_seq)),
+                      silence_level)
 
-    def __str__(self):
-        """
-        Return a string representation of the Grid object.
-        """
-        return 'Grid: %i grid points, %i timesteps.' % (
-            self._grid_size['space'], self._grid_size['time'])
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return Grid.__cache_state__(self)
 
-    def clear_cache(self):
+    def __str__(self):
         """
-        Clean up cache.
-
-        Is reversible, since all cached information can be recalculated from
-        basic data.
+        Return a string representation of the GeoGrid object.
         """
-        if self._angular_distance_cached:
-            del self._angular_distance
-            self._angular_distance_cached = False
+        return (f"GeoGrid: {self._grid_size['space']} grid points, "
+                f"{self._grid_size['time']} timesteps.")
 
     #
     #  Functions for loading and saving the Grid object
     #
 
-    def save(self, filename):
-        """
-        Save the Grid object to a pickle file.
-
-        :arg str filename: The name of the file where Grid object is stored
-            (including ending).
-        """
-        try:
-            f = open(filename, 'w')
-            pickle.dump(self, f)
-            f.close()
-        except IOError:
-            print("An error occurred while saving Grid instance to "
-                  f"pickle file {filename}")
-
     def save_txt(self, filename):
         """
-        Save the Grid object to text files.
+        Save the GeoGrid object to text files.
 
         The latitude, longitude and time sequences are stored in three separate
         text files.
 
         :arg str filename: The name of the files where Grid object is stored
             (excluding ending).
         """
@@ -163,192 +102,168 @@
             np.savetxt(filename + "_lon.txt", lon_seq)
             np.savetxt(filename + "_time.txt", time_seq)
         except IOError:
             print("An error occurred while saving Grid instance to "
                   f"text files {filename}")
 
     @staticmethod
-    def Load(filename):
-        """
-        Return a Grid object stored in a pickle file.
-
-        :arg str filename: The name of the file where Grid object is stored
-            (including ending).
-        :rtype: Grid object
-        :return: :class:`Grid` instance.
-        """
-        try:
-            f = open(filename, 'r')
-            grid = pickle.load(f)
-            f.close()
-
-            return grid
-        except IOError:
-            print("An error occurred while loading Grid instance from "
-                  f"pickle file {filename}")
-
-    @staticmethod
     def LoadTXT(filename):
         """
-        Return a Grid object stored in text files.
+        Return a GeoGrid object stored in text files.
 
         The latitude, longitude and time sequences are loaded from three
         separate text files.
 
-        :arg str filename: The name of the files where Grid object is stored
-            (excluding endings).
+        :arg str filename: The name of the files where the GeoGrid object is
+            stored (excluding endings).
         :rtype: Grid object
-        :return: :class:`Grid` instance.
+        :return: :class:`GeoGrid` instance.
         """
         try:
             lat_seq = np.loadtxt(filename + "_lat.txt")
             lon_seq = np.loadtxt(filename + "_lon.txt")
             time_seq = np.loadtxt(filename + "_time.txt")
         except IOError:
             print("An error occurred while loading Grid instance from "
                   f"text files {filename}")
 
-        return Grid(time_seq, lat_seq, lon_seq)
+        return GeoGrid(time_seq, lat_seq, lon_seq)
 
     #
     #  Alternative constructors and Grid generation methods
     #
 
     @staticmethod
     def SmallTestGrid():
         """
         Return test grid of 6 spatial grid points with 10 temporal sampling
         points each.
 
-        :rtype: Grid instance
-        :return: a Grid instance for testing purposes.
+        :rtype: GeoGrid instance
+        :return: a GeoGrid instance for testing purposes.
         """
-        return Grid(time_seq=np.arange(10),
-                    lat_seq=np.array([0, 5, 10, 15, 20, 25]),
-                    lon_seq=np.array([2.5, 5., 7.5, 10., 12.5, 15.]),
-                    silence_level=2)
+        return GeoGrid(time_seq=np.arange(10),
+                       lat_seq=np.array([0, 5, 10, 15, 20, 25]),
+                       lon_seq=np.array([2.5, 5., 7.5, 10., 12.5, 15.]),
+                       silence_level=2)
 
     @staticmethod
-    def RegularGrid(time_seq, lat_grid, lon_grid, silence_level=0):
+    def RegularGrid(time_seq, space_grid, silence_level=0):
         """
         Initialize an instance of a regular grid.
 
         **Examples:**
 
-        >>> Grid.RegularGrid(
-        ...     time_seq=np.arange(2), lat_grid=np.array([0.,5.]),
-        ...     lon_grid=np.array([1.,2.]), silence_level=2).lat_sequence()
+        >>> GeoGrid.RegularGrid(
+        ...      time_seq=np.arange(2),
+        ...      space_grid=(np.array([0.,5.]),
+        ...                  np.array([1.,2.])),
+        ...      silence_level=2).lat_sequence()
         array([ 0.,  0.,  5.,  5.], dtype=float32)
-        >>> Grid.RegularGrid(
-        ...     time_seq=np.arange(2), lat_grid=np.array([0.,5.]),
-        ...     lon_grid=np.array([1.,2.]), silence_level=2).lon_sequence()
+        >>> GeoGrid.RegularGrid(
+        ...      time_seq=np.arange(2),
+        ...      space_grid=(np.array([0.,5.]),
+        ...                  np.array([1.,2.])),
+        ...      silence_level=2).lon_sequence()
         array([ 1.,  2.,  1.,  2.], dtype=float32)
 
         :type time_seq: 1D Numpy array [time]
         :arg time_seq: The increasing sequence of temporal sampling points.
-
-        :type lat_grid: 1D Numpy array [n_lat]
-        :arg lat_grid: The latitudinal grid.
-
-        :type lon_grid: 1D Numpy array [n_lon]
-        :arg lon_grid: The longitudinal grid.
-
+        :type space_grid: tuple or list of two 1D Numpy arrays
+            ([n_lat], [n_lon])
+        :arg space_grid: The spatial grid, consisting of the latitudinal
+            and the longitudinal grid.
         :type silence_level: number (int)
         :arg silence_level: The inverse level of verbosity of the object.
 
-        :rtype: Grid object
-        :return: :class:`Grid` instance.
+        :rtype: GeoGrid object
+        :return: :class:`GeoGrid` instance.
         """
+        try:
+            (lat_grid, lon_grid) = space_grid
+        except ValueError as e:
+            raise ValueError("'space_grid' must be a tuple or list of two "
+                             "items: lat_grid, lon_grid") from e
+
         #  Generate sequence of latitudes and longitudes for all nodes
-        lat_seq, lon_seq = Grid.coord_sequence_from_rect_grid(lat_grid,
-                                                              lon_grid)
+        lat_seq, lon_seq = GeoGrid.coord_sequence_from_rect_grid(lat_grid,
+                                                                 lon_grid)
 
         #  Return instance of Grid
-        return Grid(time_seq, lat_seq, lon_seq, silence_level)
+        return GeoGrid(time_seq, lat_seq, lon_seq, silence_level)
 
     #
     #  Definitions of grid related functions
     #
 
     @staticmethod
     def coord_sequence_from_rect_grid(lat_grid, lon_grid):
         """
         Return the sequences of latitude and longitude for a regular and
         rectangular grid.
 
         **Example:**
 
-        >>> Grid.coord_sequence_from_rect_grid(
+        >>> GeoGrid.coord_sequence_from_rect_grid(
         ...     lat_grid=np.array([0.,5.]), lon_grid=np.array([1.,2.]))
         (array([ 0.,  0.,  5.,  5.]), array([ 1.,  2.,  1.,  2.]))
 
         :type lat_grid: 1D Numpy array [lat]
         :arg lat_grid: The grid's latitudinal sampling points.
 
         :type lon_grid: 1D Numpy array [lon]
         :arg lon_grid: The grid's longitudinal sampling points.
 
         :rtype: tuple of two 1D Numpy arrays [index]
         :return: the coordinates of all nodes in the grid.
         """
-        #  Get grid size
-        n_lat = len(lat_grid)
-        n_lon = len(lon_grid)
-        n = n_lat * n_lon
-
-        #  Initialize sequences
-        lat_seq = np.empty(n)
-        lon_seq = np.empty(n)
-
-        for i in range(n_lat):
-            lat_seq[i * n_lon:(i + 1) * n_lon] = lat_grid[i] * np.ones(n_lon)
-            lon_seq[i * n_lon:(i + 1) * n_lon] = lon_grid
+        space_seq = Grid.coord_sequence_from_rect_grid([lat_grid, lon_grid])
 
         #  Return results as a tuple
-        return (lat_seq, lon_seq)
+        return (space_seq[0], space_seq[1])
 
     def lat_sequence(self):
         """
         Return the sequence of latitudes for all nodes.
 
         **Example:**
 
-        >>> Grid.SmallTestGrid().lat_sequence()
+        >>> GeoGrid.SmallTestGrid().lat_sequence()
         array([  0.,   5.,  10.,  15.,  20.,  25.], dtype=float32)
 
         :rtype: 1D Numpy array [index]
         :return: the sequence of latitudes for all nodes.
         """
-        return self._grid["lat"]
+        return self.sequence(0)
 
     def lon_sequence(self):
         """
         Return the sequence of longitudes for all nodes.
 
         **Example:**
 
-        >>> Grid.SmallTestGrid().lon_sequence()
+        >>> GeoGrid.SmallTestGrid().lon_sequence()
         array([  2.5,   5. ,   7.5,  10. ,  12.5,  15. ], dtype=float32)
 
         :rtype: 1D Numpy array [index]
         :return: the sequence of longitudes for all nodes.
         """
-        return self._grid["lon"]
+        return self.sequence(1)
 
     def convert_lon_coordinates(self, lon_seq):
         """
         Return longitude coordinates in the system
         -180 deg W <= lon <= +180 deg O for all nodes.
 
         Accepts longitude coordinates in the system 0 deg <= lon <= 360 deg.
         0 deg corresponds to Greenwich, England.
 
         **Example:**
 
-        >>> Grid.SmallTestGrid().convert_lon_coordinates(
+        >>> GeoGrid.SmallTestGrid().convert_lon_coordinates(
         ...     np.array([10.,350.,20.,340.,170.,190.]))
         array([  10.,  -10.,   20.,  -20.,  170., -170.])
 
         :type lon_seq: 1D Numpy array [index]
         :arg lon_seq: Sequence of longitude coordinates.
 
         :rtype: 1D Numpy array [index]
@@ -360,52 +275,33 @@
             if lon_seq[i] > 180.:
                 new_lon_grid[i] = lon_seq[i] - 360.
             else:
                 new_lon_grid[i] = lon_seq[i]
 
         return new_lon_grid
 
-    def node_coordinates(self, index):
-        """
-        Return the geographical latitude and longitude of node ``index``.
-
-        **Example:**
-
-        >>> Grid.SmallTestGrid().node_coordinates(3)
-        (15.0, 10.0)
-
-        :type index: number (int)
-        :arg index: The node index as used in node sequences.
-
-        :rtype: tuple of number (float)
-        :return: the node's latitude and longitude coordinates.
-        """
-        lat_node = self.lat_sequence()[index]
-        lon_node = self.lon_sequence()[index]
-        return (lat_node, lon_node)
-
     def node_number(self, lat_node, lon_node):
         """
         Return the index of the closest node given geographical coordinates.
 
         **Example:**
 
-        >>> Grid.SmallTestGrid().node_number(lat_node=14., lon_node=9.)
+        >>> GeoGrid.SmallTestGrid().node_number(lat_node=14., lon_node=9.)
         3
 
         :type lat_node: number (float)
         :arg lat_node: The latitude coordinate.
 
         :type lon_node: number (float)
         :arg lon_node: The longitude coordinate.
 
         :rtype: number (int)
         :return: the closest node's index.
         """
-        #  Get sequences of cosLat, sinLat, cosLon and sinLon for all nodes
+        # Get sequences of cosLat, sinLat, cosLon and sinLon for all nodes
         cos_lat = self.cos_lat()
         sin_lat = self.sin_lat()
         cos_lon = self.cos_lon()
         sin_lon = self.sin_lon()
 
         sin_lat_v = np.sin(lat_node * np.pi / 180)
         cos_lat_v = np.cos(lat_node * np.pi / 180)
@@ -430,295 +326,206 @@
 
     def cos_lat(self):
         """
         Return the sequence of cosines of latitude for all nodes.
 
         **Example:**
 
-        >>> r(Grid.SmallTestGrid().cos_lat()[:2])
+        >>> r(GeoGrid.SmallTestGrid().cos_lat()[:2])
         array([ 1. , 0.9962])
 
         :rtype: 1D Numpy array [index]
         :return: the cosine of latitudes for all nodes.
         """
         return np.cos(self.lat_sequence() * np.pi / 180)
 
     def sin_lat(self):
         """
         Return the sequence of sines of latitude for all nodes.
 
         **Example:**
 
-        >>> r(Grid.SmallTestGrid().sin_lat()[:2])
+        >>> r(GeoGrid.SmallTestGrid().sin_lat()[:2])
         array([ 0. , 0.0872])
 
         :rtype: 1D Numpy array [index]
         :return: the sine of latitudes for all nodes.
         """
         return np.sin(self.lat_sequence() * np.pi / 180)
 
     def cos_lon(self):
         """
         Return the sequence of cosines of longitude for all nodes.
 
         **Example:**
 
-        >>> r(Grid.SmallTestGrid().cos_lon()[:2])
+        >>> r(GeoGrid.SmallTestGrid().cos_lon()[:2])
         array([ 0.999 , 0.9962])
 
         :rtype: 1D Numpy array [index]
         :return: the cosine of longitudes for all nodes.
         """
         return np.cos(self.lon_sequence() * np.pi / 180)
 
     def sin_lon(self):
         """
         Return the sequence of sines of longitude for all nodes.
 
         **Example:**
 
-        >>> r(Grid.SmallTestGrid().sin_lon()[:2])
+        >>> r(GeoGrid.SmallTestGrid().sin_lon()[:2])
         array([ 0.0436, 0.0872])
 
         :rtype: 1D Numpy array [index]
         :return: the sine of longitudes for all nodes.
         """
         return np.sin(self.lon_sequence() * np.pi / 180)
 
-    def _calculate_angular_distance(self):
+    def distance(self):
         """
-        Calculate and return the angular great circle distance matrix.
-
-        **No normalization applied anymore!** Return values are in the range
-        0 to Pi.
+        Calculate and return the standard distance matrix of the corresponding
+        grid type
 
         :rtype: 2D Numpy array [index, index]
-        :return: the angular great circle distance matrix (unit radians).
+        :return: the distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating angular great circle distance using Cython...")
-
-        #  Get number of nodes
-        N = self.N
-
-        #  Get sequences of cosLat, sinLat, cosLon and sinLon for all nodes
-        cos_lat = self.cos_lat()
-        sin_lat = self.sin_lat()
-        cos_lon = self.cos_lon()
-        sin_lon = self.sin_lon()
-
-        #  Initialize cython cof of angular distance matrix
-        cosangdist = np.zeros((N, N), dtype="float32")
-
-        _cy_calculate_angular_distance(cos_lat, sin_lat, cos_lon, sin_lon,
-                                       cosangdist, N)
-        return np.arccos(cosangdist)
+        return self.angular_distance()
 
+    @Cached.method(name="angular great circle distance")
     def angular_distance(self):
         """
-        Return the angular great circle distance matrix.
+        Calculate the angular great circle distance matrix.
 
         **No normalization applied anymore!** Return values are in the range
         0 to Pi.
 
         **Example:**
 
-        >>> rr(Grid.SmallTestGrid().angular_distance(), 2)
+        >>> rr(GeoGrid.SmallTestGrid().angular_distance(), 2)
         [['0'    '0.1'  '0.19' '0.29' '0.39' '0.48']
          ['0.1'  '0'    '0.1'  '0.19' '0.29' '0.39']
          ['0.19' '0.1'  '0'    '0.1'  '0.19' '0.29']
          ['0.29' '0.19' '0.1'  '0'    '0.1'  '0.19']
          ['0.39' '0.29' '0.19' '0.1'  '0'    '0.1']
          ['0.48' '0.39' '0.29' '0.19' '0.1'  '0']]
 
         :rtype: 2D Numpy array [index, index]
         :return: the angular great circle distance matrix.
         """
-        if not self._angular_distance_cached:
-            self._angular_distance = self._calculate_angular_distance()
-            self._angular_distance_cached = True
-
-        return self._angular_distance
-
-    def euclidean_distance(self):
-        """
-        Return the euclidean distance matrix between grid points.
-
-        So far assumes that the given latitude and longitude coordinates are
-        planar, euclidean coordinates. Approximates great circle distance well
-        for points with a separation much smaller than the Earth's radius.
-
-        :rtype: 2D Numpy array [index, index]
-        :return: the euclidean distance matrix.
-        """
         #  Get number of nodes
         N = self.N
-
-        #  Get sequences of coordinates
-        x = self.lon_sequence()
-        y = self.lat_sequence()
-
-        distance = np.zeros((N, N), dtype="float32")
-        _euclidean_distance(x, y, distance, N)
-
-        return distance
+        #  Initialize cython cof of angular distance matrix
+        cosangdist = np.zeros((N, N), dtype=FIELD)
+        _calculate_angular_distance(
+            #  Get sequences of cosLat, sinLat, cosLon and sinLon for all nodes
+            to_cy(self.cos_lat(), FIELD),
+            to_cy(self.sin_lat(), FIELD),
+            to_cy(self.cos_lon(), FIELD),
+            to_cy(self.sin_lon(), FIELD),
+            cosangdist, N)
+        return np.arccos(cosangdist)
 
     def boundaries(self):
         """
         Return the spatio-temporal grid boundaries.
 
         Structure of the returned dictionary:
-          - self._boundaries = {"time_min": time_seq.min(),
-                                "time_max": time_seq.max(),
-                                "lat_min": lat_seq.min(),
-                                "lat_max": lat_seq.max(),
-                                "lon_min": lon_seq.min(),
-                                "lon_max": lon_seq.max()}
-
-        **Example:**
-
-        >>> print(Grid.SmallTestGrid().print_boundaries())
-                 time     lat     lon
-           min    0.0    0.00    2.50
-           max    9.0   25.00   15.00
+          - boundaries = {"time_min": self._boundaries["time_min"],
+                          "time_max": self._boundaries["time_max"],
+                          "lat_min": self._boundaries["space_min"][0],
+                          "lat_max": self._boundaries["space_max"][1],
+                          "lon_min": self._boundaries["space_min"][0],
+                          "lon_max": self._boundaries["space_max"][1]}
 
         :rtype: dictionary
         :return: the spatio-temporal grid boundaries.
         """
-        return self._boundaries
+        boundaries = {"time_min": self._boundaries["time_min"],
+                      "time_max": self._boundaries["time_max"],
+                      "lat_min": self._boundaries["space_min"][0],
+                      "lat_max": self._boundaries["space_max"][0],
+                      "lon_min": self._boundaries["space_min"][1],
+                      "lon_max": self._boundaries["space_max"][1]}
+        return boundaries
 
     def print_boundaries(self):
         """
         Pretty print the spatio-temporal grid boundaries.
+
+        **Example:**
+
+        >>> print(GeoGrid.SmallTestGrid().print_boundaries())
+                 time     lat     lon
+           min    0.0    0.00    2.50
+           max    9.0   25.00   15.00
+
+        :rtype: string
+        :return: printable string for the spatio-temporal grid boundaries
         """
         return (
             "         time     lat     lon"
             "\n   min {time_min:6.1f} {lat_min: 7.2f} {lon_min: 7.2f}"
             "\n   max {time_max:6.1f} {lat_max: 7.2f} {lon_max: 7.2f}"
         ).format(**self.boundaries())
 
     def grid(self):
         """
         Return the grid's spatio-temporal sampling points.
 
         Structure of the returned dictionary:
-          - self._grid = {"time": time_seq.astype("float32"),
-                          "lat": lat_seq.astype("float32"),
-                          "lon": lon_seq.astype("float32")}
+          - grid = {"time": self._grid["time"],
+                    "lat": self._grid["space"][0],
+                    "lon": self._grid["space"][1]}
 
         **Examples:**
 
-        >>> Grid.SmallTestGrid().grid()["lat"]
+        >>> Grid.SmallTestGrid().grid()["space"][0]
         array([  0.,   5.,  10.,  15.,  20.,  25.], dtype=float32)
-        >>> Grid.SmallTestGrid().grid()["lon"][5]
+        >>> Grid.SmallTestGrid().grid()["space"][0][5]
         15.0
 
         :rtype: dictionary
         :return: the grid's spatio-temporal sampling points.
         """
-        return self._grid
-
-    def grid_size(self):
-        """
-        Return the sizes of the grid's spatial and temporal dimensions.
-
-        Structure of the returned dictionary:
-          - self._grid_size = {"time": len(time_seq),
-                               "space": len(lat_seq)}
-
-        **Example:**
-
-        >>> print(Grid.SmallTestGrid().print_grid_size())
-           space    time
-               6      10
-
-        :rtype: dictionary
-        :return: the sizes of the grid's spatial and temporal dimensions.
-        """
-        return self._grid_size
-
-    def print_grid_size(self):
-        """
-        Pretty print the sizes of the grid's spatial and temporal dimensions.
-        """
-        return "     space    time\n   {space:7} {time:7}".format(
-            **self.grid_size())
-
-    def geometric_distance_distribution(self, n_bins):
-        """
-        Return the distribution of angular great circle distances between all
-        pairs of grid points.
-
-        **Examples:**
-
-        >>> r(Grid.SmallTestGrid().geometric_distance_distribution(3)[0])
-        array([ 0.3333, 0.4667, 0.2 ])
-        >>> r(Grid.SmallTestGrid().geometric_distance_distribution(3)[1])
-        array([ 0. , 0.1616, 0.3231, 0.4847])
-
-        :type n_bins: number (int)
-        :arg n_bins: The number of histogram bins.
-
-        :rtype: tuple of two 1D Numpy arrays [bin]
-        :return: the normalized histogram and lower bin boundaries of angular
-                 great circle distances.
-        """
-        if self.silence_level <= 1:
-            print("Calculating the geometric distance distribution of the "
-                  "grid...")
-
-        #  Get angular distance matrix
-        D = self.angular_distance()
-
-        #  Determine range for link distance histograms
-        max_range = D.max()
-        interval = (0, max_range)
-
-        #  Calculate geometry related factor of distributions to divide it out
-        (dist, lbb) = np.histogram(a=D, bins=n_bins, range=interval)
-        #  Subtract self.N from first bin because of spurious links with zero
-        #  distance on the diagonal of the angular distance matrix
-        dist[0] -= self.N
-
-        #  Normalize distribution
-        dist = dist.astype("float")
-        dist /= dist.sum()
-
-        return (dist, lbb)
+        grid = {"time": self._grid["time"],
+                "lat": self._grid["space"][0],
+                "lon": self._grid["space"][1]}
+        return grid
 
     #
     #  Methods for selecting regions
     #
 
     def region_indices(self, region):
         """
         Returns a boolean array of nodes with True values when the node
         is inside the region.
 
         **Example:**
 
-        >>> Grid.SmallTestGrid().region_indices(
+        >>> GeoGrid.SmallTestGrid().region_indices(
         ...     np.array([0.,0.,0.,11.,11.,11.,11.,0.])).astype(int)
         array([0, 1, 1, 0, 0, 0])
 
         :type region: 1D Numpy array [n_polygon_nodes]
         :arg region: array of lon, lat, lon, lat, ...
                      [-80.2, 5., -82.4, 5.3, ...] as copied from Google Earth
                      Polygon file
         :rtype: 1D bool array [index]
         :return: bool array with True for nodes inside region
         """
         # Reshape Google Earth array  into (n,2) array
         remapped_region = region.reshape(len(region)//2, 2)
         # Remap from East-West to 360 degree map if the longitudes are [0, 360]
-        if self._grid["lon"].min() >= 0:
+        if self._grid["space"][1].min() >= 0:
             remapped_region[remapped_region[:, 0] < 0, 0] = \
                 360 + remapped_region[remapped_region[:, 0] < 0, 0]
 
-        lat_lon_map = np.column_stack((self._grid["lon"], self._grid["lat"]))
+        lat_lon_map = np.column_stack((self._grid["space"][1],
+                                       self._grid["space"][0]))
 
         return path.Path(remapped_region).contains_points(lat_lon_map)
 
     @staticmethod
     def region(name):
         """Return some standard regions."""
         if name == 'ENSO':
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/geo_network.py` & `pyunicorn-0.7.0/src/pyunicorn/core/geo_network.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,70 +1,59 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
-Provides classes for analyzing spatially embedded complex networks, handling
-multivariate data and generating time series surrogates.
+Provides class for analyzing complex network embedded on a spherical surface.
 """
 
-# array object and fast numerics
+from typing import Tuple
+from collections.abc import Hashable
+
 import numpy as np
-# random number generation
 from numpy import random
-# high performance graph theory tools written in pure ANSI-C
 import igraph
 
-from ._ext.numerics import _randomly_rewire_geomodel_I, \
-        _randomly_rewire_geomodel_II, _randomly_rewire_geomodel_III
-
-from .network import Network, cached_const
-from .grid import Grid
+from .spatial_network import SpatialNetwork
+from .geo_grid import GeoGrid
 
 
-#
-#  Define class ClimateNetwork
-#
-
-class GeoNetwork(Network):
-
+class GeoNetwork(SpatialNetwork):
     """
     Encapsulates a network embedded on a spherical surface.
 
     Particularly adds more network measures and statistics based on the
     spatial embedding.
 
     :ivar node_weight_type: (string) - The type of geographical node weight to
                             be used.
     """
 
     #
     #  Definitions of internal methods
     #
 
-    def __init__(self, grid, adjacency=None, edge_list=None, directed=False,
-                 node_weight_type="surface", silence_level=0):
+    def __init__(self, grid: GeoGrid, adjacency=None, edge_list=None,
+                 directed=False, node_weight_type="surface", silence_level=0):
         """
         Initialize an instance of GeoNetwork.
 
-        :type grid: :class:`.Grid`
-        :arg grid: The Grid object describing the network's spatial embedding.
+        :type grid: :class:`.GeoGrid`
+        :arg grid: The GeoGrid object describing the network's spatial
+            embedding.
         :type adjacency: 2D array (int8) [index, index]
         :arg adjacency: The network's adjacency matrix.
         :type edge_list: array-like list of lists
         :arg  edge_list: Edge list of the new network.
                          Entries [i,0], [i,1] contain the end-nodes of an edge.
         :arg bool directed: Determines, whether the network is treated as
             directed.
@@ -73,46 +62,46 @@
         :arg int silence_level: The inverse level of verbosity of the object.
 
         Possible choices for ``node_weight_type``:
           - None (constant unit weights)
           - "surface" (cos lat)
           - "irrigation" (cos² lat)
         """
-        self.grid = grid
-        """(Grid) - Grid object describing the network's spatial embedding"""
+        assert isinstance(grid, GeoGrid)
+        self.grid: GeoGrid = grid
+        """GeoGrid object describing the network's spatial embedding"""
 
         #  Call constructor of parent class Network
-        Network.__init__(self, adjacency=adjacency, edge_list=edge_list,
-                         directed=directed, silence_level=silence_level)
+        SpatialNetwork.__init__(self, grid=grid, adjacency=adjacency,
+                                edge_list=edge_list, directed=directed,
+                                silence_level=silence_level)
 
         #  Set area weights
         self.set_node_weight_type(node_weight_type)
 
         #  cartesian coordinates of nodes
         self.cartesian = None
         self.grid_neighbours = None
         self.grid_neighbours_set = None
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        # The following attributes are assumed immutable:
+        #   (grid)
+        return SpatialNetwork.__cache_state__(self)
+
+    def __rec_cache_state__(self) -> Tuple[object, ...]:
+        return (self.grid,)
+
     def __str__(self):
         """
         Return a string representation of the GeoNetwork object.
         """
-        return (f'GeoNetwork:\n{Network.__str__(self)}\n'
+        return (f'GeoNetwork:\n{SpatialNetwork.__str__(self)}\n'
                 f'Geographical boundaries:\n{self.grid.print_boundaries()}')
 
-    def clear_cache(self):
-        """
-        Clean up cache.
-
-        Is reversible, since all cached information can be recalculated from
-        basic data.
-        """
-        Network.clear_cache(self)
-        self.grid.clear_cache()
-
     def set_node_weight_type(self, node_weight_type):
         """
         Set node weights for calculation of n.s.i. measures according to
         requested type.
 
         Possible choices for ``node_weight_type``:
           - None (constant unit weights)
@@ -126,107 +115,27 @@
             print("Setting area weights according to type "
                   f"{node_weight_type} ...")
 
         #  Set instance variable accordingly
         self.node_weight_type = node_weight_type
 
         if node_weight_type == "surface":
-            self.node_weights = self.grid.cos_lat()
+            self._node_weights = self.grid.cos_lat()
         elif node_weight_type == "irrigation":
-            self.node_weights = np.square(self.grid.cos_lat())
+            self._node_weights = np.square(self.grid.cos_lat())
         #  If None or invalid choice:
         else:
-            self.node_weights = None
+            self._node_weights = None
 
     #
     #  Load and save GeoNetwork object
     #
 
-    def save(self, filename_network, filename_grid=None, fileformat=None,
-             *args, **kwds):
-        """
-        Save the GeoNetwork object to files.
-
-        Unified writing function for graphs. Relies on and partially extends
-        the corresponding igraph function. Refer to igraph documentation for
-        further details on the various writer methods for different formats.
-
-        This method tries to identify the format of the graph given in
-        the first parameter (based on extension) and calls the corresponding
-        writer method.
-
-        Existing node and link attributes/weights are also stored depending
-        on the chosen file format. E.g., the formats GraphML and gzipped
-        GraphML are able to store both node and link weights.
-
-        The grid is not stored if the corresponding filename is None.
-
-        The remaining arguments are passed to the writer method without
-        any changes.
-
-        :arg str filename_network:  The name of the file where the Network
-            object is to be stored.
-        :arg str filename_grid:  The name of the file where the Grid object is
-            to be stored (including ending).
-        :arg str fileformat: the format of the file (if one wants to override
-            the format determined from the filename extension, or the filename
-            itself is a stream). ``None`` means auto-detection.  Possible
-            values are: ``"ncol"`` (NCOL format), ``"lgl"`` (LGL format),
-            ``"graphml"``, ``"graphmlz"`` (GraphML and gzipped GraphML format),
-            ``"gml"`` (GML format), ``"dot"``, ``"graphviz"`` (DOT format, used
-            by GraphViz), ``"net"``, ``"pajek"`` (Pajek format), ``"dimacs"``
-            (DIMACS format), ``"edgelist"``, ``"edges"`` or ``"edge"`` (edge
-            list), ``"adjacency"`` (adjacency matrix), ``"pickle"`` (Python
-            pickled format), ``"svg"`` (Scalable Vector Graphics).
-        """
-        #  Store network
-        Network.save(self, filename=filename_network, fileformat=fileformat,
-                     *args, **kwds)
-
-        #  Store grid
-        if filename_grid is not None:
-            self.grid.save(filename=filename_grid)
-
-    def save_for_cgv(self, filename, fileformat="graphml"):
-        """
-        Save the GeoNetwork and its attributes for the CGV visualization
-        software.
-
-        The node coordinates are stored as node attributes by default, likewise
-        angular link distances are stored as edge attributes by default. All
-        additional node and link properties are also stored for visualization.
-
-        This format is intended for being used by the spatial graph
-        visualization software CGV developed in Rostock (contact Thomas Nocke,
-        nocke@pik-potsdam.de). By default, the file includes the latitude and
-        longitude vectors as node properties, as well as the geodesic angular
-        distance as an link property.
-
-        :arg str file_name: The file name should end with ".dot" or ".gml".
-        :arg str fileformat: The file format: "graphml"  - GraphML format
-            "graphmlz" - gzipped GraphML format
-            "graphviz" - GraphViz format
-        """
-        #  Save node coordinates as node attribute
-        self.set_node_attribute("lat", self.grid.lat_sequence())
-        self.set_node_attribute("lon", self.grid.lon_sequence())
-
-        #  Save geodesic angular distances on the sphere as link attribute
-        self.set_link_attribute("ang_dist", self.grid.angular_distance())
-
-        #  Save network, independent of filename!
-        if fileformat in ["graphml", "graphmlz", "graphviz"]:
-            self.graph.save(filename, format=fileformat)
-        else:
-            print("ERROR: the chosen format is not supported by save_for_cgv "
-                  "for use with the CGV software.")
-
     @staticmethod
-    def Load(filename_network, filename_grid, fileformat=None,
-             silence_level=0, *args, **kwds):
+    def Load(filename, fileformat=None, silence_level=0, *args, **kwds):
         """
         Return a GeoNetwork object stored in files.
 
         Unified reading function for graphs. Relies on and partially extends
         the corresponding igraph function. Refer to igraph documentation for
         further details on the various reader methods for different formats.
 
@@ -236,465 +145,139 @@
         Existing node and link attributes/weights are also restored depending
         on the chosen file format. E.g., the formats GraphML and gzipped
         GraphML are able to store both node and link weights.
 
         The remaining arguments are passed to the reader method without
         any changes.
 
-        :arg str filename_network:  The name of the file where the Network
-            object is to be stored.
-        :arg str filename_grid:  The name of the file where the Grid object is
-            to be stored (including ending).
+        :arg tuple/list filename: Tuple or list of two strings, namely
+            the paths to the files containing the Network object
+            and the GeoGrid object (filename_network, filename_grid)
         :arg str fileformat: the format of the file (if known in advance)
           ``None`` means auto-detection. Possible values are: ``"ncol"`` (NCOL
           format), ``"lgl"`` (LGL format), ``"graphml"``, ``"graphmlz"``
           (GraphML and gzipped GraphML format), ``"gml"`` (GML format),
           ``"net"``, ``"pajek"`` (Pajek format), ``"dimacs"`` (DIMACS format),
           ``"edgelist"``, ``"edges"`` or ``"edge"`` (edge list),
           ``"adjacency"`` (adjacency matrix), ``"pickle"`` (Python pickled
           format).
         :arg int silence_level: The inverse level of verbosity of the object.
-        :rtype: GeoNetwork object
-        :return: :class:`GeoNetwork` instance.
+        :rtype: SpatialNetwork object
+        :return: :class:`GeolNetwork` instance.
         """
+        try:
+            (filename_network, filename_grid) = filename
+        except ValueError as e:
+            raise ValueError("'filename' must be a tuple or list of two "
+                             "items: filename_network, filename_grid") from e
+
         #  Load Grid object
-        grid = Grid.Load(filename_grid)
+        grid = GeoGrid.Load(filename_grid)
+        print(grid.__class__)
 
         #  Load to igraph Graph object
         graph = igraph.Graph.Read(f=filename_network, format=fileformat,
                                   *args, **kwds)
 
         #  Extract adjacency matrix
         A = np.array(graph.get_adjacency(type=2).data)
 
         #  Create GeoNetwork instance
-        net = GeoNetwork(adjacency=A, grid=grid, directed=graph.is_directed(),
-                         node_weight_type=None)
+        net = GeoNetwork(adjacency=A, grid=grid,
+                         directed=graph.is_directed(),
+                         silence_level=silence_level)
 
         #  Extract node weights
         if "node_weight_nsi" in graph.vs.attribute_names():
             node_weights = \
                 np.array(graph.vs.get_attribute_values("node_weight_nsi"))
             net.node_weights = node_weights
 
         #  Overwrite igraph Graph object in Network instance to restore link
         #  attributes/weights
         net.graph = graph
-        #  Restore link attributes/weights
-        net.clear_paths_cache()
-
+        #  invalidate cache
+        net._mut_la += 1
         return net
 
+    def save_for_cgv(self, filename, fileformat="graphml"):
+        """
+        Save the GeoNetwork and its attributes for the CGV visualization
+        software.
+
+        The node coordinates are stored as node attributes by default, likewise
+        angular link distances are stored as edge attributes by default. All
+        additional node and link properties are also stored for visualization.
+
+        This format is intended for being used by the spatial graph
+        visualization software CGV developed in Rostock (contact Thomas Nocke,
+        nocke@pik-potsdam.de). By default, the file includes the latitude and
+        longitude vectors as node properties, as well as the geodesic angular
+        distance as an link property.
+
+        :arg str file_name: The file name should end with ".dot" or ".gml".
+        :arg str fileformat: The file format: "graphml"  - GraphML format
+            "graphmlz" - gzipped GraphML format
+            "graphviz" - GraphViz format
+        """
+        #  Save node coordinates as node attribute
+        self.set_node_attribute("lat", self.grid.lat_sequence())
+        self.set_node_attribute("lon", self.grid.lon_sequence())
+
+        #  Save geodesic angular distances on the sphere as link attribute
+        self.set_link_attribute("ang_dist", self.grid.angular_distance())
+
+        #  Save network, independent of filename!
+        if fileformat in ["graphml", "graphmlz", "graphviz"]:
+            self.graph.save(filename, format=fileformat)
+        else:
+            print("ERROR: the chosen format is not supported by save_for_cgv "
+                  "for use with the CGV software.")
+
     #
     #  Graph generation methods
     #
 
     @staticmethod
     def SmallTestNetwork():
         """
         Return a 6-node undirected geographically embedded test network.
 
         The test network consists of the SmallTestNetwork of the Network class
-        with node coordinates given by the SmallTestGrid of the Grid class.
+        with node coordinates given by the SmallTestGrid of the GeoGrid class.
 
         The network looks like this::
 
                 3 - 1
                 |   | \\
             5 - 0 - 4 - 2
 
         :rtype: GeoNetwork instance
         :return: an instance of GeoNetwork for testing purposes.
         """
-        return GeoNetwork(adjacency=Network.SmallTestNetwork().adjacency,
-                          grid=Grid.SmallTestGrid(),
+        return GeoNetwork(grid=GeoGrid.SmallTestGrid(),
+                          adjacency=SpatialNetwork.SmallTestNetwork()
+                          .adjacency,
                           directed=False, node_weight_type="surface",
                           silence_level=2)
 
     @staticmethod
-    def ErdosRenyi(grid, n_nodes, link_probability=None, n_links=None,
-                   node_weight_type="surface", silence_level=0):
+    def Model(network_model, grid, node_weight_type="surface", **kwargs):
         """
-        Generates an undirected and spatially embedded Erdos-Renyi random graph
-
-        Any pair of nodes is connected with probability :math:`p`.
-
-        **Example:**
-
-        >>> print(GeoNetwork.ErdosRenyi(
-        ...     grid=Grid.SmallTestGrid(), n_nodes=6, n_links=5))
-        Generating Erdos-Renyi random graph with 6 nodes and 5 links...
-        Setting area weights according to type surface...
-        GeoNetwork:
-        Network: undirected, 6 nodes, 5 links, link density 0.333.
-        Geographical boundaries:
-                 time     lat     lon
-           min    0.0    0.00    2.50
-           max    9.0   25.00   15.00
-
-        :type grid: :class:`.Grid` object
-        :arg grid: The :class:`.Grid` object describing the network's spatial
-            embedding.
-        :type n_nodes: number > 0 (int)
-        :arg  n_nodes: Number of nodes.
-        :type link_probability: number from 0 to 1 (float), or None
-        :arg  link_probability: If not None, each pair of nodes is
-            independently linked with this probability.  (Default: None)
-        :type n_links: number > 0 (int), or None
-        :arg  n_links: If not None, this many links are assigned at random.
-            Must be None if link_probability is not None.  (Default: None)
-        :arg str node_weight_type: The type of geographical node weight to be
-            used (see :meth:`set_node_weight_type`).
-        :arg int silence_level: The inverse level of verbosity of the object.
-        :rtype: :class:`GeoNetwork`
-        :return: the Erdos-Renyi random graph.
+        Return a new model graph generated with the specified network model
+        and embedded on a geographical grid
         """
-        if link_probability is not None and n_links is None:
-            if silence_level <= 1:
-                print(f"Generating Erdos-Renyi random graph with {n_nodes} "
-                      f"nodes and probability {link_probability}...")
-            graph = igraph.Graph.Erdos_Renyi(n=n_nodes, p=link_probability)
-            # type=2 corresponds to returning the full adjacency matrix
-            A = np.array(graph.get_adjacency(type=2).data)
-
-        elif link_probability is None and n_links is not None:
-            if silence_level <= 1:
-                print(f"Generating Erdos-Renyi random graph with {n_nodes} "
-                      f"nodes and {n_links} links...")
-            graph = igraph.Graph.Erdos_Renyi(n=n_nodes, m=n_links)
-            # type=2 corresponds to returning the full adjacency matrix
-            A = np.array(graph.get_adjacency(type=2).data)
-
-        else:
-            return None
-
+        A = getattr(GeoNetwork, network_model)(**kwargs)
         return GeoNetwork(adjacency=A, grid=grid, directed=False,
-                          node_weight_type=node_weight_type,
-                          silence_level=silence_level)
-
-    @staticmethod
-    def BarabasiAlbert(n_nodes, n_links, grid, node_weight_type="surface",
-                       silence_level=0):
-        """
-        Generates an undirected and spatially embedded Barabasi-Albert network.
-
-        :arg int n_nodes: The number of nodes.
-        :arg int n_links: The number of links of the node that is added at each
-            step of the growth process.
-        :type grid: Grid object
-        :arg grid: The Grid object describing the network's spatial embedding.
-        :arg str node_weight_type: The type of geographical node weight to be
-            used (see :meth:`set_node_weight_type`).
-        :arg int silence_level: The inverse level of verbosity of the object.
-        :rtype: GeoNetwork
-        :return: the Barabasi-Albert network.
-        """
-        #  FIXME: Add example
-
-        if silence_level <= 1:
-            print("Generating Barabasi-Albert random graph "
-                  f"(n = {n_nodes}, m = {n_links})...")
-
-        graph = igraph.Graph.Barabasi(n_nodes, n_links)
-
-        #  Remove self-loops and multiple links, this does of course change the
-        #  actual degree sequence of the generated graph, but just slightly
-        graph.simplify()
-
-        #  type=2 corresponds to returning the full adjacency matrix
-        A = np.array(graph.get_adjacency(type=2).data)
-
-        network = GeoNetwork(adjacency=A, grid=grid, directed=False,
-                             node_weight_type=node_weight_type,
-                             silence_level=silence_level)
-
-        return network
-
-    @staticmethod
-    def ConfigurationModel(grid, degrees, node_weight_type="surface",
-                           silence_level=0):
-        """
-        Generates an undirected and spatially embedded configuration model
-        graph.
-
-        The configuration model gives a fully random graph with a given degree
-        sequence `degrees`.
-
-        .. note::
-           The configuration model network is simplified to eliminate
-           self-loops and multiple edges. This results in a model
-           degree sequence differing (slightly) from the original one.
-           To fully conserve the degree sequence, distribution, link density
-           etc., random rewiring should be used
-           (:meth:`.Network.randomly_rewire`).
-
-        **Example** (Repeat creation of configuration model network from
-        SmallTestNetwork until the number of links is the same as in the
-        original network):
-
-        >>> n = 0
-        >>> while n != 7:
-        ...     net = GeoNetwork.ConfigurationModel(
-        ...         grid=Grid.SmallTestGrid(),
-        ...         degrees=GeoNetwork.SmallTestNetwork().degree(),
-        ...         silence_level=2)
-        ...     n = net.n_links
-        >>> print(net.link_density)
-        0.4666666666666667
-
-        :type degrees: 1D array [index]
-        :arg degrees: The original degree sequence.
-        :type grid: Grid object
-        :arg grid: The Grid object describing the network's spatial embedding.
-        :arg str node_weight_type: The type of geographical node weight to be
-            used (see :meth:`set_node_weight_type`).
-        :arg int silence_level: The inverse level of verbosity of the object.
-        :rtype: GeoNetwork
-        :return: the configuration model network.
-        """
-        if silence_level <= 1:
-            print("Generating configuration model random graph from degree "
-                  "sequence...")
-
-        graph = igraph.Graph.Degree_Sequence(list(degrees))
-
-        #  Remove self-loops and multiple links, this does of course change the
-        #  actual degree sequence of the generated graph, but just slightly
-        graph.simplify()
-
-        #  type=2 corresponds to returning the full adjacency matrix
-        A = np.array(graph.get_adjacency(type=2).data)
-
-        network = GeoNetwork(adjacency=A, grid=grid, directed=False,
-                             node_weight_type=node_weight_type,
-                             silence_level=silence_level)
-
-        return network
+                          node_weight_type=node_weight_type)
 
     #
     #  Graph randomization methods
     #
 
-    #  TODO: Experimental code!
-    def randomly_rewire_geomodel_I(self, distance_matrix, iterations,
-                                   inaccuracy):
-        """
-        Randomly rewire the current network in place using geographical
-        model I.
-
-        Geographical model I preserves the degree sequence (exactly) and the
-        link distance distribution :math:`p(l)` (approximately).
-
-        A higher ``inaccuracy`` in the conservation of :math:`p(l)` will lead
-        to
-
-          - less deterministic links in the network and, hence,
-          - more degrees of freedom for the random graph and
-          - a shorter runtime of the algorithm, since more pairs of nodes
-            eligible for rewiring can be found.
-
-        **Example** (The degree sequence should be the same after rewiring):
-
-        >>> _i()
-        >>> net = GeoNetwork.SmallTestNetwork()
-        >>> net.randomly_rewire_geomodel_I(
-        ...     distance_matrix=net.grid.angular_distance(),
-        ...     iterations=100, inaccuracy=1.0)
-        #
-        >>> net.degree()
-        array([3, 3, 2, 2, 3, 1])
-
-        :type distance_matrix: 2D Numpy array [index, index]
-        :arg distance_matrix: Suitable distance matrix between nodes.
-
-        :type iterations: number (int)
-        :arg iterations: The number of rewirings to be performed.
-
-        :type inaccuracy: number (float)
-        :arg inaccuracy: The inaccuracy with which to conserve :math:`p(l)`.
-        """
-        if self.silence_level <= 1:
-            print("Randomly rewiring given graph, preserving the degree "
-                  "sequence and link distance distribution...")
-        #  Get number of nodes
-        N = self.N
-        #  Get number of links
-        E = self.n_links
-        #  Collect adjacency and distance matrices
-        A = self.adjacency.copy(order='c')
-        D = distance_matrix.astype("float32").copy(order='c')
-        #  Get degree sequence
-        # degree = self.degree()
-
-        #  Define for brevity
-        eps = float(inaccuracy)
-
-        # iterations = int(iterations)
-
-        #  Get edge list
-        edges = np.array(self.graph.get_edgelist()).copy(order='c')
-
-        #  Initialize list of neighbors
-        # neighbors = np.zeros((N, degree.max()))
-
-        _randomly_rewire_geomodel_I(iterations, eps, A, D, E, N, edges)
-
-        #  Update all other properties of GeoNetwork
-        self.adjacency = A
-
-    #  TODO: Experimental code!
-    def randomly_rewire_geomodel_II(self, distance_matrix,
-                                    iterations, inaccuracy):
-        """
-        Randomly rewire the current network in place using geographical
-        model II.
-
-        Geographical model II preserves the degree sequence :math:`k_v`
-        (exactly), the link distance distribution :math:`p(l)` (approximately),
-        and the average link distance sequence :math:`<l>_v` (approximately).
-
-        A higher ``inaccuracy`` in the conservation of :math:`p(l)` and
-        :math:`<l>_v` will lead to:
-
-          - less deterministic links in the network and, hence,
-          - more degrees of freedom for the random graph and
-          - a shorter runtime of the algorithm, since more pairs of nodes
-            eligible for rewiring can be found.
-
-        :type distance_matrix: 2D Numpy array [index, index]
-        :arg distance_matrix: Suitable distance matrix between nodes.
-
-        :type iterations: number (int)
-        :arg iterations: The number of rewirings to be performed.
-
-        :type inaccuracy: number (float)
-        :arg inaccuracy: The inaccuracy with which to conserve :math:`p(l)`.
-        """
-        #  FIXME: Add example
-        if self.silence_level <= 1:
-            print("Randomly rewiring given graph, preserving the degree "
-                  "sequence, link distance distribution and average link "
-                  "distance sequence...")
-
-        #  Get number of nodes
-        N = int(self.N)
-        #  Get number of links
-        E = int(self.n_links)
-        #  Collect adjacency and distance matrices
-        A = self.adjacency.copy(order='c')
-        D = distance_matrix.astype("float32").copy(order='c')
-
-        #  Define for brevity
-        eps = float(inaccuracy)
-
-        #  Get edge list
-        edges = np.array(self.graph.get_edgelist()).copy(order='c')
-
-        _randomly_rewire_geomodel_II(iterations, eps, A, D, E, N, edges)
-
-        #  Update all other properties of GeoNetwork
-        self.adjacency = A
-
-    #  TODO: Experimental code!
-    def randomly_rewire_geomodel_III(self, distance_matrix,
-                                     iterations, inaccuracy):
-        """
-        Randomly rewire the current network in place using geographical
-        model III.
-
-        Geographical model III preserves the degree sequence :math:`k_v`
-        (exactly), the link distance distribution :math:`p(l)` (approximately),
-        and the average link distance sequence :math:`<l>_v` (approximately).
-        Moreover, degree-degree correlations are also conserved exactly.
-
-        A higher ``inaccuracy`` in the conservation of :math:`p(l)` and
-        :math:`<l>_v` will lead to:
-
-          - less deterministic links in the network and, hence,
-          - more degrees of freedom for the random graph and
-          - a shorter runtime of the algorithm, since more pairs of nodes
-            eligible for rewiring can be found.
-
-        :type distance_matrix: 2D Numpy array [index, index]
-        :arg distance_matrix: Suitable distance matrix between nodes.
-
-        :type iterations: number (int)
-        :arg iterations: The number of rewirings to be performed.
-
-        :type inaccuracy: number (float)
-        :arg inaccuracy: The inaccuracy with which to conserve :math:`p(l)`.
-        """
-        #  FIXME: Add example
-        if self.silence_level <= 1:
-            print("Randomly rewiring given graph, preserving the degree "
-                  "sequence, degree-degree correlations, link distance "
-                  "distribution and average link distance sequence...")
-
-        #  Get number of nodes
-        N = int(self.N)
-        #  Get number of links
-        E = int(self.n_links)
-        #  Collect adjacency and distance matrices
-        A = self.adjacency.copy(order='c')
-        D = distance_matrix.astype("float32").copy(order='c')
-        #  Get degree sequence
-        degree = self.degree().copy(order='c')
-
-        #  Define for brevity
-        eps = float(inaccuracy)
-
-        #  Get edge list
-        edges = np.array(self.graph.get_edgelist()).copy(order='c')
-
-        _randomly_rewire_geomodel_III(iterations, eps, A, D, E, N, edges,
-                                      degree)
-
-        #  Update all other properties of GeoNetwork
-        self.adjacency = A
-
-    def set_random_links_by_distance(self, a, b):
-        """
-        Reassign links independently with
-        link probability = :math:`exp(a + b*angular distance)`.
-
-        .. note::
-           Modifies network in place, creates an undirected network!
-
-        **Example** (Repeat until a network with 5 links is created):
-
-        >>> net = GeoNetwork.SmallTestNetwork()
-        >>> while (net.n_links != 5):
-        ...     net.set_random_links_by_distance(a=0., b=-4.)
-        >>> net.n_links
-        5
-
-        :type a: number (float)
-        :arg a: The a parameter.
-
-        :type b: number (float)
-        :arg b: The b parameter.
-        """
-        #  Get angular distance matrix
-        D = self.grid.angular_distance()
-        #  Calculate link probabilities
-        p = np.exp(a + b * D)
-
-        #  Generate random numbers
-        P = random.random(D.shape)
-        #  Symmetrize
-        P = 0.5 * (P + P.transpose())
-
-        #  Create new adjacency matrix
-        A = (p >= P).astype("int8")
-        #  Set diagonal to zero - no self-loops!
-        np.fill_diagonal(A, 0)
-
-        #  Set new adjacency matrix
-        self.adjacency = A
-
     #  FIXME: Check this method and implement in C++ via Cython for speed.
     #  FIXME: Also improve documentation.
     #  FIXME: Add example
     def shuffled_by_distance_copy(self):
         """
         Return a copy of the network where all links in each node-distance
         class have been randomly re-assigned.
@@ -704,15 +287,15 @@
         the original network.
 
         :rtype: GeoNetwork
         :return: the distance shuffled copy.
         """
         N = self.N
         A = self.adjacency
-        D = self.grid.angular_distance()
+        D = self.grid.distance()
 
         #  Count pairs and links by distance
         n_pairs_by_dist = {}
         n_links_by_dist = {}
         for j in range(0, N):
             print(j)
             for i in range(0, j):
@@ -725,17 +308,17 @@
                     try:
                         n_links_by_dist[d] += 1
                     except KeyError:
                         n_links_by_dist[d] = 1
 
         #  Determine link probabilities
         p_by_dist = {}
-        for d in n_pairs_by_dist:
+        for d, n in n_pairs_by_dist.items():
             try:
-                p_by_dist[d] = n_links_by_dist[d] * 1.0 / n_pairs_by_dist[d]
+                p_by_dist[d] = n_links_by_dist[d] * 1.0 / n
             except KeyError:
                 p_by_dist[d] = 0.0
             print(d, p_by_dist[d])
         del n_links_by_dist, n_pairs_by_dist
 
         #  Link new pairs with respective probability
         A_new = np.zeros((N, N))
@@ -866,70 +449,14 @@
         (dist, error, lbb) = self.geographical_distribution(sequence, n_bins)
         cumu_dist = np.zeros(n_bins)
         for i in range(n_bins):
             cumu_dist[i] = dist[i:].sum()
         return (cumu_dist, error, lbb)
 
     #
-    #  Get link distance distribution
-    #
-
-    def link_distance_distribution(self, n_bins, grid_type="spherical",
-                                   geometry_corrected=False):
-        """
-        Return the normalized link distance distribution.
-
-        Correct for the geometry of the embedding space by default.
-
-        **Examples:**
-
-        >>> GeoNetwork.SmallTestNetwork().link_distance_distribution(
-        ...     n_bins=4, geometry_corrected=False)[0]
-        array([ 0.14285714,  0.28571429,  0.28571429,  0.28571429])
-        >>> GeoNetwork.SmallTestNetwork().link_distance_distribution(
-        ...     n_bins=4, geometry_corrected=True)[0]
-        array([ 0.09836066,  0.24590164,  0.32786885,  0.32786885])
-
-        :arg int n_bins: The number of bins for histogram.
-        :arg str grid_type: Type of grid, used for distance calculation, can
-            take values "euclidean" and "spherical".
-        :arg bool geometry_corrected: Toggles correction for grid geometry.
-        :rtype: tuple of three 1D arrays [bin]
-        :return: the link distance distribution, statistical error,
-                 and lower bin boundaries.
-        """
-        if self.silence_level <= 1:
-            print("Calculating link distance distribution...")
-
-        #  Collect matrices
-        A = self.adjacency
-        if grid_type == "spherical":
-            D = self.grid.angular_distance()
-        elif grid_type == "euclidean":
-            D = self.grid.euclidean_distance()
-
-        #  Determine range for link distance histograms
-        interval = (0, D.max())
-
-        #  Get link distance distribution
-        (dist, error, lbb) = self._histogram(D[A == 1], n_bins=n_bins,
-                                             interval=interval)
-
-        if geometry_corrected:
-            geometric_ld_dist = \
-                self.grid.geometric_distance_distribution(n_bins)[0]
-            # Divide out the geometrical factor of the distribution
-            dist /= geometric_ld_dist
-
-        #  Normalize the distribution
-        dist /= dist.sum()
-
-        return (dist, error, lbb)
-
-    #
     #  Area weighted connectivity (AWC) related measures
     #
 
     def area_weighted_connectivity(self):
         """
         Return area weighted connectivity (:math:`AWC`).
 
@@ -1228,139 +755,14 @@
 
         return max_neighbor_awc
 
     #
     #  Distance related measures
     #
 
-    #  (Un)directed average link distances
-
-    #  TODO: Discuss geometry correction with Jobst.
-    def _calculate_general_average_link_distance(self, adjacency, degrees,
-                                                 geometry_corrected=False):
-        """
-        Return general average link distances (:math:`ALD`).
-
-        This general method is called to calculate undirected average link
-        distance, average in-link distance and average out-link distance.
-
-        The resulting sequence can optionally be corrected for biases in
-        average link distance arising due to the grid geometry. E.g., for
-        regional networks, nodes on the boundaries may have a bias towards
-        larger values of :math:`ALD`, while nodes in the center have a bias
-        towards smaller values of :math:`ALD`.
-
-        :type adjacency: 2D array [index, index]
-        :arg adjacency: The adjacency matrix.
-        :type degrees: 1D array [index]
-        :arg degrees: The degree sequence.
-        :arg bool geometry_corrected: Toggles geometry correction.
-        :rtype: 1D array [index]
-        :return: the general average link distance sequence.
-        """
-        D = self.grid.angular_distance()
-        k = self.degree()
-
-        average_link_distance = np.zeros(self.N)
-
-        #  Normalize by degree, not by number of nodes!!!
-        average_link_distance[k != 0] = \
-            (D * adjacency).sum(axis=1)[k != 0] / k[k != 0]
-
-        if geometry_corrected:
-            #  Calculate the average link distance for a fully connected
-            #  network to correct for geometrical biases, particularly in
-            #  regional networks.
-            ald_correction = D.mean(axis=1)
-            # aldCorrection = angularDistance.max(axis=1)
-
-            #  Correct average link distance
-            average_link_distance /= ald_correction
-
-        return average_link_distance
-
-    def average_link_distance(self, geometry_corrected=False):
-        """
-        Return average link distances (undirected).
-
-        .. note::
-           Does not use directionality information.
-
-        **Examples:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                average_link_distance(geometry_corrected=False))
-        array([ 0.3885, 0.1943, 0.1456, 0.2433, 0.2912, 0.4847])
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                average_link_distance(geometry_corrected=True))[:-1]
-        array([ 1.5988, 1.0921, 1.0001, 1.6708, 1.6384])
-
-        :arg bool geometry_corrected: Toggles geometry correction.
-        :rtype: 1D array [index]
-        :return: the average link distance sequence (undirected).
-        """
-        if self.silence_level <= 1:
-            print("Calculating average link distance...")
-
-        A = self.undirected_adjacency().A
-        degree = self.degree()
-
-        return self._calculate_general_average_link_distance(
-            A, degree, geometry_corrected=geometry_corrected)
-
-    def inaverage_link_distance(self, geometry_corrected=False):
-        """
-        Return in-average link distances.
-
-        Return regular average link distance for undirected networks.
-
-        **Example:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                inaverage_link_distance(geometry_corrected=False))
-        array([ 0.3885, 0.1943, 0.1456, 0.2433, 0.2912, 0.4847])
-
-        :arg bool geometry_corrected: Toggles geometry correction.
-        :rtype: 1D array [index]
-        :return: the in-average link distance sequence.
-        """
-        if self.silence_level <= 1:
-            print("Calculating in-average link distance...")
-
-        A = self.adjacency.T
-        in_degree = self.indegree()
-
-        return self._calculate_general_average_link_distance(
-            A, in_degree, geometry_corrected=geometry_corrected)
-
-    def outaverage_link_distance(self, geometry_corrected=False):
-        """
-        Return out-average link distances.
-
-        Return regular average link distance for undirected networks.
-
-        **Example:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                outaverage_link_distance(geometry_corrected=False))
-        array([ 0.3885, 0.1943, 0.1456, 0.2433, 0.2912, 0.4847])
-
-        :arg bool geometry_corrected: Toggles geometry correction.
-        :rtype: 1D array [index]
-        :return: the out-average link distance sequence.
-        """
-        if self.silence_level <= 1:
-            print("Calculating out-average link distance...")
-
-        A = self.adjacency
-        out_degree = self.outdegree()
-
-        return self._calculate_general_average_link_distance(
-            A, out_degree, geometry_corrected=geometry_corrected)
-
     #  (Un)directed total link distances
 
     def total_link_distance(self, geometry_corrected=False):
         """
         Return the sequence of total link distances for all nodes.
 
         .. note::
@@ -1525,128 +927,18 @@
 
         A = self.adjacency
         outdegree = self.outdegree()
 
         return self._calculate_general_connectivity_weighted_distance(
             A, outdegree)
 
-    def max_link_distance(self):
-        """
-        Return maximum angular geodesic link distances.
-
-        .. note::
-           Does not use directionality information.
-
-        **Example:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().max_link_distance())
-        array([ 0.4847, 0.2911, 0.1938, 0.292 , 0.3887, 0.4847])
-
-        :rtype: 1D Numpy array [index]
-        :return: the maximum link distance sequence.
-        """
-        if self.silence_level <= 1:
-            print("Calculating maximum link distance...")
-
-        A = self.undirected_adjacency().A
-        D = self.grid.angular_distance()
-
-        maximum_link_distance = (D * A).max(axis=1)
-        return maximum_link_distance
-
-    #
-    #  Link weighted network measures
-    #
-
-    @cached_const('base', 'angular_distance')
-    def angular_distance(self):
-        """
-        Return the angular great circle distance matrix.
-        """
-        ad = self.grid.angular_distance()
-        self.set_link_attribute('angular_distance', ad)
-        return ad
-
-    def average_distance_weighted_path_length(self):
-        """
-        Return average distance weighted path length.
-
-        Returns the average path length link-weighted by the angular
-        great circle distance between nodes.
-
-        **Example:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                average_distance_weighted_path_length())
-        0.4985
-
-        :rtype: number (float)
-        :return: the average distance weighted path length.
-        """
-        self.angular_distance()
-        return self.average_path_length('angular_distance')
-
-    def distance_weighted_closeness(self):
-        """
-        Return distance weighted closeness.
-
-        Returns the sequence of closeness centralities link-weighted by the
-        angular great circle distance between nodes.
-
-        **Example:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                distance_weighted_closeness())
-        array([ 2.2378, 2.4501, 2.2396, 2.4501, 2.2396, 1.1982])
-
-        :rtype: 1D Numpy array [index]
-        :return: the distance weighted closeness sequence.
-        """
-        self.angular_distance()
-        return self.closeness('angular_distance')
-
-    def local_distance_weighted_vulnerability(self):
-        """
-        Return local distance weighted vulnerability.
-
-        Return the sequence of vulnerabilities link-weighted by
-        the angular great circle distance between nodes.
-
-        **Example:**
-
-        >>> r(GeoNetwork.SmallTestNetwork().\
-                local_distance_weighted_vulnerability())
-        array([ 0.0325, 0.3137, 0.2056, 0.028 , -0.0283, -0.288 ])
-
-        :rtype: 1D Numpy array [index]
-        :return: the local distance weighted vulnerability sequence.
-        """
-        self.angular_distance()
-        return self.local_vulnerability('angular_distance')
-
     #
     #  Clustering coefficients including geographical information
     #
 
-    #  TODO: Maybe implement this one day...
-    def local_tsonis_clustering(self):
-        """
-        Return local Tsonis clustering.
-
-        This measure of local clustering was introduced in [Tsonis2008a]_.
-
-        :rtype: 1D Numpy array (index)
-        :return: the local Tsonis clustering sequence.
-        """
-        if self.silence_level <= 1:
-            print("Calculating local Tsonis clustering coefficients...")
-
-        tsonis_clustering = np.zeros(self.N)
-        return tsonis_clustering
-
     def local_geographical_clustering(self):
         """
         Return local geographical clustering.
 
         Returns the sequence of local clustering coefficients weighted by the
         inverse angular great circle distance between nodes. This guarantees,
         that short links between spatially neighboring nodes in a triangle are
@@ -1740,17 +1032,17 @@
         * EXPERIMENTAL! *
         """
         #  Optional import for this experimental method
         try:
             import stripack  # @UnresolvedImport
             # tries to import stripack.so which must have been compiled with
             # f2py -c -m stripack stripack.f90
-        except ImportError:
-            raise RuntimeError("NOTE: stripack.so not available, boundary() \
-                               won't work.")
+        except ImportError as err:
+            raise RuntimeError("NOTE: stripack.so not available, "
+                               "boundary() won't work.") from err
 
         N = self.N
         nodes_set = set(nodes)
         if len(nodes_set) >= N:
             return [], [], [], [(0.0, 0.0)]
         # find grid neighbours:
         if geodesic:
@@ -1829,14 +1121,15 @@
                 continue
             o = list(self.grid_neighbours_set[i] - nodes_set)[0]
 
             # traverse boundary:
             partial_boundary = [i]
             partial_shape = [lam*pos[i] + lam1*pos[o]]
             partial_fullshape = [0.49*pos[i] + 0.51*pos[o]]
+            print(partial_shape)
             steps = [(i, o)]
             for it in range(N):  # at most this many steps we need
                 nbi = self.grid_neighbours[i]
                 j = nbi[0]
                 try:
                     j = nbi[(nbi.index(o)-1) % len(nbi)]
                 except IndexError:
@@ -1862,23 +1155,22 @@
             mind2 = np.inf
             latlon_shape = []
             latlon_fullshape = []
             length = len(partial_shape)-1
             off = length/2
             for it in range(length):
                 pos1 = partial_shape[it]
-                pos2 = partial_shape[(it+off) % length]
+                pos2 = partial_shape[int((it+off) % length)]
                 latlon_shape.append(self.cartesian2latlon(pos1))
                 d2 = ((pos2-pos1)**2).sum()
                 if d2 < mind2:
                     rep = self.cartesian2latlon((pos1+pos2)/2)
                     mind2 = d2
             latlon_shape.append(self.cartesian2latlon(partial_shape[-1]))
-            for it, _ in enumerate(partial_fullshape):
-                pos1 = partial_fullshape[it]
+            for pos1 in partial_fullshape:
                 latlon_fullshape.append(self.cartesian2latlon(pos1))
 
             boundary.append(partial_boundary)
             shape.append(latlon_shape)
             fullshape.append(latlon_fullshape)
             representative.append(rep)
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/resistive_network.py` & `pyunicorn-0.7.0/src/pyunicorn/core/resistive_network.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # # Copyright (C) 2014 Paul Schultz and the SWIPO Project
 #
 # Authors (this file):
 #   Stefan Schinkel <stefan.schinkel@gmail.com>
 #   Paul Schultz pschultz@pik-potsdam.de>
 #
 #
@@ -37,20 +34,21 @@
 
 # Import handler for sparse matrices
 from scipy import sparse
 
 #  Import iGraph for high performance graph theory tools written in pure ANSI-C
 import igraph
 
+from ._ext.types import to_cy, FIELD, DFIELD
 from ._ext.numerics import _vertex_current_flow_betweenness, \
     _edge_current_flow_betweenness
 
 # Import things we inherit from
 from .geo_network import GeoNetwork
-from .grid import Grid
+from .geo_grid import GeoGrid
 
 # a network Error (use uncertain)
 # from .network import NetworkError
 
 
 class ResNetwork(GeoNetwork):
     """ A resistive network class
@@ -78,16 +76,17 @@
                  directed=False, node_weight_type=None, silence_level=2):
 
         """Initialize an instance of ResNetwork.
 
         :type resistances: 2D NumPy array
         :arg resistances: A matrix with the resistances
 
-        :type grid: Grid object
-        :arg grid: The Grid object describing the network's spatial embedding.
+        :type grid: GeoGrid object
+        :arg grid: The GeoGrid object describing the network's spatial
+            embedding.
 
         :type adjacency: 2D NumPy array (int8) [index, index]
         :arg adjacency: The network's adjacency matrix.
 
         :type edge_list: array-like list of lists
         :arg  edge_list: Edge list of the new network.
                          Entries [i,0], [i,1] contain the end-nodes of an edge.
@@ -115,15 +114,15 @@
             adjacency[resistances != 0] = 1
 
         # 1b) a Grid object
         #     an actual grid might not exist, so we fake one
         if grid is None:
             if silence_level < 2:
                 print("Using dummy grid")
-            grid = Grid(
+            grid = GeoGrid(
                 time_seq=np.arange(10), lat_seq=np.absolute(
                     np.linspace(-90, 90, adjacency.shape[0])),
                 lon_seq=np.linspace(-180, 180, adjacency.shape[0]),
                 silence_level=0)
 
         # 2) init parent
         GeoNetwork.__init__(self, grid, adjacency=adjacency,
@@ -143,16 +142,16 @@
         # 4) cache
         self._effective_resistances = None
 
     def __str__(self):
         """
         Return a short summary of the resistive network.
         """
-        return 'ResNetwork:\n%s\nAverage resistance: %s' % (
-            GeoNetwork.__str__(self), self.resistances.mean())
+        return (f"ResNetwork:\n{GeoNetwork.__str__(self)}\n"
+                f"Average resistance: {self.resistances.mean()}")
 
 ###############################################################################
 # ##                       PUBLIC FUNCTIONS                                ## #
 ###############################################################################
     @staticmethod
     def SmallTestNetwork():
         r"""
@@ -187,15 +186,15 @@
         # # the resistances should be a full matrix
         resistances = np.array([[0, 2, 0, 0, 0],
                                 [2, 0, 8, 2, 0],
                                 [0, 8, 0, 8, 0],
                                 [0, 2, 8, 0, 10],
                                 [0, 0, 0, 10, 0]])
         # a grid
-        grid = Grid(
+        grid = GeoGrid(
             time_seq=np.arange(10), lat_seq=np.absolute(
                 np.linspace(-90, 90, adjacency.shape[0])),
             lon_seq=np.linspace(-180, 180, adjacency.shape[0]),
             silence_level=0)
 
         return ResNetwork(resistances, grid=grid, adjacency=adjacency)
 
@@ -695,15 +694,15 @@
         >>> print("%.3f" % res.effective_resistance_closeness_centrality(0))
         0.154
         >>> print("%.3f" % res.effective_resistance_closeness_centrality(4))
         0.080
         """
 
         # alloc
-        ERCC = np.float(0.0)
+        ERCC = DFIELD(0.0)
 
         # compute
         for i in range(self.N):
             ERCC += self.effective_resistance(a, i)
         # ERCC /=  np.square( self.N - 1 )
         ERCC = (self.N - 1) / ERCC
 
@@ -741,19 +740,18 @@
         >>> res = ResNetwork.SmallTestNetwork()
         >>> print("%.3f" % res.vertex_current_flow_betweenness(1))
         0.389
         >>> print("%.3f" % res.vertex_current_flow_betweenness(2))
         0.044
         """
         # set params
-        Is = It = np.float(1.0)
+        Is = It = FIELD(1.0)
         return _vertex_current_flow_betweenness(
-            np.int(self.N), Is, It,
-            self.get_admittance().astype('float32').copy(order='c'),
-            self.get_R().astype('float32').copy(order='c'), i)
+            self.N, Is, It,
+            to_cy(self.get_admittance(), FIELD), to_cy(self.get_R(), FIELD), i)
 
     def edge_current_flow_betweenness(self):
         """The electrial version of Newmann's edge betweeness
 
         :rtype: NumPy float
 
         **Examples:**
@@ -771,20 +769,19 @@
         [[ 0.      0.4     0.      0.      0.    ]
          [ 0.4     0.      0.3333  0.4     0.    ]
          [ 0.      0.3333  0.      0.3333  0.    ]
          [ 0.      0.4     0.3333  0.      0.4   ]
          [ 0.      0.      0.      0.4     0.    ]]
         """
         # set currents
-        Is = It = np.float(1)
+        Is = It = FIELD(1)
 
         return _edge_current_flow_betweenness(
-            np.int(self.N), Is, It,
-            self.get_admittance().astype('float32').copy(order='c'),
-            self.get_R().astype('float32').copy(order='c'))
+            self.N, Is, It,
+            to_cy(self.get_admittance(), FIELD), to_cy(self.get_R(), FIELD))
 
 
 ###############################################################################
 # ##                       FUNCTIONS ATTIC                                 ## #
 ###############################################################################
 
     # These functions are no longer needed as the computation can be broken
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/_ext/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/utils/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,21 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
+
+"""
+utils
+=====
+
+"""
+
+__all__ = ['mpi', 'navigator']
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/_ext/numerics.pyx` & `pyunicorn-0.7.0/src/pyunicorn/core/_ext/numerics.pyx`

 * *Files 20% similar despite different names*

```diff
@@ -1,244 +1,186 @@
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
-
 cimport cython
-cimport numpy as np
+
+import random
 
 import numpy as np
+cimport numpy as cnp
+from numpy cimport ndarray, abs
 import numpy.random as rd
-
 randint = rd.randint
 
-INTTYPE = np.int
-INT16TYPE = np.int16
-INT32TYPE = np.int32
-FLOATTYPE = np.float
-FLOAT32TYPE = np.float32
-FLOAT64TYPE = np.float64
-ctypedef np.int_t INTTYPE_t
-ctypedef np.int16_t INT16TYPE_t
-ctypedef np.int32_t INT32TYPE_t
-ctypedef np.float_t FLOATTYPE_t
-ctypedef np.float32_t FLOAT32TYPE_t
-ctypedef np.float64_t FLOAT64TYPE_t
-
-cdef extern from "stdlib.h":
-    double drand48()
-    double srand48()
-
-cdef extern from "time.h":
-    double time()
+from ...core._ext.types import NODE, DEGREE, FIELD, DFIELD
+from ...core._ext.types cimport \
+    ADJ_t, MASK_t, NODE_t, DEGREE_t, WEIGHT_t, DWEIGHT_t, FIELD_t, DFIELD_t
 
 cdef extern from "src_numerics.c":
-    void _randomly_rewire_geomodel_I_fast(int iterations, float eps, short *A,
-        float *D, int E, int N, int *edges)
-    void _randomly_rewire_geomodel_II_fast(int iterations, float eps, short *A,
-        float *D, int E, int N, int *edges)
-    void _randomly_rewire_geomodel_III_fast(int iterations, float eps,
-        short *A, float *D, int E, int N, int *edges, int *degree)
-    double _higher_order_transitivity4_fast(int N, short* A)
     void _do_nsi_hamming_clustering_fast(int n2, int nActiveIndices,
         float mind0, float minwp0, int lastunited, int part1, int part2,
-        float *distances, int *theActiveIndices, float *linkedWeights,
-        float *weightProducts, float *errors, float *result, int *mayJoin)
+        double *distances, int *theActiveIndices, double *linkedWeights,
+        double *weightProducts, double *errors, double *result, int *mayJoin)
     double _vertex_current_flow_betweenness_fast(int N, double Is, double It,
         float *admittance, float *R, int i)
     void _edge_current_flow_betweenness_fast(int N, double Is, double It,
         float *admittance, float *R, float *ECFB)
 
 
 # geo_network =================================================================
 
-def _randomly_rewire_geomodel_I(int iterations, float eps,
-    np.ndarray[short, ndim=2] A, np.ndarray[float, ndim=2] D, int E, int N,
-    np.ndarray[INTTYPE_t, ndim=2] edges):
 
-    cdef:
-        int i, j, s, t, k, l, edge1, edge2, count
-        int neighbor_s_index, neighbor_t_index
-        int neighbor_k_index, neighbor_l_index
-
-    #  Create list of neighbors
-    #for (int i = 0; i < N; i++) {
-    #
-    #    count = 0;
-    #
-    #    for (int j = 0; j < N; j++) {
-    #        if (A(i,j) == 1) {
-    #            neighbors(i,count) = j;
-    #            count++;
-    #        }
-    #    }
-    #}
+# parameters for `_randomly_rewire_geomodel()`
+ctypedef bint (*rewire_cond_len)(FIELD_t[:,:], float, int, int, int, int)
+ctypedef bint (*rewire_cond_deg)(DEGREE_t[:], int, int, int, int)
+
+cdef:
+    # condition C1
+    inline bint cond_len_c1(
+        FIELD_t[:,:] D, float eps, int s, int t, int k, int l):
+        return (
+            (abs(D[s,t] - D[k,t]) < eps and abs(D[k,l] - D[s,l]) < eps) or
+            (abs(D[s,t] - D[s,l]) < eps and abs(D[k,l] - D[k,t]) < eps))
+    # condition C2
+    inline bint cond_len_c2(
+        FIELD_t[:,:] D, float eps, int s, int t, int k, int l):
+        return (
+            abs(D[s,t] - D[s,l]) < eps and abs(D[t,s] - D[t,k]) < eps and
+            abs(D[k,l] - D[k,t]) < eps and abs(D[l,k] - D[l,s]) < eps)
+    # invariance of degree-degree correlations
+    inline bint cond_deg_corr(DEGREE_t[:] degree, int s, int t, int k, int l):
+        return (degree[s] == degree[k] and degree[t] == degree[l])
+    # tautology
+    rewire_cond_deg cond_deg_true = NULL
+
+
+cdef void _randomly_rewire_geomodel(int iterations, float eps,
+    ndarray[ADJ_t, ndim=2] A, ndarray[FIELD_t, ndim=2] D, int E,
+    ndarray[NODE_t, ndim=2] edges, ndarray[DEGREE_t, ndim=1] degree,
+    rewire_cond_len cond_len, rewire_cond_deg cond_deg):
 
-    #  Initialize random number generator
-    #srand48(time(0))
+    cdef int i = 0, s, t, k, l, edge1, edge2
 
-    i = 0
-    count = 0
     while (i < iterations):
         # Randomly choose 2 edges
         edge1 = np.floor(rd.random() * E)
         edge2 = np.floor(rd.random() * E)
+        s, t = edges[edge1,[0,1]]
+        k, l = edges[edge2,[0,1]]
 
-        s = edges[edge1,0]
-        t = edges[edge1,1]
+        # Proceed only if old links are disjoint
+        if ((s != k and s != l and t != k and t != l) and
+            # Proceed only if new links do NOT already exist
+            (A[s,l] == 0 and A[t,k] == 0) and
+            # Proceed only if link conditions are fulfilled
+            (cond_deg is NULL or cond_deg(degree, s, t, k, l)) and
+            cond_len(D, eps, s, t, k, l)):
+
+                # Now rewire the links symmetrically & increment i
+                A[s,t] = A[t,s] = 0
+                A[k,l] = A[l,k] = 0
+                A[s,l] = A[l,s] = 1
+                A[t,k] = A[k,t] = 1
+                edges[edge1,[0,1]] = s, l
+                edges[edge2,[0,1]] = k, t
 
-        k = edges[edge2,0]
-        l = edges[edge2,1]
+                i+=1
 
-        #  Randomly choose 2 nodes
-        #s = floor(drand48() * N);
-        #k = floor(drand48() * N);
-
-        #  Randomly choose 1 neighbor of each
-        #neighbor_s_index = floor(drand48() * degree(s));
-        #neighbor_k_index = floor(drand48() * degree(k));
-        #t = neighbors(s,neighbor_s_index);
-        #l = neighbors(k,neighbor_k_index);
-
-        count+=1
-
-        #  Proceed only if s != k, s != l, t != k, t != l
-        if (s != k and s != l and t != k and t != l):
-            # Proceed only if the new links {s,l} and {t,k}
-            # do NOT already exist
-            if (A[s,l] == 0 and A[t,k] == 0):
-                # Proceed only if the link lengths fulfill condition C1
-                if ((np.abs(D[s,t] - D[k,t]) < eps and
-                        np.abs(D[k,l] - D[s,l]) < eps ) or
-                            (np.abs(D[s,t] - D[s,l]) < eps and
-                                np.abs(D[k,l] - D[k,t]) < eps )):
-                    # Now rewire the links symmetrically
-                    # and increase i by 1
-                    A[s,t] = 0
-                    A[t,s] = 0
-                    A[k,l] = 0
-                    A[l,k] = 0
-                    A[s,l] = 1
-                    A[l,s] = 1
-                    A[t,k] = 1
-                    A[k,t] = 1
-
-                    edges[edge1,0] = s
-                    edges[edge1,1] = l
-                    edges[edge2,0] = k
-                    edges[edge2,1] = t
-
-                    #  Update neighbor lists of all 4 involved nodes
-                    #neighbors(s,neighbor_s_index) = l;
-                    #neighbors(k,neighbor_k_index) = t;
-
-                    #neighbor_t_index = 0;
-                    #while (neighbors(t,neighbor_t_index) != s) {
-                    #    neighbor_t_index++;
-                    #}
-                    #neighbors(t,neighbor_t_index) = k;
-
-                    #neighbor_l_index = 0;
-                    #while (neighbors(l,neighbor_l_index) != k) {
-                    #    neighbor_l_index++;
-                    #}
-                    #neighbors(l,neighbor_l_index) = s;
 
-                    i+=1
-
-    print("Trials %d, Rewirings %d", (count, iterations))
-    """
-    _randomly_rewire_geomodel_I_fast(iterations, eps,
-            <short*> np.PyArray_DATA(A), <float*> np.PyArray_DATA(D), E, N,
-            <int*> np.PyArray_DATA(edges))
-    """
+def _randomly_rewire_geomodel_I(int iterations, float eps,
+    ndarray[ADJ_t, ndim=2] A, ndarray[FIELD_t, ndim=2] D, int E,
+    ndarray[NODE_t, ndim=2] edges):
+    cdef:
+        ndarray[DEGREE_t, ndim=1] null = np.array([], dtype=DEGREE)
+    _randomly_rewire_geomodel(iterations, eps, A, D, E, edges, null,
+                              cond_len_c1, cond_deg_true)
 
 def _randomly_rewire_geomodel_II(int iterations, float eps,
-    np.ndarray[short, ndim=2] A, np.ndarray[float, ndim=2] D, int E, int N,
-    np.ndarray[INTTYPE_t, ndim=2] edges):
-
-    _randomly_rewire_geomodel_II_fast(iterations, eps,
-            <short*> np.PyArray_DATA(A), <float*> np.PyArray_DATA(D), E, N,
-            <int*> np.PyArray_DATA(edges))
+    ndarray[ADJ_t, ndim=2] A, ndarray[FIELD_t, ndim=2] D, int E,
+    ndarray[NODE_t, ndim=2] edges):
+    cdef:
+        ndarray[DEGREE_t, ndim=1] null = np.array([], dtype=DEGREE)
+    _randomly_rewire_geomodel(iterations, eps, A, D, E, edges, null,
+                              cond_len_c2, cond_deg_true)
 
 def _randomly_rewire_geomodel_III(int iterations, float eps,
-    np.ndarray[short, ndim=2] A, np.ndarray[float, ndim=2] D, int E, int N,
-    np.ndarray[INTTYPE_t, ndim=2] edges, np.ndarray[INTTYPE_t, ndim=1] degree):
-
-    _randomly_rewire_geomodel_III_fast(iterations, eps,
-            <short*> np.PyArray_DATA(A), <float*> np.PyArray_DATA(D), E, N,
-            <int*> np.PyArray_DATA(edges), <int*> np.PyArray_DATA(degree))
+    ndarray[ADJ_t, ndim=2] A, ndarray[FIELD_t, ndim=2] D, int E,
+    ndarray[NODE_t, ndim=2] edges, ndarray[DEGREE_t, ndim=1] degree):
+    _randomly_rewire_geomodel(iterations, eps, A, D, E, edges, degree,
+                              cond_len_c2, cond_deg_corr)
 
 
 # interacting_networks ========================================================
 
+
 cdef void overwriteAdjacency(
-    np.ndarray[INTTYPE_t, ndim=2] A, np.ndarray[INTTYPE_t, ndim=2] cross_A,
-    np.ndarray[INTTYPE_t, ndim=1] nodes1, np.ndarray[INTTYPE_t, ndim=1] nodes2,
+    ndarray[ADJ_t, ndim=2] A, ndarray[ADJ_t, ndim=2] cross_A,
+    ndarray[NODE_t, ndim=1] nodes1, ndarray[NODE_t, ndim=1] nodes2,
     int m, int n):
     """
     Overwrite the adjacency matrix of the full interacting network with the
     randomly rewired cross edges of the two considered subnetworks.
     """
     cdef:
         int i, j
-        INTTYPE_t n1, n2
+        NODE_t n1, n2
 
     for i in range(m):
         for j in range(n):
             n1, n2 = nodes1[i], nodes2[j]
             A[n1, n2] = A[n2, n1] = cross_A[i, j]
 
 
 def _randomlySetCrossLinks(
-    np.ndarray[INTTYPE_t, ndim=2] A, np.ndarray[INTTYPE_t, ndim=2] cross_A,
+    ndarray[ADJ_t, ndim=2] A, ndarray[ADJ_t, ndim=2] cross_A,
     int number_cross_links,
-    np.ndarray[INTTYPE_t, ndim=1] nodes1, np.ndarray[INTTYPE_t, ndim=1] nodes2,
+    ndarray[NODE_t, ndim=1] nodes1, ndarray[NODE_t, ndim=1] nodes2,
     int m, int n):
     """
     >>> A = np.eye(2, dtype=np.int)
     >>> _randomlySetCrossLinks(A, np.array([[0]]), 1,
     ...                        np.array([0]), np.array([1]), 1, 1)
     >>> np.all(A == np.ones(2))
     True
     """
     cdef:
-        unsigned int i, j
+        int i, j
 
     # create random cross links
     for _ in range(number_cross_links):
         while True:
             i, j = randint(m), randint(n)
             if not cross_A[i, j]:
                 break
         cross_A[i, j] = 1
     overwriteAdjacency(A, cross_A, nodes1, nodes2, m, n)
 
 
 def _randomlyRewireCrossLinks(
-    np.ndarray[INTTYPE_t, ndim=2] A, np.ndarray[INTTYPE_t, ndim=2] cross_A,
-    np.ndarray[INTTYPE_t, ndim=2] cross_links,
-    np.ndarray[INTTYPE_t, ndim=1] nodes1, np.ndarray[INTTYPE_t, ndim=1] nodes2,
+    ndarray[ADJ_t, ndim=2] A,
+    ndarray[ADJ_t, ndim=2] cross_A,
+    ndarray[NODE_t, ndim=2] cross_links,
+    ndarray[NODE_t, ndim=1] nodes1,
+    ndarray[NODE_t, ndim=1] nodes2,
     int number_cross_links, int number_swaps):
 
     cdef:
-        int m = len(nodes1), n = len(nodes2)
-        INTTYPE_t e1, e2, a, b, c, d
+        int m = int(len(nodes1)), n = int(len(nodes2))
+        NODE_t e1, e2, a, b, c, d
 
     # implement permutations
     for _ in range(number_swaps):
         while True:
             # choose two random edges
             e1, e2 = randint(number_cross_links), randint(number_cross_links)
             a, b = cross_links[e1]
@@ -256,21 +198,21 @@
         b                  = cross_links[e1, 1]
         cross_links[e1, 1] = cross_links[e2, 1]
         cross_links[e2, 1] = b
     overwriteAdjacency(A, cross_A, nodes1, nodes2, m, n)
 
 
 def _cross_transitivity(
-    np.ndarray[INTTYPE_t, ndim=2] A, np.ndarray[INTTYPE_t, ndim=1] nodes1,
-    np.ndarray[INTTYPE_t, ndim=1] nodes2):
+    ndarray[ADJ_t, ndim=2] A,
+    ndarray[NODE_t, ndim=1] nodes1, ndarray[NODE_t, ndim=1] nodes2):
 
     cdef:
-        unsigned int m = len(nodes1), n = len(nodes2)
-        unsigned int i, j, k
-        INTTYPE_t n1, n2, n3
+        int m = int(len(nodes1)), n = int(len(nodes2))
+        int i, j, k
+        NODE_t n1, n2, n3
         long triangles = 0, triples = 0
 
     for i in range(m):
         n1 = nodes1[i]
         # loop over unique pairs of nodes in subnetwork 2
         for j in range(n):
             n2 = nodes2[j]
@@ -284,23 +226,24 @@
     if triples:
         return triangles / float(triples)
     else:
         return 0.0
 
 
 def _nsi_cross_transitivity(
-    np.ndarray[INTTYPE_t, ndim=2] A,
-    np.ndarray[INTTYPE_t, ndim=1] nodes1, np.ndarray[INTTYPE_t, ndim=1] nodes2,
-    np.ndarray[FLOATTYPE_t, ndim=1] node_weights):
+    ndarray[ADJ_t, ndim=2] A,
+    ndarray[NODE_t, ndim=1] nodes1,
+    ndarray[NODE_t, ndim=1] nodes2,
+    ndarray[DWEIGHT_t, ndim=1] node_weights):
 
     cdef:
-        unsigned int m = len(nodes1), n = len(nodes2)
-        unsigned int v, p, q
-        INTTYPE_t node_v, node_p, node_q
-        FLOATTYPE_t weight_v, weight_p, ppv, pqv, T1 = 0, T2 = 0
+        int m = int(len(nodes1)), n = int(len(nodes2))
+        int v, p, q
+        NODE_t node_v, node_p, node_q
+        DWEIGHT_t weight_v, weight_p, ppv, pqv, T1 = 0, T2 = 0
 
     for v in range(m):
         node_v = nodes1[v]
         weight_v = node_weights[node_v]
         for p in range(n):
             node_p = nodes2[p]
             if A[node_v, node_p]:
@@ -315,22 +258,23 @@
                         T2 += pqv
                         if A[node_p, node_q]:
                             T1 += pqv
     return T1 / T2
 
 
 def _cross_local_clustering(
-    np.ndarray[INTTYPE_t, ndim=2] A, np.ndarray[FLOATTYPE_t, ndim=1] norm,
-    np.ndarray[INTTYPE_t, ndim=1] nodes1, np.ndarray[INTTYPE_t, ndim=1] nodes2,
-    np.ndarray[FLOATTYPE_t, ndim=1] cross_clustering):
+    ndarray[ADJ_t, ndim=2] A,
+    ndarray[DFIELD_t, ndim=1] norm,
+    ndarray[NODE_t, ndim=1] nodes1, ndarray[NODE_t, ndim=1] nodes2,
+    ndarray[DFIELD_t, ndim=1] cross_clustering):
 
     cdef:
-        unsigned int m = len(nodes1), n = len(nodes2)
-        unsigned int i, j, k
-        INTTYPE_t n1, n2, n3
+        int m = int(len(nodes1)), n = int(len(nodes2))
+        int i, j, k
+        NODE_t n1, n2, n3
         long counter
 
     for i in range(m):
         n1 = nodes1[i]
         # check if node1[i] has cross degree larger than 1
         if norm[i]:
             counter = 0
@@ -342,54 +286,52 @@
                         n3 = nodes2[k]
                         if A[n2, n3] and A[n3, n1]:
                             counter += 1
             cross_clustering[i] = counter / norm[i]
 
 
 def _nsi_cross_local_clustering(
-    np.ndarray[INTTYPE_t, ndim=2] A, np.ndarray[FLOATTYPE_t, ndim=1] nsi_cc,
-    np.ndarray[INTTYPE_t, ndim=1] nodes1, np.ndarray[INTTYPE_t, ndim=1] nodes2,
-    np.ndarray[FLOATTYPE_t, ndim=1] node_weights):
+    ndarray[ADJ_t, ndim=2] A,
+    ndarray[DFIELD_t, ndim=1] nsi_cc,
+    ndarray[NODE_t, ndim=1] nodes1, ndarray[NODE_t, ndim=1] nodes2,
+    ndarray[DWEIGHT_t, ndim=1] node_weights):
 
     cdef:
-        unsigned int m = len(nodes1), n = len(nodes2)
-        unsigned int v, p, q
-        INTTYPE_t node_v, node_p, node_q
-        FLOATTYPE_t weight_p
+        int m = int(len(nodes1)), n = int(len(nodes2))
+        int v, p, q
+        NODE_t node_v, node_p, node_q
+        DWEIGHT_t weight_p
 
     for v in range(m):
         node_v = nodes1[v]
         for p in range(n):
             node_p = nodes2[p]
             if A[node_v, node_p]:
                 weight_p = node_weights[node_p]
                 nsi_cc[v] += weight_p * weight_p
                 for q in range(p + 1, n):
                     node_q = nodes2[q]
                     if A[node_p, node_q] and A[node_q, node_v]:
-                        nsi_cc[v] += 2 * weight_p * node_weights[node_q]
+                        nsi_cc[v] += <WEIGHT_t>2 * weight_p * node_weights[node_q]
 
 
 # network =====================================================================
 
-def _higher_order_transitivity4(int N, np.ndarray[short, ndim=2] A):
-    return _higher_order_transitivity4_fast(N, <short*> np.PyArray_DATA(A))
-
 
 def _local_cliquishness_4thorder(
-    int N, np.ndarray[INTTYPE_t, ndim=2] A,
-    np.ndarray[INTTYPE_t, ndim=1] degree):
+    int N, ndarray[ADJ_t, ndim=2] A, ndarray[DEGREE_t, ndim=1] degree):
 
     cdef:
-        unsigned int order = 4, index
-        INTTYPE_t node1, node2, node3, degree_i
+        int i, j, k, l
+        int index
+        NODE_t node1, node2, node3, degree_i, order = 4
         long counter
-        np.ndarray[INTTYPE_t, ndim=1] neighbors = np.zeros(N, dtype=INTTYPE)
-        np.ndarray[FLOATTYPE_t, ndim=1] local_cliquishness = \
-            np.zeros(N, dtype=FLOATTYPE)
+        ndarray[NODE_t, ndim=1] neighbors = np.zeros(N, dtype=NODE)
+        ndarray[DFIELD_t, ndim=1] local_cliquishness = \
+            np.zeros(N, dtype=DFIELD)
 
     # Iterate over all nodes
     for i in range(N):
         # If degree is smaller than order - 1, set local cliquishness to 0
         degree_i = degree[i]
         if degree_i >= order - 1:
             # Get neighbors of node i
@@ -405,30 +347,29 @@
                 for k in range(degree_i):
                     node2 = neighbors[k]
                     if A[node1, node2] == 1:
                         for l in range(degree_i):
                             node3 = neighbors[l]
                             if A[node2, node3] == 1 and A[node3, node1] == 1:
                                 counter += 1
-            local_cliquishness[i] = float(counter) / degree_i /\
-                (degree_i - 1) / (degree_i - 2)
+            local_cliquishness[i] = counter /\
+                (degree_i * (degree_i - 1) * (degree_i - 2))
     return local_cliquishness
 
 
 def _local_cliquishness_5thorder(
-    int N, np.ndarray[INTTYPE_t, ndim=2] A,
-    np.ndarray[INTTYPE_t, ndim=1] degree):
+    int N, ndarray[ADJ_t, ndim=2] A, ndarray[DEGREE_t, ndim=1] degree):
 
     cdef:
-        unsigned int index, order = 5
-        INTTYPE_t j, node1, node2, node3, node4, degree_i
+        int i, index
+        NODE_t j, k, l, m, node1, node2, node3, node4, degree_i, order = 5
         long counter
-        np.ndarray[INTTYPE_t, ndim=1] neighbors = np.zeros(N, dtype=INTTYPE)
-        np.ndarray[FLOATTYPE_t, ndim=1] local_cliquishness = \
-            np.zeros(N, dtype=FLOATTYPE)
+        ndarray[NODE_t, ndim=1] neighbors = np.zeros(N, dtype=NODE)
+        ndarray[DFIELD_t, ndim=1] local_cliquishness = \
+            np.zeros(N, dtype=DFIELD)
 
     # Iterate over all nodes
     for i in range(N):
         # If degree is smaller than order - 1, set local cliquishness to 0
         degree_i = degree[i]
         if degree_i >= order - 1:
             # Get neighbors of node i
@@ -449,150 +390,134 @@
                             if A[node1, node3] == 1 and A[node2, node3] == 1:
                                 for m in range(degree_i):
                                     node4 = neighbors[m]
                                     if (A[node1, node4] == 1 and
                                         A[node2, node4] == 1 and
                                         A[node3, node4] == 1):
                                         counter += 1
-            local_cliquishness[i] = float(counter) / degree_i /\
-                (degree_i - 1) / (degree_i - 2) / (degree_i -3)
+            local_cliquishness[i] = counter /\
+                (degree_i * (degree_i - 1) * (degree_i - 2) * (degree_i -3))
     return local_cliquishness
 
 
 def _nsi_betweenness(
-    int N, int E, np.ndarray[FLOATTYPE_t, ndim=1] w,
-    np.ndarray[INTTYPE_t, ndim=1] k, int j ,
-    np.ndarray[FLOATTYPE_t, ndim=1] betweenness_to_j,
-    np.ndarray[FLOATTYPE_t, ndim=1] excess_to_j,
-    np.ndarray[INTTYPE_t, ndim=1] offsets,
-    np.ndarray[INTTYPE_t, ndim=1] flat_neighbors,
-    np.ndarray[FLOATTYPE_t, ndim=1] is_source,
-    np.ndarray[INTTYPE_t, ndim=1] flat_predecessors):
-
-    cdef:
-        unsigned int qi, oi, queue_len, l_index, ql, fi
-        INTTYPE_t l, i, next_d, dl, ol
-        float base_factor
-        np.ndarray[INTTYPE_t, ndim=1] distances_to_j =\
-            2 * N * np.ones(N, dtype=INTTYPE)
-        np.ndarray[INTTYPE_t, ndim=1] n_predecessors =\
-            np.zeros(N, dtype=INTTYPE)
-        np.ndarray[INTTYPE_t, ndim=1] queue =\
-          np.zeros(N, dtype=INTTYPE)
-        np.ndarray[FLOATTYPE_t, ndim=1] multiplicity_to_j =\
-            np.zeros(N, dtype=FLOATTYPE)
-
-    # init distances to j and queue of nodes by distance from j
-    for l in range(N):
-        # distances_to_j[l] = 2 * N
-        # n_predecessors[l] = 0
-        # multiplicity_to_j[l] = 0.0
-        # initialize contribution of paths ending in j to the betweenness of l
-        excess_to_j[l] = betweenness_to_j[l] = is_source[l] * w[l]
-
-    distances_to_j[j] = 0
-    queue[0] = j
-    queue_len = 1
-    multiplicity_to_j[j] = w[j]
-
-    # process the queue forward and grow it on the way: (this is the standard
-    # breadth-first search giving all the shortest paths to j)
-    qi = 0
-    while qi < queue_len:
-    #for qi in range(queue_len):
-        i = queue[qi]
-        if i == -1:
-            # this should never happen ...
-            print("Opps: %d,%d,%d\n" % qi, queue_len, i)
-            break
-        next_d = distances_to_j[i] + 1
-        #iterate through all neighbors l of i
-        oi = offsets[i]
-        for l_index in range(oi, oi+k[i]):
-            # if on a shortes j-l-path, register i as predecessor of l
-            l = flat_neighbors[l_index]
-            dl = distances_to_j[l]
-            if dl >= next_d:
-                fi = offsets[l] + n_predecessors[l]
-                n_predecessors[l] += 1
-                flat_predecessors[fi] = i
-                multiplicity_to_j[l] += w[l] * multiplicity_to_j[i]
-                if dl > next_d:
-                    distances_to_j[l] = next_d
-                    queue[queue_len] = l
-                    queue_len += 1
-        qi += 1
-
-    # process the queue again backward: (this is Newman's 2nd part where
-    # the contribution of paths ending in j to the betweenness of all nodes
-    # is computed recursively by traversing the shortest paths backwards)
-    for ql in range(queue_len-1, -1, -1):
-        l = queue[ql]
-        if l == -1:
-            print("Opps: %d,%d,%d\n" % ql, queue_len, l)
-            break
-        if l == j:
-            # set betweenness and excess to zero
-            betweenness_to_j[l] = excess_to_j[l] = 0
-        else:
-            # otherwise, iterate through all predecessors i of l:
-            base_factor = w[l] / multiplicity_to_j[l]
-            ol = offsets[l]
-            for fi in range(ol, ol+n_predecessors[l]):
-                # add betweenness to predecessor
-                i = flat_predecessors[fi]
-                betweenness_to_j[i] += betweenness_to_j[l] * base_factor * \
-                    multiplicity_to_j[i]
-
-
-def _newman_betweenness_badly_cython(np.ndarray[INTTYPE_t, ndim=2] adjacency,
-    np.ndarray[FLOAT64TYPE_t, ndim=2] T, np.ndarray[FLOAT64TYPE_t, ndim=2] rwb,
-    N):
+    int N, ndarray[DWEIGHT_t, ndim=1] w,
+    ndarray[DEGREE_t, ndim=1] k,
+    ndarray[NODE_t, ndim=1] flat_neighbors,
+    ndarray[MASK_t, ndim=1] is_source,
+    ndarray[NODE_t, ndim=1] targets):
+    """
+    Performs Newman's algorithm. [Newman2001]_
+    """
 
     cdef:
-        int i, j, s, t
-        double norm, sum, Tis, Tit, Tjs, Tjt
-
-    norm = 2 / (N * (N - 1))
+        long int E = len(flat_neighbors)
+        int j, qi, oi, queue_len, l_index, ql
+        NODE_t l, i, next_d, dl, ol, fi
+        DFIELD_t base_factor
+        ndarray[NODE_t, ndim=1] offsets = np.zeros(N, dtype=NODE)
+        ndarray[NODE_t, ndim=1] distances_to_j = np.ones(N, dtype=NODE)
+        ndarray[NODE_t, ndim=1] n_predecessors = np.zeros(N, dtype=NODE)
+        ndarray[NODE_t, ndim=1] flat_predecessors = np.zeros(E, dtype=NODE)
+        ndarray[NODE_t, ndim=1] queue = np.zeros(N, dtype=NODE)
+        ndarray[DFIELD_t, ndim=1] multiplicity_to_j = np.zeros(N, dtype=DFIELD)
+        ndarray[DFIELD_t, ndim=1] betweenness_to_j = np.zeros(N, dtype=DFIELD)
+        ndarray[DFIELD_t, ndim=1] excess_to_j = np.zeros(N, dtype=DFIELD)
+        ndarray[DFIELD_t, ndim=1] betweenness_times_w = np.zeros(N, dtype=DFIELD)
+
+    # init node offsets
+    # NOTE: We don't use k.cumsum() since that uses too much memory!
+    for i in range(1, N):
+        offsets[i] = offsets[i-1] + k[i-1]
+
+    for j in targets:
+        # init distances to j and queue of nodes by distance from j
+        distances_to_j.fill(2 * N)
+        n_predecessors.fill(0)
+        flat_predecessors.fill(0)
+        queue.fill(0)
+        multiplicity_to_j.fill(0)
+
+        # init contribution of paths ending in j to the betweenness of l
+        for l in range(N):
+            excess_to_j[l] = betweenness_to_j[l] = is_source[l] * w[l]
+
+        distances_to_j[j] = 0
+        queue[0] = j
+        queue_len = 1
+        multiplicity_to_j[j] = w[j]
+
+        # process the queue forward and grow it on the way: (this is the
+        # standard breadth-first search giving all the shortest paths to j)
+        qi = 0
+        while qi < queue_len:
+            i = queue[qi]
+            if i == -1:
+                # this should never happen ...
+                print("Opps: %d,%d,%d\n" % qi, queue_len, i)
+                break
+            next_d = distances_to_j[i] + 1
+            # iterate through all neighbors l of i
+            oi = offsets[i]
+            for l_index in range(oi, oi+k[i]):
+                # if on a shortest j-l-path, register i as predecessor of l
+                l = flat_neighbors[l_index]
+                dl = distances_to_j[l]
+                if dl >= next_d:
+                    fi = offsets[l] + n_predecessors[l]
+                    n_predecessors[l] += 1
+                    flat_predecessors[fi] = i
+                    multiplicity_to_j[l] += w[l] * multiplicity_to_j[i]
+                    if dl > next_d:
+                        distances_to_j[l] = next_d
+                        queue[queue_len] = l
+                        queue_len += 1
+            qi += 1
+
+        # process the queue again backward: (this is Newman's 2nd part where the
+        # contribution of paths ending in j to the betweenness of all nodes is
+        # computed recursively by traversing the shortest paths backwards)
+        for ql in range(queue_len-1, -1, -1):
+            l = queue[ql]
+            if l == -1:
+                print("Opps: %d,%d,%d\n" % ql, queue_len, l)
+                break
+            if l == j:
+                # set betweenness and excess to zero
+                betweenness_to_j[l] = excess_to_j[l] = 0
+            else:
+                # otherwise, iterate through all predecessors i of l:
+                base_factor = w[l] / multiplicity_to_j[l]
+                ol = offsets[l]
+                for fi in range(ol, ol+n_predecessors[l]):
+                    # add betweenness to predecessor
+                    i = flat_predecessors[fi]
+                    betweenness_to_j[i] += betweenness_to_j[l] * base_factor * \
+                        multiplicity_to_j[i]
 
-    for i in range(N):
-        for s in range(N):
-            for t in range(s):
-                if (i == s or i == t):
-                    rwb[i] += 1
-                else:
-                    sum = 0
-                    Tis = T[i,s]
-                    Tit = T[i,t]
-                    for j in range(N):
-                        if (adjacency[i,j] == 1):
-                            Tjs = T(j,s)
-                            Tjt = T(j,t)
-                            sum += np.abs(Tis - Tit - Tjs + Tjt)
-                    rwb[i] += 0.5 * sum;
-        rwb[i] *= norm
-    return rwb
+        betweenness_times_w += w[j] * (betweenness_to_j - excess_to_j)
+    return betweenness_times_w
 
 
-def _cy_mpi_newman_betweenness(
-    np.ndarray[INTTYPE_t, ndim=2] this_A, np.ndarray[FLOATTYPE_t, ndim=2] V,
+def _mpi_newman_betweenness(
+    ndarray[ADJ_t, ndim=2] this_A, ndarray[DFIELD_t, ndim=2] V,
     int N, int start_i, int end_i):
     """
     This function does the outer loop for a certain range start_i-end_i of
     c's.  it gets the full V matrix but only the needed rows of the A matrix.
     Each parallel job will consist of a call to this function:
     """
 
     cdef:
         int i_rel, j, s, t, i_abs
-        float sum_s, sum_j, Vis_minus_Vjs
+        double sum_s, sum_j, Vis_minus_Vjs
 
         int this_N = end_i - start_i
-        np.ndarray[FLOATTYPE_t, ndim=1] this_betweenness =\
-            np.zeros(this_N, dtype=FLOATTYPE)
+        ndarray[DFIELD_t, ndim=1] this_betweenness = \
+            np.zeros(this_N, dtype=DFIELD)
 
     for i_rel in range(this_N):
         # correct i index for V matrix
         i_abs = i_rel + start_i
         for j in range(N):
              if this_A[i_rel, j]:
                 sum_j = 0.0
@@ -606,27 +531,26 @@
                                              V[j, t])
                         sum_j += sum_s
                 this_betweenness[i_rel] += sum_j
 
     return this_betweenness, start_i, end_i
 
 
-def _cy_mpi_nsi_newman_betweenness(
-    np.ndarray[INTTYPE_t, ndim=2] this_A, np.ndarray[FLOATTYPE_t, ndim=2] V,
-    int N, np.ndarray[FLOATTYPE_t, ndim=1] w,
-    np.ndarray[INTTYPE_t, ndim=2] this_not_adj_or_equal, int start_i,
-    int end_i):
+def _mpi_nsi_newman_betweenness(
+    ndarray[ADJ_t, ndim=2] this_A,
+    ndarray[DFIELD_t, ndim=2] V, int N, ndarray[DWEIGHT_t, ndim=1] w,
+    ndarray[MASK_t, ndim=2] this_not_adj_or_equal, int start_i, int end_i):
 
     cdef:
         int i_rel, j, s, t, i_abs
-        float sum_s, sum_j, Vis_minus_Vjs
+        double sum_s, sum_j, Vis_minus_Vjs
 
         int this_N = end_i - start_i
-        np.ndarray[FLOATTYPE_t, ndim=1] this_betweenness =\
-            np.zeros(this_N, dtype=FLOATTYPE)
+        ndarray[DFIELD_t, ndim=1] this_betweenness =\
+            np.zeros(this_N, dtype=DFIELD)
 
     for i_rel in range(this_N):
         i_abs = i_rel + start_i
         for j in range(N):
              if this_A[i_rel, j]:
                 sum_j = 0.0
                 for s in range(N):
@@ -640,25 +564,24 @@
                         sum_j += w[s] * sum_s
                 this_betweenness[i_rel] += w[j] * sum_j
 
     return this_betweenness, start_i, end_i
 
 
 def _do_nsi_clustering_I(
-    int n_cands, np.ndarray[INTTYPE_t, ndim=1] cands,
-    np.ndarray[INT16TYPE_t, ndim=1] D_cluster,
-    np.ndarray[FLOATTYPE_t, ndim=1] w, double d0,
-    np.ndarray[INT32TYPE_t, ndim=1] D_firstpos,
-    np.ndarray[INT32TYPE_t, ndim=1] D_nextpos, int N, dict dict_D,
-    dict dict_Delta):
+    int n_cands, ndarray[NODE_t, ndim=1] cands,
+    ndarray[DEGREE_t, ndim=1] D_cluster,
+    ndarray[DFIELD_t, ndim=1] w, double d0,
+    ndarray[NODE_t, ndim=1] D_firstpos, ndarray[NODE_t, ndim=1] D_nextpos,
+    int N, dict dict_D, dict dict_Delta):
 
     cdef:
         int ca, ij, i, j, posh, h, ih, jh
-        float wi, wj, wjd0, Delta_inc, wh, Dih, Djh, Dch_wc, Dch_wc_Dih_wi, \
-            Dch_wc_Dih_wj, whd0, Dch_wc_whd0
+        double wi, wj, wc, wjd0, Delta_inc, wh, whd0, Dih, Djh, Dch_wc, \
+            Dch_wc_Dih_wi, Dch_wc_Djh_wj, Dch_wc_whd0
 
     # loop thru candidates:
     for ca in range(n_cands):
         ij = cands[ca]
         i = int(ij/N)
         j = ij%N
         wi = w[i]
@@ -710,35 +633,35 @@
 
         dict_Delta[ij] = float(dict_Delta[ij]) + Delta_inc
 
     return dict_Delta
 
 
 def _do_nsi_clustering_II(int a, int b,
-    np.ndarray[INT16TYPE_t, ndim=1] D_cluster,
-    np.ndarray[FLOATTYPE_t, ndim=1] w, double d0,
-    np.ndarray[INT32TYPE_t, ndim=1] D_firstpos,
-    np.ndarray[INT32TYPE_t, ndim=1] D_nextpos, int N, dict dict_D,
-    dict dict_Delta):
+    ndarray[DEGREE_t, ndim=1] D_cluster,
+    ndarray[DFIELD_t, ndim=1] w, double d0,
+    ndarray[NODE_t, ndim=1] D_firstpos, ndarray[NODE_t, ndim=1] D_nextpos,
+    int N, dict dict_D, dict dict_Delta):
 
     cdef:
-        float wa = w[a], wb = w[b], wc = wa+wb, wad0 = wa*d0, wbd0 = wb*d0
-        float wa1, wa1sq, wa1d0, Da1a1, Da1a, Da1b, Da1c, wb1, wb1d0, wb1sq, \
+        double  wa = w[a], wb = w[b], wc = wa+wb, wad0 = wa*d0, wbd0 = wb*d0, \
+                wa1, wa1sq, wa1d0, Da1a1, Da1a, Da1b, Da1c, wb1, wb1d0, wb1sq, \
                 wa1b1, wc1, Db1b1, Da1b1, Dc1c1_wc1sq, \
-                Dc1c1_wc1sq_Da1a1_wa1sq, Dc1c1_wc1sq_Da1a1_wb1sq, \
-                Dc1c1_wc1sq_Da1b1_wa1b1, Delta_new, wc2, Da1c2, Db1c2, \
+                Dc1c1_wc1sq_Da1a1_wa1sq, Dc1c1_wc1sq_Da1b1_wa1b1, \
+                Dc1c1_wc1sq_Db1b1_wb1sq, \
+                Delta_new, Delta_inc, wc2 = 0, Da1c2, Db1c2, \
                 Dc1c2_wc1, Dc1c2_wc1_Da1c2_wa1, Dc1c2_wc1_Db1c2_wb1, \
                 Dc1c2_wc1_wc2_d0, Db1a, Db1b, Db1c, Dc1a_wc1, Dc1b_wc1, \
                 Dc1c_wc1, Dc1c_wc1_Da1c_wa1, Dc1a_wc1_Da1a_wa1, \
                 Dc1b_wc1_Da1b_wa1, Dc1c_wc1_Db1c_wb1, Dc1a_wc1_Db1a_wb1, \
                 Dc1b_wc1_Db1b_wb1
         int N1 = N+1, posa1 = D_firstpos[a] # a meaning c!
-        int a1, a1N, a1a1, a1a, a1b, posb1, b1, b1N, posc2, b1c2, b1a, b1b, \
-                a1b1key, b1b1
-
+        int a1, a1N, a1a1, a1a, a1b, posb1, b1, b1N, posc2, b1c2 = 0, b1a, b1b, \
+            a1b1key, b1b1
+        DEGREE_t c2
 
     while (posa1 > 0):
         a1 = D_cluster[posa1]
         a1N = a1*N
         a1a1 = a1*N1
         a1a = a1N+a
         a1b = a1N+b
@@ -780,27 +703,27 @@
                     Db1b1 = dict_D[b1b1]
                 else:
                     Db1b1 = 0.0
                 if (dict_D.has_key(a1b1key)):
                     Da1b1 = dict_D[a1b1key]
                 else:
                     Da1b1 = wb1 * wa1d0
-                Dc1c1_wc1sq = (Da1a1+Db1b1+2.0*Da1b1) / (wc1*wc1)
+                Dc1c1_wc1sq = (Da1a1+Db1b1+<float>2*Da1b1) / (wc1*wc1)
                 if (b1 == a): # a meaning c!
                     Dc1c1_wc1sq_Da1a1_wa1sq = Dc1c1_wc1sq - Da1a1/wa1sq
                     Dc1c1_wc1sq_Db1b1_wb1sq = Dc1c1_wc1sq - Db1b1/wb1sq
                     Dc1c1_wc1sq_Da1b1_wa1b1 = Dc1c1_wc1sq - Da1b1/wa1b1
                     Delta_new = wa1sq * Dc1c1_wc1sq_Da1a1_wa1sq * \
                                 Dc1c1_wc1sq_Da1a1_wa1sq + \
                                 wb1sq * Dc1c1_wc1sq_Db1b1_wb1sq * \
                                 Dc1c1_wc1sq_Db1b1_wb1sq + \
-                                2.0 * wa1b1 * Dc1c1_wc1sq_Da1b1_wa1b1 * \
+                                <float>2 * wa1b1 * Dc1c1_wc1sq_Da1b1_wa1b1 * \
                                 Dc1c1_wc1sq_Da1b1_wa1b1
                     # loop thru all nbs c2 of a1 other than b1:
-                    posc2 = D_firstpos[a1], c2
+                    posc2 = D_firstpos[a1]
                     while (posc2 > 0):
                         c2 = D_cluster[posc2]
                         if (c2 != b1):
                             b1c2 = b1N+c2
                             wc2 = w[c2]
                             Da1c2 = dict_D[a1N+c2]
                             if (dict_D.has_key(b1c2)):
@@ -860,109 +783,116 @@
                     Dc1c_wc1 = (Da1c + Db1c) / wc1
                     Dc1c_wc1_Da1c_wa1 = Dc1c_wc1 - Da1c/wa1
                     Dc1a_wc1_Da1a_wa1 = Dc1a_wc1 - Da1a/wa1
                     Dc1b_wc1_Da1b_wa1 = Dc1b_wc1 - Da1b/wa1
                     Dc1c_wc1_Db1c_wb1 = Dc1c_wc1 - Db1c/wb1
                     Dc1a_wc1_Db1a_wb1 = Dc1a_wc1 - Db1a/wb1
                     Dc1b_wc1_Db1b_wb1 = Dc1b_wc1 - Db1b/wb1
-                    Delta_inc = 2 * (Dc1c_wc1_Da1c_wa1*Dc1c_wc1_Da1c_wa1/wc - \
-                                     Dc1a_wc1_Da1a_wa1*Dc1a_wc1_Da1a_wa1/wa - \
-                                     Dc1b_wc1_Da1b_wa1*Dc1b_wc1_Da1b_wa1/wb)/ \
+                    Delta_inc = (Dc1c_wc1_Da1c_wa1*Dc1c_wc1_Da1c_wa1/wc - \
+                                 Dc1a_wc1_Da1a_wa1*Dc1a_wc1_Da1a_wa1/wa - \
+                                 Dc1b_wc1_Da1b_wa1*Dc1b_wc1_Da1b_wa1/wb)/ \
                                 wa1 + \
-                                2 * (Dc1c_wc1_Db1c_wb1*Dc1c_wc1_Db1c_wb1/wc - \
-                                     Dc1a_wc1_Db1a_wb1*Dc1a_wc1_Db1a_wb1/wa - \
-                                     Dc1b_wc1_Db1b_wb1*Dc1b_wc1_Db1b_wb1/wb)/ \
+                                (Dc1c_wc1_Db1c_wb1*Dc1c_wc1_Db1c_wb1/wc - \
+                                 Dc1a_wc1_Db1a_wb1*Dc1a_wc1_Db1a_wb1/wa - \
+                                 Dc1b_wc1_Db1b_wb1*Dc1b_wc1_Db1b_wb1/wb)/ \
                                 wb1
+                    Delta_inc *= <float>2
                     dict_Delta[a1b1key] = float(dict_Delta[a1b1key])+Delta_inc
 
             posb1 = D_nextpos[posb1]
 
         posa1 = D_nextpos[posa1]
 
     return dict_Delta
 
 
 def _do_nsi_hamming_clustering(int n2, int nActiveIndices, float mind0,
     float minwp0, int lastunited, int part1, int part2,
-    np.ndarray[FLOATTYPE_t, ndim=2] distances,
-    np.ndarray[INTTYPE_t, ndim=1] theActiveIndices,
-    np.ndarray[FLOATTYPE_t, ndim=2] linkedWeights,
-    np.ndarray[FLOATTYPE_t, ndim=2] weightProducts,
-    np.ndarray[FLOATTYPE_t, ndim=2] errors,
-    np.ndarray[FLOATTYPE_t, ndim=1] results,
-    np.ndarray[INTTYPE_t, ndim=2] mayJoin):
+    ndarray[DFIELD_t, ndim=2] distances,
+    ndarray[NODE_t, ndim=1] theActiveIndices,
+    ndarray[DFIELD_t, ndim=2] linkedWeights,
+    ndarray[DFIELD_t, ndim=2] weightProducts,
+    ndarray[DFIELD_t, ndim=2] errors,
+    ndarray[DFIELD_t, ndim=1] results,
+    ndarray[MASK_t, ndim=2] mayJoin):
 
-    return _do_nsi_hamming_clustering_fast(n2, nActiveIndices, mind0, minwp0,
+    _do_nsi_hamming_clustering_fast(n2, nActiveIndices, mind0, minwp0,
         lastunited, part1, part2,
-        <float*> np.PyArray_DATA(distances),
-        <int*> np.PyArray_DATA(theActiveIndices),
-        <float*> np.PyArray_DATA(linkedWeights),
-        <float*> np.PyArray_DATA(weightProducts),
-        <float*> np.PyArray_DATA(errors),
-        <float*> np.PyArray_DATA(results),
-        <int*> np.PyArray_DATA(mayJoin))
+        <DFIELD_t*> cnp.PyArray_DATA(distances),
+        <int*> cnp.PyArray_DATA(theActiveIndices),
+        <DFIELD_t*> cnp.PyArray_DATA(linkedWeights),
+        <DFIELD_t*> cnp.PyArray_DATA(weightProducts),
+        <DFIELD_t*> cnp.PyArray_DATA(errors),
+        <DFIELD_t*> cnp.PyArray_DATA(results),
+        <int*> cnp.PyArray_DATA(mayJoin))
 
 
 # grid ========================================================================
 
-def _cy_calculate_angular_distance(
-    np.ndarray[FLOAT32TYPE_t, ndim=1] cos_lat,
-    np.ndarray[FLOAT32TYPE_t, ndim=1] sin_lat,
-    np.ndarray[FLOAT32TYPE_t, ndim=1] cos_lon,
-    np.ndarray[FLOAT32TYPE_t, ndim=1] sin_lon,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] cosangdist, unsigned int N):
+
+def _calculate_angular_distance(
+    ndarray[FIELD_t, ndim=1] cos_lat,
+    ndarray[FIELD_t, ndim=1] sin_lat,
+    ndarray[FIELD_t, ndim=1] cos_lon,
+    ndarray[FIELD_t, ndim=1] sin_lon,
+    ndarray[FIELD_t, ndim=2] cosangdist, int N):
 
     cdef:
-        FLOAT32TYPE_t expr
-        unsigned int i,j
+        FIELD_t expr
+        int i,j
 
     for i in range(N):
         for j in range(i+1):
             expr = sin_lat[i]*sin_lat[j] + cos_lat[i]*cos_lat[j] * \
                 (sin_lon[i]*sin_lon[j] + cos_lon[i]*cos_lon[j])
 
             if expr > 1:
                 expr = 1
             elif expr < -1:
                 expr = -1
 
             cosangdist[i, j] = cosangdist[j, i] = expr
 
 
-def _euclidean_distance(
-    np.ndarray[FLOAT32TYPE_t, ndim=1] x, np.ndarray[FLOAT32TYPE_t, ndim=1] y,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] distance, unsigned int N):
+def _calculate_euclidean_distance(
+    ndarray[FIELD_t, ndim=2] x,
+    ndarray[FIELD_t, ndim=2] distance,
+    int N_dim, int N_nodes):
 
     cdef:
-        unsigned int i,j
-        FLOAT32TYPE_t expr
+        int i,j,k
+        FIELD_t expr
 
-    for i in range(N):
+    for i in range(N_nodes):
         for j in range(i+1):
-            expr = (x[i]-x[j])**2 + (y[i]-y[j])**2
-            distance[i, j] = distance[j, i] = expr**(0.5)
+            expr = 0
+            for k in range(N_dim):
+                expr += (x[k, i]-x[k, j])**2
+            distance[i, j] = distance[j, i] = expr**(<FIELD_t> 0.5)
 
 
 # resistive_network ===========================================================
 
+
 def _vertex_current_flow_betweenness(int N, double Is, double It,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] admittance,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] R, int i):
+    ndarray[FIELD_t, ndim=2] admittance, ndarray[FIELD_t, ndim=2] R,
+    int i):
 
     return _vertex_current_flow_betweenness_fast(N, Is, It,
-        <float*> np.PyArray_DATA(admittance),
-        <float*> np.PyArray_DATA(R), i)
+        <FIELD_t*> cnp.PyArray_DATA(admittance),
+        <FIELD_t*> cnp.PyArray_DATA(R), i)
+
 
 def _edge_current_flow_betweenness(int N, double Is, double It,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] admittance,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] R,):
+    ndarray[FIELD_t, ndim=2] admittance,
+    ndarray[FIELD_t, ndim=2] R,):
 
     # alloc output
-    cdef np.ndarray[FLOAT32TYPE_t, ndim=2, mode='c'] ECFB = \
-            np.zeros((N, N), dtype='float32')
+    cdef ndarray[FIELD_t, ndim=2, mode='c'] ECFB = \
+            np.zeros((N, N), dtype=FIELD)
 
     _edge_current_flow_betweenness_fast(N, Is, It,
-        <float*> np.PyArray_DATA(admittance),
-        <float*> np.PyArray_DATA(R),
-        <float*> np.PyArray_DATA(ECFB))
+        <FIELD_t*> cnp.PyArray_DATA(admittance),
+        <FIELD_t*> cnp.PyArray_DATA(R),
+        <FIELD_t*> cnp.PyArray_DATA(ECFB))
 
     return ECFB
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/netcdf_dictionary.py` & `pyunicorn-0.7.0/src/pyunicorn/core/netcdf_dictionary.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -20,24 +17,25 @@
 appropriate Python dictionaries, allowing NetCDF4 compression methods.
 """
 
 #
 #  Imports
 #
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
 
-#  Import netCDF4 for Dataset class
 try:
-    from netCDF4 import Dataset
+    from h5netcdf.legacyapi import Dataset
 except ImportError:
-    print("pyunicorn: Package netCDF4 could not be loaded. "
-          "Some functionality in class NetCDFDictionary might not be "
-          "available!")
+    try:
+        from netCDF4 import Dataset
+    except ImportError:
+        print("pyunicorn: Packages netCDF4 or h5netcdf could not be loaded. "
+              "Some functionality in class NetCDFDictionary might not be "
+              "available!")
 
 
 #
 #  Define class NetCDF
 #
 
 class NetCDFDictionary:
@@ -79,44 +77,45 @@
         The higher, the less progress info is output.
         """
 
     def __str__(self):
         """
         Return a string representation of the object.
         """
-        text = 'NetCDFDictionary:\nGlobal attributes:\n%s\nVariables:' % (
-            self.dict["global_attributes"])
+        text = (f'NetCDFDictionary:\nGlobal attributes:\n'
+                f'{self.dict["global_attributes"]}\nVariables:')
+
         for key in self.dict["variables"].keys():
-            text += '\n\t%s\t-> array shape %s' % (
-                key, self.dict["variables"][key]["array"].shape)
+            text += (f'\n\t{key}\t-> array shape'
+                     f'{self.dict["variables"][key]["array"].shape}')
         return text
 
     #
     #  Define methods for NetCDF4 files via NetCDF4 module
     #
 
     @staticmethod
-    def from_file(file_name, with_array=('all')):
+    def from_file(file_name, with_array='all'):
         """
         Load NetCDF4 file into a dictionary.
 
         Supported file types ``file_type`` are:
           - "NetCDF"
           - "NetCDF4"
 
         :arg str file_name: The name of the data file.
         :arg [str] with_array: Names of data arrays to be loaded completely.
         :rtype: NetCDF instance
         """
         #  Open NetCDF4 file
         try:
             cdf = Dataset(file_name, "r")
-            print("MODULE: File %s opened." % file_name)
+            print(f"MODULE: File {file_name} opened.")
         except RuntimeError:
-            print("MODULE: File %s couldn't be opened." % file_name)
+            print(f"MODULE: File {file_name} couldn't be opened.")
             return None
 
         #  Create empty dictionary structure
         content = {"global_attributes": {}, "dimensions": {}, "variables": {}}
         #  Copy all global attributes and all dimensions
         content["global_attributes"] = cdf.__dict__
         for dim_name, dim_obj in cdf.dimensions.iteritems():
@@ -130,27 +129,27 @@
             #  Copy type, dimensions and variable attributes
             content["variables"][var]["type"] = cdf.variables[var].dtype.char
             content["variables"][var]["dims"] = cdf.variables[var].dimensions
             content["variables"][var]["attributes"] = \
                 cdf.variables[var].__dict__
 
             #  Load data if wanted
-            if var in with_array or 'all' in with_array:
+            if var in with_array or with_array == 'all':
                 try:
                     content["variables"][var]["array"] = cdf.variables[var][:]
-                    print("MODULE: Array %s loaded to dictionary." % var)
+                    print(f"MODULE: Array {var} loaded to dictionary.")
                 except MemoryError:
-                    print("Memory Error during loading of array %s" % var)
+                    print(f"Memory Error during loading of array {var}")
                 except RuntimeError:
-                    print("Other Error during loading of array %s" % var)
+                    print(f"Other Error during loading of array {var}")
 
                 try:
                     content["variables"][var]["array"] = \
                         content["variables"][var]["array"].astype('float32')
-                    print("MODULE: Array %s converted to 'float32'." % var)
+                    print(f"MODULE: Array {var} converted to 'float32'.")
                 except MemoryError:
                     print("MODULE: Memory Error during conversion of "
                           f"array {var}.")
                 except RuntimeError:
                     print("MODULE: Other Error during conversion of "
                           f"array {var}.")
 
@@ -186,15 +185,15 @@
         :arg int comp_level: Level of compression, between 0 (no compression,
             fastest) and 9 (strongest compression, slowest).
         :arg int least_significant_digit: Last precise digit.
         """
         #  Check dictionary for empty entries
         for val in self.dict.keys():
             if not self.dict[val]:
-                print("MODULE: Entry %s is empty." % val)
+                print("MODULE: Entry {val} is empty.")
 
         print(f"MODULE: If {file_name} already existed, old file will be "
               "overwritten.")
         #  Format can be:
         #  NETCDF3_CLASSIC, NETCDF3_64BIT, NETCDF4_CLASSIC, NETCDF4
         cdf = Dataset(file_name, "w", format="NETCDF4")
 
@@ -237,8 +236,8 @@
 
             #  Write all variable attributes to dictionary
             for att in self.dict["variables"][var]["attributes"]:
                 setattr(var_, att,
                         self.dict["variables"][var]["attributes"][att])
 
         cdf.close()
-        print("MODULE: Dictionary saved as NetCDF file %s." % file_name)
+        print("MODULE: Dictionary saved as NetCDF file {file_name}.")
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/network.py` & `pyunicorn-0.7.0/src/pyunicorn/core/network.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12720 +1,12308 @@
-00000000: 2321 2f75 7372 2f62 696e 2f70 7974 686f  #!/usr/bin/pytho
-00000010: 6e0a 2320 2d2a 2d20 636f 6469 6e67 3a20  n.# -*- coding: 
-00000020: 7574 662d 3820 2d2a 2d0a 230a 2320 5468  utf-8 -*-.#.# Th
-00000030: 6973 2066 696c 6520 6973 2070 6172 7420  is file is part 
-00000040: 6f66 2070 7975 6e69 636f 726e 2e0a 2320  of pyunicorn..# 
-00000050: 436f 7079 7269 6768 7420 2843 2920 3230  Copyright (C) 20
-00000060: 3038 2d2d 3230 3139 204a 6f6e 6174 6861  08--2019 Jonatha
-00000070: 6e20 462e 2044 6f6e 6765 7320 616e 6420  n F. Donges and 
-00000080: 7079 756e 6963 6f72 6e20 6175 7468 6f72  pyunicorn author
-00000090: 730a 2320 5552 4c3a 203c 6874 7470 3a2f  s.# URL: <http:/
-000000a0: 2f77 7777 2e70 696b 2d70 6f74 7364 616d  /www.pik-potsdam
-000000b0: 2e64 652f 6d65 6d62 6572 732f 646f 6e67  .de/members/dong
-000000c0: 6573 2f73 6f66 7477 6172 653e 0a23 204c  es/software>.# L
-000000d0: 6963 656e 7365 3a20 4253 4420 2833 2d63  icense: BSD (3-c
-000000e0: 6c61 7573 6529 0a23 0a23 2050 6c65 6173  lause).#.# Pleas
-000000f0: 6520 6163 6b6e 6f77 6c65 6467 6520 616e  e acknowledge an
-00000100: 6420 6369 7465 2074 6865 2075 7365 206f  d cite the use o
-00000110: 6620 7468 6973 2073 6f66 7477 6172 6520  f this software 
-00000120: 616e 6420 6974 7320 6175 7468 6f72 730a  and its authors.
-00000130: 2320 7768 656e 2072 6573 756c 7473 2061  # when results a
-00000140: 7265 2075 7365 6420 696e 2070 7562 6c69  re used in publi
-00000150: 6361 7469 6f6e 7320 6f72 2070 7562 6c69  cations or publi
-00000160: 7368 6564 2065 6c73 6577 6865 7265 2e0a  shed elsewhere..
-00000170: 230a 2320 596f 7520 6361 6e20 7573 6520  #.# You can use 
-00000180: 7468 6520 666f 6c6c 6f77 696e 6720 7265  the following re
-00000190: 6665 7265 6e63 653a 0a23 204a 2e46 2e20  ference:.# J.F. 
-000001a0: 446f 6e67 6573 2c20 4a2e 2048 6569 747a  Donges, J. Heitz
-000001b0: 6967 2c20 422e 2042 6572 6f6e 6f76 2c20  ig, B. Beronov, 
-000001c0: 4d2e 2057 6965 6465 726d 616e 6e2c 204a  M. Wiedermann, J
-000001d0: 2e20 5275 6e67 652c 2051 2e2d 592e 2046  . Runge, Q.-Y. F
-000001e0: 656e 672c 0a23 204c 2e20 5475 7069 6b69  eng,.# L. Tupiki
-000001f0: 6e61 2c20 562e 2053 746f 6c62 6f76 612c  na, V. Stolbova,
-00000200: 2052 2e56 2e20 446f 6e6e 6572 2c20 4e2e   R.V. Donner, N.
-00000210: 204d 6172 7761 6e2c 2048 2e41 2e20 4469   Marwan, H.A. Di
-00000220: 6a6b 7374 7261 2c0a 2320 616e 6420 4a2e  jkstra,.# and J.
-00000230: 204b 7572 7468 732c 2022 556e 6966 6965   Kurths, "Unifie
-00000240: 6420 6675 6e63 7469 6f6e 616c 206e 6574  d functional net
-00000250: 776f 726b 2061 6e64 206e 6f6e 6c69 6e65  work and nonline
-00000260: 6172 2074 696d 6520 7365 7269 6573 2061  ar time series a
-00000270: 6e61 6c79 7369 730a 2320 666f 7220 636f  nalysis.# for co
-00000280: 6d70 6c65 7820 7379 7374 656d 7320 7363  mplex systems sc
-00000290: 6965 6e63 653a 2054 6865 2070 7975 6e69  ience: The pyuni
-000002a0: 636f 726e 2070 6163 6b61 6765 220a 0a22  corn package".."
-000002b0: 2222 0a50 726f 7669 6465 7320 636c 6173  "".Provides clas
-000002c0: 7365 7320 666f 7220 616e 616c 797a 696e  ses for analyzin
-000002d0: 6720 7370 6174 6961 6c6c 7920 656d 6265  g spatially embe
-000002e0: 6464 6564 2063 6f6d 706c 6578 206e 6574  dded complex net
-000002f0: 776f 726b 732c 2068 616e 646c 696e 670a  works, handling.
-00000300: 6d75 6c74 6976 6172 6961 7465 2064 6174  multivariate dat
-00000310: 6120 616e 6420 6765 6e65 7261 7469 6e67  a and generating
-00000320: 2074 696d 6520 7365 7269 6573 2073 7572   time series sur
-00000330: 726f 6761 7465 732e 0a22 2222 0a0a 2320  rogates.."""..# 
-00000340: 6765 6e65 7261 6c20 544f 444f 3a0a 2320  general TODO:.# 
-00000350: 2d20 6669 6e64 2073 6567 6661 756c 7420  - find segfault 
-00000360: 7072 6f62 6c65 6d20 696e 2061 2e77 2e20  problem in a.w. 
-00000370: 7368 6f72 7465 7374 2070 6174 6820 6265  shortest path be
-00000380: 7477 6565 6e6e 6573 730a 2320 2d20 7265  tweenness.# - re
-00000390: 6e61 6d65 2061 772e 2e2e 2074 6f20 6e73  name aw... to ns
-000003a0: 692e 2e2e 2028 6e6f 6465 2073 706c 6974  i... (node split
-000003b0: 7469 6e67 2069 6e76 6172 6961 6e74 290a  ting invariant).
-000003c0: 2320 2d20 696d 706c 656d 656e 7420 2263  # - implement "c
-000003d0: 6f72 7265 6374 6564 2220 6e6f 6465 2073  orrected" node s
-000003e0: 706c 6974 7469 6e67 2069 6e76 6172 6961  plitting invaria
-000003f0: 6e74 206d 6561 7375 7265 7320 6e61 6d65  nt measures name
-00000400: 6420 636e 7369 2e2e 2e0a 2320 2020 2873  d cnsi....#   (s
-00000410: 6565 2070 6170 6572 290a 2320 2d20 696d  ee paper).# - im
-00000420: 706c 656d 656e 7420 4e65 776d 616e 206d  plement Newman m
-00000430: 6f64 756c 6172 6974 7920 616e 6420 6974  odularity and it
-00000440: 6572 6174 6976 6520 6469 7669 7369 6f6e  erative division
-00000450: 0a23 202d 2074 7265 6174 2074 7970 652d  .# - treat type-
-00000460: 7265 6c61 7465 6420 616d 6269 6775 6974  related ambiguit
-00000470: 6965 7320 6d6f 7265 2074 686f 726f 7567  ies more thoroug
-00000480: 686c 790a 2320 2020 2866 6c61 7474 656e  hly.#   (flatten
-00000490: 2829 2c20 6c69 7374 282e 2e2e 292c 2061  (), list(...), a
-000004a0: 7374 7970 6528 2e2e 2e29 2065 7463 2e29  stype(...) etc.)
-000004b0: 0a0a 230a 2320 2049 6d70 6f72 7420 6573  ..#.#  Import es
-000004c0: 7365 6e74 6961 6c20 7061 636b 6167 6573  sential packages
-000004d0: 0a23 0a0a 0a69 6d70 6f72 7420 7379 7320  .#...import sys 
-000004e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000004f0: 2020 2020 2020 2020 2023 2070 6572 666f           # perfo
-00000500: 726d 616e 6365 2074 6573 7469 6e67 0a69  rmance testing.i
-00000510: 6d70 6f72 7420 7469 6d65 0a66 726f 6d20  mport time.from 
-00000520: 6675 6e63 746f 6f6c 7320 696d 706f 7274  functools import
-00000530: 2077 7261 7073 2020 2020 2020 2020 2023   wraps         #
-00000540: 2068 656c 7065 7220 6675 6e63 7469 6f6e   helper function
-00000550: 2066 6f72 2064 6563 6f72 6174 6f72 730a   for decorators.
-00000560: 0a69 6d70 6f72 7420 6e75 6d70 7920 6173  .import numpy as
-00000570: 206e 7020 2020 2020 2020 2020 2020 2020   np             
-00000580: 2020 2020 2023 2061 7272 6179 206f 626a       # array obj
-00000590: 6563 7420 616e 6420 6661 7374 206e 756d  ect and fast num
-000005a0: 6572 6963 730a 6672 6f6d 206e 756d 7079  erics.from numpy
-000005b0: 2069 6d70 6f72 7420 7261 6e64 6f6d 0a66   import random.f
-000005c0: 726f 6d20 7363 6970 7920 696d 706f 7274  rom scipy import
-000005d0: 206c 696e 616c 6720 2020 2020 2020 2020   linalg         
-000005e0: 2020 2023 2073 6f6c 7665 7273 0a66 726f     # solvers.fro
-000005f0: 6d20 7363 6970 792e 6c69 6e61 6c67 2069  m scipy.linalg i
-00000600: 6d70 6f72 7420 6d61 7466 756e 6373 0a66  mport matfuncs.f
-00000610: 726f 6d20 7363 6970 7920 696d 706f 7274  rom scipy import
-00000620: 2073 7061 7273 6520 6173 2073 7020 2020   sparse as sp   
-00000630: 2020 2023 2066 6173 7420 7370 6172 7365     # fast sparse
-00000640: 206d 6174 7269 6365 730a 6672 6f6d 2073   matrices.from s
-00000650: 6369 7079 2e73 7061 7273 652e 6c69 6e61  cipy.sparse.lina
-00000660: 6c67 2069 6d70 6f72 7420 6569 6773 682c  lg import eigsh,
-00000670: 2069 6e76 2c20 7370 6c75 0a0a 696d 706f   inv, splu..impo
-00000680: 7274 2069 6772 6170 6820 2020 2020 2020  rt igraph       
-00000690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000006a0: 2320 6869 6768 2070 6572 666f 726d 616e  # high performan
-000006b0: 6365 2067 7261 7068 2074 6865 6f72 7920  ce graph theory 
-000006c0: 746f 6f6c 730a 0a66 726f 6d20 2e2e 7574  tools..from ..ut
-000006d0: 696c 7320 696d 706f 7274 206d 7069 2020  ils import mpi  
-000006e0: 2020 2020 2020 2020 2020 2023 2070 6172             # par
-000006f0: 616c 6c65 6c69 7a65 6420 636f 6d70 7574  allelized comput
-00000700: 6174 696f 6e73 0a0a 6672 6f6d 202e 5f65  ations..from ._e
-00000710: 7874 2e6e 756d 6572 6963 7320 696d 706f  xt.numerics impo
-00000720: 7274 205f 6c6f 6361 6c5f 636c 6971 7569  rt _local_cliqui
-00000730: 7368 6e65 7373 5f34 7468 6f72 6465 722c  shness_4thorder,
-00000740: 205c 0a20 2020 205f 6c6f 6361 6c5f 636c   \.    _local_cl
-00000750: 6971 7569 7368 6e65 7373 5f35 7468 6f72  iquishness_5thor
-00000760: 6465 722c 205f 6379 5f6d 7069 5f6e 7369  der, _cy_mpi_nsi
-00000770: 5f6e 6577 6d61 6e5f 6265 7477 6565 6e6e  _newman_betweenn
-00000780: 6573 732c 205c 0a20 2020 205f 6379 5f6d  ess, \.    _cy_m
-00000790: 7069 5f6e 6577 6d61 6e5f 6265 7477 6565  pi_newman_betwee
-000007a0: 6e6e 6573 732c 205f 6e73 695f 6265 7477  nness, _nsi_betw
-000007b0: 6565 6e6e 6573 732c 205c 0a20 2020 205f  eenness, \.    _
-000007c0: 6e65 776d 616e 5f62 6574 7765 656e 6e65  newman_betweenne
-000007d0: 7373 5f62 6164 6c79 5f63 7974 686f 6e2c  ss_badly_cython,
-000007e0: 205f 646f 5f6e 7369 5f63 6c75 7374 6572   _do_nsi_cluster
-000007f0: 696e 675f 492c 205c 0a20 2020 205f 646f  ing_I, \.    _do
-00000800: 5f6e 7369 5f63 6c75 7374 6572 696e 675f  _nsi_clustering_
-00000810: 4949 2c20 5f64 6f5f 6e73 695f 6861 6d6d  II, _do_nsi_hamm
-00000820: 696e 675f 636c 7573 7465 7269 6e67 0a0a  ing_clustering..
-00000830: 6672 6f6d 202e 2e75 7469 6c73 2069 6d70  from ..utils imp
-00000840: 6f72 7420 7072 6f67 7265 7373 6261 7220  ort progressbar 
-00000850: 2020 2020 2320 6561 7379 2070 726f 6772      # easy progr
-00000860: 6573 7320 6261 7220 6861 6e64 6c69 6e67  ess bar handling
-00000870: 0a0a 0a64 6566 206e 7a5f 636f 6f72 6473  ...def nz_coords
-00000880: 286d 6174 7269 7829 3a0a 2020 2020 2222  (matrix):.    ""
-00000890: 220a 2020 2020 4669 6e64 2063 6f6f 7264  ".    Find coord
-000008a0: 696e 6174 6573 206f 6620 616c 6c20 6e6f  inates of all no
-000008b0: 6e2d 7a65 726f 2065 6e74 7269 6573 2069  n-zero entries i
-000008c0: 6e20 6120 7370 6172 7365 206d 6174 7269  n a sparse matri
-000008d0: 782e 0a0a 2020 2020 3a72 6574 7572 6e3a  x...    :return:
-000008e0: 206c 6973 7420 6f66 2063 6f6f 7264 696e   list of coordin
-000008f0: 6174 6573 205b 726f 772c 636f 6c5d 0a20  ates [row,col]. 
-00000900: 2020 203a 7274 7970 653a 2020 6172 7261     :rtype:  arra
-00000910: 7928 5b5b 696e 743e 3d30 2c69 6e74 3e3d  y([[int>=0,int>=
-00000920: 305d 5d29 0a20 2020 2022 2222 0a20 2020  0]]).    """.   
-00000930: 2072 6574 7572 6e20 6e70 2e61 7272 6179   return np.array
-00000940: 286d 6174 7269 782e 6e6f 6e7a 6572 6f28  (matrix.nonzero(
-00000950: 2929 2e54 0a0a 0a64 6566 2063 6163 6865  )).T...def cache
-00000960: 5f68 656c 7065 7228 7365 6c66 2c20 6361  _helper(self, ca
-00000970: 742c 206b 6579 2c20 6d73 672c 2066 756e  t, key, msg, fun
-00000980: 632c 202a 6172 6773 2c20 2a2a 6b77 6172  c, *args, **kwar
-00000990: 6773 293a 0a20 2020 2022 2222 0a20 2020  gs):.    """.   
-000009a0: 2043 6163 6865 2072 6573 756c 7420 6f66   Cache result of
-000009b0: 2061 2066 756e 6374 696f 6e20 696e 2061   a function in a
-000009c0: 2073 7562 6469 6374 206f 6620 3a61 7474   subdict of :att
-000009d0: 723a 6073 656c 662e 6361 6368 6560 2e0a  r:`self.cache`..
-000009e0: 0a20 2020 203a 6172 6720 7374 7220 6361  .    :arg str ca
-000009f0: 743a 2063 6163 6865 2063 6174 6567 6f72  t: cache categor
-00000a00: 790a 2020 2020 3a61 7267 2073 7472 206b  y.    :arg str k
-00000a10: 6579 3a20 6361 6368 6520 6b65 790a 2020  ey: cache key.  
-00000a20: 2020 3a61 7267 2073 7472 206d 7367 3a20    :arg str msg: 
-00000a30: 6d65 7373 6167 6520 746f 2062 6520 6469  message to be di
-00000a40: 7370 6c61 7965 6420 6475 7269 6e67 2066  splayed during f
-00000a50: 6972 7374 2063 616c 6375 6c61 7469 6f6e  irst calculation
-00000a60: 0a20 2020 203a 6172 6720 6675 6e63 2066  .    :arg func f
-00000a70: 756e 633a 2066 756e 6374 696f 6e20 746f  unc: function to
-00000a80: 2062 6520 6361 6368 6564 0a20 2020 2022   be cached.    "
-00000a90: 2222 0a20 2020 2023 2063 6174 6567 6f72  "".    # categor
-00000aa0: 6965 7320 6361 6e20 6265 2061 6464 6564  ies can be added
-00000ab0: 206f 6e20 7468 6520 666c 793f 213f 210a   on the fly?!?!.
-00000ac0: 2020 2020 7365 6c66 2e63 6163 6865 2e73      self.cache.s
-00000ad0: 6574 6465 6661 756c 7428 6361 742c 207b  etdefault(cat, {
-00000ae0: 7d29 0a0a 2020 2020 6966 2073 656c 662e  })..    if self.
-00000af0: 6361 6368 655b 6361 745d 2e73 6574 6465  cache[cat].setde
-00000b00: 6661 756c 7428 6b65 7929 2069 7320 4e6f  fault(key) is No
-00000b10: 6e65 3a0a 2020 2020 2020 2020 6966 206d  ne:.        if m
-00000b20: 7367 2069 7320 6e6f 7420 4e6f 6e65 2061  sg is not None a
-00000b30: 6e64 2073 656c 662e 7369 6c65 6e63 655f  nd self.silence_
-00000b40: 6c65 7665 6c20 3c3d 2031 3a0a 2020 2020  level <= 1:.    
-00000b50: 2020 2020 2020 2020 7072 696e 7428 2743          print('C
-00000b60: 616c 6375 6c61 7469 6e67 2027 202b 206d  alculating ' + m
-00000b70: 7367 202b 2027 2e2e 2e27 290a 2020 2020  sg + '...').    
-00000b80: 2020 2020 7365 6c66 2e63 6163 6865 5b63      self.cache[c
-00000b90: 6174 5d5b 6b65 795d 203d 2066 756e 6328  at][key] = func(
-00000ba0: 7365 6c66 2c20 2a61 7267 732c 202a 2a6b  self, *args, **k
-00000bb0: 7761 7267 7329 0a20 2020 2072 6574 7572  wargs).    retur
-00000bc0: 6e20 7365 6c66 2e63 6163 6865 5b63 6174  n self.cache[cat
-00000bd0: 5d5b 6b65 795d 0a0a 0a64 6566 2063 6163  ][key]...def cac
-00000be0: 6865 645f 636f 6e73 7428 6361 742c 206b  hed_const(cat, k
-00000bf0: 6579 2c20 6d73 673d 4e6f 6e65 293a 0a20  ey, msg=None):. 
-00000c00: 2020 2022 2222 0a20 2020 2043 6163 6865     """.    Cache
-00000c10: 2072 6573 756c 7420 6f66 2064 6563 6f72   result of decor
-00000c20: 6174 6564 206d 6574 686f 6420 696e 2061  ated method in a
-00000c30: 2066 6978 6564 2073 7562 6469 6374 206f   fixed subdict o
-00000c40: 6620 3a61 7474 723a 6073 656c 662e 6361  f :attr:`self.ca
-00000c50: 6368 6560 2e0a 2020 2020 2222 220a 2020  che`..    """.  
-00000c60: 2020 6465 6620 7772 6170 7065 7228 6675    def wrapper(fu
-00000c70: 6e63 293a 0a20 2020 2020 2020 2040 7772  nc):.        @wr
-00000c80: 6170 7328 6675 6e63 290a 2020 2020 2020  aps(func).      
-00000c90: 2020 6465 6620 7772 6170 7065 6428 7365    def wrapped(se
-00000ca0: 6c66 2c20 2a61 7267 732c 202a 2a6b 7761  lf, *args, **kwa
-00000cb0: 7267 7329 3a0a 2020 2020 2020 2020 2020  rgs):.          
-00000cc0: 2020 7265 7475 726e 2063 6163 6865 5f68    return cache_h
-00000cd0: 656c 7065 7228 7365 6c66 2c20 6361 742c  elper(self, cat,
-00000ce0: 206b 6579 2c20 6d73 672c 2066 756e 632c   key, msg, func,
-00000cf0: 202a 6172 6773 2c20 2a2a 6b77 6172 6773   *args, **kwargs
-00000d00: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00000d10: 2077 7261 7070 6564 0a20 2020 2072 6574   wrapped.    ret
-00000d20: 7572 6e20 7772 6170 7065 720a 0a0a 6465  urn wrapper...de
-00000d30: 6620 6361 6368 6564 5f76 6172 2863 6174  f cached_var(cat
-00000d40: 2c20 6d73 673d 4e6f 6e65 293a 0a20 2020  , msg=None):.   
-00000d50: 2022 2222 0a20 2020 2043 6163 6865 2072   """.    Cache r
-00000d60: 6573 756c 7420 6f66 2064 6563 6f72 6174  esult of decorat
-00000d70: 6564 206d 6574 686f 6420 696e 2061 2076  ed method in a v
-00000d80: 6172 6961 626c 6520 7375 6264 6963 7420  ariable subdict 
-00000d90: 6f66 0a20 2020 203a 6174 7472 3a60 7365  of.    :attr:`se
-00000da0: 6c66 2e63 6163 6865 602c 2073 7065 6369  lf.cache`, speci
-00000db0: 6669 6564 2061 7320 6669 7273 7420 6172  fied as first ar
-00000dc0: 6775 6d65 6e74 2074 6f20 7468 6520 6465  gument to the de
-00000dd0: 636f 7261 7465 6420 6d65 7468 6f64 2e0a  corated method..
-00000de0: 2020 2020 2222 220a 2020 2020 6465 6620      """.    def 
-00000df0: 7772 6170 7065 7228 6675 6e63 293a 0a20  wrapper(func):. 
-00000e00: 2020 2020 2020 2040 7772 6170 7328 6675         @wraps(fu
-00000e10: 6e63 290a 2020 2020 2020 2020 6465 6620  nc).        def 
-00000e20: 7772 6170 7065 6428 7365 6c66 2c20 6b65  wrapped(self, ke
-00000e30: 793d 4e6f 6e65 2c20 2a2a 6b77 6172 6773  y=None, **kwargs
-00000e40: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-00000e50: 6574 7572 6e20 6361 6368 655f 6865 6c70  eturn cache_help
-00000e60: 6572 2873 656c 662c 2063 6174 2c20 6b65  er(self, cat, ke
-00000e70: 792c 206d 7367 2c20 6675 6e63 2c20 6b65  y, msg, func, ke
-00000e80: 792c 202a 2a6b 7761 7267 7329 0a20 2020  y, **kwargs).   
-00000e90: 2020 2020 2072 6574 7572 6e20 7772 6170       return wrap
-00000ea0: 7065 640a 2020 2020 7265 7475 726e 2077  ped.    return w
-00000eb0: 7261 7070 6572 0a0a 0a63 6c61 7373 204e  rapper...class N
-00000ec0: 6574 776f 726b 4572 726f 7228 4578 6365  etworkError(Exce
-00000ed0: 7074 696f 6e29 3a0a 2020 2020 2222 220a  ption):.    """.
-00000ee0: 2020 2020 5573 6564 2066 6f72 2061 6c6c      Used for all
-00000ef0: 2065 7863 6570 7469 6f6e 7320 7261 6973   exceptions rais
-00000f00: 6564 2062 7920 4e65 7477 6f72 6b2e 0a20  ed by Network.. 
-00000f10: 2020 2022 2222 0a20 2020 2064 6566 205f     """.    def _
-00000f20: 5f69 6e69 745f 5f28 7365 6c66 2c20 7661  _init__(self, va
-00000f30: 6c75 6529 3a0a 2020 2020 2020 2020 4578  lue):.        Ex
-00000f40: 6365 7074 696f 6e2e 5f5f 696e 6974 5f5f  ception.__init__
-00000f50: 2873 656c 6629 0a20 2020 2020 2020 2073  (self).        s
-00000f60: 656c 662e 7661 6c75 6520 3d20 7661 6c75  elf.value = valu
-00000f70: 650a 0a20 2020 2064 6566 205f 5f73 7472  e..    def __str
-00000f80: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
-00000f90: 2020 7265 7475 726e 2072 6570 7228 7365    return repr(se
-00000fa0: 6c66 2e76 616c 7565 290a 0a0a 230a 2320  lf.value)...#.# 
-00000fb0: 2044 6566 696e 6520 636c 6173 7320 4e65   Define class Ne
-00000fc0: 7477 6f72 6b0a 230a 0a63 6c61 7373 204e  twork.#..class N
-00000fd0: 6574 776f 726b 3a0a 2020 2020 2222 220a  etwork:.    """.
-00000fe0: 2020 2020 4120 4e65 7477 6f72 6b20 6973      A Network is
-00000ff0: 2061 2073 696d 706c 652c 2075 6e64 6972   a simple, undir
-00001000: 6563 7465 6420 6f72 2064 6972 6563 7465  ected or directe
-00001010: 6420 6772 6170 6820 7769 7468 206f 7074  d graph with opt
-00001020: 696f 6e61 6c20 6e6f 6465 0a20 2020 2061  ional node.    a
-00001030: 6e64 2f6f 7220 6c69 6e6b 2077 6569 6768  nd/or link weigh
-00001040: 7473 2e20 5468 6973 2063 6c61 7373 2065  ts. This class e
-00001050: 6e63 6170 7375 6c61 7465 7320 6461 7461  ncapsulates data
-00001060: 2073 7472 7563 7475 7265 7320 616e 6420   structures and 
-00001070: 6d65 7468 6f64 7320 746f 0a20 2020 2072  methods to.    r
-00001080: 6570 7265 7365 6e74 2c20 6765 6e65 7261  epresent, genera
-00001090: 7465 2061 6e64 2061 6e61 6c79 7a65 2073  te and analyze s
-000010a0: 7563 6820 7374 7275 6374 7572 6573 2e0a  uch structures..
-000010b0: 0a20 2020 204e 6574 776f 726b 2072 656c  .    Network rel
-000010c0: 6965 7320 6f6e 2074 6865 2070 6163 6b61  ies on the packa
-000010d0: 6765 2069 6772 6170 6820 666f 7220 6d61  ge igraph for ma
-000010e0: 6e79 206f 6620 6974 7320 6665 6174 7572  ny of its featur
-000010f0: 6573 2c20 6275 7420 616c 736f 0a20 2020  es, but also.   
-00001100: 2069 6d70 6c65 6d65 6e74 7320 6e65 7720   implements new 
-00001110: 6675 6e63 7469 6f6e 616c 6974 792e 2048  functionality. H
-00001120: 6967 686c 6967 6874 7320 696e 636c 7564  ighlights includ
-00001130: 6520 7765 6967 6874 6564 2061 6e64 2064  e weighted and d
-00001140: 6972 6563 7465 640a 2020 2020 7374 6174  irected.    stat
-00001150: 6973 7469 6361 6c20 6e65 7477 6f72 6b20  istical network 
-00001160: 6d65 6173 7572 6573 2c20 6d65 6173 7572  measures, measur
-00001170: 6573 2062 6173 6564 206f 6e20 7261 6e64  es based on rand
-00001180: 6f6d 2077 616c 6b73 2c20 616e 640a 2020  om walks, and.  
-00001190: 2020 6e6f 6465 2073 706c 6974 7469 6e67    node splitting
-000011a0: 2069 6e76 6172 6961 6e74 206e 6574 776f   invariant netwo
-000011b0: 726b 206d 6561 7375 7265 732e 0a0a 2020  rk measures...  
-000011c0: 2020 2a2a 4578 616d 706c 6573 3a2a 2a0a    **Examples:**.
-000011d0: 0a20 2020 2043 7265 6174 6520 616e 2075  .    Create an u
-000011e0: 6e64 6972 6563 7465 6420 6e65 7477 6f72  ndirected networ
-000011f0: 6b20 6769 7665 6e20 7468 6520 6164 6a61  k given the adja
-00001200: 6365 6e63 7920 6d61 7472 6978 3a0a 0a20  cency matrix:.. 
-00001210: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
-00001220: 776f 726b 2861 646a 6163 656e 6379 3d5b  work(adjacency=[
-00001230: 5b30 2c31 2c30 2c30 2c30 2c30 5d2c 205b  [0,1,0,0,0,0], [
-00001240: 312c 302c 312c 302c 302c 315d 2c0a 2020  1,0,1,0,0,1],.  
-00001250: 2020 2e2e 2e20 2020 2020 2020 2020 2020    ...           
-00001260: 2020 2020 2020 2020 2020 2020 2020 205b                 [
-00001270: 302c 312c 302c 312c 312c 305d 2c20 5b30  0,1,0,1,1,0], [0
-00001280: 2c30 2c31 2c30 2c31 2c30 5d2c 0a20 2020  ,0,1,0,1,0],.   
-00001290: 202e 2e2e 2020 2020 2020 2020 2020 2020   ...            
-000012a0: 2020 2020 2020 2020 2020 2020 2020 5b30                [0
-000012b0: 2c30 2c31 2c31 2c30 2c31 5d2c 205b 302c  ,0,1,1,0,1], [0,
-000012c0: 312c 302c 302c 312c 305d 5d29 0a0a 2020  1,0,0,1,0]])..  
-000012d0: 2020 4372 6561 7465 2061 6e20 4572 646f    Create an Erdo
-000012e0: 732d 5265 6e79 6920 7261 6e64 6f6d 2067  s-Renyi random g
-000012f0: 7261 7068 3a0a 0a20 2020 203e 3e3e 206e  raph:..    >>> n
-00001300: 6574 203d 204e 6574 776f 726b 2e45 7264  et = Network.Erd
-00001310: 6f73 5265 6e79 6928 6e5f 6e6f 6465 733d  osRenyi(n_nodes=
-00001320: 3130 302c 206c 696e 6b5f 7072 6f62 6162  100, link_probab
-00001330: 696c 6974 793d 302e 3035 290a 2020 2020  ility=0.05).    
-00001340: 4765 6e65 7261 7469 6e67 2045 7264 6f73  Generating Erdos
-00001350: 2d52 656e 7969 2072 616e 646f 6d20 6772  -Renyi random gr
-00001360: 6170 6820 7769 7468 2031 3030 206e 6f64  aph with 100 nod
-00001370: 6573 2061 6e64 2070 726f 6261 6269 6c69  es and probabili
-00001380: 7479 2030 2e30 352e 2e2e 0a20 2020 2022  ty 0.05....    "
-00001390: 2222 0a0a 2020 2020 230a 2020 2020 2320  ""..    #.    # 
-000013a0: 2044 6566 696e 6974 696f 6e73 206f 6620   Definitions of 
-000013b0: 696e 7465 726e 616c 206d 6574 686f 6473  internal methods
-000013c0: 0a20 2020 2023 0a0a 2020 2020 6465 6620  .    #..    def 
-000013d0: 5f5f 696e 6974 5f5f 2873 656c 662c 2061  __init__(self, a
-000013e0: 646a 6163 656e 6379 3d4e 6f6e 652c 206e  djacency=None, n
-000013f0: 5f6e 6f64 6573 3d4e 6f6e 652c 2065 6467  _nodes=None, edg
-00001400: 655f 6c69 7374 3d4e 6f6e 652c 0a20 2020  e_list=None,.   
-00001410: 2020 2020 2020 2020 2020 2020 2020 6469                di
-00001420: 7265 6374 6564 3d46 616c 7365 2c20 6e6f  rected=False, no
-00001430: 6465 5f77 6569 6768 7473 3d4e 6f6e 652c  de_weights=None,
-00001440: 2073 696c 656e 6365 5f6c 6576 656c 3d30   silence_level=0
-00001450: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00001460: 2020 2020 2020 2052 6574 7572 6e20 6120         Return a 
-00001470: 6e65 7720 6469 7265 6374 6564 206f 7220  new directed or 
-00001480: 756e 6469 7265 6374 6564 204e 6574 776f  undirected Netwo
-00001490: 726b 206f 626a 6563 740a 2020 2020 2020  rk object.      
-000014a0: 2020 7769 7468 2067 6976 656e 2061 646a    with given adj
-000014b0: 6163 656e 6379 206d 6174 7269 7820 616e  acency matrix an
-000014c0: 6420 6f70 7469 6f6e 616c 206e 6f64 6520  d optional node 
-000014d0: 7765 6967 6874 732e 0a0a 2020 2020 2020  weights...      
-000014e0: 2020 3a74 7970 6520 6164 6a61 6365 6e63    :type adjacenc
-000014f0: 793a 2073 7175 6172 6520 6172 7261 792d  y: square array-
-00001500: 6c69 6b65 205b 6e6f 6465 2c6e 6f64 655d  like [node,node]
-00001510: 2c20 6f72 2070 7973 7061 7273 6520 6d61  , or pysparse ma
-00001520: 7472 6978 206f 660a 2020 2020 2020 2020  trix of.        
-00001530: 2020 2020 3073 2061 6e64 2031 730a 2020      0s and 1s.  
-00001540: 2020 2020 2020 3a61 7267 2020 6164 6a61        :arg  adja
-00001550: 6365 6e63 793a 2041 646a 6163 656e 6379  cency: Adjacency
-00001560: 206d 6174 7269 7820 6f66 2074 6865 206e   matrix of the n
-00001570: 6577 206e 6574 776f 726b 2e20 2045 6e74  ew network.  Ent
-00001580: 7279 205b 692c 6a5d 0a20 2020 2020 2020  ry [i,j].       
-00001590: 2020 2020 2069 6e64 6963 6174 6573 2077       indicates w
-000015a0: 6865 7468 6572 206e 6f64 6520 6920 6c69  hether node i li
-000015b0: 6e6b 7320 746f 206e 6f64 6520 6a2e 2020  nks to node j.  
-000015c0: 4974 7320 6469 6167 6f6e 616c 206d 7573  Its diagonal mus
-000015d0: 7420 6265 0a20 2020 2020 2020 2020 2020  t be.           
-000015e0: 207a 6572 6f2e 2020 4d75 7374 2062 6520   zero.  Must be 
-000015f0: 7379 6d6d 6574 7269 6320 6966 2064 6972  symmetric if dir
-00001600: 6563 7465 643d 4661 6c73 652e 0a20 2020  ected=False..   
-00001610: 2020 2020 203a 7479 7065 206e 5f6e 6f64       :type n_nod
-00001620: 6573 3a20 696e 740a 2020 2020 2020 2020  es: int.        
-00001630: 3a61 7267 2020 6e5f 6e6f 6465 733a 204e  :arg  n_nodes: N
-00001640: 756d 6265 7220 6f66 206e 6f64 6573 2c20  umber of nodes, 
-00001650: 6f70 7469 6f6e 616c 2061 7267 756d 656e  optional argumen
-00001660: 7420 7768 656e 2075 7369 6e67 2065 6467  t when using edg
-00001670: 655f 6c69 7374 0a20 2020 2020 2020 203a  e_list.        :
-00001680: 7479 7065 2065 6467 655f 6c69 7374 3a20  type edge_list: 
-00001690: 6172 7261 792d 6c69 6b65 206c 6973 7420  array-like list 
-000016a0: 6f66 206c 6973 7473 0a20 2020 2020 2020  of lists.       
-000016b0: 203a 6172 6720 2065 6467 655f 6c69 7374   :arg  edge_list
-000016c0: 3a20 4564 6765 206c 6973 7420 6f66 2074  : Edge list of t
-000016d0: 6865 206e 6577 206e 6574 776f 726b 2e20  he new network. 
-000016e0: 2045 6e74 7269 6573 205b 692c 305d 2c20   Entries [i,0], 
-000016f0: 5b69 2c31 5d0a 2020 2020 2020 2020 2020  [i,1].          
-00001700: 2020 636f 6e74 6169 6e20 7468 6520 656e    contain the en
-00001710: 642d 6e6f 6465 7320 6f66 2061 6e20 6564  d-nodes of an ed
-00001720: 6765 2e0a 2020 2020 2020 2020 3a61 7267  ge..        :arg
-00001730: 2062 6f6f 6c20 6469 7265 6374 6564 3a20   bool directed: 
-00001740: 496e 6469 6361 7465 7320 7768 6574 6865  Indicates whethe
-00001750: 7220 7468 6520 6e65 7477 6f72 6b20 7368  r the network sh
-00001760: 616c 6c20 6265 2063 6f6e 7369 6465 7265  all be considere
-00001770: 640a 2020 2020 2020 2020 2020 2020 6173  d.            as
-00001780: 2064 6972 6563 7465 642e 2049 6620 4661   directed. If Fa
-00001790: 6c73 652c 2061 646a 6163 656e 6379 206d  lse, adjacency m
-000017a0: 7573 7420 6265 2073 796d 6d65 7472 6963  ust be symmetric
-000017b0: 2e0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
-000017c0: 6e6f 6465 5f77 6569 6768 7473 3a20 3164  node_weights: 1d
-000017d0: 206e 756d 7079 2061 7272 6179 206f 7220   numpy array or 
-000017e0: 6c69 7374 205b 6e6f 6465 5d20 6f66 2066  list [node] of f
-000017f0: 6c6f 6174 7320 3e3d 2030 0a20 2020 2020  loats >= 0.     
-00001800: 2020 203a 6172 6720 206e 6f64 655f 7765     :arg  node_we
-00001810: 6967 6874 733a 204f 7074 696f 6e61 6c20  ights: Optional 
-00001820: 6172 7261 7920 6f72 206c 6973 7420 6f66  array or list of
-00001830: 206e 6f64 6520 7765 6967 6874 7320 746f   node weights to
-00001840: 2062 6520 7573 6564 0a20 2020 2020 2020   be used.       
-00001850: 2020 2020 2066 6f72 206e 6f64 6520 7370       for node sp
-00001860: 6c69 7474 696e 6720 696e 7661 7269 616e  litting invarian
-00001870: 7420 6e65 7477 6f72 6b20 6d65 6173 7572  t network measur
-00001880: 6573 2e20 2045 6e74 7279 205b 695d 2069  es.  Entry [i] i
-00001890: 7320 7468 650a 2020 2020 2020 2020 2020  s the.          
-000018a0: 2020 7765 6967 6874 206f 6620 6e6f 6465    weight of node
-000018b0: 2069 2e20 2028 4465 6661 756c 743a 206c   i.  (Default: l
-000018c0: 6973 7420 6f66 206f 6e65 7329 0a20 2020  ist of ones).   
-000018d0: 2020 2020 203a 7479 7065 2073 696c 656e       :type silen
-000018e0: 6365 5f6c 6576 656c 3a20 696e 7420 3e3d  ce_level: int >=
-000018f0: 2030 0a20 2020 2020 2020 203a 6172 6720   0.        :arg 
-00001900: 2073 696c 656e 6365 5f6c 6576 656c 3a20   silence_level: 
-00001910: 5468 6520 6869 6768 6572 2c20 7468 6520  The higher, the 
-00001920: 6c65 7373 2070 726f 6772 6573 7320 696e  less progress in
-00001930: 666f 2069 7320 6f75 7470 7574 2e0a 2020  fo is output..  
-00001940: 2020 2020 2020 3a72 7479 7065 3a20 3a63        :rtype: :c
-00001950: 6c61 7373 3a60 4e65 7477 6f72 6b60 2069  lass:`Network` i
-00001960: 6e73 7461 6e63 650a 2020 2020 2020 2020  nstance.        
-00001970: 3a72 6574 7572 6e3a 2054 6865 206e 6577  :return: The new
-00001980: 206e 6574 776f 726b 2e0a 2020 2020 2020   network..      
-00001990: 2020 2222 220a 0a20 2020 2020 2020 2073    """..        s
-000019a0: 656c 662e 6469 7265 6374 6564 203d 2064  elf.directed = d
-000019b0: 6972 6563 7465 640a 2020 2020 2020 2020  irected.        
-000019c0: 2222 2228 626f 6f6c 2920 496e 6469 6361  """(bool) Indica
-000019d0: 7465 7320 7768 6574 6865 7220 7468 6520  tes whether the 
-000019e0: 6e65 7477 6f72 6b20 6973 2064 6972 6563  network is direc
-000019f0: 7465 642e 2222 220a 2020 2020 2020 2020  ted.""".        
-00001a00: 7365 6c66 2e73 696c 656e 6365 5f6c 6576  self.silence_lev
-00001a10: 656c 203d 2073 696c 656e 6365 5f6c 6576  el = silence_lev
-00001a20: 656c 0a20 2020 2020 2020 2022 2222 2869  el.        """(i
-00001a30: 6e74 3e3d 3029 2068 6967 6865 7220 2d3e  nt>=0) higher ->
-00001a40: 206c 6573 7320 7072 6f67 7265 7373 2069   less progress i
-00001a50: 6e66 6f22 2222 0a0a 2020 2020 2020 2020  nfo"""..        
-00001a60: 6966 206e 5f6e 6f64 6573 2069 7320 4e6f  if n_nodes is No
-00001a70: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00001a80: 7365 6c66 2e4e 203d 2030 0a20 2020 2020  self.N = 0.     
-00001a90: 2020 2020 2020 2022 2222 2869 6e74 3e30         """(int>0
-00001aa0: 2920 6e75 6d62 6572 206f 6620 6e6f 6465  ) number of node
-00001ab0: 7322 2222 0a20 2020 2020 2020 2065 6c73  s""".        els
-00001ac0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
-00001ad0: 656c 662e 4e20 3d20 6e5f 6e6f 6465 730a  elf.N = n_nodes.
-00001ae0: 0a20 2020 2020 2020 2073 656c 662e 6e5f  .        self.n_
-00001af0: 6c69 6e6b 7320 3d20 300a 2020 2020 2020  links = 0.      
-00001b00: 2020 2222 2228 696e 743e 3029 206e 756d    """(int>0) num
-00001b10: 6265 7220 6f66 206c 696e 6b73 2222 220a  ber of links""".
-00001b20: 2020 2020 2020 2020 7365 6c66 2e6c 696e          self.lin
-00001b30: 6b5f 6465 6e73 6974 7920 3d20 300a 2020  k_density = 0.  
-00001b40: 2020 2020 2020 2222 2228 303c 666c 6f61        """(0<floa
-00001b50: 743c 3129 2070 726f 706f 7274 696f 6e20  t<1) proportion 
-00001b60: 6f66 206c 696e 6b65 6420 6e6f 6465 2070  of linked node p
-00001b70: 6169 7273 2222 220a 0a20 2020 2020 2020  airs"""..       
-00001b80: 2073 656c 662e 7370 5f41 203d 204e 6f6e   self.sp_A = Non
-00001b90: 650a 2020 2020 2020 2020 2222 2228 7370  e.        """(sp
-00001ba0: 6172 7365 2e63 7363 5f6d 6174 7269 7828  arse.csc_matrix(
-00001bb0: 5b5b 696e 742c 696e 745d 5d29 2077 6974  [[int,int]]) wit
-00001bc0: 6820 656e 7472 6965 7320 302c 3129 0a20  h entries 0,1). 
-00001bd0: 2020 2020 2020 2041 646a 6163 656e 6379         Adjacency
-00001be0: 206d 6174 7269 782e 2041 5b69 2c6a 5d3d   matrix. A[i,j]=
-00001bf0: 3120 696e 6469 6361 7465 7320 6120 6c69  1 indicates a li
-00001c00: 6e6b 2069 202d 3e20 6a2e 2053 796d 6d65  nk i -> j. Symme
-00001c10: 7472 6963 2069 6620 7468 650a 2020 2020  tric if the.    
-00001c20: 2020 2020 6e65 7477 6f72 6b20 6973 2075      network is u
-00001c30: 6e64 6972 6563 7465 642e 2222 220a 2020  ndirected.""".  
-00001c40: 2020 2020 2020 7365 6c66 2e73 705f 6474        self.sp_dt
-00001c50: 7970 6520 3d20 4e6f 6e65 0a0a 2020 2020  ype = None..    
-00001c60: 2020 2020 7365 6c66 2e67 7261 7068 203d      self.graph =
-00001c70: 204e 6f6e 650a 2020 2020 2020 2020 2222   None.        ""
-00001c80: 2228 6967 7261 7068 2e47 7261 7068 2920  "(igraph.Graph) 
-00001c90: 456d 6265 6464 6564 2067 7261 7068 206f  Embedded graph o
-00001ca0: 626a 6563 7420 7072 6f76 6964 696e 6720  bject providing 
-00001cb0: 736f 6d65 2073 7461 6e64 6172 6420 6e65  some standard ne
-00001cc0: 7477 6f72 6b0a 2020 2020 2020 2020 6d65  twork.        me
-00001cd0: 6173 7572 6573 2e22 2222 0a0a 2020 2020  asures."""..    
-00001ce0: 2020 2020 7365 6c66 2e5f 6e6f 6465 5f77      self._node_w
-00001cf0: 6569 6768 7473 203d 204e 6f6e 650a 2020  eights = None.  
-00001d00: 2020 2020 2020 2222 2228 6172 7261 7928        """(array(
-00001d10: 5b69 6e74 3e3d 305d 2929 2061 7272 6179  [int>=0])) array
-00001d20: 206f 6620 6e6f 6465 2077 6569 6768 7473   of node weights
-00001d30: 2222 220a 2020 2020 2020 2020 7365 6c66  """.        self
-00001d40: 2e6d 6561 6e5f 6e6f 6465 5f77 6569 6768  .mean_node_weigh
-00001d50: 7420 3d20 300a 2020 2020 2020 2020 2222  t = 0.        ""
-00001d60: 226d 6561 6e20 6e6f 6465 2077 6569 6768  "mean node weigh
-00001d70: 7422 2222 0a20 2020 2020 2020 2073 656c  t""".        sel
-00001d80: 662e 746f 7461 6c5f 6e6f 6465 5f77 6569  f.total_node_wei
-00001d90: 6768 7420 3d20 300a 2020 2020 2020 2020  ght = 0.        
-00001da0: 2222 2274 6f74 616c 206e 6f64 6520 7765  """total node we
-00001db0: 6967 6874 2222 220a 0a20 2020 2020 2020  ight"""..       
-00001dc0: 2073 656c 662e 6361 6368 6520 3d20 7b27   self.cache = {'
-00001dd0: 6261 7365 273a 207b 7d2c 2027 6e73 6927  base': {}, 'nsi'
-00001de0: 3a20 7b7d 2c20 2770 6174 6873 273a 207b  : {}, 'paths': {
-00001df0: 7d7d 0a20 2020 2020 2020 2022 2222 2864  }}.        """(d
-00001e00: 6963 7429 2063 6163 6865 206f 6620 7265  ict) cache of re
-00001e10: 2d75 7361 626c 6520 636f 6d70 7574 6174  -usable computat
-00001e20: 696f 6e20 7265 7375 6c74 7322 2222 0a0a  ion results"""..
-00001e30: 2020 2020 2020 2020 6966 2061 646a 6163          if adjac
-00001e40: 656e 6379 2069 7320 6e6f 7420 4e6f 6e65  ency is not None
-00001e50: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00001e60: 6c66 2e5f 7365 745f 6164 6a61 6365 6e63  lf._set_adjacenc
-00001e70: 7928 6164 6a61 6365 6e63 7929 0a20 2020  y(adjacency).   
-00001e80: 2020 2020 2065 6c69 6620 6564 6765 5f6c       elif edge_l
-00001e90: 6973 7420 6973 206e 6f74 204e 6f6e 653a  ist is not None:
-00001ea0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00001eb0: 662e 7365 745f 6564 6765 5f6c 6973 7428  f.set_edge_list(
-00001ec0: 6564 6765 5f6c 6973 742c 206e 5f6e 6f64  edge_list, n_nod
-00001ed0: 6573 290a 2020 2020 2020 2020 656c 7365  es).        else
-00001ee0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00001ef0: 6973 6520 4e65 7477 6f72 6b45 7272 6f72  ise NetworkError
-00001f00: 2822 416e 2061 646a 6163 656e 6379 206d  ("An adjacency m
-00001f10: 6174 7269 7820 6f72 2065 6467 6520 6c69  atrix or edge li
-00001f20: 7374 2068 6173 2074 6f20 6265 205c 0a20  st has to be \. 
-00001f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f40: 2020 2020 2020 2020 2020 2020 2020 6769                gi
-00001f50: 7665 6e20 746f 2069 6e69 7469 616c 697a  ven to initializ
-00001f60: 6520 616e 2069 6e73 7461 6e63 6520 6f66  e an instance of
-00001f70: 204e 6574 776f 726b 2e22 290a 0a20 2020   Network.")..   
-00001f80: 2020 2020 2073 656c 662e 5f73 6574 5f6e       self._set_n
-00001f90: 6f64 655f 7765 6967 6874 7328 6e6f 6465  ode_weights(node
-00001fa0: 5f77 6569 6768 7473 290a 2020 2020 2020  _weights).      
-00001fb0: 2020 7365 6c66 2e64 6567 7265 6528 290a    self.degree().
-00001fc0: 0a20 2020 2064 6566 205f 5f73 7472 5f5f  .    def __str__
-00001fd0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00001fe0: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
-00001ff0: 726e 2061 2073 686f 7274 2073 756d 6d61  rn a short summa
-00002000: 7279 206f 6620 7468 6520 6e65 7477 6f72  ry of the networ
-00002010: 6b2e 0a0a 2020 2020 2020 2020 2a2a 4578  k...        **Ex
-00002020: 616d 706c 653a 2a2a 0a0a 2020 2020 2020  ample:**..      
-00002030: 2020 3e3e 3e20 7072 696e 7428 4e65 7477    >>> print(Netw
-00002040: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
-00002050: 776f 726b 2829 290a 2020 2020 2020 2020  work()).        
-00002060: 4e65 7477 6f72 6b3a 2075 6e64 6972 6563  Network: undirec
-00002070: 7465 642c 2036 206e 6f64 6573 2c20 3720  ted, 6 nodes, 7 
-00002080: 6c69 6e6b 732c 206c 696e 6b20 6465 6e73  links, link dens
-00002090: 6974 7920 302e 3436 372e 0a0a 2020 2020  ity 0.467...    
-000020a0: 2020 2020 3a72 7479 7065 3a20 7374 7269      :rtype: stri
-000020b0: 6e67 0a20 2020 2020 2020 2022 2222 0a20  ng.        """. 
-000020c0: 2020 2020 2020 2072 6574 7572 6e20 2827         return ('
-000020d0: 4e65 7477 6f72 6b3a 2025 7364 6972 6563  Network: %sdirec
-000020e0: 7465 642c 2025 6920 6e6f 6465 732c 2025  ted, %i nodes, %
-000020f0: 6920 6c69 6e6b 732c 2027 0a20 2020 2020  i links, '.     
-00002100: 2020 2020 2020 2020 2020 2027 6c69 6e6b             'link
-00002110: 2064 656e 7369 7479 2025 2e33 662e 2729   density %.3f.')
-00002120: 2025 2028 2727 2069 6620 7365 6c66 2e64   % ('' if self.d
-00002130: 6972 6563 7465 6420 656c 7365 2027 756e  irected else 'un
-00002140: 272c 2073 656c 662e 4e2c 0a20 2020 2020  ', self.N,.     
-00002150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002170: 2020 2020 7365 6c66 2e6e 5f6c 696e 6b73      self.n_links
-00002180: 2c20 7365 6c66 2e6c 696e 6b5f 6465 6e73  , self.link_dens
-00002190: 6974 7929 0a0a 2020 2020 6465 6620 5f5f  ity)..    def __
-000021a0: 6c65 6e5f 5f28 7365 6c66 293a 0a20 2020  len__(self):.   
-000021b0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000021c0: 2052 6574 7572 6e20 7468 6520 6e75 6d62   Return the numb
-000021d0: 6572 206f 6620 6e6f 6465 7320 6173 2074  er of nodes as t
-000021e0: 6865 2027 6c65 6e67 7468 272e 0a0a 2020  he 'length'...  
-000021f0: 2020 2020 2020 2a2a 4578 616d 706c 653a        **Example:
-00002200: 2a2a 0a0a 2020 2020 2020 2020 3e3e 3e20  **..        >>> 
-00002210: 6c65 6e28 4e65 7477 6f72 6b2e 536d 616c  len(Network.Smal
-00002220: 6c54 6573 744e 6574 776f 726b 2829 290a  lTestNetwork()).
-00002230: 2020 2020 2020 2020 360a 0a20 2020 2020          6..     
-00002240: 2020 203a 7274 7970 653a 2069 6e74 203e     :rtype: int >
-00002250: 2030 0a20 2020 2020 2020 2022 2222 0a20   0.        """. 
-00002260: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00002270: 6c66 2e4e 0a0a 2020 2020 6465 6620 636c  lf.N..    def cl
-00002280: 6561 725f 6361 6368 6528 7365 6c66 293a  ear_cache(self):
-00002290: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-000022a0: 2020 2020 2043 6c65 6172 2063 6163 6865       Clear cache
-000022b0: 206f 6620 696e 666f 726d 6174 696f 6e20   of information 
-000022c0: 7468 6174 2063 616e 2062 6520 7265 6361  that can be reca
-000022d0: 6c63 756c 6174 6564 2066 726f 6d20 6261  lculated from ba
-000022e0: 7369 6320 6461 7461 2e0a 2020 2020 2020  sic data..      
-000022f0: 2020 2222 220a 2020 2020 2020 2020 7365    """.        se
-00002300: 6c66 2e63 6163 6865 5b27 6261 7365 275d  lf.cache['base']
-00002310: 203d 207b 7d0a 2020 2020 2020 2020 7365   = {}.        se
-00002320: 6c66 2e63 6c65 6172 5f6e 7369 5f63 6163  lf.clear_nsi_cac
-00002330: 6865 2829 0a20 2020 2020 2020 2073 656c  he().        sel
-00002340: 662e 636c 6561 725f 7061 7468 735f 6361  f.clear_paths_ca
-00002350: 6368 6528 290a 0a20 2020 2064 6566 2063  che()..    def c
-00002360: 6c65 6172 5f6e 7369 5f63 6163 6865 2873  lear_nsi_cache(s
-00002370: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00002380: 220a 2020 2020 2020 2020 436c 6561 7220  ".        Clear 
-00002390: 6361 6368 6520 6f66 2069 6e66 6f72 6d61  cache of informa
-000023a0: 7469 6f6e 2074 6861 7420 6361 6e20 6265  tion that can be
-000023b0: 2072 6563 616c 6375 6c61 7465 6420 6672   recalculated fr
-000023c0: 6f6d 2062 6173 6963 2064 6174 610a 2020  om basic data.  
-000023d0: 2020 2020 2020 616e 6420 6465 7065 6e64        and depend
-000023e0: 7320 6f6e 2074 6865 206e 6f64 6520 7765  s on the node we
-000023f0: 6967 6874 732e 0a20 2020 2020 2020 2022  ights..        "
-00002400: 2222 0a20 2020 2020 2020 2073 656c 662e  "".        self.
-00002410: 6361 6368 655b 276e 7369 275d 203d 207b  cache['nsi'] = {
-00002420: 7d0a 0a20 2020 2064 6566 2063 6c65 6172  }..    def clear
-00002430: 5f70 6174 6873 5f63 6163 6865 2873 656c  _paths_cache(sel
-00002440: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-00002450: 2020 2020 2020 2020 436c 6561 7220 6361          Clear ca
-00002460: 6368 6520 6f66 2070 6174 6820 6c65 6774  che of path legt
-00002470: 6873 2066 6f72 206c 696e 6b20 6174 7472  hs for link attr
-00002480: 6962 7574 6573 2e0a 2020 2020 2020 2020  ibutes..        
-00002490: 2222 220a 2020 2020 2020 2020 666f 7220  """.        for 
-000024a0: 6174 7472 2069 6e20 7365 6c66 2e63 6163  attr in self.cac
-000024b0: 6865 5b27 7061 7468 7327 5d3a 0a20 2020  he['paths']:.   
-000024c0: 2020 2020 2020 2020 2073 656c 662e 636c           self.cl
-000024d0: 6561 725f 6c69 6e6b 5f61 7474 7269 6275  ear_link_attribu
-000024e0: 7465 2861 7474 7229 0a20 2020 2020 2020  te(attr).       
-000024f0: 2073 656c 662e 6361 6368 655b 2770 6174   self.cache['pat
-00002500: 6873 275d 203d 207b 7d0a 0a20 2020 2064  hs'] = {}..    d
-00002510: 6566 2063 6f70 7928 7365 6c66 293a 0a20  ef copy(self):. 
-00002520: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00002530: 2020 2052 6574 7572 6e20 6120 636f 7079     Return a copy
-00002540: 206f 6620 7468 6520 6e65 7477 6f72 6b2e   of the network.
-00002550: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00002560: 2020 2020 2072 6574 7572 6e20 4e65 7477       return Netw
-00002570: 6f72 6b28 6164 6a61 6365 6e63 793d 7365  ork(adjacency=se
-00002580: 6c66 2e73 705f 412c 2064 6972 6563 7465  lf.sp_A, directe
-00002590: 643d 7365 6c66 2e64 6972 6563 7465 642c  d=self.directed,
-000025a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000025b0: 2020 2020 2020 2020 6e6f 6465 5f77 6569          node_wei
-000025c0: 6768 7473 3d73 656c 662e 6e6f 6465 5f77  ghts=self.node_w
-000025d0: 6569 6768 7473 2c0a 2020 2020 2020 2020  eights,.        
-000025e0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000025f0: 696c 656e 6365 5f6c 6576 656c 3d73 656c  ilence_level=sel
-00002600: 662e 7369 6c65 6e63 655f 6c65 7665 6c29  f.silence_level)
-00002610: 0a0a 2020 2020 6465 6620 756e 6469 7265  ..    def undire
-00002620: 6374 6564 5f63 6f70 7928 7365 6c66 293a  cted_copy(self):
-00002630: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00002640: 2020 2020 2052 6574 7572 6e20 616e 2075       Return an u
-00002650: 6e64 6972 6563 7465 6420 636f 7079 206f  ndirected copy o
-00002660: 6620 7468 6520 6e65 7477 6f72 6b2e 0a0a  f the network...
-00002670: 2020 2020 2020 2020 4e6f 6465 7320 6920          Nodes i 
-00002680: 616e 6420 6a20 6172 6520 6c69 6e6b 6564  and j are linked
-00002690: 2069 6e20 7468 6520 636f 7079 2069 662c   in the copy if,
-000026a0: 2069 6e20 7468 6520 6375 7272 656e 7420   in the current 
-000026b0: 6e65 7477 6f72 6b2c 2069 0a20 2020 2020  network, i.     
-000026c0: 2020 206c 696e 6b73 2074 6f20 6a20 6f72     links to j or
-000026d0: 206a 206c 696e 6b73 2074 6f20 6920 6f72   j links to i or
-000026e0: 2062 6f74 682e 0a0a 2020 2020 2020 2020   both...        
-000026f0: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
-00002700: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
-00002710: 4e65 7477 6f72 6b28 6164 6a61 6365 6e63  Network(adjacenc
-00002720: 793d 5b5b 302c 315d 2c5b 302c 305d 5d2c  y=[[0,1],[0,0]],
-00002730: 2064 6972 6563 7465 643d 5472 7565 293b   directed=True);
-00002740: 2070 7269 6e74 286e 6574 290a 2020 2020   print(net).    
-00002750: 2020 2020 4e65 7477 6f72 6b3a 2064 6972      Network: dir
-00002760: 6563 7465 642c 2032 206e 6f64 6573 2c20  ected, 2 nodes, 
-00002770: 3120 6c69 6e6b 732c 206c 696e 6b20 6465  1 links, link de
-00002780: 6e73 6974 7920 302e 3530 302e 0a20 2020  nsity 0.500..   
-00002790: 2020 2020 203e 3e3e 2070 7269 6e74 286e       >>> print(n
-000027a0: 6574 2e75 6e64 6972 6563 7465 645f 636f  et.undirected_co
-000027b0: 7079 2829 290a 2020 2020 2020 2020 4e65  py()).        Ne
-000027c0: 7477 6f72 6b3a 2075 6e64 6972 6563 7465  twork: undirecte
-000027d0: 642c 2032 206e 6f64 6573 2c20 3120 6c69  d, 2 nodes, 1 li
-000027e0: 6e6b 732c 206c 696e 6b20 6465 6e73 6974  nks, link densit
-000027f0: 7920 312e 3030 302e 0a0a 2020 2020 2020  y 1.000...      
-00002800: 2020 3a72 7479 7065 3a20 3a63 6c61 7373    :rtype: :class
-00002810: 3a60 4e65 7477 6f72 6b60 2069 6e73 7461  :`Network` insta
-00002820: 6e63 650a 2020 2020 2020 2020 2222 220a  nce.        """.
-00002830: 2020 2020 2020 2020 7265 7475 726e 204e          return N
-00002840: 6574 776f 726b 2861 646a 6163 656e 6379  etwork(adjacency
-00002850: 3d73 656c 662e 756e 6469 7265 6374 6564  =self.undirected
-00002860: 5f61 646a 6163 656e 6379 2829 2c0a 2020  _adjacency(),.  
-00002870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002880: 2020 2020 2064 6972 6563 7465 643d 4661       directed=Fa
-00002890: 6c73 652c 206e 6f64 655f 7765 6967 6874  lse, node_weight
-000028a0: 733d 7365 6c66 2e6e 6f64 655f 7765 6967  s=self.node_weig
-000028b0: 6874 732c 0a20 2020 2020 2020 2020 2020  hts,.           
-000028c0: 2020 2020 2020 2020 2020 2020 7369 6c65              sile
-000028d0: 6e63 655f 6c65 7665 6c3d 7365 6c66 2e73  nce_level=self.s
-000028e0: 696c 656e 6365 5f6c 6576 656c 290a 0a20  ilence_level).. 
-000028f0: 2020 2064 6566 2070 6572 6d75 7465 645f     def permuted_
-00002900: 636f 7079 2873 656c 662c 2070 6572 6d75  copy(self, permu
-00002910: 7461 7469 6f6e 293a 0a20 2020 2020 2020  tation):.       
-00002920: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
-00002930: 7572 6e20 6120 636f 7079 206f 6620 7468  urn a copy of th
-00002940: 6520 6e65 7477 6f72 6b20 7769 7468 206e  e network with n
-00002950: 6f64 6520 6e75 6d62 6572 7320 7265 6172  ode numbers rear
-00002960: 7261 6e67 6564 2e20 5468 6973 0a20 2020  ranged. This.   
-00002970: 2020 2020 206f 7065 7261 7469 6f6e 2073       operation s
-00002980: 686f 756c 6420 6e6f 7420 6368 616e 6765  hould not change
-00002990: 2074 6f70 6f6c 6f67 6963 616c 2069 6e66   topological inf
-000029a0: 6f72 6d61 7469 6f6e 2061 6e64 206e 6574  ormation and net
-000029b0: 776f 726b 0a20 2020 2020 2020 206d 6561  work.        mea
-000029c0: 7375 7265 732e 0a0a 2020 2020 2020 2020  sures...        
-000029d0: 3a74 7970 6520 7065 726d 7574 6174 696f  :type permutatio
-000029e0: 6e3a 2061 7272 6179 2d6c 696b 6520 5b69  n: array-like [i
-000029f0: 6e74 5d0a 2020 2020 2020 2020 3a61 7267  nt].        :arg
-00002a00: 2070 6572 6d75 7461 7469 6f6e 3a20 6465   permutation: de
-00002a10: 7369 7265 6420 7065 726d 7574 6174 696f  sired permutatio
-00002a20: 6e20 6f66 206e 6f64 6573 0a20 2020 2020  n of nodes.     
-00002a30: 2020 203a 7274 7970 653a 203a 636c 6173     :rtype: :clas
-00002a40: 733a 604e 6574 776f 726b 6020 696e 7374  s:`Network` inst
-00002a50: 616e 6365 0a20 2020 2020 2020 2022 2222  ance.        """
-00002a60: 0a20 2020 2020 2020 2069 6478 203d 206e  .        idx = n
-00002a70: 702e 6172 7261 7928 7065 726d 7574 6174  p.array(permutat
-00002a80: 696f 6e29 0a20 2020 2020 2020 2069 6620  ion).        if 
-00002a90: 2873 6f72 7465 6428 6964 7829 2021 3d20  (sorted(idx) != 
-00002aa0: 6e70 2e61 7261 6e67 6528 7365 6c66 2e4e  np.arange(self.N
-00002ab0: 2929 2e61 6e79 2829 3a0a 2020 2020 2020  )).any():.      
-00002ac0: 2020 2020 2020 7261 6973 6520 4e65 7477        raise Netw
-00002ad0: 6f72 6b45 7272 6f72 2822 496e 636f 7272  orkError("Incorr
-00002ae0: 6563 7420 7065 726d 7574 6174 696f 6e20  ect permutation 
-00002af0: 696e 6469 6365 7321 2229 0a0a 2020 2020  indices!")..    
-00002b00: 2020 2020 7265 7475 726e 204e 6574 776f      return Netwo
-00002b10: 726b 2861 646a 6163 656e 6379 3d73 656c  rk(adjacency=sel
-00002b20: 662e 7370 5f41 5b69 6478 5d5b 3a2c 2069  f.sp_A[idx][:, i
-00002b30: 6478 5d2c 0a20 2020 2020 2020 2020 2020  dx],.           
-00002b40: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
-00002b50: 5f77 6569 6768 7473 3d73 656c 662e 6e6f  _weights=self.no
-00002b60: 6465 5f77 6569 6768 7473 5b69 6478 5d2c  de_weights[idx],
-00002b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002b80: 2020 2020 2020 2020 6469 7265 6374 6564          directed
-00002b90: 3d73 656c 662e 6469 7265 6374 6564 2c0a  =self.directed,.
-00002ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bb0: 2020 2020 2020 2073 696c 656e 6365 5f6c         silence_l
-00002bc0: 6576 656c 3d73 656c 662e 7369 6c65 6e63  evel=self.silenc
-00002bd0: 655f 6c65 7665 6c29 0a0a 2020 2020 6465  e_level)..    de
-00002be0: 6620 7370 6c69 7474 6564 5f63 6f70 7928  f splitted_copy(
-00002bf0: 7365 6c66 2c20 6e6f 6465 3d2d 312c 2070  self, node=-1, p
-00002c00: 726f 706f 7274 696f 6e3d 302e 3529 3a0a  roportion=0.5):.
-00002c10: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00002c20: 2020 2020 5265 7475 726e 2061 2063 6f70      Return a cop
-00002c30: 7920 6f66 2074 6865 206e 6574 776f 726b  y of the network
-00002c40: 2077 6974 6820 6f6e 6520 6e6f 6465 2073   with one node s
-00002c50: 706c 6974 7465 642e 0a0a 2020 2020 2020  plitted...      
-00002c60: 2020 5468 6520 7370 6563 6966 6965 6420    The specified 
-00002c70: 6e6f 6465 2069 7320 7370 6c69 7420 696e  node is split in
-00002c80: 2074 776f 2069 6e74 6572 6c69 6e6b 6564   two interlinked
-00002c90: 206e 6f64 6573 0a20 2020 2020 2020 2077   nodes.        w
-00002ca0: 6869 6368 2061 7265 206c 696e 6b65 6420  hich are linked 
-00002cb0: 746f 2074 6865 2073 616d 6520 6e6f 6465  to the same node
-00002cc0: 7320 6173 2074 6865 206f 7269 6769 6e61  s as the origina
-00002cd0: 6c20 6e6f 6465 2c0a 2020 2020 2020 2020  l node,.        
-00002ce0: 616e 6420 7468 6520 7765 6967 6874 2069  and the weight i
-00002cf0: 7320 7370 6c69 7474 6564 2061 6363 6f72  s splitted accor
-00002d00: 6469 6e67 2074 6f20 7468 6520 6769 7665  ding to the give
-00002d10: 6e20 7072 6f70 6f72 7469 6f6e 2e0a 0a20  n proportion... 
-00002d20: 2020 2020 2020 2028 5468 6973 206d 6574         (This met
-00002d30: 686f 6420 6973 2075 7365 6675 6c20 666f  hod is useful fo
-00002d40: 7220 7465 7374 696e 6720 7468 6520 6e6f  r testing the no
-00002d50: 6465 2073 706c 6974 7469 6e67 2069 6e76  de splitting inv
-00002d60: 6172 6961 6e63 650a 2020 2020 2020 2020  ariance.        
-00002d70: 6f66 206d 6561 7375 7265 7320 7369 6e63  of measures sinc
-00002d80: 6520 6120 6e2e 732e 692e 206d 6561 7375  e a n.s.i. measu
-00002d90: 7265 2077 696c 6c20 6265 2074 6865 2073  re will be the s
-00002da0: 616d 6520 6265 666f 7265 2061 6e64 2061  ame before and a
-00002db0: 6674 6572 0a20 2020 2020 2020 2074 6865  fter.        the
-00002dc0: 2073 706c 6974 2e29 0a0a 2020 2020 2020   split.)..      
-00002dd0: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
-00002de0: 2020 2020 2020 2020 3e3e 3e20 6e65 7420          >>> net 
-00002df0: 3d20 4e65 7477 6f72 6b2e 536d 616c 6c54  = Network.SmallT
-00002e00: 6573 744e 6574 776f 726b 2829 3b20 7072  estNetwork(); pr
-00002e10: 696e 7428 6e65 7429 0a20 2020 2020 2020  int(net).       
-00002e20: 204e 6574 776f 726b 3a20 756e 6469 7265   Network: undire
-00002e30: 6374 6564 2c20 3620 6e6f 6465 732c 2037  cted, 6 nodes, 7
-00002e40: 206c 696e 6b73 2c20 6c69 6e6b 2064 656e   links, link den
-00002e50: 7369 7479 2030 2e34 3637 2e0a 2020 2020  sity 0.467..    
-00002e60: 2020 2020 3e3e 3e20 6e65 7432 203d 206e      >>> net2 = n
-00002e70: 6574 2e73 706c 6974 7465 645f 636f 7079  et.splitted_copy
-00002e80: 286e 6f64 653d 352c 2070 726f 706f 7274  (node=5, proport
-00002e90: 696f 6e3d 302e 3229 3b20 7072 696e 7428  ion=0.2); print(
-00002ea0: 6e65 7432 290a 2020 2020 2020 2020 4e65  net2).        Ne
-00002eb0: 7477 6f72 6b3a 2075 6e64 6972 6563 7465  twork: undirecte
-00002ec0: 642c 2037 206e 6f64 6573 2c20 3920 6c69  d, 7 nodes, 9 li
-00002ed0: 6e6b 732c 206c 696e 6b20 6465 6e73 6974  nks, link densit
-00002ee0: 7920 302e 3432 392e 0a20 2020 2020 2020  y 0.429..       
-00002ef0: 203e 3e3e 2070 7269 6e74 286e 6574 2e6e   >>> print(net.n
-00002f00: 6f64 655f 7765 6967 6874 7329 3b20 7072  ode_weights); pr
-00002f10: 696e 7428 6e65 7432 2e6e 6f64 655f 7765  int(net2.node_we
-00002f20: 6967 6874 7329 0a20 2020 2020 2020 205b  ights).        [
-00002f30: 2031 2e35 2020 312e 3720 2031 2e39 2020   1.5  1.7  1.9  
-00002f40: 322e 3120 2032 2e33 2020 322e 355d 0a20  2.1  2.3  2.5]. 
-00002f50: 2020 2020 2020 205b 2031 2e35 2020 312e         [ 1.5  1.
-00002f60: 3720 2031 2e39 2020 322e 3120 2032 2e33  7  1.9  2.1  2.3
-00002f70: 2020 322e 2020 302e 355d 0a0a 2020 2020    2.  0.5]..    
-00002f80: 2020 2020 3a74 7970 6520 6e6f 6465 3a20      :type node: 
-00002f90: 696e 740a 2020 2020 2020 2020 3a61 7267  int.        :arg
-00002fa0: 2020 6e6f 6465 3a20 5468 6520 696e 6465    node: The inde
-00002fb0: 7820 6f66 2074 6865 206e 6f64 6520 746f  x of the node to
-00002fc0: 2062 6520 7370 6c69 7474 6564 2e20 4966   be splitted. If
-00002fd0: 206e 6567 6174 6976 652c 0a20 2020 2020   negative,.     
-00002fe0: 2020 2020 2020 2020 2020 2020 2020 204e                 N
-00002ff0: 202b 2069 6e64 6578 2069 7320 7573 6564   + index is used
-00003000: 2e20 5468 6520 6e65 7720 6e6f 6465 2067  . The new node g
-00003010: 6574 7320 696e 6465 7820 4e2e 2028 4465  ets index N. (De
-00003020: 6661 756c 743a 202d 3129 0a0a 2020 2020  fault: -1)..    
-00003030: 2020 2020 3a74 7970 6520 7072 6f70 6f72      :type propor
-00003040: 7469 6f6e 3a20 666c 6f61 7420 6672 6f6d  tion: float from
-00003050: 2030 2074 6f20 310a 2020 2020 2020 2020   0 to 1.        
-00003060: 3a61 7267 2020 7072 6f70 6f72 7469 6f6e  :arg  proportion
-00003070: 3a20 5468 6520 7370 6c69 7474 6564 206e  : The splitted n
-00003080: 6f64 6520 6765 7473 2061 206e 6577 2077  ode gets a new w
-00003090: 6569 6768 7420 6f66 0a20 2020 2020 2020  eight of.       
-000030a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030b0: 2020 2028 312d 7072 6f70 6f72 7469 6f6e     (1-proportion
-000030c0: 2920 2a20 2877 6569 6768 7420 6f66 2073  ) * (weight of s
-000030d0: 706c 6974 7465 6420 6e6f 6465 292c 0a20  plitted node),. 
-000030e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000030f0: 2020 2020 2020 2020 2061 6e64 2074 6865           and the
-00003100: 206e 6577 206e 6f64 6520 6765 7473 2061   new node gets a
-00003110: 2077 6569 6768 7420 6f66 0a20 2020 2020   weight of.     
-00003120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003130: 2020 2020 2070 726f 706f 7274 696f 6e20       proportion 
-00003140: 2a20 2877 6569 6768 7420 6f66 2073 706c  * (weight of spl
-00003150: 6974 7465 6420 6e6f 6465 292e 0a20 2020  itted node)..   
-00003160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003170: 2020 2020 2020 2028 4465 6661 756c 743a         (Default:
-00003180: 2030 2e35 290a 0a20 2020 2020 2020 203a   0.5)..        :
-00003190: 7274 7970 653a 203a 636c 6173 733a 604e  rtype: :class:`N
-000031a0: 6574 776f 726b 600a 2020 2020 2020 2020  etwork`.        
-000031b0: 2222 220a 2020 2020 2020 2020 4e2c 2041  """.        N, A
-000031c0: 2c20 7720 3d20 7365 6c66 2e4e 2c20 7365  , w = self.N, se
-000031d0: 6c66 2e73 705f 412c 2073 656c 662e 6e6f  lf.sp_A, self.no
-000031e0: 6465 5f77 6569 6768 7473 0a20 2020 2020  de_weights.     
-000031f0: 2020 2069 6620 6e6f 6465 203c 2030 3a0a     if node < 0:.
-00003200: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
-00003210: 202b 3d20 4e0a 0a20 2020 2020 2020 206e   += N..        n
-00003220: 6577 5f41 203d 2073 702e 6c69 6c5f 6d61  ew_A = sp.lil_ma
-00003230: 7472 6978 2828 4e2b 312c 204e 2b31 2929  trix((N+1, N+1))
-00003240: 0a20 2020 2020 2020 206e 6577 5f77 203d  .        new_w =
-00003250: 206e 702e 7a65 726f 7328 4e2b 3129 0a20   np.zeros(N+1). 
-00003260: 2020 2020 2020 206e 6577 5f41 5b3a 4e2c         new_A[:N,
-00003270: 203a 4e5d 203d 2041 0a20 2020 2020 2020   :N] = A.       
-00003280: 2023 2061 6464 206c 6173 7420 726f 7720   # add last row 
-00003290: 616e 6420 636f 6c75 6d6e 0a20 2020 2020  and column.     
-000032a0: 2020 206e 6577 5f41 5b3a 4e2c 204e 5d20     new_A[:N, N] 
-000032b0: 3d20 415b 3a2c 206e 6f64 655d 0a20 2020  = A[:, node].   
-000032c0: 2020 2020 206e 6577 5f41 5b4e 2c20 3a4e       new_A[N, :N
-000032d0: 5d20 3d20 415b 6e6f 6465 2c20 3a5d 0a20  ] = A[node, :]. 
-000032e0: 2020 2020 2020 2023 2063 6f6e 6e65 6374         # connect
-000032f0: 206e 6577 206e 6f64 6520 7769 7468 206f   new node with o
-00003300: 7269 6769 6e61 6c0a 2020 2020 2020 2020  riginal.        
-00003310: 6e65 775f 415b 6e6f 6465 2c20 4e5d 203d  new_A[node, N] =
-00003320: 206e 6577 5f41 5b4e 2c20 6e6f 6465 5d20   new_A[N, node] 
-00003330: 3d20 310a 2020 2020 2020 2020 2320 636f  = 1.        # co
-00003340: 7079 2061 6e64 2061 646a 7573 7420 7765  py and adjust we
-00003350: 6967 6874 730a 2020 2020 2020 2020 6e65  ights.        ne
-00003360: 775f 775b 3a4e 5d20 3d20 775b 3a4e 5d0a  w_w[:N] = w[:N].
-00003370: 2020 2020 2020 2020 6e65 775f 775b 4e5d          new_w[N]
-00003380: 203d 2070 726f 706f 7274 696f 6e20 2a20   = proportion * 
-00003390: 775b 6e6f 6465 5d0a 2020 2020 2020 2020  w[node].        
-000033a0: 6e65 775f 775b 6e6f 6465 5d20 3d20 2831  new_w[node] = (1
-000033b0: 2e30 202d 2070 726f 706f 7274 696f 6e29  .0 - proportion)
-000033c0: 202a 2077 5b6e 6f64 655d 0a0a 2020 2020   * w[node]..    
-000033d0: 2020 2020 6e65 775f 4e57 203d 204e 6574      new_NW = Net
-000033e0: 776f 726b 2861 646a 6163 656e 6379 3d6e  work(adjacency=n
-000033f0: 6577 5f41 2c20 6469 7265 6374 6564 3d73  ew_A, directed=s
-00003400: 656c 662e 6469 7265 6374 6564 2c0a 2020  elf.directed,.  
-00003410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003420: 2020 2020 2020 206e 6f64 655f 7765 6967         node_weig
-00003430: 6874 733d 6e65 775f 772c 2073 696c 656e  hts=new_w, silen
-00003440: 6365 5f6c 6576 656c 3d73 656c 662e 7369  ce_level=self.si
-00003450: 6c65 6e63 655f 6c65 7665 6c29 0a20 2020  lence_level).   
-00003460: 2020 2020 2023 202d 2d20 436f 7079 206c       # -- Copy l
-00003470: 696e 6b20 6174 7472 6962 7574 6573 0a20  ink attributes. 
-00003480: 2020 2020 2020 2066 6f72 2061 2069 6e20         for a in 
-00003490: 7365 6c66 2e67 7261 7068 2e65 732e 6174  self.graph.es.at
-000034a0: 7472 6962 7574 6573 2829 3a0a 2020 2020  tributes():.    
-000034b0: 2020 2020 2020 2020 5720 3d20 7365 6c66          W = self
-000034c0: 2e6c 696e 6b5f 6174 7472 6962 7574 6528  .link_attribute(
-000034d0: 6129 0a20 2020 2020 2020 2020 2020 206e  a).            n
-000034e0: 6577 5f57 203d 206e 702e 7a65 726f 7328  ew_W = np.zeros(
-000034f0: 284e 2b31 2c20 4e2b 3129 290a 2020 2020  (N+1, N+1)).    
-00003500: 2020 2020 2020 2020 6e65 775f 575b 3a4e          new_W[:N
-00003510: 2c20 3a4e 5d20 3d20 570a 2020 2020 2020  , :N] = W.      
-00003520: 2020 2020 2020 2320 6164 6420 6c61 7374        # add last
-00003530: 2072 6f77 2061 6e64 2063 6f6c 756d 6e0a   row and column.
-00003540: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
-00003550: 575b 3a4e 2c20 4e5d 203d 2057 5b3a 2c20  W[:N, N] = W[:, 
-00003560: 6e6f 6465 5d0a 2020 2020 2020 2020 2020  node].          
-00003570: 2020 6e65 775f 575b 4e2c 203a 4e5d 203d    new_W[N, :N] =
-00003580: 2057 5b6e 6f64 652c 203a 5d0a 2020 2020   W[node, :].    
-00003590: 2020 2020 2020 2020 2320 6173 7369 676e          # assign
-000035a0: 2077 6569 6768 7420 6265 7477 6565 6e20   weight between 
-000035b0: 6e65 7720 6e6f 6465 2061 6e64 206f 7269  new node and ori
-000035c0: 6769 6e61 6c20 616e 6420 666f 7220 7365  ginal and for se
-000035d0: 6c66 206c 6f6f 700a 2020 2020 2020 2020  lf loop.        
-000035e0: 2020 2020 6e65 775f 575b 6e6f 6465 2c20      new_W[node, 
-000035f0: 4e5d 203d 206e 6577 5f57 5b4e 2c20 6e6f  N] = new_W[N, no
-00003600: 6465 5d20 3d20 6e65 775f 575b 4e2c 204e  de] = new_W[N, N
-00003610: 5d20 3d20 575b 6e6f 6465 2c20 6e6f 6465  ] = W[node, node
-00003620: 5d0a 2020 2020 2020 2020 2020 2020 6e65  ].            ne
-00003630: 775f 4e57 2e73 6574 5f6c 696e 6b5f 6174  w_NW.set_link_at
-00003640: 7472 6962 7574 6528 612c 206e 6577 5f57  tribute(a, new_W
-00003650: 290a 2020 2020 2020 2020 2320 2d2d 0a20  ).        # --. 
-00003660: 2020 2020 2020 2072 6574 7572 6e20 6e65         return ne
-00003670: 775f 4e57 0a0a 2020 2020 4070 726f 7065  w_NW..    @prope
-00003680: 7274 790a 2020 2020 6465 6620 6164 6a61  rty.    def adja
-00003690: 6365 6e63 7928 7365 6c66 293a 0a20 2020  cency(self):.   
-000036a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000036b0: 2052 6574 7572 6e20 7468 6520 2870 6f73   Return the (pos
-000036c0: 7369 626c 7920 6e6f 6e2d 7379 6d6d 6574  sibly non-symmet
-000036d0: 7269 6329 2061 646a 6163 656e 6379 206d  ric) adjacency m
-000036e0: 6174 7269 7820 6173 2061 2064 656e 7365  atrix as a dense
-000036f0: 206d 6174 7269 782e 0a0a 2020 2020 2020   matrix...      
-00003700: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
-00003710: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
-00003720: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-00003730: 6574 776f 726b 2829 2e61 646a 6163 656e  etwork().adjacen
-00003740: 6379 290a 2020 2020 2020 2020 6172 7261  cy).        arra
-00003750: 7928 5b5b 302c 2030 2c20 302c 2031 2c20  y([[0, 0, 0, 1, 
-00003760: 312c 2031 5d2c 205b 302c 2030 2c20 312c  1, 1], [0, 0, 1,
-00003770: 2031 2c20 312c 2030 5d2c 205b 302c 2031   1, 1, 0], [0, 1
-00003780: 2c20 302c 2030 2c20 312c 2030 5d2c 0a20  , 0, 0, 1, 0],. 
-00003790: 2020 2020 2020 2020 2020 2020 2020 5b31                [1
-000037a0: 2c20 312c 2030 2c20 302c 2030 2c20 305d  , 1, 0, 0, 0, 0]
-000037b0: 2c20 5b31 2c20 312c 2031 2c20 302c 2030  , [1, 1, 1, 0, 0
-000037c0: 2c20 305d 2c20 5b31 2c20 302c 2030 2c20  , 0], [1, 0, 0, 
-000037d0: 302c 2030 2c20 305d 5d29 0a0a 2020 2020  0, 0, 0]])..    
-000037e0: 2020 2020 3a72 7479 7065 3a20 7371 7561      :rtype: squa
-000037f0: 7265 206e 756d 7079 2061 7272 6179 205b  re numpy array [
-00003800: 6e6f 6465 2c6e 6f64 655d 206f 6620 3073  node,node] of 0s
-00003810: 2061 6e64 2031 730a 2020 2020 2020 2020   and 1s.        
-00003820: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00003830: 726e 2073 656c 662e 7370 5f41 2e41 0a0a  rn self.sp_A.A..
-00003840: 2020 2020 6465 6620 5f73 6574 5f61 646a      def _set_adj
-00003850: 6163 656e 6379 2873 656c 662c 2061 646a  acency(self, adj
-00003860: 6163 656e 6379 293a 0a20 2020 2020 2020  acency):.       
-00003870: 2022 2222 0a20 2020 2020 2020 2053 6574   """.        Set
-00003880: 2061 206e 6577 2061 646a 6163 656e 6379   a new adjacency
-00003890: 206d 6174 7269 782e 0a0a 2020 2020 2020   matrix...      
-000038a0: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
-000038b0: 2020 2020 2020 2020 3e3e 3e20 6e65 7420          >>> net 
-000038c0: 3d20 4e65 7477 6f72 6b2e 536d 616c 6c54  = Network.SmallT
-000038d0: 6573 744e 6574 776f 726b 2829 3b20 7072  estNetwork(); pr
-000038e0: 696e 7428 6e65 7429 0a20 2020 2020 2020  int(net).       
-000038f0: 204e 6574 776f 726b 3a20 756e 6469 7265   Network: undire
-00003900: 6374 6564 2c20 3620 6e6f 6465 732c 2037  cted, 6 nodes, 7
-00003910: 206c 696e 6b73 2c20 6c69 6e6b 2064 656e   links, link den
-00003920: 7369 7479 2030 2e34 3637 2e0a 2020 2020  sity 0.467..    
-00003930: 2020 2020 3e3e 3e20 6e65 742e 6164 6a61      >>> net.adja
-00003940: 6365 6e63 7920 3d20 5b5b 302c 315d 2c5b  cency = [[0,1],[
-00003950: 312c 305d 5d3b 2070 7269 6e74 286e 6574  1,0]]; print(net
-00003960: 290a 2020 2020 2020 2020 4e65 7477 6f72  ).        Networ
-00003970: 6b3a 2075 6e64 6972 6563 7465 642c 2032  k: undirected, 2
-00003980: 206e 6f64 6573 2c20 3120 6c69 6e6b 732c   nodes, 1 links,
-00003990: 206c 696e 6b20 6465 6e73 6974 7920 312e   link density 1.
-000039a0: 3030 302e 0a0a 2020 2020 2020 2020 3a74  000...        :t
-000039b0: 7970 6520 6164 6a61 6365 6e63 793a 2073  ype adjacency: s
-000039c0: 7175 6172 6520 6172 7261 792d 6c69 6b65  quare array-like
-000039d0: 205b 5b30 7c31 5d5d 0a20 2020 2020 2020   [[0|1]].       
-000039e0: 203a 6172 6720 2061 646a 6163 656e 6379   :arg  adjacency
-000039f0: 3a20 456e 7472 7920 5b69 2c6a 5d20 696e  : Entry [i,j] in
-00003a00: 6469 6361 7465 7320 7768 6574 6865 7220  dicates whether 
-00003a10: 6e6f 6465 2069 206c 696e 6b73 2074 6f20  node i links to 
-00003a20: 6e6f 6465 206a 2e0a 2020 2020 2020 2020  node j..        
-00003a30: 2020 2020 4974 7320 6469 6167 6f6e 616c      Its diagonal
-00003a40: 206d 7573 7420 6265 207a 6572 6f2e 2053   must be zero. S
-00003a50: 796d 6d65 7472 6963 2069 6620 7468 6520  ymmetric if the 
-00003a60: 6e65 7477 6f72 6b20 6973 2075 6e64 6972  network is undir
-00003a70: 6563 7465 642e 0a20 2020 2020 2020 2022  ected..        "
-00003a80: 2222 0a20 2020 2020 2020 2023 2063 6f6e  "".        # con
-00003a90: 7665 7274 2074 6f20 7370 6172 7365 206d  vert to sparse m
-00003aa0: 6174 7269 780a 2020 2020 2020 2020 7365  atrix.        se
-00003ab0: 6c66 2e73 705f 4120 3d20 4e6f 6e65 0a20  lf.sp_A = None. 
-00003ac0: 2020 2020 2020 2069 6620 6e6f 7420 7370         if not sp
-00003ad0: 2e69 7373 7061 7273 6528 6164 6a61 6365  .issparse(adjace
-00003ae0: 6e63 7929 3a0a 2020 2020 2020 2020 2020  ncy):.          
-00003af0: 2020 6164 6a61 6365 6e63 7920 3d20 7370    adjacency = sp
-00003b00: 2e63 7363 5f6d 6174 7269 7828 6e70 2e61  .csc_matrix(np.a
-00003b10: 7272 6179 2861 646a 6163 656e 6379 2929  rray(adjacency))
-00003b20: 0a0a 2020 2020 2020 2020 2320 656e 7375  ..        # ensu
-00003b30: 7265 2073 7175 6172 6520 6d61 7472 6978  re square matrix
-00003b40: 0a20 2020 2020 2020 204d 2c20 4e20 3d20  .        M, N = 
-00003b50: 6164 6a61 6365 6e63 792e 7368 6170 650a  adjacency.shape.
-00003b60: 2020 2020 2020 2020 6966 204d 2021 3d20          if M != 
-00003b70: 4e3a 0a20 2020 2020 2020 2020 2020 2072  N:.            r
-00003b80: 6169 7365 204e 6574 776f 726b 4572 726f  aise NetworkErro
-00003b90: 7228 2241 646a 6163 656e 6379 206d 7573  r("Adjacency mus
-00003ba0: 7420 6265 2073 7175 6172 6521 2229 0a20  t be square!"). 
-00003bb0: 2020 2020 2020 2073 656c 662e 4e20 3d20         self.N = 
-00003bc0: 4e0a 2020 2020 2020 2020 6966 204e 203c  N.        if N <
-00003bd0: 2033 3237 3637 3a0a 2020 2020 2020 2020   32767:.        
-00003be0: 2020 2020 7365 6c66 2e73 705f 6474 7970      self.sp_dtyp
-00003bf0: 6520 3d20 6e70 2e69 6e74 3136 0a20 2020  e = np.int16.   
-00003c00: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00003c10: 2020 2020 2020 2073 656c 662e 7370 5f64         self.sp_d
-00003c20: 7479 7065 203d 206e 702e 696e 7433 320a  type = np.int32.
-00003c30: 2020 2020 2020 2020 7365 6c66 2e73 705f          self.sp_
-00003c40: 4120 3d20 6164 6a61 6365 6e63 792e 746f  A = adjacency.to
-00003c50: 6373 6328 292e 6173 7479 7065 2873 656c  csc().astype(sel
-00003c60: 662e 7370 5f64 7479 7065 290a 0a20 2020  f.sp_dtype)..   
-00003c70: 2020 2020 2023 2063 616c 6375 6c61 7465       # calculate
-00003c80: 2067 7261 7068 2061 7474 7269 6275 7465   graph attribute
-00003c90: 730a 2020 2020 2020 2020 6564 6765 7320  s.        edges 
-00003ca0: 3d20 6e7a 5f63 6f6f 7264 7328 6164 6a61  = nz_coords(adja
-00003cb0: 6365 6e63 7929 0a20 2020 2020 2020 2073  cency).        s
-00003cc0: 656c 662e 6e5f 6c69 6e6b 7320 3d20 6564  elf.n_links = ed
-00003cd0: 6765 732e 7368 6170 655b 305d 0a20 2020  ges.shape[0].   
-00003ce0: 2020 2020 2073 656c 662e 6c69 6e6b 5f64       self.link_d
-00003cf0: 656e 7369 7479 203d 2031 2e30 202a 2073  ensity = 1.0 * s
-00003d00: 656c 662e 6e5f 6c69 6e6b 7320 2f20 4e20  elf.n_links / N 
-00003d10: 2f20 284e 202d 2031 290a 2020 2020 2020  / (N - 1).      
-00003d20: 2020 6966 206e 6f74 2073 656c 662e 6469    if not self.di
-00003d30: 7265 6374 6564 3a0a 2020 2020 2020 2020  rected:.        
-00003d40: 2020 2020 7365 6c66 2e6e 5f6c 696e 6b73      self.n_links
-00003d50: 202f 2f3d 2032 0a0a 2020 2020 2020 2020   //= 2..        
-00003d60: 2320 6372 6561 7465 2067 7261 7068 206f  # create graph o
-00003d70: 626a 6563 740a 2020 2020 2020 2020 7365  bject.        se
-00003d80: 6c66 2e67 7261 7068 203d 2069 6772 6170  lf.graph = igrap
-00003d90: 682e 4772 6170 6828 6e3d 4e2c 2065 6467  h.Graph(n=N, edg
-00003da0: 6573 3d6c 6973 7428 6564 6765 7329 2c0a  es=list(edges),.
-00003db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003dd0: 2020 6469 7265 6374 6564 3d73 656c 662e    directed=self.
-00003de0: 6469 7265 6374 6564 290a 2020 2020 2020  directed).      
-00003df0: 2020 7365 6c66 2e67 7261 7068 2e73 696d    self.graph.sim
-00003e00: 706c 6966 7928 290a 2020 2020 2020 2020  plify().        
-00003e10: 4e65 7477 6f72 6b2e 636c 6561 725f 6361  Network.clear_ca
-00003e20: 6368 6528 7365 6c66 290a 0a20 2020 2040  che(self)..    @
-00003e30: 6164 6a61 6365 6e63 792e 7365 7474 6572  adjacency.setter
-00003e40: 0a20 2020 2064 6566 2061 646a 6163 656e  .    def adjacen
-00003e50: 6379 2873 656c 662c 2061 646a 6163 656e  cy(self, adjacen
-00003e60: 6379 293a 0a20 2020 2020 2020 2073 656c  cy):.        sel
-00003e70: 662e 5f73 6574 5f61 646a 6163 656e 6379  f._set_adjacency
-00003e80: 2861 646a 6163 656e 6379 290a 0a20 2020  (adjacency)..   
-00003e90: 2064 6566 2073 6574 5f65 6467 655f 6c69   def set_edge_li
-00003ea0: 7374 2873 656c 662c 2065 6467 655f 6c69  st(self, edge_li
-00003eb0: 7374 2c20 6e5f 6e6f 6465 733d 4e6f 6e65  st, n_nodes=None
-00003ec0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00003ed0: 2020 2020 2020 2052 6573 6574 206e 6574         Reset net
-00003ee0: 776f 726b 2066 726f 6d20 616e 2065 6467  work from an edg
-00003ef0: 6520 6c69 7374 2072 6570 7265 7365 6e74  e list represent
-00003f00: 6174 696f 6e2e 0a0a 2020 2020 2020 2020  ation...        
-00003f10: 2e2e 206e 6f74 653a 3a0a 2020 2020 2020  .. note::.      
-00003f20: 2020 2020 2041 7373 756d 6573 2074 6861       Assumes tha
-00003f30: 7420 6e6f 6465 7320 6172 6520 6e75 6d62  t nodes are numb
-00003f40: 6572 6564 2062 7920 6e61 7475 7261 6c20  ered by natural 
-00003f50: 6e75 6d62 6572 7320 6672 6f6d 2030 2074  numbers from 0 t
-00003f60: 6f20 4e2d 310a 2020 2020 2020 2020 2020  o N-1.          
-00003f70: 2077 6974 686f 7574 2067 6170 7321 0a0a   without gaps!..
-00003f80: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
-00003f90: 653a 2a2a 0a0a 2020 2020 2020 2020 3a74  e:**..        :t
-00003fa0: 7970 6520 6564 6765 5f6c 6973 743a 2061  ype edge_list: a
-00003fb0: 7272 6179 2d6c 696b 6520 5b5b 696e 743e  rray-like [[int>
-00003fc0: 3d30 2c69 6e74 3e3d 305d 5d0a 2020 2020  =0,int>=0]].    
-00003fd0: 2020 2020 3a61 7267 2020 6564 6765 5f6c      :arg  edge_l
-00003fe0: 6973 743a 205b 5b69 2c6a 5d5d 2066 6f72  ist: [[i,j]] for
-00003ff0: 2065 6467 6573 2069 202d 3e20 6a0a 2020   edges i -> j.  
-00004000: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00004010: 2020 2320 2043 6f6e 7665 7274 2074 6f20    #  Convert to 
-00004020: 4e75 6d70 7920 6172 7261 7920 616e 6420  Numpy array and 
-00004030: 6765 7420 6e75 6d62 6572 206f 6620 6e6f  get number of no
-00004040: 6465 730a 2020 2020 2020 2020 6564 6765  des.        edge
-00004050: 7320 3d20 6e70 2e61 7272 6179 2865 6467  s = np.array(edg
-00004060: 655f 6c69 7374 290a 0a20 2020 2020 2020  e_list)..       
-00004070: 2069 6620 6e5f 6e6f 6465 7320 6973 204e   if n_nodes is N
-00004080: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00004090: 204e 203d 2065 6467 6573 2e6d 6178 2829   N = edges.max()
-000040a0: 202b 2031 0a20 2020 2020 2020 2065 6c73   + 1.        els
-000040b0: 653a 0a20 2020 2020 2020 2020 2020 204e  e:.            N
-000040c0: 203d 206e 5f6e 6f64 6573 0a0a 2020 2020   = n_nodes..    
-000040d0: 2020 2020 2320 2053 796d 6d65 7472 697a      #  Symmetriz
-000040e0: 6520 6966 2075 6e64 6972 6563 7465 6420  e if undirected 
-000040f0: 6e65 7477 6f72 6b0a 2020 2020 2020 2020  network.        
-00004100: 6966 206e 6f74 2073 656c 662e 6469 7265  if not self.dire
-00004110: 6374 6564 3a0a 2020 2020 2020 2020 2020  cted:.          
-00004120: 2020 6564 6765 7320 3d20 6e70 2e61 7070    edges = np.app
-00004130: 656e 6428 6564 6765 732c 2065 6467 6573  end(edges, edges
-00004140: 5b3a 2c20 5b31 2c20 305d 5d2c 2061 7869  [:, [1, 0]], axi
-00004150: 733d 3029 0a0a 2020 2020 2020 2020 2320  s=0)..        # 
-00004160: 2043 7265 6174 6520 7370 6172 7365 2061   Create sparse a
-00004170: 646a 6163 656e 6379 206d 6174 7269 7820  djacency matrix 
-00004180: 6672 6f6d 2065 6467 6520 6c69 7374 0a20  from edge list. 
-00004190: 2020 2020 2020 2073 705f 4120 3d20 7370         sp_A = sp
-000041a0: 2e63 6f6f 5f6d 6174 7269 7828 0a20 2020  .coo_matrix(.   
-000041b0: 2020 2020 2020 2020 2028 6e70 2e6f 6e65           (np.one
-000041c0: 735f 6c69 6b65 2865 6467 6573 2e54 5b30  s_like(edges.T[0
-000041d0: 5d29 2c20 7475 706c 6528 6564 6765 732e  ]), tuple(edges.
-000041e0: 5429 292c 2073 6861 7065 3d28 4e2c 204e  T)), shape=(N, N
-000041f0: 2929 0a0a 2020 2020 2020 2020 2320 2053  ))..        #  S
-00004200: 6574 2073 7061 7273 6520 6164 6a61 6365  et sparse adjace
-00004210: 6e63 7920 6d61 7472 6978 0a20 2020 2020  ncy matrix.     
-00004220: 2020 2073 656c 662e 6164 6a61 6365 6e63     self.adjacenc
-00004230: 7920 3d20 7370 5f41 0a0a 2020 2020 4070  y = sp_A..    @p
-00004240: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00004250: 6e6f 6465 5f77 6569 6768 7473 2873 656c  node_weights(sel
-00004260: 6629 3a0a 2020 2020 2020 2020 2222 2228  f):.        """(
-00004270: 6172 7261 7928 5b69 6e74 3e3d 305d 2929  array([int>=0]))
-00004280: 2061 7272 6179 206f 6620 6e6f 6465 2077   array of node w
-00004290: 6569 6768 7473 2222 220a 2020 2020 2020  eights""".      
-000042a0: 2020 7265 7475 726e 2073 656c 662e 5f6e    return self._n
-000042b0: 6f64 655f 7765 6967 6874 730a 0a20 2020  ode_weights..   
-000042c0: 2064 6566 205f 7365 745f 6e6f 6465 5f77   def _set_node_w
-000042d0: 6569 6768 7473 2873 656c 662c 2077 6569  eights(self, wei
-000042e0: 6768 7473 293a 0a20 2020 2020 2020 2022  ghts):.        "
-000042f0: 2222 0a20 2020 2020 2020 2053 6574 2074  "".        Set t
-00004300: 6865 206e 6f64 6520 7765 6967 6874 7320  he node weights 
-00004310: 746f 2062 6520 7573 6564 2066 6f72 206e  to be used for n
-00004320: 6f64 6520 7370 6c69 7474 696e 6720 696e  ode splitting in
-00004330: 7661 7269 616e 7420 6e65 7477 6f72 6b0a  variant network.
-00004340: 2020 2020 2020 2020 6d65 6173 7572 6573          measures
-00004350: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
-00004360: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
-00004370: 203e 3e3e 206e 6574 203d 204e 6574 776f   >>> net = Netwo
-00004380: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-00004390: 6f72 6b28 293b 2070 7269 6e74 286e 6574  ork(); print(net
-000043a0: 2e6e 6f64 655f 7765 6967 6874 7329 0a20  .node_weights). 
-000043b0: 2020 2020 2020 205b 2031 2e35 2020 312e         [ 1.5  1.
-000043c0: 3720 2031 2e39 2020 322e 3120 2032 2e33  7  1.9  2.1  2.3
-000043d0: 2020 322e 355d 0a20 2020 2020 2020 203e    2.5].        >
-000043e0: 3e3e 206e 6574 2e6e 6f64 655f 7765 6967  >> net.node_weig
-000043f0: 6874 7320 3d20 5b31 2c31 2c31 2c31 2c31  hts = [1,1,1,1,1
-00004400: 2c31 5d3b 2070 7269 6e74 286e 6574 2e6e  ,1]; print(net.n
-00004410: 6f64 655f 7765 6967 6874 7329 0a20 2020  ode_weights).   
-00004420: 2020 2020 205b 2031 2e20 2031 2e20 2031       [ 1.  1.  1
-00004430: 2e20 2031 2e20 2031 2e20 2031 2e5d 0a0a  .  1.  1.  1.]..
-00004440: 2020 2020 2020 2020 3a74 7970 6520 7765          :type we
-00004450: 6967 6874 733a 2061 7272 6179 2d6c 696b  ights: array-lik
-00004460: 6520 5b66 6c6f 6174 3e3d 305d 0a20 2020  e [float>=0].   
-00004470: 2020 2020 203a 6172 6720 2077 6569 6768       :arg  weigh
-00004480: 7473 3a20 6172 7261 792d 6c69 6b65 205b  ts: array-like [
-00004490: 6e6f 6465 5d20 6f66 2077 6569 6768 7473  node] of weights
-000044a0: 2028 6465 6661 756c 743a 205b 312e 2e2e   (default: [1...
-000044b0: 315d 290a 2020 2020 2020 2020 2222 220a  1]).        """.
-000044c0: 2020 2020 2020 2020 4e20 3d20 7365 6c66          N = self
-000044d0: 2e4e 0a20 2020 2020 2020 2073 656c 662e  .N.        self.
-000044e0: 636c 6561 725f 6e73 695f 6361 6368 6528  clear_nsi_cache(
-000044f0: 290a 0a20 2020 2020 2020 2069 6620 7765  )..        if we
-00004500: 6967 6874 7320 6973 204e 6f6e 653a 0a20  ights is None:. 
-00004510: 2020 2020 2020 2020 2020 2077 203d 206e             w = n
-00004520: 702e 6f6e 6573 284e 2c20 6474 7970 653d  p.ones(N, dtype=
-00004530: 6e70 2e66 6c6f 6174 290a 2020 2020 2020  np.float).      
-00004540: 2020 656c 6966 206c 656e 2877 6569 6768    elif len(weigh
-00004550: 7473 2920 213d 204e 3a0a 2020 2020 2020  ts) != N:.      
-00004560: 2020 2020 2020 7261 6973 6520 4e65 7477        raise Netw
-00004570: 6f72 6b45 7272 6f72 2822 496e 636f 7272  orkError("Incorr
-00004580: 6563 7420 6e75 6d62 6572 206f 6620 6e6f  ect number of no
-00004590: 6465 2077 6569 6768 7473 2122 290a 2020  de weights!").  
-000045a0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000045b0: 2020 2020 2020 2020 7720 3d20 6e70 2e61          w = np.a
-000045c0: 7272 6179 2877 6569 6768 7473 2c20 6474  rray(weights, dt
-000045d0: 7970 653d 6e70 2e66 6c6f 6174 290a 0a20  ype=np.float).. 
-000045e0: 2020 2020 2020 2073 656c 662e 5f6e 6f64         self._nod
-000045f0: 655f 7765 6967 6874 7320 3d20 770a 2020  e_weights = w.  
-00004600: 2020 2020 2020 7365 6c66 2e6d 6561 6e5f        self.mean_
-00004610: 6e6f 6465 5f77 6569 6768 7420 3d20 772e  node_weight = w.
-00004620: 6d65 616e 2829 0a20 2020 2020 2020 2073  mean().        s
-00004630: 656c 662e 746f 7461 6c5f 6e6f 6465 5f77  elf.total_node_w
-00004640: 6569 6768 7420 3d20 772e 7375 6d28 290a  eight = w.sum().
-00004650: 0a20 2020 2040 6e6f 6465 5f77 6569 6768  .    @node_weigh
-00004660: 7473 2e73 6574 7465 720a 2020 2020 6465  ts.setter.    de
-00004670: 6620 6e6f 6465 5f77 6569 6768 7473 2873  f node_weights(s
-00004680: 656c 662c 206e 6f64 655f 7765 6967 6874  elf, node_weight
-00004690: 7329 3a0a 2020 2020 2020 2020 7365 6c66  s):.        self
-000046a0: 2e5f 7365 745f 6e6f 6465 5f77 6569 6768  ._set_node_weigh
-000046b0: 7473 286e 6f64 655f 7765 6967 6874 7329  ts(node_weights)
-000046c0: 0a0a 2020 2020 6465 6620 7370 5f41 706c  ..    def sp_Apl
-000046d0: 7573 2873 656c 6629 3a0a 2020 2020 2020  us(self):.      
-000046e0: 2020 2222 2241 5e2b 203d 2041 202b 2049    """A^+ = A + I
-000046f0: 642e 206d 6174 7269 7820 7573 6564 2069  d. matrix used i
-00004700: 6e20 6e2e 732e 692e 206d 6561 7375 7265  n n.s.i. measure
-00004710: 7322 2222 0a20 2020 2020 2020 2072 6574  s""".        ret
-00004720: 7572 6e20 7365 6c66 2e73 705f 4120 2b20  urn self.sp_A + 
-00004730: 7370 2e69 6465 6e74 6974 7928 7365 6c66  sp.identity(self
-00004740: 2e4e 2c20 6474 7970 653d 7365 6c66 2e73  .N, dtype=self.s
-00004750: 705f 6474 7970 6529 0a0a 2020 2020 6465  p_dtype)..    de
-00004760: 6620 7370 5f64 6961 675f 7728 7365 6c66  f sp_diag_w(self
-00004770: 293a 0a20 2020 2020 2020 2022 2222 5370  ):.        """Sp
-00004780: 6172 7365 2064 6961 676f 6e61 6c20 6d61  arse diagonal ma
-00004790: 7472 6978 206f 6620 6e6f 6465 2077 6569  trix of node wei
-000047a0: 6768 7473 2222 220a 2020 2020 2020 2020  ghts""".        
-000047b0: 7265 7475 726e 2073 702e 6469 6167 7328  return sp.diags(
-000047c0: 5b73 656c 662e 6e6f 6465 5f77 6569 6768  [self.node_weigh
-000047d0: 7473 5d2c 205b 305d 2c0a 2020 2020 2020  ts], [0],.      
-000047e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000047f0: 2020 7368 6170 653d 2873 656c 662e 4e2c    shape=(self.N,
-00004800: 2073 656c 662e 4e29 2c20 666f 726d 6174   self.N), format
-00004810: 3d27 6373 6327 290a 0a20 2020 2064 6566  ='csc')..    def
-00004820: 2073 705f 6469 6167 5f77 5f69 6e76 2873   sp_diag_w_inv(s
-00004830: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00004840: 2253 7061 7273 6520 6469 6167 6f6e 616c  "Sparse diagonal
-00004850: 206d 6174 7269 7820 6f66 2069 6e76 6572   matrix of inver
-00004860: 7365 206e 6f64 6520 7765 6967 6874 7322  se node weights"
-00004870: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00004880: 6e20 7370 2e64 6961 6773 285b 3120 2f20  n sp.diags([1 / 
-00004890: 7365 6c66 2e6e 6f64 655f 7765 6967 6874  self.node_weight
-000048a0: 735d 2c20 5b30 5d2c 0a20 2020 2020 2020  s], [0],.       
-000048b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000048c0: 2073 6861 7065 3d28 7365 6c66 2e4e 2c20   shape=(self.N, 
-000048d0: 7365 6c66 2e4e 292c 2066 6f72 6d61 743d  self.N), format=
-000048e0: 2763 7363 2729 0a0a 2020 2020 6465 6620  'csc')..    def 
-000048f0: 7370 5f64 6961 675f 7371 7274 5f77 2873  sp_diag_sqrt_w(s
-00004900: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00004910: 2253 7061 7273 6520 6469 6167 6f6e 616c  "Sparse diagonal
-00004920: 206d 6174 7269 7820 6f66 2073 7175 6172   matrix of squar
-00004930: 6520 726f 6f74 7320 6f66 206e 6f64 6520  e roots of node 
-00004940: 7765 6967 6874 7322 2222 0a20 2020 2020  weights""".     
-00004950: 2020 2072 6574 7572 6e20 7370 2e64 6961     return sp.dia
-00004960: 6773 285b 6e70 2e73 7172 7428 7365 6c66  gs([np.sqrt(self
-00004970: 2e6e 6f64 655f 7765 6967 6874 7329 5d2c  .node_weights)],
-00004980: 205b 305d 2c0a 2020 2020 2020 2020 2020   [0],.          
-00004990: 2020 2020 2020 2020 2020 2020 2020 7368                sh
-000049a0: 6170 653d 2873 656c 662e 4e2c 2073 656c  ape=(self.N, sel
-000049b0: 662e 4e29 2c20 666f 726d 6174 3d27 6373  f.N), format='cs
-000049c0: 6327 290a 0a20 2020 2023 0a20 2020 2023  c')..    #.    #
-000049d0: 2020 4c6f 6164 2061 6e64 2073 6176 6520    Load and save 
-000049e0: 4e65 7477 6f72 6b20 6f62 6a65 6374 0a20  Network object. 
-000049f0: 2020 2023 0a0a 2020 2020 6465 6620 7361     #..    def sa
-00004a00: 7665 2873 656c 662c 2066 696c 656e 616d  ve(self, filenam
-00004a10: 652c 2066 696c 6566 6f72 6d61 743d 4e6f  e, fileformat=No
-00004a20: 6e65 2c20 2a61 7267 732c 202a 2a6b 7764  ne, *args, **kwd
-00004a30: 7329 3a0a 2020 2020 2020 2020 2222 220a  s):.        """.
-00004a40: 2020 2020 2020 2020 5361 7665 2074 6865          Save the
-00004a50: 204e 6574 776f 726b 206f 626a 6563 7420   Network object 
-00004a60: 746f 2061 2066 696c 652e 0a0a 2020 2020  to a file...    
-00004a70: 2020 2020 556e 6966 6965 6420 7772 6974      Unified writ
-00004a80: 696e 6720 6675 6e63 7469 6f6e 2066 6f72  ing function for
-00004a90: 2067 7261 7068 732e 2052 656c 6965 7320   graphs. Relies 
-00004aa0: 6f6e 2061 6e64 2070 6172 7469 616c 6c79  on and partially
-00004ab0: 2065 7874 656e 6473 0a20 2020 2020 2020   extends.       
-00004ac0: 2074 6865 2063 6f72 7265 7370 6f6e 6469   the correspondi
-00004ad0: 6e67 2069 6772 6170 6820 6675 6e63 7469  ng igraph functi
-00004ae0: 6f6e 2e20 5265 6665 7220 746f 2069 6772  on. Refer to igr
-00004af0: 6170 6820 646f 6375 6d65 6e74 6174 696f  aph documentatio
-00004b00: 6e20 666f 720a 2020 2020 2020 2020 6675  n for.        fu
-00004b10: 7274 6865 7220 6465 7461 696c 7320 6f6e  rther details on
-00004b20: 2074 6865 2076 6172 696f 7573 2077 7269   the various wri
-00004b30: 7465 7220 6d65 7468 6f64 7320 666f 7220  ter methods for 
-00004b40: 6469 6666 6572 656e 7420 666f 726d 6174  different format
-00004b50: 732e 0a0a 2020 2020 2020 2020 5468 6973  s...        This
-00004b60: 206d 6574 686f 6420 7472 6965 7320 746f   method tries to
-00004b70: 2069 6465 6e74 6966 7920 7468 6520 666f   identify the fo
-00004b80: 726d 6174 206f 6620 7468 6520 6772 6170  rmat of the grap
-00004b90: 6820 6769 7665 6e20 696e 0a20 2020 2020  h given in.     
-00004ba0: 2020 2074 6865 2066 6972 7374 2070 6172     the first par
-00004bb0: 616d 6574 6572 2028 6261 7365 6420 6f6e  ameter (based on
-00004bc0: 2065 7874 656e 7369 6f6e 2920 616e 6420   extension) and 
-00004bd0: 6361 6c6c 7320 7468 6520 636f 7272 6573  calls the corres
-00004be0: 706f 6e64 696e 670a 2020 2020 2020 2020  ponding.        
-00004bf0: 7772 6974 6572 206d 6574 686f 642e 0a0a  writer method...
-00004c00: 2020 2020 2020 2020 4578 6973 7469 6e67          Existing
-00004c10: 206e 6f64 6520 616e 6420 6c69 6e6b 2061   node and link a
-00004c20: 7474 7269 6275 7465 732f 7765 6967 6874  ttributes/weight
-00004c30: 7320 6172 6520 616c 736f 2073 746f 7265  s are also store
-00004c40: 6420 6465 7065 6e64 696e 670a 2020 2020  d depending.    
-00004c50: 2020 2020 6f6e 2074 6865 2063 686f 7365      on the chose
-00004c60: 6e20 6669 6c65 2066 6f72 6d61 742e 2045  n file format. E
-00004c70: 2e67 2e2c 2074 6865 2066 6f72 6d61 7473  .g., the formats
-00004c80: 2047 7261 7068 4d4c 2061 6e64 2067 7a69   GraphML and gzi
-00004c90: 7070 6564 0a20 2020 2020 2020 2047 7261  pped.        Gra
-00004ca0: 7068 4d4c 2061 7265 2061 626c 6520 746f  phML are able to
-00004cb0: 2073 746f 7265 2062 6f74 6820 6e6f 6465   store both node
-00004cc0: 2061 6e64 206c 696e 6b20 7765 6967 6874   and link weight
-00004cd0: 732e 0a0a 2020 2020 2020 2020 5468 6520  s...        The 
-00004ce0: 7265 6d61 696e 696e 6720 6172 6775 6d65  remaining argume
-00004cf0: 6e74 7320 6172 6520 7061 7373 6564 2074  nts are passed t
-00004d00: 6f20 7468 6520 7772 6974 6572 206d 6574  o the writer met
-00004d10: 686f 6420 7769 7468 6f75 740a 2020 2020  hod without.    
-00004d20: 2020 2020 616e 7920 6368 616e 6765 732e      any changes.
-00004d30: 0a0a 2020 2020 2020 2020 3a61 7267 2073  ..        :arg s
-00004d40: 7472 2066 696c 656e 616d 653a 2054 6865  tr filename: The
-00004d50: 206e 616d 6520 6f66 2074 6865 2066 696c   name of the fil
-00004d60: 6520 7768 6572 6520 7468 6520 4e65 7477  e where the Netw
-00004d70: 6f72 6b20 6f62 6a65 6374 2069 7320 746f  ork object is to
-00004d80: 0a20 2020 2020 2020 2020 2020 2062 6520  .            be 
-00004d90: 7374 6f72 6564 2e0a 2020 2020 2020 2020  stored..        
-00004da0: 3a61 7267 2073 7472 2066 696c 6566 6f72  :arg str filefor
-00004db0: 6d61 743a 2074 6865 2066 6f72 6d61 7420  mat: the format 
-00004dc0: 6f66 2074 6865 2066 696c 6520 2869 6620  of the file (if 
-00004dd0: 6f6e 6520 7761 6e74 7320 746f 206f 7665  one wants to ove
-00004de0: 7272 6964 650a 2020 2020 2020 2020 2020  rride.          
-00004df0: 2020 7468 6520 666f 726d 6174 2064 6574    the format det
-00004e00: 6572 6d69 6e65 6420 6672 6f6d 2074 6865  ermined from the
-00004e10: 2066 696c 656e 616d 6520 6578 7465 6e73   filename extens
-00004e20: 696f 6e2c 206f 7220 7468 6520 6669 6c65  ion, or the file
-00004e30: 6e61 6d65 0a20 2020 2020 2020 2020 2020  name.           
-00004e40: 2069 7473 656c 6620 6973 2061 2073 7472   itself is a str
-00004e50: 6561 6d29 2e20 6060 4e6f 6e65 6060 206d  eam). ``None`` m
-00004e60: 6561 6e73 2061 7574 6f2d 6465 7465 6374  eans auto-detect
-00004e70: 696f 6e2e 2050 6f73 7369 626c 6520 7661  ion. Possible va
-00004e80: 6c75 6573 0a20 2020 2020 2020 2020 2020  lues.           
-00004e90: 2061 7265 3a20 6060 226e 636f 6c22 6060   are: ``"ncol"``
-00004ea0: 2028 4e43 4f4c 2066 6f72 6d61 7429 2c20   (NCOL format), 
-00004eb0: 6060 226c 676c 2260 6020 284c 474c 2066  ``"lgl"`` (LGL f
-00004ec0: 6f72 6d61 7429 2c0a 2020 2020 2020 2020  ormat),.        
-00004ed0: 2020 2020 6060 2267 7261 7068 6d6c 2260      ``"graphml"`
-00004ee0: 602c 2060 6022 6772 6170 686d 6c7a 2260  `, ``"graphmlz"`
-00004ef0: 6020 2847 7261 7068 4d4c 2061 6e64 2067  ` (GraphML and g
-00004f00: 7a69 7070 6564 2047 7261 7068 4d4c 2066  zipped GraphML f
-00004f10: 6f72 6d61 7429 2c0a 2020 2020 2020 2020  ormat),.        
-00004f20: 2020 2020 6060 2267 6d6c 2260 6020 2847      ``"gml"`` (G
-00004f30: 4d4c 2066 6f72 6d61 7429 2c20 6060 2264  ML format), ``"d
-00004f40: 6f74 2260 602c 2060 6022 6772 6170 6876  ot"``, ``"graphv
-00004f50: 697a 2260 6020 2844 4f54 2066 6f72 6d61  iz"`` (DOT forma
-00004f60: 742c 2075 7365 640a 2020 2020 2020 2020  t, used.        
-00004f70: 2020 2020 6279 2047 7261 7068 5669 7a29      by GraphViz)
-00004f80: 2c20 6060 226e 6574 2260 602c 2060 6022  , ``"net"``, ``"
-00004f90: 7061 6a65 6b22 6060 2028 5061 6a65 6b20  pajek"`` (Pajek 
-00004fa0: 666f 726d 6174 292c 2060 6022 6469 6d61  format), ``"dima
-00004fb0: 6373 2260 600a 2020 2020 2020 2020 2020  cs"``.          
-00004fc0: 2020 2844 494d 4143 5320 666f 726d 6174    (DIMACS format
-00004fd0: 292c 2060 6022 6564 6765 6c69 7374 2260  ), ``"edgelist"`
-00004fe0: 602c 2060 6022 6564 6765 7322 6060 206f  `, ``"edges"`` o
-00004ff0: 7220 6060 2265 6467 6522 6060 2028 6564  r ``"edge"`` (ed
-00005000: 6765 0a20 2020 2020 2020 2020 2020 206c  ge.            l
-00005010: 6973 7429 2c20 6060 2261 646a 6163 656e  ist), ``"adjacen
-00005020: 6379 2260 6020 2861 646a 6163 656e 6379  cy"`` (adjacency
-00005030: 206d 6174 7269 7829 2c20 6060 2270 6963   matrix), ``"pic
-00005040: 6b6c 6522 6060 2028 5079 7468 6f6e 0a20  kle"`` (Python. 
-00005050: 2020 2020 2020 2020 2020 2070 6963 6b6c             pickl
-00005060: 6564 2066 6f72 6d61 7429 2c20 6060 2273  ed format), ``"s
-00005070: 7667 2260 6020 2853 6361 6c61 626c 6520  vg"`` (Scalable 
-00005080: 5665 6374 6f72 2047 7261 7068 6963 7329  Vector Graphics)
-00005090: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-000050a0: 2020 2020 2020 2320 2053 746f 7265 206e        #  Store n
-000050b0: 6f64 6520 7765 6967 6874 7320 6173 2061  ode weights as a
-000050c0: 6e20 6967 7261 7068 2076 6572 7465 7820  n igraph vertex 
-000050d0: 6174 7472 6962 7574 6520 666f 7220 7361  attribute for sa
-000050e0: 7669 6e67 0a20 2020 2020 2020 2023 2020  ving.        #  
-000050f0: 4c69 6e6b 2061 7474 7269 6275 7465 732f  Link attributes/
-00005100: 7765 6967 6874 7320 6172 6520 7374 6f72  weights are stor
-00005110: 6564 2061 7574 6f6d 6174 6963 616c 6c79  ed automatically
-00005120: 2069 6620 7468 6579 2065 7869 7374 0a20   if they exist. 
-00005130: 2020 2020 2020 2069 6620 7365 6c66 2e6e         if self.n
-00005140: 6f64 655f 7765 6967 6874 7320 6973 206e  ode_weights is n
-00005150: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-00005160: 2020 2020 2073 656c 662e 6772 6170 682e       self.graph.
-00005170: 7673 2e73 6574 5f61 7474 7269 6275 7465  vs.set_attribute
-00005180: 5f76 616c 7565 7328 0a20 2020 2020 2020  _values(.       
-00005190: 2020 2020 2020 2020 2022 6e6f 6465 5f77           "node_w
-000051a0: 6569 6768 745f 6e73 6922 2c20 6c69 7374  eight_nsi", list
-000051b0: 2873 656c 662e 6e6f 6465 5f77 6569 6768  (self.node_weigh
-000051c0: 7473 2929 0a0a 2020 2020 2020 2020 7365  ts))..        se
-000051d0: 6c66 2e67 7261 7068 2e77 7269 7465 2866  lf.graph.write(f
-000051e0: 3d66 696c 656e 616d 652c 2066 6f72 6d61  =filename, forma
-000051f0: 743d 6669 6c65 666f 726d 6174 2c20 2a61  t=fileformat, *a
-00005200: 7267 732c 202a 2a6b 7764 7329 0a0a 2020  rgs, **kwds)..  
-00005210: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
-00005220: 2020 2020 6465 6620 4c6f 6164 2866 696c      def Load(fil
-00005230: 656e 616d 652c 2066 696c 6566 6f72 6d61  ename, fileforma
-00005240: 743d 4e6f 6e65 2c20 7369 6c65 6e63 655f  t=None, silence_
-00005250: 6c65 7665 6c3d 302c 202a 6172 6773 2c20  level=0, *args, 
-00005260: 2a2a 6b77 6473 293a 0a20 2020 2020 2020  **kwds):.       
-00005270: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
-00005280: 7572 6e20 6120 4e65 7477 6f72 6b20 6f62  urn a Network ob
-00005290: 6a65 6374 2073 746f 7265 6420 696e 2061  ject stored in a
-000052a0: 2066 696c 652e 0a0a 2020 2020 2020 2020   file...        
-000052b0: 556e 6966 6965 6420 7265 6164 696e 6720  Unified reading 
-000052c0: 6675 6e63 7469 6f6e 2066 6f72 2067 7261  function for gra
-000052d0: 7068 732e 2052 656c 6965 7320 6f6e 2061  phs. Relies on a
-000052e0: 6e64 2070 6172 7469 616c 6c79 2065 7874  nd partially ext
-000052f0: 656e 6473 0a20 2020 2020 2020 2074 6865  ends.        the
-00005300: 2063 6f72 7265 7370 6f6e 6469 6e67 2069   corresponding i
-00005310: 6772 6170 6820 6675 6e63 7469 6f6e 2e20  graph function. 
-00005320: 5265 6665 7220 746f 2069 6772 6170 6820  Refer to igraph 
-00005330: 646f 6375 6d65 6e74 6174 696f 6e20 666f  documentation fo
-00005340: 720a 2020 2020 2020 2020 6675 7274 6865  r.        furthe
-00005350: 7220 6465 7461 696c 7320 6f6e 2074 6865  r details on the
-00005360: 2076 6172 696f 7573 2072 6561 6465 7220   various reader 
-00005370: 6d65 7468 6f64 7320 666f 7220 6469 6666  methods for diff
-00005380: 6572 656e 7420 666f 726d 6174 732e 0a0a  erent formats...
-00005390: 2020 2020 2020 2020 5468 6973 206d 6574          This met
-000053a0: 686f 6420 7472 6965 7320 746f 2069 6465  hod tries to ide
-000053b0: 6e74 6966 7920 7468 6520 666f 726d 6174  ntify the format
-000053c0: 206f 6620 7468 6520 6772 6170 6820 6769   of the graph gi
-000053d0: 7665 6e20 696e 0a20 2020 2020 2020 2074  ven in.        t
-000053e0: 6865 2066 6972 7374 2070 6172 616d 6574  he first paramet
-000053f0: 6572 2061 6e64 2063 616c 6c73 2074 6865  er and calls the
-00005400: 2063 6f72 7265 7370 6f6e 6469 6e67 2072   corresponding r
-00005410: 6561 6465 7220 6d65 7468 6f64 2e0a 0a20  eader method... 
-00005420: 2020 2020 2020 2045 7869 7374 696e 6720         Existing 
-00005430: 6e6f 6465 2061 6e64 206c 696e 6b20 6174  node and link at
-00005440: 7472 6962 7574 6573 2f77 6569 6768 7473  tributes/weights
-00005450: 2061 7265 2061 6c73 6f20 7265 7374 6f72   are also restor
-00005460: 6564 2064 6570 656e 6469 6e67 0a20 2020  ed depending.   
-00005470: 2020 2020 206f 6e20 7468 6520 6368 6f73       on the chos
-00005480: 656e 2066 696c 6520 666f 726d 6174 2e20  en file format. 
-00005490: 452e 672e 2c20 7468 6520 666f 726d 6174  E.g., the format
-000054a0: 7320 4772 6170 684d 4c20 616e 6420 677a  s GraphML and gz
-000054b0: 6970 7065 640a 2020 2020 2020 2020 4772  ipped.        Gr
-000054c0: 6170 684d 4c20 6172 6520 6162 6c65 2074  aphML are able t
-000054d0: 6f20 7374 6f72 6520 626f 7468 206e 6f64  o store both nod
-000054e0: 6520 616e 6420 6c69 6e6b 2077 6569 6768  e and link weigh
-000054f0: 7473 2e0a 0a20 2020 2020 2020 2054 6865  ts...        The
-00005500: 2072 656d 6169 6e69 6e67 2061 7267 756d   remaining argum
-00005510: 656e 7473 2061 7265 2070 6173 7365 6420  ents are passed 
-00005520: 746f 2074 6865 2072 6561 6465 7220 6d65  to the reader me
-00005530: 7468 6f64 2077 6974 686f 7574 0a20 2020  thod without.   
-00005540: 2020 2020 2061 6e79 2063 6861 6e67 6573       any changes
-00005550: 2e0a 0a20 2020 2020 2020 203a 6172 6720  ...        :arg 
-00005560: 7374 7220 6669 6c65 6e61 6d65 3a20 5468  str filename: Th
-00005570: 6520 6e61 6d65 206f 6620 7468 6520 6669  e name of the fi
-00005580: 6c65 2063 6f6e 7461 696e 696e 6720 7468  le containing th
-00005590: 6520 4e65 7477 6f72 6b20 6f62 6a65 6374  e Network object
-000055a0: 2e0a 2020 2020 2020 2020 3a61 7267 2073  ..        :arg s
-000055b0: 7472 2066 696c 6566 6f72 6d61 743a 2074  tr fileformat: t
-000055c0: 6865 2066 6f72 6d61 7420 6f66 2074 6865  he format of the
-000055d0: 2066 696c 6520 2869 6620 6b6e 6f77 6e20   file (if known 
-000055e0: 696e 2061 6476 616e 6365 292e 0a20 2020  in advance)..   
-000055f0: 2020 2020 2020 2060 604e 6f6e 6560 6020         ``None`` 
-00005600: 6d65 616e 7320 6175 746f 2d64 6574 6563  means auto-detec
-00005610: 7469 6f6e 2e20 506f 7373 6962 6c65 2076  tion. Possible v
-00005620: 616c 7565 7320 6172 653a 2060 6022 6e63  alues are: ``"nc
-00005630: 6f6c 2260 6020 284e 434f 4c0a 2020 2020  ol"`` (NCOL.    
-00005640: 2020 2020 2020 666f 726d 6174 292c 2060        format), `
-00005650: 6022 6c67 6c22 6060 2028 4c47 4c20 666f  `"lgl"`` (LGL fo
-00005660: 726d 6174 292c 2060 6022 6772 6170 686d  rmat), ``"graphm
-00005670: 6c22 6060 2c20 6060 2267 7261 7068 6d6c  l"``, ``"graphml
-00005680: 7a22 6060 0a20 2020 2020 2020 2020 2028  z"``.          (
-00005690: 4772 6170 684d 4c20 616e 6420 677a 6970  GraphML and gzip
-000056a0: 7065 6420 4772 6170 684d 4c20 666f 726d  ped GraphML form
-000056b0: 6174 292c 2060 6022 676d 6c22 6060 2028  at), ``"gml"`` (
-000056c0: 474d 4c20 666f 726d 6174 292c 0a20 2020  GML format),.   
-000056d0: 2020 2020 2020 2060 6022 6e65 7422 6060         ``"net"``
-000056e0: 2c20 6060 2270 616a 656b 2260 6020 2850  , ``"pajek"`` (P
-000056f0: 616a 656b 2066 6f72 6d61 7429 2c20 6060  ajek format), ``
-00005700: 2264 696d 6163 7322 6060 2028 4449 4d41  "dimacs"`` (DIMA
-00005710: 4353 2066 6f72 6d61 7429 2c0a 2020 2020  CS format),.    
-00005720: 2020 2020 2020 6060 2265 6467 656c 6973        ``"edgelis
-00005730: 7422 6060 2c20 6060 2265 6467 6573 2260  t"``, ``"edges"`
-00005740: 6020 6f72 2060 6022 6564 6765 2260 6020  ` or ``"edge"`` 
-00005750: 2865 6467 6520 6c69 7374 292c 0a20 2020  (edge list),.   
-00005760: 2020 2020 2020 2060 6022 6164 6a61 6365         ``"adjace
-00005770: 6e63 7922 6060 2028 6164 6a61 6365 6e63  ncy"`` (adjacenc
-00005780: 7920 6d61 7472 6978 292c 2060 6022 7069  y matrix), ``"pi
-00005790: 636b 6c65 2260 6020 2850 7974 686f 6e20  ckle"`` (Python 
-000057a0: 7069 636b 6c65 640a 2020 2020 2020 2020  pickled.        
-000057b0: 2020 666f 726d 6174 292e 0a20 2020 2020    format)..     
-000057c0: 2020 203a 7479 7065 2073 696c 656e 6365     :type silence
-000057d0: 5f6c 6576 656c 3a20 696e 7420 3e3d 2030  _level: int >= 0
-000057e0: 0a20 2020 2020 2020 203a 6172 6720 2073  .        :arg  s
-000057f0: 696c 656e 6365 5f6c 6576 656c 3a20 5468  ilence_level: Th
-00005800: 6520 6869 6768 6572 2c20 7468 6520 6c65  e higher, the le
-00005810: 7373 2070 726f 6772 6573 7320 696e 666f  ss progress info
-00005820: 2069 7320 6f75 7470 7574 2e0a 2020 2020   is output..    
-00005830: 2020 2020 3a72 7479 7065 3a20 4e65 7477      :rtype: Netw
-00005840: 6f72 6b20 6f62 6a65 6374 0a20 2020 2020  ork object.     
-00005850: 2020 203a 7265 7475 726e 3a20 3a63 6c61     :return: :cla
-00005860: 7373 3a60 4e65 7477 6f72 6b60 2069 6e73  ss:`Network` ins
-00005870: 7461 6e63 652e 0a20 2020 2020 2020 2022  tance..        "
-00005880: 2222 0a20 2020 2020 2020 2023 2020 4c6f  "".        #  Lo
-00005890: 6164 2074 6f20 6967 7261 7068 2047 7261  ad to igraph Gra
-000058a0: 7068 206f 626a 6563 740a 2020 2020 2020  ph object.      
-000058b0: 2020 6772 6170 6820 3d20 6967 7261 7068    graph = igraph
-000058c0: 2e47 7261 7068 2e52 6561 6428 663d 6669  .Graph.Read(f=fi
-000058d0: 6c65 6e61 6d65 2c20 666f 726d 6174 3d66  lename, format=f
-000058e0: 696c 6566 6f72 6d61 742c 202a 6172 6773  ileformat, *args
-000058f0: 2c20 2a2a 6b77 6473 290a 2020 2020 2020  , **kwds).      
-00005900: 2020 7265 7475 726e 204e 6574 776f 726b    return Network
-00005910: 2e46 726f 6d49 4772 6170 6828 6772 6170  .FromIGraph(grap
-00005920: 683d 6772 6170 682c 2073 696c 656e 6365  h=graph, silence
-00005930: 5f6c 6576 656c 3d73 696c 656e 6365 5f6c  _level=silence_l
-00005940: 6576 656c 290a 0a20 2020 2023 0a20 2020  evel)..    #.   
-00005950: 2023 2020 4772 6170 6820 6765 6e65 7261   #  Graph genera
-00005960: 7469 6f6e 206d 6574 686f 6473 0a20 2020  tion methods.   
-00005970: 2023 0a0a 2020 2020 4073 7461 7469 636d   #..    @staticm
-00005980: 6574 686f 640a 2020 2020 6465 6620 4672  ethod.    def Fr
-00005990: 6f6d 4947 7261 7068 2867 7261 7068 2c20  omIGraph(graph, 
-000059a0: 7369 6c65 6e63 655f 6c65 7665 6c3d 3029  silence_level=0)
-000059b0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-000059c0: 2020 2020 2020 5265 7475 726e 2061 203a        Return a :
-000059d0: 636c 6173 733a 604e 6574 776f 726b 6020  class:`Network` 
-000059e0: 6f62 6a65 6374 2067 6976 656e 2061 6e20  object given an 
-000059f0: 6967 7261 7068 2047 7261 7068 206f 626a  igraph Graph obj
-00005a00: 6563 742e 0a0a 2020 2020 2020 2020 3a74  ect...        :t
-00005a10: 7970 6520 6772 6170 683a 2069 6772 6170  ype graph: igrap
-00005a20: 6820 4772 6170 6820 6f62 6a65 6374 0a20  h Graph object. 
-00005a30: 2020 2020 2020 203a 6172 6720 6772 6170         :arg grap
-00005a40: 683a 2054 6865 2069 6772 6170 6820 4772  h: The igraph Gr
-00005a50: 6170 6820 6f62 6a65 6374 2074 6f20 6265  aph object to be
-00005a60: 2063 6f6e 7665 7274 6564 2e0a 0a20 2020   converted...   
-00005a70: 2020 2020 203a 7479 7065 2073 696c 656e       :type silen
-00005a80: 6365 5f6c 6576 656c 3a20 696e 7420 3e3d  ce_level: int >=
-00005a90: 2030 0a20 2020 2020 2020 203a 6172 6720   0.        :arg 
-00005aa0: 2073 696c 656e 6365 5f6c 6576 656c 3a20   silence_level: 
-00005ab0: 5468 6520 6869 6768 6572 2c20 7468 6520  The higher, the 
-00005ac0: 6c65 7373 2070 726f 6772 6573 7320 696e  less progress in
-00005ad0: 666f 2069 7320 6f75 7470 7574 2e0a 0a20  fo is output... 
-00005ae0: 2020 2020 2020 203a 7274 7970 653a 203a         :rtype: :
-00005af0: 636c 6173 733a 604e 6574 776f 726b 6020  class:`Network` 
-00005b00: 696e 7374 616e 6365 0a20 2020 2020 2020  instance.       
-00005b10: 203a 7265 7475 726e 3a20 3a63 6c61 7373   :return: :class
-00005b20: 3a60 4e65 7477 6f72 6b60 206f 626a 6563  :`Network` objec
-00005b30: 742e 0a20 2020 2020 2020 2022 2222 0a20  t..        """. 
-00005b40: 2020 2020 2020 2023 2020 4765 7420 6e75         #  Get nu
-00005b50: 6d62 6572 206f 6620 6e6f 6465 730a 2020  mber of nodes.  
-00005b60: 2020 2020 2020 4e20 3d20 6c65 6e28 6772        N = len(gr
-00005b70: 6170 682e 7673 290a 0a20 2020 2020 2020  aph.vs)..       
-00005b80: 2023 2020 4765 7420 6469 7265 6374 6564   #  Get directed
-00005b90: 6e65 7373 0a20 2020 2020 2020 2064 6972  ness.        dir
-00005ba0: 6563 7465 6420 3d20 6772 6170 682e 6973  ected = graph.is
-00005bb0: 5f64 6972 6563 7465 6428 290a 0a20 2020  _directed()..   
-00005bc0: 2020 2020 2023 2020 4578 7472 6163 7420       #  Extract 
-00005bd0: 6564 6765 206c 6973 740a 2020 2020 2020  edge list.      
-00005be0: 2020 6564 6765 7320 3d20 6e70 2e61 7272    edges = np.arr
-00005bf0: 6179 2867 7261 7068 2e67 6574 5f65 6467  ay(graph.get_edg
-00005c00: 656c 6973 7428 2929 0a0a 2020 2020 2020  elist())..      
-00005c10: 2020 2320 2053 796d 6d65 7472 697a 6520    #  Symmetrize 
-00005c20: 6966 2075 6e64 6972 6563 7465 6420 6e65  if undirected ne
-00005c30: 7477 6f72 6b0a 2020 2020 2020 2020 6966  twork.        if
-00005c40: 206e 6f74 2064 6972 6563 7465 643a 0a20   not directed:. 
-00005c50: 2020 2020 2020 2020 2020 2065 6467 6573             edges
-00005c60: 203d 206e 702e 6170 7065 6e64 2865 6467   = np.append(edg
-00005c70: 6573 2c20 6564 6765 735b 3a2c 205b 312c  es, edges[:, [1,
-00005c80: 2030 5d5d 2c20 6178 6973 3d30 290a 0a20   0]], axis=0).. 
-00005c90: 2020 2020 2020 2023 2020 4372 6561 7465         #  Create
-00005ca0: 2073 7061 7273 6520 6164 6a61 6365 6e63   sparse adjacenc
-00005cb0: 7920 6d61 7472 6978 2066 726f 6d20 6564  y matrix from ed
-00005cc0: 6765 206c 6973 740a 2020 2020 2020 2020  ge list.        
-00005cd0: 7370 5f41 203d 2073 702e 636f 6f5f 6d61  sp_A = sp.coo_ma
-00005ce0: 7472 6978 280a 2020 2020 2020 2020 2020  trix(.          
-00005cf0: 2020 286e 702e 6f6e 6573 5f6c 696b 6528    (np.ones_like(
-00005d00: 6564 6765 732e 545b 305d 292c 2074 7570  edges.T[0]), tup
-00005d10: 6c65 2865 6467 6573 2e54 2929 2c20 7368  le(edges.T)), sh
-00005d20: 6170 653d 284e 2c20 4e29 290a 0a20 2020  ape=(N, N))..   
-00005d30: 2020 2020 2023 2020 4578 7472 6163 7420       #  Extract 
-00005d40: 6e6f 6465 2077 6569 6768 7473 0a20 2020  node weights.   
-00005d50: 2020 2020 2069 6620 226e 6f64 655f 7765       if "node_we
-00005d60: 6967 6874 5f6e 7369 2220 696e 2067 7261  ight_nsi" in gra
-00005d70: 7068 2e76 732e 6174 7472 6962 7574 655f  ph.vs.attribute_
-00005d80: 6e61 6d65 7328 293a 0a20 2020 2020 2020  names():.       
-00005d90: 2020 2020 206e 6f64 655f 7765 6967 6874       node_weight
-00005da0: 7320 3d20 6e70 2e61 7272 6179 280a 2020  s = np.array(.  
-00005db0: 2020 2020 2020 2020 2020 2020 2020 6772                gr
-00005dc0: 6170 682e 7673 2e67 6574 5f61 7474 7269  aph.vs.get_attri
-00005dd0: 6275 7465 5f76 616c 7565 7328 226e 6f64  bute_values("nod
-00005de0: 655f 7765 6967 6874 5f6e 7369 2229 290a  e_weight_nsi")).
-00005df0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00005e00: 2020 2020 2020 2020 2020 6e6f 6465 5f77            node_w
-00005e10: 6569 6768 7473 203d 204e 6f6e 650a 0a20  eights = None.. 
-00005e20: 2020 2020 2020 206e 6574 203d 204e 6574         net = Net
-00005e30: 776f 726b 2861 646a 6163 656e 6379 3d73  work(adjacency=s
-00005e40: 705f 412c 2064 6972 6563 7465 643d 6469  p_A, directed=di
-00005e50: 7265 6374 6564 2c0a 2020 2020 2020 2020  rected,.        
-00005e60: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
-00005e70: 6465 5f77 6569 6768 7473 3d6e 6f64 655f  de_weights=node_
-00005e80: 7765 6967 6874 732c 2073 696c 656e 6365  weights, silence
-00005e90: 5f6c 6576 656c 3d73 696c 656e 6365 5f6c  _level=silence_l
-00005ea0: 6576 656c 290a 0a20 2020 2020 2020 2023  evel)..        #
-00005eb0: 2020 4f76 6572 7772 6974 6520 6967 7261    Overwrite igra
-00005ec0: 7068 2047 7261 7068 206f 626a 6563 7420  ph Graph object 
-00005ed0: 696e 204e 6574 776f 726b 2069 6e73 7461  in Network insta
-00005ee0: 6e63 6520 746f 2072 6573 746f 7265 206c  nce to restore l
-00005ef0: 696e 6b0a 2020 2020 2020 2020 2320 2061  ink.        #  a
-00005f00: 7474 7269 6275 7465 732f 7765 6967 6874  ttributes/weight
-00005f10: 730a 2020 2020 2020 2020 6e65 742e 6772  s.        net.gr
-00005f20: 6170 6820 3d20 6772 6170 680a 2020 2020  aph = graph.    
-00005f30: 2020 2020 6e65 742e 636c 6561 725f 7061      net.clear_pa
-00005f40: 7468 735f 6361 6368 6528 290a 0a20 2020  ths_cache()..   
-00005f50: 2020 2020 2072 6574 7572 6e20 6e65 740a       return net.
-00005f60: 0a20 2020 2040 7374 6174 6963 6d65 7468  .    @staticmeth
-00005f70: 6f64 0a20 2020 2064 6566 2053 6d61 6c6c  od.    def Small
-00005f80: 5465 7374 4e65 7477 6f72 6b28 293a 0a20  TestNetwork():. 
-00005f90: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00005fa0: 2020 2052 6574 7572 6e20 6120 362d 6e6f     Return a 6-no
-00005fb0: 6465 2075 6e64 6972 6563 7465 6420 7465  de undirected te
-00005fc0: 7374 206e 6574 776f 726b 2077 6974 6820  st network with 
-00005fd0: 6e6f 6465 2077 6569 6768 7473 2e0a 0a20  node weights... 
-00005fe0: 2020 2020 2020 2054 6865 206e 6574 776f         The netwo
-00005ff0: 726b 206c 6f6f 6b73 206c 696b 6520 7468  rk looks like th
-00006000: 6973 3a3a 0a0a 2020 2020 2020 2020 2020  is::..          
-00006010: 2020 2020 2020 3320 2d20 310a 2020 2020        3 - 1.    
-00006020: 2020 2020 2020 2020 2020 2020 7c20 2020              |   
-00006030: 7c20 5c5c 0a20 2020 2020 2020 2020 2020  | \\.           
-00006040: 2035 202d 2030 202d 2034 202d 2032 0a0a   5 - 0 - 4 - 2..
-00006050: 2020 2020 2020 2020 5468 6520 6e6f 6465          The node
-00006060: 2077 6569 6768 7473 2061 7265 205b 312e   weights are [1.
-00006070: 352c 2031 2e37 2c20 312e 392c 2032 2e31  5, 1.7, 1.9, 2.1
-00006080: 2c20 322e 332c 2032 2e35 5d2c 0a20 2020  , 2.3, 2.5],.   
-00006090: 2020 2020 2061 2074 7970 6963 616c 206e       a typical n
-000060a0: 6f64 6520 7765 6967 6874 2066 6f72 2063  ode weight for c
-000060b0: 6f72 7265 6374 6564 206e 2e73 2e69 2e20  orrected n.s.i. 
-000060c0: 6d65 6173 7572 6573 2077 6f75 6c64 2062  measures would b
-000060d0: 6520 322e 302e 0a0a 2020 2020 2020 2020  e 2.0...        
-000060e0: 3a72 7479 7065 3a20 4e65 7477 6f72 6b20  :rtype: Network 
-000060f0: 696e 7374 616e 6365 0a20 2020 2020 2020  instance.       
-00006100: 2022 2222 0a20 2020 2020 2020 206e 7720   """.        nw 
-00006110: 3d20 4e65 7477 6f72 6b28 6164 6a61 6365  = Network(adjace
-00006120: 6e63 793d 5b5b 302c 2030 2c20 302c 2031  ncy=[[0, 0, 0, 1
-00006130: 2c20 312c 2031 5d2c 205b 302c 2030 2c20  , 1, 1], [0, 0, 
-00006140: 312c 2031 2c20 312c 2030 5d2c 0a20 2020  1, 1, 1, 0],.   
-00006150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006160: 2020 2020 2020 2020 2020 2020 205b 302c               [0,
-00006170: 2031 2c20 302c 2030 2c20 312c 2030 5d2c   1, 0, 0, 1, 0],
-00006180: 205b 312c 2031 2c20 302c 2030 2c20 302c   [1, 1, 0, 0, 0,
-00006190: 2030 5d2c 0a20 2020 2020 2020 2020 2020   0],.           
-000061a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000061b0: 2020 2020 205b 312c 2031 2c20 312c 2030       [1, 1, 1, 0
-000061c0: 2c20 302c 2030 5d2c 205b 312c 2030 2c20  , 0, 0], [1, 0, 
-000061d0: 302c 2030 2c20 302c 2030 5d5d 2c0a 2020  0, 0, 0, 0]],.  
-000061e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000061f0: 2020 2064 6972 6563 7465 643d 4661 6c73     directed=Fals
-00006200: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00006210: 2020 2020 2020 2020 6e6f 6465 5f77 6569          node_wei
-00006220: 6768 7473 3d5b 312e 352c 2031 2e37 2c20  ghts=[1.5, 1.7, 
-00006230: 312e 392c 2032 2e31 2c20 322e 332c 2032  1.9, 2.1, 2.3, 2
-00006240: 2e35 5d2c 0a20 2020 2020 2020 2020 2020  .5],.           
-00006250: 2020 2020 2020 2020 2020 7369 6c65 6e63            silenc
-00006260: 655f 6c65 7665 6c3d 3129 0a20 2020 2020  e_level=1).     
-00006270: 2020 206c 696e 6b5f 7765 6967 6874 7320     link_weights 
-00006280: 3d20 6e70 2e61 7272 6179 285b 5b30 2c20  = np.array([[0, 
-00006290: 302c 2030 2c20 312e 332c 2032 2e35 2c20  0, 0, 1.3, 2.5, 
-000062a0: 312e 315d 2c0a 2020 2020 2020 2020 2020  1.1],.          
-000062b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000062c0: 2020 2020 2020 205b 302c 2030 2c20 322e         [0, 0, 2.
-000062d0: 332c 2032 2e39 2c20 322e 372c 2030 5d2c  3, 2.9, 2.7, 0],
-000062e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000062f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006300: 2020 5b30 2c20 322e 332c 2030 2c20 302c    [0, 2.3, 0, 0,
-00006310: 2031 2e35 2c20 305d 2c0a 2020 2020 2020   1.5, 0],.      
-00006320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006330: 2020 2020 2020 2020 2020 205b 312e 332c             [1.3,
-00006340: 2032 2e39 2c20 302c 2030 2c20 302c 2030   2.9, 0, 0, 0, 0
-00006350: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-00006360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006370: 2020 2020 5b32 2e35 2c20 322e 372c 2031      [2.5, 2.7, 1
-00006380: 2e35 2c20 302c 2030 2c20 305d 2c0a 2020  .5, 0, 0, 0],.  
+00000000: 2320 5468 6973 2066 696c 6520 6973 2070  # This file is p
+00000010: 6172 7420 6f66 2070 7975 6e69 636f 726e  art of pyunicorn
+00000020: 2e0a 2320 436f 7079 7269 6768 7420 2843  ..# Copyright (C
+00000030: 2920 3230 3038 2d2d 3230 3234 204a 6f6e  ) 2008--2024 Jon
+00000040: 6174 6861 6e20 462e 2044 6f6e 6765 7320  athan F. Donges 
+00000050: 616e 6420 7079 756e 6963 6f72 6e20 6175  and pyunicorn au
+00000060: 7468 6f72 730a 2320 5552 4c3a 203c 6874  thors.# URL: <ht
+00000070: 7470 733a 2f2f 7777 772e 7069 6b2d 706f  tps://www.pik-po
+00000080: 7473 6461 6d2e 6465 2f6d 656d 6265 7273  tsdam.de/members
+00000090: 2f64 6f6e 6765 732f 736f 6674 7761 7265  /donges/software
+000000a0: 2d32 2f73 6f66 7477 6172 653e 0a23 204c  -2/software>.# L
+000000b0: 6963 656e 7365 3a20 4253 4420 2833 2d63  icense: BSD (3-c
+000000c0: 6c61 7573 6529 0a23 0a23 2050 6c65 6173  lause).#.# Pleas
+000000d0: 6520 6163 6b6e 6f77 6c65 6467 6520 616e  e acknowledge an
+000000e0: 6420 6369 7465 2074 6865 2075 7365 206f  d cite the use o
+000000f0: 6620 7468 6973 2073 6f66 7477 6172 6520  f this software 
+00000100: 616e 6420 6974 7320 6175 7468 6f72 730a  and its authors.
+00000110: 2320 7768 656e 2072 6573 756c 7473 2061  # when results a
+00000120: 7265 2075 7365 6420 696e 2070 7562 6c69  re used in publi
+00000130: 6361 7469 6f6e 7320 6f72 2070 7562 6c69  cations or publi
+00000140: 7368 6564 2065 6c73 6577 6865 7265 2e0a  shed elsewhere..
+00000150: 230a 2320 596f 7520 6361 6e20 7573 6520  #.# You can use 
+00000160: 7468 6520 666f 6c6c 6f77 696e 6720 7265  the following re
+00000170: 6665 7265 6e63 653a 0a23 204a 2e46 2e20  ference:.# J.F. 
+00000180: 446f 6e67 6573 2c20 4a2e 2048 6569 747a  Donges, J. Heitz
+00000190: 6967 2c20 422e 2042 6572 6f6e 6f76 2c20  ig, B. Beronov, 
+000001a0: 4d2e 2057 6965 6465 726d 616e 6e2c 204a  M. Wiedermann, J
+000001b0: 2e20 5275 6e67 652c 2051 2e2d 592e 2046  . Runge, Q.-Y. F
+000001c0: 656e 672c 0a23 204c 2e20 5475 7069 6b69  eng,.# L. Tupiki
+000001d0: 6e61 2c20 562e 2053 746f 6c62 6f76 612c  na, V. Stolbova,
+000001e0: 2052 2e56 2e20 446f 6e6e 6572 2c20 4e2e   R.V. Donner, N.
+000001f0: 204d 6172 7761 6e2c 2048 2e41 2e20 4469   Marwan, H.A. Di
+00000200: 6a6b 7374 7261 2c0a 2320 616e 6420 4a2e  jkstra,.# and J.
+00000210: 204b 7572 7468 732c 2022 556e 6966 6965   Kurths, "Unifie
+00000220: 6420 6675 6e63 7469 6f6e 616c 206e 6574  d functional net
+00000230: 776f 726b 2061 6e64 206e 6f6e 6c69 6e65  work and nonline
+00000240: 6172 2074 696d 6520 7365 7269 6573 2061  ar time series a
+00000250: 6e61 6c79 7369 730a 2320 666f 7220 636f  nalysis.# for co
+00000260: 6d70 6c65 7820 7379 7374 656d 7320 7363  mplex systems sc
+00000270: 6965 6e63 653a 2054 6865 2070 7975 6e69  ience: The pyuni
+00000280: 636f 726e 2070 6163 6b61 6765 220a 0a22  corn package".."
+00000290: 2222 0a50 726f 7669 6465 7320 636c 6173  "".Provides clas
+000002a0: 7365 7320 666f 7220 616e 616c 797a 696e  ses for analyzin
+000002b0: 6720 7370 6174 6961 6c6c 7920 656d 6265  g spatially embe
+000002c0: 6464 6564 2063 6f6d 706c 6578 206e 6574  dded complex net
+000002d0: 776f 726b 732c 2068 616e 646c 696e 670a  works, handling.
+000002e0: 6d75 6c74 6976 6172 6961 7465 2064 6174  multivariate dat
+000002f0: 6120 616e 6420 6765 6e65 7261 7469 6e67  a and generating
+00000300: 2074 696d 6520 7365 7269 6573 2073 7572   time series sur
+00000310: 726f 6761 7465 732e 0a22 2222 0a0a 696d  rogates.."""..im
+00000320: 706f 7274 2073 7973 2020 2020 2020 2020  port sys        
+00000330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000340: 2020 2320 7065 7266 6f72 6d61 6e63 6520    # performance 
+00000350: 7465 7374 696e 670a 696d 706f 7274 2074  testing.import t
+00000360: 696d 650a 6672 6f6d 2066 756e 6374 6f6f  ime.from functoo
+00000370: 6c73 2069 6d70 6f72 7420 7061 7274 6961  ls import partia
+00000380: 6c0a 6672 6f6d 2074 7970 696e 6720 696d  l.from typing im
+00000390: 706f 7274 2054 7570 6c65 2c20 4f70 7469  port Tuple, Opti
+000003a0: 6f6e 616c 0a66 726f 6d20 636f 6c6c 6563  onal.from collec
+000003b0: 7469 6f6e 732e 6162 6320 696d 706f 7274  tions.abc import
+000003c0: 2048 6173 6861 626c 650a 6672 6f6d 206d   Hashable.from m
+000003d0: 756c 7469 7072 6f63 6573 7369 6e67 2069  ultiprocessing i
+000003e0: 6d70 6f72 7420 6765 745f 636f 6e74 6578  mport get_contex
+000003f0: 742c 2063 7075 5f63 6f75 6e74 0a0a 696d  t, cpu_count..im
+00000400: 706f 7274 206e 756d 7079 2061 7320 6e70  port numpy as np
+00000410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000420: 2020 2320 6172 7261 7920 6f62 6a65 6374    # array object
+00000430: 2061 6e64 2066 6173 7420 6e75 6d65 7269   and fast numeri
+00000440: 6373 0a66 726f 6d20 6e75 6d70 7920 696d  cs.from numpy im
+00000450: 706f 7274 2072 616e 646f 6d0a 6672 6f6d  port random.from
+00000460: 2073 6369 7079 2069 6d70 6f72 7420 6c69   scipy import li
+00000470: 6e61 6c67 2020 2020 2020 2020 2020 2020  nalg            
+00000480: 2320 736f 6c76 6572 730a 6672 6f6d 2073  # solvers.from s
+00000490: 6369 7079 2e6c 696e 616c 6720 696d 706f  cipy.linalg impo
+000004a0: 7274 2065 7870 6d0a 6672 6f6d 2073 6369  rt expm.from sci
+000004b0: 7079 2069 6d70 6f72 7420 7370 6172 7365  py import sparse
+000004c0: 2061 7320 7370 2020 2020 2020 2320 6661   as sp      # fa
+000004d0: 7374 2073 7061 7273 6520 6d61 7472 6963  st sparse matric
+000004e0: 6573 0a66 726f 6d20 7363 6970 792e 7370  es.from scipy.sp
+000004f0: 6172 7365 2e6c 696e 616c 6720 696d 706f  arse.linalg impo
+00000500: 7274 2065 6967 7368 2c20 696e 762c 2073  rt eigsh, inv, s
+00000510: 706c 750a 6672 6f6d 2074 7164 6d20 696d  plu.from tqdm im
+00000520: 706f 7274 2074 7164 6d2c 2074 7261 6e67  port tqdm, trang
+00000530: 6520 2020 2020 2020 2320 6561 7379 2070  e       # easy p
+00000540: 726f 6772 6573 7320 6261 7220 6861 6e64  rogress bar hand
+00000550: 6c69 6e67 0a0a 696d 706f 7274 2069 6772  ling..import igr
+00000560: 6170 6820 2020 2020 2020 2020 2020 2020  aph             
+00000570: 2020 2020 2020 2020 2020 2320 6869 6768            # high
+00000580: 2070 6572 666f 726d 616e 6365 2067 7261   performance gra
+00000590: 7068 2074 6865 6f72 7920 746f 6f6c 730a  ph theory tools.
+000005a0: 0a66 726f 6d20 2e63 6163 6865 2069 6d70  .from .cache imp
+000005b0: 6f72 7420 4361 6368 6564 0a66 726f 6d20  ort Cached.from 
+000005c0: 2e2e 7574 696c 7320 696d 706f 7274 206d  ..utils import m
+000005d0: 7069 2020 2020 2020 2020 2020 2020 2023  pi             #
+000005e0: 2070 6172 616c 6c65 6c69 7a65 6420 636f   parallelized co
+000005f0: 6d70 7574 6174 696f 6e73 0a0a 6672 6f6d  mputations..from
+00000600: 202e 5f65 7874 2e74 7970 6573 2069 6d70   ._ext.types imp
+00000610: 6f72 7420 5c0a 2020 2020 746f 5f63 792c  ort \.    to_cy,
+00000620: 2041 444a 2c20 4d41 534b 2c20 4e4f 4445   ADJ, MASK, NODE
+00000630: 2c20 4445 4752 4545 2c20 4457 4549 4748  , DEGREE, DWEIGH
+00000640: 542c 2046 4945 4c44 2c20 4446 4945 4c44  T, FIELD, DFIELD
+00000650: 0a66 726f 6d20 2e5f 6578 742e 6e75 6d65  .from ._ext.nume
+00000660: 7269 6373 2069 6d70 6f72 7420 5c0a 2020  rics import \.  
+00000670: 2020 5f6c 6f63 616c 5f63 6c69 7175 6973    _local_cliquis
+00000680: 686e 6573 735f 3474 686f 7264 6572 2c20  hness_4thorder, 
+00000690: 5f6c 6f63 616c 5f63 6c69 7175 6973 686e  _local_cliquishn
+000006a0: 6573 735f 3574 686f 7264 6572 2c20 5c0a  ess_5thorder, \.
+000006b0: 2020 2020 5f6e 7369 5f62 6574 7765 656e      _nsi_between
+000006c0: 6e65 7373 2c20 5f6d 7069 5f6e 6577 6d61  ness, _mpi_newma
+000006d0: 6e5f 6265 7477 6565 6e6e 6573 732c 205f  n_betweenness, _
+000006e0: 6d70 695f 6e73 695f 6e65 776d 616e 5f62  mpi_nsi_newman_b
+000006f0: 6574 7765 656e 6e65 7373 2c20 5c0a 2020  etweenness, \.  
+00000700: 2020 5f64 6f5f 6e73 695f 636c 7573 7465    _do_nsi_cluste
+00000710: 7269 6e67 5f49 2c20 5f64 6f5f 6e73 695f  ring_I, _do_nsi_
+00000720: 636c 7573 7465 7269 6e67 5f49 492c 205f  clustering_II, _
+00000730: 646f 5f6e 7369 5f68 616d 6d69 6e67 5f63  do_nsi_hamming_c
+00000740: 6c75 7374 6572 696e 670a 0a0a 2320 3d3d  lustering...# ==
+00000750: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000760: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000770: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000780: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000790: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2320 2055  ===========.#  U
+000007a0: 7469 6c69 7469 6573 0a0a 0a64 6566 206e  tilities...def n
+000007b0: 7a5f 636f 6f72 6473 286d 6174 7269 7829  z_coords(matrix)
+000007c0: 3a0a 2020 2020 2222 220a 2020 2020 4669  :.    """.    Fi
+000007d0: 6e64 2063 6f6f 7264 696e 6174 6573 206f  nd coordinates o
+000007e0: 6620 616c 6c20 6e6f 6e2d 7a65 726f 2065  f all non-zero e
+000007f0: 6e74 7269 6573 2069 6e20 6120 7370 6172  ntries in a spar
+00000800: 7365 206d 6174 7269 782e 0a0a 2020 2020  se matrix...    
+00000810: 3a72 6574 7572 6e3a 206c 6973 7420 6f66  :return: list of
+00000820: 2063 6f6f 7264 696e 6174 6573 205b 726f   coordinates [ro
+00000830: 772c 636f 6c5d 0a20 2020 203a 7274 7970  w,col].    :rtyp
+00000840: 653a 2020 6172 7261 7928 5b5b 696e 743e  e:  array([[int>
+00000850: 3d30 2c69 6e74 3e3d 305d 5d29 0a20 2020  =0,int>=0]]).   
+00000860: 2022 2222 0a20 2020 2072 6574 7572 6e20   """.    return 
+00000870: 6e70 2e61 7272 6179 286d 6174 7269 782e  np.array(matrix.
+00000880: 6e6f 6e7a 6572 6f28 2929 2e54 0a0a 0a63  nonzero()).T...c
+00000890: 6c61 7373 204e 6574 776f 726b 4572 726f  lass NetworkErro
+000008a0: 7228 4578 6365 7074 696f 6e29 3a0a 2020  r(Exception):.  
+000008b0: 2020 2222 220a 2020 2020 5573 6564 2066    """.    Used f
+000008c0: 6f72 2061 6c6c 2065 7863 6570 7469 6f6e  or all exception
+000008d0: 7320 7261 6973 6564 2062 7920 4e65 7477  s raised by Netw
+000008e0: 6f72 6b2e 0a20 2020 2022 2222 0a20 2020  ork..    """.   
+000008f0: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
+00000900: 6c66 2c20 7661 6c75 6529 3a0a 2020 2020  lf, value):.    
+00000910: 2020 2020 4578 6365 7074 696f 6e2e 5f5f      Exception.__
+00000920: 696e 6974 5f5f 2873 656c 6629 0a20 2020  init__(self).   
+00000930: 2020 2020 2073 656c 662e 7661 6c75 6520       self.value 
+00000940: 3d20 7661 6c75 650a 0a20 2020 2064 6566  = value..    def
+00000950: 205f 5f73 7472 5f5f 2873 656c 6629 3a0a   __str__(self):.
+00000960: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+00000970: 6570 7228 7365 6c66 2e76 616c 7565 290a  epr(self.value).
+00000980: 0a0a 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ..# ============
+00000990: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000009a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000009b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000009c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000009d0: 3d0a 2320 2044 6f63 7465 7374 2068 656c  =.#  Doctest hel
+000009e0: 7065 7273 0a0a 0a64 6566 2072 286f 626a  pers...def r(obj
+000009f0: 2c20 6465 6369 6d61 6c73 3d34 293a 0a20  , decimals=4):. 
+00000a00: 2020 2022 2222 0a20 2020 2052 6f75 6e64     """.    Round
+00000a10: 206e 756d 6265 7273 2c20 6172 7261 7973   numbers, arrays
+00000a20: 206f 7220 6974 6572 6162 6c65 7320 7468   or iterables th
+00000a30: 6572 656f 662e 204f 6e6c 7920 7573 6564  ereof. Only used
+00000a40: 2069 6e20 646f 6373 7472 696e 6773 2e0a   in docstrings..
+00000a50: 2020 2020 2222 220a 2020 2020 6966 2069      """.    if i
+00000a60: 7369 6e73 7461 6e63 6528 6f62 6a2c 2028  sinstance(obj, (
+00000a70: 6e70 2e6e 6461 7272 6179 2c20 6e70 2e6d  np.ndarray, np.m
+00000a80: 6174 7269 7829 293a 0a20 2020 2020 2020  atrix)):.       
+00000a90: 2069 6620 6f62 6a2e 6474 7970 652e 6b69   if obj.dtype.ki
+00000aa0: 6e64 203d 3d20 2766 273a 0a20 2020 2020  nd == 'f':.     
+00000ab0: 2020 2020 2020 2072 6f75 6e64 6564 203d         rounded =
+00000ac0: 206e 702e 6172 6f75 6e64 286f 626a 2e61   np.around(obj.a
+00000ad0: 7374 7970 6528 6e70 2e66 6c6f 6174 3132  stype(np.float12
+00000ae0: 3829 2c0a 2020 2020 2020 2020 2020 2020  8),.            
+00000af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000b00: 2020 2020 6465 6369 6d61 6c73 3d64 6563      decimals=dec
+00000b10: 696d 616c 7329 2e61 7374 7970 6528 6e70  imals).astype(np
+00000b20: 2e66 6c6f 6174 3634 290a 2020 2020 2020  .float64).      
+00000b30: 2020 656c 6966 206f 626a 2e64 7479 7065    elif obj.dtype
+00000b40: 2e6b 696e 6420 3d3d 2027 6927 3a0a 2020  .kind == 'i':.  
+00000b50: 2020 2020 2020 2020 2020 726f 756e 6465            rounde
+00000b60: 6420 3d20 6f62 6a2e 6173 7479 7065 286e  d = obj.astype(n
+00000b70: 702e 696e 7429 0a20 2020 2065 6c69 6620  p.int).    elif 
+00000b80: 6973 696e 7374 616e 6365 286f 626a 2c20  isinstance(obj, 
+00000b90: 6c69 7374 293a 0a20 2020 2020 2020 2072  list):.        r
+00000ba0: 6f75 6e64 6564 203d 206d 6170 2872 2c20  ounded = map(r, 
+00000bb0: 6f62 6a29 0a20 2020 2065 6c69 6620 6973  obj).    elif is
+00000bc0: 696e 7374 616e 6365 286f 626a 2c20 7475  instance(obj, tu
+00000bd0: 706c 6529 3a0a 2020 2020 2020 2020 726f  ple):.        ro
+00000be0: 756e 6465 6420 3d20 7475 706c 6528 6d61  unded = tuple(ma
+00000bf0: 7028 722c 206f 626a 2929 0a20 2020 2065  p(r, obj)).    e
+00000c00: 6c69 6620 6973 696e 7374 616e 6365 286f  lif isinstance(o
+00000c10: 626a 2c20 2866 6c6f 6174 2c20 6e70 2e66  bj, (float, np.f
+00000c20: 6c6f 6174 3332 2c20 6e70 2e66 6c6f 6174  loat32, np.float
+00000c30: 3634 2c20 6e70 2e66 6c6f 6174 3132 3829  64, np.float128)
+00000c40: 293a 0a20 2020 2020 2020 2072 6f75 6e64  ):.        round
+00000c50: 6564 203d 206e 702e 666c 6f61 7436 3428  ed = np.float64(
+00000c60: 6e70 2e61 726f 756e 6428 6e70 2e66 6c6f  np.around(np.flo
+00000c70: 6174 3132 3828 6f62 6a29 2c20 6465 6369  at128(obj), deci
+00000c80: 6d61 6c73 3d64 6563 696d 616c 7329 290a  mals=decimals)).
+00000c90: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
+00000ca0: 6e63 6528 6f62 6a2c 2028 696e 742c 206e  nce(obj, (int, n
+00000cb0: 702e 696e 7438 2c20 6e70 2e69 6e74 3136  p.int8, np.int16
+00000cc0: 2c20 6e70 2e69 6e74 3332 2929 3a0a 2020  , np.int32)):.  
+00000cd0: 2020 2020 2020 726f 756e 6465 6420 3d20        rounded = 
+00000ce0: 696e 7428 6f62 6a29 0a20 2020 2065 6c73  int(obj).    els
+00000cf0: 653a 0a20 2020 2020 2020 2072 6f75 6e64  e:.        round
+00000d00: 6564 203d 206f 626a 0a20 2020 2072 6574  ed = obj.    ret
+00000d10: 7572 6e20 726f 756e 6465 640a 0a0a 6465  urn rounded...de
+00000d20: 6620 7272 286f 626a 2c20 6465 6369 6d61  f rr(obj, decima
+00000d30: 6c73 3d34 293a 0a20 2020 2022 2222 0a20  ls=4):.    """. 
+00000d40: 2020 2052 6f75 6e64 2061 7272 6179 7320     Round arrays 
+00000d50: 696e 2073 6369 656e 7469 6669 6320 6e6f  in scientific no
+00000d60: 7461 7469 6f6e 2e20 4f6e 6c79 2075 7365  tation. Only use
+00000d70: 6420 696e 2064 6f63 7374 7269 6e67 732e  d in docstrings.
+00000d80: 0a20 2020 2022 2222 0a20 2020 2070 7269  .    """.    pri
+00000d90: 6e74 286e 702e 7665 6374 6f72 697a 6528  nt(np.vectorize(
+00000da0: 2725 2e34 6727 2e5f 5f6d 6f64 5f5f 2928  '%.4g'.__mod__)(
+00000db0: 7228 6f62 6a2c 2064 6563 696d 616c 733d  r(obj, decimals=
+00000dc0: 6465 6369 6d61 6c73 2929 290a 0a0a 2320  decimals)))...# 
+00000dd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000de0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000df0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000e00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000e10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 0a0a  =============...
+00000e20: 636c 6173 7320 4e65 7477 6f72 6b28 4361  class Network(Ca
+00000e30: 6368 6564 293a 0a20 2020 2022 2222 0a20  ched):.    """. 
+00000e40: 2020 2041 204e 6574 776f 726b 2069 7320     A Network is 
+00000e50: 6120 7369 6d70 6c65 2c20 756e 6469 7265  a simple, undire
+00000e60: 6374 6564 206f 7220 6469 7265 6374 6564  cted or directed
+00000e70: 2067 7261 7068 2077 6974 6820 6f70 7469   graph with opti
+00000e80: 6f6e 616c 206e 6f64 650a 2020 2020 616e  onal node.    an
+00000e90: 642f 6f72 206c 696e 6b20 7765 6967 6874  d/or link weight
+00000ea0: 732e 2054 6869 7320 636c 6173 7320 656e  s. This class en
+00000eb0: 6361 7073 756c 6174 6573 2064 6174 6120  capsulates data 
+00000ec0: 7374 7275 6374 7572 6573 2061 6e64 206d  structures and m
+00000ed0: 6574 686f 6473 2074 6f0a 2020 2020 7265  ethods to.    re
+00000ee0: 7072 6573 656e 742c 2067 656e 6572 6174  present, generat
+00000ef0: 6520 616e 6420 616e 616c 797a 6520 7375  e and analyze su
+00000f00: 6368 2073 7472 7563 7475 7265 732e 0a0a  ch structures...
+00000f10: 2020 2020 4e65 7477 6f72 6b20 7265 6c69      Network reli
+00000f20: 6573 206f 6e20 7468 6520 7061 636b 6167  es on the packag
+00000f30: 6520 6967 7261 7068 2066 6f72 206d 616e  e igraph for man
+00000f40: 7920 6f66 2069 7473 2066 6561 7475 7265  y of its feature
+00000f50: 732c 2062 7574 2061 6c73 6f0a 2020 2020  s, but also.    
+00000f60: 696d 706c 656d 656e 7473 206e 6577 2066  implements new f
+00000f70: 756e 6374 696f 6e61 6c69 7479 2e20 4869  unctionality. Hi
+00000f80: 6768 6c69 6768 7473 2069 6e63 6c75 6465  ghlights include
+00000f90: 2077 6569 6768 7465 6420 616e 6420 6469   weighted and di
+00000fa0: 7265 6374 6564 0a20 2020 2073 7461 7469  rected.    stati
+00000fb0: 7374 6963 616c 206e 6574 776f 726b 206d  stical network m
+00000fc0: 6561 7375 7265 732c 206d 6561 7375 7265  easures, measure
+00000fd0: 7320 6261 7365 6420 6f6e 2072 616e 646f  s based on rando
+00000fe0: 6d20 7761 6c6b 732c 2061 6e64 0a20 2020  m walks, and.   
+00000ff0: 206e 6f64 6520 7370 6c69 7474 696e 6720   node splitting 
+00001000: 696e 7661 7269 616e 7420 6e65 7477 6f72  invariant networ
+00001010: 6b20 6d65 6173 7572 6573 2e0a 0a20 2020  k measures...   
+00001020: 202a 2a45 7861 6d70 6c65 733a 2a2a 0a0a   **Examples:**..
+00001030: 2020 2020 4372 6561 7465 2061 6e20 756e      Create an un
+00001040: 6469 7265 6374 6564 206e 6574 776f 726b  directed network
+00001050: 2067 6976 656e 2074 6865 2061 646a 6163   given the adjac
+00001060: 656e 6379 206d 6174 7269 783a 0a0a 2020  ency matrix:..  
+00001070: 2020 3e3e 3e20 6e65 7420 3d20 4e65 7477    >>> net = Netw
+00001080: 6f72 6b28 6164 6a61 6365 6e63 793d 5b5b  ork(adjacency=[[
+00001090: 302c 312c 302c 302c 302c 305d 2c20 5b31  0,1,0,0,0,0], [1
+000010a0: 2c30 2c31 2c30 2c30 2c31 5d2c 0a20 2020  ,0,1,0,0,1],.   
+000010b0: 202e 2e2e 2020 2020 2020 2020 2020 2020   ...            
+000010c0: 2020 2020 2020 2020 2020 2020 2020 5b30                [0
+000010d0: 2c31 2c30 2c31 2c31 2c30 5d2c 205b 302c  ,1,0,1,1,0], [0,
+000010e0: 302c 312c 302c 312c 305d 2c0a 2020 2020  0,1,0,1,0],.    
+000010f0: 2e2e 2e20 2020 2020 2020 2020 2020 2020  ...             
+00001100: 2020 2020 2020 2020 2020 2020 205b 302c               [0,
+00001110: 302c 312c 312c 302c 315d 2c20 5b30 2c31  0,1,1,0,1], [0,1
+00001120: 2c30 2c30 2c31 2c30 5d5d 290a 0a20 2020  ,0,0,1,0]])..   
+00001130: 2043 7265 6174 6520 616e 2045 7264 6f73   Create an Erdos
+00001140: 2d52 656e 7969 2072 616e 646f 6d20 6772  -Renyi random gr
+00001150: 6170 683a 0a0a 2020 2020 3e3e 3e20 6e65  aph:..    >>> ne
+00001160: 7420 3d20 4e65 7477 6f72 6b2e 4d6f 6465  t = Network.Mode
+00001170: 6c28 2245 7264 6f73 5265 6e79 6922 2c20  l("ErdosRenyi", 
+00001180: 6e5f 6e6f 6465 733d 3130 302c 206c 696e  n_nodes=100, lin
+00001190: 6b5f 7072 6f62 6162 696c 6974 793d 302e  k_probability=0.
+000011a0: 3035 290a 2020 2020 4765 6e65 7261 7469  05).    Generati
+000011b0: 6e67 2045 7264 6f73 2d52 656e 7969 2072  ng Erdos-Renyi r
+000011c0: 616e 646f 6d20 6772 6170 6820 7769 7468  andom graph with
+000011d0: 2031 3030 206e 6f64 6573 2061 6e64 2070   100 nodes and p
+000011e0: 726f 6261 6269 6c69 7479 2030 2e30 352e  robability 0.05.
+000011f0: 2e2e 0a20 2020 2022 2222 0a0a 2020 2020  ...    """..    
+00001200: 230a 2020 2020 2320 2044 6566 696e 6974  #.    #  Definit
+00001210: 696f 6e73 206f 6620 696e 7465 726e 616c  ions of internal
+00001220: 206d 6574 686f 6473 0a20 2020 2023 0a0a   methods.    #..
+00001230: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
+00001240: 2873 656c 662c 2061 646a 6163 656e 6379  (self, adjacency
+00001250: 3d4e 6f6e 652c 206e 5f6e 6f64 6573 3d4e  =None, n_nodes=N
+00001260: 6f6e 652c 2065 6467 655f 6c69 7374 3d4e  one, edge_list=N
+00001270: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
+00001280: 2020 2020 2020 6469 7265 6374 6564 3d46        directed=F
+00001290: 616c 7365 2c20 6e6f 6465 5f77 6569 6768  alse, node_weigh
+000012a0: 7473 3d4e 6f6e 652c 2073 696c 656e 6365  ts=None, silence
+000012b0: 5f6c 6576 656c 3d30 293a 0a20 2020 2020  _level=0):.     
+000012c0: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
+000012d0: 6574 7572 6e20 6120 6e65 7720 6469 7265  eturn a new dire
+000012e0: 6374 6564 206f 7220 756e 6469 7265 6374  cted or undirect
+000012f0: 6564 204e 6574 776f 726b 206f 626a 6563  ed Network objec
+00001300: 740a 2020 2020 2020 2020 7769 7468 2067  t.        with g
+00001310: 6976 656e 2061 646a 6163 656e 6379 206d  iven adjacency m
+00001320: 6174 7269 7820 616e 6420 6f70 7469 6f6e  atrix and option
+00001330: 616c 206e 6f64 6520 7765 6967 6874 732e  al node weights.
+00001340: 0a0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
+00001350: 6164 6a61 6365 6e63 793a 2073 7175 6172  adjacency: squar
+00001360: 6520 6172 7261 792d 6c69 6b65 205b 6e6f  e array-like [no
+00001370: 6465 2c6e 6f64 655d 2c20 6f72 2070 7973  de,node], or pys
+00001380: 7061 7273 6520 6d61 7472 6978 206f 660a  parse matrix of.
+00001390: 2020 2020 2020 2020 2020 2020 3073 2061              0s a
+000013a0: 6e64 2031 730a 2020 2020 2020 2020 3a61  nd 1s.        :a
+000013b0: 7267 2020 6164 6a61 6365 6e63 793a 2041  rg  adjacency: A
+000013c0: 646a 6163 656e 6379 206d 6174 7269 7820  djacency matrix 
+000013d0: 6f66 2074 6865 206e 6577 206e 6574 776f  of the new netwo
+000013e0: 726b 2e20 2045 6e74 7279 205b 692c 6a5d  rk.  Entry [i,j]
+000013f0: 0a20 2020 2020 2020 2020 2020 2069 6e64  .            ind
+00001400: 6963 6174 6573 2077 6865 7468 6572 206e  icates whether n
+00001410: 6f64 6520 6920 6c69 6e6b 7320 746f 206e  ode i links to n
+00001420: 6f64 6520 6a2e 2020 4974 7320 6469 6167  ode j.  Its diag
+00001430: 6f6e 616c 206d 7573 7420 6265 0a20 2020  onal must be.   
+00001440: 2020 2020 2020 2020 207a 6572 6f2e 2020           zero.  
+00001450: 4d75 7374 2062 6520 7379 6d6d 6574 7269  Must be symmetri
+00001460: 6320 6966 2064 6972 6563 7465 643d 4661  c if directed=Fa
+00001470: 6c73 652e 0a20 2020 2020 2020 203a 7479  lse..        :ty
+00001480: 7065 206e 5f6e 6f64 6573 3a20 696e 740a  pe n_nodes: int.
+00001490: 2020 2020 2020 2020 3a61 7267 2020 6e5f          :arg  n_
+000014a0: 6e6f 6465 733a 204e 756d 6265 7220 6f66  nodes: Number of
+000014b0: 206e 6f64 6573 2c20 6f70 7469 6f6e 616c   nodes, optional
+000014c0: 2061 7267 756d 656e 7420 7768 656e 2075   argument when u
+000014d0: 7369 6e67 2065 6467 655f 6c69 7374 0a20  sing edge_list. 
+000014e0: 2020 2020 2020 203a 7479 7065 2065 6467         :type edg
+000014f0: 655f 6c69 7374 3a20 6172 7261 792d 6c69  e_list: array-li
+00001500: 6b65 206c 6973 7420 6f66 206c 6973 7473  ke list of lists
+00001510: 0a20 2020 2020 2020 203a 6172 6720 2065  .        :arg  e
+00001520: 6467 655f 6c69 7374 3a20 4564 6765 206c  dge_list: Edge l
+00001530: 6973 7420 6f66 2074 6865 206e 6577 206e  ist of the new n
+00001540: 6574 776f 726b 2e20 2045 6e74 7269 6573  etwork.  Entries
+00001550: 205b 692c 305d 2c20 5b69 2c31 5d0a 2020   [i,0], [i,1].  
+00001560: 2020 2020 2020 2020 2020 636f 6e74 6169            contai
+00001570: 6e20 7468 6520 656e 642d 6e6f 6465 7320  n the end-nodes 
+00001580: 6f66 2061 6e20 6564 6765 2e0a 2020 2020  of an edge..    
+00001590: 2020 2020 3a61 7267 2062 6f6f 6c20 6469      :arg bool di
+000015a0: 7265 6374 6564 3a20 496e 6469 6361 7465  rected: Indicate
+000015b0: 7320 7768 6574 6865 7220 7468 6520 6e65  s whether the ne
+000015c0: 7477 6f72 6b20 7368 616c 6c20 6265 2063  twork shall be c
+000015d0: 6f6e 7369 6465 7265 640a 2020 2020 2020  onsidered.      
+000015e0: 2020 2020 2020 6173 2064 6972 6563 7465        as directe
+000015f0: 642e 2049 6620 4661 6c73 652c 2061 646a  d. If False, adj
+00001600: 6163 656e 6379 206d 7573 7420 6265 2073  acency must be s
+00001610: 796d 6d65 7472 6963 2e0a 2020 2020 2020  ymmetric..      
+00001620: 2020 3a74 7970 6520 6e6f 6465 5f77 6569    :type node_wei
+00001630: 6768 7473 3a20 3164 206e 756d 7079 2061  ghts: 1d numpy a
+00001640: 7272 6179 206f 7220 6c69 7374 205b 6e6f  rray or list [no
+00001650: 6465 5d20 6f66 2066 6c6f 6174 7320 3e3d  de] of floats >=
+00001660: 2030 0a20 2020 2020 2020 203a 6172 6720   0.        :arg 
+00001670: 206e 6f64 655f 7765 6967 6874 733a 204f   node_weights: O
+00001680: 7074 696f 6e61 6c20 6172 7261 7920 6f72  ptional array or
+00001690: 206c 6973 7420 6f66 206e 6f64 6520 7765   list of node we
+000016a0: 6967 6874 7320 746f 2062 6520 7573 6564  ights to be used
+000016b0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+000016c0: 206e 6f64 6520 7370 6c69 7474 696e 6720   node splitting 
+000016d0: 696e 7661 7269 616e 7420 6e65 7477 6f72  invariant networ
+000016e0: 6b20 6d65 6173 7572 6573 2e20 2045 6e74  k measures.  Ent
+000016f0: 7279 205b 695d 2069 7320 7468 650a 2020  ry [i] is the.  
+00001700: 2020 2020 2020 2020 2020 7765 6967 6874            weight
+00001710: 206f 6620 6e6f 6465 2069 2e20 2028 4465   of node i.  (De
+00001720: 6661 756c 743a 206c 6973 7420 6f66 206f  fault: list of o
+00001730: 6e65 7329 0a20 2020 2020 2020 203a 7479  nes).        :ty
+00001740: 7065 2073 696c 656e 6365 5f6c 6576 656c  pe silence_level
+00001750: 3a20 696e 7420 3e3d 2030 0a20 2020 2020  : int >= 0.     
+00001760: 2020 203a 6172 6720 2073 696c 656e 6365     :arg  silence
+00001770: 5f6c 6576 656c 3a20 5468 6520 6869 6768  _level: The high
+00001780: 6572 2c20 7468 6520 6c65 7373 2070 726f  er, the less pro
+00001790: 6772 6573 7320 696e 666f 2069 7320 6f75  gress info is ou
+000017a0: 7470 7574 2e0a 2020 2020 2020 2020 3a72  tput..        :r
+000017b0: 7479 7065 3a20 3a63 6c61 7373 3a60 4e65  type: :class:`Ne
+000017c0: 7477 6f72 6b60 2069 6e73 7461 6e63 650a  twork` instance.
+000017d0: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
+000017e0: 2054 6865 206e 6577 206e 6574 776f 726b   The new network
+000017f0: 2e0a 2020 2020 2020 2020 2222 220a 0a20  ..        """.. 
+00001800: 2020 2020 2020 2073 656c 662e 6469 7265         self.dire
+00001810: 6374 6564 3a20 626f 6f6c 203d 2064 6972  cted: bool = dir
+00001820: 6563 7465 640a 2020 2020 2020 2020 2222  ected.        ""
+00001830: 2269 6e64 6963 6174 6573 2077 6865 7468  "indicates wheth
+00001840: 6572 2074 6865 206e 6574 776f 726b 2069  er the network i
+00001850: 7320 6469 7265 6374 6564 2222 220a 2020  s directed""".  
+00001860: 2020 2020 2020 7365 6c66 2e73 696c 656e        self.silen
+00001870: 6365 5f6c 6576 656c 3a20 696e 7420 3d20  ce_level: int = 
+00001880: 7369 6c65 6e63 655f 6c65 7665 6c0a 2020  silence_level.  
+00001890: 2020 2020 2020 2222 2268 6967 6865 7220        """higher 
+000018a0: 2d3e 206c 6573 7320 7072 6f67 7265 7373  -> less progress
+000018b0: 2069 6e66 6f22 2222 0a0a 2020 2020 2020   info"""..      
+000018c0: 2020 7365 6c66 2e5f 6d75 745f 413a 2069    self._mut_A: i
+000018d0: 6e74 203d 2030 0a20 2020 2020 2020 2022  nt = 0.        "
+000018e0: 2222 6d75 7461 7469 6f6e 2063 6f75 6e74  ""mutation count
+000018f0: 2074 7261 636b 696e 6720 6073 656c 662e   tracking `self.
+00001900: 6164 6a63 656e 6379 6022 2222 0a20 2020  adjcency`""".   
+00001910: 2020 2020 2073 656c 662e 5f6d 7574 5f6e       self._mut_n
+00001920: 773a 2069 6e74 203d 2030 0a20 2020 2020  w: int = 0.     
+00001930: 2020 2022 2222 6d75 7461 7469 6f6e 2063     """mutation c
+00001940: 6f75 6e74 2074 7261 636b 696e 6720 6073  ount tracking `s
+00001950: 656c 662e 6e6f 6465 5f77 6569 6768 7473  elf.node_weights
+00001960: 6022 2222 0a20 2020 2020 2020 2073 656c  `""".        sel
+00001970: 662e 5f6d 7574 5f6c 613a 2069 6e74 203d  f._mut_la: int =
+00001980: 2030 0a20 2020 2020 2020 2022 2222 6d75   0.        """mu
+00001990: 7461 7469 6f6e 2063 6f75 6e74 2074 7261  tation count tra
+000019a0: 636b 696e 6720 6073 656c 662e 6772 6170  cking `self.grap
+000019b0: 682e 6573 6022 2222 0a0a 2020 2020 2020  h.es`"""..      
+000019c0: 2020 7365 6c66 2e4e 3a20 696e 7420 3d20    self.N: int = 
+000019d0: 300a 2020 2020 2020 2020 2222 226e 756d  0.        """num
+000019e0: 6265 7220 6f66 206e 6f64 6573 2222 220a  ber of nodes""".
+000019f0: 2020 2020 2020 2020 6966 206e 5f6e 6f64          if n_nod
+00001a00: 6573 2069 7320 6e6f 7420 4e6f 6e65 3a0a  es is not None:.
+00001a10: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00001a20: 2e4e 203d 206e 5f6e 6f64 6573 0a0a 2020  .N = n_nodes..  
+00001a30: 2020 2020 2020 7365 6c66 2e6e 5f6c 696e        self.n_lin
+00001a40: 6b73 3a20 696e 7420 3d20 300a 2020 2020  ks: int = 0.    
+00001a50: 2020 2020 2222 226e 756d 6265 7220 6f66      """number of
+00001a60: 206c 696e 6b73 2222 220a 2020 2020 2020   links""".      
+00001a70: 2020 7365 6c66 2e6c 696e 6b5f 6465 6e73    self.link_dens
+00001a80: 6974 793a 2066 6c6f 6174 203d 2030 0a20  ity: float = 0. 
+00001a90: 2020 2020 2020 2022 2222 7072 6f70 6f72         """propor
+00001aa0: 7469 6f6e 206f 6620 6c69 6e6b 6564 206e  tion of linked n
+00001ab0: 6f64 6520 7061 6972 7322 2222 0a0a 2020  ode pairs"""..  
+00001ac0: 2020 2020 2020 7365 6c66 2e73 705f 413a        self.sp_A:
+00001ad0: 2073 702e 6373 635f 6d61 7472 6978 203d   sp.csc_matrix =
+00001ae0: 204e 6f6e 650a 2020 2020 2020 2020 2222   None.        ""
+00001af0: 220a 2020 2020 2020 2020 4164 6a61 6365  ".        Adjace
+00001b00: 6e63 7920 6d61 7472 6978 2e20 415b 692c  ncy matrix. A[i,
+00001b10: 6a5d 3d31 2069 6e64 6963 6174 6573 2061  j]=1 indicates a
+00001b20: 206c 696e 6b20 6920 2d3e 206a 2e20 5379   link i -> j. Sy
+00001b30: 6d6d 6574 7269 6320 6966 2074 6865 0a20  mmetric if the. 
+00001b40: 2020 2020 2020 206e 6574 776f 726b 2069         network i
+00001b50: 7320 756e 6469 7265 6374 6564 2e0a 2020  s undirected..  
+00001b60: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00001b70: 2020 7365 6c66 2e73 705f 6474 7970 6520    self.sp_dtype 
+00001b80: 3d20 4e6f 6e65 0a0a 2020 2020 2020 2020  = None..        
+00001b90: 7365 6c66 2e67 7261 7068 3a20 6967 7261  self.graph: igra
+00001ba0: 7068 2e47 7261 7068 203d 204e 6f6e 650a  ph.Graph = None.
+00001bb0: 2020 2020 2020 2020 2222 2265 6d62 6564          """embed
+00001bc0: 6465 6420 6772 6170 6820 6f62 6a65 6374  ded graph object
+00001bd0: 2070 726f 7669 6469 6e67 2073 6f6d 6520   providing some 
+00001be0: 7374 616e 6461 7264 206e 6574 776f 726b  standard network
+00001bf0: 206d 6561 7375 7265 7322 2222 0a0a 2020   measures"""..  
+00001c00: 2020 2020 2020 7365 6c66 2e5f 6e6f 6465        self._node
+00001c10: 5f77 6569 6768 7473 3a20 4f70 7469 6f6e  _weights: Option
+00001c20: 616c 5b6e 702e 6e64 6172 7261 795d 203d  al[np.ndarray] =
+00001c30: 204e 6f6e 650a 2020 2020 2020 2020 7365   None.        se
+00001c40: 6c66 2e6d 6561 6e5f 6e6f 6465 5f77 6569  lf.mean_node_wei
+00001c50: 6768 743a 2066 6c6f 6174 203d 2030 0a20  ght: float = 0. 
+00001c60: 2020 2020 2020 2022 2222 6d65 616e 206e         """mean n
+00001c70: 6f64 6520 7765 6967 6874 2222 220a 2020  ode weight""".  
+00001c80: 2020 2020 2020 7365 6c66 2e74 6f74 616c        self.total
+00001c90: 5f6e 6f64 655f 7765 6967 6874 3a20 666c  _node_weight: fl
+00001ca0: 6f61 7420 3d20 300a 2020 2020 2020 2020  oat = 0.        
+00001cb0: 2222 2274 6f74 616c 206e 6f64 6520 7765  """total node we
+00001cc0: 6967 6874 2222 220a 0a20 2020 2020 2020  ight"""..       
+00001cd0: 2069 6620 6164 6a61 6365 6e63 7920 6973   if adjacency is
+00001ce0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00001cf0: 2020 2020 2020 2073 656c 662e 6164 6a61         self.adja
+00001d00: 6365 6e63 7920 3d20 6164 6a61 6365 6e63  cency = adjacenc
+00001d10: 790a 2020 2020 2020 2020 656c 6966 2065  y.        elif e
+00001d20: 6467 655f 6c69 7374 2069 7320 6e6f 7420  dge_list is not 
+00001d30: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00001d40: 2020 7365 6c66 2e73 6574 5f65 6467 655f    self.set_edge_
+00001d50: 6c69 7374 2865 6467 655f 6c69 7374 2c20  list(edge_list, 
+00001d60: 6e5f 6e6f 6465 7329 0a20 2020 2020 2020  n_nodes).       
+00001d70: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00001d80: 2020 2072 6169 7365 204e 6574 776f 726b     raise Network
+00001d90: 4572 726f 7228 2241 6e20 6164 6a61 6365  Error("An adjace
+00001da0: 6e63 7920 6d61 7472 6978 206f 7220 6564  ncy matrix or ed
+00001db0: 6765 206c 6973 7420 6861 7320 746f 2062  ge list has to b
+00001dc0: 6520 220a 2020 2020 2020 2020 2020 2020  e ".            
+00001dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001de0: 2020 2022 6769 7665 6e20 746f 2069 6e69     "given to ini
+00001df0: 7469 616c 697a 6520 616e 2069 6e73 7461  tialize an insta
+00001e00: 6e63 6520 6f66 204e 6574 776f 726b 2e22  nce of Network."
+00001e10: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+00001e20: 6e6f 6465 5f77 6569 6768 7473 203d 206e  node_weights = n
+00001e30: 6f64 655f 7765 6967 6874 730a 2020 2020  ode_weights.    
+00001e40: 2020 2020 7365 6c66 2e64 6567 7265 6528      self.degree(
+00001e50: 290a 0a20 2020 2064 6566 205f 5f63 6163  )..    def __cac
+00001e60: 6865 5f73 7461 7465 5f5f 2873 656c 6629  he_state__(self)
+00001e70: 202d 3e20 5475 706c 655b 4861 7368 6162   -> Tuple[Hashab
+00001e80: 6c65 2c20 2e2e 2e5d 3a0a 2020 2020 2020  le, ...]:.      
+00001e90: 2020 7265 7475 726e 2028 7365 6c66 2e64    return (self.d
+00001ea0: 6972 6563 7465 642c 2073 656c 662e 5f6d  irected, self._m
+00001eb0: 7574 5f41 2c29 0a0a 2020 2020 6465 6620  ut_A,)..    def 
+00001ec0: 5f5f 7374 725f 5f28 7365 6c66 293a 0a20  __str__(self):. 
+00001ed0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00001ee0: 2020 2052 6574 7572 6e20 6120 7368 6f72     Return a shor
+00001ef0: 7420 7375 6d6d 6172 7920 6f66 2074 6865  t summary of the
+00001f00: 206e 6574 776f 726b 2e0a 0a20 2020 2020   network...     
+00001f10: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
+00001f20: 0a20 2020 2020 2020 203e 3e3e 2070 7269  .        >>> pri
+00001f30: 6e74 284e 6574 776f 726b 2e53 6d61 6c6c  nt(Network.Small
+00001f40: 5465 7374 4e65 7477 6f72 6b28 2929 0a20  TestNetwork()). 
+00001f50: 2020 2020 2020 204e 6574 776f 726b 3a20         Network: 
+00001f60: 756e 6469 7265 6374 6564 2c20 3620 6e6f  undirected, 6 no
+00001f70: 6465 732c 2037 206c 696e 6b73 2c20 6c69  des, 7 links, li
+00001f80: 6e6b 2064 656e 7369 7479 2030 2e34 3637  nk density 0.467
+00001f90: 2e0a 0a20 2020 2020 2020 203a 7274 7970  ...        :rtyp
+00001fa0: 653a 2073 7472 696e 670a 2020 2020 2020  e: string.      
+00001fb0: 2020 2222 220a 2020 2020 2020 2020 6e65    """.        ne
+00001fc0: 745f 7479 7065 5f70 7265 6669 7820 3d20  t_type_prefix = 
+00001fd0: 2727 2069 6620 7365 6c66 2e64 6972 6563  '' if self.direc
+00001fe0: 7465 6420 656c 7365 2027 756e 270a 2020  ted else 'un'.  
+00001ff0: 2020 2020 2020 7265 7475 726e 2028 6622        return (f"
+00002000: 4e65 7477 6f72 6b3a 207b 6e65 745f 7479  Network: {net_ty
+00002010: 7065 5f70 7265 6669 787d 6469 7265 6374  pe_prefix}direct
+00002020: 6564 2c20 220a 2020 2020 2020 2020 2020  ed, ".          
+00002030: 2020 2020 2020 6622 7b73 656c 662e 4e7d        f"{self.N}
+00002040: 206e 6f64 6573 2c20 7b73 656c 662e 6e5f   nodes, {self.n_
+00002050: 6c69 6e6b 737d 206c 696e 6b73 2c20 220a  links} links, ".
+00002060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002070: 6622 6c69 6e6b 2064 656e 7369 7479 207b  f"link density {
+00002080: 7365 6c66 2e6c 696e 6b5f 6465 6e73 6974  self.link_densit
+00002090: 793a 2e33 667d 2e22 290a 0a20 2020 2064  y:.3f}.")..    d
+000020a0: 6566 205f 5f6c 656e 5f5f 2873 656c 6629  ef __len__(self)
+000020b0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+000020c0: 2020 2020 2020 5265 7475 726e 2074 6865        Return the
+000020d0: 206e 756d 6265 7220 6f66 206e 6f64 6573   number of nodes
+000020e0: 2061 7320 7468 6520 276c 656e 6774 6827   as the 'length'
+000020f0: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+00002100: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+00002110: 203e 3e3e 206c 656e 284e 6574 776f 726b   >>> len(Network
+00002120: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
+00002130: 6b28 2929 0a20 2020 2020 2020 2036 0a0a  k()).        6..
+00002140: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00002150: 696e 7420 3e20 300a 2020 2020 2020 2020  int > 0.        
+00002160: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00002170: 726e 2073 656c 662e 4e0a 0a20 2020 2064  rn self.N..    d
+00002180: 6566 2063 6f70 7928 7365 6c66 293a 0a20  ef copy(self):. 
+00002190: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+000021a0: 2020 2052 6574 7572 6e20 6120 636f 7079     Return a copy
+000021b0: 206f 6620 7468 6520 6e65 7477 6f72 6b2e   of the network.
+000021c0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000021d0: 2020 2020 2072 6574 7572 6e20 4e65 7477       return Netw
+000021e0: 6f72 6b28 6164 6a61 6365 6e63 793d 7365  ork(adjacency=se
+000021f0: 6c66 2e73 705f 412c 2064 6972 6563 7465  lf.sp_A, directe
+00002200: 643d 7365 6c66 2e64 6972 6563 7465 642c  d=self.directed,
+00002210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002220: 2020 2020 2020 2020 6e6f 6465 5f77 6569          node_wei
+00002230: 6768 7473 3d73 656c 662e 6e6f 6465 5f77  ghts=self.node_w
+00002240: 6569 6768 7473 2c0a 2020 2020 2020 2020  eights,.        
+00002250: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00002260: 696c 656e 6365 5f6c 6576 656c 3d73 656c  ilence_level=sel
+00002270: 662e 7369 6c65 6e63 655f 6c65 7665 6c29  f.silence_level)
+00002280: 0a0a 2020 2020 6465 6620 756e 6469 7265  ..    def undire
+00002290: 6374 6564 5f63 6f70 7928 7365 6c66 293a  cted_copy(self):
+000022a0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000022b0: 2020 2020 2052 6574 7572 6e20 616e 2075       Return an u
+000022c0: 6e64 6972 6563 7465 6420 636f 7079 206f  ndirected copy o
+000022d0: 6620 7468 6520 6e65 7477 6f72 6b2e 0a0a  f the network...
+000022e0: 2020 2020 2020 2020 4e6f 6465 7320 6920          Nodes i 
+000022f0: 616e 6420 6a20 6172 6520 6c69 6e6b 6564  and j are linked
+00002300: 2069 6e20 7468 6520 636f 7079 2069 662c   in the copy if,
+00002310: 2069 6e20 7468 6520 6375 7272 656e 7420   in the current 
+00002320: 6e65 7477 6f72 6b2c 2069 0a20 2020 2020  network, i.     
+00002330: 2020 206c 696e 6b73 2074 6f20 6a20 6f72     links to j or
+00002340: 206a 206c 696e 6b73 2074 6f20 6920 6f72   j links to i or
+00002350: 2062 6f74 682e 0a0a 2020 2020 2020 2020   both...        
+00002360: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
+00002370: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
+00002380: 4e65 7477 6f72 6b28 6164 6a61 6365 6e63  Network(adjacenc
+00002390: 793d 5b5b 302c 315d 2c5b 302c 305d 5d2c  y=[[0,1],[0,0]],
+000023a0: 2064 6972 6563 7465 643d 5472 7565 293b   directed=True);
+000023b0: 2070 7269 6e74 286e 6574 290a 2020 2020   print(net).    
+000023c0: 2020 2020 4e65 7477 6f72 6b3a 2064 6972      Network: dir
+000023d0: 6563 7465 642c 2032 206e 6f64 6573 2c20  ected, 2 nodes, 
+000023e0: 3120 6c69 6e6b 732c 206c 696e 6b20 6465  1 links, link de
+000023f0: 6e73 6974 7920 302e 3530 302e 0a20 2020  nsity 0.500..   
+00002400: 2020 2020 203e 3e3e 2070 7269 6e74 286e       >>> print(n
+00002410: 6574 2e75 6e64 6972 6563 7465 645f 636f  et.undirected_co
+00002420: 7079 2829 290a 2020 2020 2020 2020 4e65  py()).        Ne
+00002430: 7477 6f72 6b3a 2075 6e64 6972 6563 7465  twork: undirecte
+00002440: 642c 2032 206e 6f64 6573 2c20 3120 6c69  d, 2 nodes, 1 li
+00002450: 6e6b 732c 206c 696e 6b20 6465 6e73 6974  nks, link densit
+00002460: 7920 312e 3030 302e 0a0a 2020 2020 2020  y 1.000...      
+00002470: 2020 3a72 7479 7065 3a20 3a63 6c61 7373    :rtype: :class
+00002480: 3a60 4e65 7477 6f72 6b60 2069 6e73 7461  :`Network` insta
+00002490: 6e63 650a 2020 2020 2020 2020 2222 220a  nce.        """.
+000024a0: 2020 2020 2020 2020 7265 7475 726e 204e          return N
+000024b0: 6574 776f 726b 2861 646a 6163 656e 6379  etwork(adjacency
+000024c0: 3d73 656c 662e 756e 6469 7265 6374 6564  =self.undirected
+000024d0: 5f61 646a 6163 656e 6379 2829 2c0a 2020  _adjacency(),.  
+000024e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000024f0: 2020 2020 2064 6972 6563 7465 643d 4661       directed=Fa
+00002500: 6c73 652c 206e 6f64 655f 7765 6967 6874  lse, node_weight
+00002510: 733d 7365 6c66 2e6e 6f64 655f 7765 6967  s=self.node_weig
+00002520: 6874 732c 0a20 2020 2020 2020 2020 2020  hts,.           
+00002530: 2020 2020 2020 2020 2020 2020 7369 6c65              sile
+00002540: 6e63 655f 6c65 7665 6c3d 7365 6c66 2e73  nce_level=self.s
+00002550: 696c 656e 6365 5f6c 6576 656c 290a 0a20  ilence_level).. 
+00002560: 2020 2064 6566 2070 6572 6d75 7465 645f     def permuted_
+00002570: 636f 7079 2873 656c 662c 2070 6572 6d75  copy(self, permu
+00002580: 7461 7469 6f6e 293a 0a20 2020 2020 2020  tation):.       
+00002590: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
+000025a0: 7572 6e20 6120 636f 7079 206f 6620 7468  urn a copy of th
+000025b0: 6520 6e65 7477 6f72 6b20 7769 7468 206e  e network with n
+000025c0: 6f64 6520 6e75 6d62 6572 7320 7265 6172  ode numbers rear
+000025d0: 7261 6e67 6564 2e20 5468 6973 0a20 2020  ranged. This.   
+000025e0: 2020 2020 206f 7065 7261 7469 6f6e 2073       operation s
+000025f0: 686f 756c 6420 6e6f 7420 6368 616e 6765  hould not change
+00002600: 2074 6f70 6f6c 6f67 6963 616c 2069 6e66   topological inf
+00002610: 6f72 6d61 7469 6f6e 2061 6e64 206e 6574  ormation and net
+00002620: 776f 726b 0a20 2020 2020 2020 206d 6561  work.        mea
+00002630: 7375 7265 732e 0a0a 2020 2020 2020 2020  sures...        
+00002640: 3a74 7970 6520 7065 726d 7574 6174 696f  :type permutatio
+00002650: 6e3a 2061 7272 6179 2d6c 696b 6520 5b69  n: array-like [i
+00002660: 6e74 5d0a 2020 2020 2020 2020 3a61 7267  nt].        :arg
+00002670: 2070 6572 6d75 7461 7469 6f6e 3a20 6465   permutation: de
+00002680: 7369 7265 6420 7065 726d 7574 6174 696f  sired permutatio
+00002690: 6e20 6f66 206e 6f64 6573 0a20 2020 2020  n of nodes.     
+000026a0: 2020 203a 7274 7970 653a 203a 636c 6173     :rtype: :clas
+000026b0: 733a 604e 6574 776f 726b 6020 696e 7374  s:`Network` inst
+000026c0: 616e 6365 0a20 2020 2020 2020 2022 2222  ance.        """
+000026d0: 0a20 2020 2020 2020 2069 6478 203d 206e  .        idx = n
+000026e0: 702e 6172 7261 7928 7065 726d 7574 6174  p.array(permutat
+000026f0: 696f 6e29 0a20 2020 2020 2020 2069 6620  ion).        if 
+00002700: 2873 6f72 7465 6428 6964 7829 2021 3d20  (sorted(idx) != 
+00002710: 6e70 2e61 7261 6e67 6528 7365 6c66 2e4e  np.arange(self.N
+00002720: 2929 2e61 6e79 2829 3a0a 2020 2020 2020  )).any():.      
+00002730: 2020 2020 2020 7261 6973 6520 4e65 7477        raise Netw
+00002740: 6f72 6b45 7272 6f72 2822 496e 636f 7272  orkError("Incorr
+00002750: 6563 7420 7065 726d 7574 6174 696f 6e20  ect permutation 
+00002760: 696e 6469 6365 7321 2229 0a0a 2020 2020  indices!")..    
+00002770: 2020 2020 7265 7475 726e 204e 6574 776f      return Netwo
+00002780: 726b 2861 646a 6163 656e 6379 3d73 656c  rk(adjacency=sel
+00002790: 662e 7370 5f41 5b69 6478 5d5b 3a2c 2069  f.sp_A[idx][:, i
+000027a0: 6478 5d2c 0a20 2020 2020 2020 2020 2020  dx],.           
+000027b0: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
+000027c0: 5f77 6569 6768 7473 3d73 656c 662e 6e6f  _weights=self.no
+000027d0: 6465 5f77 6569 6768 7473 5b69 6478 5d2c  de_weights[idx],
+000027e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000027f0: 2020 2020 2020 2020 6469 7265 6374 6564          directed
+00002800: 3d73 656c 662e 6469 7265 6374 6564 2c0a  =self.directed,.
+00002810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002820: 2020 2020 2020 2073 696c 656e 6365 5f6c         silence_l
+00002830: 6576 656c 3d73 656c 662e 7369 6c65 6e63  evel=self.silenc
+00002840: 655f 6c65 7665 6c29 0a0a 2020 2020 6465  e_level)..    de
+00002850: 6620 7370 6c69 7474 6564 5f63 6f70 7928  f splitted_copy(
+00002860: 7365 6c66 2c20 6e6f 6465 3d2d 312c 2070  self, node=-1, p
+00002870: 726f 706f 7274 696f 6e3d 302e 3529 3a0a  roportion=0.5):.
+00002880: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00002890: 2020 2020 5265 7475 726e 2061 2063 6f70      Return a cop
+000028a0: 7920 6f66 2074 6865 206e 6574 776f 726b  y of the network
+000028b0: 2077 6974 6820 6f6e 6520 6e6f 6465 2073   with one node s
+000028c0: 706c 6974 7465 642e 0a0a 2020 2020 2020  plitted...      
+000028d0: 2020 5468 6520 7370 6563 6966 6965 6420    The specified 
+000028e0: 6e6f 6465 2069 7320 7370 6c69 7420 696e  node is split in
+000028f0: 2074 776f 2069 6e74 6572 6c69 6e6b 6564   two interlinked
+00002900: 206e 6f64 6573 0a20 2020 2020 2020 2077   nodes.        w
+00002910: 6869 6368 2061 7265 206c 696e 6b65 6420  hich are linked 
+00002920: 746f 2074 6865 2073 616d 6520 6e6f 6465  to the same node
+00002930: 7320 6173 2074 6865 206f 7269 6769 6e61  s as the origina
+00002940: 6c20 6e6f 6465 2c0a 2020 2020 2020 2020  l node,.        
+00002950: 616e 6420 7468 6520 7765 6967 6874 2069  and the weight i
+00002960: 7320 7370 6c69 7474 6564 2061 6363 6f72  s splitted accor
+00002970: 6469 6e67 2074 6f20 7468 6520 6769 7665  ding to the give
+00002980: 6e20 7072 6f70 6f72 7469 6f6e 2e0a 0a20  n proportion... 
+00002990: 2020 2020 2020 2028 5468 6973 206d 6574         (This met
+000029a0: 686f 6420 6973 2075 7365 6675 6c20 666f  hod is useful fo
+000029b0: 7220 7465 7374 696e 6720 7468 6520 6e6f  r testing the no
+000029c0: 6465 2073 706c 6974 7469 6e67 2069 6e76  de splitting inv
+000029d0: 6172 6961 6e63 650a 2020 2020 2020 2020  ariance.        
+000029e0: 6f66 206d 6561 7375 7265 7320 7369 6e63  of measures sinc
+000029f0: 6520 6120 6e2e 732e 692e 206d 6561 7375  e a n.s.i. measu
+00002a00: 7265 2077 696c 6c20 6265 2074 6865 2073  re will be the s
+00002a10: 616d 6520 6265 666f 7265 2061 6e64 2061  ame before and a
+00002a20: 6674 6572 0a20 2020 2020 2020 2074 6865  fter.        the
+00002a30: 2073 706c 6974 2e29 0a0a 2020 2020 2020   split.)..      
+00002a40: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
+00002a50: 2020 2020 2020 2020 3e3e 3e20 6e65 7420          >>> net 
+00002a60: 3d20 4e65 7477 6f72 6b2e 536d 616c 6c54  = Network.SmallT
+00002a70: 6573 744e 6574 776f 726b 2829 3b20 7072  estNetwork(); pr
+00002a80: 696e 7428 6e65 7429 0a20 2020 2020 2020  int(net).       
+00002a90: 204e 6574 776f 726b 3a20 756e 6469 7265   Network: undire
+00002aa0: 6374 6564 2c20 3620 6e6f 6465 732c 2037  cted, 6 nodes, 7
+00002ab0: 206c 696e 6b73 2c20 6c69 6e6b 2064 656e   links, link den
+00002ac0: 7369 7479 2030 2e34 3637 2e0a 2020 2020  sity 0.467..    
+00002ad0: 2020 2020 3e3e 3e20 6e65 7432 203d 206e      >>> net2 = n
+00002ae0: 6574 2e73 706c 6974 7465 645f 636f 7079  et.splitted_copy
+00002af0: 286e 6f64 653d 352c 2070 726f 706f 7274  (node=5, proport
+00002b00: 696f 6e3d 302e 3229 3b20 7072 696e 7428  ion=0.2); print(
+00002b10: 6e65 7432 290a 2020 2020 2020 2020 4e65  net2).        Ne
+00002b20: 7477 6f72 6b3a 2075 6e64 6972 6563 7465  twork: undirecte
+00002b30: 642c 2037 206e 6f64 6573 2c20 3920 6c69  d, 7 nodes, 9 li
+00002b40: 6e6b 732c 206c 696e 6b20 6465 6e73 6974  nks, link densit
+00002b50: 7920 302e 3432 392e 0a20 2020 2020 2020  y 0.429..       
+00002b60: 203e 3e3e 2070 7269 6e74 286e 6574 2e6e   >>> print(net.n
+00002b70: 6f64 655f 7765 6967 6874 7329 3b20 7072  ode_weights); pr
+00002b80: 696e 7428 6e65 7432 2e6e 6f64 655f 7765  int(net2.node_we
+00002b90: 6967 6874 7329 0a20 2020 2020 2020 205b  ights).        [
+00002ba0: 2031 2e35 2020 312e 3720 2031 2e39 2020   1.5  1.7  1.9  
+00002bb0: 322e 3120 2032 2e33 2020 322e 355d 0a20  2.1  2.3  2.5]. 
+00002bc0: 2020 2020 2020 205b 2031 2e35 2020 312e         [ 1.5  1.
+00002bd0: 3720 2031 2e39 2020 322e 3120 2032 2e33  7  1.9  2.1  2.3
+00002be0: 2020 322e 2020 302e 355d 0a0a 2020 2020    2.  0.5]..    
+00002bf0: 2020 2020 3a74 7970 6520 6e6f 6465 3a20      :type node: 
+00002c00: 696e 740a 2020 2020 2020 2020 3a61 7267  int.        :arg
+00002c10: 2020 6e6f 6465 3a20 5468 6520 696e 6465    node: The inde
+00002c20: 7820 6f66 2074 6865 206e 6f64 6520 746f  x of the node to
+00002c30: 2062 6520 7370 6c69 7474 6564 2e20 4966   be splitted. If
+00002c40: 206e 6567 6174 6976 652c 0a20 2020 2020   negative,.     
+00002c50: 2020 2020 2020 2020 2020 2020 2020 204e                 N
+00002c60: 202b 2069 6e64 6578 2069 7320 7573 6564   + index is used
+00002c70: 2e20 5468 6520 6e65 7720 6e6f 6465 2067  . The new node g
+00002c80: 6574 7320 696e 6465 7820 4e2e 2028 4465  ets index N. (De
+00002c90: 6661 756c 743a 202d 3129 0a0a 2020 2020  fault: -1)..    
+00002ca0: 2020 2020 3a74 7970 6520 7072 6f70 6f72      :type propor
+00002cb0: 7469 6f6e 3a20 666c 6f61 7420 6672 6f6d  tion: float from
+00002cc0: 2030 2074 6f20 310a 2020 2020 2020 2020   0 to 1.        
+00002cd0: 3a61 7267 2020 7072 6f70 6f72 7469 6f6e  :arg  proportion
+00002ce0: 3a20 5468 6520 7370 6c69 7474 6564 206e  : The splitted n
+00002cf0: 6f64 6520 6765 7473 2061 206e 6577 2077  ode gets a new w
+00002d00: 6569 6768 7420 6f66 0a20 2020 2020 2020  eight of.       
+00002d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d20: 2020 2028 312d 7072 6f70 6f72 7469 6f6e     (1-proportion
+00002d30: 2920 2a20 2877 6569 6768 7420 6f66 2073  ) * (weight of s
+00002d40: 706c 6974 7465 6420 6e6f 6465 292c 0a20  plitted node),. 
+00002d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d60: 2020 2020 2020 2020 2061 6e64 2074 6865           and the
+00002d70: 206e 6577 206e 6f64 6520 6765 7473 2061   new node gets a
+00002d80: 2077 6569 6768 7420 6f66 0a20 2020 2020   weight of.     
+00002d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002da0: 2020 2020 2070 726f 706f 7274 696f 6e20       proportion 
+00002db0: 2a20 2877 6569 6768 7420 6f66 2073 706c  * (weight of spl
+00002dc0: 6974 7465 6420 6e6f 6465 292e 0a20 2020  itted node)..   
+00002dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002de0: 2020 2020 2020 2028 4465 6661 756c 743a         (Default:
+00002df0: 2030 2e35 290a 0a20 2020 2020 2020 203a   0.5)..        :
+00002e00: 7274 7970 653a 203a 636c 6173 733a 604e  rtype: :class:`N
+00002e10: 6574 776f 726b 600a 2020 2020 2020 2020  etwork`.        
+00002e20: 2222 220a 2020 2020 2020 2020 4e2c 2041  """.        N, A
+00002e30: 2c20 7720 3d20 7365 6c66 2e4e 2c20 7365  , w = self.N, se
+00002e40: 6c66 2e73 705f 412c 2073 656c 662e 6e6f  lf.sp_A, self.no
+00002e50: 6465 5f77 6569 6768 7473 0a20 2020 2020  de_weights.     
+00002e60: 2020 2069 6620 6e6f 6465 203c 2030 3a0a     if node < 0:.
+00002e70: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
+00002e80: 202b 3d20 4e0a 0a20 2020 2020 2020 206e   += N..        n
+00002e90: 6577 5f41 203d 2073 702e 6c69 6c5f 6d61  ew_A = sp.lil_ma
+00002ea0: 7472 6978 2828 4e2b 312c 204e 2b31 2929  trix((N+1, N+1))
+00002eb0: 0a20 2020 2020 2020 206e 6577 5f77 203d  .        new_w =
+00002ec0: 206e 702e 7a65 726f 7328 4e2b 3129 0a20   np.zeros(N+1). 
+00002ed0: 2020 2020 2020 206e 6577 5f41 5b3a 4e2c         new_A[:N,
+00002ee0: 203a 4e5d 203d 2041 0a20 2020 2020 2020   :N] = A.       
+00002ef0: 2023 2061 6464 206c 6173 7420 726f 7720   # add last row 
+00002f00: 616e 6420 636f 6c75 6d6e 0a20 2020 2020  and column.     
+00002f10: 2020 206e 6577 5f41 5b3a 4e2c 204e 5d20     new_A[:N, N] 
+00002f20: 3d20 415b 3a2c 206e 6f64 655d 0a20 2020  = A[:, node].   
+00002f30: 2020 2020 206e 6577 5f41 5b4e 2c20 3a4e       new_A[N, :N
+00002f40: 5d20 3d20 415b 6e6f 6465 2c20 3a5d 0a20  ] = A[node, :]. 
+00002f50: 2020 2020 2020 2023 2063 6f6e 6e65 6374         # connect
+00002f60: 206e 6577 206e 6f64 6520 7769 7468 206f   new node with o
+00002f70: 7269 6769 6e61 6c0a 2020 2020 2020 2020  riginal.        
+00002f80: 6e65 775f 415b 6e6f 6465 2c20 4e5d 203d  new_A[node, N] =
+00002f90: 206e 6577 5f41 5b4e 2c20 6e6f 6465 5d20   new_A[N, node] 
+00002fa0: 3d20 310a 2020 2020 2020 2020 2320 636f  = 1.        # co
+00002fb0: 7079 2061 6e64 2061 646a 7573 7420 7765  py and adjust we
+00002fc0: 6967 6874 730a 2020 2020 2020 2020 6e65  ights.        ne
+00002fd0: 775f 775b 3a4e 5d20 3d20 775b 3a4e 5d0a  w_w[:N] = w[:N].
+00002fe0: 2020 2020 2020 2020 6e65 775f 775b 4e5d          new_w[N]
+00002ff0: 203d 2070 726f 706f 7274 696f 6e20 2a20   = proportion * 
+00003000: 775b 6e6f 6465 5d0a 2020 2020 2020 2020  w[node].        
+00003010: 6e65 775f 775b 6e6f 6465 5d20 3d20 2831  new_w[node] = (1
+00003020: 2e30 202d 2070 726f 706f 7274 696f 6e29  .0 - proportion)
+00003030: 202a 2077 5b6e 6f64 655d 0a0a 2020 2020   * w[node]..    
+00003040: 2020 2020 6e65 775f 4e57 203d 204e 6574      new_NW = Net
+00003050: 776f 726b 2861 646a 6163 656e 6379 3d6e  work(adjacency=n
+00003060: 6577 5f41 2c20 6469 7265 6374 6564 3d73  ew_A, directed=s
+00003070: 656c 662e 6469 7265 6374 6564 2c0a 2020  elf.directed,.  
+00003080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003090: 2020 2020 2020 206e 6f64 655f 7765 6967         node_weig
+000030a0: 6874 733d 6e65 775f 772c 2073 696c 656e  hts=new_w, silen
+000030b0: 6365 5f6c 6576 656c 3d73 656c 662e 7369  ce_level=self.si
+000030c0: 6c65 6e63 655f 6c65 7665 6c29 0a20 2020  lence_level).   
+000030d0: 2020 2020 2023 202d 2d20 436f 7079 206c       # -- Copy l
+000030e0: 696e 6b20 6174 7472 6962 7574 6573 0a20  ink attributes. 
+000030f0: 2020 2020 2020 2066 6f72 2061 2069 6e20         for a in 
+00003100: 7365 6c66 2e67 7261 7068 2e65 732e 6174  self.graph.es.at
+00003110: 7472 6962 7574 6573 2829 3a0a 2020 2020  tributes():.    
+00003120: 2020 2020 2020 2020 5720 3d20 7365 6c66          W = self
+00003130: 2e6c 696e 6b5f 6174 7472 6962 7574 6528  .link_attribute(
+00003140: 6129 0a20 2020 2020 2020 2020 2020 206e  a).            n
+00003150: 6577 5f57 203d 206e 702e 7a65 726f 7328  ew_W = np.zeros(
+00003160: 284e 2b31 2c20 4e2b 3129 290a 2020 2020  (N+1, N+1)).    
+00003170: 2020 2020 2020 2020 6e65 775f 575b 3a4e          new_W[:N
+00003180: 2c20 3a4e 5d20 3d20 570a 2020 2020 2020  , :N] = W.      
+00003190: 2020 2020 2020 2320 6164 6420 6c61 7374        # add last
+000031a0: 2072 6f77 2061 6e64 2063 6f6c 756d 6e0a   row and column.
+000031b0: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
+000031c0: 575b 3a4e 2c20 4e5d 203d 2057 5b3a 2c20  W[:N, N] = W[:, 
+000031d0: 6e6f 6465 5d0a 2020 2020 2020 2020 2020  node].          
+000031e0: 2020 6e65 775f 575b 4e2c 203a 4e5d 203d    new_W[N, :N] =
+000031f0: 2057 5b6e 6f64 652c 203a 5d0a 2020 2020   W[node, :].    
+00003200: 2020 2020 2020 2020 2320 6173 7369 676e          # assign
+00003210: 2077 6569 6768 7420 6265 7477 6565 6e20   weight between 
+00003220: 6e65 7720 6e6f 6465 2061 6e64 206f 7269  new node and ori
+00003230: 6769 6e61 6c20 616e 6420 666f 7220 7365  ginal and for se
+00003240: 6c66 206c 6f6f 700a 2020 2020 2020 2020  lf loop.        
+00003250: 2020 2020 6e65 775f 575b 6e6f 6465 2c20      new_W[node, 
+00003260: 4e5d 203d 206e 6577 5f57 5b4e 2c20 6e6f  N] = new_W[N, no
+00003270: 6465 5d20 3d20 6e65 775f 575b 4e2c 204e  de] = new_W[N, N
+00003280: 5d20 3d20 575b 6e6f 6465 2c20 6e6f 6465  ] = W[node, node
+00003290: 5d0a 2020 2020 2020 2020 2020 2020 6e65  ].            ne
+000032a0: 775f 4e57 2e73 6574 5f6c 696e 6b5f 6174  w_NW.set_link_at
+000032b0: 7472 6962 7574 6528 612c 206e 6577 5f57  tribute(a, new_W
+000032c0: 290a 2020 2020 2020 2020 2320 2d2d 0a20  ).        # --. 
+000032d0: 2020 2020 2020 2072 6574 7572 6e20 6e65         return ne
+000032e0: 775f 4e57 0a0a 2020 2020 4070 726f 7065  w_NW..    @prope
+000032f0: 7274 790a 2020 2020 6465 6620 6164 6a61  rty.    def adja
+00003300: 6365 6e63 7928 7365 6c66 293a 0a20 2020  cency(self):.   
+00003310: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00003320: 2052 6574 7572 6e20 7468 6520 2870 6f73   Return the (pos
+00003330: 7369 626c 7920 6e6f 6e2d 7379 6d6d 6574  sibly non-symmet
+00003340: 7269 6329 2061 646a 6163 656e 6379 206d  ric) adjacency m
+00003350: 6174 7269 7820 6173 2061 2064 656e 7365  atrix as a dense
+00003360: 206d 6174 7269 782e 0a0a 2020 2020 2020   matrix...      
+00003370: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
+00003380: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
+00003390: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
+000033a0: 6574 776f 726b 2829 2e61 646a 6163 656e  etwork().adjacen
+000033b0: 6379 290a 2020 2020 2020 2020 6172 7261  cy).        arra
+000033c0: 7928 5b5b 302c 2030 2c20 302c 2031 2c20  y([[0, 0, 0, 1, 
+000033d0: 312c 2031 5d2c 205b 302c 2030 2c20 312c  1, 1], [0, 0, 1,
+000033e0: 2031 2c20 312c 2030 5d2c 205b 302c 2031   1, 1, 0], [0, 1
+000033f0: 2c20 302c 2030 2c20 312c 2030 5d2c 0a20  , 0, 0, 1, 0],. 
+00003400: 2020 2020 2020 2020 2020 2020 2020 5b31                [1
+00003410: 2c20 312c 2030 2c20 302c 2030 2c20 305d  , 1, 0, 0, 0, 0]
+00003420: 2c20 5b31 2c20 312c 2031 2c20 302c 2030  , [1, 1, 1, 0, 0
+00003430: 2c20 305d 2c20 5b31 2c20 302c 2030 2c20  , 0], [1, 0, 0, 
+00003440: 302c 2030 2c20 305d 5d29 0a0a 2020 2020  0, 0, 0]])..    
+00003450: 2020 2020 3a72 7479 7065 3a20 7371 7561      :rtype: squa
+00003460: 7265 206e 756d 7079 2061 7272 6179 205b  re numpy array [
+00003470: 6e6f 6465 2c6e 6f64 655d 206f 6620 3073  node,node] of 0s
+00003480: 2061 6e64 2031 730a 2020 2020 2020 2020   and 1s.        
+00003490: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+000034a0: 726e 2073 656c 662e 7370 5f41 2e41 0a0a  rn self.sp_A.A..
+000034b0: 2020 2020 4061 646a 6163 656e 6379 2e73      @adjacency.s
+000034c0: 6574 7465 720a 2020 2020 6465 6620 6164  etter.    def ad
+000034d0: 6a61 6365 6e63 7928 7365 6c66 2c20 6164  jacency(self, ad
+000034e0: 6a61 6365 6e63 7929 3a0a 2020 2020 2020  jacency):.      
+000034f0: 2020 2222 220a 2020 2020 2020 2020 5365    """.        Se
+00003500: 7420 6120 6e65 7720 6164 6a61 6365 6e63  t a new adjacenc
+00003510: 7920 6d61 7472 6978 2e0a 0a20 2020 2020  y matrix...     
+00003520: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
+00003530: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
+00003540: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
+00003550: 5465 7374 4e65 7477 6f72 6b28 293b 2070  TestNetwork(); p
+00003560: 7269 6e74 286e 6574 290a 2020 2020 2020  rint(net).      
+00003570: 2020 4e65 7477 6f72 6b3a 2075 6e64 6972    Network: undir
+00003580: 6563 7465 642c 2036 206e 6f64 6573 2c20  ected, 6 nodes, 
+00003590: 3720 6c69 6e6b 732c 206c 696e 6b20 6465  7 links, link de
+000035a0: 6e73 6974 7920 302e 3436 372e 0a20 2020  nsity 0.467..   
+000035b0: 2020 2020 203e 3e3e 206e 6574 2e61 646a       >>> net.adj
+000035c0: 6163 656e 6379 203d 205b 5b30 2c31 5d2c  acency = [[0,1],
+000035d0: 5b31 2c30 5d5d 3b20 7072 696e 7428 6e65  [1,0]]; print(ne
+000035e0: 7429 0a20 2020 2020 2020 204e 6574 776f  t).        Netwo
+000035f0: 726b 3a20 756e 6469 7265 6374 6564 2c20  rk: undirected, 
+00003600: 3220 6e6f 6465 732c 2031 206c 696e 6b73  2 nodes, 1 links
+00003610: 2c20 6c69 6e6b 2064 656e 7369 7479 2031  , link density 1
+00003620: 2e30 3030 2e0a 0a20 2020 2020 2020 203a  .000...        :
+00003630: 7479 7065 2061 646a 6163 656e 6379 3a20  type adjacency: 
+00003640: 7371 7561 7265 2061 7272 6179 2d6c 696b  square array-lik
+00003650: 6520 5b5b 307c 315d 5d0a 2020 2020 2020  e [[0|1]].      
+00003660: 2020 3a61 7267 2020 6164 6a61 6365 6e63    :arg  adjacenc
+00003670: 793a 2045 6e74 7279 205b 692c 6a5d 2069  y: Entry [i,j] i
+00003680: 6e64 6963 6174 6573 2077 6865 7468 6572  ndicates whether
+00003690: 206e 6f64 6520 6920 6c69 6e6b 7320 746f   node i links to
+000036a0: 206e 6f64 6520 6a2e 0a20 2020 2020 2020   node j..       
+000036b0: 2020 2020 2049 7473 2064 6961 676f 6e61       Its diagona
+000036c0: 6c20 6d75 7374 2062 6520 7a65 726f 2e20  l must be zero. 
+000036d0: 5379 6d6d 6574 7269 6320 6966 2074 6865  Symmetric if the
+000036e0: 206e 6574 776f 726b 2069 7320 756e 6469   network is undi
+000036f0: 7265 6374 6564 2e0a 2020 2020 2020 2020  rected..        
+00003700: 2222 220a 2020 2020 2020 2020 2320 636f  """.        # co
+00003710: 6e76 6572 7420 746f 2073 7061 7273 6520  nvert to sparse 
+00003720: 6d61 7472 6978 0a20 2020 2020 2020 2073  matrix.        s
+00003730: 656c 662e 7370 5f41 203d 204e 6f6e 650a  elf.sp_A = None.
+00003740: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+00003750: 702e 6973 7370 6172 7365 2861 646a 6163  p.issparse(adjac
+00003760: 656e 6379 293a 0a20 2020 2020 2020 2020  ency):.         
+00003770: 2020 2061 646a 6163 656e 6379 203d 2073     adjacency = s
+00003780: 702e 6373 635f 6d61 7472 6978 286e 702e  p.csc_matrix(np.
+00003790: 6172 7261 7928 6164 6a61 6365 6e63 7929  array(adjacency)
+000037a0: 290a 0a20 2020 2020 2020 2023 2065 6e73  )..        # ens
+000037b0: 7572 6520 7371 7561 7265 206d 6174 7269  ure square matri
+000037c0: 780a 2020 2020 2020 2020 4d2c 204e 203d  x.        M, N =
+000037d0: 2061 646a 6163 656e 6379 2e73 6861 7065   adjacency.shape
+000037e0: 0a20 2020 2020 2020 2069 6620 4d20 213d  .        if M !=
+000037f0: 204e 3a0a 2020 2020 2020 2020 2020 2020   N:.            
+00003800: 7261 6973 6520 4e65 7477 6f72 6b45 7272  raise NetworkErr
+00003810: 6f72 2822 4164 6a61 6365 6e63 7920 6d75  or("Adjacency mu
+00003820: 7374 2062 6520 7371 7561 7265 2122 290a  st be square!").
+00003830: 2020 2020 2020 2020 7365 6c66 2e4e 203d          self.N =
+00003840: 204e 0a20 2020 2020 2020 2069 6620 4e20   N.        if N 
+00003850: 3c20 3332 3736 373a 0a20 2020 2020 2020  < 32767:.       
+00003860: 2020 2020 2073 656c 662e 7370 5f64 7479       self.sp_dty
+00003870: 7065 203d 206e 702e 696e 7431 360a 2020  pe = np.int16.  
+00003880: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00003890: 2020 2020 2020 2020 7365 6c66 2e73 705f          self.sp_
+000038a0: 6474 7970 6520 3d20 6e70 2e69 6e74 3332  dtype = np.int32
+000038b0: 0a20 2020 2020 2020 2073 656c 662e 7370  .        self.sp
+000038c0: 5f41 203d 2061 646a 6163 656e 6379 2e74  _A = adjacency.t
+000038d0: 6f63 7363 2829 2e61 7374 7970 6528 7365  ocsc().astype(se
+000038e0: 6c66 2e73 705f 6474 7970 6529 0a0a 2020  lf.sp_dtype)..  
+000038f0: 2020 2020 2020 2320 6361 6c63 756c 6174        # calculat
+00003900: 6520 6772 6170 6820 6174 7472 6962 7574  e graph attribut
+00003910: 6573 0a20 2020 2020 2020 2065 6467 6573  es.        edges
+00003920: 203d 206e 7a5f 636f 6f72 6473 2861 646a   = nz_coords(adj
+00003930: 6163 656e 6379 290a 2020 2020 2020 2020  acency).        
+00003940: 7365 6c66 2e6e 5f6c 696e 6b73 203d 2065  self.n_links = e
+00003950: 6467 6573 2e73 6861 7065 5b30 5d0a 2020  dges.shape[0].  
+00003960: 2020 2020 2020 7365 6c66 2e6c 696e 6b5f        self.link_
+00003970: 6465 6e73 6974 7920 3d20 312e 3020 2a20  density = 1.0 * 
+00003980: 7365 6c66 2e6e 5f6c 696e 6b73 202f 204e  self.n_links / N
+00003990: 202f 2028 4e20 2d20 3129 0a20 2020 2020   / (N - 1).     
+000039a0: 2020 2069 6620 6e6f 7420 7365 6c66 2e64     if not self.d
+000039b0: 6972 6563 7465 643a 0a20 2020 2020 2020  irected:.       
+000039c0: 2020 2020 2073 656c 662e 6e5f 6c69 6e6b       self.n_link
+000039d0: 7320 2f2f 3d20 320a 0a20 2020 2020 2020  s //= 2..       
+000039e0: 2023 2063 7265 6174 6520 6772 6170 6820   # create graph 
+000039f0: 6f62 6a65 6374 0a20 2020 2020 2020 2073  object.        s
+00003a00: 656c 662e 6772 6170 6820 3d20 6967 7261  elf.graph = igra
+00003a10: 7068 2e47 7261 7068 286e 3d4e 2c20 6564  ph.Graph(n=N, ed
+00003a20: 6765 733d 6c69 7374 2865 6467 6573 292c  ges=list(edges),
+00003a30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003a50: 2020 2064 6972 6563 7465 643d 7365 6c66     directed=self
+00003a60: 2e64 6972 6563 7465 6429 0a20 2020 2020  .directed).     
+00003a70: 2020 2073 656c 662e 6772 6170 682e 7369     self.graph.si
+00003a80: 6d70 6c69 6679 2829 0a0a 2020 2020 2020  mplify()..      
+00003a90: 2020 2320 696e 7661 6c69 6461 7465 2063    # invalidate c
+00003aa0: 6163 6865 0a20 2020 2020 2020 2073 656c  ache.        sel
+00003ab0: 662e 5f6d 7574 5f41 202b 3d20 310a 0a20  f._mut_A += 1.. 
+00003ac0: 2020 2064 6566 2073 6574 5f65 6467 655f     def set_edge_
+00003ad0: 6c69 7374 2873 656c 662c 2065 6467 655f  list(self, edge_
+00003ae0: 6c69 7374 2c20 6e5f 6e6f 6465 733d 4e6f  list, n_nodes=No
+00003af0: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
+00003b00: 0a20 2020 2020 2020 2052 6573 6574 206e  .        Reset n
+00003b10: 6574 776f 726b 2066 726f 6d20 616e 2065  etwork from an e
+00003b20: 6467 6520 6c69 7374 2072 6570 7265 7365  dge list represe
+00003b30: 6e74 6174 696f 6e2e 0a0a 2020 2020 2020  ntation...      
+00003b40: 2020 2e2e 206e 6f74 653a 3a0a 2020 2020    .. note::.    
+00003b50: 2020 2020 2020 2041 7373 756d 6573 2074         Assumes t
+00003b60: 6861 7420 6e6f 6465 7320 6172 6520 6e75  hat nodes are nu
+00003b70: 6d62 6572 6564 2062 7920 6e61 7475 7261  mbered by natura
+00003b80: 6c20 6e75 6d62 6572 7320 6672 6f6d 2030  l numbers from 0
+00003b90: 2074 6f20 4e2d 310a 2020 2020 2020 2020   to N-1.        
+00003ba0: 2020 2077 6974 686f 7574 2067 6170 7321     without gaps!
+00003bb0: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
+00003bc0: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
+00003bd0: 3a74 7970 6520 6564 6765 5f6c 6973 743a  :type edge_list:
+00003be0: 2061 7272 6179 2d6c 696b 6520 5b5b 696e   array-like [[in
+00003bf0: 743e 3d30 2c69 6e74 3e3d 305d 5d0a 2020  t>=0,int>=0]].  
+00003c00: 2020 2020 2020 3a61 7267 2020 6564 6765        :arg  edge
+00003c10: 5f6c 6973 743a 205b 5b69 2c6a 5d5d 2066  _list: [[i,j]] f
+00003c20: 6f72 2065 6467 6573 2069 202d 3e20 6a0a  or edges i -> j.
+00003c30: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00003c40: 2020 2020 2320 2043 6f6e 7665 7274 2074      #  Convert t
+00003c50: 6f20 4e75 6d70 7920 6172 7261 7920 616e  o Numpy array an
+00003c60: 6420 6765 7420 6e75 6d62 6572 206f 6620  d get number of 
+00003c70: 6e6f 6465 730a 2020 2020 2020 2020 6564  nodes.        ed
+00003c80: 6765 7320 3d20 6e70 2e61 7272 6179 2865  ges = np.array(e
+00003c90: 6467 655f 6c69 7374 290a 0a20 2020 2020  dge_list)..     
+00003ca0: 2020 2069 6620 6e5f 6e6f 6465 7320 6973     if n_nodes is
+00003cb0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00003cc0: 2020 204e 203d 2065 6467 6573 2e6d 6178     N = edges.max
+00003cd0: 2829 202b 2031 0a20 2020 2020 2020 2065  () + 1.        e
+00003ce0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00003cf0: 204e 203d 206e 5f6e 6f64 6573 0a0a 2020   N = n_nodes..  
+00003d00: 2020 2020 2020 2320 2053 796d 6d65 7472        #  Symmetr
+00003d10: 697a 6520 6966 2075 6e64 6972 6563 7465  ize if undirecte
+00003d20: 6420 6e65 7477 6f72 6b0a 2020 2020 2020  d network.      
+00003d30: 2020 6966 206e 6f74 2073 656c 662e 6469    if not self.di
+00003d40: 7265 6374 6564 3a0a 2020 2020 2020 2020  rected:.        
+00003d50: 2020 2020 6564 6765 7320 3d20 6e70 2e61      edges = np.a
+00003d60: 7070 656e 6428 6564 6765 732c 2065 6467  ppend(edges, edg
+00003d70: 6573 5b3a 2c20 5b31 2c20 305d 5d2c 2061  es[:, [1, 0]], a
+00003d80: 7869 733d 3029 0a0a 2020 2020 2020 2020  xis=0)..        
+00003d90: 2320 2043 7265 6174 6520 7370 6172 7365  #  Create sparse
+00003da0: 2061 646a 6163 656e 6379 206d 6174 7269   adjacency matri
+00003db0: 7820 6672 6f6d 2065 6467 6520 6c69 7374  x from edge list
+00003dc0: 0a20 2020 2020 2020 2073 705f 4120 3d20  .        sp_A = 
+00003dd0: 7370 2e63 6f6f 5f6d 6174 7269 7828 0a20  sp.coo_matrix(. 
+00003de0: 2020 2020 2020 2020 2020 2028 6e70 2e6f             (np.o
+00003df0: 6e65 735f 6c69 6b65 2865 6467 6573 2e54  nes_like(edges.T
+00003e00: 5b30 5d29 2c20 7475 706c 6528 6564 6765  [0]), tuple(edge
+00003e10: 732e 5429 292c 2073 6861 7065 3d28 4e2c  s.T)), shape=(N,
+00003e20: 204e 2929 0a0a 2020 2020 2020 2020 2320   N))..        # 
+00003e30: 2053 6574 2073 7061 7273 6520 6164 6a61   Set sparse adja
+00003e40: 6365 6e63 7920 6d61 7472 6978 0a20 2020  cency matrix.   
+00003e50: 2020 2020 2073 656c 662e 6164 6a61 6365       self.adjace
+00003e60: 6e63 7920 3d20 7370 5f41 0a0a 2020 2020  ncy = sp_A..    
+00003e70: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00003e80: 6620 6e6f 6465 5f77 6569 6768 7473 2873  f node_weights(s
+00003e90: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00003ea0: 2261 7272 6179 206f 6620 6e6f 6465 2077  "array of node w
+00003eb0: 6569 6768 7473 2222 220a 2020 2020 2020  eights""".      
+00003ec0: 2020 7265 7475 726e 2073 656c 662e 5f6e    return self._n
+00003ed0: 6f64 655f 7765 6967 6874 730a 0a20 2020  ode_weights..   
+00003ee0: 2040 6e6f 6465 5f77 6569 6768 7473 2e73   @node_weights.s
+00003ef0: 6574 7465 720a 2020 2020 6465 6620 6e6f  etter.    def no
+00003f00: 6465 5f77 6569 6768 7473 2873 656c 662c  de_weights(self,
+00003f10: 2077 6569 6768 7473 3a20 4f70 7469 6f6e   weights: Option
+00003f20: 616c 5b6e 702e 6e64 6172 7261 795d 293a  al[np.ndarray]):
+00003f30: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00003f40: 2020 2020 2053 6574 2074 6865 206e 6f64       Set the nod
+00003f50: 6520 7765 6967 6874 7320 746f 2062 6520  e weights to be 
+00003f60: 7573 6564 2066 6f72 206e 6f64 6520 7370  used for node sp
+00003f70: 6c69 7474 696e 6720 696e 7661 7269 616e  litting invarian
+00003f80: 7420 6e65 7477 6f72 6b0a 2020 2020 2020  t network.      
+00003f90: 2020 6d65 6173 7572 6573 2e0a 0a20 2020    measures...   
+00003fa0: 2020 2020 202a 2a45 7861 6d70 6c65 3a2a       **Example:*
+00003fb0: 2a0a 0a20 2020 2020 2020 203e 3e3e 206e  *..        >>> n
+00003fc0: 6574 203d 204e 6574 776f 726b 2e53 6d61  et = Network.Sma
+00003fd0: 6c6c 5465 7374 4e65 7477 6f72 6b28 293b  llTestNetwork();
+00003fe0: 2070 7269 6e74 286e 6574 2e6e 6f64 655f   print(net.node_
+00003ff0: 7765 6967 6874 7329 0a20 2020 2020 2020  weights).       
+00004000: 205b 2031 2e35 2020 312e 3720 2031 2e39   [ 1.5  1.7  1.9
+00004010: 2020 322e 3120 2032 2e33 2020 322e 355d    2.1  2.3  2.5]
+00004020: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
+00004030: 2e6e 6f64 655f 7765 6967 6874 7320 3d20  .node_weights = 
+00004040: 5b31 2c31 2c31 2c31 2c31 2c31 5d3b 2070  [1,1,1,1,1,1]; p
+00004050: 7269 6e74 286e 6574 2e6e 6f64 655f 7765  rint(net.node_we
+00004060: 6967 6874 7329 0a20 2020 2020 2020 205b  ights).        [
+00004070: 2031 2e20 2031 2e20 2031 2e20 2031 2e20   1.  1.  1.  1. 
+00004080: 2031 2e20 2031 2e5d 0a0a 2020 2020 2020   1.  1.]..      
+00004090: 2020 3a74 7970 6520 7765 6967 6874 733a    :type weights:
+000040a0: 2061 7272 6179 2d6c 696b 6520 5b66 6c6f   array-like [flo
+000040b0: 6174 3e3d 305d 0a20 2020 2020 2020 203a  at>=0].        :
+000040c0: 6172 6720 2077 6569 6768 7473 3a20 6172  arg  weights: ar
+000040d0: 7261 792d 6c69 6b65 205b 6e6f 6465 5d20  ray-like [node] 
+000040e0: 6f66 2077 6569 6768 7473 2028 6465 6661  of weights (defa
+000040f0: 756c 743a 205b 312e 2e2e 315d 290a 2020  ult: [1...1]).  
+00004100: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00004110: 2020 4e20 3d20 7365 6c66 2e4e 0a0a 2020    N = self.N..  
+00004120: 2020 2020 2020 6966 2077 6569 6768 7473        if weights
+00004130: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00004140: 2020 2020 2020 7720 3d20 6e70 2e6f 6e65        w = np.one
+00004150: 7328 4e2c 2064 7479 7065 3d44 5745 4947  s(N, dtype=DWEIG
+00004160: 4854 290a 2020 2020 2020 2020 656c 6966  HT).        elif
+00004170: 206c 656e 2877 6569 6768 7473 2920 213d   len(weights) !=
+00004180: 204e 3a0a 2020 2020 2020 2020 2020 2020   N:.            
+00004190: 7261 6973 6520 4e65 7477 6f72 6b45 7272  raise NetworkErr
+000041a0: 6f72 2822 496e 636f 7272 6563 7420 6e75  or("Incorrect nu
+000041b0: 6d62 6572 206f 6620 6e6f 6465 2077 6569  mber of node wei
+000041c0: 6768 7473 2122 290a 2020 2020 2020 2020  ghts!").        
+000041d0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000041e0: 2020 7720 3d20 6e70 2e61 7272 6179 2877    w = np.array(w
+000041f0: 6569 6768 7473 2c20 6474 7970 653d 4457  eights, dtype=DW
+00004200: 4549 4748 5429 0a0a 2020 2020 2020 2020  EIGHT)..        
+00004210: 7365 6c66 2e5f 6e6f 6465 5f77 6569 6768  self._node_weigh
+00004220: 7473 203d 2077 0a20 2020 2020 2020 2073  ts = w.        s
+00004230: 656c 662e 6d65 616e 5f6e 6f64 655f 7765  elf.mean_node_we
+00004240: 6967 6874 203d 2077 2e6d 6561 6e28 290a  ight = w.mean().
+00004250: 2020 2020 2020 2020 7365 6c66 2e74 6f74          self.tot
+00004260: 616c 5f6e 6f64 655f 7765 6967 6874 203d  al_node_weight =
+00004270: 2077 2e73 756d 2829 0a0a 2020 2020 2020   w.sum()..      
+00004280: 2020 2320 696e 7661 6c69 6461 7465 2063    # invalidate c
+00004290: 6163 6865 0a20 2020 2020 2020 2073 656c  ache.        sel
+000042a0: 662e 5f6d 7574 5f6e 7720 2b3d 2031 0a0a  f._mut_nw += 1..
+000042b0: 2020 2020 6465 6620 7370 5f41 706c 7573      def sp_Aplus
+000042c0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000042d0: 2222 2241 5e2b 203d 2041 202b 2049 642e  """A^+ = A + Id.
+000042e0: 206d 6174 7269 7820 7573 6564 2069 6e20   matrix used in 
+000042f0: 6e2e 732e 692e 206d 6561 7375 7265 7322  n.s.i. measures"
+00004300: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
+00004310: 6e20 7365 6c66 2e73 705f 4120 2b20 7370  n self.sp_A + sp
+00004320: 2e69 6465 6e74 6974 7928 7365 6c66 2e4e  .identity(self.N
+00004330: 2c20 6474 7970 653d 7365 6c66 2e73 705f  , dtype=self.sp_
+00004340: 6474 7970 6529 0a0a 2020 2020 6465 6620  dtype)..    def 
+00004350: 7370 5f64 6961 675f 7728 7365 6c66 293a  sp_diag_w(self):
+00004360: 0a20 2020 2020 2020 2022 2222 5370 6172  .        """Spar
+00004370: 7365 2064 6961 676f 6e61 6c20 6d61 7472  se diagonal matr
+00004380: 6978 206f 6620 6e6f 6465 2077 6569 6768  ix of node weigh
+00004390: 7473 2222 220a 2020 2020 2020 2020 7265  ts""".        re
+000043a0: 7475 726e 2073 702e 6469 6167 7328 5b73  turn sp.diags([s
+000043b0: 656c 662e 6e6f 6465 5f77 6569 6768 7473  elf.node_weights
+000043c0: 5d2c 205b 305d 2c0a 2020 2020 2020 2020  ], [0],.        
+000043d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000043e0: 7368 6170 653d 2873 656c 662e 4e2c 2073  shape=(self.N, s
+000043f0: 656c 662e 4e29 2c20 666f 726d 6174 3d27  elf.N), format='
+00004400: 6373 6327 290a 0a20 2020 2064 6566 2073  csc')..    def s
+00004410: 705f 6469 6167 5f77 5f69 6e76 2873 656c  p_diag_w_inv(sel
+00004420: 6629 3a0a 2020 2020 2020 2020 2222 2253  f):.        """S
+00004430: 7061 7273 6520 6469 6167 6f6e 616c 206d  parse diagonal m
+00004440: 6174 7269 7820 6f66 2069 6e76 6572 7365  atrix of inverse
+00004450: 206e 6f64 6520 7765 6967 6874 7322 2222   node weights"""
+00004460: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00004470: 7370 2e64 6961 6773 285b 3120 2f20 7365  sp.diags([1 / se
+00004480: 6c66 2e6e 6f64 655f 7765 6967 6874 735d  lf.node_weights]
+00004490: 2c20 5b30 5d2c 0a20 2020 2020 2020 2020  , [0],.         
+000044a0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000044b0: 6861 7065 3d28 7365 6c66 2e4e 2c20 7365  hape=(self.N, se
+000044c0: 6c66 2e4e 292c 2066 6f72 6d61 743d 2763  lf.N), format='c
+000044d0: 7363 2729 0a0a 2020 2020 6465 6620 7370  sc')..    def sp
+000044e0: 5f64 6961 675f 7371 7274 5f77 2873 656c  _diag_sqrt_w(sel
+000044f0: 6629 3a0a 2020 2020 2020 2020 2222 2253  f):.        """S
+00004500: 7061 7273 6520 6469 6167 6f6e 616c 206d  parse diagonal m
+00004510: 6174 7269 7820 6f66 2073 7175 6172 6520  atrix of square 
+00004520: 726f 6f74 7320 6f66 206e 6f64 6520 7765  roots of node we
+00004530: 6967 6874 7322 2222 0a20 2020 2020 2020  ights""".       
+00004540: 2072 6574 7572 6e20 7370 2e64 6961 6773   return sp.diags
+00004550: 285b 6e70 2e73 7172 7428 7365 6c66 2e6e  ([np.sqrt(self.n
+00004560: 6f64 655f 7765 6967 6874 7329 5d2c 205b  ode_weights)], [
+00004570: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+00004580: 2020 2020 2020 2020 2020 2020 7368 6170              shap
+00004590: 653d 2873 656c 662e 4e2c 2073 656c 662e  e=(self.N, self.
+000045a0: 4e29 2c20 666f 726d 6174 3d27 6373 6327  N), format='csc'
+000045b0: 290a 0a20 2020 2023 0a20 2020 2023 2020  )..    #.    #  
+000045c0: 4c6f 6164 2061 6e64 2073 6176 6520 4e65  Load and save Ne
+000045d0: 7477 6f72 6b20 6f62 6a65 6374 0a20 2020  twork object.   
+000045e0: 2023 0a0a 2020 2020 6465 6620 7361 7665   #..    def save
+000045f0: 2873 656c 662c 2066 696c 656e 616d 652c  (self, filename,
+00004600: 2066 696c 6566 6f72 6d61 743d 4e6f 6e65   fileformat=None
+00004610: 2c20 2a61 7267 732c 202a 2a6b 7764 7329  , *args, **kwds)
+00004620: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00004630: 2020 2020 2020 5361 7665 2074 6865 204e        Save the N
+00004640: 6574 776f 726b 206f 626a 6563 7420 746f  etwork object to
+00004650: 2061 2066 696c 652e 0a0a 2020 2020 2020   a file...      
+00004660: 2020 556e 6966 6965 6420 7772 6974 696e    Unified writin
+00004670: 6720 6675 6e63 7469 6f6e 2066 6f72 2067  g function for g
+00004680: 7261 7068 732e 2052 656c 6965 7320 6f6e  raphs. Relies on
+00004690: 2061 6e64 2070 6172 7469 616c 6c79 2065   and partially e
+000046a0: 7874 656e 6473 0a20 2020 2020 2020 2074  xtends.        t
+000046b0: 6865 2063 6f72 7265 7370 6f6e 6469 6e67  he corresponding
+000046c0: 2069 6772 6170 6820 6675 6e63 7469 6f6e   igraph function
+000046d0: 2e20 5265 6665 7220 746f 2069 6772 6170  . Refer to igrap
+000046e0: 6820 646f 6375 6d65 6e74 6174 696f 6e20  h documentation 
+000046f0: 666f 720a 2020 2020 2020 2020 6675 7274  for.        furt
+00004700: 6865 7220 6465 7461 696c 7320 6f6e 2074  her details on t
+00004710: 6865 2076 6172 696f 7573 2077 7269 7465  he various write
+00004720: 7220 6d65 7468 6f64 7320 666f 7220 6469  r methods for di
+00004730: 6666 6572 656e 7420 666f 726d 6174 732e  fferent formats.
+00004740: 0a0a 2020 2020 2020 2020 5468 6973 206d  ..        This m
+00004750: 6574 686f 6420 7472 6965 7320 746f 2069  ethod tries to i
+00004760: 6465 6e74 6966 7920 7468 6520 666f 726d  dentify the form
+00004770: 6174 206f 6620 7468 6520 6772 6170 6820  at of the graph 
+00004780: 6769 7665 6e20 696e 0a20 2020 2020 2020  given in.       
+00004790: 2074 6865 2066 6972 7374 2070 6172 616d   the first param
+000047a0: 6574 6572 2028 6261 7365 6420 6f6e 2065  eter (based on e
+000047b0: 7874 656e 7369 6f6e 2920 616e 6420 6361  xtension) and ca
+000047c0: 6c6c 7320 7468 6520 636f 7272 6573 706f  lls the correspo
+000047d0: 6e64 696e 670a 2020 2020 2020 2020 7772  nding.        wr
+000047e0: 6974 6572 206d 6574 686f 642e 0a0a 2020  iter method...  
+000047f0: 2020 2020 2020 4578 6973 7469 6e67 206e        Existing n
+00004800: 6f64 6520 616e 6420 6c69 6e6b 2061 7474  ode and link att
+00004810: 7269 6275 7465 732f 7765 6967 6874 7320  ributes/weights 
+00004820: 6172 6520 616c 736f 2073 746f 7265 6420  are also stored 
+00004830: 6465 7065 6e64 696e 670a 2020 2020 2020  depending.      
+00004840: 2020 6f6e 2074 6865 2063 686f 7365 6e20    on the chosen 
+00004850: 6669 6c65 2066 6f72 6d61 742e 2045 2e67  file format. E.g
+00004860: 2e2c 2074 6865 2066 6f72 6d61 7473 2047  ., the formats G
+00004870: 7261 7068 4d4c 2061 6e64 2067 7a69 7070  raphML and gzipp
+00004880: 6564 0a20 2020 2020 2020 2047 7261 7068  ed.        Graph
+00004890: 4d4c 2061 7265 2061 626c 6520 746f 2073  ML are able to s
+000048a0: 746f 7265 2062 6f74 6820 6e6f 6465 2061  tore both node a
+000048b0: 6e64 206c 696e 6b20 7765 6967 6874 732e  nd link weights.
+000048c0: 0a0a 2020 2020 2020 2020 5468 6520 7265  ..        The re
+000048d0: 6d61 696e 696e 6720 6172 6775 6d65 6e74  maining argument
+000048e0: 7320 6172 6520 7061 7373 6564 2074 6f20  s are passed to 
+000048f0: 7468 6520 7772 6974 6572 206d 6574 686f  the writer metho
+00004900: 6420 7769 7468 6f75 740a 2020 2020 2020  d without.      
+00004910: 2020 616e 7920 6368 616e 6765 732e 0a0a    any changes...
+00004920: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
+00004930: 2066 696c 656e 616d 653a 2054 6865 206e   filename: The n
+00004940: 616d 6520 6f66 2074 6865 2066 696c 6520  ame of the file 
+00004950: 7768 6572 6520 7468 6520 4e65 7477 6f72  where the Networ
+00004960: 6b20 6f62 6a65 6374 2069 7320 746f 0a20  k object is to. 
+00004970: 2020 2020 2020 2020 2020 2062 6520 7374             be st
+00004980: 6f72 6564 2e0a 2020 2020 2020 2020 3a61  ored..        :a
+00004990: 7267 2073 7472 2066 696c 6566 6f72 6d61  rg str fileforma
+000049a0: 743a 2074 6865 2066 6f72 6d61 7420 6f66  t: the format of
+000049b0: 2074 6865 2066 696c 6520 2869 6620 6f6e   the file (if on
+000049c0: 6520 7761 6e74 7320 746f 206f 7665 7272  e wants to overr
+000049d0: 6964 650a 2020 2020 2020 2020 2020 2020  ide.            
+000049e0: 7468 6520 666f 726d 6174 2064 6574 6572  the format deter
+000049f0: 6d69 6e65 6420 6672 6f6d 2074 6865 2066  mined from the f
+00004a00: 696c 656e 616d 6520 6578 7465 6e73 696f  ilename extensio
+00004a10: 6e2c 206f 7220 7468 6520 6669 6c65 6e61  n, or the filena
+00004a20: 6d65 0a20 2020 2020 2020 2020 2020 2069  me.            i
+00004a30: 7473 656c 6620 6973 2061 2073 7472 6561  tself is a strea
+00004a40: 6d29 2e20 6060 4e6f 6e65 6060 206d 6561  m). ``None`` mea
+00004a50: 6e73 2061 7574 6f2d 6465 7465 6374 696f  ns auto-detectio
+00004a60: 6e2e 2050 6f73 7369 626c 6520 7661 6c75  n. Possible valu
+00004a70: 6573 0a20 2020 2020 2020 2020 2020 2061  es.            a
+00004a80: 7265 3a20 6060 226e 636f 6c22 6060 2028  re: ``"ncol"`` (
+00004a90: 4e43 4f4c 2066 6f72 6d61 7429 2c20 6060  NCOL format), ``
+00004aa0: 226c 676c 2260 6020 284c 474c 2066 6f72  "lgl"`` (LGL for
+00004ab0: 6d61 7429 2c0a 2020 2020 2020 2020 2020  mat),.          
+00004ac0: 2020 6060 2267 7261 7068 6d6c 2260 602c    ``"graphml"``,
+00004ad0: 2060 6022 6772 6170 686d 6c7a 2260 6020   ``"graphmlz"`` 
+00004ae0: 2847 7261 7068 4d4c 2061 6e64 2067 7a69  (GraphML and gzi
+00004af0: 7070 6564 2047 7261 7068 4d4c 2066 6f72  pped GraphML for
+00004b00: 6d61 7429 2c0a 2020 2020 2020 2020 2020  mat),.          
+00004b10: 2020 6060 2267 6d6c 2260 6020 2847 4d4c    ``"gml"`` (GML
+00004b20: 2066 6f72 6d61 7429 2c20 6060 2264 6f74   format), ``"dot
+00004b30: 2260 602c 2060 6022 6772 6170 6876 697a  "``, ``"graphviz
+00004b40: 2260 6020 2844 4f54 2066 6f72 6d61 742c  "`` (DOT format,
+00004b50: 2075 7365 640a 2020 2020 2020 2020 2020   used.          
+00004b60: 2020 6279 2047 7261 7068 5669 7a29 2c20    by GraphViz), 
+00004b70: 6060 226e 6574 2260 602c 2060 6022 7061  ``"net"``, ``"pa
+00004b80: 6a65 6b22 6060 2028 5061 6a65 6b20 666f  jek"`` (Pajek fo
+00004b90: 726d 6174 292c 2060 6022 6469 6d61 6373  rmat), ``"dimacs
+00004ba0: 2260 600a 2020 2020 2020 2020 2020 2020  "``.            
+00004bb0: 2844 494d 4143 5320 666f 726d 6174 292c  (DIMACS format),
+00004bc0: 2060 6022 6564 6765 6c69 7374 2260 602c   ``"edgelist"``,
+00004bd0: 2060 6022 6564 6765 7322 6060 206f 7220   ``"edges"`` or 
+00004be0: 6060 2265 6467 6522 6060 2028 6564 6765  ``"edge"`` (edge
+00004bf0: 0a20 2020 2020 2020 2020 2020 206c 6973  .            lis
+00004c00: 7429 2c20 6060 2261 646a 6163 656e 6379  t), ``"adjacency
+00004c10: 2260 6020 2861 646a 6163 656e 6379 206d  "`` (adjacency m
+00004c20: 6174 7269 7829 2c20 6060 2270 6963 6b6c  atrix), ``"pickl
+00004c30: 6522 6060 2028 5079 7468 6f6e 0a20 2020  e"`` (Python.   
+00004c40: 2020 2020 2020 2020 2070 6963 6b6c 6564           pickled
+00004c50: 2066 6f72 6d61 7429 2c20 6060 2273 7667   format), ``"svg
+00004c60: 2260 6020 2853 6361 6c61 626c 6520 5665  "`` (Scalable Ve
+00004c70: 6374 6f72 2047 7261 7068 6963 7329 2e0a  ctor Graphics)..
+00004c80: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00004c90: 2020 2020 2320 2053 746f 7265 206e 6f64      #  Store nod
+00004ca0: 6520 7765 6967 6874 7320 6173 2061 6e20  e weights as an 
+00004cb0: 6967 7261 7068 2076 6572 7465 7820 6174  igraph vertex at
+00004cc0: 7472 6962 7574 6520 666f 7220 7361 7669  tribute for savi
+00004cd0: 6e67 0a20 2020 2020 2020 2023 2020 4c69  ng.        #  Li
+00004ce0: 6e6b 2061 7474 7269 6275 7465 732f 7765  nk attributes/we
+00004cf0: 6967 6874 7320 6172 6520 7374 6f72 6564  ights are stored
+00004d00: 2061 7574 6f6d 6174 6963 616c 6c79 2069   automatically i
+00004d10: 6620 7468 6579 2065 7869 7374 0a20 2020  f they exist.   
+00004d20: 2020 2020 2069 6620 7365 6c66 2e6e 6f64       if self.nod
+00004d30: 655f 7765 6967 6874 7320 6973 206e 6f74  e_weights is not
+00004d40: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00004d50: 2020 2073 656c 662e 6772 6170 682e 7673     self.graph.vs
+00004d60: 2e73 6574 5f61 7474 7269 6275 7465 5f76  .set_attribute_v
+00004d70: 616c 7565 7328 0a20 2020 2020 2020 2020  alues(.         
+00004d80: 2020 2020 2020 2022 6e6f 6465 5f77 6569         "node_wei
+00004d90: 6768 745f 6e73 6922 2c20 6c69 7374 2873  ght_nsi", list(s
+00004da0: 656c 662e 6e6f 6465 5f77 6569 6768 7473  elf.node_weights
+00004db0: 2929 0a0a 2020 2020 2020 2020 7365 6c66  ))..        self
+00004dc0: 2e67 7261 7068 2e77 7269 7465 2866 3d66  .graph.write(f=f
+00004dd0: 696c 656e 616d 652c 2066 6f72 6d61 743d  ilename, format=
+00004de0: 6669 6c65 666f 726d 6174 2c20 2a61 7267  fileformat, *arg
+00004df0: 732c 202a 2a6b 7764 7329 0a0a 2020 2020  s, **kwds)..    
+00004e00: 4073 7461 7469 636d 6574 686f 640a 2020  @staticmethod.  
+00004e10: 2020 6465 6620 4c6f 6164 2866 696c 656e    def Load(filen
+00004e20: 616d 652c 2066 696c 6566 6f72 6d61 743d  ame, fileformat=
+00004e30: 4e6f 6e65 2c20 7369 6c65 6e63 655f 6c65  None, silence_le
+00004e40: 7665 6c3d 302c 202a 6172 6773 2c20 2a2a  vel=0, *args, **
+00004e50: 6b77 6473 293a 0a20 2020 2020 2020 2022  kwds):.        "
+00004e60: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
+00004e70: 6e20 6120 4e65 7477 6f72 6b20 6f62 6a65  n a Network obje
+00004e80: 6374 2073 746f 7265 6420 696e 2061 2066  ct stored in a f
+00004e90: 696c 652e 0a0a 2020 2020 2020 2020 556e  ile...        Un
+00004ea0: 6966 6965 6420 7265 6164 696e 6720 6675  ified reading fu
+00004eb0: 6e63 7469 6f6e 2066 6f72 2067 7261 7068  nction for graph
+00004ec0: 732e 2052 656c 6965 7320 6f6e 2061 6e64  s. Relies on and
+00004ed0: 2070 6172 7469 616c 6c79 2065 7874 656e   partially exten
+00004ee0: 6473 0a20 2020 2020 2020 2074 6865 2063  ds.        the c
+00004ef0: 6f72 7265 7370 6f6e 6469 6e67 2069 6772  orresponding igr
+00004f00: 6170 6820 6675 6e63 7469 6f6e 2e20 5265  aph function. Re
+00004f10: 6665 7220 746f 2069 6772 6170 6820 646f  fer to igraph do
+00004f20: 6375 6d65 6e74 6174 696f 6e20 666f 720a  cumentation for.
+00004f30: 2020 2020 2020 2020 6675 7274 6865 7220          further 
+00004f40: 6465 7461 696c 7320 6f6e 2074 6865 2076  details on the v
+00004f50: 6172 696f 7573 2072 6561 6465 7220 6d65  arious reader me
+00004f60: 7468 6f64 7320 666f 7220 6469 6666 6572  thods for differ
+00004f70: 656e 7420 666f 726d 6174 732e 0a0a 2020  ent formats...  
+00004f80: 2020 2020 2020 5468 6973 206d 6574 686f        This metho
+00004f90: 6420 7472 6965 7320 746f 2069 6465 6e74  d tries to ident
+00004fa0: 6966 7920 7468 6520 666f 726d 6174 206f  ify the format o
+00004fb0: 6620 7468 6520 6772 6170 6820 6769 7665  f the graph give
+00004fc0: 6e20 696e 0a20 2020 2020 2020 2074 6865  n in.        the
+00004fd0: 2066 6972 7374 2070 6172 616d 6574 6572   first parameter
+00004fe0: 2061 6e64 2063 616c 6c73 2074 6865 2063   and calls the c
+00004ff0: 6f72 7265 7370 6f6e 6469 6e67 2072 6561  orresponding rea
+00005000: 6465 7220 6d65 7468 6f64 2e0a 0a20 2020  der method...   
+00005010: 2020 2020 2045 7869 7374 696e 6720 6e6f       Existing no
+00005020: 6465 2061 6e64 206c 696e 6b20 6174 7472  de and link attr
+00005030: 6962 7574 6573 2f77 6569 6768 7473 2061  ibutes/weights a
+00005040: 7265 2061 6c73 6f20 7265 7374 6f72 6564  re also restored
+00005050: 2064 6570 656e 6469 6e67 0a20 2020 2020   depending.     
+00005060: 2020 206f 6e20 7468 6520 6368 6f73 656e     on the chosen
+00005070: 2066 696c 6520 666f 726d 6174 2e20 452e   file format. E.
+00005080: 672e 2c20 7468 6520 666f 726d 6174 7320  g., the formats 
+00005090: 4772 6170 684d 4c20 616e 6420 677a 6970  GraphML and gzip
+000050a0: 7065 640a 2020 2020 2020 2020 4772 6170  ped.        Grap
+000050b0: 684d 4c20 6172 6520 6162 6c65 2074 6f20  hML are able to 
+000050c0: 7374 6f72 6520 626f 7468 206e 6f64 6520  store both node 
+000050d0: 616e 6420 6c69 6e6b 2077 6569 6768 7473  and link weights
+000050e0: 2e0a 0a20 2020 2020 2020 2054 6865 2072  ...        The r
+000050f0: 656d 6169 6e69 6e67 2061 7267 756d 656e  emaining argumen
+00005100: 7473 2061 7265 2070 6173 7365 6420 746f  ts are passed to
+00005110: 2074 6865 2072 6561 6465 7220 6d65 7468   the reader meth
+00005120: 6f64 2077 6974 686f 7574 0a20 2020 2020  od without.     
+00005130: 2020 2061 6e79 2063 6861 6e67 6573 2e0a     any changes..
+00005140: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
+00005150: 7220 6669 6c65 6e61 6d65 3a20 5468 6520  r filename: The 
+00005160: 6e61 6d65 206f 6620 7468 6520 6669 6c65  name of the file
+00005170: 2063 6f6e 7461 696e 696e 6720 7468 6520   containing the 
+00005180: 4e65 7477 6f72 6b20 6f62 6a65 6374 2e0a  Network object..
+00005190: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
+000051a0: 2066 696c 6566 6f72 6d61 743a 2074 6865   fileformat: the
+000051b0: 2066 6f72 6d61 7420 6f66 2074 6865 2066   format of the f
+000051c0: 696c 6520 2869 6620 6b6e 6f77 6e20 696e  ile (if known in
+000051d0: 2061 6476 616e 6365 292e 0a20 2020 2020   advance)..     
+000051e0: 2020 2020 2060 604e 6f6e 6560 6020 6d65       ``None`` me
+000051f0: 616e 7320 6175 746f 2d64 6574 6563 7469  ans auto-detecti
+00005200: 6f6e 2e20 506f 7373 6962 6c65 2076 616c  on. Possible val
+00005210: 7565 7320 6172 653a 2060 6022 6e63 6f6c  ues are: ``"ncol
+00005220: 2260 6020 284e 434f 4c0a 2020 2020 2020  "`` (NCOL.      
+00005230: 2020 2020 666f 726d 6174 292c 2060 6022      format), ``"
+00005240: 6c67 6c22 6060 2028 4c47 4c20 666f 726d  lgl"`` (LGL form
+00005250: 6174 292c 2060 6022 6772 6170 686d 6c22  at), ``"graphml"
+00005260: 6060 2c20 6060 2267 7261 7068 6d6c 7a22  ``, ``"graphmlz"
+00005270: 6060 0a20 2020 2020 2020 2020 2028 4772  ``.          (Gr
+00005280: 6170 684d 4c20 616e 6420 677a 6970 7065  aphML and gzippe
+00005290: 6420 4772 6170 684d 4c20 666f 726d 6174  d GraphML format
+000052a0: 292c 2060 6022 676d 6c22 6060 2028 474d  ), ``"gml"`` (GM
+000052b0: 4c20 666f 726d 6174 292c 0a20 2020 2020  L format),.     
+000052c0: 2020 2020 2060 6022 6e65 7422 6060 2c20       ``"net"``, 
+000052d0: 6060 2270 616a 656b 2260 6020 2850 616a  ``"pajek"`` (Paj
+000052e0: 656b 2066 6f72 6d61 7429 2c20 6060 2264  ek format), ``"d
+000052f0: 696d 6163 7322 6060 2028 4449 4d41 4353  imacs"`` (DIMACS
+00005300: 2066 6f72 6d61 7429 2c0a 2020 2020 2020   format),.      
+00005310: 2020 2020 6060 2265 6467 656c 6973 7422      ``"edgelist"
+00005320: 6060 2c20 6060 2265 6467 6573 2260 6020  ``, ``"edges"`` 
+00005330: 6f72 2060 6022 6564 6765 2260 6020 2865  or ``"edge"`` (e
+00005340: 6467 6520 6c69 7374 292c 0a20 2020 2020  dge list),.     
+00005350: 2020 2020 2060 6022 6164 6a61 6365 6e63       ``"adjacenc
+00005360: 7922 6060 2028 6164 6a61 6365 6e63 7920  y"`` (adjacency 
+00005370: 6d61 7472 6978 292c 2060 6022 7069 636b  matrix), ``"pick
+00005380: 6c65 2260 6020 2850 7974 686f 6e20 7069  le"`` (Python pi
+00005390: 636b 6c65 640a 2020 2020 2020 2020 2020  ckled.          
+000053a0: 666f 726d 6174 292e 0a20 2020 2020 2020  format)..       
+000053b0: 203a 7479 7065 2073 696c 656e 6365 5f6c   :type silence_l
+000053c0: 6576 656c 3a20 696e 7420 3e3d 2030 0a20  evel: int >= 0. 
+000053d0: 2020 2020 2020 203a 6172 6720 2073 696c         :arg  sil
+000053e0: 656e 6365 5f6c 6576 656c 3a20 5468 6520  ence_level: The 
+000053f0: 6869 6768 6572 2c20 7468 6520 6c65 7373  higher, the less
+00005400: 2070 726f 6772 6573 7320 696e 666f 2069   progress info i
+00005410: 7320 6f75 7470 7574 2e0a 2020 2020 2020  s output..      
+00005420: 2020 3a72 7479 7065 3a20 4e65 7477 6f72    :rtype: Networ
+00005430: 6b20 6f62 6a65 6374 0a20 2020 2020 2020  k object.       
+00005440: 203a 7265 7475 726e 3a20 3a63 6c61 7373   :return: :class
+00005450: 3a60 4e65 7477 6f72 6b60 2069 6e73 7461  :`Network` insta
+00005460: 6e63 652e 0a20 2020 2020 2020 2022 2222  nce..        """
+00005470: 0a20 2020 2020 2020 2023 2020 4c6f 6164  .        #  Load
+00005480: 2074 6f20 6967 7261 7068 2047 7261 7068   to igraph Graph
+00005490: 206f 626a 6563 740a 2020 2020 2020 2020   object.        
+000054a0: 6772 6170 6820 3d20 6967 7261 7068 2e47  graph = igraph.G
+000054b0: 7261 7068 2e52 6561 6428 663d 6669 6c65  raph.Read(f=file
+000054c0: 6e61 6d65 2c20 666f 726d 6174 3d66 696c  name, format=fil
+000054d0: 6566 6f72 6d61 742c 202a 6172 6773 2c20  eformat, *args, 
+000054e0: 2a2a 6b77 6473 290a 2020 2020 2020 2020  **kwds).        
+000054f0: 7265 7475 726e 204e 6574 776f 726b 2e46  return Network.F
+00005500: 726f 6d49 4772 6170 6828 6772 6170 683d  romIGraph(graph=
+00005510: 6772 6170 682c 2073 696c 656e 6365 5f6c  graph, silence_l
+00005520: 6576 656c 3d73 696c 656e 6365 5f6c 6576  evel=silence_lev
+00005530: 656c 290a 0a20 2020 2023 0a20 2020 2023  el)..    #.    #
+00005540: 2020 4772 6170 6820 6765 6e65 7261 7469    Graph generati
+00005550: 6f6e 206d 6574 686f 6473 0a20 2020 2023  on methods.    #
+00005560: 0a0a 2020 2020 4073 7461 7469 636d 6574  ..    @staticmet
+00005570: 686f 640a 2020 2020 6465 6620 4672 6f6d  hod.    def From
+00005580: 4947 7261 7068 2867 7261 7068 2c20 7369  IGraph(graph, si
+00005590: 6c65 6e63 655f 6c65 7665 6c3d 3029 3a0a  lence_level=0):.
+000055a0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000055b0: 2020 2020 5265 7475 726e 2061 203a 636c      Return a :cl
+000055c0: 6173 733a 604e 6574 776f 726b 6020 6f62  ass:`Network` ob
+000055d0: 6a65 6374 2067 6976 656e 2061 6e20 6967  ject given an ig
+000055e0: 7261 7068 2047 7261 7068 206f 626a 6563  raph Graph objec
+000055f0: 742e 0a0a 2020 2020 2020 2020 3a74 7970  t...        :typ
+00005600: 6520 6772 6170 683a 2069 6772 6170 6820  e graph: igraph 
+00005610: 4772 6170 6820 6f62 6a65 6374 0a20 2020  Graph object.   
+00005620: 2020 2020 203a 6172 6720 6772 6170 683a       :arg graph:
+00005630: 2054 6865 2069 6772 6170 6820 4772 6170   The igraph Grap
+00005640: 6820 6f62 6a65 6374 2074 6f20 6265 2063  h object to be c
+00005650: 6f6e 7665 7274 6564 2e0a 0a20 2020 2020  onverted...     
+00005660: 2020 203a 7479 7065 2073 696c 656e 6365     :type silence
+00005670: 5f6c 6576 656c 3a20 696e 7420 3e3d 2030  _level: int >= 0
+00005680: 0a20 2020 2020 2020 203a 6172 6720 2073  .        :arg  s
+00005690: 696c 656e 6365 5f6c 6576 656c 3a20 5468  ilence_level: Th
+000056a0: 6520 6869 6768 6572 2c20 7468 6520 6c65  e higher, the le
+000056b0: 7373 2070 726f 6772 6573 7320 696e 666f  ss progress info
+000056c0: 2069 7320 6f75 7470 7574 2e0a 0a20 2020   is output...   
+000056d0: 2020 2020 203a 7274 7970 653a 203a 636c       :rtype: :cl
+000056e0: 6173 733a 604e 6574 776f 726b 6020 696e  ass:`Network` in
+000056f0: 7374 616e 6365 0a20 2020 2020 2020 203a  stance.        :
+00005700: 7265 7475 726e 3a20 3a63 6c61 7373 3a60  return: :class:`
+00005710: 4e65 7477 6f72 6b60 206f 626a 6563 742e  Network` object.
+00005720: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00005730: 2020 2020 2023 2020 4765 7420 6e75 6d62       #  Get numb
+00005740: 6572 206f 6620 6e6f 6465 730a 2020 2020  er of nodes.    
+00005750: 2020 2020 4e20 3d20 6c65 6e28 6772 6170      N = len(grap
+00005760: 682e 7673 290a 0a20 2020 2020 2020 2023  h.vs)..        #
+00005770: 2020 4765 7420 6469 7265 6374 6564 6e65    Get directedne
+00005780: 7373 0a20 2020 2020 2020 2064 6972 6563  ss.        direc
+00005790: 7465 6420 3d20 6772 6170 682e 6973 5f64  ted = graph.is_d
+000057a0: 6972 6563 7465 6428 290a 0a20 2020 2020  irected()..     
+000057b0: 2020 2023 2020 4578 7472 6163 7420 6564     #  Extract ed
+000057c0: 6765 206c 6973 740a 2020 2020 2020 2020  ge list.        
+000057d0: 6564 6765 7320 3d20 6e70 2e61 7272 6179  edges = np.array
+000057e0: 2867 7261 7068 2e67 6574 5f65 6467 656c  (graph.get_edgel
+000057f0: 6973 7428 2929 0a0a 2020 2020 2020 2020  ist())..        
+00005800: 2320 2053 796d 6d65 7472 697a 6520 6966  #  Symmetrize if
+00005810: 2075 6e64 6972 6563 7465 6420 6e65 7477   undirected netw
+00005820: 6f72 6b0a 2020 2020 2020 2020 6966 206e  ork.        if n
+00005830: 6f74 2064 6972 6563 7465 643a 0a20 2020  ot directed:.   
+00005840: 2020 2020 2020 2020 2065 6467 6573 203d           edges =
+00005850: 206e 702e 6170 7065 6e64 2865 6467 6573   np.append(edges
+00005860: 2c20 6564 6765 735b 3a2c 205b 312c 2030  , edges[:, [1, 0
+00005870: 5d5d 2c20 6178 6973 3d30 290a 0a20 2020  ]], axis=0)..   
+00005880: 2020 2020 2023 2020 4372 6561 7465 2073       #  Create s
+00005890: 7061 7273 6520 6164 6a61 6365 6e63 7920  parse adjacency 
+000058a0: 6d61 7472 6978 2066 726f 6d20 6564 6765  matrix from edge
+000058b0: 206c 6973 740a 2020 2020 2020 2020 7370   list.        sp
+000058c0: 5f41 203d 2073 702e 636f 6f5f 6d61 7472  _A = sp.coo_matr
+000058d0: 6978 280a 2020 2020 2020 2020 2020 2020  ix(.            
+000058e0: 286e 702e 6f6e 6573 5f6c 696b 6528 6564  (np.ones_like(ed
+000058f0: 6765 732e 545b 305d 292c 2074 7570 6c65  ges.T[0]), tuple
+00005900: 2865 6467 6573 2e54 2929 2c20 7368 6170  (edges.T)), shap
+00005910: 653d 284e 2c20 4e29 290a 0a20 2020 2020  e=(N, N))..     
+00005920: 2020 2023 2020 4578 7472 6163 7420 6e6f     #  Extract no
+00005930: 6465 2077 6569 6768 7473 0a20 2020 2020  de weights.     
+00005940: 2020 2069 6620 226e 6f64 655f 7765 6967     if "node_weig
+00005950: 6874 5f6e 7369 2220 696e 2067 7261 7068  ht_nsi" in graph
+00005960: 2e76 732e 6174 7472 6962 7574 655f 6e61  .vs.attribute_na
+00005970: 6d65 7328 293a 0a20 2020 2020 2020 2020  mes():.         
+00005980: 2020 206e 6f64 655f 7765 6967 6874 7320     node_weights 
+00005990: 3d20 6e70 2e61 7272 6179 280a 2020 2020  = np.array(.    
+000059a0: 2020 2020 2020 2020 2020 2020 6772 6170              grap
+000059b0: 682e 7673 2e67 6574 5f61 7474 7269 6275  h.vs.get_attribu
+000059c0: 7465 5f76 616c 7565 7328 226e 6f64 655f  te_values("node_
+000059d0: 7765 6967 6874 5f6e 7369 2229 290a 2020  weight_nsi")).  
+000059e0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000059f0: 2020 2020 2020 2020 6e6f 6465 5f77 6569          node_wei
+00005a00: 6768 7473 203d 204e 6f6e 650a 0a20 2020  ghts = None..   
+00005a10: 2020 2020 206e 6574 203d 204e 6574 776f       net = Netwo
+00005a20: 726b 2861 646a 6163 656e 6379 3d73 705f  rk(adjacency=sp_
+00005a30: 412c 2064 6972 6563 7465 643d 6469 7265  A, directed=dire
+00005a40: 6374 6564 2c0a 2020 2020 2020 2020 2020  cted,.          
+00005a50: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
+00005a60: 5f77 6569 6768 7473 3d6e 6f64 655f 7765  _weights=node_we
+00005a70: 6967 6874 732c 2073 696c 656e 6365 5f6c  ights, silence_l
+00005a80: 6576 656c 3d73 696c 656e 6365 5f6c 6576  evel=silence_lev
+00005a90: 656c 290a 0a20 2020 2020 2020 2023 2020  el)..        #  
+00005aa0: 4f76 6572 7772 6974 6520 6967 7261 7068  Overwrite igraph
+00005ab0: 2047 7261 7068 206f 626a 6563 7420 696e   Graph object in
+00005ac0: 204e 6574 776f 726b 2069 6e73 7461 6e63   Network instanc
+00005ad0: 6520 746f 2072 6573 746f 7265 206c 696e  e to restore lin
+00005ae0: 6b0a 2020 2020 2020 2020 2320 2061 7474  k.        #  att
+00005af0: 7269 6275 7465 732f 7765 6967 6874 730a  ributes/weights.
+00005b00: 2020 2020 2020 2020 6e65 742e 6772 6170          net.grap
+00005b10: 6820 3d20 6772 6170 680a 2020 2020 2020  h = graph.      
+00005b20: 2020 2320 2069 6e76 616c 6964 6174 6520    #  invalidate 
+00005b30: 6361 6368 650a 2020 2020 2020 2020 6e65  cache.        ne
+00005b40: 742e 5f6d 7574 5f6c 6120 2b3d 2031 0a20  t._mut_la += 1. 
+00005b50: 2020 2020 2020 2072 6574 7572 6e20 6e65         return ne
+00005b60: 740a 0a20 2020 2040 7374 6174 6963 6d65  t..    @staticme
+00005b70: 7468 6f64 0a20 2020 2064 6566 2053 6d61  thod.    def Sma
+00005b80: 6c6c 5465 7374 4e65 7477 6f72 6b28 293a  llTestNetwork():
+00005b90: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00005ba0: 2020 2020 2052 6574 7572 6e20 6120 362d       Return a 6-
+00005bb0: 6e6f 6465 2075 6e64 6972 6563 7465 6420  node undirected 
+00005bc0: 7465 7374 206e 6574 776f 726b 2077 6974  test network wit
+00005bd0: 6820 6e6f 6465 2077 6569 6768 7473 2e0a  h node weights..
+00005be0: 0a20 2020 2020 2020 2054 6865 206e 6574  .        The net
+00005bf0: 776f 726b 206c 6f6f 6b73 206c 696b 6520  work looks like 
+00005c00: 7468 6973 3a3a 0a0a 2020 2020 2020 2020  this::..        
+00005c10: 2020 2020 2020 2020 3320 2d20 310a 2020          3 - 1.  
+00005c20: 2020 2020 2020 2020 2020 2020 2020 7c20                | 
+00005c30: 2020 7c20 5c5c 0a20 2020 2020 2020 2020    | \\.         
+00005c40: 2020 2035 202d 2030 202d 2034 202d 2032     5 - 0 - 4 - 2
+00005c50: 0a0a 2020 2020 2020 2020 5468 6520 6e6f  ..        The no
+00005c60: 6465 2077 6569 6768 7473 2061 7265 205b  de weights are [
+00005c70: 312e 352c 2031 2e37 2c20 312e 392c 2032  1.5, 1.7, 1.9, 2
+00005c80: 2e31 2c20 322e 332c 2032 2e35 5d2c 0a20  .1, 2.3, 2.5],. 
+00005c90: 2020 2020 2020 2061 2074 7970 6963 616c         a typical
+00005ca0: 206e 6f64 6520 7765 6967 6874 2066 6f72   node weight for
+00005cb0: 2063 6f72 7265 6374 6564 206e 2e73 2e69   corrected n.s.i
+00005cc0: 2e20 6d65 6173 7572 6573 2077 6f75 6c64  . measures would
+00005cd0: 2062 6520 322e 302e 0a0a 2020 2020 2020   be 2.0...      
+00005ce0: 2020 3a72 7479 7065 3a20 3a63 6c61 7373    :rtype: :class
+00005cf0: 3a60 4e65 7477 6f72 6b60 2069 6e73 7461  :`Network` insta
+00005d00: 6e63 650a 2020 2020 2020 2020 3a72 6574  nce.        :ret
+00005d10: 7572 6e3a 203a 636c 6173 733a 604e 6574  urn: :class:`Net
+00005d20: 776f 726b 6020 6f62 6a65 6374 2e0a 2020  work` object..  
+00005d30: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00005d40: 2020 6e77 203d 204e 6574 776f 726b 2861    nw = Network(a
+00005d50: 646a 6163 656e 6379 3d5b 5b30 2c20 302c  djacency=[[0, 0,
+00005d60: 2030 2c20 312c 2031 2c20 315d 2c20 5b30   0, 1, 1, 1], [0
+00005d70: 2c20 302c 2031 2c20 312c 2031 2c20 305d  , 0, 1, 1, 1, 0]
+00005d80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00005d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005da0: 2020 5b30 2c20 312c 2030 2c20 302c 2031    [0, 1, 0, 0, 1
+00005db0: 2c20 305d 2c20 5b31 2c20 312c 2030 2c20  , 0], [1, 1, 0, 
+00005dc0: 302c 2030 2c20 305d 2c0a 2020 2020 2020  0, 0, 0],.      
+00005dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005de0: 2020 2020 2020 2020 2020 5b31 2c20 312c            [1, 1,
+00005df0: 2031 2c20 302c 2030 2c20 305d 2c20 5b31   1, 0, 0, 0], [1
+00005e00: 2c20 302c 2030 2c20 302c 2030 2c20 305d  , 0, 0, 0, 0, 0]
+00005e10: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00005e20: 2020 2020 2020 2020 6469 7265 6374 6564          directed
+00005e30: 3d46 616c 7365 2c0a 2020 2020 2020 2020  =False,.        
+00005e40: 2020 2020 2020 2020 2020 2020 206e 6f64               nod
+00005e50: 655f 7765 6967 6874 733d 5b31 2e35 2c20  e_weights=[1.5, 
+00005e60: 312e 372c 2031 2e39 2c20 322e 312c 2032  1.7, 1.9, 2.1, 2
+00005e70: 2e33 2c20 322e 355d 2c0a 2020 2020 2020  .3, 2.5],.      
+00005e80: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00005e90: 696c 656e 6365 5f6c 6576 656c 3d31 290a  ilence_level=1).
+00005ea0: 2020 2020 2020 2020 6c69 6e6b 5f77 6569          link_wei
+00005eb0: 6768 7473 203d 206e 702e 6172 7261 7928  ghts = np.array(
+00005ec0: 5b5b 302c 2030 2c20 302c 2031 2e33 2c20  [[0, 0, 0, 1.3, 
+00005ed0: 322e 352c 2031 2e31 5d2c 0a20 2020 2020  2.5, 1.1],.     
+00005ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005ef0: 2020 2020 2020 2020 2020 2020 5b30 2c20              [0, 
+00005f00: 302c 2032 2e33 2c20 322e 392c 2032 2e37  0, 2.3, 2.9, 2.7
+00005f10: 2c20 305d 2c0a 2020 2020 2020 2020 2020  , 0],.          
+00005f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f30: 2020 2020 2020 205b 302c 2032 2e33 2c20         [0, 2.3, 
+00005f40: 302c 2030 2c20 312e 352c 2030 5d2c 0a20  0, 0, 1.5, 0],. 
+00005f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f70: 5b31 2e33 2c20 322e 392c 2030 2c20 302c  [1.3, 2.9, 0, 0,
+00005f80: 2030 2c20 305d 2c0a 2020 2020 2020 2020   0, 0],.        
+00005f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005fa0: 2020 2020 2020 2020 205b 322e 352c 2032           [2.5, 2
+00005fb0: 2e37 2c20 312e 352c 2030 2c20 302c 2030  .7, 1.5, 0, 0, 0
+00005fc0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+00005fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005fe0: 2020 2020 5b31 2e31 2c20 302c 2030 2c20      [1.1, 0, 0, 
+00005ff0: 302c 2030 2c20 305d 5d29 0a20 2020 2020  0, 0, 0]]).     
+00006000: 2020 206e 772e 7365 745f 6c69 6e6b 5f61     nw.set_link_a
+00006010: 7474 7269 6275 7465 2822 6c69 6e6b 5f77  ttribute("link_w
+00006020: 6569 6768 7473 222c 206c 696e 6b5f 7765  eights", link_we
+00006030: 6967 6874 7329 0a20 2020 2020 2020 2072  ights).        r
+00006040: 6574 7572 6e20 6e77 0a0a 2020 2020 4073  eturn nw..    @s
+00006050: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+00006060: 6465 6620 536d 616c 6c44 6972 6563 7465  def SmallDirecte
+00006070: 6454 6573 744e 6574 776f 726b 2829 3a0a  dTestNetwork():.
+00006080: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00006090: 2020 2020 5265 7475 726e 2061 2036 2d6e      Return a 6-n
+000060a0: 6f64 6520 6469 7265 6374 6564 2074 6573  ode directed tes
+000060b0: 7420 6e65 7477 6f72 6b20 7769 7468 206e  t network with n
+000060c0: 6f64 6520 616e 6420 6564 6765 2077 6569  ode and edge wei
+000060d0: 6768 7473 2e0a 0a20 2020 2020 2020 2054  ghts...        T
+000060e0: 6865 206e 6f64 6520 7765 6967 6874 7320  he node weights 
+000060f0: 6172 6520 5b31 2e35 2c20 312e 372c 2031  are [1.5, 1.7, 1
+00006100: 2e39 2c20 322e 312c 2032 2e33 2c20 322e  .9, 2.1, 2.3, 2.
+00006110: 355d 2c0a 2020 2020 2020 2020 6120 7479  5],.        a ty
+00006120: 7069 6361 6c20 6e6f 6465 2077 6569 6768  pical node weigh
+00006130: 7420 666f 7220 636f 7272 6563 7465 6420  t for corrected 
+00006140: 6e2e 732e 692e 206d 6561 7375 7265 7320  n.s.i. measures 
+00006150: 776f 756c 6420 6265 2032 2e30 2e0a 0a20  would be 2.0... 
+00006160: 2020 2020 2020 203a 7274 7970 653a 203a         :rtype: :
+00006170: 636c 6173 733a 604e 6574 776f 726b 6020  class:`Network` 
+00006180: 696e 7374 616e 6365 0a20 2020 2020 2020  instance.       
+00006190: 203a 7265 7475 726e 3a20 3a63 6c61 7373   :return: :class
+000061a0: 3a60 4e65 7477 6f72 6b60 206f 626a 6563  :`Network` objec
+000061b0: 742e 0a20 2020 2020 2020 2022 2222 0a20  t..        """. 
+000061c0: 2020 2020 2020 206e 7720 3d20 4e65 7477         nw = Netw
+000061d0: 6f72 6b28 6164 6a61 6365 6e63 793d 5b5b  ork(adjacency=[[
+000061e0: 302c 2031 2c20 302c 2031 2c20 302c 2030  0, 1, 0, 1, 0, 0
+000061f0: 5d2c 205b 302c 2030 2c20 312c 2030 2c20  ], [0, 0, 1, 0, 
+00006200: 312c 2030 5d2c 0a20 2020 2020 2020 2020  1, 0],.         
+00006210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006220: 2020 2020 2020 205b 302c 2030 2c20 302c         [0, 0, 0,
+00006230: 2030 2c20 302c 2030 5d2c 205b 302c 2031   0, 0, 0], [0, 1
+00006240: 2c20 302c 2030 2c20 302c 2030 5d2c 0a20  , 0, 0, 0, 0],. 
+00006250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006260: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+00006270: 312c 2030 2c20 312c 2030 2c20 302c 2030  1, 0, 1, 0, 0, 0
+00006280: 5d2c 205b 312c 2030 2c20 302c 2030 2c20  ], [1, 0, 0, 0, 
+00006290: 302c 2030 5d5d 2c0a 2020 2020 2020 2020  0, 0]],.        
+000062a0: 2020 2020 2020 2020 2020 2020 2064 6972               dir
+000062b0: 6563 7465 643d 5472 7565 2c0a 2020 2020  ected=True,.    
+000062c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000062d0: 206e 6f64 655f 7765 6967 6874 733d 5b31   node_weights=[1
+000062e0: 2e35 2c20 312e 372c 2031 2e39 2c20 322e  .5, 1.7, 1.9, 2.
+000062f0: 312c 2032 2e33 2c20 322e 355d 2c0a 2020  1, 2.3, 2.5],.  
+00006300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006310: 2020 2073 696c 656e 6365 5f6c 6576 656c     silence_level
+00006320: 3d31 290a 2020 2020 2020 2020 6e77 2e73  =1).        nw.s
+00006330: 6574 5f6c 696e 6b5f 6174 7472 6962 7574  et_link_attribut
+00006340: 6528 226c 696e 6b5f 7765 6967 6874 7322  e("link_weights"
+00006350: 2c20 6e70 2e61 7272 6179 285b 5b30 2c20  , np.array([[0, 
+00006360: 312e 332c 2030 2c20 322e 352c 2030 2c20  1.3, 0, 2.5, 0, 
+00006370: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+00006380: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00006390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000063a0: 2020 2020 2020 2020 2020 2020 2020 205b                 [
-000063b0: 312e 312c 2030 2c20 302c 2030 2c20 302c  1.1, 0, 0, 0, 0,
-000063c0: 2030 5d5d 290a 2020 2020 2020 2020 6e77   0]]).        nw
-000063d0: 2e73 6574 5f6c 696e 6b5f 6174 7472 6962  .set_link_attrib
-000063e0: 7574 6528 226c 696e 6b5f 7765 6967 6874  ute("link_weight
-000063f0: 7322 2c20 6c69 6e6b 5f77 6569 6768 7473  s", link_weights
-00006400: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00006410: 206e 770a 0a20 2020 2040 7374 6174 6963   nw..    @static
-00006420: 6d65 7468 6f64 0a20 2020 2064 6566 2053  method.    def S
-00006430: 6d61 6c6c 4469 7265 6374 6564 5465 7374  mallDirectedTest
-00006440: 4e65 7477 6f72 6b28 293a 0a20 2020 2020  Network():.     
-00006450: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
-00006460: 6574 7572 6e20 6120 362d 6e6f 6465 2064  eturn a 6-node d
-00006470: 6972 6563 7465 6420 7465 7374 206e 6574  irected test net
-00006480: 776f 726b 2077 6974 6820 6e6f 6465 2061  work with node a
-00006490: 6e64 2065 6467 6520 7765 6967 6874 732e  nd edge weights.
-000064a0: 0a0a 2020 2020 2020 2020 5468 6520 6e6f  ..        The no
-000064b0: 6465 2077 6569 6768 7473 2061 7265 205b  de weights are [
-000064c0: 312e 352c 2031 2e37 2c20 312e 392c 2032  1.5, 1.7, 1.9, 2
-000064d0: 2e31 2c20 322e 332c 2032 2e35 5d2c 0a20  .1, 2.3, 2.5],. 
-000064e0: 2020 2020 2020 2061 2074 7970 6963 616c         a typical
-000064f0: 206e 6f64 6520 7765 6967 6874 2066 6f72   node weight for
-00006500: 2063 6f72 7265 6374 6564 206e 2e73 2e69   corrected n.s.i
-00006510: 2e20 6d65 6173 7572 6573 2077 6f75 6c64  . measures would
-00006520: 2062 6520 322e 302e 0a0a 2020 2020 2020   be 2.0...      
-00006530: 2020 3a72 7479 7065 3a20 4e65 7477 6f72    :rtype: Networ
-00006540: 6b20 696e 7374 616e 6365 0a20 2020 2020  k instance.     
-00006550: 2020 2022 2222 0a20 2020 2020 2020 206e     """.        n
-00006560: 7720 3d20 4e65 7477 6f72 6b28 6164 6a61  w = Network(adja
-00006570: 6365 6e63 793d 5b5b 302c 2031 2c20 302c  cency=[[0, 1, 0,
-00006580: 2031 2c20 302c 2030 5d2c 205b 302c 2030   1, 0, 0], [0, 0
-00006590: 2c20 312c 2030 2c20 312c 2030 5d2c 0a20  , 1, 0, 1, 0],. 
-000065a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000065b0: 2020 2020 2020 2020 2020 2020 2020 205b                 [
-000065c0: 302c 2030 2c20 302c 2030 2c20 302c 2030  0, 0, 0, 0, 0, 0
-000065d0: 5d2c 205b 302c 2031 2c20 302c 2030 2c20  ], [0, 1, 0, 0, 
-000065e0: 302c 2030 5d2c 0a20 2020 2020 2020 2020  0, 0],.         
-000065f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006600: 2020 2020 2020 205b 312c 2030 2c20 312c         [1, 0, 1,
-00006610: 2030 2c20 302c 2030 5d2c 205b 312c 2030   0, 0, 0], [1, 0
-00006620: 2c20 302c 2030 2c20 302c 2030 5d5d 2c0a  , 0, 0, 0, 0]],.
-00006630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006640: 2020 2020 2064 6972 6563 7465 643d 5472       directed=Tr
-00006650: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
-00006660: 2020 2020 2020 2020 206e 6f64 655f 7765           node_we
-00006670: 6967 6874 733d 5b31 2e35 2c20 312e 372c  ights=[1.5, 1.7,
-00006680: 2031 2e39 2c20 322e 312c 2032 2e33 2c20   1.9, 2.1, 2.3, 
-00006690: 322e 355d 2c0a 2020 2020 2020 2020 2020  2.5],.          
-000066a0: 2020 2020 2020 2020 2020 2073 696c 656e             silen
-000066b0: 6365 5f6c 6576 656c 3d31 290a 2020 2020  ce_level=1).    
-000066c0: 2020 2020 6e77 2e73 6574 5f6c 696e 6b5f      nw.set_link_
-000066d0: 6174 7472 6962 7574 6528 226c 696e 6b5f  attribute("link_
-000066e0: 7765 6967 6874 7322 2c20 6e70 2e61 7272  weights", np.arr
-000066f0: 6179 285b 5b30 2c20 312e 332c 2030 2c20  ay([[0, 1.3, 0, 
-00006700: 322e 352c 2030 2c20 305d 2c0a 2020 2020  2.5, 0, 0],.    
-00006710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006740: 2020 2020 5b30 2c20 302c 2031 2e39 2c20      [0, 0, 1.9, 
-00006750: 302c 2031 2e30 2c20 305d 2c0a 2020 2020  0, 1.0, 0],.    
-00006760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006790: 2020 2020 5b30 2c20 302c 2030 2c20 302c      [0, 0, 0, 0,
-000067a0: 2030 2c20 305d 2c0a 2020 2020 2020 2020   0, 0],.        
-000067b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067e0: 5b30 2c20 332e 302c 2030 2c20 302c 2030  [0, 3.0, 0, 0, 0
-000067f0: 2c20 305d 2c0a 2020 2020 2020 2020 2020  , 0],.          
-00006800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006820: 2020 2020 2020 2020 2020 2020 2020 5b32                [2
-00006830: 2e31 2c20 302c 2032 2e37 2c20 302c 2030  .1, 0, 2.7, 0, 0
-00006840: 2c20 305d 2c0a 2020 2020 2020 2020 2020  , 0],.          
-00006850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006870: 2020 2020 2020 2020 2020 2020 2020 5b31                [1
-00006880: 2e35 2c20 302c 2030 2c20 302c 2030 2c20  .5, 0, 0, 0, 0, 
-00006890: 305d 5d29 290a 2020 2020 2020 2020 7265  0]])).        re
-000068a0: 7475 726e 206e 770a 0a20 2020 2040 7374  turn nw..    @st
-000068b0: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
-000068c0: 6566 2045 7264 6f73 5265 6e79 6928 6e5f  ef ErdosRenyi(n_
-000068d0: 6e6f 6465 733d 3130 302c 206c 696e 6b5f  nodes=100, link_
-000068e0: 7072 6f62 6162 696c 6974 793d 4e6f 6e65  probability=None
-000068f0: 2c20 6e5f 6c69 6e6b 733d 4e6f 6e65 2c0a  , n_links=None,.
-00006900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006910: 2020 2073 696c 656e 6365 5f6c 6576 656c     silence_level
-00006920: 3d30 293a 0a20 2020 2020 2020 2022 2222  =0):.        """
-00006930: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
-00006940: 6120 6e65 7720 756e 6469 7265 6374 6564  a new undirected
-00006950: 2045 7264 6f73 2d52 656e 7969 2072 616e   Erdos-Renyi ran
-00006960: 646f 6d20 6772 6170 680a 2020 2020 2020  dom graph.      
-00006970: 2020 7769 7468 2061 2067 6976 656e 206e    with a given n
-00006980: 756d 6265 7220 6f66 206e 6f64 6573 2061  umber of nodes a
-00006990: 6e64 206c 696e 6b69 6e67 2070 726f 6261  nd linking proba
-000069a0: 6269 6c69 7479 2e0a 0a20 2020 2020 2020  bility...       
-000069b0: 2054 6865 2065 7870 6563 7465 6420 6c69   The expected li
-000069c0: 6e6b 2064 656e 7369 7479 2065 7175 616c  nk density equal
-000069d0: 7320 7468 6973 2070 726f 6261 6269 6c69  s this probabili
-000069e0: 7479 2e0a 0a20 2020 2020 2020 202a 2a45  ty...        **E
-000069f0: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
-00006a00: 2020 203e 3e3e 2070 7269 6e74 284e 6574     >>> print(Net
-00006a10: 776f 726b 2e45 7264 6f73 5265 6e79 6928  work.ErdosRenyi(
-00006a20: 6e5f 6e6f 6465 733d 3130 2c20 6e5f 6c69  n_nodes=10, n_li
-00006a30: 6e6b 733d 3138 2929 0a20 2020 2020 2020  nks=18)).       
-00006a40: 2047 656e 6572 6174 696e 6720 4572 646f   Generating Erdo
-00006a50: 732d 5265 6e79 6920 7261 6e64 6f6d 2067  s-Renyi random g
-00006a60: 7261 7068 2077 6974 6820 3130 206e 6f64  raph with 10 nod
-00006a70: 6573 2061 6e64 2031 3820 6c69 6e6b 732e  es and 18 links.
-00006a80: 2e2e 0a20 2020 2020 2020 204e 6574 776f  ...        Netwo
-00006a90: 726b 3a20 756e 6469 7265 6374 6564 2c20  rk: undirected, 
-00006aa0: 3130 206e 6f64 6573 2c20 3138 206c 696e  10 nodes, 18 lin
-00006ab0: 6b73 2c20 6c69 6e6b 2064 656e 7369 7479  ks, link density
-00006ac0: 2030 2e34 3030 2e0a 0a20 2020 2020 2020   0.400...       
-00006ad0: 203a 7479 7065 206e 5f6e 6f64 6573 3a20   :type n_nodes: 
-00006ae0: 696e 7420 3e20 300a 2020 2020 2020 2020  int > 0.        
-00006af0: 3a61 7267 2020 6e5f 6e6f 6465 733a 204e  :arg  n_nodes: N
-00006b00: 756d 6265 7220 6f66 206e 6f64 6573 2e20  umber of nodes. 
-00006b10: 2844 6566 6175 6c74 3a20 3130 3029 0a0a  (Default: 100)..
-00006b20: 2020 2020 2020 2020 3a74 7970 6520 6c69          :type li
-00006b30: 6e6b 5f70 726f 6261 6269 6c69 7479 3a20  nk_probability: 
-00006b40: 666c 6f61 7420 6672 6f6d 2030 2074 6f20  float from 0 to 
-00006b50: 312c 206f 7220 4e6f 6e65 0a20 2020 2020  1, or None.     
-00006b60: 2020 203a 6172 6720 206c 696e 6b5f 7072     :arg  link_pr
-00006b70: 6f62 6162 696c 6974 793a 2049 6620 6e6f  obability: If no
-00006b80: 7420 4e6f 6e65 2c20 6561 6368 2070 6169  t None, each pai
-00006b90: 7220 6f66 206e 6f64 6573 2069 730a 2020  r of nodes is.  
-00006ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006bb0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-00006bc0: 6465 7065 6e64 656e 746c 7920 6c69 6e6b  dependently link
-00006bd0: 6564 2077 6974 6820 7468 6973 2070 726f  ed with this pro
-00006be0: 6261 6269 6c69 7479 2e0a 2020 2020 2020  bability..      
-00006bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c00: 2020 2020 2020 2020 2020 2844 6566 6175            (Defau
-00006c10: 6c74 3a20 4e6f 6e65 290a 0a20 2020 2020  lt: None)..     
-00006c20: 2020 203a 7479 7065 206e 5f6c 696e 6b73     :type n_links
-00006c30: 3a20 696e 7420 3e20 302c 206f 7220 4e6f  : int > 0, or No
-00006c40: 6e65 0a20 2020 2020 2020 203a 6172 6720  ne.        :arg 
-00006c50: 206e 5f6c 696e 6b73 3a20 4966 206e 6f74   n_links: If not
-00006c60: 204e 6f6e 652c 2074 6869 7320 6d61 6e79   None, this many
-00006c70: 206c 696e 6b73 2061 7265 2061 7373 6967   links are assig
-00006c80: 6e65 6420 6174 2072 616e 646f 6d2e 0a20  ned at random.. 
-00006c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ca0: 2020 2020 2020 4d75 7374 2062 6520 4e6f        Must be No
-00006cb0: 6e65 2069 6620 6c69 6e6b 5f70 726f 6261  ne if link_proba
-00006cc0: 6269 6c69 7479 2069 7320 6e6f 7420 4e6f  bility is not No
-00006cd0: 6e65 2e0a 2020 2020 2020 2020 2020 2020  ne..            
-00006ce0: 2020 2020 2020 2020 2020 2028 4465 6661             (Defa
-00006cf0: 756c 743a 204e 6f6e 6529 0a0a 2020 2020  ult: None)..    
-00006d00: 2020 2020 3a74 7970 6520 7369 6c65 6e63      :type silenc
-00006d10: 655f 6c65 7665 6c3a 2069 6e74 203e 3d20  e_level: int >= 
-00006d20: 300a 2020 2020 2020 2020 3a61 7267 2020  0.        :arg  
-00006d30: 7369 6c65 6e63 655f 6c65 7665 6c3a 2054  silence_level: T
-00006d40: 6865 2068 6967 6865 722c 2074 6865 206c  he higher, the l
-00006d50: 6573 7320 7072 6f67 7265 7373 2069 6e66  ess progress inf
-00006d60: 6f20 6973 206f 7574 7075 742e 0a0a 2020  o is output...  
-00006d70: 2020 2020 2020 3a72 7479 7065 3a20 3a63        :rtype: :c
-00006d80: 6c61 7373 3a60 4e65 7477 6f72 6b60 2069  lass:`Network` i
-00006d90: 6e73 7461 6e63 650a 2020 2020 2020 2020  nstance.        
-00006da0: 2222 220a 2020 2020 2020 2020 6966 206c  """.        if l
-00006db0: 696e 6b5f 7072 6f62 6162 696c 6974 7920  ink_probability 
-00006dc0: 6973 206e 6f74 204e 6f6e 6520 616e 6420  is not None and 
-00006dd0: 6e5f 6c69 6e6b 7320 6973 204e 6f6e 653a  n_links is None:
-00006de0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00006df0: 7369 6c65 6e63 655f 6c65 7665 6c20 3c20  silence_level < 
-00006e00: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
-00006e10: 2020 2070 7269 6e74 2866 2247 656e 6572     print(f"Gener
-00006e20: 6174 696e 6720 4572 646f 732d 5265 6e79  ating Erdos-Reny
-00006e30: 6920 7261 6e64 6f6d 2067 7261 7068 2077  i random graph w
-00006e40: 6974 6820 220a 2020 2020 2020 2020 2020  ith ".          
-00006e50: 2020 2020 2020 2020 2020 2020 6622 7b6e              f"{n
-00006e60: 5f6e 6f64 6573 7d20 6e6f 6465 7320 616e  _nodes} nodes an
-00006e70: 6420 7072 6f62 6162 696c 6974 7920 7b6c  d probability {l
-00006e80: 696e 6b5f 7072 6f62 6162 696c 6974 797d  ink_probability}
-00006e90: 2e2e 2e22 290a 0a20 2020 2020 2020 2020  ...")..         
-00006ea0: 2020 2067 7261 7068 203d 2069 6772 6170     graph = igrap
-00006eb0: 682e 4772 6170 682e 4572 646f 735f 5265  h.Graph.Erdos_Re
-00006ec0: 6e79 6928 6e3d 6e5f 6e6f 6465 732c 2070  nyi(n=n_nodes, p
-00006ed0: 3d6c 696e 6b5f 7072 6f62 6162 696c 6974  =link_probabilit
-00006ee0: 7929 0a20 2020 2020 2020 2020 2020 2023  y).            #
-00006ef0: 2020 4765 7420 6564 6765 206c 6973 740a    Get edge list.
-00006f00: 2020 2020 2020 2020 2020 2020 6564 6765              edge
-00006f10: 5f6c 6973 7420 3d20 6772 6170 682e 6765  _list = graph.ge
-00006f20: 745f 6564 6765 6c69 7374 2829 0a0a 2020  t_edgelist()..  
-00006f30: 2020 2020 2020 656c 6966 206c 696e 6b5f        elif link_
-00006f40: 7072 6f62 6162 696c 6974 7920 6973 204e  probability is N
-00006f50: 6f6e 6520 616e 6420 6e5f 6c69 6e6b 7320  one and n_links 
-00006f60: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-00006f70: 2020 2020 2020 2020 2069 6620 7369 6c65           if sile
-00006f80: 6e63 655f 6c65 7665 6c20 3c20 313a 0a20  nce_level < 1:. 
-00006f90: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00006fa0: 7269 6e74 2866 2247 656e 6572 6174 696e  rint(f"Generatin
-00006fb0: 6720 4572 646f 732d 5265 6e79 6920 7261  g Erdos-Renyi ra
-00006fc0: 6e64 6f6d 2067 7261 7068 2077 6974 6820  ndom graph with 
-00006fd0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-00006fe0: 2020 2020 2020 2020 6622 7b6e 5f6e 6f64          f"{n_nod
-00006ff0: 6573 7d20 6e6f 6465 7320 616e 6420 7b6e  es} nodes and {n
-00007000: 5f6c 696e 6b73 7d20 6c69 6e6b 732e 2e2e  _links} links...
-00007010: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
-00007020: 6772 6170 6820 3d20 6967 7261 7068 2e47  graph = igraph.G
-00007030: 7261 7068 2e45 7264 6f73 5f52 656e 7969  raph.Erdos_Renyi
-00007040: 286e 3d6e 5f6e 6f64 6573 2c20 6d3d 6e5f  (n=n_nodes, m=n_
-00007050: 6c69 6e6b 7329 0a20 2020 2020 2020 2020  links).         
-00007060: 2020 2023 2020 4765 7420 6564 6765 206c     #  Get edge l
-00007070: 6973 740a 2020 2020 2020 2020 2020 2020  ist.            
-00007080: 6564 6765 5f6c 6973 7420 3d20 6772 6170  edge_list = grap
-00007090: 682e 6765 745f 6564 6765 6c69 7374 2829  h.get_edgelist()
-000070a0: 0a0a 2020 2020 2020 2020 656c 7365 3a0a  ..        else:.
-000070b0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000070c0: 726e 204e 6f6e 650a 0a20 2020 2020 2020  rn None..       
-000070d0: 2072 6574 7572 6e20 4e65 7477 6f72 6b28   return Network(
-000070e0: 6e5f 6e6f 6465 733d 6e5f 6e6f 6465 732c  n_nodes=n_nodes,
-000070f0: 2065 6467 655f 6c69 7374 3d65 6467 655f   edge_list=edge_
-00007100: 6c69 7374 2c20 6469 7265 6374 6564 3d46  list, directed=F
-00007110: 616c 7365 2c0a 2020 2020 2020 2020 2020  alse,.          
-00007120: 2020 2020 2020 2020 2020 2020 2073 696c               sil
-00007130: 656e 6365 5f6c 6576 656c 3d73 696c 656e  ence_level=silen
-00007140: 6365 5f6c 6576 656c 290a 0a20 2020 2040  ce_level)..    @
-00007150: 7374 6174 6963 6d65 7468 6f64 0a20 2020  staticmethod.   
-00007160: 2064 6566 2042 6172 6162 6173 6941 6c62   def BarabasiAlb
-00007170: 6572 745f 6967 7261 7068 286e 5f6e 6f64  ert_igraph(n_nod
-00007180: 6573 3d31 3030 2c20 6e5f 6c69 6e6b 735f  es=100, n_links_
-00007190: 6561 6368 3d35 2c20 7369 6c65 6e63 655f  each=5, silence_
-000071a0: 6c65 7665 6c3d 3029 3a0a 2020 2020 2020  level=0):.      
-000071b0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
-000071c0: 7475 726e 2061 206e 6577 2075 6e64 6972  turn a new undir
-000071d0: 6563 7465 6420 4261 7261 6261 7369 2d41  ected Barabasi-A
-000071e0: 6c62 6572 7420 7261 6e64 6f6d 2067 7261  lbert random gra
-000071f0: 7068 2067 656e 6572 6174 6564 2062 790a  ph generated by.
-00007200: 2020 2020 2020 2020 6967 7261 7068 2e0a          igraph..
-00007210: 0a20 2020 2020 2020 2043 4155 5449 4f4e  .        CAUTION
-00007220: 3a20 6163 7475 616c 206e 6f2e 206f 6620  : actual no. of 
-00007230: 6e65 7720 6c69 6e6b 7320 6361 6e20 6265  new links can be
-00007240: 2073 6d61 6c6c 6572 2074 6861 6e20 6e5f   smaller than n_
-00007250: 6c69 6e6b 735f 6561 6368 0a20 2020 2020  links_each.     
-00007260: 2020 2062 6563 6175 7365 206e 6569 6768     because neigh
-00007270: 626f 7572 7320 6172 6520 6472 6177 6e20  bours are drawn 
-00007280: 7769 7468 2072 6570 6c61 6365 6d65 6e74  with replacement
-00007290: 2061 6e64 2067 7261 7068 2069 7320 7468   and graph is th
-000072a0: 656e 0a20 2020 2020 2020 2073 696d 706c  en.        simpl
-000072b0: 6966 6965 642e 0a0a 2020 2020 2020 2020  ified...        
-000072c0: 5468 6520 6769 7665 6e20 6e75 6d62 6572  The given number
-000072d0: 206f 6620 6e6f 6465 7320 6172 6520 6164   of nodes are ad
-000072e0: 6465 6420 696e 2074 7572 6e20 746f 2074  ded in turn to t
-000072f0: 6865 2069 6e69 7469 616c 6c79 2065 6d70  he initially emp
-00007300: 7479 206e 6f64 650a 2020 2020 2020 2020  ty node.        
-00007310: 7365 742c 2061 6e64 2065 6163 6820 6e65  set, and each ne
-00007320: 7720 6e6f 6465 2069 7320 6c69 6e6b 6564  w node is linked
-00007330: 2074 6f20 7468 6520 6769 7665 6e20 6e75   to the given nu
-00007340: 6d62 6572 206f 6620 6578 6973 7469 6e67  mber of existing
-00007350: 206e 6f64 6573 2e0a 2020 2020 2020 2020   nodes..        
-00007360: 5468 6520 7265 7375 6c74 696e 6720 6c69  The resulting li
-00007370: 6e6b 2064 656e 7369 7479 2069 7320 6170  nk density is ap
-00007380: 7072 6f78 2e20 3220 2a20 6060 6e5f 6c69  prox. 2 * ``n_li
-00007390: 6e6b 735f 6561 6368 6060 2f60 606e 5f6e  nks_each``/``n_n
-000073a0: 6f64 6573 6060 2e0a 0a20 2020 2020 2020  odes``...       
-000073b0: 202a 2a45 7861 6d70 6c65 3a2a 2a20 4765   **Example:** Ge
-000073c0: 6e65 7261 7469 6e67 2061 2072 616e 646f  nerating a rando
-000073d0: 6d20 7472 6565 3a0a 0a20 2020 2020 2020  m tree:..       
-000073e0: 203e 3e3e 206e 6574 203d 204e 6574 776f   >>> net = Netwo
-000073f0: 726b 2e42 6172 6162 6173 6941 6c62 6572  rk.BarabasiAlber
-00007400: 745f 6967 7261 7068 286e 5f6e 6f64 6573  t_igraph(n_nodes
-00007410: 3d31 3030 2c20 6e5f 6c69 6e6b 735f 6561  =100, n_links_ea
-00007420: 6368 3d31 290a 2020 2020 2020 2020 3e3e  ch=1).        >>
-00007430: 3e20 7072 696e 7428 6e65 742e 6c69 6e6b  > print(net.link
-00007440: 5f64 656e 7369 7479 290a 2020 2020 2020  _density).      
-00007450: 2020 302e 3032 0a0a 2020 2020 2020 2020    0.02..        
-00007460: 3a74 7970 6520 6e5f 6e6f 6465 733a 2069  :type n_nodes: i
-00007470: 6e74 203e 2030 0a20 2020 2020 2020 203a  nt > 0.        :
-00007480: 6172 6720 206e 5f6e 6f64 6573 3a20 4e75  arg  n_nodes: Nu
-00007490: 6d62 6572 206f 6620 6e6f 6465 732e 2028  mber of nodes. (
-000074a0: 4465 6661 756c 743a 2031 3030 290a 2020  Default: 100).  
-000074b0: 2020 2020 2020 3a74 7970 6520 6e5f 6c69        :type n_li
-000074c0: 6e6b 735f 6561 6368 3a20 696e 7420 3e20  nks_each: int > 
-000074d0: 300a 2020 2020 2020 2020 3a61 7267 2020  0.        :arg  
-000074e0: 6e5f 6c69 6e6b 735f 6561 6368 3a20 4e75  n_links_each: Nu
-000074f0: 6d62 6572 206f 6620 6c69 6e6b 7320 746f  mber of links to
-00007500: 2065 7869 7374 696e 6720 6e6f 6465 7320   existing nodes 
-00007510: 6561 6368 206e 6577 206e 6f64 650a 2020  each new node.  
-00007520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007530: 2020 2020 2020 2020 2020 6765 7473 2064            gets d
-00007540: 7572 696e 6720 636f 6e73 7472 7563 7469  uring constructi
-00007550: 6f6e 2e20 2844 6566 6175 6c74 3a20 3529  on. (Default: 5)
-00007560: 0a20 2020 2020 2020 203a 7479 7065 2073  .        :type s
-00007570: 696c 656e 6365 5f6c 6576 656c 3a20 696e  ilence_level: in
-00007580: 7420 3e3d 2030 0a20 2020 2020 2020 203a  t >= 0.        :
-00007590: 6172 6720 2073 696c 656e 6365 5f6c 6576  arg  silence_lev
-000075a0: 656c 3a20 5468 6520 6869 6768 6572 2c20  el: The higher, 
-000075b0: 7468 6520 6c65 7373 2070 726f 6772 6573  the less progres
-000075c0: 7320 696e 666f 2069 7320 6f75 7470 7574  s info is output
-000075d0: 2e0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
-000075e0: 3a20 3a63 6c61 7373 3a60 4e65 7477 6f72  : :class:`Networ
-000075f0: 6b60 2069 6e73 7461 6e63 650a 2020 2020  k` instance.    
-00007600: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00007610: 6772 6170 6820 3d20 6967 7261 7068 2e47  graph = igraph.G
-00007620: 7261 7068 2e42 6172 6162 6173 6928 6e3d  raph.Barabasi(n=
-00007630: 6e5f 6e6f 6465 732c 206d 3d6e 5f6c 696e  n_nodes, m=n_lin
-00007640: 6b73 5f65 6163 6829 0a0a 2020 2020 2020  ks_each)..      
-00007650: 2020 2320 5265 6d6f 7665 2073 656c 662d    # Remove self-
-00007660: 6c6f 6f70 7320 616e 6420 6d75 6c74 6970  loops and multip
-00007670: 6c65 206c 696e 6b73 2c20 7468 6973 2064  le links, this d
-00007680: 6f65 7320 6f66 2063 6f75 7273 6520 6368  oes of course ch
-00007690: 616e 6765 2074 6865 0a20 2020 2020 2020  ange the.       
-000076a0: 2023 2061 6374 7561 6c20 6465 6772 6565   # actual degree
-000076b0: 2073 6571 7565 6e63 6520 6f66 2074 6865   sequence of the
-000076c0: 2067 656e 6572 6174 6564 2067 7261 7068   generated graph
-000076d0: 2c20 6275 7420 6a75 7374 2073 6c69 6768  , but just sligh
-000076e0: 746c 790a 2020 2020 2020 2020 6772 6170  tly.        grap
-000076f0: 682e 7369 6d70 6c69 6679 2829 0a20 2020  h.simplify().   
-00007700: 2020 2020 2065 6467 655f 6c69 7374 203d       edge_list =
-00007710: 2067 7261 7068 2e67 6574 5f65 6467 656c   graph.get_edgel
-00007720: 6973 7428 290a 0a20 2020 2020 2020 2072  ist()..        r
-00007730: 6574 7572 6e20 4e65 7477 6f72 6b28 6564  eturn Network(ed
-00007740: 6765 5f6c 6973 743d 6564 6765 5f6c 6973  ge_list=edge_lis
-00007750: 742c 2064 6972 6563 7465 643d 4661 6c73  t, directed=Fals
-00007760: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00007770: 2020 2020 2020 2020 2020 7369 6c65 6e63            silenc
-00007780: 655f 6c65 7665 6c3d 7369 6c65 6e63 655f  e_level=silence_
-00007790: 6c65 7665 6c29 0a0a 2020 2020 4073 7461  level)..    @sta
-000077a0: 7469 636d 6574 686f 640a 2020 2020 6465  ticmethod.    de
-000077b0: 6620 4261 7261 6261 7369 416c 6265 7274  f BarabasiAlbert
-000077c0: 286e 5f6e 6f64 6573 3d31 3030 2c20 6e5f  (n_nodes=100, n_
-000077d0: 6c69 6e6b 735f 6561 6368 3d35 2c20 7369  links_each=5, si
-000077e0: 6c65 6e63 655f 6c65 7665 6c3d 3029 3a0a  lence_level=0):.
-000077f0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00007800: 2020 2020 5265 7475 726e 2061 206e 6577      Return a new
-00007810: 2075 6e64 6972 6563 7465 6420 4261 7261   undirected Bara
-00007820: 6261 7369 2d41 6c62 6572 7420 7261 6e64  basi-Albert rand
-00007830: 6f6d 2067 7261 7068 0a20 2020 2020 2020  om graph.       
-00007840: 2077 6974 6820 6578 6163 746c 7920 6e5f   with exactly n_
-00007850: 6c69 6e6b 735f 6561 6368 202a 2028 6e5f  links_each * (n_
-00007860: 6e6f 6465 732d 6e5f 6c69 6e6b 735f 6561  nodes-n_links_ea
-00007870: 6368 2920 6c69 6e6b 732e 0a0a 2020 2020  ch) links...    
-00007880: 2020 2020 3a74 7970 6520 7369 6c65 6e63      :type silenc
-00007890: 655f 6c65 7665 6c3a 2069 6e74 203e 3d20  e_level: int >= 
-000078a0: 300a 2020 2020 2020 2020 3a61 7267 2020  0.        :arg  
-000078b0: 7369 6c65 6e63 655f 6c65 7665 6c3a 2054  silence_level: T
-000078c0: 6865 2068 6967 6865 722c 2074 6865 206c  he higher, the l
-000078d0: 6573 7320 7072 6f67 7265 7373 2069 6e66  ess progress inf
-000078e0: 6f20 6973 206f 7574 7075 742e 0a20 2020  o is output..   
-000078f0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00007900: 2023 2073 7461 7274 2077 6974 6820 312b   # start with 1+
-00007910: 6d20 6e6f 6465 7320 6f66 2077 6869 6368  m nodes of which
-00007920: 2074 6865 2066 6972 7374 2069 7320 6c69   the first is li
-00007930: 6e6b 6564 2074 6f20 7468 6520 7265 7374  nked to the rest
-00007940: 0a20 2020 2020 2020 204e 2c20 6d20 3d20  .        N, m = 
-00007950: 6e5f 6e6f 6465 732c 206e 5f6c 696e 6b73  n_nodes, n_links
-00007960: 5f65 6163 680a 2020 2020 2020 2020 4120  _each.        A 
-00007970: 3d20 7370 2e6c 696c 5f6d 6174 7269 7828  = sp.lil_matrix(
-00007980: 284e 2c20 4e29 2c20 6474 7970 653d 6e70  (N, N), dtype=np
-00007990: 2e69 6e74 3829 0a20 2020 2020 2020 2041  .int8).        A
-000079a0: 5b30 2c20 313a 312b 6d5d 203d 2031 0a20  [0, 1:1+m] = 1. 
-000079b0: 2020 2020 2020 2041 5b31 3a31 2b6d 2c20         A[1:1+m, 
-000079c0: 305d 203d 2031 0a0a 2020 2020 2020 2020  0] = 1..        
-000079d0: 2320 696e 7665 7273 6520 6375 6d2e 2064  # inverse cum. d
-000079e0: 6567 7265 6520 6469 7374 7269 6275 7469  egree distributi
-000079f0: 6f6e 0a20 2020 2020 2020 2074 6172 6765  on.        targe
-00007a00: 7473 2c20 6c61 7374 5f63 6869 6c64 203d  ts, last_child =
-00007a10: 206e 702e 7a65 726f 7328 322a 6d2a 284e   np.zeros(2*m*(N
-00007a20: 2d6d 292c 2064 7479 7065 3d6e 702e 696e  -m), dtype=np.in
-00007a30: 7438 292c 206e 702e 7a65 726f 7328 4e29  t8), np.zeros(N)
-00007a40: 0a20 2020 2020 2020 2074 6172 6765 7473  .        targets
-00007a50: 5b6d 3a32 2a6d 5d20 3d20 7261 6e67 6528  [m:2*m] = range(
-00007a60: 312c 2031 2b6d 290a 2020 2020 2020 2020  1, 1+m).        
-00007a70: 6e5f 7461 7267 6574 7320 3d20 322a 6d0a  n_targets = 2*m.
-00007a80: 2020 2020 2020 2020 666f 7220 6a20 696e          for j in
-00007a90: 2072 616e 6765 2831 2b6d 2c20 4e29 3a0a   range(1+m, N):.
-00007aa0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00007ab0: 6974 2069 6e20 7261 6e67 6528 6d29 3a0a  it in range(m):.
-00007ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007ad0: 7768 696c 6520 5472 7565 3a0a 2020 2020  while True:.    
-00007ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007af0: 6920 3d20 7461 7267 6574 735b 696e 7428  i = targets[int(
-00007b00: 7261 6e64 6f6d 2e75 6e69 666f 726d 286c  random.uniform(l
-00007b10: 6f77 3d30 2c20 6869 6768 3d6e 5f74 6172  ow=0, high=n_tar
-00007b20: 6765 7473 2929 5d0a 2020 2020 2020 2020  gets))].        
-00007b30: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-00007b40: 6173 745f 6368 696c 645b 695d 2021 3d20  ast_child[i] != 
-00007b50: 6a3a 0a20 2020 2020 2020 2020 2020 2020  j:.             
-00007b60: 2020 2020 2020 2020 2020 2062 7265 616b             break
-00007b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007b80: 2041 5b69 2c20 6a5d 203d 2041 5b6a 2c20   A[i, j] = A[j, 
-00007b90: 695d 203d 2031 0a20 2020 2020 2020 2020  i] = 1.         
-00007ba0: 2020 2020 2020 2074 6172 6765 7473 5b6e         targets[n
-00007bb0: 5f74 6172 6765 7473 202b 2069 745d 203d  _targets + it] =
-00007bc0: 2069 0a20 2020 2020 2020 2020 2020 2020   i.             
-00007bd0: 2020 206c 6173 745f 6368 696c 645b 695d     last_child[i]
-00007be0: 203d 206a 0a20 2020 2020 2020 2020 2020   = j.           
-00007bf0: 2074 6172 6765 7473 5b6e 5f74 6172 6765   targets[n_targe
-00007c00: 7473 202b 206d 3a20 6e5f 7461 7267 6574  ts + m: n_target
-00007c10: 7320 2b20 322a 6d5d 203d 206a 0a20 2020  s + 2*m] = j.   
-00007c20: 2020 2020 2020 2020 206e 5f74 6172 6765           n_targe
-00007c30: 7473 202b 3d20 322a 6d0a 0a20 2020 2020  ts += 2*m..     
-00007c40: 2020 2072 6574 7572 6e20 4e65 7477 6f72     return Networ
-00007c50: 6b28 412c 2073 696c 656e 6365 5f6c 6576  k(A, silence_lev
-00007c60: 656c 3d73 696c 656e 6365 5f6c 6576 656c  el=silence_level
-00007c70: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
-00007c80: 7468 6f64 0a20 2020 2064 6566 2047 726f  thod.    def Gro
-00007c90: 7750 7265 6665 7265 6e74 6961 6c6c 795f  wPreferentially_
-00007ca0: 6f6c 6428 6e5f 6e6f 6465 733d 3130 302c  old(n_nodes=100,
-00007cb0: 206d 3d32 2c20 7369 6c65 6e63 655f 6c65   m=2, silence_le
-00007cc0: 7665 6c3d 3029 3a0a 2020 2020 2020 2020  vel=0):.        
-00007cd0: 2222 220a 2020 2020 2020 2020 4558 5045  """.        EXPE
-00007ce0: 5249 4d45 4e54 414c 3a20 5265 7475 726e  RIMENTAL: Return
-00007cf0: 2061 2072 616e 646f 6d20 6e65 7477 6f72   a random networ
-00007d00: 6b20 6772 6f77 6e20 7769 7468 2070 7265  k grown with pre
-00007d10: 6665 7265 6e74 6961 6c20 7765 6967 6874  ferential weight
-00007d20: 0a20 2020 2020 2020 2069 6e63 7265 6173  .        increas
-00007d30: 6520 616e 6420 7072 6566 6572 656e 7469  e and preferenti
-00007d40: 616c 2061 7474 6163 686d 656e 742e 0a0a  al attachment...
-00007d50: 2020 2020 2020 2020 5265 7475 726e 2061          Return a
-00007d60: 2072 616e 646f 6d20 6e65 7477 6f72 6b20   random network 
-00007d70: 6772 6f77 6e20 6173 2066 6f6c 6c6f 7773  grown as follows
-00007d80: 3a20 5374 6172 7469 6e67 2077 6974 6820  : Starting with 
-00007d90: 6120 636c 6971 7565 0a20 2020 2020 2020  a clique.       
-00007da0: 206f 6620 6d2b 3120 756e 6974 2077 6569   of m+1 unit wei
-00007db0: 6768 7420 6e6f 6465 732c 2069 7465 7261  ght nodes, itera
-00007dc0: 7469 7665 6c79 2061 6464 2061 2075 6e69  tively add a uni
-00007dd0: 7420 7765 6967 6874 206e 6f64 6520 616e  t weight node an
-00007de0: 6420 7468 656e 0a20 2020 2020 2020 206d  d then.        m
-00007df0: 2074 696d 6573 2069 6e63 7265 6173 6520   times increase 
-00007e00: 7468 6520 7765 6967 6874 206f 6620 616e  the weight of an
-00007e10: 2065 7869 7374 696e 6720 6e6f 6465 2062   existing node b
-00007e20: 7920 6f6e 6520 756e 6974 2c20 666f 720a  y one unit, for.
-00007e30: 2020 2020 2020 2020 6e3d 6d2b 322e 2e2e          n=m+2...
-00007e40: 4e2e 2043 686f 6f73 6520 7468 6520 6772  N. Choose the gr
-00007e50: 6f77 696e 6720 6e6f 6465 2077 6974 6820  owing node with 
-00007e60: 7072 6f62 6162 696c 6974 6965 7320 7072  probabilities pr
-00007e70: 6f70 6f72 7469 6f6e 616c 2074 6f0a 2020  oportional to.  
-00007e80: 2020 2020 2020 7468 6520 6e6f 6465 2773        the node's
-00007e90: 2077 6569 6768 742e 2041 6674 6572 2065   weight. After e
-00007ea0: 6163 6820 6e6f 6465 2061 6464 6974 696f  ach node additio
-00007eb0: 6e20 6f72 2077 6569 6768 7420 696e 6372  n or weight incr
-00007ec0: 6561 7365 2c20 6164 6420 6f6e 650a 2020  ease, add one.  
-00007ed0: 2020 2020 2020 6c69 6e6b 2066 726f 6d20        link from 
-00007ee0: 7468 6520 7265 7370 6563 7469 7665 206e  the respective n
-00007ef0: 6f64 6520 746f 2061 6e6f 7468 6572 206e  ode to another n
-00007f00: 6f64 652c 2063 686f 7365 6e20 7769 7468  ode, chosen with
-00007f10: 2070 726f 6261 6269 6c69 7479 0a20 2020   probability.   
-00007f20: 2020 2020 2070 726f 706f 7274 696f 6e61       proportiona
-00007f30: 6c20 746f 2074 6861 7420 6e6f 6465 2773  l to that node's
-00007f40: 206e 2e73 2e69 2e20 6465 6772 6565 2e0a   n.s.i. degree..
-00007f50: 0a20 2020 2020 2020 203a 7479 7065 2073  .        :type s
-00007f60: 696c 656e 6365 5f6c 6576 656c 3a20 696e  ilence_level: in
-00007f70: 7420 3e3d 2030 0a20 2020 2020 2020 203a  t >= 0.        :
-00007f80: 6172 6720 2073 696c 656e 6365 5f6c 6576  arg  silence_lev
-00007f90: 656c 3a20 5468 6520 6869 6768 6572 2c20  el: The higher, 
-00007fa0: 7468 6520 6c65 7373 2070 726f 6772 6573  the less progres
-00007fb0: 7320 696e 666f 2069 7320 6f75 7470 7574  s info is output
-00007fc0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-00007fd0: 2020 2020 2020 4e20 3d20 6e5f 6e6f 6465        N = n_node
-00007fe0: 730a 2020 2020 2020 2020 772c 2041 203d  s.        w, A =
-00007ff0: 206e 702e 7a65 726f 7328 4e2c 2069 6e74   np.zeros(N, int
-00008000: 292c 2073 702e 6c69 6c5f 6d61 7472 6978  ), sp.lil_matrix
-00008010: 2828 4e2c 204e 2929 0a20 2020 2020 2020  ((N, N)).       
-00008020: 206e 6273 203d 205b 5b5d 2066 6f72 2069   nbs = [[] for i
-00008030: 2069 6e20 7261 6e67 6528 4e29 5d0a 0a20   in range(N)].. 
-00008040: 2020 2020 2020 2023 2073 7461 7274 2077         # start w
-00008050: 6974 6820 6d2b 3120 6675 6c6c 7920 636f  ith m+1 fully co
-00008060: 6e6e 6563 7465 6420 6e6f 6465 730a 2020  nnected nodes.  
-00008070: 2020 2020 2020 775b 3a6d 2b31 5d20 3d20        w[:m+1] = 
-00008080: 310a 0a20 2020 2020 2020 2023 2074 6f74  1..        # tot
-00008090: 616c 2077 6569 6768 7420 6e6f 7720 616e  al weight now an
-000080a0: 6420 696e 2074 6865 2065 6e64 0a20 2020  d in the end.   
-000080b0: 2020 2020 206c 6173 745f 5720 3d20 6d2b       last_W = m+
-000080c0: 310a 2020 2020 2020 2020 2320 7468 6973  1.        # this
-000080d0: 2069 7320 616c 736f 2061 7070 726f 782e   is also approx.
-000080e0: 2074 6865 2074 6f74 616c 206e 6f2e 206f   the total no. o
-000080f0: 6620 6c69 6e6b 7320 696e 2074 6865 2065  f links in the e
-00008100: 6e64 210a 2020 2020 2020 2020 5720 3d20  nd!.        W = 
-00008110: 286d 2b31 2920 2a20 284e 2d6d 290a 2020  (m+1) * (N-m).  
-00008120: 2020 2020 2020 696e 635f 7461 7267 6574        inc_target
-00008130: 203d 206e 702e 7a65 726f 7328 572c 2022   = np.zeros(W, "
-00008140: 696e 7422 2920 2023 2069 6e76 6572 7365  int")  # inverse
-00008150: 2063 756d 2e20 7720 6469 7374 7269 6275   cum. w distribu
-00008160: 7469 6f6e 0a20 2020 2020 2020 2069 6e63  tion.        inc
-00008170: 5f74 6172 6765 745b 3a6d 2b31 5d20 3d20  _target[:m+1] = 
-00008180: 7261 6e67 6528 6d2b 3129 0a0a 2020 2020  range(m+1)..    
-00008190: 2020 2020 2320 6d61 782e 2070 6f73 7369      # max. possi
-000081a0: 626c 6520 7720 6265 666f 7265 2073 7465  ble w before ste
-000081b0: 7020 6e3a 2031 202b 206d 286e 2d6d 2d32  p n: 1 + m(n-m-2
-000081c0: 292c 0a20 2020 2020 2020 2023 2073 6f20  ),.        # so 
-000081d0: 7468 6520 6164 6469 7469 6f6e 2069 6e20  the addition in 
-000081e0: 7374 6570 206e 2069 6e63 7265 6173 6573  step n increases
-000081f0: 2074 6f74 616c 206e 2e73 2e69 2e20 6465   total n.s.i. de
-00008200: 6772 6565 2062 7920 6174 206d 6f73 740a  gree by at most.
-00008210: 2020 2020 2020 2020 2320 3320 2b20 6d28          # 3 + m(
-00008220: 6e2d 6d2d 3229 203c 3d20 6e6d 2c0a 2020  n-m-2) <= nm,.  
-00008230: 2020 2020 2020 2320 6561 6368 206f 6620        # each of 
-00008240: 7468 6520 6d20 7765 6967 6874 2069 6e63  the m weight inc
-00008250: 7265 6173 6573 2069 6e63 7265 6173 6573  reases increases
-00008260: 2069 7420 6279 2061 7420 6d6f 7374 206e   it by at most n
-00008270: 2c20 746f 7461 6c6c 696e 670a 2020 2020  , totalling.    
-00008280: 2020 2020 2320 6d6e 2c0a 2020 2020 2020      # mn,.      
-00008290: 2020 2320 616e 6420 6561 6368 206f 6620    # and each of 
-000082a0: 7468 6520 6d20 6164 6469 7469 6f6e 616c  the m additional
-000082b0: 206c 696e 6b73 2069 6e63 7265 6173 6573   links increases
-000082c0: 2069 7420 6279 2061 7420 6d6f 7374 0a20   it by at most. 
-000082d0: 2020 2020 2020 2023 2032 202a 2028 3120         # 2 * (1 
-000082e0: 2b20 6d28 6e2d 6d2d 3229 202b 206d 292c  + m(n-m-2) + m),
-000082f0: 2074 6f74 616c 6c69 6e67 203c 3d20 326e   totalling <= 2n
-00008300: 6d2c 2061 6c6c 2074 6f74 616c 6c69 6e67  m, all totalling
-00008310: 203c 3d20 326e 6d5e 320a 2020 2020 2020   <= 2nm^2.      
-00008320: 2020 2320 746f 7461 6c20 6e2e 732e 692e    # total n.s.i.
-00008330: 2064 6567 7265 6520 6e6f 7720 616e 6420   degree now and 
-00008340: 6d61 782e 2069 6e20 7468 6520 656e 643a  max. in the end:
-00008350: 0a20 2020 2020 2020 2023 206c 6173 745f  .        # last_
-00008360: 4b73 7461 7220 3d20 286d 2b31 292a 2a32  Kstar = (m+1)**2
-00008370: 0a20 2020 2020 2020 206c 6173 745f 4b73  .        last_Ks
-00008380: 7461 7220 3d20 286d 2b31 292a 6d0a 2020  tar = (m+1)*m.  
-00008390: 2020 2020 2020 6d61 785f 4b73 7461 7220        max_Kstar 
-000083a0: 3d20 4e2a 2a32 202a 2028 6d2b 3129 2a2a  = N**2 * (m+1)**
-000083b0: 320a 2020 2020 2020 2020 2320 696e 7665  2.        # inve
-000083c0: 7273 6520 6375 6d2e 206b 2a20 6469 7374  rse cum. k* dist
-000083d0: 7269 6275 7469 6f6e 0a20 2020 2020 2020  ribution.       
-000083e0: 206c 696e 6b5f 7461 7267 6574 203d 206e   link_target = n
-000083f0: 702e 7a65 726f 7328 6d61 785f 4b73 7461  p.zeros(max_Ksta
-00008400: 722c 2022 696e 7422 290a 0a20 2020 2020  r, "int")..     
-00008410: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
-00008420: 6528 6d2b 3129 3a0a 2020 2020 2020 2020  e(m+1):.        
-00008430: 2020 2020 666f 7220 6a20 696e 2072 616e      for j in ran
-00008440: 6765 2869 293a 0a20 2020 2020 2020 2020  ge(i):.         
-00008450: 2020 2020 2020 2041 5b69 2c20 6a5d 203d         A[i, j] =
-00008460: 2041 5b6a 2c20 695d 203d 2031 0a20 2020   A[j, i] = 1.   
-00008470: 2020 2020 2020 2020 206e 6273 5b69 5d20           nbs[i] 
-00008480: 3d20 7261 6e67 6528 6d2b 3129 0a20 2020  = range(m+1).   
-00008490: 2020 2020 2020 2020 206e 6273 5b69 5d2e           nbs[i].
-000084a0: 7265 6d6f 7665 2869 290a 2020 2020 2020  remove(i).      
-000084b0: 2020 2020 2020 6c69 6e6b 5f74 6172 6765        link_targe
-000084c0: 745b 286d 2b31 292a 693a 286d 2b31 292a  t[(m+1)*i:(m+1)*
-000084d0: 2869 2b31 295d 203d 2069 0a0a 2020 2020  (i+1)] = i..    
-000084e0: 2020 2020 666f 7220 6e20 696e 2072 616e      for n in ran
-000084f0: 6765 286d 2b32 2c20 4e2b 3129 3a0a 2020  ge(m+2, N+1):.  
-00008500: 2020 2020 2020 2020 2020 2320 6164 6420            # add 
-00008510: 6e6f 6465 206e 2d31 2077 6974 6820 756e  node n-1 with un
-00008520: 6974 2077 6569 6768 743a 0a20 2020 2020  it weight:.     
-00008530: 2020 2020 2020 2077 5b6e 2d31 5d20 3d20         w[n-1] = 
-00008540: 310a 2020 2020 2020 2020 2020 2020 696e  1.            in
-00008550: 635f 7461 7267 6574 5b6c 6173 745f 575d  c_target[last_W]
-00008560: 203d 206e 2d31 0a20 2020 2020 2020 2020   = n-1.         
-00008570: 2020 206c 6173 745f 5720 2b3d 2031 0a20     last_W += 1. 
-00008580: 2020 2020 2020 2020 2020 2023 206c 696e             # lin
-00008590: 6b20 6974 2074 6f20 736f 6d65 2069 3a0a  k it to some i:.
-000085a0: 2020 2020 2020 2020 2020 2020 6920 3d20              i = 
-000085b0: 696e 7428 6c69 6e6b 5f74 6172 6765 745b  int(link_target[
-000085c0: 696e 7428 7261 6e64 6f6d 2e75 6e69 666f  int(random.unifo
-000085d0: 726d 286c 6173 745f 4b73 7461 7229 295d  rm(last_Kstar))]
-000085e0: 290a 2020 2020 2020 2020 2020 2020 7072  ).            pr
-000085f0: 696e 7428 226e 222c 206e 2c20 2269 222c  int("n", n, "i",
-00008600: 2069 290a 2020 2020 2020 2020 2020 2020   i).            
-00008610: 415b 692c 206e 2d31 5d20 3d20 415b 6e2d  A[i, n-1] = A[n-
-00008620: 312c 2069 5d20 3d20 310a 2020 2020 2020  1, i] = 1.      
-00008630: 2020 2020 2020 6e62 735b 6e2d 315d 203d        nbs[n-1] =
-00008640: 205b 695d 0a20 2020 2020 2020 2020 2020   [i].           
-00008650: 206e 6273 5b69 5d2e 6170 7065 6e64 286e   nbs[i].append(n
-00008660: 2d31 290a 2020 2020 2020 2020 2020 2020  -1).            
-00008670: 6c69 6e6b 5f74 6172 6765 745b 6c61 7374  link_target[last
-00008680: 5f4b 7374 6172 5d20 3d20 690a 2020 2020  _Kstar] = i.    
-00008690: 2020 2020 2020 2020 2320 6c69 6e6b 5f74          # link_t
-000086a0: 6172 6765 745b 6c61 7374 5f4b 7374 6172  arget[last_Kstar
-000086b0: 2b31 3a6c 6173 745f 4b73 7461 722b 322b  +1:last_Kstar+2+
-000086c0: 775b 695d 5d20 3d20 6e2d 310a 2020 2020  w[i]] = n-1.    
-000086d0: 2020 2020 2020 2020 2320 6c61 7374 5f4b          # last_K
-000086e0: 7374 6172 202b 3d20 322b 775b 695d 0a20  star += 2+w[i]. 
-000086f0: 2020 2020 2020 2020 2020 206c 696e 6b5f             link_
-00008700: 7461 7267 6574 5b6c 6173 745f 4b73 7461  target[last_Ksta
-00008710: 722b 315d 203d 206e 2d31 0a20 2020 2020  r+1] = n-1.     
-00008720: 2020 2020 2020 206c 6173 745f 4b73 7461         last_Ksta
-00008730: 7220 2b3d 2032 0a0a 2020 2020 2020 2020  r += 2..        
-00008740: 2020 2020 666f 7220 6a6a 2069 6e20 7261      for jj in ra
-00008750: 6e67 6528 6d29 3a0a 2020 2020 2020 2020  nge(m):.        
-00008760: 2020 2020 2020 2020 2320 696e 6372 6561          # increa
-00008770: 7365 2077 6569 6768 7420 6f66 2073 6f6d  se weight of som
-00008780: 6520 6a20 6e6f 7420 616c 7265 6164 7920  e j not already 
-00008790: 6c69 6e6b 6564 2074 6f20 616c 6c3a 0a20  linked to all:. 
-000087a0: 2020 2020 2020 2020 2020 2020 2020 206a                 j
-000087b0: 203d 2069 6e74 2869 6e63 5f74 6172 6765   = int(inc_targe
-000087c0: 745b 696e 7428 7261 6e64 6f6d 2e75 6e69  t[int(random.uni
-000087d0: 666f 726d 286c 6173 745f 5729 295d 290a  form(last_W))]).
-000087e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000087f0: 7768 696c 6520 6c65 6e28 6e62 735b 6a5d  while len(nbs[j]
-00008800: 2920 3d3d 206e 2d31 3a0a 2020 2020 2020  ) == n-1:.      
-00008810: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00008820: 696e 7428 2220 6e6f 7420 6a22 2c20 6a29  int(" not j", j)
-00008830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008840: 2020 2020 206a 203d 2069 6e74 2869 6e63       j = int(inc
-00008850: 5f74 6172 6765 745b 696e 7428 7261 6e64  _target[int(rand
-00008860: 6f6d 2e75 6e69 666f 726d 286c 6173 745f  om.uniform(last_
-00008870: 5729 295d 290a 2020 2020 2020 2020 2020  W))]).          
-00008880: 2020 2020 2020 775b 6a5d 202b 3d20 310a        w[j] += 1.
-00008890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000088a0: 7072 696e 7428 2220 6a6a 222c 206a 6a2c  print(" jj", jj,
-000088b0: 2022 6a22 2c20 6a2c 2022 775b 6a5d 222c   "j", j, "w[j]",
-000088c0: 2077 5b6a 5d29 0a20 2020 2020 2020 2020   w[j]).         
-000088d0: 2020 2020 2020 2069 6e63 5f74 6172 6765         inc_targe
-000088e0: 745b 6c61 7374 5f57 5d20 3d20 6a0a 2020  t[last_W] = j.  
-000088f0: 2020 2020 2020 2020 2020 2020 2020 6c61                la
-00008900: 7374 5f57 202b 3d20 310a 2020 2020 2020  st_W += 1.      
-00008910: 2020 2020 2020 2020 2020 2320 6c69 6e6b            # link
-00008920: 5f74 6172 6765 745b 6c61 7374 5f4b 7374  _target[last_Kst
-00008930: 6172 5d20 3d20 6a0a 2020 2020 2020 2020  ar] = j.        
-00008940: 2020 2020 2020 2020 2320 6c61 7374 5f4b          # last_K
-00008950: 7374 6172 202b 3d20 310a 2020 2020 2020  star += 1.      
-00008960: 2020 2020 2020 2020 2020 2320 666f 7220            # for 
-00008970: 6920 696e 206e 6273 5b6a 5d3a 0a20 2020  i in nbs[j]:.   
-00008980: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-00008990: 2020 2070 7269 6e74 2822 2020 6922 2c20     print("  i", 
-000089a0: 6929 0a20 2020 2020 2020 2020 2020 2020  i).             
-000089b0: 2020 2023 2020 2020 206c 696e 6b5f 7461     #     link_ta
-000089c0: 7267 6574 5b6c 6173 745f 4b73 7461 725d  rget[last_Kstar]
-000089d0: 203d 2069 0a20 2020 2020 2020 2020 2020   = i.           
-000089e0: 2020 2020 2023 2020 2020 206c 6173 745f       #     last_
-000089f0: 4b73 7461 7220 2b3d 2031 0a0a 2020 2020  Kstar += 1..    
-00008a00: 2020 2020 2020 2020 2020 2020 2320 6c69              # li
-00008a10: 6e6b 2069 7420 746f 2073 6f6d 6520 6920  nk it to some i 
-00008a20: 6e6f 7420 616c 7265 6164 7920 6c69 6e6b  not already link
-00008a30: 6564 2074 6f20 6974 3a0a 2020 2020 2020  ed to it:.      
-00008a40: 2020 2020 2020 2020 2020 6920 3d20 696e            i = in
-00008a50: 7428 6c69 6e6b 5f74 6172 6765 745b 696e  t(link_target[in
-00008a60: 7428 7261 6e64 6f6d 2e75 6e69 666f 726d  t(random.uniform
-00008a70: 286c 6173 745f 4b73 7461 7229 295d 290a  (last_Kstar))]).
-00008a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008a90: 7768 696c 6520 6920 3d3d 206a 206f 7220  while i == j or 
-00008aa0: 415b 692c 206a 5d20 3d3d 2031 3a0a 2020  A[i, j] == 1:.  
-00008ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ac0: 2020 2320 7072 696e 7428 2220 206e 6f74    # print("  not
-00008ad0: 2069 222c 6929 0a20 2020 2020 2020 2020   i",i).         
-00008ae0: 2020 2020 2020 2020 2020 2069 203d 2069             i = i
-00008af0: 6e74 286c 696e 6b5f 7461 7267 6574 5b69  nt(link_target[i
-00008b00: 6e74 2872 616e 646f 6d2e 756e 6966 6f72  nt(random.unifor
-00008b10: 6d28 6c61 7374 5f4b 7374 6172 2929 5d29  m(last_Kstar))])
-00008b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008b30: 2041 5b69 2c20 6a5d 203d 2041 5b6a 2c20   A[i, j] = A[j, 
-00008b40: 695d 203d 2031 0a20 2020 2020 2020 2020  i] = 1.         
-00008b50: 2020 2020 2020 206e 6273 5b6a 5d2e 6170         nbs[j].ap
-00008b60: 7065 6e64 2869 290a 2020 2020 2020 2020  pend(i).        
-00008b70: 2020 2020 2020 2020 6e62 735b 695d 2e61          nbs[i].a
-00008b80: 7070 656e 6428 6a29 0a20 2020 2020 2020  ppend(j).       
-00008b90: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
-00008ba0: 2822 2020 6922 2c69 2c22 6e62 735b 695d  ("  i",i,"nbs[i]
-00008bb0: 222c 6e62 735b 695d 2c22 6e62 735b 6a5d  ",nbs[i],"nbs[j]
-00008bc0: 222c 6e62 735b 6a5d 290a 2020 2020 2020  ",nbs[j]).      
-00008bd0: 2020 2020 2020 2020 2020 2320 6c69 6e6b            # link
-00008be0: 5f74 6172 6765 745b 6c61 7374 5f4b 7374  _target[last_Kst
-00008bf0: 6172 3a6c 6173 745f 4b73 7461 722b 775b  ar:last_Kstar+w[
-00008c00: 6a5d 5d20 3d20 690a 2020 2020 2020 2020  j]] = i.        
-00008c10: 2020 2020 2020 2020 2320 6c61 7374 5f4b          # last_K
-00008c20: 7374 6172 202b 3d20 775b 6a5d 0a20 2020  star += w[j].   
-00008c30: 2020 2020 2020 2020 2020 2020 2023 206c               # l
-00008c40: 696e 6b5f 7461 7267 6574 5b6c 6173 745f  ink_target[last_
-00008c50: 4b73 7461 723a 6c61 7374 5f4b 7374 6172  Kstar:last_Kstar
-00008c60: 2b77 5b69 5d5d 203d 206a 0a20 2020 2020  +w[i]] = j.     
-00008c70: 2020 2020 2020 2020 2020 2023 206c 6173             # las
-00008c80: 745f 4b73 7461 7220 2b3d 2077 5b69 5d0a  t_Kstar += w[i].
-00008c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ca0: 6c69 6e6b 5f74 6172 6765 745b 6c61 7374  link_target[last
-00008cb0: 5f4b 7374 6172 5d20 3d20 690a 2020 2020  _Kstar] = i.    
-00008cc0: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
-00008cd0: 5f74 6172 6765 745b 6c61 7374 5f4b 7374  _target[last_Kst
-00008ce0: 6172 2b31 5d20 3d20 6a0a 2020 2020 2020  ar+1] = j.      
-00008cf0: 2020 2020 2020 2020 2020 6c61 7374 5f4b            last_K
-00008d00: 7374 6172 202b 3d20 320a 0a20 2020 2020  star += 2..     
-00008d10: 2020 2064 656c 206e 6273 2c20 6c69 6e6b     del nbs, link
-00008d20: 5f74 6172 6765 742c 2069 6e63 5f74 6172  _target, inc_tar
-00008d30: 6765 740a 2020 2020 2020 2020 7265 7475  get.        retu
-00008d40: 726e 204e 6574 776f 726b 2841 2c20 6e6f  rn Network(A, no
-00008d50: 6465 5f77 6569 6768 7473 3d77 2c20 7369  de_weights=w, si
-00008d60: 6c65 6e63 655f 6c65 7665 6c3d 7369 6c65  lence_level=sile
-00008d70: 6e63 655f 6c65 7665 6c29 0a0a 2020 2020  nce_level)..    
-00008d80: 4073 7461 7469 636d 6574 686f 640a 2020  @staticmethod.  
-00008d90: 2020 6465 6620 4772 6f77 5072 6566 6572    def GrowPrefer
-00008da0: 656e 7469 616c 6c79 286e 5f6e 6f64 6573  entially(n_nodes
-00008db0: 3d31 3030 2c20 6e5f 6772 6f77 7468 733d  =100, n_growths=
-00008dc0: 312c 206e 5f6c 696e 6b73 5f6e 6577 3d31  1, n_links_new=1
-00008dd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008de0: 2020 2020 2020 2020 2020 2020 206e 5f6c               n_l
-00008df0: 696e 6b73 5f6f 6c64 3d31 2c20 6e73 693d  inks_old=1, nsi=
-00008e00: 5472 7565 2c20 7072 6566 6572 656e 7469  True, preferenti
-00008e10: 616c 5f65 7870 6f6e 656e 743d 312c 0a20  al_exponent=1,. 
-00008e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008e30: 2020 2020 2020 2020 2020 6e5f 696e 6974            n_init
-00008e40: 6961 6c73 3d31 2c20 7369 6c65 6e63 655f  ials=1, silence_
-00008e50: 6c65 7665 6c3d 3029 3a0a 2020 2020 2020  level=0):.      
-00008e60: 2020 2222 220a 2020 2020 2020 2020 4558    """.        EX
-00008e70: 5045 5249 4d45 4e54 414c 3a20 5265 7475  PERIMENTAL: Retu
-00008e80: 726e 2061 2072 616e 646f 6d20 6e65 7477  rn a random netw
-00008e90: 6f72 6b20 6772 6f77 6e20 7769 7468 2070  ork grown with p
-00008ea0: 7265 6665 7265 6e74 6961 6c20 7765 6967  referential weig
-00008eb0: 6874 0a20 2020 2020 2020 2069 6e63 7265  ht.        incre
-00008ec0: 6173 6520 616e 6420 6e2e 732e 692e 2070  ase and n.s.i. p
-00008ed0: 7265 6665 7265 6e74 6961 6c20 6174 7461  referential atta
-00008ee0: 6368 6d65 6e74 2e0a 0a20 2020 2020 2020  chment...       
-00008ef0: 2052 6574 7572 6e20 6120 7261 6e64 6f6d   Return a random
-00008f00: 206e 6574 776f 726b 2067 726f 776e 2061   network grown a
-00008f10: 7320 666f 6c6c 6f77 733a 2053 7461 7274  s follows: Start
-00008f20: 696e 6720 7769 7468 2061 2063 6c69 7175  ing with a cliqu
-00008f30: 650a 2020 2020 2020 2020 6f66 2032 2a6e  e.        of 2*n
-00008f40: 5f6c 696e 6b73 5f6e 6577 2b31 2075 6e69  _links_new+1 uni
-00008f50: 7420 7765 6967 6874 206e 6f64 6573 2c20  t weight nodes, 
-00008f60: 6974 6572 6174 6976 656c 7920 6164 6420  iteratively add 
-00008f70: 6120 756e 6974 2077 6569 6768 740a 2020  a unit weight.  
-00008f80: 2020 2020 2020 6e6f 6465 2c20 636f 6e6e        node, conn
-00008f90: 6563 7420 6974 2077 6974 6820 6e5f 6c69  ect it with n_li
-00008fa0: 6e6b 735f 6e65 7720 6469 6666 6572 656e  nks_new differen
-00008fb0: 7420 6578 6973 7469 6e67 206e 6f64 6573  t existing nodes
-00008fc0: 2063 686f 7365 6e0a 2020 2020 2020 2020   chosen.        
-00008fd0: 7769 7468 2070 726f 6261 6269 6c69 7469  with probabiliti
-00008fe0: 6573 2070 726f 706f 7274 696f 6e61 6c20  es proportional 
-00008ff0: 746f 2074 6865 6972 2063 7572 7265 6e74  to their current
-00009000: 206e 2e73 2e69 2e20 6465 6772 6565 2c20   n.s.i. degree, 
-00009010: 7468 656e 0a20 2020 2020 2020 2069 6e63  then.        inc
-00009020: 7265 6173 6520 7468 6520 7765 6967 6874  rease the weight
-00009030: 7320 6f66 206e 5f67 726f 7774 6873 206e  s of n_growths n
-00009040: 6f64 6573 2063 686f 7365 6e20 7769 7468  odes chosen with
-00009050: 2070 726f 6261 6269 6c69 7469 6573 0a20   probabilities. 
-00009060: 2020 2020 2020 2070 726f 706f 7274 696f         proportio
-00009070: 6e61 6c20 746f 2074 6865 6972 2063 7572  nal to their cur
-00009080: 7265 6e74 2077 6569 6768 7420 2877 6974  rent weight (wit
-00009090: 6820 7265 706c 6163 656d 656e 7429 2c20  h replacement), 
-000090a0: 7468 656e 2061 6464 0a20 2020 2020 2020  then add.       
-000090b0: 206e 5f6c 696e 6b73 5f6f 6c64 206e 6577   n_links_old new
-000090c0: 206c 696e 6b73 2062 6574 7765 656e 2070   links between p
-000090d0: 6169 7273 206f 6620 6e6f 6465 7320 6368  airs of nodes ch
-000090e0: 6f73 656e 2077 6974 6820 7072 6f62 6162  osen with probab
-000090f0: 696c 6974 6965 730a 2020 2020 2020 2020  ilities.        
-00009100: 7072 6f70 6f72 7469 6f6e 616c 2074 6f20  proportional to 
-00009110: 7468 6569 7220 6375 7272 656e 7420 7765  their current we
-00009120: 6967 6874 2e0a 0a20 2020 2020 2020 203a  ight...        :
-00009130: 7479 7065 2073 696c 656e 6365 5f6c 6576  type silence_lev
-00009140: 656c 3a20 696e 7420 3e3d 2030 0a20 2020  el: int >= 0.   
-00009150: 2020 2020 203a 6172 6720 2073 696c 656e       :arg  silen
-00009160: 6365 5f6c 6576 656c 3a20 5468 6520 6869  ce_level: The hi
-00009170: 6768 6572 2c20 7468 6520 6c65 7373 2070  gher, the less p
-00009180: 726f 6772 6573 7320 696e 666f 2069 7320  rogress info is 
-00009190: 6f75 7470 7574 2e0a 2020 2020 2020 2020  output..        
-000091a0: 2222 220a 2020 2020 2020 2020 4e20 3d20  """.        N = 
-000091b0: 6e5f 6e6f 6465 730a 2020 2020 2020 2020  n_nodes.        
-000091c0: 772c 2041 203d 206e 702e 7a65 726f 7328  w, A = np.zeros(
-000091d0: 4e2c 2064 7479 7065 3d69 6e74 292c 2073  N, dtype=int), s
-000091e0: 702e 6c69 6c5f 6d61 7472 6978 2828 4e2c  p.lil_matrix((N,
-000091f0: 204e 2929 0a20 2020 2020 2020 206e 6273   N)).        nbs
-00009200: 203d 205b 5b5d 2066 6f72 2069 2069 6e20   = [[] for i in 
-00009210: 7261 6e67 6528 4e29 5d0a 2020 2020 2020  range(N)].      
-00009220: 2020 696e 635f 7461 7267 6574 203d 206c    inc_target = l
-00009230: 6973 7428 7261 6e67 6528 6e5f 696e 6974  ist(range(n_init
-00009240: 6961 6c73 2929 0a0a 2020 2020 2020 2020  ials))..        
-00009250: 6966 206e 7369 3a0a 2020 2020 2020 2020  if nsi:.        
-00009260: 2020 2020 6b73 7461 7220 3d20 6e70 2e7a      kstar = np.z
-00009270: 6572 6f73 284e 290a 2020 2020 2020 2020  eros(N).        
-00009280: 2020 2020 6c69 6e6b 5f70 726f 6220 3d20      link_prob = 
-00009290: 6e70 2e7a 6572 6f73 284e 2920 2023 2077  np.zeros(N)  # w
-000092a0: 202a 206b 7374 6172 0a0a 2020 2020 2020   * kstar..      
-000092b0: 2020 2020 2020 775b 3a6e 5f69 6e69 7469        w[:n_initi
-000092c0: 616c 735d 203d 2031 0a20 2020 2020 2020  als] = 1.       
-000092d0: 2020 2020 206c 696e 6b5f 7072 6f62 5b3a       link_prob[:
-000092e0: 6e5f 696e 6974 6961 6c73 5d20 3d20 310a  n_initials] = 1.
-000092f0: 2020 2020 2020 2020 2020 2020 746f 7461              tota
-00009300: 6c5f 6c69 6e6b 5f70 726f 6220 3d20 6c69  l_link_prob = li
-00009310: 6e6b 5f70 726f 622e 7375 6d28 290a 0a20  nk_prob.sum().. 
-00009320: 2020 2020 2020 2020 2020 2064 6566 205f             def _
-00009330: 6c69 6e6b 5f74 6172 6765 7428 293a 0a20  link_target():. 
-00009340: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00009350: 6864 203d 2072 616e 646f 6d2e 756e 6966  hd = random.unif
-00009360: 6f72 6d28 6c6f 773d 302c 2068 6967 683d  orm(low=0, high=
-00009370: 746f 7461 6c5f 6c69 6e6b 5f70 726f 6229  total_link_prob)
-00009380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009390: 2069 203d 2030 0a20 2020 2020 2020 2020   i = 0.         
-000093a0: 2020 2020 2020 2063 756d 203d 206c 696e         cum = lin
-000093b0: 6b5f 7072 6f62 5b30 5d0a 2020 2020 2020  k_prob[0].      
-000093c0: 2020 2020 2020 2020 2020 7768 696c 6520            while 
-000093d0: 6375 6d20 3c20 7468 643a 0a20 2020 2020  cum < thd:.     
-000093e0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000093f0: 202b 3d20 310a 2020 2020 2020 2020 2020   += 1.          
-00009400: 2020 2020 2020 2020 2020 6375 6d20 2b3d            cum +=
-00009410: 206c 696e 6b5f 7072 6f62 5b69 5d0a 2020   link_prob[i].  
-00009420: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00009430: 7475 726e 2069 0a0a 2020 2020 2020 2020  turn i..        
-00009440: 2020 2020 7072 6f67 7265 7373 203d 2070      progress = p
-00009450: 726f 6772 6573 7362 6172 2e50 726f 6772  rogressbar.Progr
-00009460: 6573 7342 6172 286d 6178 7661 6c3d 4e29  essBar(maxval=N)
-00009470: 2e73 7461 7274 2829 0a20 2020 2020 2020  .start().       
-00009480: 2020 2020 2066 6f72 206a 2069 6e20 7261       for j in ra
-00009490: 6e67 6528 6e5f 696e 6974 6961 6c73 2c20  nge(n_initials, 
-000094a0: 4e29 3a0a 2020 2020 2020 2020 2020 2020  N):.            
-000094b0: 2020 2020 2320 6164 6420 6e6f 6465 206a      # add node j
-000094c0: 2077 6974 6820 756e 6974 2077 6569 6768   with unit weigh
-000094d0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
-000094e0: 2020 206c 696e 6b5f 7072 6f62 5b6a 5d20     link_prob[j] 
-000094f0: 3d20 6b73 7461 725b 6a5d 203d 2077 5b6a  = kstar[j] = w[j
-00009500: 5d20 3d20 310a 2020 2020 2020 2020 2020  ] = 1.          
-00009510: 2020 2020 2020 746f 7461 6c5f 6c69 6e6b        total_link
-00009520: 5f70 726f 6220 2b3d 2031 0a20 2020 2020  _prob += 1.     
-00009530: 2020 2020 2020 2020 2020 2069 6e63 5f74             inc_t
-00009540: 6172 6765 742e 6170 7065 6e64 286a 290a  arget.append(j).
-00009550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009560: 2320 6c69 6e6b 2069 7420 746f 2073 6f6d  # link it to som
-00009570: 6520 6927 733a 0a20 2020 2020 2020 2020  e i's:.         
-00009580: 2020 2020 2020 2066 6f72 205f 2069 6e20         for _ in 
-00009590: 7261 6e67 6528 6e5f 6c69 6e6b 735f 6e65  range(n_links_ne
-000095a0: 7729 3a0a 2020 2020 2020 2020 2020 2020  w):.            
-000095b0: 2020 2020 2020 2020 6920 3d20 5f6c 696e          i = _lin
-000095c0: 6b5f 7461 7267 6574 2829 0a20 2020 2020  k_target().     
-000095d0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000095e0: 2070 7269 6e74 286a 2c69 290a 2020 2020   print(j,i).    
-000095f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009600: 7768 696c 6520 6920 3d3d 206a 3a0a 2020  while i == j:.  
+000063a0: 2020 2020 2020 2020 2020 2020 5b30 2c20              [0, 
+000063b0: 302c 2031 2e39 2c20 302c 2031 2e30 2c20  0, 1.9, 0, 1.0, 
+000063c0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+000063d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000063e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000063f0: 2020 2020 2020 2020 2020 2020 5b30 2c20              [0, 
+00006400: 302c 2030 2c20 302c 2030 2c20 305d 2c0a  0, 0, 0, 0, 0],.
+00006410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006440: 2020 2020 2020 2020 5b30 2c20 332e 302c          [0, 3.0,
+00006450: 2030 2c20 302c 2030 2c20 305d 2c0a 2020   0, 0, 0, 0],.  
+00006460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006490: 2020 2020 2020 5b32 2e31 2c20 302c 2032        [2.1, 0, 2
+000064a0: 2e37 2c20 302c 2030 2c20 305d 2c0a 2020  .7, 0, 0, 0],.  
+000064b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000064c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000064d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000064e0: 2020 2020 2020 5b31 2e35 2c20 302c 2030        [1.5, 0, 0
+000064f0: 2c20 302c 2030 2c20 305d 5d29 290a 2020  , 0, 0, 0]])).  
+00006500: 2020 2020 2020 7265 7475 726e 206e 770a        return nw.
+00006510: 0a20 2020 2023 0a20 2020 2023 2020 4e65  .    #.    #  Ne
+00006520: 7477 6f72 6b20 6d6f 6465 6c73 0a20 2020  twork models.   
+00006530: 2023 0a0a 2020 2020 4073 7461 7469 636d   #..    @staticm
+00006540: 6574 686f 640a 2020 2020 6465 6620 4d6f  ethod.    def Mo
+00006550: 6465 6c28 6e65 7477 6f72 6b5f 6d6f 6465  del(network_mode
+00006560: 6c2c 202a 2a6b 7761 7267 7329 3a0a 2020  l, **kwargs):.  
+00006570: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00006580: 2020 5265 7475 726e 2061 206e 6577 206d    Return a new m
+00006590: 6f64 656c 2067 7261 7068 2067 656e 6572  odel graph gener
+000065a0: 6174 6564 2077 6974 6820 7468 6520 7370  ated with the sp
+000065b0: 6563 6966 6965 6420 6e65 7477 6f72 6b20  ecified network 
+000065c0: 6d6f 6465 6c0a 0a20 2020 2020 2020 202a  model..        *
+000065d0: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+000065e0: 2020 2020 203e 3e3e 2070 7269 6e74 284e       >>> print(N
+000065f0: 6574 776f 726b 2e4d 6f64 656c 2822 4572  etwork.Model("Er
+00006600: 646f 7352 656e 7969 222c 206e 5f6e 6f64  dosRenyi", n_nod
+00006610: 6573 3d31 302c 206e 5f6c 696e 6b73 3d31  es=10, n_links=1
+00006620: 3829 290a 2020 2020 2020 2020 4765 6e65  8)).        Gene
+00006630: 7261 7469 6e67 2045 7264 6f73 2d52 656e  rating Erdos-Ren
+00006640: 7969 2072 616e 646f 6d20 6772 6170 6820  yi random graph 
+00006650: 7769 7468 2031 3020 6e6f 6465 7320 616e  with 10 nodes an
+00006660: 6420 3138 206c 696e 6b73 2e2e 2e0a 2020  d 18 links....  
+00006670: 2020 2020 2020 4e65 7477 6f72 6b3a 2075        Network: u
+00006680: 6e64 6972 6563 7465 642c 2031 3020 6e6f  ndirected, 10 no
+00006690: 6465 732c 2031 3820 6c69 6e6b 732c 206c  des, 18 links, l
+000066a0: 696e 6b20 6465 6e73 6974 7920 302e 3430  ink density 0.40
+000066b0: 302e 0a0a 2020 2020 2020 2020 3a74 7970  0...        :typ
+000066c0: 6520 6e65 7477 6f72 6b5f 6d6f 6465 6c20  e network_model 
+000066d0: 7374 7269 6e67 0a20 2020 2020 2020 203a  string.        :
+000066e0: 6172 6720 6e65 7477 6f72 6b5f 6d6f 6465  arg network_mode
+000066f0: 6c20 6e61 6d65 206f 6620 7468 6520 636f  l name of the co
+00006700: 7272 6573 706f 6e64 696e 6720 6e65 7477  rresponding netw
+00006710: 6f72 6b20 6d6f 6465 6c0a 0a20 2020 2020  ork model..     
+00006720: 2020 203a 7274 7970 653a 203a 636c 6173     :rtype: :clas
+00006730: 733a 604e 6574 776f 726b 6020 696e 7374  s:`Network` inst
+00006740: 616e 6365 0a20 2020 2020 2020 203a 7265  ance.        :re
+00006750: 7475 726e 3a20 3a63 6c61 7373 3a60 4e65  turn: :class:`Ne
+00006760: 7477 6f72 6b60 206f 626a 6563 742e 0a0a  twork` object...
+00006770: 2020 2020 2020 2020 506f 7373 6962 6c65          Possible
+00006780: 2063 686f 6963 6573 2066 6f72 2060 606e   choices for ``n
+00006790: 6574 776f 726b 5f6d 6f64 656c 6060 3a0a  etwork_model``:.
+000067a0: 2020 2020 2020 2020 2020 2d20 2245 7264            - "Erd
+000067b0: 6f73 5265 6e79 6922 0a20 2020 2020 2020  osRenyi".       
+000067c0: 2020 202d 2022 4261 7261 6261 7369 416c     - "BarabasiAl
+000067d0: 6265 7274 220a 2020 2020 2020 2020 2020  bert".          
+000067e0: 2d20 2242 6172 6162 6173 6941 6c62 6572  - "BarabasiAlber
+000067f0: 745f 6967 7261 7068 220a 2020 2020 2020  t_igraph".      
+00006800: 2020 2020 2d20 2243 6f6e 6669 6775 7261      - "Configura
+00006810: 7469 6f6e 220a 2020 2020 2020 2020 2222  tion".        ""
+00006820: 220a 2020 2020 2020 2020 4120 3d20 6765  ".        A = ge
+00006830: 7461 7474 7228 4e65 7477 6f72 6b2c 206e  tattr(Network, n
+00006840: 6574 776f 726b 5f6d 6f64 656c 2928 2a2a  etwork_model)(**
+00006850: 6b77 6172 6773 290a 2020 2020 2020 2020  kwargs).        
+00006860: 7265 7475 726e 204e 6574 776f 726b 2841  return Network(A
+00006870: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
+00006880: 7468 6f64 0a20 2020 2064 6566 2045 7264  thod.    def Erd
+00006890: 6f73 5265 6e79 6928 6e5f 6e6f 6465 733d  osRenyi(n_nodes=
+000068a0: 3130 302c 206c 696e 6b5f 7072 6f62 6162  100, link_probab
+000068b0: 696c 6974 793d 4e6f 6e65 2c20 6e5f 6c69  ility=None, n_li
+000068c0: 6e6b 733d 4e6f 6e65 2c0a 2020 2020 2020  nks=None,.      
+000068d0: 2020 2020 2020 2020 2020 2020 2073 696c               sil
+000068e0: 656e 6365 5f6c 6576 656c 3d30 293a 0a20  ence_level=0):. 
+000068f0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00006900: 2020 2052 6574 7572 6e20 6164 6a61 6365     Return adjace
+00006910: 6e63 7920 6d61 7472 6978 206f 6620 6120  ncy matrix of a 
+00006920: 6e65 7720 756e 6469 7265 6374 6564 2045  new undirected E
+00006930: 7264 6f73 2d52 656e 7969 2072 616e 646f  rdos-Renyi rando
+00006940: 6d20 6772 6170 680a 2020 2020 2020 2020  m graph.        
+00006950: 7769 7468 2061 2067 6976 656e 206e 756d  with a given num
+00006960: 6265 7220 6f66 206e 6f64 6573 2061 6e64  ber of nodes and
+00006970: 206c 696e 6b69 6e67 2070 726f 6261 6269   linking probabi
+00006980: 6c69 7479 2e0a 0a20 2020 2020 2020 2054  lity...        T
+00006990: 6865 2065 7870 6563 7465 6420 6c69 6e6b  he expected link
+000069a0: 2064 656e 7369 7479 2065 7175 616c 7320   density equals 
+000069b0: 7468 6973 2070 726f 6261 6269 6c69 7479  this probability
+000069c0: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+000069d0: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+000069e0: 203e 3e3e 2041 203d 204e 6574 776f 726b   >>> A = Network
+000069f0: 2e45 7264 6f73 5265 6e79 6928 6e5f 6e6f  .ErdosRenyi(n_no
+00006a00: 6465 733d 3130 2c20 6e5f 6c69 6e6b 733d  des=10, n_links=
+00006a10: 3138 290a 2020 2020 2020 2020 4765 6e65  18).        Gene
+00006a20: 7261 7469 6e67 2045 7264 6f73 2d52 656e  rating Erdos-Ren
+00006a30: 7969 2072 616e 646f 6d20 6772 6170 6820  yi random graph 
+00006a40: 7769 7468 2031 3020 6e6f 6465 7320 616e  with 10 nodes an
+00006a50: 6420 3138 206c 696e 6b73 2e2e 2e0a 0a20  d 18 links..... 
+00006a60: 2020 2020 2020 203a 7479 7065 206e 5f6e         :type n_n
+00006a70: 6f64 6573 3a20 696e 7420 3e20 300a 2020  odes: int > 0.  
+00006a80: 2020 2020 2020 3a61 7267 2020 6e5f 6e6f        :arg  n_no
+00006a90: 6465 733a 204e 756d 6265 7220 6f66 206e  des: Number of n
+00006aa0: 6f64 6573 2e20 2844 6566 6175 6c74 3a20  odes. (Default: 
+00006ab0: 3130 3029 0a0a 2020 2020 2020 2020 3a74  100)..        :t
+00006ac0: 7970 6520 6c69 6e6b 5f70 726f 6261 6269  ype link_probabi
+00006ad0: 6c69 7479 3a20 666c 6f61 7420 6672 6f6d  lity: float from
+00006ae0: 2030 2074 6f20 312c 206f 7220 4e6f 6e65   0 to 1, or None
+00006af0: 0a20 2020 2020 2020 203a 6172 6720 206c  .        :arg  l
+00006b00: 696e 6b5f 7072 6f62 6162 696c 6974 793a  ink_probability:
+00006b10: 2049 6620 6e6f 7420 4e6f 6e65 2c20 6561   If not None, ea
+00006b20: 6368 2070 6169 7220 6f66 206e 6f64 6573  ch pair of nodes
+00006b30: 2069 730a 2020 2020 2020 2020 2020 2020   is.            
+00006b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006b50: 2020 2020 696e 6465 7065 6e64 656e 746c      independentl
+00006b60: 7920 6c69 6e6b 6564 2077 6974 6820 7468  y linked with th
+00006b70: 6973 2070 726f 6261 6269 6c69 7479 2e0a  is probability..
+00006b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006ba0: 2844 6566 6175 6c74 3a20 4e6f 6e65 290a  (Default: None).
+00006bb0: 0a20 2020 2020 2020 203a 7479 7065 206e  .        :type n
+00006bc0: 5f6c 696e 6b73 3a20 696e 7420 3e20 302c  _links: int > 0,
+00006bd0: 206f 7220 4e6f 6e65 0a20 2020 2020 2020   or None.       
+00006be0: 203a 6172 6720 206e 5f6c 696e 6b73 3a20   :arg  n_links: 
+00006bf0: 4966 206e 6f74 204e 6f6e 652c 2074 6869  If not None, thi
+00006c00: 7320 6d61 6e79 206c 696e 6b73 2061 7265  s many links are
+00006c10: 2061 7373 6967 6e65 6420 6174 2072 616e   assigned at ran
+00006c20: 646f 6d2e 0a20 2020 2020 2020 2020 2020  dom..           
+00006c30: 2020 2020 2020 2020 2020 2020 4d75 7374              Must
+00006c40: 2062 6520 4e6f 6e65 2069 6620 6c69 6e6b   be None if link
+00006c50: 5f70 726f 6261 6269 6c69 7479 2069 7320  _probability is 
+00006c60: 6e6f 7420 4e6f 6e65 2e0a 2020 2020 2020  not None..      
+00006c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006c80: 2028 4465 6661 756c 743a 204e 6f6e 6529   (Default: None)
+00006c90: 0a0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
+00006ca0: 7369 6c65 6e63 655f 6c65 7665 6c3a 2069  silence_level: i
+00006cb0: 6e74 203e 3d20 300a 2020 2020 2020 2020  nt >= 0.        
+00006cc0: 3a61 7267 2020 7369 6c65 6e63 655f 6c65  :arg  silence_le
+00006cd0: 7665 6c3a 2054 6865 2068 6967 6865 722c  vel: The higher,
+00006ce0: 2074 6865 206c 6573 7320 7072 6f67 7265   the less progre
+00006cf0: 7373 2069 6e66 6f20 6973 206f 7574 7075  ss info is outpu
+00006d00: 742e 0a0a 2020 2020 2020 2020 3a72 7479  t...        :rty
+00006d10: 7065 3a20 7371 7561 7265 2061 7272 6179  pe: square array
+00006d20: 2d6c 696b 6520 5b6e 6f64 652c 6e6f 6465  -like [node,node
+00006d30: 5d0a 2020 2020 2020 2020 3a72 6574 7572  ].        :retur
+00006d40: 6e3a 2061 646a 6163 656e 6379 206d 6174  n: adjacency mat
+00006d50: 7269 7820 6f66 2074 6865 2067 656e 6572  rix of the gener
+00006d60: 6174 6564 206d 6f64 656c 206e 6574 776f  ated model netwo
+00006d70: 726b 0a20 2020 2020 2020 2022 2222 0a20  rk.        """. 
+00006d80: 2020 2020 2020 2069 6620 6c69 6e6b 5f70         if link_p
+00006d90: 726f 6261 6269 6c69 7479 2069 7320 6e6f  robability is no
+00006da0: 7420 4e6f 6e65 2061 6e64 206e 5f6c 696e  t None and n_lin
+00006db0: 6b73 2069 7320 4e6f 6e65 3a0a 2020 2020  ks is None:.    
+00006dc0: 2020 2020 2020 2020 6966 2073 696c 656e          if silen
+00006dd0: 6365 5f6c 6576 656c 203c 2031 3a0a 2020  ce_level < 1:.  
+00006de0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00006df0: 696e 7428 6622 4765 6e65 7261 7469 6e67  int(f"Generating
+00006e00: 2045 7264 6f73 2d52 656e 7969 2072 616e   Erdos-Renyi ran
+00006e10: 646f 6d20 6772 6170 6820 7769 7468 2022  dom graph with "
+00006e20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006e30: 2020 2020 2020 2066 227b 6e5f 6e6f 6465         f"{n_node
+00006e40: 737d 206e 6f64 6573 2061 6e64 2070 726f  s} nodes and pro
+00006e50: 6261 6269 6c69 7479 207b 6c69 6e6b 5f70  bability {link_p
+00006e60: 726f 6261 6269 6c69 7479 7d2e 2e2e 2229  robability}...")
+00006e70: 0a0a 2020 2020 2020 2020 2020 2020 6772  ..            gr
+00006e80: 6170 6820 3d20 6967 7261 7068 2e47 7261  aph = igraph.Gra
+00006e90: 7068 2e45 7264 6f73 5f52 656e 7969 286e  ph.Erdos_Renyi(n
+00006ea0: 3d6e 5f6e 6f64 6573 2c20 703d 6c69 6e6b  =n_nodes, p=link
+00006eb0: 5f70 726f 6261 6269 6c69 7479 290a 0a20  _probability).. 
+00006ec0: 2020 2020 2020 2065 6c69 6620 6c69 6e6b         elif link
+00006ed0: 5f70 726f 6261 6269 6c69 7479 2069 7320  _probability is 
+00006ee0: 4e6f 6e65 2061 6e64 206e 5f6c 696e 6b73  None and n_links
+00006ef0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+00006f00: 2020 2020 2020 2020 2020 6966 2073 696c            if sil
+00006f10: 656e 6365 5f6c 6576 656c 203c 2031 3a0a  ence_level < 1:.
+00006f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006f30: 7072 696e 7428 6622 4765 6e65 7261 7469  print(f"Generati
+00006f40: 6e67 2045 7264 6f73 2d52 656e 7969 2072  ng Erdos-Renyi r
+00006f50: 616e 646f 6d20 6772 6170 6820 7769 7468  andom graph with
+00006f60: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+00006f70: 2020 2020 2020 2020 2066 227b 6e5f 6e6f           f"{n_no
+00006f80: 6465 737d 206e 6f64 6573 2061 6e64 207b  des} nodes and {
+00006f90: 6e5f 6c69 6e6b 737d 206c 696e 6b73 2e2e  n_links} links..
+00006fa0: 2e22 290a 0a20 2020 2020 2020 2020 2020  .")..           
+00006fb0: 2067 7261 7068 203d 2069 6772 6170 682e   graph = igraph.
+00006fc0: 4772 6170 682e 4572 646f 735f 5265 6e79  Graph.Erdos_Reny
+00006fd0: 6928 6e3d 6e5f 6e6f 6465 732c 206d 3d6e  i(n=n_nodes, m=n
+00006fe0: 5f6c 696e 6b73 290a 0a20 2020 2020 2020  _links)..       
+00006ff0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00007000: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00007010: 726f 7228 2260 4572 646f 7352 656e 7969  ror("`ErdosRenyi
+00007020: 2829 6020 7265 7175 6972 6573 2065 6974  ()` requires eit
+00007030: 6865 7220 6120 220a 2020 2020 2020 2020  her a ".        
+00007040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007050: 2020 2020 2022 606c 696e 6b5f 7072 6f62       "`link_prob
+00007060: 6162 696c 6974 7960 206f 7220 606e 5f6c  ability` or `n_l
+00007070: 696e 6b73 6020 6172 6775 6d65 6e74 2e22  inks` argument."
+00007080: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00007090: 6e20 6e70 2e61 7272 6179 2867 7261 7068  n np.array(graph
+000070a0: 2e67 6574 5f61 646a 6163 656e 6379 2874  .get_adjacency(t
+000070b0: 7970 653d 3229 2e64 6174 6129 0a0a 2020  ype=2).data)..  
+000070c0: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
+000070d0: 2020 2020 6465 6620 4261 7261 6261 7369      def Barabasi
+000070e0: 416c 6265 7274 5f69 6772 6170 6828 6e5f  Albert_igraph(n_
+000070f0: 6e6f 6465 733d 3130 302c 206e 5f6c 696e  nodes=100, n_lin
+00007100: 6b73 5f65 6163 683d 352c 2073 696c 656e  ks_each=5, silen
+00007110: 6365 5f6c 6576 656c 3d30 293a 0a20 2020  ce_level=0):.   
+00007120: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00007130: 2052 6574 7572 6e20 6164 6a61 6365 6e63   Return adjacenc
+00007140: 7920 6d61 7472 6978 206f 6620 6120 6e65  y matrix of a ne
+00007150: 7720 756e 6469 7265 6374 6564 2042 6172  w undirected Bar
+00007160: 6162 6173 692d 416c 6265 7274 2072 616e  abasi-Albert ran
+00007170: 646f 6d0a 2020 2020 2020 2020 6772 6170  dom.        grap
+00007180: 6820 6765 6e65 7261 7465 6420 6279 2069  h generated by i
+00007190: 6772 6170 682e 0a0a 2020 2020 2020 2020  graph...        
+000071a0: 4341 5554 494f 4e3a 2061 6374 7561 6c20  CAUTION: actual 
+000071b0: 6e6f 2e20 6f66 206e 6577 206c 696e 6b73  no. of new links
+000071c0: 2063 616e 2062 6520 736d 616c 6c65 7220   can be smaller 
+000071d0: 7468 616e 206e 5f6c 696e 6b73 5f65 6163  than n_links_eac
+000071e0: 680a 2020 2020 2020 2020 6265 6361 7573  h.        becaus
+000071f0: 6520 6e65 6967 6862 6f75 7273 2061 7265  e neighbours are
+00007200: 2064 7261 776e 2077 6974 6820 7265 706c   drawn with repl
+00007210: 6163 656d 656e 7420 616e 6420 6772 6170  acement and grap
+00007220: 6820 6973 2074 6865 6e0a 2020 2020 2020  h is then.      
+00007230: 2020 7369 6d70 6c69 6669 6564 2e0a 0a20    simplified... 
+00007240: 2020 2020 2020 2054 6865 2067 6976 656e         The given
+00007250: 206e 756d 6265 7220 6f66 206e 6f64 6573   number of nodes
+00007260: 2061 7265 2061 6464 6564 2069 6e20 7475   are added in tu
+00007270: 726e 2074 6f20 7468 6520 696e 6974 6961  rn to the initia
+00007280: 6c6c 7920 656d 7074 7920 6e6f 6465 0a20  lly empty node. 
+00007290: 2020 2020 2020 2073 6574 2c20 616e 6420         set, and 
+000072a0: 6561 6368 206e 6577 206e 6f64 6520 6973  each new node is
+000072b0: 206c 696e 6b65 6420 746f 2074 6865 2067   linked to the g
+000072c0: 6976 656e 206e 756d 6265 7220 6f66 2065  iven number of e
+000072d0: 7869 7374 696e 6720 6e6f 6465 732e 0a20  xisting nodes.. 
+000072e0: 2020 2020 2020 2054 6865 2072 6573 756c         The resul
+000072f0: 7469 6e67 206c 696e 6b20 6465 6e73 6974  ting link densit
+00007300: 7920 6973 2061 7070 726f 782e 2032 202a  y is approx. 2 *
+00007310: 2060 606e 5f6c 696e 6b73 5f65 6163 6860   ``n_links_each`
+00007320: 602f 6060 6e5f 6e6f 6465 7360 602e 0a0a  `/``n_nodes``...
+00007330: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
+00007340: 653a 2a2a 2047 656e 6572 6174 696e 6720  e:** Generating 
+00007350: 6120 7261 6e64 6f6d 2074 7265 653a 0a0a  a random tree:..
+00007360: 2020 2020 2020 2020 3e3e 3e20 4120 3d20          >>> A = 
+00007370: 4e65 7477 6f72 6b2e 4261 7261 6261 7369  Network.Barabasi
+00007380: 416c 6265 7274 5f69 6772 6170 6828 6e5f  Albert_igraph(n_
+00007390: 6e6f 6465 733d 3130 302c 206e 5f6c 696e  nodes=100, n_lin
+000073a0: 6b73 5f65 6163 683d 3129 0a0a 2020 2020  ks_each=1)..    
+000073b0: 2020 2020 3a74 7970 6520 6e5f 6e6f 6465      :type n_node
+000073c0: 733a 2069 6e74 203e 2030 0a20 2020 2020  s: int > 0.     
+000073d0: 2020 203a 6172 6720 206e 5f6e 6f64 6573     :arg  n_nodes
+000073e0: 3a20 4e75 6d62 6572 206f 6620 6e6f 6465  : Number of node
+000073f0: 732e 2028 4465 6661 756c 743a 2031 3030  s. (Default: 100
+00007400: 290a 0a20 2020 2020 2020 203a 7479 7065  )..        :type
+00007410: 206e 5f6c 696e 6b73 5f65 6163 683a 2069   n_links_each: i
+00007420: 6e74 203e 2030 0a20 2020 2020 2020 203a  nt > 0.        :
+00007430: 6172 6720 206e 5f6c 696e 6b73 5f65 6163  arg  n_links_eac
+00007440: 683a 204e 756d 6265 7220 6f66 206c 696e  h: Number of lin
+00007450: 6b73 2074 6f20 6578 6973 7469 6e67 206e  ks to existing n
+00007460: 6f64 6573 2065 6163 6820 6e65 7720 6e6f  odes each new no
+00007470: 6465 0a20 2020 2020 2020 2020 2020 2020  de.             
+00007480: 2020 2020 2020 2020 2020 2020 2020 2067                 g
+00007490: 6574 7320 6475 7269 6e67 2063 6f6e 7374  ets during const
+000074a0: 7275 6374 696f 6e2e 2028 4465 6661 756c  ruction. (Defaul
+000074b0: 743a 2035 290a 0a20 2020 2020 2020 203a  t: 5)..        :
+000074c0: 7479 7065 2073 696c 656e 6365 5f6c 6576  type silence_lev
+000074d0: 656c 3a20 696e 7420 3e3d 2030 0a20 2020  el: int >= 0.   
+000074e0: 2020 2020 203a 6172 6720 2073 696c 656e       :arg  silen
+000074f0: 6365 5f6c 6576 656c 3a20 5468 6520 6869  ce_level: The hi
+00007500: 6768 6572 2c20 7468 6520 6c65 7373 2070  gher, the less p
+00007510: 726f 6772 6573 7320 696e 666f 2069 7320  rogress info is 
+00007520: 6f75 7470 7574 2e0a 0a20 2020 2020 2020  output...       
+00007530: 203a 7274 7970 653a 2073 7175 6172 6520   :rtype: square 
+00007540: 6172 7261 792d 6c69 6b65 205b 6e6f 6465  array-like [node
+00007550: 2c6e 6f64 655d 0a20 2020 2020 2020 203a  ,node].        :
+00007560: 7265 7475 726e 3a20 6164 6a61 6365 6e63  return: adjacenc
+00007570: 7920 6d61 7472 6978 206f 6620 6765 6e65  y matrix of gene
+00007580: 7261 7465 6420 6e65 7477 6f72 6b0a 2020  rated network.  
+00007590: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000075a0: 2020 6772 6170 6820 3d20 6967 7261 7068    graph = igraph
+000075b0: 2e47 7261 7068 2e42 6172 6162 6173 6928  .Graph.Barabasi(
+000075c0: 6e3d 6e5f 6e6f 6465 732c 206d 3d6e 5f6c  n=n_nodes, m=n_l
+000075d0: 696e 6b73 5f65 6163 6829 0a0a 2020 2020  inks_each)..    
+000075e0: 2020 2020 2320 5265 6d6f 7665 2073 656c      # Remove sel
+000075f0: 662d 6c6f 6f70 7320 616e 6420 6d75 6c74  f-loops and mult
+00007600: 6970 6c65 206c 696e 6b73 2c20 7468 6973  iple links, this
+00007610: 2064 6f65 7320 6f66 2063 6f75 7273 6520   does of course 
+00007620: 6368 616e 6765 2074 6865 0a20 2020 2020  change the.     
+00007630: 2020 2023 2061 6374 7561 6c20 6465 6772     # actual degr
+00007640: 6565 2073 6571 7565 6e63 6520 6f66 2074  ee sequence of t
+00007650: 6865 2067 656e 6572 6174 6564 2067 7261  he generated gra
+00007660: 7068 2c20 6275 7420 6a75 7374 2073 6c69  ph, but just sli
+00007670: 6768 746c 790a 2020 2020 2020 2020 6772  ghtly.        gr
+00007680: 6170 682e 7369 6d70 6c69 6679 2829 0a0a  aph.simplify()..
+00007690: 2020 2020 2020 2020 7265 7475 726e 206e          return n
+000076a0: 702e 6172 7261 7928 6772 6170 682e 6765  p.array(graph.ge
+000076b0: 745f 6164 6a61 6365 6e63 7928 7479 7065  t_adjacency(type
+000076c0: 3d32 292e 6461 7461 290a 0a20 2020 2023  =2).data)..    #
+000076d0: 2046 4958 4d45 3a20 4164 6420 6578 616d   FIXME: Add exam
+000076e0: 706c 650a 2020 2020 4073 7461 7469 636d  ple.    @staticm
+000076f0: 6574 686f 640a 2020 2020 6465 6620 4261  ethod.    def Ba
+00007700: 7261 6261 7369 416c 6265 7274 286e 5f6e  rabasiAlbert(n_n
+00007710: 6f64 6573 3d31 3030 2c20 6e5f 6c69 6e6b  odes=100, n_link
+00007720: 735f 6561 6368 3d35 2c20 7369 6c65 6e63  s_each=5, silenc
+00007730: 655f 6c65 7665 6c3d 3029 3a0a 2020 2020  e_level=0):.    
+00007740: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00007750: 5265 7475 726e 2061 646a 6163 656e 6379  Return adjacency
+00007760: 206d 6174 7269 7820 6f66 2061 206e 6577   matrix of a new
+00007770: 2075 6e64 6972 6563 7465 6420 4261 7261   undirected Bara
+00007780: 6261 7369 2d41 6c62 6572 7420 7261 6e64  basi-Albert rand
+00007790: 6f6d 0a20 2020 2020 2020 2067 7261 7068  om.        graph
+000077a0: 2077 6974 6820 6578 6163 746c 7920 6e5f   with exactly n_
+000077b0: 6c69 6e6b 735f 6561 6368 202a 2028 6e5f  links_each * (n_
+000077c0: 6e6f 6465 732d 6e5f 6c69 6e6b 735f 6561  nodes-n_links_ea
+000077d0: 6368 2920 6c69 6e6b 732e 0a0a 2020 2020  ch) links...    
+000077e0: 2020 2020 3a74 7970 6520 7369 6c65 6e63      :type silenc
+000077f0: 655f 6c65 7665 6c3a 2069 6e74 203e 3d20  e_level: int >= 
+00007800: 300a 2020 2020 2020 2020 3a61 7267 2020  0.        :arg  
+00007810: 7369 6c65 6e63 655f 6c65 7665 6c3a 2054  silence_level: T
+00007820: 6865 2068 6967 6865 722c 2074 6865 206c  he higher, the l
+00007830: 6573 7320 7072 6f67 7265 7373 2069 6e66  ess progress inf
+00007840: 6f20 6973 206f 7574 7075 742e 0a0a 2020  o is output...  
+00007850: 2020 2020 2020 3a72 7479 7065 3a20 7371        :rtype: sq
+00007860: 7561 7265 2061 7272 6179 2d6c 696b 6520  uare array-like 
+00007870: 5b6e 6f64 652c 6e6f 6465 5d0a 2020 2020  [node,node].    
+00007880: 2020 2020 3a72 6574 7572 6e3a 2061 646a      :return: adj
+00007890: 6163 656e 6379 206d 6174 7269 7820 6f66  acency matrix of
+000078a0: 2067 656e 6572 6174 6564 206e 6574 776f   generated netwo
+000078b0: 726b 0a20 2020 2020 2020 2022 2222 0a20  rk.        """. 
+000078c0: 2020 2020 2020 2023 2073 7461 7274 2077         # start w
+000078d0: 6974 6820 312b 6d20 6e6f 6465 7320 6f66  ith 1+m nodes of
+000078e0: 2077 6869 6368 2074 6865 2066 6972 7374   which the first
+000078f0: 2069 7320 6c69 6e6b 6564 2074 6f20 7468   is linked to th
+00007900: 6520 7265 7374 0a20 2020 2020 2020 204e  e rest.        N
+00007910: 2c20 6d20 3d20 6e5f 6e6f 6465 732c 206e  , m = n_nodes, n
+00007920: 5f6c 696e 6b73 5f65 6163 680a 2020 2020  _links_each.    
+00007930: 2020 2020 4120 3d20 7370 2e6c 696c 5f6d      A = sp.lil_m
+00007940: 6174 7269 7828 284e 2c20 4e29 2c20 6474  atrix((N, N), dt
+00007950: 7970 653d 6e70 2e69 6e74 3829 0a20 2020  ype=np.int8).   
+00007960: 2020 2020 2041 5b30 2c20 313a 312b 6d5d       A[0, 1:1+m]
+00007970: 203d 2031 0a20 2020 2020 2020 2041 5b31   = 1.        A[1
+00007980: 3a31 2b6d 2c20 305d 203d 2031 0a0a 2020  :1+m, 0] = 1..  
+00007990: 2020 2020 2020 2320 696e 7665 7273 6520        # inverse 
+000079a0: 6375 6d2e 2064 6567 7265 6520 6469 7374  cum. degree dist
+000079b0: 7269 6275 7469 6f6e 0a20 2020 2020 2020  ribution.       
+000079c0: 2074 6172 6765 7473 2c20 6c61 7374 5f63   targets, last_c
+000079d0: 6869 6c64 203d 206e 702e 7a65 726f 7328  hild = np.zeros(
+000079e0: 322a 6d2a 284e 2d6d 292c 2064 7479 7065  2*m*(N-m), dtype
+000079f0: 3d6e 702e 696e 7438 292c 206e 702e 7a65  =np.int8), np.ze
+00007a00: 726f 7328 4e29 0a20 2020 2020 2020 2074  ros(N).        t
+00007a10: 6172 6765 7473 5b6d 3a32 2a6d 5d20 3d20  argets[m:2*m] = 
+00007a20: 7261 6e67 6528 312c 2031 2b6d 290a 2020  range(1, 1+m).  
+00007a30: 2020 2020 2020 6e5f 7461 7267 6574 7320        n_targets 
+00007a40: 3d20 322a 6d0a 2020 2020 2020 2020 666f  = 2*m.        fo
+00007a50: 7220 6a20 696e 2072 616e 6765 2831 2b6d  r j in range(1+m
+00007a60: 2c20 4e29 3a0a 2020 2020 2020 2020 2020  , N):.          
+00007a70: 2020 666f 7220 6974 2069 6e20 7261 6e67    for it in rang
+00007a80: 6528 6d29 3a0a 2020 2020 2020 2020 2020  e(m):.          
+00007a90: 2020 2020 2020 7768 696c 6520 5472 7565        while True
+00007aa0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007ab0: 2020 2020 2020 6920 3d20 7461 7267 6574        i = target
+00007ac0: 735b 696e 7428 7261 6e64 6f6d 2e75 6e69  s[int(random.uni
+00007ad0: 666f 726d 286c 6f77 3d30 2c20 6869 6768  form(low=0, high
+00007ae0: 3d6e 5f74 6172 6765 7473 2929 5d0a 2020  =n_targets))].  
+00007af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007b00: 2020 6966 206c 6173 745f 6368 696c 645b    if last_child[
+00007b10: 695d 2021 3d20 6a3a 0a20 2020 2020 2020  i] != j:.       
+00007b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007b30: 2062 7265 616b 0a20 2020 2020 2020 2020   break.         
+00007b40: 2020 2020 2020 2041 5b69 2c20 6a5d 203d         A[i, j] =
+00007b50: 2041 5b6a 2c20 695d 203d 2031 0a20 2020   A[j, i] = 1.   
+00007b60: 2020 2020 2020 2020 2020 2020 2074 6172               tar
+00007b70: 6765 7473 5b6e 5f74 6172 6765 7473 202b  gets[n_targets +
+00007b80: 2069 745d 203d 2069 0a20 2020 2020 2020   it] = i.       
+00007b90: 2020 2020 2020 2020 206c 6173 745f 6368           last_ch
+00007ba0: 696c 645b 695d 203d 206a 0a20 2020 2020  ild[i] = j.     
+00007bb0: 2020 2020 2020 2074 6172 6765 7473 5b6e         targets[n
+00007bc0: 5f74 6172 6765 7473 202b 206d 3a20 6e5f  _targets + m: n_
+00007bd0: 7461 7267 6574 7320 2b20 322a 6d5d 203d  targets + 2*m] =
+00007be0: 206a 0a20 2020 2020 2020 2020 2020 206e   j.            n
+00007bf0: 5f74 6172 6765 7473 202b 3d20 322a 6d0a  _targets += 2*m.
+00007c00: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00007c10: 410a 0a20 2020 2040 7374 6174 6963 6d65  A..    @staticme
+00007c20: 7468 6f64 0a20 2020 2064 6566 2043 6f6e  thod.    def Con
+00007c30: 6669 6775 7261 7469 6f6e 2864 6567 7265  figuration(degre
+00007c40: 6573 2c20 7369 6c65 6e63 655f 6c65 7665  es, silence_leve
+00007c50: 6c3d 3029 3a0a 2020 2020 2020 2020 2222  l=0):.        ""
+00007c60: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
+00007c70: 2061 646a 6163 656e 6379 206d 6174 7269   adjacency matri
+00007c80: 7820 6f66 2061 206e 6577 2063 6f6e 6669  x of a new confi
+00007c90: 6775 7261 7469 6f6e 206d 6f64 656c 2072  guration model r
+00007ca0: 616e 646f 6d20 6772 6170 680a 2020 2020  andom graph.    
+00007cb0: 2020 2020 7769 7468 2061 2067 6976 656e      with a given
+00007cc0: 2064 6567 7265 6520 7365 7175 656e 6365   degree sequence
+00007cd0: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+00007ce0: 6d70 6c65 3a2a 2a20 4765 6e65 7261 7465  mple:** Generate
+00007cf0: 2061 206e 6574 776f 726b 206f 6620 3130   a network of 10
+00007d00: 3030 206e 6f64 6573 2077 6974 6820 6465  00 nodes with de
+00007d10: 6772 6565 2033 2065 6163 683a 0a0a 2020  gree 3 each:..  
+00007d20: 2020 2020 2020 3e3e 3e20 4120 3d20 4e65        >>> A = Ne
+00007d30: 7477 6f72 6b2e 436f 6e66 6967 7572 6174  twork.Configurat
+00007d40: 696f 6e28 5b33 2066 6f72 205f 2069 6e20  ion([3 for _ in 
+00007d50: 7261 6e67 6528 302c 3130 3030 295d 2929  range(0,1000)]))
+00007d60: 0a20 2020 2020 2020 2047 656e 6572 6174  .        Generat
+00007d70: 696e 6720 636f 6e66 6967 7572 6174 696f  ing configuratio
+00007d80: 6e20 6d6f 6465 6c20 7261 6e64 6f6d 2067  n model random g
+00007d90: 7261 7068 0a20 2020 2020 2020 2066 726f  raph.        fro
+00007da0: 6d20 6769 7665 6e20 6465 6772 6565 2073  m given degree s
+00007db0: 6571 7565 6e63 652e 2e2e 0a0a 2020 2020  equence.....    
+00007dc0: 2020 2020 3a74 7970 6520 6465 6772 6565      :type degree
+00007dd0: 733a 2031 6420 6e75 6d70 7920 6172 7261  s: 1d numpy arra
+00007de0: 7920 6f72 206c 6973 7420 5b6e 6f64 655d  y or list [node]
+00007df0: 0a20 2020 2020 2020 203a 6172 6720 2064  .        :arg  d
+00007e00: 6567 7265 6573 3a20 4172 7261 7920 6f72  egrees: Array or
+00007e10: 206c 6973 7420 6f66 2064 6567 7265 6573   list of degrees
+00007e20: 2077 616e 7465 642e 0a0a 2020 2020 2020   wanted...      
+00007e30: 2020 3a74 7970 6520 7369 6c65 6e63 655f    :type silence_
+00007e40: 6c65 7665 6c3a 2069 6e74 203e 3d20 300a  level: int >= 0.
+00007e50: 2020 2020 2020 2020 3a61 7267 2020 7369          :arg  si
+00007e60: 6c65 6e63 655f 6c65 7665 6c3a 2054 6865  lence_level: The
+00007e70: 2068 6967 6865 722c 2074 6865 206c 6573   higher, the les
+00007e80: 7320 7072 6f67 7265 7373 2069 6e66 6f20  s progress info 
+00007e90: 6973 206f 7574 7075 742e 0a0a 2020 2020  is output...    
+00007ea0: 2020 2020 3a72 7479 7065 3a20 7371 7561      :rtype: squa
+00007eb0: 7265 2061 7272 6179 2d6c 696b 6520 5b6e  re array-like [n
+00007ec0: 6f64 652c 6e6f 6465 5d0a 2020 2020 2020  ode,node].      
+00007ed0: 2020 3a72 6574 7572 6e3a 2061 646a 6163    :return: adjac
+00007ee0: 656e 6379 206d 6174 7269 7820 6f66 2067  ency matrix of g
+00007ef0: 656e 6572 6174 6564 206e 6574 776f 726b  enerated network
+00007f00: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00007f10: 2020 2020 2070 7269 6e74 2822 4765 6e65       print("Gene
+00007f20: 7261 7469 6e67 2063 6f6e 6669 6775 7261  rating configura
+00007f30: 7469 6f6e 206d 6f64 656c 2072 616e 646f  tion model rando
+00007f40: 6d20 6772 6170 685c 6e22 0a20 2020 2020  m graph\n".     
+00007f50: 2020 2020 2020 2020 202b 2022 6672 6f6d           + "from
+00007f60: 2067 6976 656e 2064 6567 7265 6520 7365   given degree se
+00007f70: 7175 656e 6365 2e2e 2e22 290a 0a20 2020  quence...")..   
+00007f80: 2020 2020 2067 7261 7068 203d 2069 6772       graph = igr
+00007f90: 6170 682e 4772 6170 682e 4465 6772 6565  aph.Graph.Degree
+00007fa0: 5f53 6571 7565 6e63 6528 6f75 743d 6c69  _Sequence(out=li
+00007fb0: 7374 2864 6567 7265 6573 2929 0a0a 2020  st(degrees))..  
+00007fc0: 2020 2020 2020 2320 2052 656d 6f76 6520        #  Remove 
+00007fd0: 7365 6c66 2d6c 6f6f 7073 2061 6e64 206d  self-loops and m
+00007fe0: 756c 7469 706c 6520 6c69 6e6b 732c 2074  ultiple links, t
+00007ff0: 6869 7320 646f 6573 206f 6620 636f 7572  his does of cour
+00008000: 7365 2063 6861 6e67 6520 7468 650a 2020  se change the.  
+00008010: 2020 2020 2020 2320 2061 6374 7561 6c20        #  actual 
+00008020: 6465 6772 6565 2073 6571 7565 6e63 6520  degree sequence 
+00008030: 6f66 2074 6865 2067 656e 6572 6174 6564  of the generated
+00008040: 2067 7261 7068 2c20 6275 7420 6a75 7374   graph, but just
+00008050: 2073 6c69 6768 746c 790a 2020 2020 2020   slightly.      
+00008060: 2020 6772 6170 682e 7369 6d70 6c69 6679    graph.simplify
+00008070: 2829 0a0a 2020 2020 2020 2020 7265 7475  ()..        retu
+00008080: 726e 206e 702e 6172 7261 7928 6772 6170  rn np.array(grap
+00008090: 682e 6765 745f 6164 6a61 6365 6e63 7928  h.get_adjacency(
+000080a0: 7479 7065 3d32 292e 6461 7461 290a 0a20  type=2).data).. 
+000080b0: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
+000080c0: 0a20 2020 2064 6566 2057 6174 7473 5374  .    def WattsSt
+000080d0: 726f 6761 747a 284e 2c20 6b2c 2070 293a  rogatz(N, k, p):
+000080e0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000080f0: 2020 2020 2052 6574 7572 6e20 6164 6a61       Return adja
+00008100: 6365 6e63 7920 6d61 7472 6978 206f 6620  cency matrix of 
+00008110: 6120 5761 7474 2d53 7472 6f67 6174 7a20  a Watt-Strogatz 
+00008120: 7261 6e64 6f6d 2067 7261 7068 2e0a 0a20  random graph... 
+00008130: 2020 2020 2020 2052 6566 6572 656e 6365         Reference
+00008140: 3a20 5b57 6174 7473 3139 3938 5d5f 0a0a  : [Watts1998]_..
+00008150: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
+00008160: 653a 2a2a 2047 656e 6572 6174 6520 6120  e:** Generate a 
+00008170: 6e65 7477 6f72 6b20 6f66 2031 3030 206e  network of 100 n
+00008180: 6f64 6573 2077 6974 6820 7265 7769 7269  odes with rewiri
+00008190: 6e67 2070 726f 6261 6269 6c69 7479 0a20  ng probability. 
+000081a0: 2020 2020 2020 2030 2e31 0a0a 2020 2020         0.1..    
+000081b0: 2020 2020 3e3e 3e20 4120 3d20 4e65 7477      >>> A = Netw
+000081c0: 6f72 6b2e 5761 7474 7353 7472 6f67 6174  ork.WattsStrogat
+000081d0: 7a28 4e3d 3130 302c 206b 3d32 2c20 703d  z(N=100, k=2, p=
+000081e0: 302e 3129 0a20 2020 2020 2020 2047 656e  0.1).        Gen
+000081f0: 6572 6174 696e 6720 5761 7474 732d 5374  erating Watts-St
+00008200: 726f 6761 747a 2072 616e 646f 6d20 6772  rogatz random gr
+00008210: 6170 6820 7769 7468 2031 3030 206e 6f64  aph with 100 nod
+00008220: 6573 2061 6e64 2072 6577 6972 696e 670a  es and rewiring.
+00008230: 2020 2020 2020 2020 7072 6f62 6162 696c          probabil
+00008240: 6974 7920 302e 310a 0a20 2020 2020 2020  ity 0.1..       
+00008250: 203a 7479 7065 204e 3a20 696e 7420 3e20   :type N: int > 
+00008260: 300a 2020 2020 2020 2020 3a61 7267 204e  0.        :arg N
+00008270: 3a20 4e75 6d62 6572 206f 6620 6e6f 6465  : Number of node
+00008280: 732e 0a0a 2020 2020 2020 2020 3a74 7970  s...        :typ
+00008290: 6520 6b3a 2069 6e74 203e 2030 0a20 2020  e k: int > 0.   
+000082a0: 2020 2020 203a 6172 6720 6b3a 2045 6163       :arg k: Eac
+000082b0: 6820 6e6f 6465 2069 7320 636f 6e6e 6563  h node is connec
+000082c0: 7465 6420 746f 206b 206e 6561 7265 7374  ted to k nearest
+000082d0: 206e 6569 6768 626f 7273 2069 6e20 7269   neighbors in ri
+000082e0: 6e67 2074 6f70 6f6c 6f67 792e 0a0a 2020  ng topology...  
+000082f0: 2020 2020 2020 3a74 7970 6520 703a 2066        :type p: f
+00008300: 6c6f 6174 203e 2030 0a20 2020 2020 2020  loat > 0.       
+00008310: 203a 6172 6720 703a 2050 726f 6261 6269   :arg p: Probabi
+00008320: 6c69 7479 206f 6620 7265 7769 7269 6e67  lity of rewiring
+00008330: 2065 6163 6820 6564 6765 2e0a 0a20 2020   each edge...   
+00008340: 2020 2020 203a 7274 7970 653a 2073 7175       :rtype: squ
+00008350: 6172 6520 6172 7261 792d 6c69 6b65 205b  are array-like [
+00008360: 6e6f 6465 2c6e 6f64 655d 0a20 2020 2020  node,node].     
+00008370: 2020 203a 7265 7475 726e 3a20 6164 6a61     :return: adja
+00008380: 6365 6e63 7920 6d61 7472 6978 206f 6620  cency matrix of 
+00008390: 6765 6e65 7261 7465 6420 6e65 7477 6f72  generated networ
+000083a0: 6b0a 2020 2020 2020 2020 2222 220a 2020  k.        """.  
+000083b0: 2020 2020 2020 7072 696e 7428 6622 4765        print(f"Ge
+000083c0: 6e65 7261 7469 6e67 2057 6174 7473 2d53  nerating Watts-S
+000083d0: 7472 6f67 6174 7a20 7261 6e64 6f6d 2067  trogatz random g
+000083e0: 7261 7068 2077 6974 6820 7b4e 7d20 6e6f  raph with {N} no
+000083f0: 6465 7320 616e 6420 220a 2020 2020 2020  des and ".      
+00008400: 2020 2020 2020 2020 6622 7265 7769 7269          f"rewiri
+00008410: 6e67 2070 726f 6261 6269 6c69 7479 207b  ng probability {
+00008420: 707d 2229 0a0a 2020 2020 2020 2020 6772  p}")..        gr
+00008430: 6170 6820 3d20 6967 7261 7068 2e47 7261  aph = igraph.Gra
+00008440: 7068 2e57 6174 7473 5f53 7472 6f67 6174  ph.Watts_Strogat
+00008450: 7a28 6469 6d3d 312c 2073 697a 653d 4e2c  z(dim=1, size=N,
+00008460: 206e 6569 3d6b 2c20 703d 7029 0a0a 2020   nei=k, p=p)..  
+00008470: 2020 2020 2020 7265 7475 726e 206e 702e        return np.
+00008480: 6172 7261 7928 6772 6170 682e 6765 745f  array(graph.get_
+00008490: 6164 6a61 6365 6e63 7928 7479 7065 3d32  adjacency(type=2
+000084a0: 292e 6461 7461 290a 0a20 2020 2040 7374  ).data)..    @st
+000084b0: 6174 6963 6d65 7468 6f64 0a20 2020 2064  aticmethod.    d
+000084c0: 6566 2047 726f 7750 7265 6665 7265 6e74  ef GrowPreferent
+000084d0: 6961 6c6c 795f 6f6c 6428 6e5f 6e6f 6465  ially_old(n_node
+000084e0: 733d 3130 302c 206d 3d32 2c20 7369 6c65  s=100, m=2, sile
+000084f0: 6e63 655f 6c65 7665 6c3d 3029 3a0a 2020  nce_level=0):.  
+00008500: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00008510: 2020 4558 5045 5249 4d45 4e54 414c 3a20    EXPERIMENTAL: 
+00008520: 5265 7475 726e 2061 2072 616e 646f 6d20  Return a random 
+00008530: 6e65 7477 6f72 6b20 6772 6f77 6e20 7769  network grown wi
+00008540: 7468 2070 7265 6665 7265 6e74 6961 6c20  th preferential 
+00008550: 7765 6967 6874 0a20 2020 2020 2020 2069  weight.        i
+00008560: 6e63 7265 6173 6520 616e 6420 7072 6566  ncrease and pref
+00008570: 6572 656e 7469 616c 2061 7474 6163 686d  erential attachm
+00008580: 656e 742e 0a0a 2020 2020 2020 2020 5265  ent...        Re
+00008590: 7475 726e 2061 2072 616e 646f 6d20 6e65  turn a random ne
+000085a0: 7477 6f72 6b20 6772 6f77 6e20 6173 2066  twork grown as f
+000085b0: 6f6c 6c6f 7773 3a20 5374 6172 7469 6e67  ollows: Starting
+000085c0: 2077 6974 6820 6120 636c 6971 7565 0a20   with a clique. 
+000085d0: 2020 2020 2020 206f 6620 6d2b 3120 756e         of m+1 un
+000085e0: 6974 2077 6569 6768 7420 6e6f 6465 732c  it weight nodes,
+000085f0: 2069 7465 7261 7469 7665 6c79 2061 6464   iteratively add
+00008600: 2061 2075 6e69 7420 7765 6967 6874 206e   a unit weight n
+00008610: 6f64 6520 616e 6420 7468 656e 0a20 2020  ode and then.   
+00008620: 2020 2020 206d 2074 696d 6573 2069 6e63       m times inc
+00008630: 7265 6173 6520 7468 6520 7765 6967 6874  rease the weight
+00008640: 206f 6620 616e 2065 7869 7374 696e 6720   of an existing 
+00008650: 6e6f 6465 2062 7920 6f6e 6520 756e 6974  node by one unit
+00008660: 2c20 666f 720a 2020 2020 2020 2020 6e3d  , for.        n=
+00008670: 6d2b 322e 2e2e 4e2e 2043 686f 6f73 6520  m+2...N. Choose 
+00008680: 7468 6520 6772 6f77 696e 6720 6e6f 6465  the growing node
+00008690: 2077 6974 6820 7072 6f62 6162 696c 6974   with probabilit
+000086a0: 6965 7320 7072 6f70 6f72 7469 6f6e 616c  ies proportional
+000086b0: 2074 6f0a 2020 2020 2020 2020 7468 6520   to.        the 
+000086c0: 6e6f 6465 2773 2077 6569 6768 742e 2041  node's weight. A
+000086d0: 6674 6572 2065 6163 6820 6e6f 6465 2061  fter each node a
+000086e0: 6464 6974 696f 6e20 6f72 2077 6569 6768  ddition or weigh
+000086f0: 7420 696e 6372 6561 7365 2c20 6164 6420  t increase, add 
+00008700: 6f6e 650a 2020 2020 2020 2020 6c69 6e6b  one.        link
+00008710: 2066 726f 6d20 7468 6520 7265 7370 6563   from the respec
+00008720: 7469 7665 206e 6f64 6520 746f 2061 6e6f  tive node to ano
+00008730: 7468 6572 206e 6f64 652c 2063 686f 7365  ther node, chose
+00008740: 6e20 7769 7468 2070 726f 6261 6269 6c69  n with probabili
+00008750: 7479 0a20 2020 2020 2020 2070 726f 706f  ty.        propo
+00008760: 7274 696f 6e61 6c20 746f 2074 6861 7420  rtional to that 
+00008770: 6e6f 6465 2773 206e 2e73 2e69 2e20 6465  node's n.s.i. de
+00008780: 6772 6565 2e0a 0a20 2020 2020 2020 203a  gree...        :
+00008790: 7479 7065 2073 696c 656e 6365 5f6c 6576  type silence_lev
+000087a0: 656c 3a20 696e 7420 3e3d 2030 0a20 2020  el: int >= 0.   
+000087b0: 2020 2020 203a 6172 6720 2073 696c 656e       :arg  silen
+000087c0: 6365 5f6c 6576 656c 3a20 5468 6520 6869  ce_level: The hi
+000087d0: 6768 6572 2c20 7468 6520 6c65 7373 2070  gher, the less p
+000087e0: 726f 6772 6573 7320 696e 666f 2069 7320  rogress info is 
+000087f0: 6f75 7470 7574 2e0a 2020 2020 2020 2020  output..        
+00008800: 2222 220a 2020 2020 2020 2020 4e20 3d20  """.        N = 
+00008810: 6e5f 6e6f 6465 730a 2020 2020 2020 2020  n_nodes.        
+00008820: 772c 2041 203d 206e 702e 7a65 726f 7328  w, A = np.zeros(
+00008830: 4e2c 2069 6e74 292c 2073 702e 6c69 6c5f  N, int), sp.lil_
+00008840: 6d61 7472 6978 2828 4e2c 204e 2929 0a20  matrix((N, N)). 
+00008850: 2020 2020 2020 206e 6273 203d 205b 5b5d         nbs = [[]
+00008860: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
+00008870: 4e29 5d0a 0a20 2020 2020 2020 2023 2073  N)]..        # s
+00008880: 7461 7274 2077 6974 6820 6d2b 3120 6675  tart with m+1 fu
+00008890: 6c6c 7920 636f 6e6e 6563 7465 6420 6e6f  lly connected no
+000088a0: 6465 730a 2020 2020 2020 2020 775b 3a6d  des.        w[:m
+000088b0: 2b31 5d20 3d20 310a 0a20 2020 2020 2020  +1] = 1..       
+000088c0: 2023 2074 6f74 616c 2077 6569 6768 7420   # total weight 
+000088d0: 6e6f 7720 616e 6420 696e 2074 6865 2065  now and in the e
+000088e0: 6e64 0a20 2020 2020 2020 206c 6173 745f  nd.        last_
+000088f0: 5720 3d20 6d2b 310a 2020 2020 2020 2020  W = m+1.        
+00008900: 2320 7468 6973 2069 7320 616c 736f 2061  # this is also a
+00008910: 7070 726f 782e 2074 6865 2074 6f74 616c  pprox. the total
+00008920: 206e 6f2e 206f 6620 6c69 6e6b 7320 696e   no. of links in
+00008930: 2074 6865 2065 6e64 210a 2020 2020 2020   the end!.      
+00008940: 2020 5720 3d20 286d 2b31 2920 2a20 284e    W = (m+1) * (N
+00008950: 2d6d 290a 2020 2020 2020 2020 696e 635f  -m).        inc_
+00008960: 7461 7267 6574 203d 206e 702e 7a65 726f  target = np.zero
+00008970: 7328 572c 2022 696e 7422 2920 2023 2069  s(W, "int")  # i
+00008980: 6e76 6572 7365 2063 756d 2e20 7720 6469  nverse cum. w di
+00008990: 7374 7269 6275 7469 6f6e 0a20 2020 2020  stribution.     
+000089a0: 2020 2069 6e63 5f74 6172 6765 745b 3a6d     inc_target[:m
+000089b0: 2b31 5d20 3d20 7261 6e67 6528 6d2b 3129  +1] = range(m+1)
+000089c0: 0a0a 2020 2020 2020 2020 2320 6d61 782e  ..        # max.
+000089d0: 2070 6f73 7369 626c 6520 7720 6265 666f   possible w befo
+000089e0: 7265 2073 7465 7020 6e3a 2031 202b 206d  re step n: 1 + m
+000089f0: 286e 2d6d 2d32 292c 0a20 2020 2020 2020  (n-m-2),.       
+00008a00: 2023 2073 6f20 7468 6520 6164 6469 7469   # so the additi
+00008a10: 6f6e 2069 6e20 7374 6570 206e 2069 6e63  on in step n inc
+00008a20: 7265 6173 6573 2074 6f74 616c 206e 2e73  reases total n.s
+00008a30: 2e69 2e20 6465 6772 6565 2062 7920 6174  .i. degree by at
+00008a40: 206d 6f73 740a 2020 2020 2020 2020 2320   most.        # 
+00008a50: 3320 2b20 6d28 6e2d 6d2d 3229 203c 3d20  3 + m(n-m-2) <= 
+00008a60: 6e6d 2c0a 2020 2020 2020 2020 2320 6561  nm,.        # ea
+00008a70: 6368 206f 6620 7468 6520 6d20 7765 6967  ch of the m weig
+00008a80: 6874 2069 6e63 7265 6173 6573 2069 6e63  ht increases inc
+00008a90: 7265 6173 6573 2069 7420 6279 2061 7420  reases it by at 
+00008aa0: 6d6f 7374 206e 2c20 746f 7461 6c6c 696e  most n, totallin
+00008ab0: 670a 2020 2020 2020 2020 2320 6d6e 2c0a  g.        # mn,.
+00008ac0: 2020 2020 2020 2020 2320 616e 6420 6561          # and ea
+00008ad0: 6368 206f 6620 7468 6520 6d20 6164 6469  ch of the m addi
+00008ae0: 7469 6f6e 616c 206c 696e 6b73 2069 6e63  tional links inc
+00008af0: 7265 6173 6573 2069 7420 6279 2061 7420  reases it by at 
+00008b00: 6d6f 7374 0a20 2020 2020 2020 2023 2032  most.        # 2
+00008b10: 202a 2028 3120 2b20 6d28 6e2d 6d2d 3229   * (1 + m(n-m-2)
+00008b20: 202b 206d 292c 2074 6f74 616c 6c69 6e67   + m), totalling
+00008b30: 203c 3d20 326e 6d2c 2061 6c6c 2074 6f74   <= 2nm, all tot
+00008b40: 616c 6c69 6e67 203c 3d20 326e 6d5e 320a  alling <= 2nm^2.
+00008b50: 2020 2020 2020 2020 2320 746f 7461 6c20          # total 
+00008b60: 6e2e 732e 692e 2064 6567 7265 6520 6e6f  n.s.i. degree no
+00008b70: 7720 616e 6420 6d61 782e 2069 6e20 7468  w and max. in th
+00008b80: 6520 656e 643a 0a20 2020 2020 2020 2023  e end:.        #
+00008b90: 206c 6173 745f 4b73 7461 7220 3d20 286d   last_Kstar = (m
+00008ba0: 2b31 292a 2a32 0a20 2020 2020 2020 206c  +1)**2.        l
+00008bb0: 6173 745f 4b73 7461 7220 3d20 286d 2b31  ast_Kstar = (m+1
+00008bc0: 292a 6d0a 2020 2020 2020 2020 6d61 785f  )*m.        max_
+00008bd0: 4b73 7461 7220 3d20 4e2a 2a32 202a 2028  Kstar = N**2 * (
+00008be0: 6d2b 3129 2a2a 320a 2020 2020 2020 2020  m+1)**2.        
+00008bf0: 2320 696e 7665 7273 6520 6375 6d2e 206b  # inverse cum. k
+00008c00: 2a20 6469 7374 7269 6275 7469 6f6e 0a20  * distribution. 
+00008c10: 2020 2020 2020 206c 696e 6b5f 7461 7267         link_targ
+00008c20: 6574 203d 206e 702e 7a65 726f 7328 6d61  et = np.zeros(ma
+00008c30: 785f 4b73 7461 722c 2022 696e 7422 290a  x_Kstar, "int").
+00008c40: 0a20 2020 2020 2020 2066 6f72 2069 2069  .        for i i
+00008c50: 6e20 7261 6e67 6528 6d2b 3129 3a0a 2020  n range(m+1):.  
+00008c60: 2020 2020 2020 2020 2020 666f 7220 6a20            for j 
+00008c70: 696e 2072 616e 6765 2869 293a 0a20 2020  in range(i):.   
+00008c80: 2020 2020 2020 2020 2020 2020 2041 5b69               A[i
+00008c90: 2c20 6a5d 203d 2041 5b6a 2c20 695d 203d  , j] = A[j, i] =
+00008ca0: 2031 0a20 2020 2020 2020 2020 2020 206e   1.            n
+00008cb0: 6273 5b69 5d20 3d20 7261 6e67 6528 6d2b  bs[i] = range(m+
+00008cc0: 3129 0a20 2020 2020 2020 2020 2020 206e  1).            n
+00008cd0: 6273 5b69 5d2e 7265 6d6f 7665 2869 290a  bs[i].remove(i).
+00008ce0: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+00008cf0: 5f74 6172 6765 745b 286d 2b31 292a 693a  _target[(m+1)*i:
+00008d00: 286d 2b31 292a 2869 2b31 295d 203d 2069  (m+1)*(i+1)] = i
+00008d10: 0a0a 2020 2020 2020 2020 666f 7220 6e20  ..        for n 
+00008d20: 696e 2072 616e 6765 286d 2b32 2c20 4e2b  in range(m+2, N+
+00008d30: 3129 3a0a 2020 2020 2020 2020 2020 2020  1):.            
+00008d40: 2320 6164 6420 6e6f 6465 206e 2d31 2077  # add node n-1 w
+00008d50: 6974 6820 756e 6974 2077 6569 6768 743a  ith unit weight:
+00008d60: 0a20 2020 2020 2020 2020 2020 2077 5b6e  .            w[n
+00008d70: 2d31 5d20 3d20 310a 2020 2020 2020 2020  -1] = 1.        
+00008d80: 2020 2020 696e 635f 7461 7267 6574 5b6c      inc_target[l
+00008d90: 6173 745f 575d 203d 206e 2d31 0a20 2020  ast_W] = n-1.   
+00008da0: 2020 2020 2020 2020 206c 6173 745f 5720           last_W 
+00008db0: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+00008dc0: 2023 206c 696e 6b20 6974 2074 6f20 736f   # link it to so
+00008dd0: 6d65 2069 3a0a 2020 2020 2020 2020 2020  me i:.          
+00008de0: 2020 6920 3d20 696e 7428 6c69 6e6b 5f74    i = int(link_t
+00008df0: 6172 6765 745b 696e 7428 7261 6e64 6f6d  arget[int(random
+00008e00: 2e75 6e69 666f 726d 286c 6173 745f 4b73  .uniform(last_Ks
+00008e10: 7461 7229 295d 290a 2020 2020 2020 2020  tar))]).        
+00008e20: 2020 2020 7072 696e 7428 226e 222c 206e      print("n", n
+00008e30: 2c20 2269 222c 2069 290a 2020 2020 2020  , "i", i).      
+00008e40: 2020 2020 2020 415b 692c 206e 2d31 5d20        A[i, n-1] 
+00008e50: 3d20 415b 6e2d 312c 2069 5d20 3d20 310a  = A[n-1, i] = 1.
+00008e60: 2020 2020 2020 2020 2020 2020 6e62 735b              nbs[
+00008e70: 6e2d 315d 203d 205b 695d 0a20 2020 2020  n-1] = [i].     
+00008e80: 2020 2020 2020 206e 6273 5b69 5d2e 6170         nbs[i].ap
+00008e90: 7065 6e64 286e 2d31 290a 2020 2020 2020  pend(n-1).      
+00008ea0: 2020 2020 2020 6c69 6e6b 5f74 6172 6765        link_targe
+00008eb0: 745b 6c61 7374 5f4b 7374 6172 5d20 3d20  t[last_Kstar] = 
+00008ec0: 690a 2020 2020 2020 2020 2020 2020 2320  i.            # 
+00008ed0: 6c69 6e6b 5f74 6172 6765 745b 6c61 7374  link_target[last
+00008ee0: 5f4b 7374 6172 2b31 3a6c 6173 745f 4b73  _Kstar+1:last_Ks
+00008ef0: 7461 722b 322b 775b 695d 5d20 3d20 6e2d  tar+2+w[i]] = n-
+00008f00: 310a 2020 2020 2020 2020 2020 2020 2320  1.            # 
+00008f10: 6c61 7374 5f4b 7374 6172 202b 3d20 322b  last_Kstar += 2+
+00008f20: 775b 695d 0a20 2020 2020 2020 2020 2020  w[i].           
+00008f30: 206c 696e 6b5f 7461 7267 6574 5b6c 6173   link_target[las
+00008f40: 745f 4b73 7461 722b 315d 203d 206e 2d31  t_Kstar+1] = n-1
+00008f50: 0a20 2020 2020 2020 2020 2020 206c 6173  .            las
+00008f60: 745f 4b73 7461 7220 2b3d 2032 0a0a 2020  t_Kstar += 2..  
+00008f70: 2020 2020 2020 2020 2020 666f 7220 6a6a            for jj
+00008f80: 2069 6e20 7261 6e67 6528 6d29 3a0a 2020   in range(m):.  
+00008f90: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00008fa0: 696e 6372 6561 7365 2077 6569 6768 7420  increase weight 
+00008fb0: 6f66 2073 6f6d 6520 6a20 6e6f 7420 616c  of some j not al
+00008fc0: 7265 6164 7920 6c69 6e6b 6564 2074 6f20  ready linked to 
+00008fd0: 616c 6c3a 0a20 2020 2020 2020 2020 2020  all:.           
+00008fe0: 2020 2020 206a 203d 2069 6e74 2869 6e63       j = int(inc
+00008ff0: 5f74 6172 6765 745b 696e 7428 7261 6e64  _target[int(rand
+00009000: 6f6d 2e75 6e69 666f 726d 286c 6173 745f  om.uniform(last_
+00009010: 5729 295d 290a 2020 2020 2020 2020 2020  W))]).          
+00009020: 2020 2020 2020 7768 696c 6520 6c65 6e28        while len(
+00009030: 6e62 735b 6a5d 2920 3d3d 206e 2d31 3a0a  nbs[j]) == n-1:.
+00009040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009050: 2020 2020 7072 696e 7428 2220 6e6f 7420      print(" not 
+00009060: 6a22 2c20 6a29 0a20 2020 2020 2020 2020  j", j).         
+00009070: 2020 2020 2020 2020 2020 206a 203d 2069             j = i
+00009080: 6e74 2869 6e63 5f74 6172 6765 745b 696e  nt(inc_target[in
+00009090: 7428 7261 6e64 6f6d 2e75 6e69 666f 726d  t(random.uniform
+000090a0: 286c 6173 745f 5729 295d 290a 2020 2020  (last_W))]).    
+000090b0: 2020 2020 2020 2020 2020 2020 775b 6a5d              w[j]
+000090c0: 202b 3d20 310a 2020 2020 2020 2020 2020   += 1.          
+000090d0: 2020 2020 2020 7072 696e 7428 2220 6a6a        print(" jj
+000090e0: 222c 206a 6a2c 2022 6a22 2c20 6a2c 2022  ", jj, "j", j, "
+000090f0: 775b 6a5d 222c 2077 5b6a 5d29 0a20 2020  w[j]", w[j]).   
+00009100: 2020 2020 2020 2020 2020 2020 2069 6e63               inc
+00009110: 5f74 6172 6765 745b 6c61 7374 5f57 5d20  _target[last_W] 
+00009120: 3d20 6a0a 2020 2020 2020 2020 2020 2020  = j.            
+00009130: 2020 2020 6c61 7374 5f57 202b 3d20 310a      last_W += 1.
+00009140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009150: 2320 6c69 6e6b 5f74 6172 6765 745b 6c61  # link_target[la
+00009160: 7374 5f4b 7374 6172 5d20 3d20 6a0a 2020  st_Kstar] = j.  
+00009170: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00009180: 6c61 7374 5f4b 7374 6172 202b 3d20 310a  last_Kstar += 1.
+00009190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000091a0: 2320 666f 7220 6920 696e 206e 6273 5b6a  # for i in nbs[j
+000091b0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+000091c0: 2020 2023 2020 2020 2070 7269 6e74 2822     #     print("
+000091d0: 2020 6922 2c20 6929 0a20 2020 2020 2020    i", i).       
+000091e0: 2020 2020 2020 2020 2023 2020 2020 206c           #     l
+000091f0: 696e 6b5f 7461 7267 6574 5b6c 6173 745f  ink_target[last_
+00009200: 4b73 7461 725d 203d 2069 0a20 2020 2020  Kstar] = i.     
+00009210: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+00009220: 206c 6173 745f 4b73 7461 7220 2b3d 2031   last_Kstar += 1
+00009230: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00009240: 2020 2320 6c69 6e6b 2069 7420 746f 2073    # link it to s
+00009250: 6f6d 6520 6920 6e6f 7420 616c 7265 6164  ome i not alread
+00009260: 7920 6c69 6e6b 6564 2074 6f20 6974 3a0a  y linked to it:.
+00009270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009280: 6920 3d20 696e 7428 6c69 6e6b 5f74 6172  i = int(link_tar
+00009290: 6765 745b 696e 7428 7261 6e64 6f6d 2e75  get[int(random.u
+000092a0: 6e69 666f 726d 286c 6173 745f 4b73 7461  niform(last_Ksta
+000092b0: 7229 295d 290a 2020 2020 2020 2020 2020  r))]).          
+000092c0: 2020 2020 2020 7768 696c 6520 6920 3d3d        while i ==
+000092d0: 206a 206f 7220 415b 692c 206a 5d20 3d3d   j or A[i, j] ==
+000092e0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+000092f0: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
+00009300: 2220 206e 6f74 2069 222c 6929 0a20 2020  "  not i",i).   
+00009310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009320: 2069 203d 2069 6e74 286c 696e 6b5f 7461   i = int(link_ta
+00009330: 7267 6574 5b69 6e74 2872 616e 646f 6d2e  rget[int(random.
+00009340: 756e 6966 6f72 6d28 6c61 7374 5f4b 7374  uniform(last_Kst
+00009350: 6172 2929 5d29 0a20 2020 2020 2020 2020  ar))]).         
+00009360: 2020 2020 2020 2041 5b69 2c20 6a5d 203d         A[i, j] =
+00009370: 2041 5b6a 2c20 695d 203d 2031 0a20 2020   A[j, i] = 1.   
+00009380: 2020 2020 2020 2020 2020 2020 206e 6273               nbs
+00009390: 5b6a 5d2e 6170 7065 6e64 2869 290a 2020  [j].append(i).  
+000093a0: 2020 2020 2020 2020 2020 2020 2020 6e62                nb
+000093b0: 735b 695d 2e61 7070 656e 6428 6a29 0a20  s[i].append(j). 
+000093c0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000093d0: 2070 7269 6e74 2822 2020 6922 2c69 2c22   print("  i",i,"
+000093e0: 6e62 735b 695d 222c 6e62 735b 695d 2c22  nbs[i]",nbs[i],"
+000093f0: 6e62 735b 6a5d 222c 6e62 735b 6a5d 290a  nbs[j]",nbs[j]).
+00009400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009410: 2320 6c69 6e6b 5f74 6172 6765 745b 6c61  # link_target[la
+00009420: 7374 5f4b 7374 6172 3a6c 6173 745f 4b73  st_Kstar:last_Ks
+00009430: 7461 722b 775b 6a5d 5d20 3d20 690a 2020  tar+w[j]] = i.  
+00009440: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00009450: 6c61 7374 5f4b 7374 6172 202b 3d20 775b  last_Kstar += w[
+00009460: 6a5d 0a20 2020 2020 2020 2020 2020 2020  j].             
+00009470: 2020 2023 206c 696e 6b5f 7461 7267 6574     # link_target
+00009480: 5b6c 6173 745f 4b73 7461 723a 6c61 7374  [last_Kstar:last
+00009490: 5f4b 7374 6172 2b77 5b69 5d5d 203d 206a  _Kstar+w[i]] = j
+000094a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000094b0: 2023 206c 6173 745f 4b73 7461 7220 2b3d   # last_Kstar +=
+000094c0: 2077 5b69 5d0a 2020 2020 2020 2020 2020   w[i].          
+000094d0: 2020 2020 2020 6c69 6e6b 5f74 6172 6765        link_targe
+000094e0: 745b 6c61 7374 5f4b 7374 6172 5d20 3d20  t[last_Kstar] = 
+000094f0: 690a 2020 2020 2020 2020 2020 2020 2020  i.              
+00009500: 2020 6c69 6e6b 5f74 6172 6765 745b 6c61    link_target[la
+00009510: 7374 5f4b 7374 6172 2b31 5d20 3d20 6a0a  st_Kstar+1] = j.
+00009520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009530: 6c61 7374 5f4b 7374 6172 202b 3d20 320a  last_Kstar += 2.
+00009540: 0a20 2020 2020 2020 2064 656c 206e 6273  .        del nbs
+00009550: 2c20 6c69 6e6b 5f74 6172 6765 742c 2069  , link_target, i
+00009560: 6e63 5f74 6172 6765 740a 2020 2020 2020  nc_target.      
+00009570: 2020 7265 7475 726e 204e 6574 776f 726b    return Network
+00009580: 2841 2c20 6e6f 6465 5f77 6569 6768 7473  (A, node_weights
+00009590: 3d77 2c20 7369 6c65 6e63 655f 6c65 7665  =w, silence_leve
+000095a0: 6c3d 7369 6c65 6e63 655f 6c65 7665 6c29  l=silence_level)
+000095b0: 0a0a 2020 2020 4073 7461 7469 636d 6574  ..    @staticmet
+000095c0: 686f 640a 2020 2020 6465 6620 4772 6f77  hod.    def Grow
+000095d0: 5072 6566 6572 656e 7469 616c 6c79 286e  Preferentially(n
+000095e0: 5f6e 6f64 6573 3d31 3030 2c20 6e5f 6772  _nodes=100, n_gr
+000095f0: 6f77 7468 733d 312c 206e 5f6c 696e 6b73  owths=1, n_links
+00009600: 5f6e 6577 3d31 2c0a 2020 2020 2020 2020  _new=1,.        
 00009610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009620: 2020 2020 2020 2320 7072 696e 7428 226e        # print("n
-00009630: 6f74 2069 222c 6929 0a20 2020 2020 2020  ot i",i).       
-00009640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009650: 2069 203d 205f 6c69 6e6b 5f74 6172 6765   i = _link_targe
-00009660: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
-00009670: 2020 2020 2020 2020 6966 2041 5b69 2c20          if A[i, 
-00009680: 6a5d 3a0a 2020 2020 2020 2020 2020 2020  j]:.            
-00009690: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-000096a0: 696e 7565 0a20 2020 2020 2020 2020 2020  inue.           
-000096b0: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
-000096c0: 2822 6a22 2c20 6a2c 2022 6922 2c20 6929  ("j", j, "i", i)
-000096d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000096e0: 2020 2020 2041 5b69 2c20 6a5d 203d 2041       A[i, j] = A
-000096f0: 5b6a 2c20 695d 203d 2031 0a20 2020 2020  [j, i] = 1.     
-00009700: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00009710: 6273 5b69 5d2e 6170 7065 6e64 286a 290a  bs[i].append(j).
-00009720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009730: 2020 2020 6e62 735b 6a5d 203d 205b 695d      nbs[j] = [i]
-00009740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009750: 2020 2020 2074 6f74 616c 5f6c 696e 6b5f       total_link_
-00009760: 7072 6f62 202d 3d20 6c69 6e6b 5f70 726f  prob -= link_pro
-00009770: 625b 695d 202b 206c 696e 6b5f 7072 6f62  b[i] + link_prob
-00009780: 5b6a 5d0a 2020 2020 2020 2020 2020 2020  [j].            
-00009790: 2020 2020 2020 2020 6b73 7461 725b 695d          kstar[i]
-000097a0: 202b 3d20 775b 6a5d 0a20 2020 2020 2020   += w[j].       
-000097b0: 2020 2020 2020 2020 2020 2020 206b 7374               kst
-000097c0: 6172 5b6a 5d20 2b3d 2077 5b69 5d0a 2020  ar[j] += w[i].  
-000097d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000097e0: 2020 6c69 6e6b 5f70 726f 625b 695d 203d    link_prob[i] =
-000097f0: 2077 5b69 5d20 2a20 6b73 7461 725b 695d   w[i] * kstar[i]
-00009800: 2a2a 7072 6566 6572 656e 7469 616c 5f65  **preferential_e
-00009810: 7870 6f6e 656e 740a 2020 2020 2020 2020  xponent.        
-00009820: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
-00009830: 5f70 726f 625b 6a5d 203d 2077 5b6a 5d20  _prob[j] = w[j] 
-00009840: 2a20 6b73 7461 725b 6a5d 2a2a 7072 6566  * kstar[j]**pref
-00009850: 6572 656e 7469 616c 5f65 7870 6f6e 656e  erential_exponen
-00009860: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00009870: 2020 2020 2020 746f 7461 6c5f 6c69 6e6b        total_link
-00009880: 5f70 726f 6220 2b3d 206c 696e 6b5f 7072  _prob += link_pr
-00009890: 6f62 5b69 5d20 2b20 6c69 6e6b 5f70 726f  ob[i] + link_pro
-000098a0: 625b 6a5d 0a20 2020 2020 2020 2020 2020  b[j].           
-000098b0: 2020 2020 2023 2070 7269 6e74 2874 6f74       # print(tot
-000098c0: 616c 5f6c 696e 6b5f 7072 6f62 2c20 6c69  al_link_prob, li
-000098d0: 6e6b 5f70 726f 622e 7375 6d28 2929 0a0a  nk_prob.sum())..
-000098e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000098f0: 666f 7220 5f20 696e 2072 616e 6765 286e  for _ in range(n
-00009900: 5f67 726f 7774 6873 293a 0a20 2020 2020  _growths):.     
-00009910: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00009920: 2069 6e63 7265 6173 6520 7765 6967 6874   increase weight
-00009930: 206f 6620 736f 6d65 2069 3a0a 2020 2020   of some i:.    
-00009940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009950: 6920 3d20 696e 635f 7461 7267 6574 5b69  i = inc_target[i
-00009960: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
-00009970: 2020 2020 2020 2020 2020 2020 7261 6e64              rand
-00009980: 6f6d 2e75 6e69 666f 726d 286c 6f77 3d30  om.uniform(low=0
-00009990: 2c20 6869 6768 3d6c 656e 2869 6e63 5f74  , high=len(inc_t
-000099a0: 6172 6765 7429 2929 5d0a 2020 2020 2020  arget)))].      
-000099b0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000099c0: 7072 696e 7428 692c 696e 635f 7461 7267  print(i,inc_targ
-000099d0: 6574 290a 2020 2020 2020 2020 2020 2020  et).            
-000099e0: 2020 2020 2020 2020 746f 7461 6c5f 6c69          total_li
-000099f0: 6e6b 5f70 726f 6220 2d3d 206c 696e 6b5f  nk_prob -= link_
-00009a00: 7072 6f62 5b6e 6273 5b69 5d5d 2e73 756d  prob[nbs[i]].sum
-00009a10: 2829 202b 206c 696e 6b5f 7072 6f62 5b69  () + link_prob[i
-00009a20: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00009a30: 2020 2020 2020 775b 695d 202b 3d20 310a        w[i] += 1.
-00009a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009a50: 2020 2020 696e 635f 7461 7267 6574 2e61      inc_target.a
-00009a60: 7070 656e 6428 6929 0a20 2020 2020 2020  ppend(i).       
-00009a70: 2020 2020 2020 2020 2020 2020 206b 7374               kst
-00009a80: 6172 5b69 5d20 2b3d 2031 0a20 2020 2020  ar[i] += 1.     
-00009a90: 2020 2020 2020 2020 2020 2020 2020 206b                 k
-00009aa0: 7374 6172 5b6e 6273 5b69 5d5d 202b 3d20  star[nbs[i]] += 
-00009ab0: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
-00009ac0: 2020 2020 2020 6c69 6e6b 5f70 726f 625b        link_prob[
-00009ad0: 695d 203d 2077 5b69 5d20 2a20 6b73 7461  i] = w[i] * ksta
-00009ae0: 725b 695d 2a2a 7072 6566 6572 656e 7469  r[i]**preferenti
-00009af0: 616c 5f65 7870 6f6e 656e 740a 2020 2020  al_exponent.    
-00009b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b10: 6c69 6e6b 5f70 726f 625b 6e62 735b 695d  link_prob[nbs[i]
-00009b20: 5d20 3d20 5c0a 2020 2020 2020 2020 2020  ] = \.          
-00009b30: 2020 2020 2020 2020 2020 2020 2020 775b                w[
-00009b40: 6e62 735b 695d 5d20 2a20 6b73 7461 725b  nbs[i]] * kstar[
-00009b50: 6e62 735b 695d 5d2a 2a70 7265 6665 7265  nbs[i]]**prefere
-00009b60: 6e74 6961 6c5f 6578 706f 6e65 6e74 0a20  ntial_exponent. 
-00009b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b80: 2020 2074 6f74 616c 5f6c 696e 6b5f 7072     total_link_pr
-00009b90: 6f62 202b 3d20 6c69 6e6b 5f70 726f 625b  ob += link_prob[
-00009ba0: 6e62 735b 695d 5d2e 7375 6d28 2920 2b20  nbs[i]].sum() + 
-00009bb0: 6c69 6e6b 5f70 726f 625b 695d 0a20 2020  link_prob[i].   
-00009bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009bd0: 2023 2070 7269 6e74 2822 2069 6922 2c69   # print(" ii",i
-00009be0: 692c 2269 222c 692c 2277 5b69 5d22 2c77  i,"i",i,"w[i]",w
-00009bf0: 5b69 5d29 0a20 2020 2020 2020 2020 2020  [i]).           
-00009c00: 2020 2020 2023 2070 7269 6e74 2874 6f74       # print(tot
-00009c10: 616c 5f6c 696e 6b5f 7072 6f62 2c20 6c69  al_link_prob, li
-00009c20: 6e6b 5f70 726f 622e 7375 6d28 2929 0a20  nk_prob.sum()). 
-00009c30: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00009c40: 6f72 2069 6920 696e 2072 616e 6765 286e  or ii in range(n
-00009c50: 5f6c 696e 6b73 5f6f 6c64 293a 0a20 2020  _links_old):.   
-00009c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c70: 2023 206a 3220 3d20 5f6c 696e 6b5f 7461   # j2 = _link_ta
-00009c80: 7267 6574 2829 0a20 2020 2020 2020 2020  rget().         
-00009c90: 2020 2020 2020 2020 2020 206a 3220 3d20             j2 = 
-00009ca0: 696e 635f 7461 7267 6574 5b69 6e74 280a  inc_target[int(.
-00009cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009cc0: 2020 2020 2020 2020 7261 6e64 6f6d 2e75          random.u
-00009cd0: 6e69 666f 726d 286c 6f77 3d30 2c20 6869  niform(low=0, hi
-00009ce0: 6768 3d6c 656e 2869 6e63 5f74 6172 6765  gh=len(inc_targe
-00009cf0: 7429 2929 5d0a 2020 2020 2020 2020 2020  t)))].          
-00009d00: 2020 2020 2020 2020 2020 6920 3d20 5f6c            i = _l
-00009d10: 696e 6b5f 7461 7267 6574 2829 0a20 2020  ink_target().   
-00009d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d30: 2077 6869 6c65 2069 203d 3d20 6a32 3a0a   while i == j2:.
-00009d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d50: 2020 2020 2020 2020 6920 3d20 5f6c 696e          i = _lin
-00009d60: 6b5f 7461 7267 6574 2829 0a20 2020 2020  k_target().     
-00009d70: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00009d80: 6620 415b 692c 206a 325d 3a0a 2020 2020  f A[i, j2]:.    
-00009d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009da0: 2020 2020 636f 6e74 696e 7565 0a20 2020      continue.   
-00009db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009dc0: 2041 5b69 2c20 6a32 5d20 3d20 415b 6a32   A[i, j2] = A[j2
-00009dd0: 2c20 695d 203d 2031 0a20 2020 2020 2020  , i] = 1.       
-00009de0: 2020 2020 2020 2020 2020 2020 206e 6273               nbs
-00009df0: 5b69 5d2e 6170 7065 6e64 286a 3229 0a20  [i].append(j2). 
-00009e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e10: 2020 206e 6273 5b6a 325d 2e61 7070 656e     nbs[j2].appen
-00009e20: 6428 6929 0a20 2020 2020 2020 2020 2020  d(i).           
-00009e30: 2020 2020 2020 2020 2074 6f74 616c 5f6c           total_l
-00009e40: 696e 6b5f 7072 6f62 202d 3d20 6c69 6e6b  ink_prob -= link
-00009e50: 5f70 726f 625b 695d 202b 206c 696e 6b5f  _prob[i] + link_
-00009e60: 7072 6f62 5b6a 325d 0a20 2020 2020 2020  prob[j2].       
-00009e70: 2020 2020 2020 2020 2020 2020 206b 7374               kst
-00009e80: 6172 5b69 5d20 2b3d 2077 5b6a 325d 0a20  ar[i] += w[j2]. 
-00009e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ea0: 2020 206b 7374 6172 5b6a 325d 202b 3d20     kstar[j2] += 
-00009eb0: 775b 695d 0a20 2020 2020 2020 2020 2020  w[i].           
-00009ec0: 2020 2020 2020 2020 206c 696e 6b5f 7072           link_pr
-00009ed0: 6f62 5b69 5d20 3d20 775b 695d 202a 206b  ob[i] = w[i] * k
-00009ee0: 7374 6172 5b69 5d2a 2a70 7265 6665 7265  star[i]**prefere
-00009ef0: 6e74 6961 6c5f 6578 706f 6e65 6e74 0a20  ntial_exponent. 
-00009f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f10: 2020 206c 696e 6b5f 7072 6f62 5b6a 325d     link_prob[j2]
-00009f20: 203d 2077 5b6a 325d 202a 206b 7374 6172   = w[j2] * kstar
-00009f30: 5b6a 325d 2a2a 7072 6566 6572 656e 7469  [j2]**preferenti
-00009f40: 616c 5f65 7870 6f6e 656e 740a 2020 2020  al_exponent.    
-00009f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f60: 746f 7461 6c5f 6c69 6e6b 5f70 726f 6220  total_link_prob 
-00009f70: 2b3d 206c 696e 6b5f 7072 6f62 5b69 5d20  += link_prob[i] 
-00009f80: 2b20 6c69 6e6b 5f70 726f 625b 6a32 5d0a  + link_prob[j2].
-00009f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fa0: 2320 7072 696e 7428 746f 7461 6c5f 6c69  # print(total_li
-00009fb0: 6e6b 5f70 726f 622c 206c 696e 6b5f 7072  nk_prob, link_pr
-00009fc0: 6f62 2e73 756d 2829 290a 0a20 2020 2020  ob.sum())..     
-00009fd0: 2020 2020 2020 2020 2020 2069 6620 6a20             if j 
-00009fe0: 2520 3130 3a0a 2020 2020 2020 2020 2020  % 10:.          
-00009ff0: 2020 2020 2020 2020 2020 7072 6f67 7265            progre
-0000a000: 7373 2e75 7064 6174 6528 6a29 0a0a 2020  ss.update(j)..  
-0000a010: 2020 2020 2020 2020 2020 7072 6f67 7265            progre
-0000a020: 7373 2e66 696e 6973 6828 290a 0a20 2020  ss.finish()..   
-0000a030: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000a040: 2020 2020 2020 206c 696e 6b5f 7461 7267         link_targ
-0000a050: 6574 203d 205b 5d0a 0a20 2020 2020 2020  et = []..       
-0000a060: 2020 2020 2023 2073 7461 7274 2077 6974       # start wit
-0000a070: 6820 2832 2a6e 5f6c 696e 6b73 5f6e 6577  h (2*n_links_new
-0000a080: 2b31 2920 6675 6c6c 7920 636f 6e6e 6563  +1) fully connec
-0000a090: 7465 6420 6e6f 6465 733a 0a20 2020 2020  ted nodes:.     
-0000a0a0: 2020 2020 2020 206e 5f69 6e69 7469 616c         n_initial
-0000a0b0: 7320 3d20 6e5f 6c69 6e6b 735f 6e65 772b  s = n_links_new+
-0000a0c0: 322a 6e5f 6c69 6e6b 735f 6f6c 642b 320a  2*n_links_old+2.
-0000a0d0: 2020 2020 2020 2020 2020 2020 2320 6d61              # ma
-0000a0e0: 7828 6e5f 6c69 6e6b 735f 6e65 772b 322a  x(n_links_new+2*
-0000a0f0: 6e5f 6c69 6e6b 735f 6f6c 642b 322c 206e  n_links_old+2, n
-0000a100: 5f67 726f 7774 6873 2d31 290a 2020 2020  _growths-1).    
-0000a110: 2020 2020 2020 2020 775b 3a6e 5f69 6e69          w[:n_ini
-0000a120: 7469 616c 735d 203d 2031 0a0a 2020 2020  tials] = 1..    
-0000a130: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
-0000a140: 2072 616e 6765 286e 5f69 6e69 7469 616c   range(n_initial
-0000a150: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-0000a160: 2020 2020 666f 7220 6a20 696e 2072 616e      for j in ran
-0000a170: 6765 2869 293a 0a20 2020 2020 2020 2020  ge(i):.         
-0000a180: 2020 2020 2020 2020 2020 2069 6620 6d69             if mi
-0000a190: 6e28 692d 6a2c 206a 2b6e 5f69 6e69 7469  n(i-j, j+n_initi
-0000a1a0: 616c 732d 6929 203c 3d20 5c0a 2020 2020  als-i) <= \.    
-0000a1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1c0: 2020 2020 2020 2020 6e70 2e63 6569 6c28          np.ceil(
-0000a1d0: 286e 5f6c 696e 6b73 5f6e 6577 202b 206e  (n_links_new + n
-0000a1e0: 5f6c 696e 6b73 5f6f 6c64 292f 322e 3029  _links_old)/2.0)
-0000a1f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a200: 2020 2020 2020 2020 2020 415b 692c 206a            A[i, j
-0000a210: 5d20 3d20 415b 6a2c 2069 5d20 3d20 310a  ] = A[j, i] = 1.
-0000a220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a230: 2020 2020 2020 2020 6e62 735b 695d 2e61          nbs[i].a
-0000a240: 7070 656e 6428 6a29 0a20 2020 2020 2020  ppend(j).       
-0000a250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a260: 206e 6273 5b6a 5d2e 6170 7065 6e64 2869   nbs[j].append(i
-0000a270: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000a280: 2020 6c69 6e6b 5f74 6172 6765 7420 2b3d    link_target +=
-0000a290: 205b 6920 666f 7220 5f20 696e 2072 616e   [i for _ in ran
-0000a2a0: 6765 286e 5f6c 696e 6b73 5f6e 6577 202b  ge(n_links_new +
-0000a2b0: 206e 5f6c 696e 6b73 5f6f 6c64 295d 0a0a   n_links_old)]..
-0000a2c0: 2020 2020 2020 2020 2020 2020 2320 6c61              # la
-0000a2d0: 7374 5f67 726f 776e 203d 206e 702e 7a65  st_grown = np.ze
-0000a2e0: 726f 7328 4e29 0a20 2020 2020 2020 2020  ros(N).         
-0000a2f0: 2020 2066 6f72 206a 2069 6e20 7261 6e67     for j in rang
-0000a300: 6528 6e5f 696e 6974 6961 6c73 2c20 4e29  e(n_initials, N)
-0000a310: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a320: 2020 2320 6164 6420 6e6f 6465 206a 2077    # add node j w
-0000a330: 6974 6820 756e 6974 2077 6569 6768 743a  ith unit weight:
-0000a340: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a350: 2077 5b6a 5d20 3d20 310a 2020 2020 2020   w[j] = 1.      
-0000a360: 2020 2020 2020 2020 2020 696e 635f 7461            inc_ta
-0000a370: 7267 6574 2e61 7070 656e 6428 6a29 0a20  rget.append(j). 
-0000a380: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000a390: 696e 6b5f 7461 7267 6574 2e61 7070 656e  ink_target.appen
-0000a3a0: 6428 6a29 0a20 2020 2020 2020 2020 2020  d(j).           
-0000a3b0: 2020 2020 2023 206c 696e 6b20 6974 2074       # link it t
-0000a3c0: 6f20 736f 6d65 2069 2773 3a0a 2020 2020  o some i's:.    
-0000a3d0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0000a3e0: 6969 2069 6e20 7261 6e67 6528 6e5f 6c69  ii in range(n_li
-0000a3f0: 6e6b 735f 6e65 7729 3a0a 2020 2020 2020  nks_new):.      
-0000a400: 2020 2020 2020 2020 2020 2020 2020 6920                i 
-0000a410: 3d20 696e 7428 6c69 6e6b 5f74 6172 6765  = int(link_targe
-0000a420: 745b 696e 7428 0a20 2020 2020 2020 2020  t[int(.         
-0000a430: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000a440: 616e 646f 6d2e 756e 6966 6f72 6d28 6c6f  andom.uniform(lo
-0000a450: 773d 302c 2068 6967 683d 6c65 6e28 6c69  w=0, high=len(li
-0000a460: 6e6b 5f74 6172 6765 7429 2929 5d29 0a20  nk_target)))]). 
-0000a470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a480: 2020 2077 6869 6c65 2069 203d 3d20 6a20     while i == j 
-0000a490: 6f72 2041 5b69 2c20 6a5d 203d 3d20 313a  or A[i, j] == 1:
-0000a4a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a4b0: 2020 2020 2020 2020 2023 2070 7269 6e74           # print
-0000a4c0: 2822 6e6f 7420 6922 2c69 290a 2020 2020  ("not i",i).    
-0000a4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4e0: 2020 2020 6920 3d20 696e 7428 6c69 6e6b      i = int(link
-0000a4f0: 5f74 6172 6765 745b 696e 7428 0a20 2020  _target[int(.   
-0000a500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a510: 2020 2020 2020 2020 2072 616e 646f 6d2e           random.
-0000a520: 756e 6966 6f72 6d28 6c6f 773d 302c 2068  uniform(low=0, h
-0000a530: 6967 683d 6c65 6e28 6c69 6e6b 5f74 6172  igh=len(link_tar
-0000a540: 6765 7429 2929 5d29 0a20 2020 2020 2020  get)))]).       
-0000a550: 2020 2020 2020 2020 2020 2020 2023 2070               # p
-0000a560: 7269 6e74 2822 6a22 2c20 6a2c 2022 6922  rint("j", j, "i"
-0000a570: 2c20 6929 0a20 2020 2020 2020 2020 2020  , i).           
-0000a580: 2020 2020 2020 2020 2041 5b69 2c20 6a5d           A[i, j]
-0000a590: 203d 2041 5b6a 2c20 695d 203d 2031 0a20   = A[j, i] = 1. 
-0000a5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5b0: 2020 206e 6273 5b6a 5d20 3d20 5b69 5d0a     nbs[j] = [i].
-0000a5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5d0: 2020 2020 6e62 735b 695d 2e61 7070 656e      nbs[i].appen
-0000a5e0: 6428 6a29 0a20 2020 2020 2020 2020 2020  d(j).           
-0000a5f0: 2020 2020 2020 2020 206c 696e 6b5f 7461           link_ta
-0000a600: 7267 6574 202b 3d20 5b6a 2066 6f72 2069  rget += [j for i
-0000a610: 6969 2069 6e20 7261 6e67 6528 775b 695d  ii in range(w[i]
-0000a620: 295d 202b 205b 695d 0a20 2020 2020 2020  )] + [i].       
-0000a630: 2020 2020 2020 2020 2066 6f72 2069 6920           for ii 
-0000a640: 696e 2072 616e 6765 286e 5f67 726f 7774  in range(n_growt
-0000a650: 6873 293a 0a20 2020 2020 2020 2020 2020  hs):.           
-0000a660: 2020 2020 2020 2020 2023 2069 6e63 7265           # incre
-0000a670: 6173 6520 7765 6967 6874 206f 6620 736f  ase weight of so
-0000a680: 6d65 2069 3a0a 2020 2020 2020 2020 2020  me i:.          
-0000a690: 2020 2020 2020 2020 2020 6920 3d20 696e            i = in
-0000a6a0: 7428 696e 635f 7461 7267 6574 5b69 6e74  t(inc_target[int
-0000a6b0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000a6c0: 2020 2020 2020 2020 2020 7261 6e64 6f6d            random
-0000a6d0: 2e75 6e69 666f 726d 286c 6f77 3d30 2c20  .uniform(low=0, 
-0000a6e0: 6869 6768 3d6c 656e 2869 6e63 5f74 6172  high=len(inc_tar
-0000a6f0: 6765 7429 2929 5d29 0a20 2020 2020 2020  get)))]).       
-0000a700: 2020 2020 2020 2020 2020 2020 2023 2077               # w
-0000a710: 6869 6c65 206c 6173 745f 6772 6f77 6e5b  hile last_grown[
-0000a720: 695d 203d 3d20 6a3a 0a20 2020 2020 2020  i] == j:.       
-0000a730: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-0000a740: 2020 6920 3d20 696e 7428 696e 635f 7461    i = int(inc_ta
-0000a750: 7267 6574 5b69 6e74 280a 2020 2020 2020  rget[int(.      
-0000a760: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000a770: 2020 2020 2020 2072 616e 646f 6d2e 756e         random.un
-0000a780: 6966 6f72 6d28 6c65 6e28 696e 635f 7461  iform(len(inc_ta
-0000a790: 7267 6574 2929 295d 290a 2020 2020 2020  rget)))]).      
-0000a7a0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000a7b0: 6c61 7374 5f67 726f 776e 5b69 5d20 3d20  last_grown[i] = 
-0000a7c0: 6a0a 2020 2020 2020 2020 2020 2020 2020  j.              
-0000a7d0: 2020 2020 2020 775b 695d 202b 3d20 310a        w[i] += 1.
-0000a7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7f0: 2020 2020 2320 7072 696e 7428 2220 6969      # print(" ii
-0000a800: 222c 6969 2c22 6922 2c69 2c22 775b 695d  ",ii,"i",i,"w[i]
-0000a810: 222c 775b 695d 290a 2020 2020 2020 2020  ",w[i]).        
-0000a820: 2020 2020 2020 2020 2020 2020 696e 635f              inc_
-0000a830: 7461 7267 6574 2e61 7070 656e 6428 6929  target.append(i)
-0000a840: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a850: 2020 2020 206c 696e 6b5f 7461 7267 6574       link_target
-0000a860: 202b 3d20 6e62 735b 695d 202b 205b 695d   += nbs[i] + [i]
-0000a870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a880: 2066 6f72 2069 6920 696e 2072 616e 6765   for ii in range
-0000a890: 286e 5f6c 696e 6b73 5f6f 6c64 293a 0a20  (n_links_old):. 
-0000a8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8b0: 2020 2023 206a 3220 3d20 696e 7428 696e     # j2 = int(in
-0000a8c0: 635f 7461 7267 6574 5b69 6e74 280a 2020  c_target[int(.  
-0000a8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8e0: 2020 2320 2020 2020 2072 616e 646f 6d2e    #      random.
-0000a8f0: 756e 6966 6f72 6d28 6c65 6e28 696e 635f  uniform(len(inc_
-0000a900: 7461 7267 6574 2929 295d 290a 2020 2020  target)))]).    
-0000a910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a920: 6a32 203d 2069 6e74 286c 696e 6b5f 7461  j2 = int(link_ta
-0000a930: 7267 6574 5b69 6e74 280a 2020 2020 2020  rget[int(.      
+00009620: 2020 206e 5f6c 696e 6b73 5f6f 6c64 3d31     n_links_old=1
+00009630: 2c20 6e73 693d 5472 7565 2c20 7072 6566  , nsi=True, pref
+00009640: 6572 656e 7469 616c 5f65 7870 6f6e 656e  erential_exponen
+00009650: 743d 312c 0a20 2020 2020 2020 2020 2020  t=1,.           
+00009660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009670: 6e5f 696e 6974 6961 6c73 3d31 2c20 7369  n_initials=1, si
+00009680: 6c65 6e63 655f 6c65 7665 6c3d 3029 3a0a  lence_level=0):.
+00009690: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000096a0: 2020 2020 4558 5045 5249 4d45 4e54 414c      EXPERIMENTAL
+000096b0: 3a20 5265 7475 726e 2061 2072 616e 646f  : Return a rando
+000096c0: 6d20 6e65 7477 6f72 6b20 6772 6f77 6e20  m network grown 
+000096d0: 7769 7468 2070 7265 6665 7265 6e74 6961  with preferentia
+000096e0: 6c20 7765 6967 6874 0a20 2020 2020 2020  l weight.       
+000096f0: 2069 6e63 7265 6173 6520 616e 6420 6e2e   increase and n.
+00009700: 732e 692e 2070 7265 6665 7265 6e74 6961  s.i. preferentia
+00009710: 6c20 6174 7461 6368 6d65 6e74 2e0a 0a20  l attachment... 
+00009720: 2020 2020 2020 2052 6574 7572 6e20 6120         Return a 
+00009730: 7261 6e64 6f6d 206e 6574 776f 726b 2067  random network g
+00009740: 726f 776e 2061 7320 666f 6c6c 6f77 733a  rown as follows:
+00009750: 2053 7461 7274 696e 6720 7769 7468 2061   Starting with a
+00009760: 2063 6c69 7175 650a 2020 2020 2020 2020   clique.        
+00009770: 6f66 2032 2a6e 5f6c 696e 6b73 5f6e 6577  of 2*n_links_new
+00009780: 2b31 2075 6e69 7420 7765 6967 6874 206e  +1 unit weight n
+00009790: 6f64 6573 2c20 6974 6572 6174 6976 656c  odes, iterativel
+000097a0: 7920 6164 6420 6120 756e 6974 2077 6569  y add a unit wei
+000097b0: 6768 740a 2020 2020 2020 2020 6e6f 6465  ght.        node
+000097c0: 2c20 636f 6e6e 6563 7420 6974 2077 6974  , connect it wit
+000097d0: 6820 6e5f 6c69 6e6b 735f 6e65 7720 6469  h n_links_new di
+000097e0: 6666 6572 656e 7420 6578 6973 7469 6e67  fferent existing
+000097f0: 206e 6f64 6573 2063 686f 7365 6e0a 2020   nodes chosen.  
+00009800: 2020 2020 2020 7769 7468 2070 726f 6261        with proba
+00009810: 6269 6c69 7469 6573 2070 726f 706f 7274  bilities proport
+00009820: 696f 6e61 6c20 746f 2074 6865 6972 2063  ional to their c
+00009830: 7572 7265 6e74 206e 2e73 2e69 2e20 6465  urrent n.s.i. de
+00009840: 6772 6565 2c20 7468 656e 0a20 2020 2020  gree, then.     
+00009850: 2020 2069 6e63 7265 6173 6520 7468 6520     increase the 
+00009860: 7765 6967 6874 7320 6f66 206e 5f67 726f  weights of n_gro
+00009870: 7774 6873 206e 6f64 6573 2063 686f 7365  wths nodes chose
+00009880: 6e20 7769 7468 2070 726f 6261 6269 6c69  n with probabili
+00009890: 7469 6573 0a20 2020 2020 2020 2070 726f  ties.        pro
+000098a0: 706f 7274 696f 6e61 6c20 746f 2074 6865  portional to the
+000098b0: 6972 2063 7572 7265 6e74 2077 6569 6768  ir current weigh
+000098c0: 7420 2877 6974 6820 7265 706c 6163 656d  t (with replacem
+000098d0: 656e 7429 2c20 7468 656e 2061 6464 0a20  ent), then add. 
+000098e0: 2020 2020 2020 206e 5f6c 696e 6b73 5f6f         n_links_o
+000098f0: 6c64 206e 6577 206c 696e 6b73 2062 6574  ld new links bet
+00009900: 7765 656e 2070 6169 7273 206f 6620 6e6f  ween pairs of no
+00009910: 6465 7320 6368 6f73 656e 2077 6974 6820  des chosen with 
+00009920: 7072 6f62 6162 696c 6974 6965 730a 2020  probabilities.  
+00009930: 2020 2020 2020 7072 6f70 6f72 7469 6f6e        proportion
+00009940: 616c 2074 6f20 7468 6569 7220 6375 7272  al to their curr
+00009950: 656e 7420 7765 6967 6874 2e0a 0a20 2020  ent weight...   
+00009960: 2020 2020 203a 7479 7065 2073 696c 656e       :type silen
+00009970: 6365 5f6c 6576 656c 3a20 696e 7420 3e3d  ce_level: int >=
+00009980: 2030 0a20 2020 2020 2020 203a 6172 6720   0.        :arg 
+00009990: 2073 696c 656e 6365 5f6c 6576 656c 3a20   silence_level: 
+000099a0: 5468 6520 6869 6768 6572 2c20 7468 6520  The higher, the 
+000099b0: 6c65 7373 2070 726f 6772 6573 7320 696e  less progress in
+000099c0: 666f 2069 7320 6f75 7470 7574 2e0a 2020  fo is output..  
+000099d0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000099e0: 2020 4e20 3d20 6e5f 6e6f 6465 730a 2020    N = n_nodes.  
+000099f0: 2020 2020 2020 772c 2041 203d 206e 702e        w, A = np.
+00009a00: 7a65 726f 7328 4e2c 2064 7479 7065 3d69  zeros(N, dtype=i
+00009a10: 6e74 292c 2073 702e 6c69 6c5f 6d61 7472  nt), sp.lil_matr
+00009a20: 6978 2828 4e2c 204e 2929 0a20 2020 2020  ix((N, N)).     
+00009a30: 2020 206e 6273 203d 205b 5b5d 2066 6f72     nbs = [[] for
+00009a40: 2069 2069 6e20 7261 6e67 6528 4e29 5d0a   i in range(N)].
+00009a50: 2020 2020 2020 2020 696e 635f 7461 7267          inc_targ
+00009a60: 6574 203d 206c 6973 7428 7261 6e67 6528  et = list(range(
+00009a70: 6e5f 696e 6974 6961 6c73 2929 0a0a 2020  n_initials))..  
+00009a80: 2020 2020 2020 6966 206e 7369 3a0a 2020        if nsi:.  
+00009a90: 2020 2020 2020 2020 2020 6b73 7461 7220            kstar 
+00009aa0: 3d20 6e70 2e7a 6572 6f73 284e 290a 2020  = np.zeros(N).  
+00009ab0: 2020 2020 2020 2020 2020 6c69 6e6b 5f70            link_p
+00009ac0: 726f 6220 3d20 6e70 2e7a 6572 6f73 284e  rob = np.zeros(N
+00009ad0: 2920 2023 2077 202a 206b 7374 6172 0a0a  )  # w * kstar..
+00009ae0: 2020 2020 2020 2020 2020 2020 775b 3a6e              w[:n
+00009af0: 5f69 6e69 7469 616c 735d 203d 2031 0a20  _initials] = 1. 
+00009b00: 2020 2020 2020 2020 2020 206c 696e 6b5f             link_
+00009b10: 7072 6f62 5b3a 6e5f 696e 6974 6961 6c73  prob[:n_initials
+00009b20: 5d20 3d20 310a 2020 2020 2020 2020 2020  ] = 1.          
+00009b30: 2020 746f 7461 6c5f 6c69 6e6b 5f70 726f    total_link_pro
+00009b40: 6220 3d20 6c69 6e6b 5f70 726f 622e 7375  b = link_prob.su
+00009b50: 6d28 290a 0a20 2020 2020 2020 2020 2020  m()..           
+00009b60: 2064 6566 205f 6c69 6e6b 5f74 6172 6765   def _link_targe
+00009b70: 7428 293a 0a20 2020 2020 2020 2020 2020  t():.           
+00009b80: 2020 2020 2074 6864 203d 2072 616e 646f       thd = rando
+00009b90: 6d2e 756e 6966 6f72 6d28 6c6f 773d 302c  m.uniform(low=0,
+00009ba0: 2068 6967 683d 746f 7461 6c5f 6c69 6e6b   high=total_link
+00009bb0: 5f70 726f 6229 0a20 2020 2020 2020 2020  _prob).         
+00009bc0: 2020 2020 2020 2069 203d 2030 0a20 2020         i = 0.   
+00009bd0: 2020 2020 2020 2020 2020 2020 2063 756d               cum
+00009be0: 203d 206c 696e 6b5f 7072 6f62 5b30 5d0a   = link_prob[0].
+00009bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c00: 7768 696c 6520 6375 6d20 3c20 7468 643a  while cum < thd:
+00009c10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009c20: 2020 2020 2069 202b 3d20 310a 2020 2020       i += 1.    
+00009c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c40: 6375 6d20 2b3d 206c 696e 6b5f 7072 6f62  cum += link_prob
+00009c50: 5b69 5d0a 2020 2020 2020 2020 2020 2020  [i].            
+00009c60: 2020 2020 7265 7475 726e 2069 0a0a 2020      return i..  
+00009c70: 2020 2020 2020 2020 2020 666f 7220 6a20            for j 
+00009c80: 696e 2074 7261 6e67 6528 6e5f 696e 6974  in trange(n_init
+00009c90: 6961 6c73 2c20 4e29 3a0a 2020 2020 2020  ials, N):.      
+00009ca0: 2020 2020 2020 2020 2020 2320 6164 6420            # add 
+00009cb0: 6e6f 6465 206a 2077 6974 6820 756e 6974  node j with unit
+00009cc0: 2077 6569 6768 743a 0a20 2020 2020 2020   weight:.       
+00009cd0: 2020 2020 2020 2020 206c 696e 6b5f 7072           link_pr
+00009ce0: 6f62 5b6a 5d20 3d20 6b73 7461 725b 6a5d  ob[j] = kstar[j]
+00009cf0: 203d 2077 5b6a 5d20 3d20 310a 2020 2020   = w[j] = 1.    
+00009d00: 2020 2020 2020 2020 2020 2020 746f 7461              tota
+00009d10: 6c5f 6c69 6e6b 5f70 726f 6220 2b3d 2031  l_link_prob += 1
+00009d20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009d30: 2069 6e63 5f74 6172 6765 742e 6170 7065   inc_target.appe
+00009d40: 6e64 286a 290a 2020 2020 2020 2020 2020  nd(j).          
+00009d50: 2020 2020 2020 2320 6c69 6e6b 2069 7420        # link it 
+00009d60: 746f 2073 6f6d 6520 6927 733a 0a20 2020  to some i's:.   
+00009d70: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00009d80: 205f 2069 6e20 7261 6e67 6528 6e5f 6c69   _ in range(n_li
+00009d90: 6e6b 735f 6e65 7729 3a0a 2020 2020 2020  nks_new):.      
+00009da0: 2020 2020 2020 2020 2020 2020 2020 6920                i 
+00009db0: 3d20 5f6c 696e 6b5f 7461 7267 6574 2829  = _link_target()
+00009dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009dd0: 2020 2020 2023 2070 7269 6e74 286a 2c69       # print(j,i
+00009de0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00009df0: 2020 2020 2020 7768 696c 6520 6920 3d3d        while i ==
+00009e00: 206a 3a0a 2020 2020 2020 2020 2020 2020   j:.            
+00009e10: 2020 2020 2020 2020 2020 2020 2320 7072              # pr
+00009e20: 696e 7428 226e 6f74 2069 222c 6929 0a20  int("not i",i). 
+00009e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e40: 2020 2020 2020 2069 203d 205f 6c69 6e6b         i = _link
+00009e50: 5f74 6172 6765 7428 290a 2020 2020 2020  _target().      
+00009e60: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00009e70: 2041 5b69 2c20 6a5d 3a0a 2020 2020 2020   A[i, j]:.      
+00009e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e90: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+00009ea0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00009eb0: 2070 7269 6e74 2822 6a22 2c20 6a2c 2022   print("j", j, "
+00009ec0: 6922 2c20 6929 0a20 2020 2020 2020 2020  i", i).         
+00009ed0: 2020 2020 2020 2020 2020 2041 5b69 2c20             A[i, 
+00009ee0: 6a5d 203d 2041 5b6a 2c20 695d 203d 2031  j] = A[j, i] = 1
+00009ef0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009f00: 2020 2020 206e 6273 5b69 5d2e 6170 7065       nbs[i].appe
+00009f10: 6e64 286a 290a 2020 2020 2020 2020 2020  nd(j).          
+00009f20: 2020 2020 2020 2020 2020 6e62 735b 6a5d            nbs[j]
+00009f30: 203d 205b 695d 0a20 2020 2020 2020 2020   = [i].         
+00009f40: 2020 2020 2020 2020 2020 2074 6f74 616c             total
+00009f50: 5f6c 696e 6b5f 7072 6f62 202d 3d20 6c69  _link_prob -= li
+00009f60: 6e6b 5f70 726f 625b 695d 202b 206c 696e  nk_prob[i] + lin
+00009f70: 6b5f 7072 6f62 5b6a 5d0a 2020 2020 2020  k_prob[j].      
+00009f80: 2020 2020 2020 2020 2020 2020 2020 6b73                ks
+00009f90: 7461 725b 695d 202b 3d20 775b 6a5d 0a20  tar[i] += w[j]. 
+00009fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009fb0: 2020 206b 7374 6172 5b6a 5d20 2b3d 2077     kstar[j] += w
+00009fc0: 5b69 5d0a 2020 2020 2020 2020 2020 2020  [i].            
+00009fd0: 2020 2020 2020 2020 6c69 6e6b 5f70 726f          link_pro
+00009fe0: 625b 695d 203d 2077 5b69 5d20 2a20 6b73  b[i] = w[i] * ks
+00009ff0: 7461 725b 695d 2a2a 7072 6566 6572 656e  tar[i]**preferen
+0000a000: 7469 616c 5f65 7870 6f6e 656e 740a 2020  tial_exponent.  
+0000a010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a020: 2020 6c69 6e6b 5f70 726f 625b 6a5d 203d    link_prob[j] =
+0000a030: 2077 5b6a 5d20 2a20 6b73 7461 725b 6a5d   w[j] * kstar[j]
+0000a040: 2a2a 7072 6566 6572 656e 7469 616c 5f65  **preferential_e
+0000a050: 7870 6f6e 656e 740a 2020 2020 2020 2020  xponent.        
+0000a060: 2020 2020 2020 2020 2020 2020 746f 7461              tota
+0000a070: 6c5f 6c69 6e6b 5f70 726f 6220 2b3d 206c  l_link_prob += l
+0000a080: 696e 6b5f 7072 6f62 5b69 5d20 2b20 6c69  ink_prob[i] + li
+0000a090: 6e6b 5f70 726f 625b 6a5d 0a20 2020 2020  nk_prob[j].     
+0000a0a0: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
+0000a0b0: 6e74 2874 6f74 616c 5f6c 696e 6b5f 7072  nt(total_link_pr
+0000a0c0: 6f62 2c20 6c69 6e6b 5f70 726f 622e 7375  ob, link_prob.su
+0000a0d0: 6d28 2929 0a0a 2020 2020 2020 2020 2020  m())..          
+0000a0e0: 2020 2020 2020 666f 7220 5f20 696e 2072        for _ in r
+0000a0f0: 616e 6765 286e 5f67 726f 7774 6873 293a  ange(n_growths):
+0000a100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a110: 2020 2020 2023 2069 6e63 7265 6173 6520       # increase 
+0000a120: 7765 6967 6874 206f 6620 736f 6d65 2069  weight of some i
+0000a130: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000a140: 2020 2020 2020 6920 3d20 696e 635f 7461        i = inc_ta
+0000a150: 7267 6574 5b69 6e74 280a 2020 2020 2020  rget[int(.      
+0000a160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a170: 2020 7261 6e64 6f6d 2e75 6e69 666f 726d    random.uniform
+0000a180: 286c 6f77 3d30 2c20 6869 6768 3d6c 656e  (low=0, high=len
+0000a190: 2869 6e63 5f74 6172 6765 7429 2929 5d0a  (inc_target)))].
+0000a1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1b0: 2020 2020 2320 7072 696e 7428 692c 696e      # print(i,in
+0000a1c0: 635f 7461 7267 6574 290a 2020 2020 2020  c_target).      
+0000a1d0: 2020 2020 2020 2020 2020 2020 2020 746f                to
+0000a1e0: 7461 6c5f 6c69 6e6b 5f70 726f 6220 2d3d  tal_link_prob -=
+0000a1f0: 206c 696e 6b5f 7072 6f62 5b6e 6273 5b69   link_prob[nbs[i
+0000a200: 5d5d 2e73 756d 2829 202b 206c 696e 6b5f  ]].sum() + link_
+0000a210: 7072 6f62 5b69 5d0a 2020 2020 2020 2020  prob[i].        
+0000a220: 2020 2020 2020 2020 2020 2020 775b 695d              w[i]
+0000a230: 202b 3d20 310a 2020 2020 2020 2020 2020   += 1.          
+0000a240: 2020 2020 2020 2020 2020 696e 635f 7461            inc_ta
+0000a250: 7267 6574 2e61 7070 656e 6428 6929 0a20  rget.append(i). 
+0000a260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a270: 2020 206b 7374 6172 5b69 5d20 2b3d 2031     kstar[i] += 1
+0000a280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a290: 2020 2020 206b 7374 6172 5b6e 6273 5b69       kstar[nbs[i
+0000a2a0: 5d5d 202b 3d20 310a 2020 2020 2020 2020  ]] += 1.        
+0000a2b0: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+0000a2c0: 5f70 726f 625b 695d 203d 2077 5b69 5d20  _prob[i] = w[i] 
+0000a2d0: 2a20 6b73 7461 725b 695d 2a2a 7072 6566  * kstar[i]**pref
+0000a2e0: 6572 656e 7469 616c 5f65 7870 6f6e 656e  erential_exponen
+0000a2f0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+0000a300: 2020 2020 2020 6c69 6e6b 5f70 726f 625b        link_prob[
+0000a310: 6e62 735b 695d 5d20 3d20 5c0a 2020 2020  nbs[i]] = \.    
+0000a320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a330: 2020 2020 775b 6e62 735b 695d 5d20 2a20      w[nbs[i]] * 
+0000a340: 6b73 7461 725b 6e62 735b 695d 5d2a 2a70  kstar[nbs[i]]**p
+0000a350: 7265 6665 7265 6e74 6961 6c5f 6578 706f  referential_expo
+0000a360: 6e65 6e74 0a20 2020 2020 2020 2020 2020  nent.           
+0000a370: 2020 2020 2020 2020 2074 6f74 616c 5f6c           total_l
+0000a380: 696e 6b5f 7072 6f62 202b 3d20 6c69 6e6b  ink_prob += link
+0000a390: 5f70 726f 625b 6e62 735b 695d 5d2e 7375  _prob[nbs[i]].su
+0000a3a0: 6d28 2920 2b20 6c69 6e6b 5f70 726f 625b  m() + link_prob[
+0000a3b0: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
+0000a3c0: 2020 2020 2020 2023 2070 7269 6e74 2822         # print("
+0000a3d0: 2069 6922 2c69 692c 2269 222c 692c 2277   ii",ii,"i",i,"w
+0000a3e0: 5b69 5d22 2c77 5b69 5d29 0a20 2020 2020  [i]",w[i]).     
+0000a3f0: 2020 2020 2020 2020 2020 2023 2070 7269             # pri
+0000a400: 6e74 2874 6f74 616c 5f6c 696e 6b5f 7072  nt(total_link_pr
+0000a410: 6f62 2c20 6c69 6e6b 5f70 726f 622e 7375  ob, link_prob.su
+0000a420: 6d28 2929 0a20 2020 2020 2020 2020 2020  m()).           
+0000a430: 2020 2020 2066 6f72 2069 6920 696e 2072       for ii in r
+0000a440: 616e 6765 286e 5f6c 696e 6b73 5f6f 6c64  ange(n_links_old
+0000a450: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000a460: 2020 2020 2020 2023 206a 3220 3d20 5f6c         # j2 = _l
+0000a470: 696e 6b5f 7461 7267 6574 2829 0a20 2020  ink_target().   
+0000a480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a490: 206a 3220 3d20 696e 635f 7461 7267 6574   j2 = inc_target
+0000a4a0: 5b69 6e74 280a 2020 2020 2020 2020 2020  [int(.          
+0000a4b0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+0000a4c0: 6e64 6f6d 2e75 6e69 666f 726d 286c 6f77  ndom.uniform(low
+0000a4d0: 3d30 2c20 6869 6768 3d6c 656e 2869 6e63  =0, high=len(inc
+0000a4e0: 5f74 6172 6765 7429 2929 5d0a 2020 2020  _target)))].    
+0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a500: 6920 3d20 5f6c 696e 6b5f 7461 7267 6574  i = _link_target
+0000a510: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+0000a520: 2020 2020 2020 2077 6869 6c65 2069 203d         while i =
+0000a530: 3d20 6a32 3a0a 2020 2020 2020 2020 2020  = j2:.          
+0000a540: 2020 2020 2020 2020 2020 2020 2020 6920                i 
+0000a550: 3d20 5f6c 696e 6b5f 7461 7267 6574 2829  = _link_target()
+0000a560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a570: 2020 2020 2069 6620 415b 692c 206a 325d       if A[i, j2]
+0000a580: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000a590: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+0000a5a0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+0000a5b0: 2020 2020 2020 2041 5b69 2c20 6a32 5d20         A[i, j2] 
+0000a5c0: 3d20 415b 6a32 2c20 695d 203d 2031 0a20  = A[j2, i] = 1. 
+0000a5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a5e0: 2020 206e 6273 5b69 5d2e 6170 7065 6e64     nbs[i].append
+0000a5f0: 286a 3229 0a20 2020 2020 2020 2020 2020  (j2).           
+0000a600: 2020 2020 2020 2020 206e 6273 5b6a 325d           nbs[j2]
+0000a610: 2e61 7070 656e 6428 6929 0a20 2020 2020  .append(i).     
+0000a620: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000a630: 6f74 616c 5f6c 696e 6b5f 7072 6f62 202d  otal_link_prob -
+0000a640: 3d20 6c69 6e6b 5f70 726f 625b 695d 202b  = link_prob[i] +
+0000a650: 206c 696e 6b5f 7072 6f62 5b6a 325d 0a20   link_prob[j2]. 
+0000a660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a670: 2020 206b 7374 6172 5b69 5d20 2b3d 2077     kstar[i] += w
+0000a680: 5b6a 325d 0a20 2020 2020 2020 2020 2020  [j2].           
+0000a690: 2020 2020 2020 2020 206b 7374 6172 5b6a           kstar[j
+0000a6a0: 325d 202b 3d20 775b 695d 0a20 2020 2020  2] += w[i].     
+0000a6b0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000a6c0: 696e 6b5f 7072 6f62 5b69 5d20 3d20 775b  ink_prob[i] = w[
+0000a6d0: 695d 202a 206b 7374 6172 5b69 5d2a 2a70  i] * kstar[i]**p
+0000a6e0: 7265 6665 7265 6e74 6961 6c5f 6578 706f  referential_expo
+0000a6f0: 6e65 6e74 0a20 2020 2020 2020 2020 2020  nent.           
+0000a700: 2020 2020 2020 2020 206c 696e 6b5f 7072           link_pr
+0000a710: 6f62 5b6a 325d 203d 2077 5b6a 325d 202a  ob[j2] = w[j2] *
+0000a720: 206b 7374 6172 5b6a 325d 2a2a 7072 6566   kstar[j2]**pref
+0000a730: 6572 656e 7469 616c 5f65 7870 6f6e 656e  erential_exponen
+0000a740: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+0000a750: 2020 2020 2020 746f 7461 6c5f 6c69 6e6b        total_link
+0000a760: 5f70 726f 6220 2b3d 206c 696e 6b5f 7072  _prob += link_pr
+0000a770: 6f62 5b69 5d20 2b20 6c69 6e6b 5f70 726f  ob[i] + link_pro
+0000a780: 625b 6a32 5d0a 2020 2020 2020 2020 2020  b[j2].          
+0000a790: 2020 2020 2020 2320 7072 696e 7428 746f        # print(to
+0000a7a0: 7461 6c5f 6c69 6e6b 5f70 726f 622c 206c  tal_link_prob, l
+0000a7b0: 696e 6b5f 7072 6f62 2e73 756d 2829 290a  ink_prob.sum()).
+0000a7c0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0000a7d0: 2020 2020 2020 2020 2020 206c 696e 6b5f             link_
+0000a7e0: 7461 7267 6574 203d 205b 5d0a 0a20 2020  target = []..   
+0000a7f0: 2020 2020 2020 2020 2023 2073 7461 7274           # start
+0000a800: 2077 6974 6820 2832 2a6e 5f6c 696e 6b73   with (2*n_links
+0000a810: 5f6e 6577 2b31 2920 6675 6c6c 7920 636f  _new+1) fully co
+0000a820: 6e6e 6563 7465 6420 6e6f 6465 733a 0a20  nnected nodes:. 
+0000a830: 2020 2020 2020 2020 2020 206e 5f69 6e69             n_ini
+0000a840: 7469 616c 7320 3d20 6e5f 6c69 6e6b 735f  tials = n_links_
+0000a850: 6e65 772b 322a 6e5f 6c69 6e6b 735f 6f6c  new+2*n_links_ol
+0000a860: 642b 320a 2020 2020 2020 2020 2020 2020  d+2.            
+0000a870: 2320 6d61 7828 6e5f 6c69 6e6b 735f 6e65  # max(n_links_ne
+0000a880: 772b 322a 6e5f 6c69 6e6b 735f 6f6c 642b  w+2*n_links_old+
+0000a890: 322c 206e 5f67 726f 7774 6873 2d31 290a  2, n_growths-1).
+0000a8a0: 2020 2020 2020 2020 2020 2020 775b 3a6e              w[:n
+0000a8b0: 5f69 6e69 7469 616c 735d 203d 2031 0a0a  _initials] = 1..
+0000a8c0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0000a8d0: 6920 696e 2072 616e 6765 286e 5f69 6e69  i in range(n_ini
+0000a8e0: 7469 616c 7329 3a0a 2020 2020 2020 2020  tials):.        
+0000a8f0: 2020 2020 2020 2020 666f 7220 6a20 696e          for j in
+0000a900: 2072 616e 6765 2869 293a 0a20 2020 2020   range(i):.     
+0000a910: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000a920: 6620 6d69 6e28 692d 6a2c 206a 2b6e 5f69  f min(i-j, j+n_i
+0000a930: 6e69 7469 616c 732d 6929 203c 3d20 5c0a  nitials-i) <= \.
 0000a940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a950: 2020 7261 6e64 6f6d 2e75 6e69 666f 726d    random.uniform
-0000a960: 286c 6f77 3d30 2c20 6869 6768 3d6c 656e  (low=0, high=len
-0000a970: 286c 696e 6b5f 7461 7267 6574 2929 295d  (link_target)))]
-0000a980: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000a990: 2020 2020 2020 2320 6920 3d20 696e 7428        # i = int(
-0000a9a0: 696e 635f 7461 7267 6574 5b69 6e74 280a  inc_target[int(.
-0000a9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a9c0: 2020 2020 2320 2020 2020 7261 6e64 6f6d      #     random
-0000a9d0: 2e75 6e69 666f 726d 286c 656e 2869 6e63  .uniform(len(inc
-0000a9e0: 5f74 6172 6765 7429 2929 5d29 0a20 2020  _target)))]).   
-0000a9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa00: 2069 203d 2069 6e74 286c 696e 6b5f 7461   i = int(link_ta
-0000aa10: 7267 6574 5b69 6e74 280a 2020 2020 2020  rget[int(.      
-0000aa20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa30: 2020 7261 6e64 6f6d 2e75 6e69 666f 726d    random.uniform
-0000aa40: 286c 6f77 3d30 2c20 6869 6768 3d6c 656e  (low=0, high=len
-0000aa50: 286c 696e 6b5f 7461 7267 6574 2929 295d  (link_target)))]
-0000aa60: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000aa70: 2020 2020 2020 7768 696c 6520 6920 3d3d        while i ==
-0000aa80: 206a 3220 6f72 2041 5b69 2c20 6a32 5d20   j2 or A[i, j2] 
-0000aa90: 3d3d 2031 3a0a 2020 2020 2020 2020 2020  == 1:.          
-0000aaa0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000aab0: 6920 3d20 696e 7428 696e 635f 7461 7267  i = int(inc_targ
-0000aac0: 6574 5b69 6e74 280a 2020 2020 2020 2020  et[int(.        
-0000aad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aae0: 2320 2020 2020 7261 6e64 6f6d 2e75 6e69  #     random.uni
-0000aaf0: 666f 726d 286c 656e 2869 6e63 5f74 6172  form(len(inc_tar
-0000ab00: 6765 7429 2929 5d29 0a20 2020 2020 2020  get)))]).       
-0000ab10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab20: 2069 203d 2069 6e74 286c 696e 6b5f 7461   i = int(link_ta
-0000ab30: 7267 6574 5b69 6e74 280a 2020 2020 2020  rget[int(.      
-0000ab40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab50: 2020 2020 2020 7261 6e64 6f6d 2e75 6e69        random.uni
-0000ab60: 666f 726d 286c 6f77 3d30 2c20 6869 6768  form(low=0, high
-0000ab70: 3d6c 656e 286c 696e 6b5f 7461 7267 6574  =len(link_target
-0000ab80: 2929 295d 290a 2020 2020 2020 2020 2020  )))]).          
-0000ab90: 2020 2020 2020 2020 2020 415b 692c 206a            A[i, j
-0000aba0: 325d 203d 2041 5b6a 322c 2069 5d20 3d20  2] = A[j2, i] = 
-0000abb0: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
-0000abc0: 2020 2020 2020 6e62 735b 6a32 5d2e 6170        nbs[j2].ap
-0000abd0: 7065 6e64 2869 290a 2020 2020 2020 2020  pend(i).        
-0000abe0: 2020 2020 2020 2020 2020 2020 6e62 735b              nbs[
-0000abf0: 695d 2e61 7070 656e 6428 6a32 290a 2020  i].append(j2).  
-0000ac00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac10: 2020 6c69 6e6b 5f74 6172 6765 7420 2b3d    link_target +=
-0000ac20: 205b 6a32 2066 6f72 2069 6969 2069 6e20   [j2 for iii in 
-0000ac30: 7261 6e67 6528 775b 695d 295d 202b 205c  range(w[i])] + \
-0000ac40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ac50: 2020 2020 2020 2020 205b 6920 666f 7220           [i for 
-0000ac60: 6969 6920 696e 2072 616e 6765 2877 5b6a  iii in range(w[j
-0000ac70: 325d 295d 0a0a 2020 2020 2020 2020 2020  2])]..          
-0000ac80: 2020 6465 6c20 6c69 6e6b 5f74 6172 6765    del link_targe
-0000ac90: 740a 0a20 2020 2020 2020 2064 656c 206e  t..        del n
-0000aca0: 6273 2c20 696e 635f 7461 7267 6574 0a20  bs, inc_target. 
-0000acb0: 2020 2020 2020 2072 6574 7572 6e20 4e65         return Ne
-0000acc0: 7477 6f72 6b28 412c 206e 6f64 655f 7765  twork(A, node_we
-0000acd0: 6967 6874 733d 772c 2073 696c 656e 6365  ights=w, silence
-0000ace0: 5f6c 6576 656c 3d73 696c 656e 6365 5f6c  _level=silence_l
-0000acf0: 6576 656c 290a 0a20 2020 2040 7374 6174  evel)..    @stat
-0000ad00: 6963 6d65 7468 6f64 0a20 2020 2064 6566  icmethod.    def
-0000ad10: 2047 726f 7757 6569 6768 7473 286e 5f6e   GrowWeights(n_n
-0000ad20: 6f64 6573 3d31 3030 2c20 6e5f 696e 6974  odes=100, n_init
-0000ad30: 6961 6c73 3d31 2c20 6578 706f 6e65 6e74  ials=1, exponent
-0000ad40: 3d31 2c0a 2020 2020 2020 2020 2020 2020  =1,.            
-0000ad50: 2020 2020 2020 2020 6d6f 6465 3d22 6578          mode="ex
-0000ad60: 7022 2c0a 2020 2020 2020 2020 2020 2020  p",.            
-0000ad70: 2020 2020 2020 2020 7370 6c69 745f 7072          split_pr
-0000ad80: 6f62 3d2e 3031 2c20 2023 2066 6f72 2065  ob=.01,  # for e
-0000ad90: 7870 6f6e 656e 7469 616c 206d 6f64 656c  xponential model
-0000ada0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000adb0: 2020 2020 2073 706c 6974 5f77 6569 6768       split_weigh
-0000adc0: 743d 3130 302c 2020 2320 666f 7220 7265  t=100,  # for re
-0000add0: 6369 7072 6f63 616c 206d 6f64 656c 0a20  ciprocal model. 
-0000ade0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000adf0: 2020 2062 6574 613d 312e 302c 206e 5f69     beta=1.0, n_i
-0000ae00: 6e63 7265 6173 6573 3d31 6531 3030 293a  ncreases=1e100):
-0000ae10: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0000ae20: 2020 2020 2045 5850 4552 494d 454e 5441       EXPERIMENTA
-0000ae30: 4c0a 2020 2020 2020 2020 2222 220a 2020  L.        """.  
-0000ae40: 2020 2020 2020 4e20 3d20 6e5f 6e6f 6465        N = n_node
-0000ae50: 730a 2020 2020 2020 2020 7720 3d20 6e70  s.        w = np
-0000ae60: 2e7a 6572 6f73 284e 290a 2020 2020 2020  .zeros(N).      
-0000ae70: 2020 696e 635f 7072 6f62 203d 206e 702e    inc_prob = np.
-0000ae80: 7a65 726f 7328 4e29 0a20 2020 2020 2020  zeros(N).       
-0000ae90: 2077 5b3a 6e5f 696e 6974 6961 6c73 5d20   w[:n_initials] 
-0000aea0: 3d20 310a 2020 2020 2020 2020 696e 635f  = 1.        inc_
-0000aeb0: 7072 6f62 5b3a 6e5f 696e 6974 6961 6c73  prob[:n_initials
-0000aec0: 5d20 3d20 310a 2020 2020 2020 2020 746f  ] = 1.        to
-0000aed0: 7461 6c5f 696e 635f 7072 6f62 203d 2069  tal_inc_prob = i
-0000aee0: 6e63 5f70 726f 622e 7375 6d28 290a 2020  nc_prob.sum().  
-0000aef0: 2020 2020 2020 686f 6c64 5f70 726f 6220        hold_prob 
-0000af00: 3d20 3120 2d20 7370 6c69 745f 7072 6f62  = 1 - split_prob
-0000af10: 0a0a 2020 2020 2020 2020 6465 6620 5f69  ..        def _i
-0000af20: 6e63 5f74 6172 6765 7428 293a 0a20 2020  nc_target():.   
-0000af30: 2020 2020 2020 2020 2074 6864 203d 2072           thd = r
-0000af40: 616e 646f 6d2e 756e 6966 6f72 6d28 6c6f  andom.uniform(lo
-0000af50: 773d 302c 2068 6967 683d 746f 7461 6c5f  w=0, high=total_
-0000af60: 696e 635f 7072 6f62 290a 2020 2020 2020  inc_prob).      
-0000af70: 2020 2020 2020 6920 3d20 300a 2020 2020        i = 0.    
-0000af80: 2020 2020 2020 2020 6375 6d20 3d20 696e          cum = in
-0000af90: 635f 7072 6f62 5b30 5d0a 2020 2020 2020  c_prob[0].      
-0000afa0: 2020 2020 2020 7768 696c 6520 6375 6d20        while cum 
-0000afb0: 3c20 7468 643a 0a20 2020 2020 2020 2020  < thd:.         
-0000afc0: 2020 2020 2020 2069 202b 3d20 310a 2020         i += 1.  
-0000afd0: 2020 2020 2020 2020 2020 2020 2020 6375                cu
-0000afe0: 6d20 2b3d 2069 6e63 5f70 726f 625b 695d  m += inc_prob[i]
-0000aff0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000b000: 7572 6e20 690a 0a20 2020 2020 2020 2074  urn i..        t
-0000b010: 6869 735f 4e20 3d20 6e5f 696e 6974 6961  his_N = n_initia
-0000b020: 6c73 0a20 2020 2020 2020 2070 726f 6772  ls.        progr
-0000b030: 6573 7320 3d20 7072 6f67 7265 7373 6261  ess = progressba
-0000b040: 722e 5072 6f67 7265 7373 4261 7228 6d61  r.ProgressBar(ma
-0000b050: 7876 616c 3d4e 292e 7374 6172 7428 290a  xval=N).start().
-0000b060: 2020 2020 2020 2020 6974 203d 2030 0a20          it = 0. 
-0000b070: 2020 2020 2020 2077 6869 6c65 2074 6869         while thi
-0000b080: 735f 4e20 3c20 4e20 616e 6420 6974 203c  s_N < N and it <
-0000b090: 206e 5f69 6e63 7265 6173 6573 3a0a 2020   n_increases:.  
-0000b0a0: 2020 2020 2020 2020 2020 6974 202b 3d20            it += 
-0000b0b0: 310a 2020 2020 2020 2020 2020 2020 6920  1.            i 
-0000b0c0: 3d20 5f69 6e63 5f74 6172 6765 7428 290a  = _inc_target().
-0000b0d0: 2020 2020 2020 2020 2020 2020 746f 7461              tota
-0000b0e0: 6c5f 696e 635f 7072 6f62 202d 3d20 696e  l_inc_prob -= in
-0000b0f0: 635f 7072 6f62 5b69 5d0a 2020 2020 2020  c_prob[i].      
-0000b100: 2020 2020 2020 775b 695d 202b 3d20 310a        w[i] += 1.
-0000b110: 2020 2020 2020 2020 2020 2020 696e 635f              inc_
-0000b120: 7072 6f62 5b69 5d20 3d20 775b 695d 2a2a  prob[i] = w[i]**
-0000b130: 6578 706f 6e65 6e74 0a20 2020 2020 2020  exponent.       
-0000b140: 2020 2020 2074 6f74 616c 5f69 6e63 5f70       total_inc_p
-0000b150: 726f 6220 2b3d 2069 6e63 5f70 726f 625b  rob += inc_prob[
-0000b160: 695d 0a20 2020 2020 2020 2020 2020 2069  i].            i
-0000b170: 6620 286d 6f64 6520 3d3d 2022 6578 7022  f (mode == "exp"
-0000b180: 2061 6e64 2072 616e 646f 6d2e 756e 6966   and random.unif
-0000b190: 6f72 6d28 2920 3e20 686f 6c64 5f70 726f  orm() > hold_pro
-0000b1a0: 622a 2a77 5b69 5d29 206f 7220 5c0a 2020  b**w[i]) or \.  
+0000a950: 2020 2020 2020 2020 2020 2020 6e70 2e63              np.c
+0000a960: 6569 6c28 286e 5f6c 696e 6b73 5f6e 6577  eil((n_links_new
+0000a970: 202b 206e 5f6c 696e 6b73 5f6f 6c64 292f   + n_links_old)/
+0000a980: 322e 3029 3a0a 2020 2020 2020 2020 2020  2.0):.          
+0000a990: 2020 2020 2020 2020 2020 2020 2020 415b                A[
+0000a9a0: 692c 206a 5d20 3d20 415b 6a2c 2069 5d20  i, j] = A[j, i] 
+0000a9b0: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
+0000a9c0: 2020 2020 2020 2020 2020 2020 6e62 735b              nbs[
+0000a9d0: 695d 2e61 7070 656e 6428 6a29 0a20 2020  i].append(j).   
+0000a9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9f0: 2020 2020 206e 6273 5b6a 5d2e 6170 7065       nbs[j].appe
+0000aa00: 6e64 2869 290a 2020 2020 2020 2020 2020  nd(i).          
+0000aa10: 2020 2020 2020 6c69 6e6b 5f74 6172 6765        link_targe
+0000aa20: 7420 2b3d 205b 6920 666f 7220 5f20 696e  t += [i for _ in
+0000aa30: 2072 616e 6765 286e 5f6c 696e 6b73 5f6e   range(n_links_n
+0000aa40: 6577 202b 206e 5f6c 696e 6b73 5f6f 6c64  ew + n_links_old
+0000aa50: 295d 0a0a 2020 2020 2020 2020 2020 2020  )]..            
+0000aa60: 2320 6c61 7374 5f67 726f 776e 203d 206e  # last_grown = n
+0000aa70: 702e 7a65 726f 7328 4e29 0a20 2020 2020  p.zeros(N).     
+0000aa80: 2020 2020 2020 2066 6f72 206a 2069 6e20         for j in 
+0000aa90: 7261 6e67 6528 6e5f 696e 6974 6961 6c73  range(n_initials
+0000aaa0: 2c20 4e29 3a0a 2020 2020 2020 2020 2020  , N):.          
+0000aab0: 2020 2020 2020 2320 6164 6420 6e6f 6465        # add node
+0000aac0: 206a 2077 6974 6820 756e 6974 2077 6569   j with unit wei
+0000aad0: 6768 743a 0a20 2020 2020 2020 2020 2020  ght:.           
+0000aae0: 2020 2020 2077 5b6a 5d20 3d20 310a 2020       w[j] = 1.  
+0000aaf0: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0000ab00: 635f 7461 7267 6574 2e61 7070 656e 6428  c_target.append(
+0000ab10: 6a29 0a20 2020 2020 2020 2020 2020 2020  j).             
+0000ab20: 2020 206c 696e 6b5f 7461 7267 6574 2e61     link_target.a
+0000ab30: 7070 656e 6428 6a29 0a20 2020 2020 2020  ppend(j).       
+0000ab40: 2020 2020 2020 2020 2023 206c 696e 6b20           # link 
+0000ab50: 6974 2074 6f20 736f 6d65 2069 2773 3a0a  it to some i's:.
+0000ab60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab70: 666f 7220 6969 2069 6e20 7261 6e67 6528  for ii in range(
+0000ab80: 6e5f 6c69 6e6b 735f 6e65 7729 3a0a 2020  n_links_new):.  
+0000ab90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aba0: 2020 6920 3d20 696e 7428 6c69 6e6b 5f74    i = int(link_t
+0000abb0: 6172 6765 745b 696e 7428 0a20 2020 2020  arget[int(.     
+0000abc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abd0: 2020 2072 616e 646f 6d2e 756e 6966 6f72     random.unifor
+0000abe0: 6d28 6c6f 773d 302c 2068 6967 683d 6c65  m(low=0, high=le
+0000abf0: 6e28 6c69 6e6b 5f74 6172 6765 7429 2929  n(link_target)))
+0000ac00: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0000ac10: 2020 2020 2020 2077 6869 6c65 2069 203d         while i =
+0000ac20: 3d20 6a20 6f72 2041 5b69 2c20 6a5d 203d  = j or A[i, j] =
+0000ac30: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+0000ac40: 2020 2020 2020 2020 2020 2020 2023 2070               # p
+0000ac50: 7269 6e74 2822 6e6f 7420 6922 2c69 290a  rint("not i",i).
+0000ac60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac70: 2020 2020 2020 2020 6920 3d20 696e 7428          i = int(
+0000ac80: 6c69 6e6b 5f74 6172 6765 745b 696e 7428  link_target[int(
+0000ac90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000aca0: 2020 2020 2020 2020 2020 2020 2072 616e               ran
+0000acb0: 646f 6d2e 756e 6966 6f72 6d28 6c6f 773d  dom.uniform(low=
+0000acc0: 302c 2068 6967 683d 6c65 6e28 6c69 6e6b  0, high=len(link
+0000acd0: 5f74 6172 6765 7429 2929 5d29 0a20 2020  _target)))]).   
+0000ace0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acf0: 2023 2070 7269 6e74 2822 6a22 2c20 6a2c   # print("j", j,
+0000ad00: 2022 6922 2c20 6929 0a20 2020 2020 2020   "i", i).       
+0000ad10: 2020 2020 2020 2020 2020 2020 2041 5b69               A[i
+0000ad20: 2c20 6a5d 203d 2041 5b6a 2c20 695d 203d  , j] = A[j, i] =
+0000ad30: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
+0000ad40: 2020 2020 2020 206e 6273 5b6a 5d20 3d20         nbs[j] = 
+0000ad50: 5b69 5d0a 2020 2020 2020 2020 2020 2020  [i].            
+0000ad60: 2020 2020 2020 2020 6e62 735b 695d 2e61          nbs[i].a
+0000ad70: 7070 656e 6428 6a29 0a20 2020 2020 2020  ppend(j).       
+0000ad80: 2020 2020 2020 2020 2020 2020 206c 696e               lin
+0000ad90: 6b5f 7461 7267 6574 202b 3d20 5b6a 2066  k_target += [j f
+0000ada0: 6f72 2069 6969 2069 6e20 7261 6e67 6528  or iii in range(
+0000adb0: 775b 695d 295d 202b 205b 695d 0a20 2020  w[i])] + [i].   
+0000adc0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0000add0: 2069 6920 696e 2072 616e 6765 286e 5f67   ii in range(n_g
+0000ade0: 726f 7774 6873 293a 0a20 2020 2020 2020  rowths):.       
+0000adf0: 2020 2020 2020 2020 2020 2020 2023 2069               # i
+0000ae00: 6e63 7265 6173 6520 7765 6967 6874 206f  ncrease weight o
+0000ae10: 6620 736f 6d65 2069 3a0a 2020 2020 2020  f some i:.      
+0000ae20: 2020 2020 2020 2020 2020 2020 2020 6920                i 
+0000ae30: 3d20 696e 7428 696e 635f 7461 7267 6574  = int(inc_target
+0000ae40: 5b69 6e74 280a 2020 2020 2020 2020 2020  [int(.          
+0000ae50: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+0000ae60: 6e64 6f6d 2e75 6e69 666f 726d 286c 6f77  ndom.uniform(low
+0000ae70: 3d30 2c20 6869 6768 3d6c 656e 2869 6e63  =0, high=len(inc
+0000ae80: 5f74 6172 6765 7429 2929 5d29 0a20 2020  _target)))]).   
+0000ae90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aea0: 2023 2077 6869 6c65 206c 6173 745f 6772   # while last_gr
+0000aeb0: 6f77 6e5b 695d 203d 3d20 6a3a 0a20 2020  own[i] == j:.   
+0000aec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aed0: 2023 2020 2020 6920 3d20 696e 7428 696e   #    i = int(in
+0000aee0: 635f 7461 7267 6574 5b69 6e74 280a 2020  c_target[int(.  
+0000aef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af00: 2020 2320 2020 2020 2020 2072 616e 646f    #        rando
+0000af10: 6d2e 756e 6966 6f72 6d28 6c65 6e28 696e  m.uniform(len(in
+0000af20: 635f 7461 7267 6574 2929 295d 290a 2020  c_target)))]).  
+0000af30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af40: 2020 2320 6c61 7374 5f67 726f 776e 5b69    # last_grown[i
+0000af50: 5d20 3d20 6a0a 2020 2020 2020 2020 2020  ] = j.          
+0000af60: 2020 2020 2020 2020 2020 775b 695d 202b            w[i] +
+0000af70: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
+0000af80: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
+0000af90: 2220 6969 222c 6969 2c22 6922 2c69 2c22  " ii",ii,"i",i,"
+0000afa0: 775b 695d 222c 775b 695d 290a 2020 2020  w[i]",w[i]).    
+0000afb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afc0: 696e 635f 7461 7267 6574 2e61 7070 656e  inc_target.appen
+0000afd0: 6428 6929 0a20 2020 2020 2020 2020 2020  d(i).           
+0000afe0: 2020 2020 2020 2020 206c 696e 6b5f 7461           link_ta
+0000aff0: 7267 6574 202b 3d20 6e62 735b 695d 202b  rget += nbs[i] +
+0000b000: 205b 695d 0a20 2020 2020 2020 2020 2020   [i].           
+0000b010: 2020 2020 2066 6f72 2069 6920 696e 2072       for ii in r
+0000b020: 616e 6765 286e 5f6c 696e 6b73 5f6f 6c64  ange(n_links_old
+0000b030: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000b040: 2020 2020 2020 2023 206a 3220 3d20 696e         # j2 = in
+0000b050: 7428 696e 635f 7461 7267 6574 5b69 6e74  t(inc_target[int
+0000b060: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000b070: 2020 2020 2020 2320 2020 2020 2072 616e        #      ran
+0000b080: 646f 6d2e 756e 6966 6f72 6d28 6c65 6e28  dom.uniform(len(
+0000b090: 696e 635f 7461 7267 6574 2929 295d 290a  inc_target)))]).
+0000b0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0b0: 2020 2020 6a32 203d 2069 6e74 286c 696e      j2 = int(lin
+0000b0c0: 6b5f 7461 7267 6574 5b69 6e74 280a 2020  k_target[int(.  
+0000b0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0e0: 2020 2020 2020 7261 6e64 6f6d 2e75 6e69        random.uni
+0000b0f0: 666f 726d 286c 6f77 3d30 2c20 6869 6768  form(low=0, high
+0000b100: 3d6c 656e 286c 696e 6b5f 7461 7267 6574  =len(link_target
+0000b110: 2929 295d 290a 2020 2020 2020 2020 2020  )))]).          
+0000b120: 2020 2020 2020 2020 2020 2320 6920 3d20            # i = 
+0000b130: 696e 7428 696e 635f 7461 7267 6574 5b69  int(inc_target[i
+0000b140: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+0000b150: 2020 2020 2020 2020 2320 2020 2020 7261          #     ra
+0000b160: 6e64 6f6d 2e75 6e69 666f 726d 286c 656e  ndom.uniform(len
+0000b170: 2869 6e63 5f74 6172 6765 7429 2929 5d29  (inc_target)))])
+0000b180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b190: 2020 2020 2069 203d 2069 6e74 286c 696e       i = int(lin
+0000b1a0: 6b5f 7461 7267 6574 5b69 6e74 280a 2020  k_target[int(.  
 0000b1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1c0: 2020 286d 6f64 6520 3d3d 2022 7265 6322    (mode == "rec"
-0000b1d0: 2061 6e64 2072 616e 646f 6d2e 756e 6966   and random.unif
-0000b1e0: 6f72 6d28 290a 2020 2020 2020 2020 2020  orm().          
-0000b1f0: 2020 2020 2020 2020 2020 203c 2077 5b69             < w[i
-0000b200: 5d2a 312e 302f 2873 706c 6974 5f77 6569  ]*1.0/(split_wei
-0000b210: 6768 742b 775b 695d 2929 3a20 2023 2072  ght+w[i])):  # r
-0000b220: 6563 6970 726f 6361 6c0a 2020 2020 2020  eciprocal.      
-0000b230: 2020 2020 2020 2020 2020 2320 7370 6c69            # spli
-0000b240: 7420 6920 696e 746f 2069 2c74 6869 735f  t i into i,this_
-0000b250: 4e3a 0a20 2020 2020 2020 2020 2020 2020  N:.             
-0000b260: 2020 2074 6f74 616c 5f69 6e63 5f70 726f     total_inc_pro
-0000b270: 6220 2d3d 2069 6e63 5f70 726f 625b 695d  b -= inc_prob[i]
-0000b280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b290: 2077 5b74 6869 735f 4e5d 203d 2077 5b69   w[this_N] = w[i
-0000b2a0: 5d2a 7261 6e64 6f6d 2e62 6574 6128 6265  ]*random.beta(be
-0000b2b0: 7461 2c20 6265 7461 290a 2020 2020 2020  ta, beta).      
-0000b2c0: 2020 2020 2020 2020 2020 775b 695d 202d            w[i] -
-0000b2d0: 3d20 775b 7468 6973 5f4e 5d0a 2020 2020  = w[this_N].    
-0000b2e0: 2020 2020 2020 2020 2020 2020 696e 635f              inc_
-0000b2f0: 7072 6f62 5b74 6869 735f 4e5d 203d 2077  prob[this_N] = w
-0000b300: 5b74 6869 735f 4e5d 2a2a 6578 706f 6e65  [this_N]**expone
-0000b310: 6e74 0a20 2020 2020 2020 2020 2020 2020  nt.             
-0000b320: 2020 2069 6e63 5f70 726f 625b 695d 203d     inc_prob[i] =
-0000b330: 2077 5b69 5d2a 2a65 7870 6f6e 656e 740a   w[i]**exponent.
-0000b340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b350: 746f 7461 6c5f 696e 635f 7072 6f62 202b  total_inc_prob +
-0000b360: 3d20 696e 635f 7072 6f62 5b74 6869 735f  = inc_prob[this_
-0000b370: 4e5d 202b 2069 6e63 5f70 726f 625b 695d  N] + inc_prob[i]
-0000b380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b390: 2074 6869 735f 4e20 2b3d 2031 0a20 2020   this_N += 1.   
-0000b3a0: 2020 2020 2020 2020 2069 6620 7468 6973           if this
-0000b3b0: 5f4e 2025 2031 303a 0a20 2020 2020 2020  _N % 10:.       
-0000b3c0: 2020 2020 2020 2020 2070 726f 6772 6573           progres
-0000b3d0: 732e 7570 6461 7465 2874 6869 735f 4e29  s.update(this_N)
-0000b3e0: 0a0a 2020 2020 2020 2020 7072 6f67 7265  ..        progre
-0000b3f0: 7373 2e66 696e 6973 6828 290a 2020 2020  ss.finish().    
-0000b400: 2020 2020 7265 7475 726e 2077 0a0a 2020      return w..  
-0000b410: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
-0000b420: 2020 2020 6465 6620 436f 6e66 6967 7572      def Configur
-0000b430: 6174 696f 6e4d 6f64 656c 2864 6567 7265  ationModel(degre
-0000b440: 6573 2c20 7369 6c65 6e63 655f 6c65 7665  es, silence_leve
-0000b450: 6c3d 3029 3a0a 2020 2020 2020 2020 2222  l=0):.        ""
-0000b460: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
-0000b470: 2061 206e 6577 2063 6f6e 6669 6775 7261   a new configura
-0000b480: 7469 6f6e 206d 6f64 656c 2072 616e 646f  tion model rando
-0000b490: 6d20 6772 6170 680a 2020 2020 2020 2020  m graph.        
-0000b4a0: 7769 7468 2061 2067 6976 656e 2064 6567  with a given deg
-0000b4b0: 7265 6520 7365 7175 656e 6365 2e0a 0a20  ree sequence... 
-0000b4c0: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
-0000b4d0: 3a2a 2a20 4765 6e65 7261 7465 2061 206e  :** Generate a n
-0000b4e0: 6574 776f 726b 206f 6620 3130 3030 206e  etwork of 1000 n
-0000b4f0: 6f64 6573 2077 6974 6820 6465 6772 6565  odes with degree
-0000b500: 2033 2065 6163 683a 0a0a 2020 2020 2020   3 each:..      
-0000b510: 2020 3e3e 3e20 6e65 7420 3d20 4e65 7477    >>> net = Netw
-0000b520: 6f72 6b2e 436f 6e66 6967 7572 6174 696f  ork.Configuratio
-0000b530: 6e4d 6f64 656c 285b 3320 666f 7220 5f20  nModel([3 for _ 
-0000b540: 696e 2072 616e 6765 2830 2c31 3030 3029  in range(0,1000)
-0000b550: 5d29 0a20 2020 2020 2020 2047 656e 6572  ]).        Gener
-0000b560: 6174 696e 6720 636f 6e66 6967 7572 6174  ating configurat
-0000b570: 696f 6e20 6d6f 6465 6c20 7261 6e64 6f6d  ion model random
-0000b580: 2067 7261 7068 0a20 2020 2020 2020 2066   graph.        f
-0000b590: 726f 6d20 6769 7665 6e20 6465 6772 6565  rom given degree
-0000b5a0: 2073 6571 7565 6e63 652e 2e2e 0a20 2020   sequence....   
-0000b5b0: 2020 2020 203e 3e3e 2070 7269 6e74 2869       >>> print(i
-0000b5c0: 6e74 2872 6f75 6e64 286e 6574 2e64 6567  nt(round(net.deg
-0000b5d0: 7265 6528 292e 6d65 616e 2829 2929 290a  ree().mean()))).
-0000b5e0: 2020 2020 2020 2020 330a 0a20 2020 2020          3..     
-0000b5f0: 2020 203a 7479 7065 2064 6567 7265 6573     :type degrees
-0000b600: 3a20 3164 206e 756d 7079 2061 7272 6179  : 1d numpy array
-0000b610: 206f 7220 6c69 7374 205b 6e6f 6465 5d0a   or list [node].
-0000b620: 2020 2020 2020 2020 3a61 7267 2020 6465          :arg  de
-0000b630: 6772 6565 733a 2041 7272 6179 206f 7220  grees: Array or 
-0000b640: 6c69 7374 206f 6620 6465 6772 6565 7320  list of degrees 
-0000b650: 7761 6e74 6564 2e0a 0a20 2020 2020 2020  wanted...       
-0000b660: 203a 7479 7065 2073 696c 656e 6365 5f6c   :type silence_l
-0000b670: 6576 656c 3a20 696e 7420 3e3d 2030 0a20  evel: int >= 0. 
-0000b680: 2020 2020 2020 203a 6172 6720 2073 696c         :arg  sil
-0000b690: 656e 6365 5f6c 6576 656c 3a20 5468 6520  ence_level: The 
-0000b6a0: 6869 6768 6572 2c20 7468 6520 6c65 7373  higher, the less
-0000b6b0: 2070 726f 6772 6573 7320 696e 666f 2069   progress info i
-0000b6c0: 7320 6f75 7470 7574 2e0a 0a20 2020 2020  s output...     
-0000b6d0: 2020 203a 7274 7970 653a 203a 636c 6173     :rtype: :clas
-0000b6e0: 733a 604e 6574 776f 726b 6020 696e 7374  s:`Network` inst
-0000b6f0: 616e 6365 0a20 2020 2020 2020 2022 2222  ance.        """
-0000b700: 0a20 2020 2020 2020 2070 7269 6e74 2822  .        print("
-0000b710: 4765 6e65 7261 7469 6e67 2063 6f6e 6669  Generating confi
-0000b720: 6775 7261 7469 6f6e 206d 6f64 656c 2072  guration model r
-0000b730: 616e 646f 6d20 6772 6170 685c 6e22 0a20  andom graph\n". 
-0000b740: 2020 2020 2020 2020 2020 2020 202b 2022               + "
-0000b750: 6672 6f6d 2067 6976 656e 2064 6567 7265  from given degre
-0000b760: 6520 7365 7175 656e 6365 2e2e 2e22 290a  e sequence...").
-0000b770: 0a20 2020 2020 2020 2067 7261 7068 203d  .        graph =
-0000b780: 2069 6772 6170 682e 4772 6170 682e 4465   igraph.Graph.De
-0000b790: 6772 6565 5f53 6571 7565 6e63 6528 6f75  gree_Sequence(ou
-0000b7a0: 743d 6c69 7374 2864 6567 7265 6573 2929  t=list(degrees))
-0000b7b0: 0a0a 2020 2020 2020 2020 2320 2052 656d  ..        #  Rem
-0000b7c0: 6f76 6520 7365 6c66 2d6c 6f6f 7073 2061  ove self-loops a
-0000b7d0: 6e64 206d 756c 7469 706c 6520 6c69 6e6b  nd multiple link
-0000b7e0: 732c 2074 6869 7320 646f 6573 206f 6620  s, this does of 
-0000b7f0: 636f 7572 7365 2063 6861 6e67 6520 7468  course change th
-0000b800: 650a 2020 2020 2020 2020 2320 2061 6374  e.        #  act
-0000b810: 7561 6c20 6465 6772 6565 2073 6571 7565  ual degree seque
-0000b820: 6e63 6520 6f66 2074 6865 2067 656e 6572  nce of the gener
-0000b830: 6174 6564 2067 7261 7068 2c20 6275 7420  ated graph, but 
-0000b840: 6a75 7374 2073 6c69 6768 746c 790a 2020  just slightly.  
-0000b850: 2020 2020 2020 6772 6170 682e 7369 6d70        graph.simp
-0000b860: 6c69 6679 2829 0a0a 2020 2020 2020 2020  lify()..        
-0000b870: 2320 2045 7874 7261 6374 2065 6467 6520  #  Extract edge 
-0000b880: 6c69 7374 0a20 2020 2020 2020 2065 6467  list.        edg
-0000b890: 655f 6c69 7374 203d 2067 7261 7068 2e67  e_list = graph.g
-0000b8a0: 6574 5f65 6467 656c 6973 7428 290a 0a20  et_edgelist().. 
-0000b8b0: 2020 2020 2020 206e 6574 776f 726b 203d         network =
-0000b8c0: 204e 6574 776f 726b 2865 6467 655f 6c69   Network(edge_li
-0000b8d0: 7374 3d65 6467 655f 6c69 7374 2c20 6469  st=edge_list, di
-0000b8e0: 7265 6374 6564 3d46 616c 7365 2c0a 2020  rected=False,.  
-0000b8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b900: 2020 2020 2020 2020 7369 6c65 6e63 655f          silence_
-0000b910: 6c65 7665 6c3d 7369 6c65 6e63 655f 6c65  level=silence_le
-0000b920: 7665 6c29 0a0a 2020 2020 2020 2020 7265  vel)..        re
-0000b930: 7475 726e 206e 6574 776f 726b 0a0a 2020  turn network..  
-0000b940: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
-0000b950: 2020 2020 6465 6620 5761 7474 7353 7472      def WattsStr
-0000b960: 6f67 6174 7a47 7261 7068 284e 2c20 6b2c  ogatzGraph(N, k,
-0000b970: 2070 293a 0a20 2020 2020 2020 2022 2222   p):.        """
-0000b980: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
-0000b990: 6120 5761 7474 2d53 7472 6f67 6174 7a20  a Watt-Strogatz 
-0000b9a0: 7261 6e64 6f6d 2067 7261 7068 2e0a 0a20  random graph... 
-0000b9b0: 2020 2020 2020 2052 6566 6572 656e 6365         Reference
-0000b9c0: 3a20 5b57 6174 7473 3139 3938 5d5f 0a0a  : [Watts1998]_..
-0000b9d0: 2020 2020 2020 2020 3a74 7970 6520 4e3a          :type N:
-0000b9e0: 2069 6e74 203e 2030 0a20 2020 2020 2020   int > 0.       
-0000b9f0: 203a 6172 6720 4e3a 204e 756d 6265 7220   :arg N: Number 
-0000ba00: 6f66 206e 6f64 6573 2e0a 0a20 2020 2020  of nodes...     
-0000ba10: 2020 203a 7479 7065 206b 3a20 696e 7420     :type k: int 
-0000ba20: 3e20 300a 2020 2020 2020 2020 3a61 7267  > 0.        :arg
-0000ba30: 206b 3a20 4561 6368 206e 6f64 6520 6973   k: Each node is
-0000ba40: 2063 6f6e 6e65 6374 6564 2074 6f20 6b20   connected to k 
-0000ba50: 6e65 6172 6573 7420 6e65 6967 6862 6f72  nearest neighbor
-0000ba60: 7320 696e 2072 696e 6720 746f 706f 6c6f  s in ring topolo
-0000ba70: 6779 2e0a 0a20 2020 2020 2020 203a 7479  gy...        :ty
-0000ba80: 7065 2070 3a20 666c 6f61 7420 3e20 300a  pe p: float > 0.
-0000ba90: 2020 2020 2020 2020 3a61 7267 2070 3a20          :arg p: 
-0000baa0: 5072 6f62 6162 696c 6974 7920 6f66 2072  Probability of r
-0000bab0: 6577 6972 696e 6720 6561 6368 2065 6467  ewiring each edg
-0000bac0: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
-0000bad0: 2020 2020 2020 2072 6169 7365 204e 6574         raise Net
-0000bae0: 776f 726b 4572 726f 7228 224e 6f74 2069  workError("Not i
-0000baf0: 6d70 6c65 6d65 6e74 6564 2079 6574 2e2e  mplemented yet..
-0000bb00: 2e22 290a 0a20 2020 2064 6566 2072 616e  .")..    def ran
-0000bb10: 646f 6d6c 795f 7265 7769 7265 2873 656c  domly_rewire(sel
-0000bb20: 662c 2069 7465 7261 7469 6f6e 7329 3a0a  f, iterations):.
-0000bb30: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0000bb40: 2020 2020 5261 6e64 6f6d 6c79 2072 6577      Randomly rew
-0000bb50: 6972 6520 7468 6520 6e65 7477 6f72 6b2c  ire the network,
-0000bb60: 2070 7265 7365 7276 696e 6720 7468 6520   preserving the 
-0000bb70: 6465 6772 6565 2073 6571 7565 6e63 652e  degree sequence.
-0000bb80: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
-0000bb90: 706c 653a 2a2a 2047 656e 6572 6174 6520  ple:** Generate 
-0000bba0: 6120 6e65 7477 6f72 6b20 6f66 2031 3030  a network of 100
-0000bbb0: 206e 6f64 6573 2077 6974 6820 6465 6772   nodes with degr
-0000bbc0: 6565 2035 2065 6163 683a 0a0a 2020 2020  ee 5 each:..    
-0000bbd0: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-0000bbe0: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-0000bbf0: 6574 776f 726b 2829 3b20 7072 696e 7428  etwork(); print(
-0000bc00: 6e65 7429 0a20 2020 2020 2020 204e 6574  net).        Net
-0000bc10: 776f 726b 3a20 756e 6469 7265 6374 6564  work: undirected
-0000bc20: 2c20 3620 6e6f 6465 732c 2037 206c 696e  , 6 nodes, 7 lin
-0000bc30: 6b73 2c20 6c69 6e6b 2064 656e 7369 7479  ks, link density
-0000bc40: 2030 2e34 3637 2e0a 2020 2020 2020 2020   0.467..        
-0000bc50: 3e3e 3e20 6e65 742e 7261 6e64 6f6d 6c79  >>> net.randomly
-0000bc60: 5f72 6577 6972 6528 6974 6572 6174 696f  _rewire(iteratio
-0000bc70: 6e73 3d31 3029 3b20 7072 696e 7428 6e65  ns=10); print(ne
-0000bc80: 7429 0a20 2020 2020 2020 2052 616e 646f  t).        Rando
-0000bc90: 6d6c 7920 7265 7769 7269 6e67 2074 6865  mly rewiring the
-0000bca0: 206e 6574 776f 726b 2c70 7265 7365 7276   network,preserv
-0000bcb0: 696e 6720 7468 6520 6465 6772 6565 2073  ing the degree s
-0000bcc0: 6571 7565 6e63 652e 2e2e 0a20 2020 2020  equence....     
-0000bcd0: 2020 204e 6574 776f 726b 3a20 756e 6469     Network: undi
-0000bce0: 7265 6374 6564 2c20 3620 6e6f 6465 732c  rected, 6 nodes,
-0000bcf0: 2037 206c 696e 6b73 2c20 6c69 6e6b 2064   7 links, link d
-0000bd00: 656e 7369 7479 2030 2e34 3637 2e0a 0a20  ensity 0.467... 
-0000bd10: 2020 2020 2020 203a 7479 7065 2069 7465         :type ite
-0000bd20: 7261 7469 6f6e 733a 2069 6e74 203e 2030  rations: int > 0
-0000bd30: 0a20 2020 2020 2020 203a 6172 6720 6974  .        :arg it
-0000bd40: 6572 6174 696f 6e73 3a20 4e75 6d62 6572  erations: Number
-0000bd50: 206f 6620 6974 6572 6174 696f 6e73 2e20   of iterations. 
-0000bd60: 496e 2065 6163 6820 6974 6572 6174 696f  In each iteratio
-0000bd70: 6e2c 2074 776f 2072 616e 646f 6d6c 790a  n, two randomly.
-0000bd80: 2020 2020 2020 2020 2020 2020 6368 6f73              chos
-0000bd90: 656e 206c 696e 6b73 2061 2d2d 6220 616e  en links a--b an
-0000bda0: 6420 632d 2d64 2066 6f72 2077 6869 6368  d c--d for which
-0000bdb0: 207b 612c 637d 2061 6e64 207b 622c 647d   {a,c} and {b,d}
-0000bdc0: 2061 7265 206e 6f74 0a20 2020 2020 2020   are not.       
-0000bdd0: 2020 2020 206c 696e 6b65 642c 2061 7265       linked, are
-0000bde0: 2072 6570 6c61 6365 6420 6279 2074 6865   replaced by the
-0000bdf0: 206c 696e 6b73 2061 2d2d 6320 616e 6420   links a--c and 
-0000be00: 622d 2d64 2e0a 2020 2020 2020 2020 2222  b--d..        ""
-0000be10: 220a 2020 2020 2020 2020 2320 544f 444f  ".        # TODO
-0000be20: 3a20 7665 7269 6679 2074 6861 7420 6974  : verify that it
-0000be30: 2069 7320 696e 6465 6564 2061 7320 6465   is indeed as de
-0000be40: 7363 7269 6265 6420 6162 6f76 652e 0a20  scribed above.. 
-0000be50: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
-0000be60: 696c 656e 6365 5f6c 6576 656c 203c 3d20  ilence_level <= 
-0000be70: 313a 0a20 2020 2020 2020 2020 2020 2070  1:.            p
-0000be80: 7269 6e74 2822 5261 6e64 6f6d 6c79 2072  rint("Randomly r
-0000be90: 6577 6972 696e 6720 7468 6520 6e65 7477  ewiring the netw
-0000bea0: 6f72 6b2c 220a 2020 2020 2020 2020 2020  ork,".          
-0000beb0: 2020 2020 2020 2020 2b20 2270 7265 7365          + "prese
-0000bec0: 7276 696e 6720 7468 6520 6465 6772 6565  rving the degree
-0000bed0: 2073 6571 7565 6e63 652e 2e2e 2229 0a0a   sequence...")..
-0000bee0: 2020 2020 2020 2020 2320 7265 7769 7265          # rewire
-0000bef0: 2065 6d62 6564 6465 6420 6967 7261 7068   embedded igraph
-0000bf00: 2e47 7261 7068 3a0a 2020 2020 2020 2020  .Graph:.        
-0000bf10: 7365 6c66 2e67 7261 7068 2e72 6577 6972  self.graph.rewir
-0000bf20: 6528 6974 6572 6174 696f 6e73 290a 0a20  e(iterations).. 
-0000bf30: 2020 2020 2020 2023 2075 7064 6174 6520         # update 
-0000bf40: 616c 6c20 6461 7461 2074 6861 7420 6465  all data that de
-0000bf50: 7065 6e64 7320 6f6e 2072 6577 6972 6564  pends on rewired
-0000bf60: 2065 6467 6520 6c69 7374 3a0a 2020 2020   edge list:.    
-0000bf70: 2020 2020 7365 6c66 2e73 6574 5f65 6467      self.set_edg
-0000bf80: 655f 6c69 7374 2873 656c 662e 6772 6170  e_list(self.grap
-0000bf90: 682e 6765 745f 6564 6765 6c69 7374 2829  h.get_edgelist()
-0000bfa0: 290a 0a20 2020 2064 6566 2065 6467 655f  )..    def edge_
-0000bfb0: 6c69 7374 2873 656c 6629 3a0a 2020 2020  list(self):.    
-0000bfc0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000bfd0: 5265 7475 726e 2074 6865 206e 6574 776f  Return the netwo
-0000bfe0: 726b 2773 2065 6467 6520 6c69 7374 2e0a  rk's edge list..
-0000bff0: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
-0000c000: 6c65 3a2a 2a0a 0a20 2020 2020 2020 203e  le:**..        >
-0000c010: 3e3e 2070 7269 6e74 284e 6574 776f 726b  >> print(Network
-0000c020: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-0000c030: 6b28 292e 6564 6765 5f6c 6973 7428 295b  k().edge_list()[
-0000c040: 3a38 5d29 0a20 2020 2020 2020 205b 5b30  :8]).        [[0
-0000c050: 2033 5d20 5b30 2034 5d20 5b30 2035 5d20   3] [0 4] [0 5] 
-0000c060: 5b31 2032 5d20 5b31 2033 5d20 5b31 2034  [1 2] [1 3] [1 4
-0000c070: 5d20 5b32 2031 5d20 5b32 2034 5d5d 0a0a  ] [2 1] [2 4]]..
-0000c080: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-0000c090: 6172 7261 792d 6c69 6b65 2028 6e75 6d70  array-like (nump
-0000c0a0: 7920 6d61 7472 6978 206f 7220 6c69 7374  y matrix or list
-0000c0b0: 206f 6620 6c69 7374 732f 7475 706c 6573   of lists/tuples
-0000c0c0: 290a 2020 2020 2020 2020 2222 220a 2020  ).        """.  
-0000c0d0: 2020 2020 2020 7265 7475 726e 206e 7a5f        return nz_
-0000c0e0: 636f 6f72 6473 2873 656c 662e 7370 5f41  coords(self.sp_A
-0000c0f0: 290a 0a20 2020 2023 2054 4f44 4f3a 2064  )..    # TODO: d
-0000c100: 6570 7265 6361 7465 2074 6869 7320 616e  eprecate this an
-0000c110: 6420 7261 7468 6572 2075 7365 2075 6e64  d rather use und
-0000c120: 6972 6563 7465 645f 636f 7079 2829 0a20  irected_copy(). 
-0000c130: 2020 2064 6566 2075 6e64 6972 6563 7465     def undirecte
-0000c140: 645f 6164 6a61 6365 6e63 7928 7365 6c66  d_adjacency(self
-0000c150: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0000c160: 2020 2020 2020 2052 6574 7572 6e20 7468         Return th
-0000c170: 6520 6164 6a61 6365 6e63 7920 6d61 7472  e adjacency matr
-0000c180: 6978 206f 6620 7468 6520 756e 6469 7265  ix of the undire
-0000c190: 6374 6564 2076 6572 7369 6f6e 206f 6620  cted version of 
-0000c1a0: 7468 6520 6e65 7477 6f72 6b0a 2020 2020  the network.    
-0000c1b0: 2020 2020 6173 2061 2064 656e 7365 206e      as a dense n
-0000c1c0: 756d 7079 2061 7272 6179 2e0a 2020 2020  umpy array..    
-0000c1d0: 2020 2020 456e 7472 7920 5b69 2c6a 5d20      Entry [i,j] 
-0000c1e0: 6973 2031 2069 6620 6920 6c69 6e6b 7320  is 1 if i links 
-0000c1f0: 746f 206a 206f 7220 6a20 6c69 6e6b 7320  to j or j links 
-0000c200: 746f 2069 2e0a 0a20 2020 2020 2020 202a  to i...        *
-0000c210: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-0000c220: 2020 2020 203e 3e3e 206e 6574 203d 204e       >>> net = N
-0000c230: 6574 776f 726b 2861 646a 6163 656e 6379  etwork(adjacency
-0000c240: 3d5b 5b30 2c31 5d2c 5b30 2c30 5d5d 2c20  =[[0,1],[0,0]], 
-0000c250: 6469 7265 6374 6564 3d54 7275 6529 0a20  directed=True). 
-0000c260: 2020 2020 2020 203e 3e3e 2070 7269 6e74         >>> print
-0000c270: 286e 6574 2e75 6e64 6972 6563 7465 645f  (net.undirected_
-0000c280: 6164 6a61 6365 6e63 7928 292e 4129 0a20  adjacency().A). 
-0000c290: 2020 2020 2020 205b 5b30 2031 5d20 5b31         [[0 1] [1
-0000c2a0: 2030 5d5d 0a0a 2020 2020 2020 2020 3a72   0]]..        :r
-0000c2b0: 7479 7065 3a20 6172 7261 7928 5b5b 307c  type: array([[0|
-0000c2c0: 315d 5d29 0a20 2020 2020 2020 2022 2222  1]]).        """
-0000c2d0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000c2e0: 7365 6c66 2e73 705f 412e 6d61 7869 6d75  self.sp_A.maximu
-0000c2f0: 6d28 7365 6c66 2e73 705f 412e 5429 0a0a  m(self.sp_A.T)..
-0000c300: 2020 2020 6465 6620 6c61 706c 6163 6961      def laplacia
-0000c310: 6e28 7365 6c66 2c20 6469 7265 6374 696f  n(self, directio
-0000c320: 6e3d 226f 7574 222c 206c 696e 6b5f 6174  n="out", link_at
-0000c330: 7472 6962 7574 653d 4e6f 6e65 293a 0a20  tribute=None):. 
-0000c340: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000c350: 2020 2052 6574 7572 6e20 7468 6520 2870     Return the (p
-0000c360: 6f73 7369 626c 7920 6e6f 6e2d 7379 6d6d  ossibly non-symm
-0000c370: 6574 7269 6329 2064 656e 7365 204c 6170  etric) dense Lap
-0000c380: 6c61 6369 616e 206d 6174 7269 782e 0a0a  lacian matrix...
-0000c390: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
-0000c3a0: 653a 2a2a 0a0a 2020 2020 2020 2020 3e3e  e:**..        >>
-0000c3b0: 3e20 7228 4e65 7477 6f72 6b2e 536d 616c  > r(Network.Smal
-0000c3c0: 6c54 6573 744e 6574 776f 726b 2829 2e6c  lTestNetwork().l
-0000c3d0: 6170 6c61 6369 616e 2829 290a 2020 2020  aplacian()).    
-0000c3e0: 2020 2020 6172 7261 7928 5b5b 2033 2c20      array([[ 3, 
-0000c3f0: 2030 2c20 2030 2c20 2d31 2c20 2d31 2c20   0,  0, -1, -1, 
-0000c400: 2d31 5d2c 205b 2030 2c20 2033 2c20 2d31  -1], [ 0,  3, -1
-0000c410: 2c20 2d31 2c20 2d31 2c20 2030 5d2c 0a20  , -1, -1,  0],. 
-0000c420: 2020 2020 2020 2020 2020 2020 2020 5b20                [ 
-0000c430: 302c 202d 312c 2020 322c 2020 302c 202d  0, -1,  2,  0, -
-0000c440: 312c 2020 305d 2c20 5b2d 312c 202d 312c  1,  0], [-1, -1,
-0000c450: 2020 302c 2020 322c 2020 302c 2020 305d    0,  2,  0,  0]
-0000c460: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000c470: 205b 2d31 2c20 2d31 2c20 2d31 2c20 2030   [-1, -1, -1,  0
-0000c480: 2c20 2033 2c20 2030 5d2c 205b 2d31 2c20  ,  3,  0], [-1, 
-0000c490: 2030 2c20 2030 2c20 2030 2c20 2030 2c20   0,  0,  0,  0, 
-0000c4a0: 2031 5d5d 290a 0a20 2020 2020 2020 203a   1]])..        :
-0000c4b0: 6172 6720 7374 7220 6469 7265 6374 696f  arg str directio
-0000c4c0: 6e3a 2054 6869 7320 6172 6775 6d65 6e74  n: This argument
-0000c4d0: 2069 7320 6967 6e6f 7265 6420 666f 7220   is ignored for 
-0000c4e0: 756e 6469 7265 6374 6564 2067 7261 7068  undirected graph
-0000c4f0: 732e 0a20 2020 2020 2020 2020 2020 2022  s..            "
-0000c500: 6f75 7422 202d 206f 7574 2d64 6567 7265  out" - out-degre
-0000c510: 6520 6f6e 2064 6961 676f 6e61 6c20 6f66  e on diagonal of
-0000c520: 206c 6170 6c61 6369 616e 0a20 2020 2020   laplacian.     
-0000c530: 2020 2020 2020 2022 696e 2220 202d 2069         "in"  - i
-0000c540: 6e2d 6465 6772 6565 206f 6e20 6469 6167  n-degree on diag
-0000c550: 6f6e 616c 206f 6620 6c61 706c 6163 6961  onal of laplacia
-0000c560: 6e0a 2020 2020 2020 2020 3a61 7267 2073  n.        :arg s
-0000c570: 7472 206c 696e 6b5f 6174 7472 6962 7574  tr link_attribut
-0000c580: 653a 206e 616d 6520 6f66 206c 696e 6b20  e: name of link 
-0000c590: 6174 7472 6962 7574 6520 746f 2062 6520  attribute to be 
-0000c5a0: 7573 6564 0a20 2020 2020 2020 203a 7274  used.        :rt
-0000c5b0: 7970 653a 2073 7175 6172 6520 6172 7261  ype: square arra
-0000c5c0: 7920 5b6e 6f64 652c 6e6f 6465 5d20 6f66  y [node,node] of
-0000c5d0: 2069 6e74 730a 2020 2020 2020 2020 2222   ints.        ""
-0000c5e0: 220a 2020 2020 2020 2020 6966 206c 696e  ".        if lin
-0000c5f0: 6b5f 6174 7472 6962 7574 6520 3d3d 2022  k_attribute == "
-0000c600: 746f 706f 6c6f 6769 6361 6c22 3a0a 2020  topological":.  
-0000c610: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000c620: 2257 4152 4e49 4e47 3a20 6c69 6e6b 5f61  "WARNING: link_a
-0000c630: 7474 7269 6275 7465 3d27 746f 706f 6c6f  ttribute='topolo
-0000c640: 6769 6361 6c27 2069 7320 6465 7072 6563  gical' is deprec
-0000c650: 6174 6564 2e5c 6e22 0a20 2020 2020 2020  ated.\n".       
-0000c660: 2020 2020 2020 2020 2020 202b 2022 5573             + "Us
-0000c670: 6520 6c69 6e6b 5f61 7474 7269 6275 7465  e link_attribute
-0000c680: 3d4e 6f6e 6520 696e 7374 6561 642e 2229  =None instead.")
-0000c690: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
-0000c6a0: 6b5f 6174 7472 6962 7574 6520 3d20 4e6f  k_attribute = No
-0000c6b0: 6e65 0a0a 2020 2020 2020 2020 6966 206c  ne..        if l
-0000c6c0: 696e 6b5f 6174 7472 6962 7574 6520 6973  ink_attribute is
-0000c6d0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-0000c6e0: 2020 2069 6620 7365 6c66 2e64 6972 6563     if self.direc
-0000c6f0: 7465 643a 0a20 2020 2020 2020 2020 2020  ted:.           
-0000c700: 2020 2020 2069 6620 6469 7265 6374 696f       if directio
-0000c710: 6e20 3d3d 2022 6f75 7422 3a0a 2020 2020  n == "out":.    
-0000c720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c730: 6469 6167 6f6e 616c 203d 2073 656c 662e  diagonal = self.
-0000c740: 6f75 7464 6567 7265 6528 290a 2020 2020  outdegree().    
-0000c750: 2020 2020 2020 2020 2020 2020 656c 6966              elif
-0000c760: 2064 6972 6563 7469 6f6e 203d 3d20 2269   direction == "i
-0000c770: 6e22 3a0a 2020 2020 2020 2020 2020 2020  n":.            
-0000c780: 2020 2020 2020 2020 6469 6167 6f6e 616c          diagonal
-0000c790: 203d 2073 656c 662e 696e 6465 6772 6565   = self.indegree
-0000c7a0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
-0000c7b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000c7c0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-0000c7d0: 6e74 2822 4552 524f 523a 2061 7267 756d  nt("ERROR: argum
-0000c7e0: 656e 7420 6469 7265 6374 696f 6e20 6f66  ent direction of
-0000c7f0: 204e 6574 776f 726b 2e6c 6170 6c61 6369   Network.laplaci
-0000c800: 616e 2022 0a20 2020 2020 2020 2020 2020  an ".           
-0000c810: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000c820: 6361 6e20 6f6e 6c79 2074 616b 6520 7661  can only take va
-0000c830: 6c75 6573 203c 3c69 6e3e 3e20 6f72 203c  lues <<in>> or <
-0000c840: 3c6f 7574 3e3e 2e22 290a 2020 2020 2020  <out>>.").      
-0000c850: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000c860: 2020 2020 2020 2020 2020 2020 6469 6167              diag
-0000c870: 6f6e 616c 203d 2073 656c 662e 6465 6772  onal = self.degr
-0000c880: 6565 2829 0a0a 2020 2020 2020 2020 2020  ee()..          
-0000c890: 2020 7265 7475 726e 206e 702e 6469 6167    return np.diag
-0000c8a0: 2864 6961 676f 6e61 6c2c 2030 2920 2d20  (diagonal, 0) - 
-0000c8b0: 7365 6c66 2e61 646a 6163 656e 6379 0a20  self.adjacency. 
-0000c8c0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000c8d0: 2020 2020 2020 2020 2072 6169 7365 204e           raise N
-0000c8e0: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
-0000c8f0: 6f72 2822 4f6e 6c79 2069 6d70 6c65 6d65  or("Only impleme
-0000c900: 6e74 6564 2066 6f72 206c 696e 6b5f 6174  nted for link_at
-0000c910: 7472 6962 7574 6520 5c0a 2020 2020 2020  tribute \.      
-0000c920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c940: 3d4e 6f6e 652e 2229 0a0a 2020 2020 6465  =None.")..    de
-0000c950: 6620 6e73 695f 6c61 706c 6163 6961 6e28  f nsi_laplacian(
-0000c960: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-0000c970: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
-0000c980: 6e20 7468 6520 6e2e 732e 692e 204c 6170  n the n.s.i. Lap
-0000c990: 6c61 6369 616e 206d 6174 7269 7820 2875  lacian matrix (u
-0000c9a0: 6e64 6972 6563 7465 6420 6e65 7477 6f72  ndirected networ
-0000c9b0: 6b73 206f 6e6c 7921 292e 0a0a 2020 2020  ks only!)...    
-0000c9c0: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
-0000c9d0: 0a0a 2020 2020 2020 2020 3e3e 3e20 4e65  ..        >>> Ne
-0000c9e0: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-0000c9f0: 6574 776f 726b 2829 2e6e 7369 5f6c 6170  etwork().nsi_lap
-0000ca00: 6c61 6369 616e 2829 0a20 2020 2020 2020  lacian().       
-0000ca10: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
-0000ca20: 2e69 2e20 6465 6772 6565 2e2e 2e0a 2020  .i. degree....  
-0000ca30: 2020 2020 2020 6172 7261 7928 5b5b 2036        array([[ 6
-0000ca40: 2e39 2c20 2030 2e20 2c20 2030 2e20 2c20  .9,  0. ,  0. , 
-0000ca50: 2d32 2e31 2c20 2d32 2e33 2c20 2d32 2e35  -2.1, -2.3, -2.5
-0000ca60: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-0000ca70: 2020 5b20 302e 202c 2020 362e 332c 202d    [ 0. ,  6.3, -
-0000ca80: 312e 392c 202d 322e 312c 202d 322e 332c  1.9, -2.1, -2.3,
-0000ca90: 2020 302e 205d 2c0a 2020 2020 2020 2020    0. ],.        
-0000caa0: 2020 2020 2020 205b 2030 2e20 2c20 2d31         [ 0. , -1
-0000cab0: 2e37 2c20 2034 2e20 2c20 2030 2e20 2c20  .7,  4. ,  0. , 
-0000cac0: 2d32 2e33 2c20 2030 2e20 5d2c 0a20 2020  -2.3,  0. ],.   
-0000cad0: 2020 2020 2020 2020 2020 2020 5b2d 312e              [-1.
-0000cae0: 352c 202d 312e 372c 2020 302e 202c 2020  5, -1.7,  0. ,  
-0000caf0: 332e 322c 2020 302e 202c 2020 302e 205d  3.2,  0. ,  0. ]
-0000cb00: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000cb10: 205b 2d31 2e35 2c20 2d31 2e37 2c20 2d31   [-1.5, -1.7, -1
-0000cb20: 2e39 2c20 2030 2e20 2c20 2035 2e31 2c20  .9,  0. ,  5.1, 
-0000cb30: 2030 2e20 5d2c 0a20 2020 2020 2020 2020   0. ],.         
-0000cb40: 2020 2020 2020 5b2d 312e 352c 2020 302e        [-1.5,  0.
-0000cb50: 202c 2020 302e 202c 2020 302e 202c 2020   ,  0. ,  0. ,  
-0000cb60: 302e 202c 2020 312e 355d 5d29 0a0a 2020  0. ,  1.5]])..  
-0000cb70: 2020 2020 2020 3a72 7479 7065 3a20 7371        :rtype: sq
-0000cb80: 7561 7265 2061 7272 6179 285b 5b66 6c6f  uare array([[flo
-0000cb90: 6174 5d5d 290a 2020 2020 2020 2020 2222  at]]).        ""
-0000cba0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-0000cbb0: 2028 7365 6c66 2e73 705f 6e73 695f 6469   (self.sp_nsi_di
-0000cbc0: 6167 5f6b 2829 202d 2073 656c 662e 7370  ag_k() - self.sp
-0000cbd0: 5f41 706c 7573 2829 202a 2073 656c 662e  _Aplus() * self.
-0000cbe0: 7370 5f64 6961 675f 7728 2929 2e41 0a0a  sp_diag_w()).A..
-0000cbf0: 2020 2020 230a 2020 2020 2320 2043 616c      #.    #  Cal
-0000cc00: 6375 6c61 7465 2066 7265 7175 656e 6379  culate frequency
-0000cc10: 2061 6e64 2063 756d 756c 6174 6976 6520   and cumulative 
-0000cc20: 6469 7374 7269 6275 7469 6f6e 730a 2020  distributions.  
-0000cc30: 2020 230a 0a20 2020 2023 2054 4f44 4f3a    #..    # TODO:
-0000cc40: 2061 6464 2073 656e 7369 626c 6520 6465   add sensible de
-0000cc50: 6661 756c 7420 666f 7220 6e5f 6269 6e73  fault for n_bins
-0000cc60: 2064 6570 656e 6469 6e67 206f 6e20 6c65   depending on le
-0000cc70: 6e28 7661 6c75 6573 290a 2020 2020 4073  n(values).    @s
-0000cc80: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
-0000cc90: 6465 6620 5f68 6973 746f 6772 616d 2876  def _histogram(v
-0000cca0: 616c 7565 732c 206e 5f62 696e 732c 2069  alues, n_bins, i
-0000ccb0: 6e74 6572 7661 6c3d 4e6f 6e65 293a 0a20  nterval=None):. 
-0000ccc0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000ccd0: 2020 2052 6574 7572 6e20 6120 6e6f 726d     Return a norm
-0000cce0: 616c 697a 6564 2068 6973 746f 6772 616d  alized histogram
-0000ccf0: 206f 6620 6120 6c69 7374 206f 6620 7661   of a list of va
-0000cd00: 6c75 6573 2c0a 2020 2020 2020 2020 6974  lues,.        it
-0000cd10: 7320 7374 6174 6973 7469 6361 6c20 6572  s statistical er
-0000cd20: 726f 722c 2061 6e64 2074 6865 206c 6f77  ror, and the low
-0000cd30: 6572 2062 696e 2062 6f75 6e64 6172 6965  er bin boundarie
-0000cd40: 732e 0a0a 2020 2020 2020 2020 2a2a 4578  s...        **Ex
-0000cd50: 616d 706c 653a 2a2a 2047 6574 2074 6865  ample:** Get the
-0000cd60: 2072 656c 6174 6976 6520 6672 6571 7565   relative freque
-0000cd70: 6e63 6965 7320 6f6e 6c79 3a0a 0a20 2020  ncies only:..   
-0000cd80: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
-0000cd90: 726b 2e5f 6869 7374 6f67 7261 6d28 0a20  rk._histogram(. 
-0000cda0: 2020 2020 2020 202e 2e2e 2020 2020 2076         ...     v
-0000cdb0: 616c 7565 733d 5b31 2c32 2c31 335d 2c20  alues=[1,2,13], 
-0000cdc0: 6e5f 6269 6e73 3d33 2c20 696e 7465 7276  n_bins=3, interv
-0000cdd0: 616c 3d28 302c 3330 2929 5b30 5d29 0a20  al=(0,30))[0]). 
-0000cde0: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
-0000cdf0: 2e36 3636 372c 2020 302e 3333 3333 2c20  .6667,  0.3333, 
-0000ce00: 2030 2e20 5d29 0a0a 2020 2020 2020 2020   0. ])..        
-0000ce10: 3a74 7970 6520 7661 6c75 6573 3a20 3164  :type values: 1d
-0000ce20: 2061 7272 6179 206f 7220 6c69 7374 206f   array or list o
-0000ce30: 6620 666c 6f61 7473 0a20 2020 2020 2020  f floats.       
-0000ce40: 203a 6172 6720 2076 616c 7565 733a 2054   :arg  values: T
-0000ce50: 6865 2076 616c 7565 7320 7768 6f73 6520  he values whose 
-0000ce60: 6469 7374 7269 6275 7469 6f6e 2069 7320  distribution is 
-0000ce70: 7761 6e74 6564 2e0a 0a20 2020 2020 2020  wanted...       
-0000ce80: 203a 7479 7065 206e 5f62 696e 733a 2069   :type n_bins: i
-0000ce90: 6e74 203e 2030 0a20 2020 2020 2020 203a  nt > 0.        :
-0000cea0: 6172 6720 206e 5f62 696e 733a 204e 756d  arg  n_bins: Num
-0000ceb0: 6265 7220 6f66 2062 696e 7320 746f 2062  ber of bins to b
-0000cec0: 6520 7573 6564 2066 6f72 2074 6865 2068  e used for the h
-0000ced0: 6973 746f 6772 616d 2e0a 0a20 2020 2020  istogram...     
-0000cee0: 2020 203a 7479 7065 2069 6e74 6572 7661     :type interva
-0000cef0: 6c3a 2074 7570 6c65 2028 666c 6f61 742c  l: tuple (float,
-0000cf00: 666c 6f61 7429 2c20 6f72 204e 6f6e 650a  float), or None.
-0000cf10: 2020 2020 2020 2020 3a61 7267 2020 696e          :arg  in
-0000cf20: 7465 7276 616c 3a20 4f70 7469 6f6e 616c  terval: Optional
-0000cf30: 2069 6e74 6572 7661 6c20 746f 2075 7365   interval to use
-0000cf40: 2e20 4966 204e 6f6e 652c 2074 6865 206d  . If None, the m
-0000cf50: 696e 696d 756d 2061 6e64 0a20 2020 2020  inimum and.     
-0000cf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf70: 2020 206d 6178 696d 756d 2076 616c 7565     maximum value
-0000cf80: 7320 6172 6520 7573 6564 2e20 2844 6566  s are used. (Def
-0000cf90: 6175 6c74 3a20 4e6f 6e65 290a 0a20 2020  ault: None)..   
-0000cfa0: 2020 2020 203a 7274 7970 653a 2020 7475       :rtype:  tu
-0000cfb0: 706c 6520 286c 6973 742c 6c69 7374 2c6c  ple (list,list,l
-0000cfc0: 6973 7429 0a20 2020 2020 2020 203a 7265  ist).        :re
-0000cfd0: 7475 726e 3a20 4120 6c69 7374 206f 6620  turn: A list of 
-0000cfe0: 7265 6c61 7469 7665 2062 696e 2066 7265  relative bin fre
-0000cff0: 7175 656e 6369 6573 2c20 6120 6c69 7374  quencies, a list
-0000d000: 206f 6620 6573 7469 6d61 7465 640a 2020   of estimated.  
-0000d010: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000d020: 7461 7469 7374 6963 616c 2065 7272 6f72  tatistical error
-0000d030: 732c 2061 6e64 2061 206c 6973 7420 6f66  s, and a list of
-0000d040: 206c 6f77 6572 2062 696e 2062 6f75 6e64   lower bin bound
-0000d050: 6172 6965 732e 0a20 2020 2020 2020 2022  aries..        "
-0000d060: 2222 0a20 2020 2020 2020 2068 6973 7420  "".        hist 
-0000d070: 3d20 6e70 2e68 6973 746f 6772 616d 2876  = np.histogram(v
-0000d080: 616c 7565 732c 2062 696e 733d 6e5f 6269  alues, bins=n_bi
-0000d090: 6e73 2c20 7261 6e67 653d 696e 7465 7276  ns, range=interv
-0000d0a0: 616c 2c20 6465 6e73 6974 793d 4661 6c73  al, density=Fals
-0000d0b0: 6529 0a20 2020 2020 2020 2066 7265 7175  e).        frequ
-0000d0c0: 656e 6369 6573 203d 2068 6973 745b 305d  encies = hist[0]
-0000d0d0: 2e61 7374 7970 6528 2766 6c6f 6174 3634  .astype('float64
-0000d0e0: 2729 0a20 2020 2020 2020 2062 696e 5f73  ').        bin_s
-0000d0f0: 7461 7274 7320 3d20 6869 7374 5b31 5d5b  tarts = hist[1][
-0000d100: 3a2d 315d 0a0a 2020 2020 2020 2020 2320  :-1]..        # 
-0000d110: 4361 6c63 756c 6174 6520 7374 6174 6973  Calculate statis
-0000d120: 7469 6361 6c20 6572 726f 7220 6769 7665  tical error give
-0000d130: 6e20 6279 2031 2f6e 5f69 2070 6572 2062  n by 1/n_i per b
-0000d140: 696e 2069 2c0a 2020 2020 2020 2020 2320  in i,.        # 
-0000d150: 7768 6572 6520 6e5f 6920 6973 2074 6865  where n_i is the
-0000d160: 206e 756d 6265 7220 6f66 2073 616d 706c   number of sampl
-0000d170: 6573 2070 6572 2062 696e 0a20 2020 2020  es per bin.     
-0000d180: 2020 2065 7272 6f72 203d 206e 702e 7a65     error = np.ze
-0000d190: 726f 7328 6e5f 6269 6e73 290a 2020 2020  ros(n_bins).    
-0000d1a0: 2020 2020 6572 726f 725b 6672 6571 7565      error[freque
-0000d1b0: 6e63 6965 7320 213d 2030 5d20 3d20 3120  ncies != 0] = 1 
-0000d1c0: 2f20 6e70 2e73 7172 7428 6672 6571 7565  / np.sqrt(freque
-0000d1d0: 6e63 6965 735b 6672 6571 7565 6e63 6965  ncies[frequencie
-0000d1e0: 7320 213d 2030 5d29 0a20 2020 2020 2020  s != 0]).       
-0000d1f0: 2023 2046 4958 4d45 3a20 7468 6973 2073   # FIXME: this s
-0000d200: 6565 6d73 206e 6f74 2063 6f72 7265 6374  eems not correct
-0000d210: 2e20 4966 2074 6865 2074 7275 6520 7072  . If the true pr
-0000d220: 6f62 6162 696c 6974 7920 666f 7220 7468  obability for th
-0000d230: 6520 6269 6e0a 2020 2020 2020 2020 2320  e bin.        # 
-0000d240: 6973 2070 5f69 2c20 7468 6520 7661 7269  is p_i, the vari
-0000d250: 616e 6365 206f 6620 206e 5f69 202f 204e  ance of  n_i / N
-0000d260: 2020 6973 2020 705f 6920 2a20 2831 202d    is  p_i * (1 -
-0000d270: 2070 5f69 2920 2f20 4e0a 2020 2020 2020   p_i) / N.      
-0000d280: 2020 2320 7768 6963 6820 6361 6e20 6265    # which can be
-0000d290: 2065 7374 696d 6174 6564 2066 726f 6d20   estimated from 
-0000d2a0: 6e5f 6920 6279 2020 6e5f 6920 2a20 284e  n_i by  n_i * (N
-0000d2b0: 202d 206e 5f69 2920 2f20 4e2a 2a33 0a0a   - n_i) / N**3..
-0000d2c0: 2020 2020 2020 2020 2320 204e 6f72 6d61          #  Norma
-0000d2d0: 6c69 7a65 2066 7265 7175 656e 6369 6573  lize frequencies
-0000d2e0: 2061 6e64 2065 7272 6f72 0a20 2020 2020   and error.     
-0000d2f0: 2020 2072 656c 5f66 7265 7173 203d 2066     rel_freqs = f
-0000d300: 7265 7175 656e 6369 6573 202f 2066 7265  requencies / fre
-0000d310: 7175 656e 6369 6573 2e73 756d 2829 0a20  quencies.sum(). 
-0000d320: 2020 2020 2020 2065 7272 6f72 202f 3d20         error /= 
-0000d330: 6672 6571 7565 6e63 6965 732e 7375 6d28  frequencies.sum(
-0000d340: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-0000d350: 6e20 2872 656c 5f66 7265 7173 2c20 6572  n (rel_freqs, er
-0000d360: 726f 722c 2062 696e 5f73 7461 7274 7329  ror, bin_starts)
-0000d370: 0a0a 2020 2020 4073 7461 7469 636d 6574  ..    @staticmet
-0000d380: 686f 640a 2020 2020 6465 6620 5f63 756d  hod.    def _cum
-0000d390: 5f68 6973 746f 6772 616d 2876 616c 7565  _histogram(value
-0000d3a0: 732c 206e 5f62 696e 732c 2069 6e74 6572  s, n_bins, inter
-0000d3b0: 7661 6c3d 4e6f 6e65 293a 0a20 2020 2020  val=None):.     
-0000d3c0: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
-0000d3d0: 6574 7572 6e20 6120 6e6f 726d 616c 697a  eturn a normaliz
-0000d3e0: 6564 2063 756d 756c 6174 6976 6520 6869  ed cumulative hi
-0000d3f0: 7374 6f67 7261 6d20 6f66 2061 206c 6973  stogram of a lis
-0000d400: 7420 6f66 2076 616c 7565 732c 0a20 2020  t of values,.   
-0000d410: 2020 2020 2061 6e64 2074 6865 206c 6f77       and the low
-0000d420: 6572 2062 696e 2062 6f75 6e64 6172 6965  er bin boundarie
-0000d430: 732e 0a0a 2020 2020 2020 2020 2a2a 4578  s...        **Ex
-0000d440: 616d 706c 653a 2a2a 2047 6574 2074 6865  ample:** Get the
-0000d450: 2072 656c 6174 6976 6520 6672 6571 7565   relative freque
-0000d460: 6e63 6965 7320 6f6e 6c79 3a0a 0a20 2020  ncies only:..   
-0000d470: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
-0000d480: 726b 2e5f 6375 6d5f 6869 7374 6f67 7261  rk._cum_histogra
-0000d490: 6d28 0a20 2020 2020 2020 202e 2e2e 2020  m(.        ...  
-0000d4a0: 2020 2076 616c 7565 733d 5b31 2c32 2c31     values=[1,2,1
-0000d4b0: 335d 2c20 6e5f 6269 6e73 3d33 2c20 696e  3], n_bins=3, in
-0000d4c0: 7465 7276 616c 3d28 302c 3330 2929 5b30  terval=(0,30))[0
-0000d4d0: 5d29 0a20 2020 2020 2020 2061 7272 6179  ]).        array
-0000d4e0: 285b 2031 2e20 2c20 2030 2e33 3333 332c  ([ 1. ,  0.3333,
-0000d4f0: 2020 302e 205d 290a 0a20 2020 2020 2020    0. ])..       
-0000d500: 203a 7479 7065 2076 616c 7565 733a 2031   :type values: 1
-0000d510: 6420 6172 7261 7920 6f72 206c 6973 7420  d array or list 
-0000d520: 6f66 2066 6c6f 6174 730a 2020 2020 2020  of floats.      
-0000d530: 2020 3a61 7267 2020 7661 6c75 6573 3a20    :arg  values: 
-0000d540: 5468 6520 7661 6c75 6573 2077 686f 7365  The values whose
-0000d550: 2064 6973 7472 6962 7574 696f 6e20 6973   distribution is
-0000d560: 2077 616e 7465 642e 0a0a 2020 2020 2020   wanted...      
-0000d570: 2020 3a74 7970 6520 6e5f 6269 6e73 3a20    :type n_bins: 
-0000d580: 696e 7420 3e20 300a 2020 2020 2020 2020  int > 0.        
-0000d590: 3a61 7267 2020 6e5f 6269 6e73 3a20 4e75  :arg  n_bins: Nu
-0000d5a0: 6d62 6572 206f 6620 6269 6e73 2074 6f20  mber of bins to 
-0000d5b0: 6265 2075 7365 6420 666f 7220 7468 6520  be used for the 
-0000d5c0: 6869 7374 6f67 7261 6d2e 0a0a 2020 2020  histogram...    
-0000d5d0: 2020 2020 3a74 7970 6520 696e 7465 7276      :type interv
-0000d5e0: 616c 3a20 7475 706c 6520 2866 6c6f 6174  al: tuple (float
-0000d5f0: 2c66 6c6f 6174 292c 206f 7220 4e6f 6e65  ,float), or None
-0000d600: 0a20 2020 2020 2020 203a 6172 6720 2069  .        :arg  i
-0000d610: 6e74 6572 7661 6c3a 204f 7074 696f 6e61  nterval: Optiona
-0000d620: 6c20 7261 6e67 6520 746f 2075 7365 2e20  l range to use. 
-0000d630: 4966 204e 6f6e 652c 2074 6865 206d 696e  If None, the min
-0000d640: 696d 756d 2061 6e64 206d 6178 696d 756d  imum and maximum
-0000d650: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d660: 2020 2020 2020 2020 2076 616c 7565 7320           values 
-0000d670: 6172 6520 7573 6564 2e20 2844 6566 6175  are used. (Defau
-0000d680: 6c74 3a20 4e6f 6e65 290a 0a20 2020 2020  lt: None)..     
-0000d690: 2020 203a 7274 7970 653a 2020 7475 706c     :rtype:  tupl
-0000d6a0: 6520 286c 6973 742c 6c69 7374 290a 2020  e (list,list).  
-0000d6b0: 2020 2020 2020 3a72 6574 7572 6e3a 2041        :return: A
-0000d6c0: 206c 6973 7420 6f66 2063 756d 756c 6174   list of cumulat
-0000d6d0: 6976 6520 7265 6c61 7469 7665 2062 696e  ive relative bin
-0000d6e0: 2066 7265 7175 656e 6369 6573 0a20 2020   frequencies.   
-0000d6f0: 2020 2020 2020 2020 2020 2020 2020 2865                (e
-0000d700: 6e74 7279 205b 695d 2069 7320 7468 6520  ntry [i] is the 
-0000d710: 7375 6d20 6f66 2074 6865 2066 7265 7175  sum of the frequ
-0000d720: 656e 6369 6573 206f 6620 616c 6c20 6269  encies of all bi
-0000d730: 6e73 206a 203e 3d20 6929 2c0a 2020 2020  ns j >= i),.    
-0000d740: 2020 2020 2020 2020 2020 2020 2061 6e64               and
-0000d750: 2061 206c 6973 7420 6f66 206c 6f77 6572   a list of lower
-0000d760: 2062 696e 2062 6f75 6e64 6172 6965 732e   bin boundaries.
-0000d770: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0000d780: 2020 2020 2028 7265 6c5f 6672 6571 732c       (rel_freqs,
-0000d790: 205f 2c20 6269 6e5f 7374 6172 7473 2920   _, bin_starts) 
-0000d7a0: 3d20 5c0a 2020 2020 2020 2020 2020 2020  = \.            
-0000d7b0: 4e65 7477 6f72 6b2e 5f68 6973 746f 6772  Network._histogr
-0000d7c0: 616d 2876 616c 7565 733d 7661 6c75 6573  am(values=values
-0000d7d0: 2c20 6e5f 6269 6e73 3d6e 5f62 696e 732c  , n_bins=n_bins,
-0000d7e0: 2069 6e74 6572 7661 6c3d 696e 7465 7276   interval=interv
-0000d7f0: 616c 290a 2020 2020 2020 2020 6375 6d5f  al).        cum_
-0000d800: 7265 6c5f 6672 6571 7320 3d20 7265 6c5f  rel_freqs = rel_
-0000d810: 6672 6571 735b 3a3a 2d31 5d2e 6375 6d73  freqs[::-1].cums
-0000d820: 756d 2829 5b3a 3a2d 315d 0a20 2020 2020  um()[::-1].     
-0000d830: 2020 2072 6574 7572 6e20 2863 756d 5f72     return (cum_r
-0000d840: 656c 5f66 7265 7173 2c20 6269 6e5f 7374  el_freqs, bin_st
-0000d850: 6172 7473 290a 0a20 2020 2023 0a20 2020  arts)..    #.   
-0000d860: 2023 2020 4d65 7468 6f64 7320 776f 726b   #  Methods work
-0000d870: 696e 6720 7769 7468 206e 6f64 6520 6174  ing with node at
-0000d880: 7472 6962 7574 6573 0a20 2020 2023 0a0a  tributes.    #..
-0000d890: 2020 2020 6465 6620 7365 745f 6e6f 6465      def set_node
-0000d8a0: 5f61 7474 7269 6275 7465 2873 656c 662c  _attribute(self,
-0000d8b0: 2061 7474 7269 6275 7465 5f6e 616d 652c   attribute_name,
-0000d8c0: 2076 616c 7565 7329 3a0a 2020 2020 2020   values):.      
-0000d8d0: 2020 2222 220a 2020 2020 2020 2020 4164    """.        Ad
-0000d8e0: 6420 6120 6e6f 6465 2061 7474 7269 6275  d a node attribu
-0000d8f0: 7465 2e0a 0a20 2020 2020 2020 2045 7861  te...        Exa
-0000d900: 6d70 6c65 7320 666f 7220 6e6f 6465 2061  mples for node a
-0000d910: 7474 7269 6275 7465 732f 7765 6967 6874  ttributes/weight
-0000d920: 7320 6172 6520 6465 6772 6565 206f 7220  s are degree or 
-0000d930: 6265 7477 6565 6e6e 6573 732e 0a0a 2020  betweenness...  
-0000d940: 2020 2020 2020 3a61 7267 2073 7472 2061        :arg str a
-0000d950: 7474 7269 6275 7465 5f6e 616d 653a 2054  ttribute_name: T
-0000d960: 6865 206e 616d 6520 6f66 2074 6865 206e  he name of the n
-0000d970: 6f64 6520 6174 7472 6962 7574 652e 0a0a  ode attribute...
-0000d980: 2020 2020 2020 2020 3a74 7970 6520 7661          :type va
-0000d990: 6c75 6573 3a20 3144 204e 756d 7079 2061  lues: 1D Numpy a
-0000d9a0: 7272 6179 205b 6e6f 6465 5d0a 2020 2020  rray [node].    
-0000d9b0: 2020 2020 3a61 7267 2076 616c 7565 733a      :arg values:
-0000d9c0: 2054 6865 206e 6f64 6520 6174 7472 6962   The node attrib
-0000d9d0: 7574 6520 7365 7175 656e 6365 2e0a 2020  ute sequence..  
-0000d9e0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000d9f0: 2020 2320 544f 444f 3a20 6164 6420 6578    # TODO: add ex
-0000da00: 616d 706c 650a 0a20 2020 2020 2020 2023  ample..        #
-0000da10: 2020 5465 7374 2077 6865 7468 6572 2074    Test whether t
-0000da20: 6865 2064 6174 6120 7665 6374 6f72 2068  he data vector h
-0000da30: 6173 2074 6865 2073 616d 6520 6c65 6e67  as the same leng
-0000da40: 7468 2061 7320 7468 6520 6e75 6d62 6572  th as the number
-0000da50: 206f 660a 2020 2020 2020 2020 2320 206e   of.        #  n
-0000da60: 6f64 6573 2069 6e20 7468 6520 6772 6170  odes in the grap
-0000da70: 682e 0a20 2020 2020 2020 2069 6620 6c65  h..        if le
-0000da80: 6e28 7661 6c75 6573 2920 3d3d 2073 656c  n(values) == sel
-0000da90: 662e 4e3a 0a20 2020 2020 2020 2020 2020  f.N:.           
-0000daa0: 2023 2020 4164 6420 6e6f 6465 2070 726f   #  Add node pro
-0000dab0: 7065 7274 7920 746f 2069 6772 6170 6820  perty to igraph 
-0000dac0: 4772 6170 6820 6f62 6a65 6374 0a20 2020  Graph object.   
-0000dad0: 2020 2020 2020 2020 2073 656c 662e 6772           self.gr
-0000dae0: 6170 682e 7673 2e73 6574 5f61 7474 7269  aph.vs.set_attri
-0000daf0: 6275 7465 5f76 616c 7565 7328 6174 7472  bute_values(attr
-0000db00: 6e61 6d65 3d61 7474 7269 6275 7465 5f6e  name=attribute_n
-0000db10: 616d 652c 0a20 2020 2020 2020 2020 2020  ame,.           
+0000b1c0: 2020 2020 2020 7261 6e64 6f6d 2e75 6e69        random.uni
+0000b1d0: 666f 726d 286c 6f77 3d30 2c20 6869 6768  form(low=0, high
+0000b1e0: 3d6c 656e 286c 696e 6b5f 7461 7267 6574  =len(link_target
+0000b1f0: 2929 295d 290a 2020 2020 2020 2020 2020  )))]).          
+0000b200: 2020 2020 2020 2020 2020 7768 696c 6520            while 
+0000b210: 6920 3d3d 206a 3220 6f72 2041 5b69 2c20  i == j2 or A[i, 
+0000b220: 6a32 5d20 3d3d 2031 3a0a 2020 2020 2020  j2] == 1:.      
+0000b230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b240: 2020 2320 6920 3d20 696e 7428 696e 635f    # i = int(inc_
+0000b250: 7461 7267 6574 5b69 6e74 280a 2020 2020  target[int(.    
+0000b260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b270: 2020 2020 2320 2020 2020 7261 6e64 6f6d      #     random
+0000b280: 2e75 6e69 666f 726d 286c 656e 2869 6e63  .uniform(len(inc
+0000b290: 5f74 6172 6765 7429 2929 5d29 0a20 2020  _target)))]).   
+0000b2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2b0: 2020 2020 2069 203d 2069 6e74 286c 696e       i = int(lin
+0000b2c0: 6b5f 7461 7267 6574 5b69 6e74 280a 2020  k_target[int(.  
+0000b2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2e0: 2020 2020 2020 2020 2020 7261 6e64 6f6d            random
+0000b2f0: 2e75 6e69 666f 726d 286c 6f77 3d30 2c20  .uniform(low=0, 
+0000b300: 6869 6768 3d6c 656e 286c 696e 6b5f 7461  high=len(link_ta
+0000b310: 7267 6574 2929 295d 290a 2020 2020 2020  rget)))]).      
+0000b320: 2020 2020 2020 2020 2020 2020 2020 415b                A[
+0000b330: 692c 206a 325d 203d 2041 5b6a 322c 2069  i, j2] = A[j2, i
+0000b340: 5d20 3d20 310a 2020 2020 2020 2020 2020  ] = 1.          
+0000b350: 2020 2020 2020 2020 2020 6e62 735b 6a32            nbs[j2
+0000b360: 5d2e 6170 7065 6e64 2869 290a 2020 2020  ].append(i).    
+0000b370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b380: 6e62 735b 695d 2e61 7070 656e 6428 6a32  nbs[i].append(j2
+0000b390: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000b3a0: 2020 2020 2020 6c69 6e6b 5f74 6172 6765        link_targe
+0000b3b0: 7420 2b3d 205b 6a32 2066 6f72 2069 6969  t += [j2 for iii
+0000b3c0: 2069 6e20 7261 6e67 6528 775b 695d 295d   in range(w[i])]
+0000b3d0: 202b 205c 0a20 2020 2020 2020 2020 2020   + \.           
+0000b3e0: 2020 2020 2020 2020 2020 2020 205b 6920               [i 
+0000b3f0: 666f 7220 6969 6920 696e 2072 616e 6765  for iii in range
+0000b400: 2877 5b6a 325d 295d 0a0a 2020 2020 2020  (w[j2])]..      
+0000b410: 2020 2020 2020 6465 6c20 6c69 6e6b 5f74        del link_t
+0000b420: 6172 6765 740a 0a20 2020 2020 2020 2064  arget..        d
+0000b430: 656c 206e 6273 2c20 696e 635f 7461 7267  el nbs, inc_targ
+0000b440: 6574 0a20 2020 2020 2020 2072 6574 7572  et.        retur
+0000b450: 6e20 4e65 7477 6f72 6b28 412c 206e 6f64  n Network(A, nod
+0000b460: 655f 7765 6967 6874 733d 772c 2073 696c  e_weights=w, sil
+0000b470: 656e 6365 5f6c 6576 656c 3d73 696c 656e  ence_level=silen
+0000b480: 6365 5f6c 6576 656c 290a 0a20 2020 2040  ce_level)..    @
+0000b490: 7374 6174 6963 6d65 7468 6f64 0a20 2020  staticmethod.   
+0000b4a0: 2064 6566 2047 726f 7757 6569 6768 7473   def GrowWeights
+0000b4b0: 286e 5f6e 6f64 6573 3d31 3030 2c20 6e5f  (n_nodes=100, n_
+0000b4c0: 696e 6974 6961 6c73 3d31 2c20 6578 706f  initials=1, expo
+0000b4d0: 6e65 6e74 3d31 2c0a 2020 2020 2020 2020  nent=1,.        
+0000b4e0: 2020 2020 2020 2020 2020 2020 6d6f 6465              mode
+0000b4f0: 3d22 6578 7022 2c0a 2020 2020 2020 2020  ="exp",.        
+0000b500: 2020 2020 2020 2020 2020 2020 7370 6c69              spli
+0000b510: 745f 7072 6f62 3d2e 3031 2c20 2023 2066  t_prob=.01,  # f
+0000b520: 6f72 2065 7870 6f6e 656e 7469 616c 206d  or exponential m
+0000b530: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
+0000b540: 2020 2020 2020 2020 2073 706c 6974 5f77           split_w
+0000b550: 6569 6768 743d 3130 302c 2020 2320 666f  eight=100,  # fo
+0000b560: 7220 7265 6369 7072 6f63 616c 206d 6f64  r reciprocal mod
+0000b570: 656c 0a20 2020 2020 2020 2020 2020 2020  el.             
+0000b580: 2020 2020 2020 2062 6574 613d 312e 302c         beta=1.0,
+0000b590: 206e 5f69 6e63 7265 6173 6573 3d31 6531   n_increases=1e1
+0000b5a0: 3030 293a 0a20 2020 2020 2020 2022 2222  00):.        """
+0000b5b0: 0a20 2020 2020 2020 2045 5850 4552 494d  .        EXPERIM
+0000b5c0: 454e 5441 4c0a 2020 2020 2020 2020 2222  ENTAL.        ""
+0000b5d0: 220a 2020 2020 2020 2020 4e20 3d20 6e5f  ".        N = n_
+0000b5e0: 6e6f 6465 730a 2020 2020 2020 2020 7720  nodes.        w 
+0000b5f0: 3d20 6e70 2e7a 6572 6f73 284e 290a 2020  = np.zeros(N).  
+0000b600: 2020 2020 2020 696e 635f 7072 6f62 203d        inc_prob =
+0000b610: 206e 702e 7a65 726f 7328 4e29 0a20 2020   np.zeros(N).   
+0000b620: 2020 2020 2077 5b3a 6e5f 696e 6974 6961       w[:n_initia
+0000b630: 6c73 5d20 3d20 310a 2020 2020 2020 2020  ls] = 1.        
+0000b640: 696e 635f 7072 6f62 5b3a 6e5f 696e 6974  inc_prob[:n_init
+0000b650: 6961 6c73 5d20 3d20 310a 2020 2020 2020  ials] = 1.      
+0000b660: 2020 746f 7461 6c5f 696e 635f 7072 6f62    total_inc_prob
+0000b670: 203d 2069 6e63 5f70 726f 622e 7375 6d28   = inc_prob.sum(
+0000b680: 290a 2020 2020 2020 2020 686f 6c64 5f70  ).        hold_p
+0000b690: 726f 6220 3d20 3120 2d20 7370 6c69 745f  rob = 1 - split_
+0000b6a0: 7072 6f62 0a0a 2020 2020 2020 2020 6465  prob..        de
+0000b6b0: 6620 5f69 6e63 5f74 6172 6765 7428 293a  f _inc_target():
+0000b6c0: 0a20 2020 2020 2020 2020 2020 2074 6864  .            thd
+0000b6d0: 203d 2072 616e 646f 6d2e 756e 6966 6f72   = random.unifor
+0000b6e0: 6d28 6c6f 773d 302c 2068 6967 683d 746f  m(low=0, high=to
+0000b6f0: 7461 6c5f 696e 635f 7072 6f62 290a 2020  tal_inc_prob).  
+0000b700: 2020 2020 2020 2020 2020 6920 3d20 300a            i = 0.
+0000b710: 2020 2020 2020 2020 2020 2020 6375 6d20              cum 
+0000b720: 3d20 696e 635f 7072 6f62 5b30 5d0a 2020  = inc_prob[0].  
+0000b730: 2020 2020 2020 2020 2020 7768 696c 6520            while 
+0000b740: 6375 6d20 3c20 7468 643a 0a20 2020 2020  cum < thd:.     
+0000b750: 2020 2020 2020 2020 2020 2069 202b 3d20             i += 
+0000b760: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+0000b770: 2020 6375 6d20 2b3d 2069 6e63 5f70 726f    cum += inc_pro
+0000b780: 625b 695d 0a20 2020 2020 2020 2020 2020  b[i].           
+0000b790: 2072 6574 7572 6e20 690a 0a20 2020 2020   return i..     
+0000b7a0: 2020 2074 6869 735f 4e20 3d20 6e5f 696e     this_N = n_in
+0000b7b0: 6974 6961 6c73 0a20 2020 2020 2020 2069  itials.        i
+0000b7c0: 7420 3d20 300a 2020 2020 2020 2020 7769  t = 0.        wi
+0000b7d0: 7468 2074 7164 6d28 746f 7461 6c3d 4e29  th tqdm(total=N)
+0000b7e0: 2061 7320 7062 6172 3a0a 2020 2020 2020   as pbar:.      
+0000b7f0: 2020 2020 2020 7768 696c 6520 7468 6973        while this
+0000b800: 5f4e 203c 204e 2061 6e64 2069 7420 3c20  _N < N and it < 
+0000b810: 6e5f 696e 6372 6561 7365 733a 0a20 2020  n_increases:.   
+0000b820: 2020 2020 2020 2020 2020 2020 2069 7420               it 
+0000b830: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+0000b840: 2020 2020 2069 203d 205f 696e 635f 7461       i = _inc_ta
+0000b850: 7267 6574 2829 0a20 2020 2020 2020 2020  rget().         
+0000b860: 2020 2020 2020 2074 6f74 616c 5f69 6e63         total_inc
+0000b870: 5f70 726f 6220 2d3d 2069 6e63 5f70 726f  _prob -= inc_pro
+0000b880: 625b 695d 0a20 2020 2020 2020 2020 2020  b[i].           
+0000b890: 2020 2020 2077 5b69 5d20 2b3d 2031 0a20       w[i] += 1. 
+0000b8a0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000b8b0: 6e63 5f70 726f 625b 695d 203d 2077 5b69  nc_prob[i] = w[i
+0000b8c0: 5d2a 2a65 7870 6f6e 656e 740a 2020 2020  ]**exponent.    
+0000b8d0: 2020 2020 2020 2020 2020 2020 746f 7461              tota
+0000b8e0: 6c5f 696e 635f 7072 6f62 202b 3d20 696e  l_inc_prob += in
+0000b8f0: 635f 7072 6f62 5b69 5d0a 2020 2020 2020  c_prob[i].      
+0000b900: 2020 2020 2020 2020 2020 6966 2028 6d6f            if (mo
+0000b910: 6465 203d 3d20 2265 7870 2220 616e 6420  de == "exp" and 
+0000b920: 7261 6e64 6f6d 2e75 6e69 666f 726d 2829  random.uniform()
+0000b930: 203e 2068 6f6c 645f 7072 6f62 2a2a 775b   > hold_prob**w[
+0000b940: 695d 2920 6f72 205c 0a20 2020 2020 2020  i]) or \.       
+0000b950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b960: 2028 6d6f 6465 203d 3d20 2272 6563 2220   (mode == "rec" 
+0000b970: 616e 6420 7261 6e64 6f6d 2e75 6e69 666f  and random.unifo
+0000b980: 726d 2829 0a20 2020 2020 2020 2020 2020  rm().           
+0000b990: 2020 2020 2020 2020 2020 2020 2020 3c20                < 
+0000b9a0: 775b 695d 2a31 2e30 2f28 7370 6c69 745f  w[i]*1.0/(split_
+0000b9b0: 7765 6967 6874 2b77 5b69 5d29 293a 2020  weight+w[i])):  
+0000b9c0: 2320 7265 6369 7072 6f63 616c 0a20 2020  # reciprocal.   
+0000b9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b9e0: 2023 2073 706c 6974 2069 2069 6e74 6f20   # split i into 
+0000b9f0: 692c 7468 6973 5f4e 3a0a 2020 2020 2020  i,this_N:.      
+0000ba00: 2020 2020 2020 2020 2020 2020 2020 746f                to
+0000ba10: 7461 6c5f 696e 635f 7072 6f62 202d 3d20  tal_inc_prob -= 
+0000ba20: 696e 635f 7072 6f62 5b69 5d0a 2020 2020  inc_prob[i].    
+0000ba30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ba40: 775b 7468 6973 5f4e 5d20 3d20 775b 695d  w[this_N] = w[i]
+0000ba50: 2a72 616e 646f 6d2e 6265 7461 2862 6574  *random.beta(bet
+0000ba60: 612c 2062 6574 6129 0a20 2020 2020 2020  a, beta).       
+0000ba70: 2020 2020 2020 2020 2020 2020 2077 5b69               w[i
+0000ba80: 5d20 2d3d 2077 5b74 6869 735f 4e5d 0a20  ] -= w[this_N]. 
+0000ba90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000baa0: 2020 2069 6e63 5f70 726f 625b 7468 6973     inc_prob[this
+0000bab0: 5f4e 5d20 3d20 775b 7468 6973 5f4e 5d2a  _N] = w[this_N]*
+0000bac0: 2a65 7870 6f6e 656e 740a 2020 2020 2020  *exponent.      
+0000bad0: 2020 2020 2020 2020 2020 2020 2020 696e                in
+0000bae0: 635f 7072 6f62 5b69 5d20 3d20 775b 695d  c_prob[i] = w[i]
+0000baf0: 2a2a 6578 706f 6e65 6e74 0a20 2020 2020  **exponent.     
+0000bb00: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000bb10: 6f74 616c 5f69 6e63 5f70 726f 6220 2b3d  otal_inc_prob +=
+0000bb20: 2069 6e63 5f70 726f 625b 7468 6973 5f4e   inc_prob[this_N
+0000bb30: 5d20 2b20 696e 635f 7072 6f62 5b69 5d0a  ] + inc_prob[i].
+0000bb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb50: 2020 2020 7468 6973 5f4e 202b 3d20 310a      this_N += 1.
+0000bb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb70: 2020 2020 7062 6172 2e75 7064 6174 6528      pbar.update(
+0000bb80: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0000bb90: 2077 0a0a 2020 2020 6465 6620 7261 6e64   w..    def rand
+0000bba0: 6f6d 6c79 5f72 6577 6972 6528 7365 6c66  omly_rewire(self
+0000bbb0: 2c20 6974 6572 6174 696f 6e73 293a 0a20  , iterations):. 
+0000bbc0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0000bbd0: 2020 2052 616e 646f 6d6c 7920 7265 7769     Randomly rewi
+0000bbe0: 7265 2074 6865 206e 6574 776f 726b 2c20  re the network, 
+0000bbf0: 7072 6573 6572 7669 6e67 2074 6865 2064  preserving the d
+0000bc00: 6567 7265 6520 7365 7175 656e 6365 2e0a  egree sequence..
+0000bc10: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
+0000bc20: 6c65 3a2a 2a20 4765 6e65 7261 7465 2061  le:** Generate a
+0000bc30: 206e 6574 776f 726b 206f 6620 3130 3020   network of 100 
+0000bc40: 6e6f 6465 7320 7769 7468 2064 6567 7265  nodes with degre
+0000bc50: 6520 3520 6561 6368 3a0a 0a20 2020 2020  e 5 each:..     
+0000bc60: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
+0000bc70: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
+0000bc80: 7477 6f72 6b28 293b 2070 7269 6e74 286e  twork(); print(n
+0000bc90: 6574 290a 2020 2020 2020 2020 4e65 7477  et).        Netw
+0000bca0: 6f72 6b3a 2075 6e64 6972 6563 7465 642c  ork: undirected,
+0000bcb0: 2036 206e 6f64 6573 2c20 3720 6c69 6e6b   6 nodes, 7 link
+0000bcc0: 732c 206c 696e 6b20 6465 6e73 6974 7920  s, link density 
+0000bcd0: 302e 3436 372e 0a20 2020 2020 2020 203e  0.467..        >
+0000bce0: 3e3e 206e 6574 2e72 616e 646f 6d6c 795f  >> net.randomly_
+0000bcf0: 7265 7769 7265 2869 7465 7261 7469 6f6e  rewire(iteration
+0000bd00: 733d 3130 293b 2070 7269 6e74 286e 6574  s=10); print(net
+0000bd10: 290a 2020 2020 2020 2020 5261 6e64 6f6d  ).        Random
+0000bd20: 6c79 2072 6577 6972 696e 6720 7468 6520  ly rewiring the 
+0000bd30: 6e65 7477 6f72 6b2c 7072 6573 6572 7669  network,preservi
+0000bd40: 6e67 2074 6865 2064 6567 7265 6520 7365  ng the degree se
+0000bd50: 7175 656e 6365 2e2e 2e0a 2020 2020 2020  quence....      
+0000bd60: 2020 4e65 7477 6f72 6b3a 2075 6e64 6972    Network: undir
+0000bd70: 6563 7465 642c 2036 206e 6f64 6573 2c20  ected, 6 nodes, 
+0000bd80: 3720 6c69 6e6b 732c 206c 696e 6b20 6465  7 links, link de
+0000bd90: 6e73 6974 7920 302e 3436 372e 0a0a 2020  nsity 0.467...  
+0000bda0: 2020 2020 2020 3a74 7970 6520 6974 6572        :type iter
+0000bdb0: 6174 696f 6e73 3a20 696e 7420 3e20 300a  ations: int > 0.
+0000bdc0: 2020 2020 2020 2020 3a61 7267 2069 7465          :arg ite
+0000bdd0: 7261 7469 6f6e 733a 204e 756d 6265 7220  rations: Number 
+0000bde0: 6f66 2069 7465 7261 7469 6f6e 732e 2049  of iterations. I
+0000bdf0: 6e20 6561 6368 2069 7465 7261 7469 6f6e  n each iteration
+0000be00: 2c20 7477 6f20 7261 6e64 6f6d 6c79 0a20  , two randomly. 
+0000be10: 2020 2020 2020 2020 2020 2063 686f 7365             chose
+0000be20: 6e20 6c69 6e6b 7320 612d 2d62 2061 6e64  n links a--b and
+0000be30: 2063 2d2d 6420 666f 7220 7768 6963 6820   c--d for which 
+0000be40: 7b61 2c63 7d20 616e 6420 7b62 2c64 7d20  {a,c} and {b,d} 
+0000be50: 6172 6520 6e6f 740a 2020 2020 2020 2020  are not.        
+0000be60: 2020 2020 6c69 6e6b 6564 2c20 6172 6520      linked, are 
+0000be70: 7265 706c 6163 6564 2062 7920 7468 6520  replaced by the 
+0000be80: 6c69 6e6b 7320 612d 2d63 2061 6e64 2062  links a--c and b
+0000be90: 2d2d 642e 0a20 2020 2020 2020 2022 2222  --d..        """
+0000bea0: 0a20 2020 2020 2020 2023 2054 4f44 4f3a  .        # TODO:
+0000beb0: 2076 6572 6966 7920 7468 6174 2069 7420   verify that it 
+0000bec0: 6973 2069 6e64 6565 6420 6173 2064 6573  is indeed as des
+0000bed0: 6372 6962 6564 2061 626f 7665 2e0a 2020  cribed above..  
+0000bee0: 2020 2020 2020 6966 2073 656c 662e 7369        if self.si
+0000bef0: 6c65 6e63 655f 6c65 7665 6c20 3c3d 2031  lence_level <= 1
+0000bf00: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+0000bf10: 696e 7428 2252 616e 646f 6d6c 7920 7265  int("Randomly re
+0000bf20: 7769 7269 6e67 2074 6865 206e 6574 776f  wiring the netwo
+0000bf30: 726b 2c22 0a20 2020 2020 2020 2020 2020  rk,".           
+0000bf40: 2020 2020 2020 202b 2022 7072 6573 6572         + "preser
+0000bf50: 7669 6e67 2074 6865 2064 6567 7265 6520  ving the degree 
+0000bf60: 7365 7175 656e 6365 2e2e 2e22 290a 0a20  sequence...").. 
+0000bf70: 2020 2020 2020 2023 2072 6577 6972 6520         # rewire 
+0000bf80: 656d 6265 6464 6564 2069 6772 6170 682e  embedded igraph.
+0000bf90: 4772 6170 683a 0a20 2020 2020 2020 2073  Graph:.        s
+0000bfa0: 656c 662e 6772 6170 682e 7265 7769 7265  elf.graph.rewire
+0000bfb0: 2869 7465 7261 7469 6f6e 7329 0a0a 2020  (iterations)..  
+0000bfc0: 2020 2020 2020 2320 7570 6461 7465 2061        # update a
+0000bfd0: 6c6c 2064 6174 6120 7468 6174 2064 6570  ll data that dep
+0000bfe0: 656e 6473 206f 6e20 7265 7769 7265 6420  ends on rewired 
+0000bff0: 6564 6765 206c 6973 743a 0a20 2020 2020  edge list:.     
+0000c000: 2020 2073 656c 662e 7365 745f 6564 6765     self.set_edge
+0000c010: 5f6c 6973 7428 7365 6c66 2e67 7261 7068  _list(self.graph
+0000c020: 2e67 6574 5f65 6467 656c 6973 7428 2929  .get_edgelist())
+0000c030: 0a0a 2020 2020 6465 6620 6564 6765 5f6c  ..    def edge_l
+0000c040: 6973 7428 7365 6c66 293a 0a20 2020 2020  ist(self):.     
+0000c050: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
+0000c060: 6574 7572 6e20 7468 6520 6e65 7477 6f72  eturn the networ
+0000c070: 6b27 7320 6564 6765 206c 6973 742e 0a0a  k's edge list...
+0000c080: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
+0000c090: 653a 2a2a 0a0a 2020 2020 2020 2020 3e3e  e:**..        >>
+0000c0a0: 3e20 7072 696e 7428 4e65 7477 6f72 6b2e  > print(Network.
+0000c0b0: 536d 616c 6c54 6573 744e 6574 776f 726b  SmallTestNetwork
+0000c0c0: 2829 2e65 6467 655f 6c69 7374 2829 5b3a  ().edge_list()[:
+0000c0d0: 385d 290a 2020 2020 2020 2020 5b5b 3020  8]).        [[0 
+0000c0e0: 335d 205b 3020 345d 205b 3020 355d 205b  3] [0 4] [0 5] [
+0000c0f0: 3120 325d 205b 3120 335d 205b 3120 345d  1 2] [1 3] [1 4]
+0000c100: 205b 3220 315d 205b 3220 345d 5d0a 0a20   [2 1] [2 4]].. 
+0000c110: 2020 2020 2020 203a 7274 7970 653a 2061         :rtype: a
+0000c120: 7272 6179 2d6c 696b 6520 286e 756d 7079  rray-like (numpy
+0000c130: 206d 6174 7269 7820 6f72 206c 6973 7420   matrix or list 
+0000c140: 6f66 206c 6973 7473 2f74 7570 6c65 7329  of lists/tuples)
+0000c150: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000c160: 2020 2020 2072 6574 7572 6e20 6e7a 5f63       return nz_c
+0000c170: 6f6f 7264 7328 7365 6c66 2e73 705f 4129  oords(self.sp_A)
+0000c180: 0a0a 2020 2020 6465 6620 756e 6469 7265  ..    def undire
+0000c190: 6374 6564 5f61 646a 6163 656e 6379 2873  cted_adjacency(s
+0000c1a0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+0000c1b0: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
+0000c1c0: 2074 6865 2061 646a 6163 656e 6379 206d   the adjacency m
+0000c1d0: 6174 7269 7820 6f66 2074 6865 2075 6e64  atrix of the und
+0000c1e0: 6972 6563 7465 6420 7665 7273 696f 6e20  irected version 
+0000c1f0: 6f66 2074 6865 206e 6574 776f 726b 0a20  of the network. 
+0000c200: 2020 2020 2020 2061 7320 6120 6465 6e73         as a dens
+0000c210: 6520 6e75 6d70 7920 6172 7261 792e 0a20  e numpy array.. 
+0000c220: 2020 2020 2020 2045 6e74 7279 205b 692c         Entry [i,
+0000c230: 6a5d 2069 7320 3120 6966 2069 206c 696e  j] is 1 if i lin
+0000c240: 6b73 2074 6f20 6a20 6f72 206a 206c 696e  ks to j or j lin
+0000c250: 6b73 2074 6f20 692e 0a0a 2020 2020 2020  ks to i...      
+0000c260: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
+0000c270: 2020 2020 2020 2020 3e3e 3e20 6e65 7420          >>> net 
+0000c280: 3d20 4e65 7477 6f72 6b28 6164 6a61 6365  = Network(adjace
+0000c290: 6e63 793d 5b5b 302c 315d 2c5b 302c 305d  ncy=[[0,1],[0,0]
+0000c2a0: 5d2c 2064 6972 6563 7465 643d 5472 7565  ], directed=True
+0000c2b0: 290a 2020 2020 2020 2020 3e3e 3e20 7072  ).        >>> pr
+0000c2c0: 696e 7428 6e65 742e 756e 6469 7265 6374  int(net.undirect
+0000c2d0: 6564 5f61 646a 6163 656e 6379 2829 2e41  ed_adjacency().A
+0000c2e0: 290a 2020 2020 2020 2020 5b5b 3020 315d  ).        [[0 1]
+0000c2f0: 205b 3120 305d 5d0a 0a20 2020 2020 2020   [1 0]]..       
+0000c300: 203a 7274 7970 653a 2061 7272 6179 285b   :rtype: array([
+0000c310: 5b30 7c31 5d5d 290a 2020 2020 2020 2020  [0|1]]).        
+0000c320: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+0000c330: 726e 2073 656c 662e 7370 5f41 2e6d 6178  rn self.sp_A.max
+0000c340: 696d 756d 2873 656c 662e 7370 5f41 2e54  imum(self.sp_A.T
+0000c350: 290a 0a20 2020 2064 6566 206c 6170 6c61  )..    def lapla
+0000c360: 6369 616e 2873 656c 662c 2064 6972 6563  cian(self, direc
+0000c370: 7469 6f6e 3d22 6f75 7422 2c20 6c69 6e6b  tion="out", link
+0000c380: 5f61 7474 7269 6275 7465 3d4e 6f6e 6529  _attribute=None)
+0000c390: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+0000c3a0: 2020 2020 2020 5265 7475 726e 2074 6865        Return the
+0000c3b0: 2028 706f 7373 6962 6c79 206e 6f6e 2d73   (possibly non-s
+0000c3c0: 796d 6d65 7472 6963 2920 6465 6e73 6520  ymmetric) dense 
+0000c3d0: 4c61 706c 6163 6961 6e20 6d61 7472 6978  Laplacian matrix
+0000c3e0: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+0000c3f0: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+0000c400: 203e 3e3e 2072 284e 6574 776f 726b 2e53   >>> r(Network.S
+0000c410: 6d61 6c6c 5465 7374 4e65 7477 6f72 6b28  mallTestNetwork(
+0000c420: 292e 6c61 706c 6163 6961 6e28 2929 0a20  ).laplacian()). 
+0000c430: 2020 2020 2020 2061 7272 6179 285b 5b20         array([[ 
+0000c440: 332c 2020 302c 2020 302c 202d 312c 202d  3,  0,  0, -1, -
+0000c450: 312c 202d 315d 2c20 5b20 302c 2020 332c  1, -1], [ 0,  3,
+0000c460: 202d 312c 202d 312c 202d 312c 2020 305d   -1, -1, -1,  0]
+0000c470: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000c480: 205b 2030 2c20 2d31 2c20 2032 2c20 2030   [ 0, -1,  2,  0
+0000c490: 2c20 2d31 2c20 2030 5d2c 205b 2d31 2c20  , -1,  0], [-1, 
+0000c4a0: 2d31 2c20 2030 2c20 2032 2c20 2030 2c20  -1,  0,  2,  0, 
+0000c4b0: 2030 5d2c 0a20 2020 2020 2020 2020 2020   0],.           
+0000c4c0: 2020 2020 5b2d 312c 202d 312c 202d 312c      [-1, -1, -1,
+0000c4d0: 2020 302c 2020 332c 2020 305d 2c20 5b2d    0,  3,  0], [-
+0000c4e0: 312c 2020 302c 2020 302c 2020 302c 2020  1,  0,  0,  0,  
+0000c4f0: 302c 2020 315d 5d29 0a0a 2020 2020 2020  0,  1]])..      
+0000c500: 2020 3a61 7267 2073 7472 2064 6972 6563    :arg str direc
+0000c510: 7469 6f6e 3a20 5468 6973 2061 7267 756d  tion: This argum
+0000c520: 656e 7420 6973 2069 676e 6f72 6564 2066  ent is ignored f
+0000c530: 6f72 2075 6e64 6972 6563 7465 6420 6772  or undirected gr
+0000c540: 6170 6873 2e0a 2020 2020 2020 2020 2020  aphs..          
+0000c550: 2020 226f 7574 2220 2d20 6f75 742d 6465    "out" - out-de
+0000c560: 6772 6565 206f 6e20 6469 6167 6f6e 616c  gree on diagonal
+0000c570: 206f 6620 6c61 706c 6163 6961 6e0a 2020   of laplacian.  
+0000c580: 2020 2020 2020 2020 2020 2269 6e22 2020            "in"  
+0000c590: 2d20 696e 2d64 6567 7265 6520 6f6e 2064  - in-degree on d
+0000c5a0: 6961 676f 6e61 6c20 6f66 206c 6170 6c61  iagonal of lapla
+0000c5b0: 6369 616e 0a20 2020 2020 2020 203a 6172  cian.        :ar
+0000c5c0: 6720 7374 7220 6c69 6e6b 5f61 7474 7269  g str link_attri
+0000c5d0: 6275 7465 3a20 6e61 6d65 206f 6620 6c69  bute: name of li
+0000c5e0: 6e6b 2061 7474 7269 6275 7465 2074 6f20  nk attribute to 
+0000c5f0: 6265 2075 7365 640a 2020 2020 2020 2020  be used.        
+0000c600: 3a72 7479 7065 3a20 7371 7561 7265 2061  :rtype: square a
+0000c610: 7272 6179 205b 6e6f 6465 2c6e 6f64 655d  rray [node,node]
+0000c620: 206f 6620 696e 7473 0a20 2020 2020 2020   of ints.       
+0000c630: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+0000c640: 6c69 6e6b 5f61 7474 7269 6275 7465 203d  link_attribute =
+0000c650: 3d20 2274 6f70 6f6c 6f67 6963 616c 223a  = "topological":
+0000c660: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+0000c670: 6e74 2822 5741 524e 494e 473a 206c 696e  nt("WARNING: lin
+0000c680: 6b5f 6174 7472 6962 7574 653d 2774 6f70  k_attribute='top
+0000c690: 6f6c 6f67 6963 616c 2720 6973 2064 6570  ological' is dep
+0000c6a0: 7265 6361 7465 642e 5c6e 220a 2020 2020  recated.\n".    
+0000c6b0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0000c6c0: 2255 7365 206c 696e 6b5f 6174 7472 6962  "Use link_attrib
+0000c6d0: 7574 653d 4e6f 6e65 2069 6e73 7465 6164  ute=None instead
+0000c6e0: 2e22 290a 2020 2020 2020 2020 2020 2020  .").            
+0000c6f0: 6c69 6e6b 5f61 7474 7269 6275 7465 203d  link_attribute =
+0000c700: 204e 6f6e 650a 0a20 2020 2020 2020 2069   None..        i
+0000c710: 6620 6c69 6e6b 5f61 7474 7269 6275 7465  f link_attribute
+0000c720: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000c730: 2020 2020 2020 6966 2073 656c 662e 6469        if self.di
+0000c740: 7265 6374 6564 3a0a 2020 2020 2020 2020  rected:.        
+0000c750: 2020 2020 2020 2020 6966 2064 6972 6563          if direc
+0000c760: 7469 6f6e 203d 3d20 226f 7574 223a 0a20  tion == "out":. 
+0000c770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c780: 2020 2064 6961 676f 6e61 6c20 3d20 7365     diagonal = se
+0000c790: 6c66 2e6f 7574 6465 6772 6565 2829 0a20  lf.outdegree(). 
+0000c7a0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000c7b0: 6c69 6620 6469 7265 6374 696f 6e20 3d3d  lif direction ==
+0000c7c0: 2022 696e 223a 0a20 2020 2020 2020 2020   "in":.         
+0000c7d0: 2020 2020 2020 2020 2020 2064 6961 676f             diago
+0000c7e0: 6e61 6c20 3d20 7365 6c66 2e69 6e64 6567  nal = self.indeg
+0000c7f0: 7265 6528 290a 2020 2020 2020 2020 2020  ree().          
+0000c800: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000c810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c820: 7072 696e 7428 2245 5252 4f52 3a20 6172  print("ERROR: ar
+0000c830: 6775 6d65 6e74 2064 6972 6563 7469 6f6e  gument direction
+0000c840: 206f 6620 4e65 7477 6f72 6b2e 6c61 706c   of Network.lapl
+0000c850: 6163 6961 6e20 220a 2020 2020 2020 2020  acian ".        
+0000c860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c870: 2020 2263 616e 206f 6e6c 7920 7461 6b65    "can only take
+0000c880: 2076 616c 7565 7320 3c3c 696e 3e3e 206f   values <<in>> o
+0000c890: 7220 3c3c 6f75 743e 3e2e 2229 0a20 2020  r <<out>>.").   
+0000c8a0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000c8b0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0000c8c0: 6961 676f 6e61 6c20 3d20 7365 6c66 2e64  iagonal = self.d
+0000c8d0: 6567 7265 6528 290a 0a20 2020 2020 2020  egree()..       
+0000c8e0: 2020 2020 2072 6574 7572 6e20 6e70 2e64       return np.d
+0000c8f0: 6961 6728 6469 6167 6f6e 616c 2c20 3029  iag(diagonal, 0)
+0000c900: 202d 2073 656c 662e 6164 6a61 6365 6e63   - self.adjacenc
+0000c910: 790a 2020 2020 2020 2020 656c 7365 3a0a  y.        else:.
+0000c920: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000c930: 6520 4e6f 7449 6d70 6c65 6d65 6e74 6564  e NotImplemented
+0000c940: 4572 726f 7228 224f 6e6c 7920 696d 706c  Error("Only impl
+0000c950: 656d 656e 7465 6420 666f 7220 6c69 6e6b  emented for link
+0000c960: 5f61 7474 7269 6275 7465 205c 0a20 2020  _attribute \.   
+0000c970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c990: 2020 203d 4e6f 6e65 2e22 290a 0a20 2020     =None.")..   
+0000c9a0: 2064 6566 206e 7369 5f6c 6170 6c61 6369   def nsi_laplaci
+0000c9b0: 616e 2873 656c 6629 3a0a 2020 2020 2020  an(self):.      
+0000c9c0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+0000c9d0: 7475 726e 2074 6865 206e 2e73 2e69 2e20  turn the n.s.i. 
+0000c9e0: 4c61 706c 6163 6961 6e20 6d61 7472 6978  Laplacian matrix
+0000c9f0: 2028 756e 6469 7265 6374 6564 206e 6574   (undirected net
+0000ca00: 776f 726b 7320 6f6e 6c79 2129 2e0a 0a20  works only!)... 
+0000ca10: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
+0000ca20: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+0000ca30: 204e 6574 776f 726b 2e53 6d61 6c6c 5465   Network.SmallTe
+0000ca40: 7374 4e65 7477 6f72 6b28 292e 6e73 695f  stNetwork().nsi_
+0000ca50: 6c61 706c 6163 6961 6e28 290a 2020 2020  laplacian().    
+0000ca60: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+0000ca70: 6e2e 732e 692e 2064 6567 7265 652e 2e2e  n.s.i. degree...
+0000ca80: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+0000ca90: 5b20 362e 392c 2020 302e 202c 2020 302e  [ 6.9,  0. ,  0.
+0000caa0: 202c 202d 322e 312c 202d 322e 332c 202d   , -2.1, -2.3, -
+0000cab0: 322e 355d 2c0a 2020 2020 2020 2020 2020  2.5],.          
+0000cac0: 2020 2020 205b 2030 2e20 2c20 2036 2e33       [ 0. ,  6.3
+0000cad0: 2c20 2d31 2e39 2c20 2d32 2e31 2c20 2d32  , -1.9, -2.1, -2
+0000cae0: 2e33 2c20 2030 2e20 5d2c 0a20 2020 2020  .3,  0. ],.     
+0000caf0: 2020 2020 2020 2020 2020 5b20 302e 202c            [ 0. ,
+0000cb00: 202d 312e 372c 2020 342e 202c 2020 302e   -1.7,  4. ,  0.
+0000cb10: 202c 202d 322e 332c 2020 302e 205d 2c0a   , -2.3,  0. ],.
+0000cb20: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+0000cb30: 2d31 2e35 2c20 2d31 2e37 2c20 2030 2e20  -1.5, -1.7,  0. 
+0000cb40: 2c20 2033 2e32 2c20 2030 2e20 2c20 2030  ,  3.2,  0. ,  0
+0000cb50: 2e20 5d2c 0a20 2020 2020 2020 2020 2020  . ],.           
+0000cb60: 2020 2020 5b2d 312e 352c 202d 312e 372c      [-1.5, -1.7,
+0000cb70: 202d 312e 392c 2020 302e 202c 2020 352e   -1.9,  0. ,  5.
+0000cb80: 312c 2020 302e 205d 2c0a 2020 2020 2020  1,  0. ],.      
+0000cb90: 2020 2020 2020 2020 205b 2d31 2e35 2c20           [-1.5, 
+0000cba0: 2030 2e20 2c20 2030 2e20 2c20 2030 2e20   0. ,  0. ,  0. 
+0000cbb0: 2c20 2030 2e20 2c20 2031 2e35 5d5d 290a  ,  0. ,  1.5]]).
+0000cbc0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+0000cbd0: 2073 7175 6172 6520 6172 7261 7928 5b5b   square array([[
+0000cbe0: 666c 6f61 745d 5d29 0a20 2020 2020 2020  float]]).       
+0000cbf0: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+0000cc00: 7365 6c66 2e64 6972 6563 7465 643a 0a20  self.directed:. 
+0000cc10: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+0000cc20: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
+0000cc30: 7272 6f72 2822 4e6f 7420 696d 706c 656d  rror("Not implem
+0000cc40: 656e 7465 6420 666f 7220 6469 7265 6374  ented for direct
+0000cc50: 6564 206e 6574 776f 726b 732e 2229 0a20  ed networks."). 
+0000cc60: 2020 2020 2020 2072 6574 7572 6e20 2873         return (s
+0000cc70: 656c 662e 7370 5f6e 7369 5f64 6961 675f  elf.sp_nsi_diag_
+0000cc80: 6b28 2920 2d20 7365 6c66 2e73 705f 4170  k() - self.sp_Ap
+0000cc90: 6c75 7328 2920 2a20 7365 6c66 2e73 705f  lus() * self.sp_
+0000cca0: 6469 6167 5f77 2829 292e 410a 0a20 2020  diag_w()).A..   
+0000ccb0: 2023 0a20 2020 2023 2020 4361 6c63 756c   #.    #  Calcul
+0000ccc0: 6174 6520 6672 6571 7565 6e63 7920 616e  ate frequency an
+0000ccd0: 6420 6375 6d75 6c61 7469 7665 2064 6973  d cumulative dis
+0000cce0: 7472 6962 7574 696f 6e73 0a20 2020 2023  tributions.    #
+0000ccf0: 0a0a 2020 2020 2320 544f 444f 3a20 6164  ..    # TODO: ad
+0000cd00: 6420 7365 6e73 6962 6c65 2064 6566 6175  d sensible defau
+0000cd10: 6c74 2066 6f72 206e 5f62 696e 7320 6465  lt for n_bins de
+0000cd20: 7065 6e64 696e 6720 6f6e 206c 656e 2876  pending on len(v
+0000cd30: 616c 7565 7329 0a20 2020 2040 7374 6174  alues).    @stat
+0000cd40: 6963 6d65 7468 6f64 0a20 2020 2064 6566  icmethod.    def
+0000cd50: 205f 6869 7374 6f67 7261 6d28 7661 6c75   _histogram(valu
+0000cd60: 6573 2c20 6e5f 6269 6e73 2c20 696e 7465  es, n_bins, inte
+0000cd70: 7276 616c 3d4e 6f6e 6529 3a0a 2020 2020  rval=None):.    
+0000cd80: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000cd90: 5265 7475 726e 2061 206e 6f72 6d61 6c69  Return a normali
+0000cda0: 7a65 6420 6869 7374 6f67 7261 6d20 6f66  zed histogram of
+0000cdb0: 2061 206c 6973 7420 6f66 2076 616c 7565   a list of value
+0000cdc0: 732c 0a20 2020 2020 2020 2069 7473 2073  s,.        its s
+0000cdd0: 7461 7469 7374 6963 616c 2065 7272 6f72  tatistical error
+0000cde0: 2c20 616e 6420 7468 6520 6c6f 7765 7220  , and the lower 
+0000cdf0: 6269 6e20 626f 756e 6461 7269 6573 2e0a  bin boundaries..
+0000ce00: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
+0000ce10: 6c65 3a2a 2a20 4765 7420 7468 6520 7265  le:** Get the re
+0000ce20: 6c61 7469 7665 2066 7265 7175 656e 6369  lative frequenci
+0000ce30: 6573 206f 6e6c 793a 0a0a 2020 2020 2020  es only:..      
+0000ce40: 2020 3e3e 3e20 7228 4e65 7477 6f72 6b2e    >>> r(Network.
+0000ce50: 5f68 6973 746f 6772 616d 280a 2020 2020  _histogram(.    
+0000ce60: 2020 2020 2e2e 2e20 2020 2020 7661 6c75      ...     valu
+0000ce70: 6573 3d5b 312c 322c 3133 5d2c 206e 5f62  es=[1,2,13], n_b
+0000ce80: 696e 733d 332c 2069 6e74 6572 7661 6c3d  ins=3, interval=
+0000ce90: 2830 2c33 3029 295b 305d 290a 2020 2020  (0,30))[0]).    
+0000cea0: 2020 2020 6172 7261 7928 5b20 302e 3636      array([ 0.66
+0000ceb0: 3637 2c20 2030 2e33 3333 332c 2020 302e  67,  0.3333,  0.
+0000cec0: 205d 290a 0a20 2020 2020 2020 203a 7479   ])..        :ty
+0000ced0: 7065 2076 616c 7565 733a 2031 6420 6172  pe values: 1d ar
+0000cee0: 7261 7920 6f72 206c 6973 7420 6f66 2066  ray or list of f
+0000cef0: 6c6f 6174 730a 2020 2020 2020 2020 3a61  loats.        :a
+0000cf00: 7267 2020 7661 6c75 6573 3a20 5468 6520  rg  values: The 
+0000cf10: 7661 6c75 6573 2077 686f 7365 2064 6973  values whose dis
+0000cf20: 7472 6962 7574 696f 6e20 6973 2077 616e  tribution is wan
+0000cf30: 7465 642e 0a0a 2020 2020 2020 2020 3a74  ted...        :t
+0000cf40: 7970 6520 6e5f 6269 6e73 3a20 696e 7420  ype n_bins: int 
+0000cf50: 3e20 300a 2020 2020 2020 2020 3a61 7267  > 0.        :arg
+0000cf60: 2020 6e5f 6269 6e73 3a20 4e75 6d62 6572    n_bins: Number
+0000cf70: 206f 6620 6269 6e73 2074 6f20 6265 2075   of bins to be u
+0000cf80: 7365 6420 666f 7220 7468 6520 6869 7374  sed for the hist
+0000cf90: 6f67 7261 6d2e 0a0a 2020 2020 2020 2020  ogram...        
+0000cfa0: 3a74 7970 6520 696e 7465 7276 616c 3a20  :type interval: 
+0000cfb0: 7475 706c 6520 2866 6c6f 6174 2c66 6c6f  tuple (float,flo
+0000cfc0: 6174 292c 206f 7220 4e6f 6e65 0a20 2020  at), or None.   
+0000cfd0: 2020 2020 203a 6172 6720 2069 6e74 6572       :arg  inter
+0000cfe0: 7661 6c3a 204f 7074 696f 6e61 6c20 696e  val: Optional in
+0000cff0: 7465 7276 616c 2074 6f20 7573 652e 2049  terval to use. I
+0000d000: 6620 4e6f 6e65 2c20 7468 6520 6d69 6e69  f None, the mini
+0000d010: 6d75 6d20 616e 640a 2020 2020 2020 2020  mum and.        
+0000d020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d030: 6d61 7869 6d75 6d20 7661 6c75 6573 2061  maximum values a
+0000d040: 7265 2075 7365 642e 2028 4465 6661 756c  re used. (Defaul
+0000d050: 743a 204e 6f6e 6529 0a0a 2020 2020 2020  t: None)..      
+0000d060: 2020 3a72 7479 7065 3a20 2074 7570 6c65    :rtype:  tuple
+0000d070: 2028 6c69 7374 2c6c 6973 742c 6c69 7374   (list,list,list
+0000d080: 290a 2020 2020 2020 2020 3a72 6574 7572  ).        :retur
+0000d090: 6e3a 2041 206c 6973 7420 6f66 2072 656c  n: A list of rel
+0000d0a0: 6174 6976 6520 6269 6e20 6672 6571 7565  ative bin freque
+0000d0b0: 6e63 6965 732c 2061 206c 6973 7420 6f66  ncies, a list of
+0000d0c0: 2065 7374 696d 6174 6564 0a20 2020 2020   estimated.     
+0000d0d0: 2020 2020 2020 2020 2020 2020 7374 6174              stat
+0000d0e0: 6973 7469 6361 6c20 6572 726f 7273 2c20  istical errors, 
+0000d0f0: 616e 6420 6120 6c69 7374 206f 6620 6c6f  and a list of lo
+0000d100: 7765 7220 6269 6e20 626f 756e 6461 7269  wer bin boundari
+0000d110: 6573 2e0a 2020 2020 2020 2020 2222 220a  es..        """.
+0000d120: 2020 2020 2020 2020 6869 7374 203d 206e          hist = n
+0000d130: 702e 6869 7374 6f67 7261 6d28 7661 6c75  p.histogram(valu
+0000d140: 6573 2c20 6269 6e73 3d6e 5f62 696e 732c  es, bins=n_bins,
+0000d150: 2072 616e 6765 3d69 6e74 6572 7661 6c2c   range=interval,
+0000d160: 2064 656e 7369 7479 3d46 616c 7365 290a   density=False).
+0000d170: 2020 2020 2020 2020 6672 6571 7565 6e63          frequenc
+0000d180: 6965 7320 3d20 6869 7374 5b30 5d2e 6173  ies = hist[0].as
+0000d190: 7479 7065 2827 666c 6f61 7436 3427 290a  type('float64').
+0000d1a0: 2020 2020 2020 2020 6269 6e5f 7374 6172          bin_star
+0000d1b0: 7473 203d 2068 6973 745b 315d 5b3a 2d31  ts = hist[1][:-1
+0000d1c0: 5d0a 0a20 2020 2020 2020 2023 2043 616c  ]..        # Cal
+0000d1d0: 6375 6c61 7465 2073 7461 7469 7374 6963  culate statistic
+0000d1e0: 616c 2065 7272 6f72 2067 6976 656e 2062  al error given b
+0000d1f0: 7920 312f 6e5f 6920 7065 7220 6269 6e20  y 1/n_i per bin 
+0000d200: 692c 0a20 2020 2020 2020 2023 2077 6865  i,.        # whe
+0000d210: 7265 206e 5f69 2069 7320 7468 6520 6e75  re n_i is the nu
+0000d220: 6d62 6572 206f 6620 7361 6d70 6c65 7320  mber of samples 
+0000d230: 7065 7220 6269 6e0a 2020 2020 2020 2020  per bin.        
+0000d240: 6572 726f 7220 3d20 6e70 2e7a 6572 6f73  error = np.zeros
+0000d250: 286e 5f62 696e 7329 0a20 2020 2020 2020  (n_bins).       
+0000d260: 2065 7272 6f72 5b66 7265 7175 656e 6369   error[frequenci
+0000d270: 6573 2021 3d20 305d 203d 2031 202f 206e  es != 0] = 1 / n
+0000d280: 702e 7371 7274 2866 7265 7175 656e 6369  p.sqrt(frequenci
+0000d290: 6573 5b66 7265 7175 656e 6369 6573 2021  es[frequencies !
+0000d2a0: 3d20 305d 290a 2020 2020 2020 2020 2320  = 0]).        # 
+0000d2b0: 4649 584d 453a 2074 6869 7320 7365 656d  FIXME: this seem
+0000d2c0: 7320 6e6f 7420 636f 7272 6563 742e 2049  s not correct. I
+0000d2d0: 6620 7468 6520 7472 7565 2070 726f 6261  f the true proba
+0000d2e0: 6269 6c69 7479 2066 6f72 2074 6865 2062  bility for the b
+0000d2f0: 696e 0a20 2020 2020 2020 2023 2069 7320  in.        # is 
+0000d300: 705f 692c 2074 6865 2076 6172 6961 6e63  p_i, the varianc
+0000d310: 6520 6f66 2020 6e5f 6920 2f20 4e20 2069  e of  n_i / N  i
+0000d320: 7320 2070 5f69 202a 2028 3120 2d20 705f  s  p_i * (1 - p_
+0000d330: 6929 202f 204e 0a20 2020 2020 2020 2023  i) / N.        #
+0000d340: 2077 6869 6368 2063 616e 2062 6520 6573   which can be es
+0000d350: 7469 6d61 7465 6420 6672 6f6d 206e 5f69  timated from n_i
+0000d360: 2062 7920 206e 5f69 202a 2028 4e20 2d20   by  n_i * (N - 
+0000d370: 6e5f 6929 202f 204e 2a2a 330a 0a20 2020  n_i) / N**3..   
+0000d380: 2020 2020 2023 2020 4e6f 726d 616c 697a       #  Normaliz
+0000d390: 6520 6672 6571 7565 6e63 6965 7320 616e  e frequencies an
+0000d3a0: 6420 6572 726f 720a 2020 2020 2020 2020  d error.        
+0000d3b0: 7265 6c5f 6672 6571 7320 3d20 6672 6571  rel_freqs = freq
+0000d3c0: 7565 6e63 6965 7320 2f20 6672 6571 7565  uencies / freque
+0000d3d0: 6e63 6965 732e 7375 6d28 290a 2020 2020  ncies.sum().    
+0000d3e0: 2020 2020 6572 726f 7220 2f3d 2066 7265      error /= fre
+0000d3f0: 7175 656e 6369 6573 2e73 756d 2829 0a0a  quencies.sum()..
+0000d400: 2020 2020 2020 2020 7265 7475 726e 2028          return (
+0000d410: 7265 6c5f 6672 6571 732c 2065 7272 6f72  rel_freqs, error
+0000d420: 2c20 6269 6e5f 7374 6172 7473 290a 0a20  , bin_starts).. 
+0000d430: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
+0000d440: 0a20 2020 2064 6566 205f 6375 6d5f 6869  .    def _cum_hi
+0000d450: 7374 6f67 7261 6d28 7661 6c75 6573 2c20  stogram(values, 
+0000d460: 6e5f 6269 6e73 2c20 696e 7465 7276 616c  n_bins, interval
+0000d470: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
+0000d480: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
+0000d490: 726e 2061 206e 6f72 6d61 6c69 7a65 6420  rn a normalized 
+0000d4a0: 6375 6d75 6c61 7469 7665 2068 6973 746f  cumulative histo
+0000d4b0: 6772 616d 206f 6620 6120 6c69 7374 206f  gram of a list o
+0000d4c0: 6620 7661 6c75 6573 2c0a 2020 2020 2020  f values,.      
+0000d4d0: 2020 616e 6420 7468 6520 6c6f 7765 7220    and the lower 
+0000d4e0: 6269 6e20 626f 756e 6461 7269 6573 2e0a  bin boundaries..
+0000d4f0: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
+0000d500: 6c65 3a2a 2a20 4765 7420 7468 6520 7265  le:** Get the re
+0000d510: 6c61 7469 7665 2066 7265 7175 656e 6369  lative frequenci
+0000d520: 6573 206f 6e6c 793a 0a0a 2020 2020 2020  es only:..      
+0000d530: 2020 3e3e 3e20 7228 4e65 7477 6f72 6b2e    >>> r(Network.
+0000d540: 5f63 756d 5f68 6973 746f 6772 616d 280a  _cum_histogram(.
+0000d550: 2020 2020 2020 2020 2e2e 2e20 2020 2020          ...     
+0000d560: 7661 6c75 6573 3d5b 312c 322c 3133 5d2c  values=[1,2,13],
+0000d570: 206e 5f62 696e 733d 332c 2069 6e74 6572   n_bins=3, inter
+0000d580: 7661 6c3d 2830 2c33 3029 295b 305d 290a  val=(0,30))[0]).
+0000d590: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+0000d5a0: 312e 202c 2020 302e 3333 3333 2c20 2030  1. ,  0.3333,  0
+0000d5b0: 2e20 5d29 0a0a 2020 2020 2020 2020 3a74  . ])..        :t
+0000d5c0: 7970 6520 7661 6c75 6573 3a20 3164 2061  ype values: 1d a
+0000d5d0: 7272 6179 206f 7220 6c69 7374 206f 6620  rray or list of 
+0000d5e0: 666c 6f61 7473 0a20 2020 2020 2020 203a  floats.        :
+0000d5f0: 6172 6720 2076 616c 7565 733a 2054 6865  arg  values: The
+0000d600: 2076 616c 7565 7320 7768 6f73 6520 6469   values whose di
+0000d610: 7374 7269 6275 7469 6f6e 2069 7320 7761  stribution is wa
+0000d620: 6e74 6564 2e0a 0a20 2020 2020 2020 203a  nted...        :
+0000d630: 7479 7065 206e 5f62 696e 733a 2069 6e74  type n_bins: int
+0000d640: 203e 2030 0a20 2020 2020 2020 203a 6172   > 0.        :ar
+0000d650: 6720 206e 5f62 696e 733a 204e 756d 6265  g  n_bins: Numbe
+0000d660: 7220 6f66 2062 696e 7320 746f 2062 6520  r of bins to be 
+0000d670: 7573 6564 2066 6f72 2074 6865 2068 6973  used for the his
+0000d680: 746f 6772 616d 2e0a 0a20 2020 2020 2020  togram...       
+0000d690: 203a 7479 7065 2069 6e74 6572 7661 6c3a   :type interval:
+0000d6a0: 2074 7570 6c65 2028 666c 6f61 742c 666c   tuple (float,fl
+0000d6b0: 6f61 7429 2c20 6f72 204e 6f6e 650a 2020  oat), or None.  
+0000d6c0: 2020 2020 2020 3a61 7267 2020 696e 7465        :arg  inte
+0000d6d0: 7276 616c 3a20 4f70 7469 6f6e 616c 2072  rval: Optional r
+0000d6e0: 616e 6765 2074 6f20 7573 652e 2049 6620  ange to use. If 
+0000d6f0: 4e6f 6e65 2c20 7468 6520 6d69 6e69 6d75  None, the minimu
+0000d700: 6d20 616e 6420 6d61 7869 6d75 6d0a 2020  m and maximum.  
+0000d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d720: 2020 2020 2020 7661 6c75 6573 2061 7265        values are
+0000d730: 2075 7365 642e 2028 4465 6661 756c 743a   used. (Default:
+0000d740: 204e 6f6e 6529 0a0a 2020 2020 2020 2020   None)..        
+0000d750: 3a72 7479 7065 3a20 2074 7570 6c65 2028  :rtype:  tuple (
+0000d760: 6c69 7374 2c6c 6973 7429 0a20 2020 2020  list,list).     
+0000d770: 2020 203a 7265 7475 726e 3a20 4120 6c69     :return: A li
+0000d780: 7374 206f 6620 6375 6d75 6c61 7469 7665  st of cumulative
+0000d790: 2072 656c 6174 6976 6520 6269 6e20 6672   relative bin fr
+0000d7a0: 6571 7565 6e63 6965 730a 2020 2020 2020  equencies.      
+0000d7b0: 2020 2020 2020 2020 2020 2028 656e 7472             (entr
+0000d7c0: 7920 5b69 5d20 6973 2074 6865 2073 756d  y [i] is the sum
+0000d7d0: 206f 6620 7468 6520 6672 6571 7565 6e63   of the frequenc
+0000d7e0: 6965 7320 6f66 2061 6c6c 2062 696e 7320  ies of all bins 
+0000d7f0: 6a20 3e3d 2069 292c 0a20 2020 2020 2020  j >= i),.       
+0000d800: 2020 2020 2020 2020 2020 616e 6420 6120            and a 
+0000d810: 6c69 7374 206f 6620 6c6f 7765 7220 6269  list of lower bi
+0000d820: 6e20 626f 756e 6461 7269 6573 2e0a 2020  n boundaries..  
+0000d830: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000d840: 2020 2872 656c 5f66 7265 7173 2c20 5f2c    (rel_freqs, _,
+0000d850: 2062 696e 5f73 7461 7274 7329 203d 205c   bin_starts) = \
+0000d860: 0a20 2020 2020 2020 2020 2020 204e 6574  .            Net
+0000d870: 776f 726b 2e5f 6869 7374 6f67 7261 6d28  work._histogram(
+0000d880: 7661 6c75 6573 3d76 616c 7565 732c 206e  values=values, n
+0000d890: 5f62 696e 733d 6e5f 6269 6e73 2c20 696e  _bins=n_bins, in
+0000d8a0: 7465 7276 616c 3d69 6e74 6572 7661 6c29  terval=interval)
+0000d8b0: 0a20 2020 2020 2020 2063 756d 5f72 656c  .        cum_rel
+0000d8c0: 5f66 7265 7173 203d 2072 656c 5f66 7265  _freqs = rel_fre
+0000d8d0: 7173 5b3a 3a2d 315d 2e63 756d 7375 6d28  qs[::-1].cumsum(
+0000d8e0: 295b 3a3a 2d31 5d0a 2020 2020 2020 2020  )[::-1].        
+0000d8f0: 7265 7475 726e 2028 6375 6d5f 7265 6c5f  return (cum_rel_
+0000d900: 6672 6571 732c 2062 696e 5f73 7461 7274  freqs, bin_start
+0000d910: 7329 0a0a 2020 2020 230a 2020 2020 2320  s)..    #.    # 
+0000d920: 204d 6574 686f 6473 2077 6f72 6b69 6e67   Methods working
+0000d930: 2077 6974 6820 6e6f 6465 2061 7474 7269   with node attri
+0000d940: 6275 7465 730a 2020 2020 230a 0a20 2020  butes.    #..   
+0000d950: 2064 6566 2073 6574 5f6e 6f64 655f 6174   def set_node_at
+0000d960: 7472 6962 7574 6528 7365 6c66 2c20 6174  tribute(self, at
+0000d970: 7472 6962 7574 655f 6e61 6d65 3a20 7374  tribute_name: st
+0000d980: 722c 2076 616c 7565 7329 3a0a 2020 2020  r, values):.    
+0000d990: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000d9a0: 4164 6420 6120 6e6f 6465 2061 7474 7269  Add a node attri
+0000d9b0: 6275 7465 2e0a 0a20 2020 2020 2020 2045  bute...        E
+0000d9c0: 7861 6d70 6c65 7320 666f 7220 6e6f 6465  xamples for node
+0000d9d0: 2061 7474 7269 6275 7465 732f 7765 6967   attributes/weig
+0000d9e0: 6874 7320 6172 6520 6465 6772 6565 206f  hts are degree o
+0000d9f0: 7220 6265 7477 6565 6e6e 6573 732e 0a0a  r betweenness...
+0000da00: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
+0000da10: 2061 7474 7269 6275 7465 5f6e 616d 653a   attribute_name:
+0000da20: 2054 6865 206e 616d 6520 6f66 2074 6865   The name of the
+0000da30: 206e 6f64 6520 6174 7472 6962 7574 652e   node attribute.
+0000da40: 0a0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
+0000da50: 7661 6c75 6573 3a20 3144 204e 756d 7079  values: 1D Numpy
+0000da60: 2061 7272 6179 205b 6e6f 6465 5d0a 2020   array [node].  
+0000da70: 2020 2020 2020 3a61 7267 2076 616c 7565        :arg value
+0000da80: 733a 2054 6865 206e 6f64 6520 6174 7472  s: The node attr
+0000da90: 6962 7574 6520 7365 7175 656e 6365 2e0a  ibute sequence..
+0000daa0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000dab0: 2020 2020 6966 206c 656e 2876 616c 7565      if len(value
+0000dac0: 7329 203d 3d20 7365 6c66 2e4e 3a0a 2020  s) == self.N:.  
+0000dad0: 2020 2020 2020 2020 2020 7365 6c66 2e67            self.g
+0000dae0: 7261 7068 2e76 732e 7365 745f 6174 7472  raph.vs.set_attr
+0000daf0: 6962 7574 655f 7661 6c75 6573 2861 7474  ibute_values(att
+0000db00: 726e 616d 653d 6174 7472 6962 7574 655f  rname=attribute_
+0000db10: 6e61 6d65 2c0a 2020 2020 2020 2020 2020  name,.          
 0000db20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000db30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000db40: 2020 2020 7661 6c75 6573 3d76 616c 7565      values=value
-0000db50: 7329 0a20 2020 2020 2020 2065 6c73 653a  s).        else:
-0000db60: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-0000db70: 6e74 2822 4572 726f 7221 2056 6572 7465  nt("Error! Verte
-0000db80: 7820 6174 7472 6962 7574 6520 6461 7461  x attribute data
-0000db90: 2061 7272 6179 222c 2061 7474 7269 6275   array", attribu
-0000dba0: 7465 5f6e 616d 652c 0a20 2020 2020 2020  te_name,.       
-0000dbb0: 2020 2020 2020 2020 2020 2022 6861 7320             "has 
-0000dbc0: 746f 2068 6176 6520 7468 6520 7361 6d65  to have the same
-0000dbd0: 206c 656e 6774 6820 6173 2074 6865 206e   length as the n
-0000dbe0: 756d 6265 7220 6f66 206e 6f64 6573 2022  umber of nodes "
-0000dbf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dc00: 2020 2022 696e 2074 6865 2067 7261 7068     "in the graph
-0000dc10: 2e22 290a 0a20 2020 2064 6566 206e 6f64  .")..    def nod
-0000dc20: 655f 6174 7472 6962 7574 6528 7365 6c66  e_attribute(self
-0000dc30: 2c20 6174 7472 6962 7574 655f 6e61 6d65  , attribute_name
-0000dc40: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0000dc50: 2020 2020 2020 2052 6574 7572 6e20 6120         Return a 
-0000dc60: 6e6f 6465 2061 7474 7269 6275 7465 2e0a  node attribute..
-0000dc70: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
-0000dc80: 7320 666f 7220 6e6f 6465 2061 7474 7269  s for node attri
-0000dc90: 6275 7465 732f 7765 6967 6874 7320 6172  butes/weights ar
-0000dca0: 6520 6465 6772 6565 206f 7220 6265 7477  e degree or betw
-0000dcb0: 6565 6e6e 6573 732e 0a0a 2020 2020 2020  eenness...      
-0000dcc0: 2020 3a61 7267 2073 7472 2061 7474 7269    :arg str attri
-0000dcd0: 6275 7465 5f6e 616d 653a 2054 6865 206e  bute_name: The n
-0000dce0: 616d 6520 6f66 2074 6865 206e 6f64 6520  ame of the node 
-0000dcf0: 6174 7472 6962 7574 652e 0a0a 2020 2020  attribute...    
-0000dd00: 2020 2020 3a72 7479 7065 3a20 3144 204e      :rtype: 1D N
-0000dd10: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
-0000dd20: 5d0a 2020 2020 2020 2020 3a72 6574 7572  ].        :retur
-0000dd30: 6e3a 2054 6865 206e 6f64 6520 6174 7472  n: The node attr
-0000dd40: 6962 7574 6520 7365 7175 656e 6365 2e0a  ibute sequence..
-0000dd50: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0000dd60: 2020 2020 2320 544f 444f 3a20 6164 6420      # TODO: add 
-0000dd70: 6578 616d 706c 650a 2020 2020 2020 2020  example.        
-0000dd80: 7265 7475 726e 206e 702e 6172 7261 7928  return np.array(
-0000dd90: 7365 6c66 2e67 7261 7068 2e76 732e 6765  self.graph.vs.ge
-0000dda0: 745f 6174 7472 6962 7574 655f 7661 6c75  t_attribute_valu
-0000ddb0: 6573 2861 7474 7269 6275 7465 5f6e 616d  es(attribute_nam
-0000ddc0: 6529 290a 0a20 2020 2064 6566 2064 656c  e))..    def del
-0000ddd0: 5f6e 6f64 655f 6174 7472 6962 7574 6528  _node_attribute(
-0000dde0: 7365 6c66 2c20 6174 7472 6962 7574 655f  self, attribute_
-0000ddf0: 6e61 6d65 293a 0a20 2020 2020 2020 2022  name):.        "
-0000de00: 2222 0a20 2020 2020 2020 2044 656c 6574  "".        Delet
-0000de10: 6520 6120 6e6f 6465 2061 7474 7269 6275  e a node attribu
-0000de20: 7465 2e0a 0a20 2020 2020 2020 203a 6172  te...        :ar
-0000de30: 6720 7374 7220 6174 7472 6962 7574 655f  g str attribute_
-0000de40: 6e61 6d65 3a20 4e61 6d65 206f 6620 6e6f  name: Name of no
-0000de50: 6465 2061 7474 7269 6275 7465 2074 6f20  de attribute to 
-0000de60: 6265 2064 656c 6574 6564 2e0a 2020 2020  be deleted..    
-0000de70: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000de80: 2320 544f 444f 3a20 6164 6420 6578 616d  # TODO: add exam
-0000de90: 706c 650a 2020 2020 2020 2020 7365 6c66  ple.        self
-0000dea0: 2e67 7261 7068 2e65 732e 5f5f 6465 6c61  .graph.es.__dela
-0000deb0: 7474 725f 5f28 6174 7472 6962 7574 655f  ttr__(attribute_
-0000dec0: 6e61 6d65 290a 0a20 2020 2023 0a20 2020  name)..    #.   
-0000ded0: 2023 2020 4d65 7468 6f64 7320 776f 726b   #  Methods work
-0000dee0: 696e 6720 7769 7468 206c 696e 6b20 6174  ing with link at
-0000def0: 7472 6962 7574 6573 0a20 2020 2023 0a0a  tributes.    #..
-0000df00: 2020 2020 2320 544f 444f 3a20 7665 7269      # TODO: veri
-0000df10: 6679 2077 6865 7468 6572 2072 6574 7572  fy whether retur
-0000df20: 6e20 7479 7065 7320 6172 6520 6c69 7374  n types are list
-0000df30: 206f 7220 6e75 6d70 7920 6172 7261 790a   or numpy array.
-0000df40: 0a20 2020 2064 6566 2061 7665 7261 6765  .    def average
-0000df50: 5f6c 696e 6b5f 6174 7472 6962 7574 6528  _link_attribute(
-0000df60: 7365 6c66 2c20 6174 7472 6962 7574 655f  self, attribute_
-0000df70: 6e61 6d65 293a 0a20 2020 2020 2020 2022  name):.        "
-0000df80: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
-0000df90: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
-0000dfa0: 2074 6865 2061 7665 7261 6765 206f 6620   the average of 
-0000dfb0: 6120 6c69 6e6b 2061 7474 7269 6275 7465  a link attribute
-0000dfc0: 0a20 2020 2020 2020 206f 7665 7220 616c  .        over al
-0000dfd0: 6c20 6c69 6e6b 7320 6f66 2074 6861 7420  l links of that 
-0000dfe0: 6e6f 6465 2e0a 0a20 2020 2020 2020 203a  node...        :
-0000dff0: 6172 6720 7374 7220 6174 7472 6962 7574  arg str attribut
-0000e000: 655f 6e61 6d65 3a20 4e61 6d65 206f 6620  e_name: Name of 
-0000e010: 6c69 6e6b 2061 7474 7269 6275 7465 2074  link attribute t
-0000e020: 6f20 6265 2075 7365 642e 0a0a 2020 2020  o be used...    
-0000e030: 2020 2020 3a72 7479 7065 3a20 3164 206e      :rtype: 1d n
-0000e040: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
-0000e050: 5d20 6f66 2066 6c6f 6174 730a 2020 2020  ] of floats.    
-0000e060: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000e070: 2320 544f 444f 3a20 6164 6420 6578 616d  # TODO: add exam
-0000e080: 706c 650a 2020 2020 2020 2020 7265 7475  ple.        retu
-0000e090: 726e 2073 656c 662e 6c69 6e6b 5f61 7474  rn self.link_att
-0000e0a0: 7269 6275 7465 2861 7474 7269 6275 7465  ribute(attribute
-0000e0b0: 5f6e 616d 6529 2e6d 6561 6e28 6178 6973  _name).mean(axis
-0000e0c0: 3d31 290a 0a20 2020 2064 6566 206c 696e  =1)..    def lin
-0000e0d0: 6b5f 6174 7472 6962 7574 6528 7365 6c66  k_attribute(self
-0000e0e0: 2c20 6174 7472 6962 7574 655f 6e61 6d65  , attribute_name
-0000e0f0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0000e100: 2020 2020 2020 2052 6574 7572 6e20 7468         Return th
-0000e110: 6520 7661 6c75 6573 206f 6620 6120 6c69  e values of a li
-0000e120: 6e6b 2061 7474 7269 6275 7465 2e0a 0a20  nk attribute... 
-0000e130: 2020 2020 2020 203a 6172 6720 7374 7220         :arg str 
-0000e140: 6174 7472 6962 7574 655f 6e61 6d65 3a20  attribute_name: 
-0000e150: 4e61 6d65 206f 6620 6c69 6e6b 2061 7474  Name of link att
-0000e160: 7269 6275 7465 2074 6f20 6265 2075 7365  ribute to be use
-0000e170: 642e 0a0a 2020 2020 2020 2020 3a72 7479  d...        :rty
-0000e180: 7065 3a20 2073 7175 6172 6520 6e75 6d70  pe:  square nump
-0000e190: 7920 6172 7261 7920 5b6e 6f64 652c 6e6f  y array [node,no
-0000e1a0: 6465 5d0a 2020 2020 2020 2020 3a72 6574  de].        :ret
-0000e1b0: 7572 6e3a 2045 6e74 7279 205b 692c 6a5d  urn: Entry [i,j]
-0000e1c0: 2069 7320 7468 6520 6174 7472 6962 7574   is the attribut
-0000e1d0: 6520 6f66 2074 6865 206c 696e 6b20 6672  e of the link fr
-0000e1e0: 6f6d 2069 2074 6f20 6a2e 0a20 2020 2020  om i to j..     
-0000e1f0: 2020 2022 2222 0a20 2020 2020 2020 2023     """.        #
-0000e200: 2054 4f44 4f3a 2061 6464 2065 7861 6d70   TODO: add examp
-0000e210: 6c65 0a20 2020 2020 2020 2023 2054 4f44  le.        # TOD
-0000e220: 4f3a 2074 6573 7420 7468 6973 2066 6f72  O: test this for
-0000e230: 2064 6972 6563 7465 6420 6772 6170 6873   directed graphs
-0000e240: 0a20 2020 2020 2020 2023 2020 496e 6974  .        #  Init
-0000e250: 6961 6c69 7a65 2077 6569 6768 7473 2061  ialize weights a
-0000e260: 7272 6179 0a20 2020 2020 2020 2077 6569  rray.        wei
-0000e270: 6768 7473 203d 206e 702e 7a65 726f 7328  ghts = np.zeros(
-0000e280: 2873 656c 662e 4e2c 2073 656c 662e 4e29  (self.N, self.N)
-0000e290: 290a 0a20 2020 2020 2020 2069 6620 7365  )..        if se
-0000e2a0: 6c66 2e64 6972 6563 7465 643a 0a20 2020  lf.directed:.   
-0000e2b0: 2020 2020 2020 2020 2066 6f72 2065 2069           for e i
-0000e2c0: 6e20 7365 6c66 2e67 7261 7068 2e65 733a  n self.graph.es:
-0000e2d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e2e0: 2077 6569 6768 7473 5b65 2e74 7570 6c65   weights[e.tuple
-0000e2f0: 5d20 3d20 655b 6174 7472 6962 7574 655f  ] = e[attribute_
-0000e300: 6e61 6d65 5d0a 2020 2020 2020 2020 2320  name].        # 
-0000e310: 2053 796d 6d65 7472 697a 6520 6966 2067   Symmetrize if g
-0000e320: 7261 7068 2069 7320 756e 6469 7265 6374  raph is undirect
-0000e330: 6564 0a20 2020 2020 2020 2065 6c73 653a  ed.        else:
-0000e340: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000e350: 2065 2069 6e20 7365 6c66 2e67 7261 7068   e in self.graph
-0000e360: 2e65 733a 0a20 2020 2020 2020 2020 2020  .es:.           
-0000e370: 2020 2020 2077 6569 6768 7473 5b65 2e74       weights[e.t
-0000e380: 7570 6c65 5d20 3d20 655b 6174 7472 6962  uple] = e[attrib
-0000e390: 7574 655f 6e61 6d65 5d0a 2020 2020 2020  ute_name].      
-0000e3a0: 2020 2020 2020 2020 2020 7765 6967 6874            weight
-0000e3b0: 735b 652e 7475 706c 655b 315d 2c20 652e  s[e.tuple[1], e.
-0000e3c0: 7475 706c 655b 305d 5d20 3d20 655b 6174  tuple[0]] = e[at
-0000e3d0: 7472 6962 7574 655f 6e61 6d65 5d0a 0a20  tribute_name].. 
-0000e3e0: 2020 2020 2020 2072 6574 7572 6e20 7765         return we
-0000e3f0: 6967 6874 730a 0a20 2020 2064 6566 2063  ights..    def c
-0000e400: 6c65 6172 5f6c 696e 6b5f 6174 7472 6962  lear_link_attrib
-0000e410: 7574 6528 7365 6c66 2c20 6174 7472 6962  ute(self, attrib
-0000e420: 7574 655f 6e61 6d65 293a 0a20 2020 2020  ute_name):.     
-0000e430: 2020 2022 2222 0a20 2020 2020 2020 2043     """.        C
-0000e440: 6c65 6172 2063 6163 6865 206f 6620 6120  lear cache of a 
-0000e450: 6c69 6e6b 2061 7474 7269 6275 7465 2e0a  link attribute..
-0000e460: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
-0000e470: 7220 6174 7472 6962 7574 655f 6e61 6d65  r attribute_name
-0000e480: 3a20 6e61 6d65 206f 6620 6c69 6e6b 2061  : name of link a
-0000e490: 7474 7269 6275 7465 0a20 2020 2020 2020  ttribute.       
-0000e4a0: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
-0000e4b0: 6174 7472 6962 7574 655f 6e61 6d65 2069  attribute_name i
-0000e4c0: 6e20 7365 6c66 2e63 6163 6865 5b27 7061  n self.cache['pa
-0000e4d0: 7468 7327 5d3a 0a20 2020 2020 2020 2020  ths']:.         
-0000e4e0: 2020 2064 656c 2073 656c 662e 6361 6368     del self.cach
-0000e4f0: 655b 2770 6174 6873 275d 5b61 7474 7269  e['paths'][attri
-0000e500: 6275 7465 5f6e 616d 655d 0a0a 2020 2020  bute_name]..    
-0000e510: 6465 6620 6465 6c5f 6c69 6e6b 5f61 7474  def del_link_att
-0000e520: 7269 6275 7465 2873 656c 662c 2061 7474  ribute(self, att
-0000e530: 7269 6275 7465 5f6e 616d 6529 3a0a 2020  ribute_name):.  
-0000e540: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000e550: 2020 4465 6c65 7465 2061 206c 696e 6b20    Delete a link 
-0000e560: 6174 7472 6962 7574 652e 0a0a 2020 2020  attribute...    
-0000e570: 2020 2020 3a61 7267 2073 7472 2061 7474      :arg str att
-0000e580: 7269 6275 7465 5f6e 616d 653a 206e 616d  ribute_name: nam
-0000e590: 6520 6f66 206c 696e 6b20 6174 7472 6962  e of link attrib
-0000e5a0: 7574 6520 746f 2062 6520 6465 6c65 7465  ute to be delete
-0000e5b0: 640a 2020 2020 2020 2020 2222 220a 2020  d.        """.  
-0000e5c0: 2020 2020 2020 2320 544f 444f 3a20 6164        # TODO: ad
-0000e5d0: 6420 6578 616d 706c 650a 2020 2020 2020  d example.      
-0000e5e0: 2020 6966 2061 7474 7269 6275 7465 5f6e    if attribute_n
-0000e5f0: 616d 6520 696e 2073 656c 662e 6361 6368  ame in self.cach
-0000e600: 655b 2770 6174 6873 275d 3a0a 2020 2020  e['paths']:.    
-0000e610: 2020 2020 2020 2020 7365 6c66 2e63 6c65          self.cle
-0000e620: 6172 5f6c 696e 6b5f 6174 7472 6962 7574  ar_link_attribut
-0000e630: 6528 6174 7472 6962 7574 655f 6e61 6d65  e(attribute_name
-0000e640: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-0000e650: 6c66 2e67 7261 7068 2e65 732e 5f5f 6465  lf.graph.es.__de
-0000e660: 6c61 7474 725f 5f28 6174 7472 6962 7574  lattr__(attribut
-0000e670: 655f 6e61 6d65 290a 2020 2020 2020 2020  e_name).        
-0000e680: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000e690: 2020 7072 696e 7428 2257 4152 4e49 4e47    print("WARNING
-0000e6a0: 3a20 4c69 6e6b 2061 7474 7269 6275 7465  : Link attribute
-0000e6b0: 222c 2061 7474 7269 6275 7465 5f6e 616d  ", attribute_nam
-0000e6c0: 652c 2022 6e6f 7420 666f 756e 6421 2229  e, "not found!")
-0000e6d0: 0a0a 2020 2020 6465 6620 7365 745f 6c69  ..    def set_li
-0000e6e0: 6e6b 5f61 7474 7269 6275 7465 2873 656c  nk_attribute(sel
-0000e6f0: 662c 2061 7474 7269 6275 7465 5f6e 616d  f, attribute_nam
-0000e700: 652c 2076 616c 7565 7329 3a0a 2020 2020  e, values):.    
-0000e710: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000e720: 5365 7420 7468 6520 7661 6c75 6573 206f  Set the values o
-0000e730: 6620 736f 6d65 206c 696e 6b20 6174 7472  f some link attr
-0000e740: 6962 7574 652e 0a0a 2020 2020 2020 2020  ibute...        
-0000e750: 5468 6573 6520 6361 6e20 6265 2075 7365  These can be use
-0000e760: 6420 6173 2077 6569 6768 7473 2069 6e20  d as weights in 
-0000e770: 6d65 6173 7572 6573 2072 6571 7569 7269  measures requiri
-0000e780: 6e67 206c 696e 6b20 7765 6967 6874 732e  ng link weights.
-0000e790: 0a0a 2020 2020 2020 2020 2e2e 206e 6f74  ..        .. not
-0000e7a0: 653a 3a0a 2020 2020 2020 2020 2020 2054  e::.           T
-0000e7b0: 6865 2061 7474 7269 6275 7465 2f77 6569  he attribute/wei
-0000e7c0: 6768 7420 6d61 7472 6978 2073 686f 756c  ght matrix shoul
-0000e7d0: 6420 6265 2073 796d 6d65 7472 6963 2066  d be symmetric f
-0000e7e0: 6f72 2075 6e64 6972 6563 7465 640a 2020  or undirected.  
-0000e7f0: 2020 2020 2020 2020 206e 6574 776f 726b           network
-0000e800: 732e 0a0a 2020 2020 2020 2020 3a61 7267  s...        :arg
-0000e810: 2073 7472 2061 7474 7269 6275 7465 5f6e   str attribute_n
-0000e820: 616d 653a 206e 616d 6520 6f66 206c 696e  ame: name of lin
-0000e830: 6b20 6174 7472 6962 7574 6520 746f 2062  k attribute to b
-0000e840: 6520 7365 740a 0a20 2020 2020 2020 203a  e set..        :
-0000e850: 7479 7065 2076 616c 7565 733a 2073 7175  type values: squ
-0000e860: 6172 6520 6e75 6d70 7920 6172 7261 7920  are numpy array 
-0000e870: 5b6e 6f64 652c 6e6f 6465 5d0a 2020 2020  [node,node].    
-0000e880: 2020 2020 3a61 7267 2020 7661 6c75 6573      :arg  values
-0000e890: 3a20 456e 7472 7920 5b69 2c6a 5d20 6973  : Entry [i,j] is
-0000e8a0: 2074 6865 2061 7474 7269 6275 7465 206f   the attribute o
-0000e8b0: 6620 7468 6520 6c69 6e6b 2066 726f 6d20  f the link from 
-0000e8c0: 6920 746f 206a 2e0a 2020 2020 2020 2020  i to j..        
-0000e8d0: 2222 220a 2020 2020 2020 2020 2320 544f  """.        # TO
-0000e8e0: 444f 3a20 6164 6420 6578 616d 706c 6520  DO: add example 
-0000e8f0: 616e 6420 7370 6172 7365 2076 6572 7369  and sparse versi
-0000e900: 6f6e 0a20 2020 2020 2020 2023 2054 4f44  on.        # TOD
-0000e910: 4f3a 2074 6573 7420 7468 6973 2066 6f72  O: test this for
-0000e920: 2064 6972 6563 7465 6420 6772 6170 6873   directed graphs
-0000e930: 0a20 2020 2020 2020 2023 2020 5365 7420  .        #  Set 
-0000e940: 6c69 6e6b 2061 7474 7269 6275 7465 2069  link attribute i
-0000e950: 6e20 6967 7261 7068 0a20 2020 2020 2020  n igraph.       
-0000e960: 2066 6f72 2065 2069 6e20 7365 6c66 2e67   for e in self.g
-0000e970: 7261 7068 2e65 733a 0a20 2020 2020 2020  raph.es:.       
-0000e980: 2020 2020 2065 5b61 7474 7269 6275 7465       e[attribute
-0000e990: 5f6e 616d 655d 203d 2076 616c 7565 735b  _name] = values[
-0000e9a0: 652e 7475 706c 655d 0a0a 2020 2020 2020  e.tuple]..      
-0000e9b0: 2020 2320 2053 6574 204e 6574 776f 726b    #  Set Network
-0000e9c0: 2073 7065 6369 6669 6320 6174 7472 6962   specific attrib
-0000e9d0: 7574 6573 0a20 2020 2020 2020 2073 656c  utes.        sel
-0000e9e0: 662e 636c 6561 725f 6c69 6e6b 5f61 7474  f.clear_link_att
-0000e9f0: 7269 6275 7465 2861 7474 7269 6275 7465  ribute(attribute
-0000ea00: 5f6e 616d 6529 0a0a 2020 2020 230a 2020  _name)..    #.  
-0000ea10: 2020 2320 2044 6567 7265 6520 7265 6c61    #  Degree rela
-0000ea20: 7465 6420 6d65 6173 7572 6573 0a20 2020  ted measures.   
-0000ea30: 2023 0a0a 2020 2020 2320 4063 6163 6865   #..    # @cache
-0000ea40: 645f 636f 6e73 7428 2762 6173 6527 2c20  d_const('base', 
-0000ea50: 2764 6567 7265 6527 290a 2020 2020 4063  'degree').    @c
-0000ea60: 6163 6865 645f 7661 7228 2764 6567 7265  ached_var('degre
-0000ea70: 6527 290a 2020 2020 6465 6620 6465 6772  e').    def degr
-0000ea80: 6565 2873 656c 662c 206b 6579 3d4e 6f6e  ee(self, key=Non
-0000ea90: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
-0000eaa0: 2020 2020 2020 2020 5265 7475 726e 206c          Return l
-0000eab0: 6973 7420 6f66 2064 6567 7265 6573 2e0a  ist of degrees..
-0000eac0: 0a20 2020 2020 2020 2049 6620 6120 6c69  .        If a li
-0000ead0: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
-0000eae0: 2069 7320 7370 6563 6966 6965 642c 2072   is specified, r
-0000eaf0: 6574 7572 6e20 7468 6520 6173 736f 6369  eturn the associ
-0000eb00: 6174 6564 2073 7472 656e 6774 680a 0a20  ated strength.. 
-0000eb10: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
-0000eb20: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
-0000eb30: 204e 6574 776f 726b 2e53 6d61 6c6c 5465   Network.SmallTe
-0000eb40: 7374 4e65 7477 6f72 6b28 292e 6465 6772  stNetwork().degr
-0000eb50: 6565 2829 0a20 2020 2020 2020 2061 7272  ee().        arr
-0000eb60: 6179 285b 332c 2033 2c20 322c 2032 2c20  ay([3, 3, 2, 2, 
-0000eb70: 332c 2031 5d29 0a0a 2020 2020 2020 2020  3, 1])..        
-0000eb80: 3a61 7267 2073 7472 206b 6579 3a20 6c69  :arg str key: li
-0000eb90: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
-0000eba0: 205b 6f70 7469 6f6e 616c 5d0a 2020 2020   [optional].    
-0000ebb0: 2020 2020 3a72 7479 7065 3a20 6172 7261      :rtype: arra
-0000ebc0: 7928 5b69 6e74 3e3d 305d 290a 2020 2020  y([int>=0]).    
-0000ebd0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000ebe0: 6966 2073 656c 662e 6469 7265 6374 6564  if self.directed
-0000ebf0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000ec00: 7475 726e 2073 656c 662e 696e 6465 6772  turn self.indegr
-0000ec10: 6565 286b 6579 2920 2b20 7365 6c66 2e6f  ee(key) + self.o
-0000ec20: 7574 6465 6772 6565 286b 6579 290a 2020  utdegree(key).  
-0000ec30: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000ec40: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0000ec50: 656c 662e 6f75 7464 6567 7265 6528 6b65  elf.outdegree(ke
-0000ec60: 7929 0a0a 2020 2020 2320 544f 444f 3a20  y)..    # TODO: 
-0000ec70: 7573 6520 6469 7265 6374 6564 2065 7861  use directed exa
-0000ec80: 6d70 6c65 2068 6572 6520 616e 6420 656c  mple here and el
-0000ec90: 7365 7768 6572 650a 2020 2020 4063 6163  sewhere.    @cac
-0000eca0: 6865 645f 7661 7228 2769 6e64 6567 7265  hed_var('indegre
-0000ecb0: 6527 290a 2020 2020 6465 6620 696e 6465  e').    def inde
-0000ecc0: 6772 6565 2873 656c 662c 206b 6579 3d4e  gree(self, key=N
-0000ecd0: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
-0000ece0: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
-0000ecf0: 206c 6973 7420 6f66 2069 6e2d 6465 6772   list of in-degr
-0000ed00: 6565 732e 0a0a 2020 2020 2020 2020 4966  ees...        If
-0000ed10: 2061 206c 696e 6b20 6174 7472 6962 7574   a link attribut
-0000ed20: 6520 6b65 7920 6973 2073 7065 6369 6669  e key is specifi
-0000ed30: 6564 2c20 7265 7475 726e 2074 6865 2061  ed, return the a
-0000ed40: 7373 6f63 6961 7465 6420 696e 2073 7472  ssociated in str
-0000ed50: 656e 6774 680a 0a20 2020 2020 2020 202a  ength..        *
-0000ed60: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-0000ed70: 2020 2020 203e 3e3e 204e 6574 776f 726b       >>> Network
-0000ed80: 2e53 6d61 6c6c 4469 7265 6374 6564 5465  .SmallDirectedTe
-0000ed90: 7374 4e65 7477 6f72 6b28 292e 696e 6465  stNetwork().inde
-0000eda0: 6772 6565 2829 0a20 2020 2020 2020 2061  gree().        a
-0000edb0: 7272 6179 285b 322c 2032 2c20 322c 2031  rray([2, 2, 2, 1
-0000edc0: 2c20 312c 2030 5d29 0a0a 2020 2020 2020  , 1, 0])..      
-0000edd0: 2020 3a61 7267 2073 7472 206b 6579 3a20    :arg str key: 
-0000ede0: 6c69 6e6b 2061 7474 7269 6275 7465 206b  link attribute k
-0000edf0: 6579 205b 6f70 7469 6f6e 616c 5d0a 2020  ey [optional].  
-0000ee00: 2020 2020 2020 3a72 7479 7065 3a20 6172        :rtype: ar
-0000ee10: 7261 7928 5b69 6e74 3e3d 305d 290a 2020  ray([int>=0]).  
-0000ee20: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000ee30: 2020 6966 206b 6579 2069 7320 4e6f 6e65    if key is None
-0000ee40: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000ee50: 7475 726e 2073 656c 662e 7370 5f41 2e73  turn self.sp_A.s
-0000ee60: 756d 2861 7869 733d 3029 2e41 2e73 7175  um(axis=0).A.squ
-0000ee70: 6565 7a65 2829 2e61 7374 7970 6528 696e  eeze().astype(in
-0000ee80: 7429 0a20 2020 2020 2020 2065 6c73 653a  t).        else:
-0000ee90: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000eea0: 7572 6e20 7365 6c66 2e6c 696e 6b5f 6174  urn self.link_at
-0000eeb0: 7472 6962 7574 6528 6b65 7929 2e73 756d  tribute(key).sum
-0000eec0: 2861 7869 733d 3029 2e54 0a0a 2020 2020  (axis=0).T..    
-0000eed0: 4063 6163 6865 645f 7661 7228 276f 7574  @cached_var('out
-0000eee0: 6465 6772 6565 2729 0a20 2020 2064 6566  degree').    def
-0000eef0: 206f 7574 6465 6772 6565 2873 656c 662c   outdegree(self,
-0000ef00: 206b 6579 3d4e 6f6e 6529 3a0a 2020 2020   key=None):.    
-0000ef10: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000ef20: 5265 7475 726e 206c 6973 7420 6f66 206f  Return list of o
-0000ef30: 7574 2d64 6567 7265 6573 2e0a 0a20 2020  ut-degrees...   
-0000ef40: 2020 2020 2049 6620 6120 6c69 6e6b 2061       If a link a
-0000ef50: 7474 7269 6275 7465 206b 6579 2069 7320  ttribute key is 
-0000ef60: 7370 6563 6966 6965 642c 2072 6574 7572  specified, retur
-0000ef70: 6e20 7468 6520 6173 736f 6369 6174 6564  n the associated
-0000ef80: 206f 7574 0a20 2020 2020 2020 2073 7472   out.        str
-0000ef90: 656e 6774 680a 0a20 2020 2020 2020 202a  ength..        *
-0000efa0: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-0000efb0: 2020 2020 203e 3e3e 204e 6574 776f 726b       >>> Network
-0000efc0: 2e53 6d61 6c6c 4469 7265 6374 6564 5465  .SmallDirectedTe
-0000efd0: 7374 4e65 7477 6f72 6b28 292e 6f75 7464  stNetwork().outd
-0000efe0: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
-0000eff0: 6172 7261 7928 5b32 2c20 322c 2030 2c20  array([2, 2, 0, 
-0000f000: 312c 2032 2c20 315d 290a 0a20 2020 2020  1, 2, 1])..     
-0000f010: 2020 203a 6172 6720 7374 7220 6b65 793a     :arg str key:
-0000f020: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
-0000f030: 6b65 7920 5b6f 7074 696f 6e61 6c5d 0a20  key [optional]. 
-0000f040: 2020 2020 2020 203a 7274 7970 653a 2061         :rtype: a
-0000f050: 7272 6179 285b 696e 743e 3d30 5d29 0a20  rray([int>=0]). 
-0000f060: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000f070: 2020 2069 6620 6b65 7920 6973 204e 6f6e     if key is Non
-0000f080: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-0000f090: 6574 7572 6e20 7365 6c66 2e73 705f 412e  eturn self.sp_A.
-0000f0a0: 7375 6d28 6178 6973 3d31 292e 542e 412e  sum(axis=1).T.A.
-0000f0b0: 7371 7565 657a 6528 292e 6173 7479 7065  squeeze().astype
-0000f0c0: 2869 6e74 290a 2020 2020 2020 2020 656c  (int).        el
-0000f0d0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000f0e0: 7265 7475 726e 2073 656c 662e 6c69 6e6b  return self.link
-0000f0f0: 5f61 7474 7269 6275 7465 286b 6579 292e  _attribute(key).
-0000f100: 7375 6d28 6178 6973 3d31 292e 540a 0a20  sum(axis=1).T.. 
-0000f110: 2020 2040 6361 6368 6564 5f76 6172 2827     @cached_var('
-0000f120: 6269 6c64 6567 7265 6527 290a 2020 2020  bildegree').    
-0000f130: 6465 6620 6269 6c64 6567 7265 6528 7365  def bildegree(se
-0000f140: 6c66 2c20 6b65 793d 4e6f 6e65 293a 0a20  lf, key=None):. 
-0000f150: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0000f160: 2020 2052 6574 7572 6e20 6c69 7374 206f     Return list o
-0000f170: 6620 6269 6c61 7465 7261 6c20 6465 6772  f bilateral degr
-0000f180: 6565 732c 2069 2e65 2e20 7468 6520 6e75  ees, i.e. the nu
-0000f190: 6d62 6572 206f 6620 7369 6d75 6c74 616e  mber of simultan
-0000f1a0: 656f 7573 6c79 2069 6e2d 0a20 2020 2020  eously in-.     
-0000f1b0: 2020 2061 6e64 206f 7574 2d67 6f69 6e67     and out-going
-0000f1c0: 2065 6467 6573 2e0a 0a20 2020 2020 2020   edges...       
-0000f1d0: 2049 6620 6120 6c69 6e6b 2061 7474 7269   If a link attri
-0000f1e0: 6275 7465 206b 6579 2069 7320 7370 6563  bute key is spec
-0000f1f0: 6966 6965 642c 2072 6574 7572 6e20 7468  ified, return th
-0000f200: 6520 6173 736f 6369 6174 6564 2062 696c  e associated bil
-0000f210: 6174 6572 616c 0a20 2020 2020 2020 2073  ateral.        s
-0000f220: 7472 656e 6774 680a 0a20 2020 2020 2020  trength..       
-0000f230: 202a 2a45 786d 6170 6c65 3a2a 2a0a 0a20   **Exmaple:**.. 
-0000f240: 2020 2020 2020 203e 3e3e 204e 6574 776f         >>> Netwo
-0000f250: 726b 2e53 6d61 6c6c 4469 7265 6374 6564  rk.SmallDirected
-0000f260: 5465 7374 4e65 7477 6f72 6b28 292e 6269  TestNetwork().bi
-0000f270: 6c64 6567 7265 6528 290a 2020 2020 2020  ldegree().      
-0000f280: 2020 6172 7261 7928 5b30 2c20 302c 2030    array([0, 0, 0
-0000f290: 2c20 302c 2030 2c20 305d 2c20 6474 7970  , 0, 0, 0], dtyp
-0000f2a0: 653d 696e 7431 3629 0a20 2020 2020 2020  e=int16).       
-0000f2b0: 203e 3e3e 206e 6574 203d 204e 6574 776f   >>> net = Netwo
-0000f2c0: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-0000f2d0: 6f72 6b28 290a 2020 2020 2020 2020 3e3e  ork().        >>
-0000f2e0: 3e20 286e 6574 2e62 696c 6465 6772 6565  > (net.bildegree
-0000f2f0: 2829 203d 3d20 6e65 742e 6465 6772 6565  () == net.degree
-0000f300: 2829 292e 616c 6c28 290a 2020 2020 2020  ()).all().      
-0000f310: 2020 5472 7565 0a20 2020 2020 2020 2022    True.        "
-0000f320: 2222 0a20 2020 2020 2020 2069 6620 6b65  "".        if ke
-0000f330: 7920 6973 204e 6f6e 653a 0a20 2020 2020  y is None:.     
-0000f340: 2020 2020 2020 2072 6574 7572 6e20 2873         return (s
-0000f350: 656c 662e 7370 5f41 202a 2073 656c 662e  elf.sp_A * self.
-0000f360: 7370 5f41 292e 6469 6167 6f6e 616c 2829  sp_A).diagonal()
-0000f370: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0000f380: 2020 2020 2020 2020 2020 2077 203d 2073             w = s
-0000f390: 656c 662e 6c69 6e6b 5f61 7474 7269 6275  elf.link_attribu
-0000f3a0: 7465 286b 6579 290a 2020 2020 2020 2020  te(key).        
-0000f3b0: 2020 2020 7265 7475 726e 2028 7720 4020      return (w @ 
-0000f3c0: 7729 2e64 6961 676f 6e61 6c28 290a 0a20  w).diagonal().. 
-0000f3d0: 2020 2040 6361 6368 6564 5f76 6172 2827     @cached_var('
-0000f3e0: 6e73 695f 6465 6772 6565 272c 2027 6e2e  nsi_degree', 'n.
-0000f3f0: 732e 692e 2064 6567 7265 6527 290a 2020  s.i. degree').  
-0000f400: 2020 6465 6620 6e73 695f 6465 6772 6565    def nsi_degree
-0000f410: 5f75 6e63 6f72 7228 7365 6c66 2c20 6b65  _uncorr(self, ke
-0000f420: 793d 4e6f 6e65 293a 0a20 2020 2020 2020  y=None):.       
-0000f430: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
-0000f440: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
-0000f450: 726e 2069 7473 2075 6e63 6f72 7265 6374  rn its uncorrect
-0000f460: 6564 206e 2e73 2e69 2e20 6465 6772 6565  ed n.s.i. degree
-0000f470: 2e0a 0a20 2020 2020 2020 2049 6620 6120  ...        If a 
-0000f480: 6c69 6e6b 2061 7474 7269 6275 7465 206b  link attribute k
-0000f490: 6579 2069 7320 7370 6563 6966 6965 642c  ey is specified,
-0000f4a0: 2072 6574 7572 6e20 7468 6520 6173 736f   return the asso
-0000f4b0: 6369 6174 6564 206e 7369 0a20 2020 2020  ciated nsi.     
-0000f4c0: 2020 2073 7472 656e 6774 680a 0a20 2020     strength..   
-0000f4d0: 2020 2020 203a 6172 6720 7374 7220 6b65       :arg str ke
-0000f4e0: 793a 206c 696e 6b20 6174 7472 6962 7574  y: link attribut
-0000f4f0: 6520 6b65 7920 5b6f 7074 696f 6e61 6c5d  e key [optional]
-0000f500: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-0000f510: 2061 7272 6179 285b 666c 6f61 745d 290a   array([float]).
-0000f520: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0000f530: 2020 2020 6966 2073 656c 662e 6469 7265      if self.dire
-0000f540: 6374 6564 3a0a 2020 2020 2020 2020 2020  cted:.          
-0000f550: 2020 7265 7475 726e 2073 656c 662e 6e73    return self.ns
-0000f560: 695f 696e 6465 6772 6565 286b 6579 2920  i_indegree(key) 
-0000f570: 2b20 7365 6c66 2e6e 7369 5f6f 7574 6465  + self.nsi_outde
-0000f580: 6772 6565 286b 6579 290a 2020 2020 2020  gree(key).      
-0000f590: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000f5a0: 2020 2020 6966 206b 6579 2069 7320 4e6f      if key is No
-0000f5b0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0000f5c0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000f5d0: 7370 5f41 706c 7573 2829 202a 2073 656c  sp_Aplus() * sel
-0000f5e0: 662e 6e6f 6465 5f77 6569 6768 7473 0a20  f.node_weights. 
-0000f5f0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000f600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f610: 2077 203d 2073 656c 662e 6c69 6e6b 5f61   w = self.link_a
-0000f620: 7474 7269 6275 7465 286b 6579 290a 2020  ttribute(key).  
-0000f630: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000f640: 7475 726e 2028 7365 6c66 2e6e 6f64 655f  turn (self.node_
-0000f650: 7765 6967 6874 7320 4020 7729 2e73 7175  weights @ w).squ
-0000f660: 6565 7a65 2829 0a0a 2020 2020 6465 6620  eeze()..    def 
-0000f670: 7370 5f6e 7369 5f64 6961 675f 6b28 7365  sp_nsi_diag_k(se
-0000f680: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0000f690: 5370 6172 7365 2064 6961 676f 6e61 6c20  Sparse diagonal 
-0000f6a0: 6d61 7472 6978 206f 6620 6e2e 732e 692e  matrix of n.s.i.
-0000f6b0: 2064 6567 7265 6573 2222 220a 2020 2020   degrees""".    
-0000f6c0: 2020 2020 7265 7475 726e 2073 702e 6469      return sp.di
-0000f6d0: 6167 7328 5b73 656c 662e 6e73 695f 6465  ags([self.nsi_de
-0000f6e0: 6772 6565 5f75 6e63 6f72 7228 295d 2c20  gree_uncorr()], 
-0000f6f0: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
-0000f700: 2020 2020 2020 2020 2020 2020 2073 6861               sha
-0000f710: 7065 3d28 7365 6c66 2e4e 2c20 7365 6c66  pe=(self.N, self
-0000f720: 2e4e 292c 2066 6f72 6d61 743d 2763 7363  .N), format='csc
-0000f730: 2729 0a0a 2020 2020 6465 6620 7370 5f6e  ')..    def sp_n
-0000f740: 7369 5f64 6961 675f 6b5f 696e 7628 7365  si_diag_k_inv(se
-0000f750: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0000f760: 5370 6172 7365 2064 6961 676f 6e61 6c20  Sparse diagonal 
-0000f770: 6d61 7472 6978 206f 6620 696e 7665 7273  matrix of invers
-0000f780: 6520 6e2e 732e 692e 2064 6567 7265 6573  e n.s.i. degrees
-0000f790: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-0000f7a0: 726e 2073 702e 6469 6167 7328 5b6e 702e  rn sp.diags([np.
-0000f7b0: 706f 7765 7228 7365 6c66 2e6e 7369 5f64  power(self.nsi_d
-0000f7c0: 6567 7265 655f 756e 636f 7272 2829 2c20  egree_uncorr(), 
-0000f7d0: 2d31 295d 2c20 5b30 5d2c 0a20 2020 2020  -1)], [0],.     
-0000f7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f7f0: 2020 2073 6861 7065 3d28 7365 6c66 2e4e     shape=(self.N
-0000f800: 2c20 7365 6c66 2e4e 292c 2066 6f72 6d61  , self.N), forma
-0000f810: 743d 2763 7363 2729 0a0a 2020 2020 6465  t='csc')..    de
-0000f820: 6620 6e73 695f 6465 6772 6565 2873 656c  f nsi_degree(sel
-0000f830: 662c 2074 7970 6963 616c 5f77 6569 6768  f, typical_weigh
-0000f840: 743d 4e6f 6e65 2c20 6b65 793d 4e6f 6e65  t=None, key=None
-0000f850: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0000f860: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
-0000f870: 6e6f 6465 2c20 7265 7475 726e 2069 7473  node, return its
-0000f880: 2075 6e63 6f72 7265 6374 6564 206f 7220   uncorrected or 
-0000f890: 636f 7272 6563 7465 6420 6e2e 732e 692e  corrected n.s.i.
-0000f8a0: 2064 6567 7265 652e 0a0a 2020 2020 2020   degree...      
-0000f8b0: 2020 4966 2061 206c 696e 6b20 6174 7472    If a link attr
-0000f8c0: 6962 7574 6520 6b65 7920 6973 2073 7065  ibute key is spe
-0000f8d0: 6369 6669 6564 2c20 7265 7475 726e 2074  cified, return t
-0000f8e0: 6865 2061 7373 6f63 6961 7465 6420 6e73  he associated ns
-0000f8f0: 690a 2020 2020 2020 2020 7374 7265 6e67  i.        streng
-0000f900: 7468 0a0a 0a20 2020 2020 2020 202a 2a45  th...        **E
-0000f910: 7861 6d70 6c65 733a 2a2a 0a0a 2020 2020  xamples:**..    
-0000f920: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-0000f930: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-0000f940: 6574 776f 726b 2829 0a20 2020 2020 2020  etwork().       
-0000f950: 203e 3e3e 206e 6574 2e6e 7369 5f64 6567   >>> net.nsi_deg
-0000f960: 7265 6528 290a 2020 2020 2020 2020 4361  ree().        Ca
-0000f970: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
-0000f980: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
-0000f990: 2020 2061 7272 6179 285b 2038 2e34 2c20     array([ 8.4, 
-0000f9a0: 2038 2e20 2c20 2035 2e39 2c20 2035 2e33   8. ,  5.9,  5.3
-0000f9b0: 2c20 2037 2e34 2c20 2034 2e20 5d29 0a20  ,  7.4,  4. ]). 
-0000f9c0: 2020 2020 2020 203e 3e3e 206e 6574 2e73         >>> net.s
-0000f9d0: 706c 6974 7465 645f 636f 7079 2829 2e6e  plitted_copy().n
-0000f9e0: 7369 5f64 6567 7265 6528 290a 2020 2020  si_degree().    
-0000f9f0: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-0000fa00: 6e2e 732e 692e 2064 6567 7265 652e 2e2e  n.s.i. degree...
-0000fa10: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
-0000fa20: 2038 2e34 2c20 2038 2e20 2c20 2035 2e39   8.4,  8. ,  5.9
-0000fa30: 2c20 2035 2e33 2c20 2037 2e34 2c20 2034  ,  5.3,  7.4,  4
-0000fa40: 2e20 2c20 2034 2e20 5d29 0a20 2020 2020  . ,  4. ]).     
-0000fa50: 2020 203e 3e3e 206e 6574 2e6e 7369 5f64     >>> net.nsi_d
-0000fa60: 6567 7265 6528 7479 7069 6361 6c5f 7765  egree(typical_we
-0000fa70: 6967 6874 3d32 2e30 290a 2020 2020 2020  ight=2.0).      
-0000fa80: 2020 6172 7261 7928 5b20 332e 3220 2c20    array([ 3.2 , 
-0000fa90: 2033 2e20 202c 2020 312e 3935 2c20 2031   3.  ,  1.95,  1
-0000faa0: 2e36 352c 2020 322e 3720 2c20 2031 2e20  .65,  2.7 ,  1. 
-0000fab0: 205d 290a 2020 2020 2020 2020 3e3e 3e20   ]).        >>> 
-0000fac0: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
-0000fad0: 7928 292e 6e73 695f 6465 6772 6565 2874  y().nsi_degree(t
-0000fae0: 7970 6963 616c 5f77 6569 6768 743d 322e  ypical_weight=2.
-0000faf0: 3029 0a20 2020 2020 2020 2043 616c 6375  0).        Calcu
-0000fb00: 6c61 7469 6e67 206e 2e73 2e69 2e20 6465  lating n.s.i. de
-0000fb10: 6772 6565 2e2e 2e0a 2020 2020 2020 2020  gree....        
-0000fb20: 6172 7261 7928 5b20 332e 3220 2c20 2033  array([ 3.2 ,  3
-0000fb30: 2e20 202c 2020 312e 3935 2c20 2031 2e36  .  ,  1.95,  1.6
-0000fb40: 352c 2020 322e 3720 2c20 2031 2e20 202c  5,  2.7 ,  1.  ,
-0000fb50: 2020 312e 2020 5d29 0a0a 2020 2020 2020    1.  ])..      
-0000fb60: 2020 6173 2063 6f6d 7061 7265 6420 746f    as compared to
-0000fb70: 2074 6865 2075 6e77 6569 6768 7465 6420   the unweighted 
-0000fb80: 7665 7273 696f 6e3a 0a0a 2020 2020 2020  version:..      
-0000fb90: 2020 3e3e 3e20 6e65 7420 3d20 4e65 7477    >>> net = Netw
-0000fba0: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
-0000fbb0: 776f 726b 2829 0a20 2020 2020 2020 203e  work().        >
-0000fbc0: 3e3e 2072 286e 6574 2e64 6567 7265 6528  >> r(net.degree(
-0000fbd0: 2929 0a20 2020 2020 2020 2061 7272 6179  )).        array
-0000fbe0: 285b 332c 2033 2c20 322c 2032 2c20 332c  ([3, 3, 2, 2, 3,
-0000fbf0: 2031 5d29 0a20 2020 2020 2020 203e 3e3e   1]).        >>>
-0000fc00: 2072 286e 6574 2e73 706c 6974 7465 645f   r(net.splitted_
-0000fc10: 636f 7079 2829 2e64 6567 7265 6528 2929  copy().degree())
-0000fc20: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
-0000fc30: 342c 2033 2c20 322c 2032 2c20 332c 2032  4, 3, 2, 2, 3, 2
-0000fc40: 2c20 325d 290a 0a20 2020 2020 2020 203a  , 2])..        :
-0000fc50: 7479 7065 2074 7970 6963 616c 5f77 6569  type typical_wei
-0000fc60: 6768 743a 2066 6c6f 6174 203e 2030 0a20  ght: float > 0. 
-0000fc70: 2020 2020 2020 203a 6172 6720 2074 7970         :arg  typ
-0000fc80: 6963 616c 5f77 6569 6768 743a 204f 7074  ical_weight: Opt
-0000fc90: 696f 6e61 6c20 7479 7069 6361 6c20 6e6f  ional typical no
-0000fca0: 6465 2077 6569 6768 7420 746f 2062 6520  de weight to be 
-0000fcb0: 7573 6564 2066 6f72 0a20 2020 2020 2020  used for.       
-0000fcc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fcd0: 2020 2020 2020 2063 6f72 7265 6374 696f         correctio
-0000fce0: 6e2e 2049 6620 4e6f 6e65 2c20 7468 6520  n. If None, the 
-0000fcf0: 756e 636f 7272 6563 7465 6420 6d65 6173  uncorrected meas
-0000fd00: 7572 6520 6973 0a20 2020 2020 2020 2020  ure is.         
-0000fd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fd20: 2020 2020 2072 6574 7572 6e65 642e 2028       returned. (
-0000fd30: 4465 6661 756c 743a 204e 6f6e 6529 0a20  Default: None). 
-0000fd40: 2020 2020 2020 203a 6172 6720 7374 7220         :arg str 
-0000fd50: 6b65 793a 206c 696e 6b20 6174 7472 6962  key: link attrib
-0000fd60: 7574 6520 6b65 7920 286f 7074 696f 6e61  ute key (optiona
-0000fd70: 6c29 0a20 2020 2020 2020 203a 7274 7970  l).        :rtyp
-0000fd80: 653a 2061 7272 6179 285b 666c 6f61 745d  e: array([float]
-0000fd90: 290a 2020 2020 2020 2020 2222 220a 2020  ).        """.  
-0000fda0: 2020 2020 2020 6966 2074 7970 6963 616c        if typical
-0000fdb0: 5f77 6569 6768 7420 6973 204e 6f6e 653a  _weight is None:
-0000fdc0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000fdd0: 7572 6e20 7365 6c66 2e6e 7369 5f64 6567  urn self.nsi_deg
-0000fde0: 7265 655f 756e 636f 7272 286b 6579 290a  ree_uncorr(key).
-0000fdf0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000fe00: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000fe10: 2073 656c 662e 6e73 695f 6465 6772 6565   self.nsi_degree
-0000fe20: 5f75 6e63 6f72 7228 6b65 7929 2f74 7970  _uncorr(key)/typ
-0000fe30: 6963 616c 5f77 6569 6768 7420 2d20 312e  ical_weight - 1.
-0000fe40: 300a 0a20 2020 2040 6361 6368 6564 5f76  0..    @cached_v
-0000fe50: 6172 2827 6e73 695f 696e 6465 6772 6565  ar('nsi_indegree
-0000fe60: 2729 0a20 2020 2064 6566 206e 7369 5f69  ').    def nsi_i
-0000fe70: 6e64 6567 7265 6528 7365 6c66 2c20 6b65  ndegree(self, ke
-0000fe80: 793d 4e6f 6e65 293a 0a20 2020 2020 2020  y=None):.       
-0000fe90: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
-0000fea0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
-0000feb0: 726e 2069 7473 206e 2e73 2e69 2e20 696e  rn its n.s.i. in
-0000fec0: 6465 6772 6565 0a0a 2020 2020 2020 2020  degree..        
-0000fed0: 4966 2061 206c 696e 6b20 6174 7472 6962  If a link attrib
-0000fee0: 7574 6520 6b65 7920 6973 2073 7065 6369  ute key is speci
-0000fef0: 6669 6564 2c20 7265 7475 726e 2074 6865  fied, return the
-0000ff00: 2061 7373 6f63 6961 7465 6420 6e73 6920   associated nsi 
-0000ff10: 696e 0a20 2020 2020 2020 2073 7472 656e  in.        stren
-0000ff20: 6774 680a 0a20 2020 2020 2020 202a 2a45  gth..        **E
-0000ff30: 7861 6d70 6c65 733a 2a2a 0a0a 2020 2020  xamples:**..    
-0000ff40: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-0000ff50: 7477 6f72 6b2e 536d 616c 6c44 6972 6563  twork.SmallDirec
-0000ff60: 7465 6454 6573 744e 6574 776f 726b 2829  tedTestNetwork()
-0000ff70: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
-0000ff80: 2e6e 7369 5f69 6e64 6567 7265 6528 290a  .nsi_indegree().
-0000ff90: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-0000ffa0: 362e 332c 2020 352e 332c 2020 352e 392c  6.3,  5.3,  5.9,
-0000ffb0: 2020 332e 362c 2020 342e 202c 2020 322e    3.6,  4. ,  2.
-0000ffc0: 355d 290a 2020 2020 2020 2020 3e3e 3e20  5]).        >>> 
-0000ffd0: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
-0000ffe0: 7928 292e 6e73 695f 696e 6465 6772 6565  y().nsi_indegree
-0000fff0: 2829 0a20 2020 2020 2020 2061 7272 6179  ().        array
-00010000: 285b 2036 2e33 2c20 2035 2e33 2c20 2035  ([ 6.3,  5.3,  5
-00010010: 2e39 2c20 2033 2e36 2c20 2034 2e20 2c20  .9,  3.6,  4. , 
-00010020: 2032 2e35 2c20 2032 2e35 5d29 0a0a 2020   2.5,  2.5])..  
-00010030: 2020 2020 2020 6173 2063 6f6d 7061 7265        as compare
-00010040: 6420 746f 2074 6865 2075 6e77 6569 6768  d to the unweigh
-00010050: 7465 6420 7665 7273 696f 6e3a 0a0a 2020  ted version:..  
-00010060: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
-00010070: 4e65 7477 6f72 6b2e 536d 616c 6c44 6972  Network.SmallDir
-00010080: 6563 7465 6454 6573 744e 6574 776f 726b  ectedTestNetwork
-00010090: 2829 0a20 2020 2020 2020 203e 3e3e 206e  ().        >>> n
-000100a0: 6574 2e69 6e64 6567 7265 6528 290a 2020  et.indegree().  
-000100b0: 2020 2020 2020 6172 7261 7928 5b32 2c20        array([2, 
-000100c0: 322c 2032 2c20 312c 2031 2c20 305d 290a  2, 2, 1, 1, 0]).
-000100d0: 2020 2020 2020 2020 3e3e 3e20 6e65 742e          >>> net.
-000100e0: 7370 6c69 7474 6564 5f63 6f70 7928 292e  splitted_copy().
-000100f0: 696e 6465 6772 6565 2829 0a20 2020 2020  indegree().     
-00010100: 2020 2061 7272 6179 285b 332c 2032 2c20     array([3, 2, 
-00010110: 322c 2031 2c20 312c 2031 2c20 315d 290a  2, 1, 1, 1, 1]).
-00010120: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
-00010130: 7220 6b65 793a 206c 696e 6b20 6174 7472  r key: link attr
-00010140: 6962 7574 6520 6b65 7920 5b6f 7074 696f  ibute key [optio
-00010150: 6e61 6c5d 0a20 2020 2020 2020 2022 2222  nal].        """
-00010160: 0a20 2020 2020 2020 2069 6620 6b65 7920  .        if key 
-00010170: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-00010180: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00010190: 2e6e 6f64 655f 7765 6967 6874 7320 2a20  .node_weights * 
-000101a0: 7365 6c66 2e73 705f 4170 6c75 7328 290a  self.sp_Aplus().
-000101b0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-000101c0: 2020 2020 2020 2020 2020 7720 3d20 7365            w = se
-000101d0: 6c66 2e6c 696e 6b5f 6174 7472 6962 7574  lf.link_attribut
-000101e0: 6528 6b65 7929 0a20 2020 2020 2020 2020  e(key).         
-000101f0: 2020 2072 6574 7572 6e20 2873 656c 662e     return (self.
-00010200: 6e6f 6465 5f77 6569 6768 7473 2040 2077  node_weights @ w
-00010210: 292e 7371 7565 657a 6528 290a 0a20 2020  ).squeeze()..   
-00010220: 2040 6361 6368 6564 5f76 6172 2827 6e73   @cached_var('ns
-00010230: 695f 6f75 7464 6567 7265 6527 290a 2020  i_outdegree').  
-00010240: 2020 6465 6620 6e73 695f 6f75 7464 6567    def nsi_outdeg
-00010250: 7265 6528 7365 6c66 2c20 6b65 793d 4e6f  ree(self, key=No
-00010260: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
-00010270: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
-00010280: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
-00010290: 7473 206e 2e73 2e69 2e6f 7574 6465 6772  ts n.s.i.outdegr
-000102a0: 6565 0a0a 2020 2020 2020 2020 4966 2061  ee..        If a
-000102b0: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
-000102c0: 6b65 7920 6973 2073 7065 6369 6669 6564  key is specified
-000102d0: 2c20 7265 7475 726e 2074 6865 2061 7373  , return the ass
-000102e0: 6f63 6961 7465 6420 6e73 6920 6f75 740a  ociated nsi out.
-000102f0: 2020 2020 2020 2020 7374 7265 6e67 7468          strength
-00010300: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
-00010310: 706c 6573 3a2a 2a0a 0a20 2020 2020 2020  ples:**..       
-00010320: 203e 3e3e 206e 6574 203d 204e 6574 776f   >>> net = Netwo
-00010330: 726b 2e53 6d61 6c6c 4469 7265 6374 6564  rk.SmallDirected
-00010340: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
-00010350: 2020 2020 2020 3e3e 3e20 6e65 742e 6e73        >>> net.ns
-00010360: 695f 6f75 7464 6567 7265 6528 290a 2020  i_outdegree().  
-00010370: 2020 2020 2020 6172 7261 7928 5b20 352e        array([ 5.
-00010380: 332c 2020 352e 392c 2020 312e 392c 2020  3,  5.9,  1.9,  
-00010390: 332e 382c 2020 352e 372c 2020 342e 205d  3.8,  5.7,  4. ]
-000103a0: 290a 2020 2020 2020 2020 3e3e 3e20 6e65  ).        >>> ne
-000103b0: 742e 7370 6c69 7474 6564 5f63 6f70 7928  t.splitted_copy(
-000103c0: 292e 6e73 695f 6f75 7464 6567 7265 6528  ).nsi_outdegree(
-000103d0: 290a 2020 2020 2020 2020 6172 7261 7928  ).        array(
-000103e0: 5b20 352e 332c 2020 352e 392c 2020 312e  [ 5.3,  5.9,  1.
-000103f0: 392c 2020 332e 382c 2020 352e 372c 2020  9,  3.8,  5.7,  
-00010400: 342e 202c 2020 342e 205d 290a 0a20 2020  4. ,  4. ])..   
-00010410: 2020 2020 2061 7320 636f 6d70 6172 6564       as compared
-00010420: 2074 6f20 7468 6520 756e 7765 6967 6874   to the unweight
-00010430: 6564 2076 6572 7369 6f6e 3a0a 0a20 2020  ed version:..   
-00010440: 2020 2020 203e 3e3e 206e 6574 203d 204e       >>> net = N
-00010450: 6574 776f 726b 2e53 6d61 6c6c 4469 7265  etwork.SmallDire
-00010460: 6374 6564 5465 7374 4e65 7477 6f72 6b28  ctedTestNetwork(
-00010470: 290a 2020 2020 2020 2020 3e3e 3e20 6e65  ).        >>> ne
-00010480: 742e 6f75 7464 6567 7265 6528 290a 2020  t.outdegree().  
-00010490: 2020 2020 2020 6172 7261 7928 5b32 2c20        array([2, 
-000104a0: 322c 2030 2c20 312c 2032 2c20 315d 290a  2, 0, 1, 2, 1]).
-000104b0: 2020 2020 2020 2020 3e3e 3e20 6e65 742e          >>> net.
-000104c0: 7370 6c69 7474 6564 5f63 6f70 7928 292e  splitted_copy().
-000104d0: 6f75 7464 6567 7265 6528 290a 2020 2020  outdegree().    
-000104e0: 2020 2020 6172 7261 7928 5b32 2c20 322c      array([2, 2,
-000104f0: 2030 2c20 312c 2032 2c20 322c 2032 5d29   0, 1, 2, 2, 2])
-00010500: 0a0a 2020 2020 2020 2020 3a61 7267 2073  ..        :arg s
-00010510: 7472 206b 6579 3a20 6c69 6e6b 2061 7474  tr key: link att
-00010520: 7269 6275 7465 206b 6579 205b 6f70 7469  ribute key [opti
-00010530: 6f6e 616c 5d0a 2020 2020 2020 2020 2222  onal].        ""
-00010540: 220a 2020 2020 2020 2020 6966 206b 6579  ".        if key
-00010550: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-00010560: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00010570: 662e 7370 5f41 706c 7573 2829 202a 2073  f.sp_Aplus() * s
-00010580: 656c 662e 6e6f 6465 5f77 6569 6768 7473  elf.node_weights
-00010590: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-000105a0: 2020 2020 2020 2020 2020 2077 203d 2073             w = s
-000105b0: 656c 662e 6c69 6e6b 5f61 7474 7269 6275  elf.link_attribu
-000105c0: 7465 286b 6579 290a 2020 2020 2020 2020  te(key).        
-000105d0: 2020 2020 7265 7475 726e 2028 7720 4020      return (w @ 
-000105e0: 7365 6c66 2e6e 6f64 655f 7765 6967 6874  self.node_weight
-000105f0: 732e 7472 616e 7370 6f73 6528 2929 2e74  s.transpose()).t
-00010600: 7261 6e73 706f 7365 2829 2e73 7175 6565  ranspose().squee
-00010610: 7a65 2829 0a0a 2020 2020 4063 6163 6865  ze()..    @cache
-00010620: 645f 636f 6e73 7428 2762 6173 6527 2c20  d_const('base', 
-00010630: 2764 6567 7265 6520 6466 272c 2027 7468  'degree df', 'th
-00010640: 6520 6465 6772 6565 2066 7265 7175 656e  e degree frequen
-00010650: 6379 2064 6973 7472 6962 7574 696f 6e27  cy distribution'
-00010660: 290a 2020 2020 6465 6620 6465 6772 6565  ).    def degree
-00010670: 5f64 6973 7472 6962 7574 696f 6e28 7365  _distribution(se
-00010680: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-00010690: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
-000106a0: 7468 6520 6465 6772 6565 2066 7265 7175  the degree frequ
-000106b0: 656e 6379 2064 6973 7472 6962 7574 696f  ency distributio
-000106c0: 6e2e 0a0a 2020 2020 2020 2020 2a2a 4578  n...        **Ex
-000106d0: 616d 706c 653a 2a2a 0a0a 2020 2020 2020  ample:**..      
-000106e0: 2020 3e3e 3e20 7228 4e65 7477 6f72 6b2e    >>> r(Network.
-000106f0: 536d 616c 6c54 6573 744e 6574 776f 726b  SmallTestNetwork
-00010700: 2829 2e64 6567 7265 655f 6469 7374 7269  ().degree_distri
-00010710: 6275 7469 6f6e 2829 290a 2020 2020 2020  bution()).      
-00010720: 2020 4361 6c63 756c 6174 696e 6720 7468    Calculating th
-00010730: 6520 6465 6772 6565 2066 7265 7175 656e  e degree frequen
-00010740: 6379 2064 6973 7472 6962 7574 696f 6e2e  cy distribution.
-00010750: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-00010760: 285b 2030 2e31 3636 372c 2030 2e33 3333  ([ 0.1667, 0.333
-00010770: 332c 2030 2e35 205d 290a 0a20 2020 2020  3, 0.5 ])..     
-00010780: 2020 203a 7274 7970 653a 2020 3164 206e     :rtype:  1d n
-00010790: 756d 7079 2061 7272 6179 205b 6b5d 206f  umpy array [k] o
-000107a0: 6620 696e 7473 203e 3d20 300a 2020 2020  f ints >= 0.    
-000107b0: 2020 2020 3a72 6574 7572 6e3a 2045 6e74      :return: Ent
-000107c0: 7279 205b 6b5d 2069 7320 7468 6520 6e75  ry [k] is the nu
-000107d0: 6d62 6572 206f 6620 6e6f 6465 7320 6861  mber of nodes ha
-000107e0: 7669 6e67 2064 6567 7265 6520 6b2e 0a20  ving degree k.. 
-000107f0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00010800: 2020 206b 203d 2073 656c 662e 6465 6772     k = self.degr
-00010810: 6565 2829 0a20 2020 2020 2020 2072 6574  ee().        ret
-00010820: 7572 6e20 7365 6c66 2e5f 6869 7374 6f67  urn self._histog
-00010830: 7261 6d28 7661 6c75 6573 3d6b 2c20 6e5f  ram(values=k, n_
-00010840: 6269 6e73 3d6b 2e6d 6178 2829 295b 305d  bins=k.max())[0]
-00010850: 0a0a 2020 2020 4063 6163 6865 645f 636f  ..    @cached_co
-00010860: 6e73 7428 2762 6173 6527 2c20 2769 6e64  nst('base', 'ind
-00010870: 6567 7265 6520 6466 272c 2027 696e 2d64  egree df', 'in-d
-00010880: 6567 7265 6520 6672 6571 7565 6e63 7920  egree frequency 
-00010890: 6469 7374 7269 6275 7469 6f6e 2729 0a20  distribution'). 
-000108a0: 2020 2064 6566 2069 6e64 6567 7265 655f     def indegree_
-000108b0: 6469 7374 7269 6275 7469 6f6e 2873 656c  distribution(sel
-000108c0: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-000108d0: 2020 2020 2020 2020 5265 7475 726e 2074          Return t
-000108e0: 6865 2069 6e2d 6465 6772 6565 2066 7265  he in-degree fre
-000108f0: 7175 656e 6379 2064 6973 7472 6962 7574  quency distribut
-00010900: 696f 6e2e 0a0a 2020 2020 2020 2020 2a2a  ion...        **
-00010910: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-00010920: 2020 2020 3e3e 3e20 7228 4e65 7477 6f72      >>> r(Networ
-00010930: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
-00010940: 726b 2829 2e69 6e64 6567 7265 655f 6469  rk().indegree_di
-00010950: 7374 7269 6275 7469 6f6e 2829 290a 2020  stribution()).  
-00010960: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-00010970: 6720 696e 2d64 6567 7265 6520 6672 6571  g in-degree freq
-00010980: 7565 6e63 7920 6469 7374 7269 6275 7469  uency distributi
-00010990: 6f6e 2e2e 2e0a 2020 2020 2020 2020 6172  on....        ar
-000109a0: 7261 7928 5b20 302e 3136 3637 2c20 302e  ray([ 0.1667, 0.
-000109b0: 3333 3333 2c20 302e 3520 5d29 0a0a 2020  3333, 0.5 ])..  
-000109c0: 2020 2020 2020 3a72 7479 7065 3a20 2031        :rtype:  1
-000109d0: 6420 6e75 6d70 7920 6172 7261 7920 5b6b  d numpy array [k
-000109e0: 5d20 6f66 2069 6e74 7320 3e3d 2030 0a20  ] of ints >= 0. 
-000109f0: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
-00010a00: 456e 7472 7920 5b6b 5d20 6973 2074 6865  Entry [k] is the
-00010a10: 206e 756d 6265 7220 6f66 206e 6f64 6573   number of nodes
-00010a20: 2068 6176 696e 6720 696e 2d64 6567 7265   having in-degre
-00010a30: 6520 6b2e 0a20 2020 2020 2020 2022 2222  e k..        """
-00010a40: 0a20 2020 2020 2020 206b 6920 3d20 7365  .        ki = se
-00010a50: 6c66 2e69 6e64 6567 7265 6528 290a 2020  lf.indegree().  
-00010a60: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00010a70: 662e 5f68 6973 746f 6772 616d 2876 616c  f._histogram(val
-00010a80: 7565 733d 6b69 2c20 6e5f 6269 6e73 3d6b  ues=ki, n_bins=k
-00010a90: 692e 6d61 7828 2929 5b30 5d0a 0a20 2020  i.max())[0]..   
-00010aa0: 2040 6361 6368 6564 5f63 6f6e 7374 2827   @cached_const('
-00010ab0: 6261 7365 272c 2027 6f75 7464 6567 7265  base', 'outdegre
-00010ac0: 6520 6466 272c 2027 6f75 742d 6465 6772  e df', 'out-degr
-00010ad0: 6565 2066 7265 7175 656e 6379 2064 6973  ee frequency dis
-00010ae0: 7472 6962 7574 696f 6e27 290a 2020 2020  tribution').    
-00010af0: 6465 6620 6f75 7464 6567 7265 655f 6469  def outdegree_di
-00010b00: 7374 7269 6275 7469 6f6e 2873 656c 6629  stribution(self)
-00010b10: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00010b20: 2020 2020 2020 5265 7475 726e 2074 6865        Return the
-00010b30: 206f 7574 2d64 6567 7265 6520 6672 6571   out-degree freq
-00010b40: 7565 6e63 7920 6469 7374 7269 6275 7469  uency distributi
-00010b50: 6f6e 2e0a 0a20 2020 2020 2020 202a 2a45  on...        **E
-00010b60: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
-00010b70: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
-00010b80: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-00010b90: 6b28 292e 6f75 7464 6567 7265 655f 6469  k().outdegree_di
-00010ba0: 7374 7269 6275 7469 6f6e 2829 290a 2020  stribution()).  
-00010bb0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-00010bc0: 6720 6f75 742d 6465 6772 6565 2066 7265  g out-degree fre
-00010bd0: 7175 656e 6379 2064 6973 7472 6962 7574  quency distribut
-00010be0: 696f 6e2e 2e2e 0a20 2020 2020 2020 2061  ion....        a
-00010bf0: 7272 6179 285b 2030 2e31 3636 372c 2030  rray([ 0.1667, 0
-00010c00: 2e20 2c20 302e 3333 3333 2c20 302e 3520  . , 0.3333, 0.5 
-00010c10: 5d29 0a0a 2020 2020 2020 2020 3a72 7479  ])..        :rty
-00010c20: 7065 3a20 2031 6420 6e75 6d70 7920 6172  pe:  1d numpy ar
-00010c30: 7261 7920 5b6b 5d20 6f66 2069 6e74 7320  ray [k] of ints 
-00010c40: 3e3d 2030 0a20 2020 2020 2020 203a 7265  >= 0.        :re
-00010c50: 7475 726e 3a20 456e 7472 7920 5b6b 5d20  turn: Entry [k] 
-00010c60: 6973 2074 6865 206e 756d 6265 7220 6f66  is the number of
-00010c70: 206e 6f64 6573 2068 6176 696e 6720 6f75   nodes having ou
-00010c80: 742d 6465 6772 6565 206b 2e0a 2020 2020  t-degree k..    
-00010c90: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00010ca0: 6b6f 203d 2073 656c 662e 6f75 7464 6567  ko = self.outdeg
-00010cb0: 7265 6528 290a 2020 2020 2020 2020 7265  ree().        re
-00010cc0: 7475 726e 2073 656c 662e 5f68 6973 746f  turn self._histo
-00010cd0: 6772 616d 2876 616c 7565 733d 6b6f 2c20  gram(values=ko, 
-00010ce0: 6e5f 6269 6e73 3d6b 6f2e 6d61 7828 292b  n_bins=ko.max()+
-00010cf0: 3129 5b30 5d0a 0a20 2020 2040 6361 6368  1)[0]..    @cach
-00010d00: 6564 5f63 6f6e 7374 2827 6261 7365 272c  ed_const('base',
-00010d10: 2027 6465 6772 6565 2063 6466 272c 2027   'degree cdf', '
-00010d20: 7468 6520 6375 6d75 6c61 7469 7665 2064  the cumulative d
-00010d30: 6567 7265 6520 6469 7374 7269 6275 7469  egree distributi
-00010d40: 6f6e 2729 0a20 2020 2064 6566 2064 6567  on').    def deg
-00010d50: 7265 655f 6364 6628 7365 6c66 293a 0a20  ree_cdf(self):. 
-00010d60: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00010d70: 2020 2052 6574 7572 6e20 7468 6520 6375     Return the cu
-00010d80: 6d75 6c61 7469 7665 2064 6567 7265 6520  mulative degree 
-00010d90: 6672 6571 7565 6e63 7920 6469 7374 7269  frequency distri
-00010da0: 6275 7469 6f6e 2e0a 0a20 2020 2020 2020  bution...       
-00010db0: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
-00010dc0: 2020 2020 2020 203e 3e3e 2072 284e 6574         >>> r(Net
-00010dd0: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
-00010de0: 7477 6f72 6b28 292e 6465 6772 6565 5f63  twork().degree_c
-00010df0: 6466 2829 290a 2020 2020 2020 2020 4361  df()).        Ca
-00010e00: 6c63 756c 6174 696e 6720 7468 6520 6375  lculating the cu
-00010e10: 6d75 6c61 7469 7665 2064 6567 7265 6520  mulative degree 
-00010e20: 6469 7374 7269 6275 7469 6f6e 2e2e 2e0a  distribution....
-00010e30: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-00010e40: 312e 202c 2030 2e38 3333 332c 2020 302e  1. , 0.8333,  0.
-00010e50: 3520 5d29 0a0a 2020 2020 2020 2020 3a72  5 ])..        :r
-00010e60: 7479 7065 3a20 2031 6420 6e75 6d70 7920  type:  1d numpy 
-00010e70: 6172 7261 7920 5b6b 5d20 6f66 2069 6e74  array [k] of int
-00010e80: 7320 3e3d 2030 0a20 2020 2020 2020 203a  s >= 0.        :
-00010e90: 7265 7475 726e 3a20 456e 7472 7920 5b6b  return: Entry [k
-00010ea0: 5d20 6973 2074 6865 206e 756d 6265 7220  ] is the number 
-00010eb0: 6f66 206e 6f64 6573 2068 6176 696e 6720  of nodes having 
-00010ec0: 6465 6772 6565 206b 206f 7220 6d6f 7265  degree k or more
-00010ed0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-00010ee0: 2020 2020 2020 6b20 3d20 7365 6c66 2e64        k = self.d
-00010ef0: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
-00010f00: 7265 7475 726e 2073 656c 662e 5f63 756d  return self._cum
-00010f10: 5f68 6973 746f 6772 616d 2876 616c 7565  _histogram(value
-00010f20: 733d 6b2c 206e 5f62 696e 733d 6b2e 6d61  s=k, n_bins=k.ma
-00010f30: 7828 2929 5b30 5d0a 0a20 2020 2040 6361  x())[0]..    @ca
-00010f40: 6368 6564 5f63 6f6e 7374 2827 6261 7365  ched_const('base
-00010f50: 272c 2027 696e 6465 6772 6565 2063 6466  ', 'indegree cdf
-00010f60: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-00010f70: 2020 2020 2027 7468 6520 6375 6d75 6c61       'the cumula
-00010f80: 7469 7665 2069 6e2d 6465 6772 6565 2064  tive in-degree d
-00010f90: 6973 7472 6962 7574 696f 6e27 290a 2020  istribution').  
-00010fa0: 2020 6465 6620 696e 6465 6772 6565 5f63    def indegree_c
-00010fb0: 6466 2873 656c 6629 3a0a 2020 2020 2020  df(self):.      
-00010fc0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
-00010fd0: 7475 726e 2074 6865 2063 756d 756c 6174  turn the cumulat
-00010fe0: 6976 6520 696e 2d64 6567 7265 6520 6672  ive in-degree fr
-00010ff0: 6571 7565 6e63 7920 6469 7374 7269 6275  equency distribu
-00011000: 7469 6f6e 2e0a 0a20 2020 2020 2020 202a  tion...        *
-00011010: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-00011020: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
-00011030: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-00011040: 6f72 6b28 292e 696e 6465 6772 6565 5f63  ork().indegree_c
-00011050: 6466 2829 290a 2020 2020 2020 2020 4361  df()).        Ca
-00011060: 6c63 756c 6174 696e 6720 7468 6520 6375  lculating the cu
-00011070: 6d75 6c61 7469 7665 2069 6e2d 6465 6772  mulative in-degr
-00011080: 6565 2064 6973 7472 6962 7574 696f 6e2e  ee distribution.
-00011090: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-000110a0: 285b 2031 2e20 2c20 302e 3833 3333 2c20  ([ 1. , 0.8333, 
-000110b0: 302e 3833 3333 2c20 302e 3520 5d29 0a0a  0.8333, 0.5 ])..
-000110c0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-000110d0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
-000110e0: 5b6b 5d20 6f66 2069 6e74 7320 3e3d 2030  [k] of ints >= 0
-000110f0: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
-00011100: 3a20 456e 7472 7920 5b6b 5d20 6973 2074  : Entry [k] is t
-00011110: 6865 206e 756d 6265 7220 6f66 206e 6f64  he number of nod
-00011120: 6573 2068 6176 696e 6720 696e 2d64 6567  es having in-deg
-00011130: 7265 6520 6b20 6f72 206d 6f72 652e 0a20  ree k or more.. 
-00011140: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00011150: 2020 206b 6920 3d20 7365 6c66 2e69 6e64     ki = self.ind
-00011160: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
-00011170: 7265 7475 726e 2073 656c 662e 5f63 756d  return self._cum
-00011180: 5f68 6973 746f 6772 616d 2876 616c 7565  _histogram(value
-00011190: 733d 6b69 2c20 6e5f 6269 6e73 3d6b 692e  s=ki, n_bins=ki.
-000111a0: 6d61 7828 2920 2b20 3129 5b30 5d0a 0a20  max() + 1)[0].. 
-000111b0: 2020 2040 6361 6368 6564 5f63 6f6e 7374     @cached_const
-000111c0: 2827 6261 7365 272c 2027 6f75 7464 6567  ('base', 'outdeg
-000111d0: 7265 6520 6364 6627 2c0a 2020 2020 2020  ree cdf',.      
-000111e0: 2020 2020 2020 2020 2020 2020 2774 6865              'the
-000111f0: 2063 756d 756c 6174 6976 6520 6f75 742d   cumulative out-
-00011200: 6465 6772 6565 2064 6973 7472 6962 7574  degree distribut
-00011210: 696f 6e27 290a 2020 2020 6465 6620 6f75  ion').    def ou
-00011220: 7464 6567 7265 655f 6364 6628 7365 6c66  tdegree_cdf(self
-00011230: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00011240: 2020 2020 2020 2052 6574 7572 6e20 7468         Return th
-00011250: 6520 6375 6d75 6c61 7469 7665 206f 7574  e cumulative out
-00011260: 2d64 6567 7265 6520 6672 6571 7565 6e63  -degree frequenc
-00011270: 7920 6469 7374 7269 6275 7469 6f6e 2e0a  y distribution..
-00011280: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
-00011290: 6c65 3a2a 2a0a 0a20 2020 2020 2020 203e  le:**..        >
-000112a0: 3e3e 2072 284e 6574 776f 726b 2e53 6d61  >> r(Network.Sma
-000112b0: 6c6c 5465 7374 4e65 7477 6f72 6b28 292e  llTestNetwork().
-000112c0: 6f75 7464 6567 7265 655f 6364 6628 2929  outdegree_cdf())
-000112d0: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
-000112e0: 7469 6e67 2074 6865 2063 756d 756c 6174  ting the cumulat
-000112f0: 6976 6520 6f75 742d 6465 6772 6565 2064  ive out-degree d
-00011300: 6973 7472 6962 7574 696f 6e2e 2e2e 0a20  istribution.... 
-00011310: 2020 2020 2020 2061 7272 6179 285b 2031         array([ 1
-00011320: 2e20 2c20 302e 3833 3333 2c20 302e 3833  . , 0.8333, 0.83
-00011330: 3333 2c20 302e 3520 5d29 0a0a 2020 2020  33, 0.5 ])..    
-00011340: 2020 2020 3a72 7479 7065 3a20 2031 6420      :rtype:  1d 
-00011350: 6e75 6d70 7920 6172 7261 7920 5b6b 5d20  numpy array [k] 
-00011360: 6f66 2069 6e74 7320 3e3d 2030 0a20 2020  of ints >= 0.   
-00011370: 2020 2020 203a 7265 7475 726e 3a20 456e       :return: En
-00011380: 7472 7920 5b6b 5d20 6973 2074 6865 206e  try [k] is the n
-00011390: 756d 6265 7220 6f66 206e 6f64 6573 2068  umber of nodes h
-000113a0: 6176 696e 6720 6f75 742d 6465 6772 6565  aving out-degree
-000113b0: 206b 206f 7220 6d6f 7265 2e0a 2020 2020   k or more..    
-000113c0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-000113d0: 6b6f 203d 2073 656c 662e 6f75 7464 6567  ko = self.outdeg
-000113e0: 7265 6528 290a 2020 2020 2020 2020 7265  ree().        re
-000113f0: 7475 726e 2073 656c 662e 5f63 756d 5f68  turn self._cum_h
-00011400: 6973 746f 6772 616d 2876 616c 7565 733d  istogram(values=
-00011410: 6b6f 2c20 6e5f 6269 6e73 3d6b 6f2e 6d61  ko, n_bins=ko.ma
-00011420: 7828 2920 2b20 3129 5b30 5d0a 0a20 2020  x() + 1)[0]..   
-00011430: 2023 2046 4958 4d45 3a20 7368 6f75 6c64   # FIXME: should
-00011440: 2072 6174 6865 7220 7265 7475 726e 2074   rather return t
-00011450: 6865 2077 6569 6768 7465 6420 6469 7374  he weighted dist
-00011460: 7269 6275 7469 6f6e 210a 2020 2020 4063  ribution!.    @c
-00011470: 6163 6865 645f 636f 6e73 7428 276e 7369  ached_const('nsi
-00011480: 272c 2027 6465 6772 6565 2068 6973 7427  ', 'degree hist'
-00011490: 2c20 2761 206e 2e73 2e69 2e20 6465 6772  , 'a n.s.i. degr
-000114a0: 6565 2066 7265 7175 656e 6379 2068 6973  ee frequency his
-000114b0: 746f 6772 616d 2729 0a20 2020 2064 6566  togram').    def
-000114c0: 206e 7369 5f64 6567 7265 655f 6869 7374   nsi_degree_hist
-000114d0: 6f67 7261 6d28 7365 6c66 293a 0a20 2020  ogram(self):.   
-000114e0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000114f0: 2052 6574 7572 6e20 6120 6672 6571 7565   Return a freque
-00011500: 6e63 7920 2821 2920 6869 7374 6f67 7261  ncy (!) histogra
-00011510: 6d20 6f66 206e 2e73 2e69 2e20 6465 6772  m of n.s.i. degr
-00011520: 6565 2e0a 0a20 2020 2020 2020 202a 2a45  ee...        **E
-00011530: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
-00011540: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
-00011550: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-00011560: 6b28 292e 6e73 695f 6465 6772 6565 5f68  k().nsi_degree_h
-00011570: 6973 746f 6772 616d 2829 290a 2020 2020  istogram()).    
-00011580: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-00011590: 6120 6e2e 732e 692e 2064 6567 7265 6520  a n.s.i. degree 
-000115a0: 6672 6571 7565 6e63 7920 6869 7374 6f67  frequency histog
-000115b0: 7261 6d2e 2e2e 0a20 2020 2020 2020 2043  ram....        C
-000115c0: 616c 6375 6c61 7469 6e67 206e 2e73 2e69  alculating n.s.i
-000115d0: 2e20 6465 6772 6565 2e2e 2e0a 2020 2020  . degree....    
-000115e0: 2020 2020 2861 7272 6179 285b 2030 2e33      (array([ 0.3
-000115f0: 3333 332c 2030 2e31 3636 372c 2030 2e35  333, 0.1667, 0.5
-00011600: 205d 292c 2061 7272 6179 285b 2030 2e31   ]), array([ 0.1
-00011610: 3137 392c 2030 2e31 3636 372c 2030 2e30  179, 0.1667, 0.0
-00011620: 3936 325d 292c 0a20 2020 2020 2020 2020  962]),.         
-00011630: 6172 7261 7928 5b20 342e 202c 2035 2e34  array([ 4. , 5.4
-00011640: 3636 372c 2036 2e39 3333 335d 2929 0a0a  667, 6.9333]))..
-00011650: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-00011660: 2074 7570 6c65 2028 6c69 7374 2c6c 6973   tuple (list,lis
-00011670: 7429 0a20 2020 2020 2020 203a 7265 7475  t).        :retu
-00011680: 726e 3a20 4c69 7374 206f 6620 6672 6571  rn: List of freq
-00011690: 7565 6e63 6965 7320 616e 6420 6c69 7374  uencies and list
-000116a0: 206f 6620 6c6f 7765 7220 6269 6e20 626f   of lower bin bo
-000116b0: 756e 6473 2e0a 2020 2020 2020 2020 2222  unds..        ""
-000116c0: 220a 2020 2020 2020 2020 6e73 695f 6b20  ".        nsi_k 
-000116d0: 3d20 7365 6c66 2e6e 7369 5f64 6567 7265  = self.nsi_degre
-000116e0: 6528 290a 2020 2020 2020 2020 7265 7475  e().        retu
-000116f0: 726e 2073 656c 662e 5f68 6973 746f 6772  rn self._histogr
-00011700: 616d 2876 616c 7565 733d 6e73 695f 6b2c  am(values=nsi_k,
-00011710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011730: 6e5f 6269 6e73 3d69 6e74 286e 7369 5f6b  n_bins=int(nsi_k
-00011740: 2e6d 6178 2829 2f6e 7369 5f6b 2e6d 696e  .max()/nsi_k.min
-00011750: 2829 2920 2b20 3129 0a0a 2020 2020 2320  ()) + 1)..    # 
-00011760: 4649 584d 453a 2073 686f 756c 6420 7261  FIXME: should ra
-00011770: 7468 6572 2072 6574 7572 6e20 7468 6520  ther return the 
-00011780: 7765 6967 6874 6564 2064 6973 7472 6962  weighted distrib
-00011790: 7574 696f 6e21 0a20 2020 2040 6361 6368  ution!.    @cach
-000117a0: 6564 5f63 6f6e 7374 2827 6e73 6927 2c20  ed_const('nsi', 
-000117b0: 2764 6567 7265 6520 6869 7374 272c 0a20  'degree hist',. 
-000117c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000117d0: 2027 6120 6375 6d75 6c61 7469 7665 206e   'a cumulative n
-000117e0: 2e73 2e69 2e20 6465 6772 6565 2066 7265  .s.i. degree fre
-000117f0: 7175 656e 6379 2068 6973 746f 6772 616d  quency histogram
-00011800: 2729 0a20 2020 2064 6566 206e 7369 5f64  ').    def nsi_d
-00011810: 6567 7265 655f 6375 6d75 6c61 7469 7665  egree_cumulative
-00011820: 5f68 6973 746f 6772 616d 2873 656c 6629  _histogram(self)
-00011830: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00011840: 2020 2020 2020 5265 7475 726e 2061 2063        Return a c
-00011850: 756d 756c 6174 6976 6520 6672 6571 7565  umulative freque
-00011860: 6e63 7920 2821 2920 6869 7374 6f67 7261  ncy (!) histogra
-00011870: 6d20 6f66 206e 2e73 2e69 2e20 6465 6772  m of n.s.i. degr
-00011880: 6565 2e0a 0a20 2020 2020 2020 202a 2a45  ee...        **E
-00011890: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
-000118a0: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
-000118b0: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-000118c0: 6b28 292e 6e73 695f 6465 6772 6565 5f63  k().nsi_degree_c
-000118d0: 756d 756c 6174 6976 655f 6869 7374 6f67  umulative_histog
-000118e0: 7261 6d28 2929 0a20 2020 2020 2020 2043  ram()).        C
-000118f0: 616c 6375 6c61 7469 6e67 2061 2063 756d  alculating a cum
-00011900: 756c 6174 6976 6520 6e2e 732e 692e 2064  ulative n.s.i. d
-00011910: 6567 7265 6520 6672 6571 7565 6e63 7920  egree frequency 
-00011920: 6869 7374 6f67 7261 6d2e 2e2e 0a20 2020  histogram....   
-00011930: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-00011940: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
-00011950: 2e0a 2020 2020 2020 2020 2861 7272 6179  ..        (array
-00011960: 285b 2031 2e20 2c20 302e 3636 3637 2c20  ([ 1. , 0.6667, 
-00011970: 302e 3520 5d29 2c20 6172 7261 7928 5b20  0.5 ]), array([ 
-00011980: 342e 202c 2035 2e34 3636 372c 2036 2e39  4. , 5.4667, 6.9
-00011990: 3333 335d 2929 0a0a 2020 2020 2020 2020  333]))..        
-000119a0: 3a72 7479 7065 3a20 2074 7570 6c65 2028  :rtype:  tuple (
-000119b0: 6c69 7374 2c6c 6973 7429 0a20 2020 2020  list,list).     
-000119c0: 2020 203a 7265 7475 726e 3a20 4c69 7374     :return: List
-000119d0: 206f 6620 6375 6d75 6c61 7469 7665 2066   of cumulative f
-000119e0: 7265 7175 656e 6369 6573 2061 6e64 206c  requencies and l
-000119f0: 6973 7420 6f66 206c 6f77 6572 2062 696e  ist of lower bin
-00011a00: 2062 6f75 6e64 732e 0a20 2020 2020 2020   bounds..       
-00011a10: 2022 2222 0a20 2020 2020 2020 206e 7369   """.        nsi
-00011a20: 5f6b 203d 2073 656c 662e 6e73 695f 6465  _k = self.nsi_de
-00011a30: 6772 6565 2829 0a20 2020 2020 2020 2072  gree().        r
-00011a40: 6574 7572 6e20 7365 6c66 2e5f 6375 6d5f  eturn self._cum_
-00011a50: 6869 7374 6f67 7261 6d28 7661 6c75 6573  histogram(values
-00011a60: 3d6e 7369 5f6b 2c0a 2020 2020 2020 2020  =nsi_k,.        
-00011a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011a80: 2020 2020 2020 2020 2020 206e 5f62 696e             n_bin
-00011a90: 733d 696e 7428 6e73 695f 6b2e 6d61 7828  s=int(nsi_k.max(
-00011aa0: 292f 6e73 695f 6b2e 6d69 6e28 2929 202b  )/nsi_k.min()) +
-00011ab0: 2031 290a 0a20 2020 2040 6361 6368 6564   1)..    @cached
-00011ac0: 5f63 6f6e 7374 2827 6261 7365 272c 2027  _const('base', '
-00011ad0: 6176 6720 6e62 7220 6465 6772 6565 272c  avg nbr degree',
-00011ae0: 2022 6176 6572 6167 6520 6e65 6967 6862   "average neighb
-00011af0: 6f75 7273 2720 6465 6772 6565 7322 290a  ours' degrees").
-00011b00: 2020 2020 6465 6620 6176 6572 6167 655f      def average_
-00011b10: 6e65 6967 6862 6f72 735f 6465 6772 6565  neighbors_degree
-00011b20: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00011b30: 2222 220a 2020 2020 2020 2020 466f 7220  """.        For 
-00011b40: 6561 6368 206e 6f64 652c 2072 6574 7572  each node, retur
-00011b50: 6e20 7468 6520 6176 6572 6167 6520 6465  n the average de
-00011b60: 6772 6565 206f 6620 6974 7320 6e65 6967  gree of its neig
-00011b70: 6862 6f72 732e 0a0a 2020 2020 2020 2020  hbors...        
-00011b80: 2844 6f65 7320 6e6f 7420 7573 6520 6469  (Does not use di
-00011b90: 7265 6374 696f 6e61 6c69 7479 2069 6e66  rectionality inf
-00011ba0: 6f72 6d61 7469 6f6e 2e29 0a0a 2020 2020  ormation.)..    
-00011bb0: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
-00011bc0: 0a0a 2020 2020 2020 2020 3e3e 3e20 7228  ..        >>> r(
-00011bd0: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
-00011be0: 744e 6574 776f 726b 2829 2e61 7665 7261  tNetwork().avera
-00011bf0: 6765 5f6e 6569 6768 626f 7273 5f64 6567  ge_neighbors_deg
-00011c00: 7265 6528 2929 0a20 2020 2020 2020 2043  ree()).        C
-00011c10: 616c 6375 6c61 7469 6e67 2061 7665 7261  alculating avera
-00011c20: 6765 206e 6569 6768 626f 7572 7327 2064  ge neighbours' d
-00011c30: 6567 7265 6573 2e2e 2e0a 2020 2020 2020  egrees....      
-00011c40: 2020 6172 7261 7928 5b20 322e 202c 2020    array([ 2. ,  
-00011c50: 322e 3333 3333 2c20 2033 2e20 2c20 332e  2.3333,  3. , 3.
-00011c60: 202c 2020 322e 3636 3637 2c20 2033 2e20   ,  2.6667,  3. 
-00011c70: 5d29 0a0a 2020 2020 2020 2020 3a72 7479  ])..        :rty
-00011c80: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
-00011c90: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
-00011ca0: 6174 7320 3e3d 2030 0a20 2020 2020 2020  ats >= 0.       
-00011cb0: 2022 2222 0a20 2020 2020 2020 206b 203d   """.        k =
-00011cc0: 2073 656c 662e 6465 6772 6565 2829 202a   self.degree() *
-00011cd0: 2031 2e30 0a20 2020 2020 2020 2072 6574   1.0.        ret
-00011ce0: 7572 6e20 7365 6c66 2e75 6e64 6972 6563  urn self.undirec
-00011cf0: 7465 645f 6164 6a61 6365 6e63 7928 2920  ted_adjacency() 
-00011d00: 2a20 6b20 2f20 6b5b 6b20 213d 2030 5d0a  * k / k[k != 0].
-00011d10: 0a20 2020 2040 6361 6368 6564 5f63 6f6e  .    @cached_con
-00011d20: 7374 2827 6261 7365 272c 2027 6d61 7820  st('base', 'max 
-00011d30: 6e62 7220 6465 6772 6565 272c 2022 6d61  nbr degree', "ma
-00011d40: 7869 6d75 6d20 6e65 6967 6862 6f75 7273  ximum neighbours
-00011d50: 2720 6465 6772 6565 2229 0a20 2020 2064  ' degree").    d
-00011d60: 6566 206d 6178 5f6e 6569 6768 626f 7273  ef max_neighbors
-00011d70: 5f64 6567 7265 6528 7365 6c66 293a 0a20  _degree(self):. 
-00011d80: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00011d90: 2020 2046 6f72 2065 6163 6820 6e6f 6465     For each node
-00011da0: 2c20 7265 7475 726e 2074 6865 206d 6178  , return the max
-00011db0: 696d 616c 2064 6567 7265 6520 6f66 2069  imal degree of i
-00011dc0: 7473 206e 6569 6768 626f 7273 2e0a 0a20  ts neighbors... 
-00011dd0: 2020 2020 2020 2028 446f 6573 206e 6f74         (Does not
-00011de0: 2075 7365 2064 6972 6563 7469 6f6e 616c   use directional
-00011df0: 6974 7920 696e 666f 726d 6174 696f 6e2e  ity information.
-00011e00: 290a 0a20 2020 2020 2020 202a 2a45 7861  )..        **Exa
-00011e10: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
-00011e20: 203e 3e3e 204e 6574 776f 726b 2e53 6d61   >>> Network.Sma
-00011e30: 6c6c 5465 7374 4e65 7477 6f72 6b28 292e  llTestNetwork().
-00011e40: 6d61 785f 6e65 6967 6862 6f72 735f 6465  max_neighbors_de
-00011e50: 6772 6565 2829 0a20 2020 2020 2020 2043  gree().        C
-00011e60: 616c 6375 6c61 7469 6e67 206d 6178 696d  alculating maxim
-00011e70: 756d 206e 6569 6768 626f 7572 7327 2064  um neighbours' d
-00011e80: 6567 7265 652e 2e2e 0a20 2020 2020 2020  egree....       
-00011e90: 2061 7272 6179 285b 332c 2033 2c20 332c   array([3, 3, 3,
-00011ea0: 2033 2c20 332c 2033 5d29 0a0a 2020 2020   3, 3, 3])..    
-00011eb0: 2020 2020 3a72 7479 7065 3a20 3164 206e      :rtype: 1d n
-00011ec0: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
-00011ed0: 5d20 6f66 2069 6e74 7320 3e3d 2030 0a20  ] of ints >= 0. 
-00011ee0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00011ef0: 2020 206e 626b 7320 3d20 7365 6c66 2e75     nbks = self.u
-00011f00: 6e64 6972 6563 7465 645f 6164 6a61 6365  ndirected_adjace
-00011f10: 6e63 7928 292e 6d75 6c74 6970 6c79 2873  ncy().multiply(s
-00011f20: 656c 662e 6465 6772 6565 2829 290a 2020  elf.degree()).  
-00011f30: 2020 2020 2020 7265 7475 726e 206e 626b        return nbk
-00011f40: 732e 6d61 7828 6178 6973 3d31 292e 542e  s.max(axis=1).T.
-00011f50: 412e 7371 7565 657a 6528 290a 0a20 2020  A.squeeze()..   
-00011f60: 2040 6361 6368 6564 5f63 6f6e 7374 2827   @cached_const('
-00011f70: 6e73 6927 2c20 2761 7667 206e 6272 2064  nsi', 'avg nbr d
-00011f80: 6567 7265 6527 2c20 226e 2e73 2e69 2e20  egree', "n.s.i. 
-00011f90: 6176 6572 6167 6520 6e65 6967 6862 6f75  average neighbou
-00011fa0: 7273 2720 6465 6772 6565 2229 0a20 2020  rs' degree").   
-00011fb0: 2064 6566 206e 7369 5f61 7665 7261 6765   def nsi_average
-00011fc0: 5f6e 6569 6768 626f 7273 5f64 6567 7265  _neighbors_degre
-00011fd0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
-00011fe0: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
-00011ff0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
-00012000: 726e 2074 6865 2061 7665 7261 6765 206e  rn the average n
-00012010: 2e73 2e69 2e20 6465 6772 6565 206f 6620  .s.i. degree of 
-00012020: 6974 7320 6e65 6967 6862 6f72 732e 0a0a  its neighbors...
-00012030: 2020 2020 2020 2020 286e 6f74 2079 6574          (not yet
-00012040: 2069 6d70 6c65 6d65 6e74 6564 2066 6f72   implemented for
-00012050: 2064 6972 6563 7465 6420 6e65 7477 6f72   directed networ
-00012060: 6b73 2e29 0a0a 2020 2020 2020 2020 2a2a  ks.)..        **
-00012070: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-00012080: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-00012090: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-000120a0: 6574 776f 726b 2829 0a20 2020 2020 2020  etwork().       
-000120b0: 203e 3e3e 2072 286e 6574 2e6e 7369 5f61   >>> r(net.nsi_a
-000120c0: 7665 7261 6765 5f6e 6569 6768 626f 7273  verage_neighbors
-000120d0: 5f64 6567 7265 6528 2929 0a20 2020 2020  _degree()).     
-000120e0: 2020 2043 616c 6375 6c61 7469 6e67 206e     Calculating n
-000120f0: 2e73 2e69 2e20 6176 6572 6167 6520 6e65  .s.i. average ne
-00012100: 6967 6862 6f75 7273 2720 6465 6772 6565  ighbours' degree
-00012110: 2e2e 2e0a 2020 2020 2020 2020 4361 6c63  ....        Calc
-00012120: 756c 6174 696e 6720 6e2e 732e 692e 2064  ulating n.s.i. d
-00012130: 6567 7265 652e 2e2e 0a20 2020 2020 2020  egree....       
-00012140: 2061 7272 6179 285b 2036 2e30 3431 372c   array([ 6.0417,
-00012150: 2036 2e36 3220 2c20 372e 3038 3938 2c20   6.62 , 7.0898, 
-00012160: 372e 3034 3334 2c20 372e 3335 3534 2c20  7.0434, 7.3554, 
-00012170: 352e 3635 205d 290a 2020 2020 2020 2020  5.65 ]).        
-00012180: 3e3e 3e20 7228 6e65 742e 7370 6c69 7474  >>> r(net.splitt
-00012190: 6564 5f63 6f70 7928 292e 6e73 695f 6176  ed_copy().nsi_av
-000121a0: 6572 6167 655f 6e65 6967 6862 6f72 735f  erage_neighbors_
-000121b0: 6465 6772 6565 2829 290a 2020 2020 2020  degree()).      
-000121c0: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
-000121d0: 732e 692e 2061 7665 7261 6765 206e 6569  s.i. average nei
-000121e0: 6768 626f 7572 7327 2064 6567 7265 652e  ghbours' degree.
-000121f0: 2e2e 0a20 2020 2020 2020 2043 616c 6375  ...        Calcu
-00012200: 6c61 7469 6e67 206e 2e73 2e69 2e20 6465  lating n.s.i. de
-00012210: 6772 6565 2e2e 2e0a 2020 2020 2020 2020  gree....        
-00012220: 6172 7261 7928 5b20 362e 3034 3137 2c20  array([ 6.0417, 
-00012230: 362e 3632 202c 2037 2e30 3839 382c 2037  6.62 , 7.0898, 7
-00012240: 2e30 3433 342c 2037 2e33 3535 342c 2035  .0434, 7.3554, 5
-00012250: 2e36 3520 2c20 352e 3635 205d 290a 0a20  .65 , 5.65 ]).. 
-00012260: 2020 2020 2020 2061 7320 636f 6d70 6172         as compar
-00012270: 6564 2074 6f20 7468 6520 756e 7765 6967  ed to the unweig
-00012280: 6874 6564 2076 6572 7369 6f6e 3a0a 0a20  hted version:.. 
-00012290: 2020 2020 2020 203e 3e3e 206e 6574 203d         >>> net =
-000122a0: 204e 6574 776f 726b 2e53 6d61 6c6c 5465   Network.SmallTe
-000122b0: 7374 4e65 7477 6f72 6b28 290a 2020 2020  stNetwork().    
-000122c0: 2020 2020 3e3e 3e20 7228 6e65 742e 6176      >>> r(net.av
-000122d0: 6572 6167 655f 6e65 6967 6862 6f72 735f  erage_neighbors_
-000122e0: 6465 6772 6565 2829 290a 2020 2020 2020  degree()).      
-000122f0: 2020 4361 6c63 756c 6174 696e 6720 6176    Calculating av
-00012300: 6572 6167 6520 6e65 6967 6862 6f75 7273  erage neighbours
-00012310: 2720 6465 6772 6565 732e 2e2e 0a20 2020  ' degrees....   
-00012320: 2020 2020 2061 7272 6179 285b 2032 2e20       array([ 2. 
-00012330: 2c20 322e 3333 3333 2c20 332e 202c 2033  , 2.3333, 3. , 3
-00012340: 2e20 2c20 322e 3636 3637 2c20 332e 205d  . , 2.6667, 3. ]
-00012350: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
-00012360: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
-00012370: 7928 292e 6176 6572 6167 655f 6e65 6967  y().average_neig
-00012380: 6862 6f72 735f 6465 6772 6565 2829 290a  hbors_degree()).
-00012390: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-000123a0: 696e 6720 6176 6572 6167 6520 6e65 6967  ing average neig
-000123b0: 6862 6f75 7273 2720 6465 6772 6565 732e  hbours' degrees.
-000123c0: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-000123d0: 285b 2032 2e32 3520 2c20 322e 3333 3333  ([ 2.25 , 2.3333
-000123e0: 2c20 332e 202c 2033 2e35 202c 2033 2e20  , 3. , 3.5 , 3. 
-000123f0: 2c20 332e 202c 2033 2e20 5d29 0a0a 2020  , 3. , 3. ])..  
-00012400: 2020 2020 2020 3a72 7479 7065 3a20 3164        :rtype: 1d
-00012410: 206e 756d 7079 2061 7272 6179 205b 6e6f   numpy array [no
-00012420: 6465 5d20 6f66 2066 6c6f 6174 7320 3e3d  de] of floats >=
-00012430: 2030 0a20 2020 2020 2020 2022 2222 0a20   0.        """. 
-00012440: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-00012450: 6972 6563 7465 643a 0a20 2020 2020 2020  irected:.       
-00012460: 2020 2020 2072 6169 7365 204e 6f74 496d       raise NotIm
-00012470: 706c 656d 656e 7465 6445 7272 6f72 2822  plementedError("
-00012480: 4e6f 7420 696d 706c 656d 656e 7465 6420  Not implemented 
-00012490: 666f 7220 6469 7265 6374 6564 206e 6574  for directed net
-000124a0: 776f 726b 732e 2229 0a0a 2020 2020 2020  works.")..      
-000124b0: 2020 2320 412b 202a 2028 4477 202a 206b    # A+ * (Dw * k
-000124c0: 2920 6973 2066 6173 7465 7220 7468 616e  ) is faster than
-000124d0: 2028 412b 202a 2044 7729 202a 206b 0a20   (A+ * Dw) * k. 
-000124e0: 2020 2020 2020 206e 7369 5f6b 203d 2073         nsi_k = s
-000124f0: 656c 662e 6e73 695f 6465 6772 6565 2829  elf.nsi_degree()
-00012500: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00012510: 7365 6c66 2e73 705f 4170 6c75 7328 2920  self.sp_Aplus() 
-00012520: 2a20 2873 656c 662e 7370 5f64 6961 675f  * (self.sp_diag_
-00012530: 7728 2920 2a20 6e73 695f 6b29 202f 206e  w() * nsi_k) / n
-00012540: 7369 5f6b 0a0a 2020 2020 4063 6163 6865  si_k..    @cache
-00012550: 645f 636f 6e73 7428 276e 7369 272c 2027  d_const('nsi', '
-00012560: 6d61 7820 6e62 7220 6465 6772 6565 272c  max nbr degree',
-00012570: 2022 6e2e 732e 692e 206d 6178 696d 756d   "n.s.i. maximum
-00012580: 206e 6569 6768 626f 7572 2064 6567 7265   neighbour degre
-00012590: 6522 290a 2020 2020 6465 6620 6e73 695f  e").    def nsi_
-000125a0: 6d61 785f 6e65 6967 6862 6f72 735f 6465  max_neighbors_de
-000125b0: 6772 6565 2873 656c 6629 3a0a 2020 2020  gree(self):.    
-000125c0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-000125d0: 466f 7220 6561 6368 206e 6f64 652c 2072  For each node, r
-000125e0: 6574 7572 6e20 7468 6520 6d61 7869 6d61  eturn the maxima
-000125f0: 6c20 6e2e 732e 692e 2064 6567 7265 6520  l n.s.i. degree 
-00012600: 6f66 2069 7473 206e 6569 6768 626f 7273  of its neighbors
-00012610: 2e0a 0a20 2020 2020 2020 2028 6e6f 7420  ...        (not 
-00012620: 7965 7420 696d 706c 656d 656e 7465 6420  yet implemented 
-00012630: 666f 7220 6469 7265 6374 6564 206e 6574  for directed net
-00012640: 776f 726b 732e 290a 0a20 2020 2020 2020  works.)..       
-00012650: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
-00012660: 2020 2020 2020 203e 3e3e 204e 6574 776f         >>> Netwo
-00012670: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-00012680: 6f72 6b28 292e 6e73 695f 6d61 785f 6e65  ork().nsi_max_ne
-00012690: 6967 6862 6f72 735f 6465 6772 6565 2829  ighbors_degree()
-000126a0: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
-000126b0: 7469 6e67 206e 2e73 2e69 2e20 6d61 7869  ting n.s.i. maxi
-000126c0: 6d75 6d20 6e65 6967 6862 6f75 7220 6465  mum neighbour de
-000126d0: 6772 6565 2e2e 2e0a 2020 2020 2020 2020  gree....        
-000126e0: 4361 6c63 756c 6174 696e 6720 6e2e 732e  Calculating n.s.
-000126f0: 692e 2064 6567 7265 652e 2e2e 0a20 2020  i. degree....   
-00012700: 2020 2020 2061 7272 6179 285b 2038 2e34       array([ 8.4
-00012710: 2c20 2038 2e20 2c20 2038 2e20 2c20 2038  ,  8. ,  8. ,  8
-00012720: 2e34 2c20 2038 2e34 2c20 2038 2e34 5d29  .4,  8.4,  8.4])
-00012730: 0a0a 2020 2020 2020 2020 6173 2063 6f6d  ..        as com
-00012740: 7061 7265 6420 746f 2074 6865 2075 6e77  pared to the unw
-00012750: 6569 6768 7465 6420 7665 7273 696f 6e3a  eighted version:
-00012760: 0a0a 2020 2020 2020 2020 3e3e 3e20 7072  ..        >>> pr
-00012770: 696e 7428 4e65 7477 6f72 6b2e 536d 616c  int(Network.Smal
-00012780: 6c54 6573 744e 6574 776f 726b 2829 2e6d  lTestNetwork().m
-00012790: 6178 5f6e 6569 6768 626f 7273 5f64 6567  ax_neighbors_deg
-000127a0: 7265 6528 2929 0a20 2020 2020 2020 2043  ree()).        C
-000127b0: 616c 6375 6c61 7469 6e67 206d 6178 696d  alculating maxim
-000127c0: 756d 206e 6569 6768 626f 7572 7327 2064  um neighbours' d
-000127d0: 6567 7265 652e 2e2e 0a20 2020 2020 2020  egree....       
-000127e0: 205b 3320 3320 3320 3320 3320 335d 0a0a   [3 3 3 3 3 3]..
-000127f0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-00012800: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
-00012810: 6e6f 6465 5d20 6f66 2066 6c6f 6174 7320  node] of floats 
-00012820: 3e3d 2030 0a20 2020 2020 2020 2022 2222  >= 0.        """
-00012830: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00012840: 2e64 6972 6563 7465 643a 0a20 2020 2020  .directed:.     
-00012850: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
-00012860: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
-00012870: 2822 4e6f 7420 696d 706c 656d 656e 7465  ("Not implemente
-00012880: 6420 666f 7220 6469 7265 6374 6564 206e  d for directed n
-00012890: 6574 776f 726b 732e 2229 0a0a 2020 2020  etworks.")..    
-000128a0: 2020 2020 7365 6c66 2e6e 7369 5f64 6567      self.nsi_deg
-000128b0: 7265 6528 290a 2020 2020 2020 2020 2320  ree().        # 
-000128c0: 6d61 7472 6978 2077 6974 6820 7468 6520  matrix with the 
-000128d0: 6465 6772 6565 7320 6f66 206e 6f64 6573  degrees of nodes
-000128e0: 2720 6e65 6967 6862 6f75 7273 2061 7320  ' neighbours as 
-000128f0: 726f 7773 0a20 2020 2020 2020 2072 6574  rows.        ret
-00012900: 7572 6e20 2873 656c 662e 7370 5f41 706c  urn (self.sp_Apl
-00012910: 7573 2829 202a 2073 656c 662e 7370 5f6e  us() * self.sp_n
-00012920: 7369 5f64 6961 675f 6b28 2929 2e6d 6178  si_diag_k()).max
-00012930: 2861 7869 733d 3129 2e54 2e41 5b30 5d0a  (axis=1).T.A[0].
-00012940: 0a20 2020 2023 0a20 2020 2023 2020 204d  .    #.    #   M
-00012950: 6561 7375 7265 7320 6f66 2063 6c75 7374  easures of clust
-00012960: 6572 696e 672c 2074 7261 6e73 6974 6976  ering, transitiv
-00012970: 6974 7920 616e 6420 636c 6971 7569 7368  ity and cliquish
-00012980: 6e65 7373 0a20 2020 2023 0a0a 2020 2020  ness.    #..    
-00012990: 4063 6163 6865 645f 636f 6e73 7428 2762  @cached_const('b
-000129a0: 6173 6527 2c20 276c 6f63 616c 2063 6c75  ase', 'local clu
-000129b0: 7374 6572 696e 6727 2c20 276c 6f63 616c  stering', 'local
-000129c0: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-000129d0: 6669 6369 656e 7473 2729 0a20 2020 2064  ficients').    d
-000129e0: 6566 206c 6f63 616c 5f63 6c75 7374 6572  ef local_cluster
-000129f0: 696e 6728 7365 6c66 293a 0a20 2020 2020  ing(self):.     
-00012a00: 2020 2022 2222 0a20 2020 2020 2020 2046     """.        F
-00012a10: 6f72 2065 6163 6820 6e6f 6465 2c20 7265  or each node, re
-00012a20: 7475 726e 2069 7473 2028 5761 7474 732d  turn its (Watts-
-00012a30: 5374 726f 6761 747a 2920 636c 7573 7465  Strogatz) cluste
-00012a40: 7269 6e67 2063 6f65 6666 6963 6965 6e74  ring coefficient
-00012a50: 2e0a 0a20 2020 2020 2020 2054 6869 7320  ...        This 
-00012a60: 6973 2074 6865 2070 726f 706f 7274 696f  is the proportio
-00012a70: 6e20 6f66 2061 6c6c 2070 6169 7273 206f  n of all pairs o
-00012a80: 6620 6974 7320 6e65 6967 6862 6f72 7320  f its neighbors 
-00012a90: 7768 6963 6820 6172 650a 2020 2020 2020  which are.      
-00012aa0: 2020 7468 656d 7365 6c76 6573 2069 6e74    themselves int
-00012ab0: 6572 6c69 6e6b 6564 2e0a 0a20 2020 2020  erlinked...     
-00012ac0: 2020 2028 5573 6573 2064 6972 6563 7469     (Uses directi
-00012ad0: 6f6e 616c 6974 7920 696e 666f 726d 6174  onality informat
-00012ae0: 696f 6e2c 2069 6620 6176 6169 6c61 626c  ion, if availabl
-00012af0: 6529 0a0a 2020 2020 2020 2020 2a2a 4578  e)..        **Ex
-00012b00: 616d 706c 653a 2a2a 0a0a 2020 2020 2020  ample:**..      
-00012b10: 2020 3e3e 3e20 7228 4e65 7477 6f72 6b2e    >>> r(Network.
+0000db40: 2020 2020 2076 616c 7565 733d 7661 6c75       values=valu
+0000db50: 6573 290a 2020 2020 2020 2020 656c 7365  es).        else
+0000db60: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+0000db70: 696e 7428 2245 7272 6f72 2120 5665 7274  int("Error! Vert
+0000db80: 6578 2061 7474 7269 6275 7465 2064 6174  ex attribute dat
+0000db90: 6120 6172 7261 7922 2c20 6174 7472 6962  a array", attrib
+0000dba0: 7574 655f 6e61 6d65 2c0a 2020 2020 2020  ute_name,.      
+0000dbb0: 2020 2020 2020 2020 2020 2020 2268 6173              "has
+0000dbc0: 2074 6f20 6861 7665 2074 6865 2073 616d   to have the sam
+0000dbd0: 6520 6c65 6e67 7468 2061 7320 7468 6520  e length as the 
+0000dbe0: 6e75 6d62 6572 206f 6620 6e6f 6465 7320  number of nodes 
+0000dbf0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000dc00: 2020 2020 2269 6e20 7468 6520 6772 6170      "in the grap
+0000dc10: 682e 2229 0a0a 2020 2020 6465 6620 6e6f  h.")..    def no
+0000dc20: 6465 5f61 7474 7269 6275 7465 2873 656c  de_attribute(sel
+0000dc30: 662c 2061 7474 7269 6275 7465 5f6e 616d  f, attribute_nam
+0000dc40: 653a 2073 7472 293a 0a20 2020 2020 2020  e: str):.       
+0000dc50: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
+0000dc60: 7572 6e20 6120 6e6f 6465 2061 7474 7269  urn a node attri
+0000dc70: 6275 7465 2e0a 0a20 2020 2020 2020 2045  bute...        E
+0000dc80: 7861 6d70 6c65 7320 666f 7220 6e6f 6465  xamples for node
+0000dc90: 2061 7474 7269 6275 7465 732f 7765 6967   attributes/weig
+0000dca0: 6874 7320 6172 6520 6465 6772 6565 206f  hts are degree o
+0000dcb0: 7220 6265 7477 6565 6e6e 6573 732e 0a0a  r betweenness...
+0000dcc0: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
+0000dcd0: 2061 7474 7269 6275 7465 5f6e 616d 653a   attribute_name:
+0000dce0: 2054 6865 206e 616d 6520 6f66 2074 6865   The name of the
+0000dcf0: 206e 6f64 6520 6174 7472 6962 7574 652e   node attribute.
+0000dd00: 0a0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
+0000dd10: 3a20 3144 204e 756d 7079 2061 7272 6179  : 1D Numpy array
+0000dd20: 205b 6e6f 6465 5d0a 2020 2020 2020 2020   [node].        
+0000dd30: 3a72 6574 7572 6e3a 2054 6865 206e 6f64  :return: The nod
+0000dd40: 6520 6174 7472 6962 7574 6520 7365 7175  e attribute sequ
+0000dd50: 656e 6365 2e0a 2020 2020 2020 2020 2222  ence..        ""
+0000dd60: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+0000dd70: 206e 702e 6172 7261 7928 7365 6c66 2e67   np.array(self.g
+0000dd80: 7261 7068 2e76 732e 6765 745f 6174 7472  raph.vs.get_attr
+0000dd90: 6962 7574 655f 7661 6c75 6573 2861 7474  ibute_values(att
+0000dda0: 7269 6275 7465 5f6e 616d 6529 290a 0a20  ribute_name)).. 
+0000ddb0: 2020 2064 6566 2064 656c 5f6e 6f64 655f     def del_node_
+0000ddc0: 6174 7472 6962 7574 6528 7365 6c66 2c20  attribute(self, 
+0000ddd0: 6174 7472 6962 7574 655f 6e61 6d65 3a20  attribute_name: 
+0000dde0: 7374 7229 3a0a 2020 2020 2020 2020 2222  str):.        ""
+0000ddf0: 220a 2020 2020 2020 2020 4465 6c65 7465  ".        Delete
+0000de00: 2061 206e 6f64 6520 6174 7472 6962 7574   a node attribut
+0000de10: 652e 0a0a 2020 2020 2020 2020 3a61 7267  e...        :arg
+0000de20: 2073 7472 2061 7474 7269 6275 7465 5f6e   str attribute_n
+0000de30: 616d 653a 204e 616d 6520 6f66 206e 6f64  ame: Name of nod
+0000de40: 6520 6174 7472 6962 7574 6520 746f 2062  e attribute to b
+0000de50: 6520 6465 6c65 7465 642e 0a20 2020 2020  e deleted..     
+0000de60: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+0000de70: 6620 6174 7472 6962 7574 655f 6e61 6d65  f attribute_name
+0000de80: 2069 6e20 7365 6c66 2e67 7261 7068 2e76   in self.graph.v
+0000de90: 732e 6174 7472 6962 7574 6573 2829 3a0a  s.attributes():.
+0000dea0: 2020 2020 2020 2020 2020 2020 6465 6c20              del 
+0000deb0: 7365 6c66 2e67 7261 7068 2e76 735b 6174  self.graph.vs[at
+0000dec0: 7472 6962 7574 655f 6e61 6d65 5d0a 0a20  tribute_name].. 
+0000ded0: 2020 2023 0a20 2020 2023 2020 4d65 7468     #.    #  Meth
+0000dee0: 6f64 7320 776f 726b 696e 6720 7769 7468  ods working with
+0000def0: 206c 696e 6b20 6174 7472 6962 7574 6573   link attributes
+0000df00: 0a20 2020 2023 0a0a 2020 2020 6465 6620  .    #..    def 
+0000df10: 6669 6e64 5f6c 696e 6b5f 6174 7472 6962  find_link_attrib
+0000df20: 7574 6528 7365 6c66 2c20 6174 7472 6962  ute(self, attrib
+0000df30: 7574 655f 6e61 6d65 3a20 7374 7229 3a0a  ute_name: str):.
+0000df40: 2020 2020 2020 2020 7265 7475 726e 2061          return a
+0000df50: 7474 7269 6275 7465 5f6e 616d 6520 696e  ttribute_name in
+0000df60: 2073 656c 662e 6772 6170 682e 6573 2e61   self.graph.es.a
+0000df70: 7474 7269 6275 7465 7328 290a 0a20 2020  ttributes()..   
+0000df80: 2064 6566 2061 7665 7261 6765 5f6c 696e   def average_lin
+0000df90: 6b5f 6174 7472 6962 7574 6528 7365 6c66  k_attribute(self
+0000dfa0: 2c20 6174 7472 6962 7574 655f 6e61 6d65  , attribute_name
+0000dfb0: 3a20 7374 7229 3a0a 2020 2020 2020 2020  : str):.        
+0000dfc0: 2222 220a 2020 2020 2020 2020 466f 7220  """.        For 
+0000dfd0: 6561 6368 206e 6f64 652c 2072 6574 7572  each node, retur
+0000dfe0: 6e20 7468 6520 6176 6572 6167 6520 6f66  n the average of
+0000dff0: 2061 206c 696e 6b20 6174 7472 6962 7574   a link attribut
+0000e000: 650a 2020 2020 2020 2020 6f76 6572 2061  e.        over a
+0000e010: 6c6c 206c 696e 6b73 206f 6620 7468 6174  ll links of that
+0000e020: 206e 6f64 652e 0a0a 2020 2020 2020 2020   node...        
+0000e030: 3a61 7267 2073 7472 2061 7474 7269 6275  :arg str attribu
+0000e040: 7465 5f6e 616d 653a 204e 616d 6520 6f66  te_name: Name of
+0000e050: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
+0000e060: 746f 2062 6520 7573 6564 2e0a 0a20 2020  to be used...   
+0000e070: 2020 2020 203a 7274 7970 653a 2031 6420       :rtype: 1d 
+0000e080: 6e75 6d70 7920 6172 7261 7920 5b6e 6f64  numpy array [nod
+0000e090: 655d 206f 6620 666c 6f61 7473 0a20 2020  e] of floats.   
+0000e0a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000e0b0: 2072 6574 7572 6e20 7365 6c66 2e6c 696e   return self.lin
+0000e0c0: 6b5f 6174 7472 6962 7574 6528 6174 7472  k_attribute(attr
+0000e0d0: 6962 7574 655f 6e61 6d65 292e 6d65 616e  ibute_name).mean
+0000e0e0: 2861 7869 733d 3129 0a0a 2020 2020 6465  (axis=1)..    de
+0000e0f0: 6620 6c69 6e6b 5f61 7474 7269 6275 7465  f link_attribute
+0000e100: 2873 656c 662c 2061 7474 7269 6275 7465  (self, attribute
+0000e110: 5f6e 616d 653a 2073 7472 293a 0a20 2020  _name: str):.   
+0000e120: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000e130: 2052 6574 7572 6e20 7468 6520 7661 6c75   Return the valu
+0000e140: 6573 206f 6620 6120 6c69 6e6b 2061 7474  es of a link att
+0000e150: 7269 6275 7465 2e0a 0a20 2020 2020 2020  ribute...       
+0000e160: 203a 6172 6720 7374 7220 6174 7472 6962   :arg str attrib
+0000e170: 7574 655f 6e61 6d65 3a20 4e61 6d65 206f  ute_name: Name o
+0000e180: 6620 6c69 6e6b 2061 7474 7269 6275 7465  f link attribute
+0000e190: 2074 6f20 6265 2075 7365 642e 0a0a 2020   to be used...  
+0000e1a0: 2020 2020 2020 3a72 7479 7065 3a20 2073        :rtype:  s
+0000e1b0: 7175 6172 6520 6e75 6d70 7920 6172 7261  quare numpy arra
+0000e1c0: 7920 5b6e 6f64 652c 6e6f 6465 5d0a 2020  y [node,node].  
+0000e1d0: 2020 2020 2020 3a72 6574 7572 6e3a 2045        :return: E
+0000e1e0: 6e74 7279 205b 692c 6a5d 2069 7320 7468  ntry [i,j] is th
+0000e1f0: 6520 6174 7472 6962 7574 6520 6f66 2074  e attribute of t
+0000e200: 6865 206c 696e 6b20 6672 6f6d 2069 2074  he link from i t
+0000e210: 6f20 6a2e 0a20 2020 2020 2020 2022 2222  o j..        """
+0000e220: 0a20 2020 2020 2020 2023 2020 496e 6974  .        #  Init
+0000e230: 6961 6c69 7a65 2077 6569 6768 7473 2061  ialize weights a
+0000e240: 7272 6179 0a20 2020 2020 2020 2077 6569  rray.        wei
+0000e250: 6768 7473 203d 206e 702e 7a65 726f 7328  ghts = np.zeros(
+0000e260: 2873 656c 662e 4e2c 2073 656c 662e 4e29  (self.N, self.N)
+0000e270: 290a 0a20 2020 2020 2020 2069 6620 7365  )..        if se
+0000e280: 6c66 2e64 6972 6563 7465 643a 0a20 2020  lf.directed:.   
+0000e290: 2020 2020 2020 2020 2066 6f72 2065 2069           for e i
+0000e2a0: 6e20 7365 6c66 2e67 7261 7068 2e65 733a  n self.graph.es:
+0000e2b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e2c0: 2077 6569 6768 7473 5b65 2e74 7570 6c65   weights[e.tuple
+0000e2d0: 5d20 3d20 655b 6174 7472 6962 7574 655f  ] = e[attribute_
+0000e2e0: 6e61 6d65 5d0a 2020 2020 2020 2020 2320  name].        # 
+0000e2f0: 2053 796d 6d65 7472 697a 6520 6966 2067   Symmetrize if g
+0000e300: 7261 7068 2069 7320 756e 6469 7265 6374  raph is undirect
+0000e310: 6564 0a20 2020 2020 2020 2065 6c73 653a  ed.        else:
+0000e320: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+0000e330: 2065 2069 6e20 7365 6c66 2e67 7261 7068   e in self.graph
+0000e340: 2e65 733a 0a20 2020 2020 2020 2020 2020  .es:.           
+0000e350: 2020 2020 2077 6569 6768 7473 5b65 2e74       weights[e.t
+0000e360: 7570 6c65 5d20 3d20 655b 6174 7472 6962  uple] = e[attrib
+0000e370: 7574 655f 6e61 6d65 5d0a 2020 2020 2020  ute_name].      
+0000e380: 2020 2020 2020 2020 2020 7765 6967 6874            weight
+0000e390: 735b 652e 7475 706c 655b 315d 2c20 652e  s[e.tuple[1], e.
+0000e3a0: 7475 706c 655b 305d 5d20 3d20 655b 6174  tuple[0]] = e[at
+0000e3b0: 7472 6962 7574 655f 6e61 6d65 5d0a 2020  tribute_name].  
+0000e3c0: 2020 2020 2020 7265 7475 726e 2077 6569        return wei
+0000e3d0: 6768 7473 0a0a 2020 2020 6465 6620 6465  ghts..    def de
+0000e3e0: 6c5f 6c69 6e6b 5f61 7474 7269 6275 7465  l_link_attribute
+0000e3f0: 2873 656c 662c 2061 7474 7269 6275 7465  (self, attribute
+0000e400: 5f6e 616d 653a 2073 7472 293a 0a20 2020  _name: str):.   
+0000e410: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000e420: 2044 656c 6574 6520 6120 6c69 6e6b 2061   Delete a link a
+0000e430: 7474 7269 6275 7465 2e0a 0a20 2020 2020  ttribute...     
+0000e440: 2020 203a 6172 6720 7374 7220 6174 7472     :arg str attr
+0000e450: 6962 7574 655f 6e61 6d65 3a20 6e61 6d65  ibute_name: name
+0000e460: 206f 6620 6c69 6e6b 2061 7474 7269 6275   of link attribu
+0000e470: 7465 2074 6f20 6265 2064 656c 6574 6564  te to be deleted
+0000e480: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000e490: 2020 2020 2069 6620 7365 6c66 2e66 696e       if self.fin
+0000e4a0: 645f 6c69 6e6b 5f61 7474 7269 6275 7465  d_link_attribute
+0000e4b0: 2861 7474 7269 6275 7465 5f6e 616d 6529  (attribute_name)
+0000e4c0: 3a0a 2020 2020 2020 2020 2020 2020 6465  :.            de
+0000e4d0: 6c20 7365 6c66 2e67 7261 7068 2e65 735b  l self.graph.es[
+0000e4e0: 6174 7472 6962 7574 655f 6e61 6d65 5d0a  attribute_name].
+0000e4f0: 2020 2020 2020 2020 2020 2020 2320 696e              # in
+0000e500: 7661 6c69 6461 7465 2063 6163 6865 0a20  validate cache. 
+0000e510: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000e520: 5f6d 7574 5f6c 6120 2b3d 2031 0a0a 2020  _mut_la += 1..  
+0000e530: 2020 6465 6620 7365 745f 6c69 6e6b 5f61    def set_link_a
+0000e540: 7474 7269 6275 7465 2873 656c 662c 2061  ttribute(self, a
+0000e550: 7474 7269 6275 7465 5f6e 616d 652c 2076  ttribute_name, v
+0000e560: 616c 7565 7329 3a0a 2020 2020 2020 2020  alues):.        
+0000e570: 2222 220a 2020 2020 2020 2020 5365 7420  """.        Set 
+0000e580: 7468 6520 7661 6c75 6573 206f 6620 736f  the values of so
+0000e590: 6d65 206c 696e 6b20 6174 7472 6962 7574  me link attribut
+0000e5a0: 652e 0a0a 2020 2020 2020 2020 5468 6573  e...        Thes
+0000e5b0: 6520 6361 6e20 6265 2075 7365 6420 6173  e can be used as
+0000e5c0: 2077 6569 6768 7473 2069 6e20 6d65 6173   weights in meas
+0000e5d0: 7572 6573 2072 6571 7569 7269 6e67 206c  ures requiring l
+0000e5e0: 696e 6b20 7765 6967 6874 732e 0a0a 2020  ink weights...  
+0000e5f0: 2020 2020 2020 2e2e 206e 6f74 653a 3a0a        .. note::.
+0000e600: 2020 2020 2020 2020 2020 2054 6865 2061             The a
+0000e610: 7474 7269 6275 7465 2f77 6569 6768 7420  ttribute/weight 
+0000e620: 6d61 7472 6978 2073 686f 756c 6420 6265  matrix should be
+0000e630: 2073 796d 6d65 7472 6963 2066 6f72 2075   symmetric for u
+0000e640: 6e64 6972 6563 7465 640a 2020 2020 2020  ndirected.      
+0000e650: 2020 2020 206e 6574 776f 726b 732e 0a0a       networks...
+0000e660: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
+0000e670: 2061 7474 7269 6275 7465 5f6e 616d 653a   attribute_name:
+0000e680: 206e 616d 6520 6f66 206c 696e 6b20 6174   name of link at
+0000e690: 7472 6962 7574 6520 746f 2062 6520 7365  tribute to be se
+0000e6a0: 740a 0a20 2020 2020 2020 203a 7479 7065  t..        :type
+0000e6b0: 2076 616c 7565 733a 2073 7175 6172 6520   values: square 
+0000e6c0: 6e75 6d70 7920 6172 7261 7920 5b6e 6f64  numpy array [nod
+0000e6d0: 652c 6e6f 6465 5d0a 2020 2020 2020 2020  e,node].        
+0000e6e0: 3a61 7267 2020 7661 6c75 6573 3a20 456e  :arg  values: En
+0000e6f0: 7472 7920 5b69 2c6a 5d20 6973 2074 6865  try [i,j] is the
+0000e700: 2061 7474 7269 6275 7465 206f 6620 7468   attribute of th
+0000e710: 6520 6c69 6e6b 2066 726f 6d20 6920 746f  e link from i to
+0000e720: 206a 2e0a 2020 2020 2020 2020 2222 220a   j..        """.
+0000e730: 2020 2020 2020 2020 666f 7220 6520 696e          for e in
+0000e740: 2073 656c 662e 6772 6170 682e 6573 3a0a   self.graph.es:.
+0000e750: 2020 2020 2020 2020 2020 2020 655b 6174              e[at
+0000e760: 7472 6962 7574 655f 6e61 6d65 5d20 3d20  tribute_name] = 
+0000e770: 7661 6c75 6573 5b65 2e74 7570 6c65 5d0a  values[e.tuple].
+0000e780: 2020 2020 2020 2020 2320 696e 7661 6c69          # invali
+0000e790: 6461 7465 2063 6163 6865 0a20 2020 2020  date cache.     
+0000e7a0: 2020 2073 656c 662e 5f6d 7574 5f6c 6120     self._mut_la 
+0000e7b0: 2b3d 2031 0a0a 2020 2020 230a 2020 2020  += 1..    #.    
+0000e7c0: 2320 2044 6567 7265 6520 7265 6c61 7465  #  Degree relate
+0000e7d0: 6420 6d65 6173 7572 6573 0a20 2020 2023  d measures.    #
+0000e7e0: 0a0a 2020 2020 4043 6163 6865 642e 6d65  ..    @Cached.me
+0000e7f0: 7468 6f64 2829 0a20 2020 2064 6566 2064  thod().    def d
+0000e800: 6567 7265 6528 7365 6c66 2c20 6b65 793d  egree(self, key=
+0000e810: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
+0000e820: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
+0000e830: 6e20 6c69 7374 206f 6620 6465 6772 6565  n list of degree
+0000e840: 732e 0a0a 2020 2020 2020 2020 4966 2061  s...        If a
+0000e850: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
+0000e860: 6b65 7920 6973 2073 7065 6369 6669 6564  key is specified
+0000e870: 2c20 7265 7475 726e 2074 6865 2061 7373  , return the ass
+0000e880: 6f63 6961 7465 6420 7374 7265 6e67 7468  ociated strength
+0000e890: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+0000e8a0: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+0000e8b0: 203e 3e3e 204e 6574 776f 726b 2e53 6d61   >>> Network.Sma
+0000e8c0: 6c6c 5465 7374 4e65 7477 6f72 6b28 292e  llTestNetwork().
+0000e8d0: 6465 6772 6565 2829 0a20 2020 2020 2020  degree().       
+0000e8e0: 2061 7272 6179 285b 332c 2033 2c20 322c   array([3, 3, 2,
+0000e8f0: 2032 2c20 332c 2031 5d29 0a0a 2020 2020   2, 3, 1])..    
+0000e900: 2020 2020 3a61 7267 2073 7472 206b 6579      :arg str key
+0000e910: 3a20 6c69 6e6b 2061 7474 7269 6275 7465  : link attribute
+0000e920: 206b 6579 205b 6f70 7469 6f6e 616c 5d0a   key [optional].
+0000e930: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+0000e940: 6172 7261 7928 5b69 6e74 3e3d 305d 290a  array([int>=0]).
+0000e950: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000e960: 2020 2020 6966 2073 656c 662e 6469 7265      if self.dire
+0000e970: 6374 6564 3a0a 2020 2020 2020 2020 2020  cted:.          
+0000e980: 2020 7265 7475 726e 2073 656c 662e 696e    return self.in
+0000e990: 6465 6772 6565 286b 6579 2920 2b20 7365  degree(key) + se
+0000e9a0: 6c66 2e6f 7574 6465 6772 6565 286b 6579  lf.outdegree(key
+0000e9b0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0000e9c0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000e9d0: 726e 2073 656c 662e 6f75 7464 6567 7265  rn self.outdegre
+0000e9e0: 6528 6b65 7929 0a0a 2020 2020 4043 6163  e(key)..    @Cac
+0000e9f0: 6865 642e 6d65 7468 6f64 2861 7474 7273  hed.method(attrs
+0000ea00: 3d28 225f 6d75 745f 6c61 222c 2929 0a20  =("_mut_la",)). 
+0000ea10: 2020 2064 6566 2069 6e64 6567 7265 6528     def indegree(
+0000ea20: 7365 6c66 2c20 6b65 793d 4e6f 6e65 293a  self, key=None):
+0000ea30: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000ea40: 2020 2020 2052 6574 7572 6e20 6c69 7374       Return list
+0000ea50: 206f 6620 696e 2d64 6567 7265 6573 2e0a   of in-degrees..
+0000ea60: 0a20 2020 2020 2020 2049 6620 6120 6c69  .        If a li
+0000ea70: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
+0000ea80: 2069 7320 7370 6563 6966 6965 642c 2072   is specified, r
+0000ea90: 6574 7572 6e20 7468 6520 6173 736f 6369  eturn the associ
+0000eaa0: 6174 6564 0a20 2020 2020 2020 2069 6e2d  ated.        in-
+0000eab0: 7374 7265 6e67 7468 2e0a 0a20 2020 2020  strength...     
+0000eac0: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
+0000ead0: 0a20 2020 2020 2020 203e 3e3e 204e 6574  .        >>> Net
+0000eae0: 776f 726b 2e53 6d61 6c6c 4469 7265 6374  work.SmallDirect
+0000eaf0: 6564 5465 7374 4e65 7477 6f72 6b28 292e  edTestNetwork().
+0000eb00: 696e 6465 6772 6565 2829 0a20 2020 2020  indegree().     
+0000eb10: 2020 2061 7272 6179 285b 322c 2032 2c20     array([2, 2, 
+0000eb20: 322c 2031 2c20 312c 2030 5d29 0a0a 2020  2, 1, 1, 0])..  
+0000eb30: 2020 2020 2020 3a61 7267 2073 7472 206b        :arg str k
+0000eb40: 6579 3a20 6c69 6e6b 2061 7474 7269 6275  ey: link attribu
+0000eb50: 7465 206b 6579 205b 6f70 7469 6f6e 616c  te key [optional
+0000eb60: 5d0a 2020 2020 2020 2020 3a72 7479 7065  ].        :rtype
+0000eb70: 3a20 6172 7261 7928 5b69 6e74 3e3d 305d  : array([int>=0]
+0000eb80: 290a 2020 2020 2020 2020 2222 220a 2020  ).        """.  
+0000eb90: 2020 2020 2020 6966 206b 6579 2069 7320        if key is 
+0000eba0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000ebb0: 2020 7265 7475 726e 2073 656c 662e 7370    return self.sp
+0000ebc0: 5f41 2e73 756d 2861 7869 733d 3029 2e41  _A.sum(axis=0).A
+0000ebd0: 2e73 7175 6565 7a65 2829 2e61 7374 7970  .squeeze().astyp
+0000ebe0: 6528 696e 7429 0a20 2020 2020 2020 2065  e(int).        e
+0000ebf0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000ec00: 2072 6574 7572 6e20 7365 6c66 2e6c 696e   return self.lin
+0000ec10: 6b5f 6174 7472 6962 7574 6528 6b65 7929  k_attribute(key)
+0000ec20: 2e73 756d 2861 7869 733d 3029 2e54 0a0a  .sum(axis=0).T..
+0000ec30: 2020 2020 4043 6163 6865 642e 6d65 7468      @Cached.meth
+0000ec40: 6f64 2861 7474 7273 3d28 225f 6d75 745f  od(attrs=("_mut_
+0000ec50: 6c61 222c 2929 0a20 2020 2064 6566 206f  la",)).    def o
+0000ec60: 7574 6465 6772 6565 2873 656c 662c 206b  utdegree(self, k
+0000ec70: 6579 3d4e 6f6e 6529 3a0a 2020 2020 2020  ey=None):.      
+0000ec80: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+0000ec90: 7475 726e 206c 6973 7420 6f66 206f 7574  turn list of out
+0000eca0: 2d64 6567 7265 6573 2e0a 0a20 2020 2020  -degrees...     
+0000ecb0: 2020 2049 6620 6120 6c69 6e6b 2061 7474     If a link att
+0000ecc0: 7269 6275 7465 206b 6579 2069 7320 7370  ribute key is sp
+0000ecd0: 6563 6966 6965 642c 2072 6574 7572 6e20  ecified, return 
+0000ece0: 7468 6520 6173 736f 6369 6174 6564 0a20  the associated. 
+0000ecf0: 2020 2020 2020 206f 7574 2d73 7472 656e         out-stren
+0000ed00: 6774 682e 0a0a 2020 2020 2020 2020 2a2a  gth...        **
+0000ed10: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
+0000ed20: 2020 2020 3e3e 3e20 4e65 7477 6f72 6b2e      >>> Network.
+0000ed30: 536d 616c 6c44 6972 6563 7465 6454 6573  SmallDirectedTes
+0000ed40: 744e 6574 776f 726b 2829 2e6f 7574 6465  tNetwork().outde
+0000ed50: 6772 6565 2829 0a20 2020 2020 2020 2061  gree().        a
+0000ed60: 7272 6179 285b 322c 2032 2c20 302c 2031  rray([2, 2, 0, 1
+0000ed70: 2c20 322c 2031 5d29 0a0a 2020 2020 2020  , 2, 1])..      
+0000ed80: 2020 3a61 7267 2073 7472 206b 6579 3a20    :arg str key: 
+0000ed90: 6c69 6e6b 2061 7474 7269 6275 7465 206b  link attribute k
+0000eda0: 6579 205b 6f70 7469 6f6e 616c 5d0a 2020  ey [optional].  
+0000edb0: 2020 2020 2020 3a72 7479 7065 3a20 6172        :rtype: ar
+0000edc0: 7261 7928 5b69 6e74 3e3d 305d 290a 2020  ray([int>=0]).  
+0000edd0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000ede0: 2020 6966 206b 6579 2069 7320 4e6f 6e65    if key is None
+0000edf0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000ee00: 7475 726e 2073 656c 662e 7370 5f41 2e73  turn self.sp_A.s
+0000ee10: 756d 2861 7869 733d 3129 2e54 2e41 2e73  um(axis=1).T.A.s
+0000ee20: 7175 6565 7a65 2829 2e61 7374 7970 6528  queeze().astype(
+0000ee30: 696e 7429 0a20 2020 2020 2020 2065 6c73  int).        els
+0000ee40: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0000ee50: 6574 7572 6e20 7365 6c66 2e6c 696e 6b5f  eturn self.link_
+0000ee60: 6174 7472 6962 7574 6528 6b65 7929 2e73  attribute(key).s
+0000ee70: 756d 2861 7869 733d 3129 2e54 0a0a 2020  um(axis=1).T..  
+0000ee80: 2020 4043 6163 6865 642e 6d65 7468 6f64    @Cached.method
+0000ee90: 2861 7474 7273 3d28 225f 6d75 745f 6c61  (attrs=("_mut_la
+0000eea0: 222c 2929 0a20 2020 2064 6566 2062 696c  ",)).    def bil
+0000eeb0: 6465 6772 6565 2873 656c 662c 206b 6579  degree(self, key
+0000eec0: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
+0000eed0: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
+0000eee0: 726e 206c 6973 7420 6f66 2062 696c 6174  rn list of bilat
+0000eef0: 6572 616c 2064 6567 7265 6573 2c20 692e  eral degrees, i.
+0000ef00: 652e 2074 6865 206e 756d 6265 7220 6f66  e. the number of
+0000ef10: 2073 696d 756c 7461 6e65 6f75 736c 7920   simultaneously 
+0000ef20: 696e 2d0a 2020 2020 2020 2020 616e 6420  in-.        and 
+0000ef30: 6f75 742d 676f 696e 6720 6564 6765 732e  out-going edges.
+0000ef40: 0a0a 2020 2020 2020 2020 4966 2061 206c  ..        If a l
+0000ef50: 696e 6b20 6174 7472 6962 7574 6520 6b65  ink attribute ke
+0000ef60: 7920 6973 2073 7065 6369 6669 6564 2c20  y is specified, 
+0000ef70: 7265 7475 726e 2074 6865 2061 7373 6f63  return the assoc
+0000ef80: 6961 7465 6420 6269 6c61 7465 7261 6c0a  iated bilateral.
+0000ef90: 2020 2020 2020 2020 7374 7265 6e67 7468          strength
+0000efa0: 2e0a 0a20 2020 2020 2020 202a 2a45 786d  ...        **Exm
+0000efb0: 6170 6c65 3a2a 2a0a 0a20 2020 2020 2020  aple:**..       
+0000efc0: 203e 3e3e 204e 6574 776f 726b 2e53 6d61   >>> Network.Sma
+0000efd0: 6c6c 4469 7265 6374 6564 5465 7374 4e65  llDirectedTestNe
+0000efe0: 7477 6f72 6b28 292e 6269 6c64 6567 7265  twork().bildegre
+0000eff0: 6528 290a 2020 2020 2020 2020 6172 7261  e().        arra
+0000f000: 7928 5b30 2c20 302c 2030 2c20 302c 2030  y([0, 0, 0, 0, 0
+0000f010: 2c20 305d 2c20 6474 7970 653d 696e 7431  , 0], dtype=int1
+0000f020: 3629 0a20 2020 2020 2020 203e 3e3e 206e  6).        >>> n
+0000f030: 6574 203d 204e 6574 776f 726b 2e53 6d61  et = Network.Sma
+0000f040: 6c6c 5465 7374 4e65 7477 6f72 6b28 290a  llTestNetwork().
+0000f050: 2020 2020 2020 2020 3e3e 3e20 286e 6574          >>> (net
+0000f060: 2e62 696c 6465 6772 6565 2829 203d 3d20  .bildegree() == 
+0000f070: 6e65 742e 6465 6772 6565 2829 292e 616c  net.degree()).al
+0000f080: 6c28 290a 2020 2020 2020 2020 5472 7565  l().        True
+0000f090: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000f0a0: 2020 2020 2069 6620 6b65 7920 6973 204e       if key is N
+0000f0b0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0000f0c0: 2072 6574 7572 6e20 2873 656c 662e 7370   return (self.sp
+0000f0d0: 5f41 202a 2073 656c 662e 7370 5f41 292e  _A * self.sp_A).
+0000f0e0: 6469 6167 6f6e 616c 2829 0a20 2020 2020  diagonal().     
+0000f0f0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000f100: 2020 2020 2077 203d 2073 656c 662e 6c69       w = self.li
+0000f110: 6e6b 5f61 7474 7269 6275 7465 286b 6579  nk_attribute(key
+0000f120: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0000f130: 7475 726e 2028 7720 4020 7729 2e64 6961  turn (w @ w).dia
+0000f140: 676f 6e61 6c28 290a 0a20 2020 2064 6566  gonal()..    def
+0000f150: 2073 705f 6e73 695f 6469 6167 5f6b 2873   sp_nsi_diag_k(s
+0000f160: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+0000f170: 2253 7061 7273 6520 6469 6167 6f6e 616c  "Sparse diagonal
+0000f180: 206d 6174 7269 7820 6f66 206e 2e73 2e69   matrix of n.s.i
+0000f190: 2e20 6465 6772 6565 7322 2222 0a20 2020  . degrees""".   
+0000f1a0: 2020 2020 2072 6574 7572 6e20 7370 2e64       return sp.d
+0000f1b0: 6961 6773 285b 7365 6c66 2e6e 7369 5f64  iags([self.nsi_d
+0000f1c0: 6567 7265 6528 295d 2c20 5b30 5d2c 0a20  egree()], [0],. 
+0000f1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f1e0: 2020 2020 2020 2073 6861 7065 3d28 7365         shape=(se
+0000f1f0: 6c66 2e4e 2c20 7365 6c66 2e4e 292c 2066  lf.N, self.N), f
+0000f200: 6f72 6d61 743d 2763 7363 2729 0a0a 2020  ormat='csc')..  
+0000f210: 2020 6465 6620 7370 5f6e 7369 5f64 6961    def sp_nsi_dia
+0000f220: 675f 6b5f 696e 7628 7365 6c66 293a 0a20  g_k_inv(self):. 
+0000f230: 2020 2020 2020 2022 2222 5370 6172 7365         """Sparse
+0000f240: 2064 6961 676f 6e61 6c20 6d61 7472 6978   diagonal matrix
+0000f250: 206f 6620 696e 7665 7273 6520 6e2e 732e   of inverse n.s.
+0000f260: 692e 2064 6567 7265 6573 2222 220a 2020  i. degrees""".  
+0000f270: 2020 2020 2020 7265 7475 726e 2073 702e        return sp.
+0000f280: 6469 6167 7328 5b6e 702e 706f 7765 7228  diags([np.power(
+0000f290: 7365 6c66 2e6e 7369 5f64 6567 7265 6528  self.nsi_degree(
+0000f2a0: 292c 202d 3129 5d2c 205b 305d 2c0a 2020  ), -1)], [0],.  
+0000f2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f2c0: 2020 2020 2020 7368 6170 653d 2873 656c        shape=(sel
+0000f2d0: 662e 4e2c 2073 656c 662e 4e29 2c20 666f  f.N, self.N), fo
+0000f2e0: 726d 6174 3d27 6373 6327 290a 0a20 2020  rmat='csc')..   
+0000f2f0: 2040 4361 6368 6564 2e6d 6574 686f 6428   @Cached.method(
+0000f300: 6174 7472 733d 2822 5f6d 7574 5f6e 7722  attrs=("_mut_nw"
+0000f310: 2c20 225f 6d75 745f 6c61 2229 290a 2020  , "_mut_la")).  
+0000f320: 2020 6465 6620 6e73 695f 6465 6772 6565    def nsi_degree
+0000f330: 2873 656c 662c 206b 6579 3d4e 6f6e 652c  (self, key=None,
+0000f340: 2074 7970 6963 616c 5f77 6569 6768 743d   typical_weight=
+0000f350: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
+0000f360: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
+0000f370: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
+0000f380: 2069 7473 2075 6e63 6f72 7265 6374 6564   its uncorrected
+0000f390: 206f 7220 636f 7272 6563 7465 6420 6e2e   or corrected n.
+0000f3a0: 732e 692e 2064 6567 7265 652e 0a0a 2020  s.i. degree...  
+0000f3b0: 2020 2020 2020 4966 2061 206c 696e 6b20        If a link 
+0000f3c0: 6174 7472 6962 7574 6520 6b65 7920 6973  attribute key is
+0000f3d0: 2073 7065 6369 6669 6564 2c20 7265 7475   specified, retu
+0000f3e0: 726e 2074 6865 2061 7373 6f63 6961 7465  rn the associate
+0000f3f0: 6420 6e2e 732e 692e 0a20 2020 2020 2020  d n.s.i..       
+0000f400: 2073 7472 656e 6774 682e 0a0a 2020 2020   strength...    
+0000f410: 2020 2020 2a2a 4578 616d 706c 6573 3a2a      **Examples:*
+0000f420: 2a0a 0a20 2020 2020 2020 203e 3e3e 206e  *..        >>> n
+0000f430: 6574 203d 204e 6574 776f 726b 2e53 6d61  et = Network.Sma
+0000f440: 6c6c 5465 7374 4e65 7477 6f72 6b28 290a  llTestNetwork().
+0000f450: 2020 2020 2020 2020 3e3e 3e20 6e65 742e          >>> net.
+0000f460: 6e73 695f 6465 6772 6565 2829 0a20 2020  nsi_degree().   
+0000f470: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+0000f480: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
+0000f490: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+0000f4a0: 5b20 382e 342c 2020 382e 202c 2020 352e  [ 8.4,  8. ,  5.
+0000f4b0: 392c 2020 352e 332c 2020 372e 342c 2020  9,  5.3,  7.4,  
+0000f4c0: 342e 205d 290a 2020 2020 2020 2020 3e3e  4. ]).        >>
+0000f4d0: 3e20 6e65 742e 7370 6c69 7474 6564 5f63  > net.splitted_c
+0000f4e0: 6f70 7928 292e 6e73 695f 6465 6772 6565  opy().nsi_degree
+0000f4f0: 2829 0a20 2020 2020 2020 2043 616c 6375  ().        Calcu
+0000f500: 6c61 7469 6e67 206e 2e73 2e69 2e20 6465  lating n.s.i. de
+0000f510: 6772 6565 2e2e 2e0a 2020 2020 2020 2020  gree....        
+0000f520: 6172 7261 7928 5b20 382e 342c 2020 382e  array([ 8.4,  8.
+0000f530: 202c 2020 352e 392c 2020 352e 332c 2020   ,  5.9,  5.3,  
+0000f540: 372e 342c 2020 342e 202c 2020 342e 205d  7.4,  4. ,  4. ]
+0000f550: 290a 2020 2020 2020 2020 3e3e 3e20 6e65  ).        >>> ne
+0000f560: 742e 6e73 695f 6465 6772 6565 2874 7970  t.nsi_degree(typ
+0000f570: 6963 616c 5f77 6569 6768 743d 322e 3029  ical_weight=2.0)
+0000f580: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+0000f590: 2033 2e32 202c 2020 332e 2020 2c20 2031   3.2 ,  3.  ,  1
+0000f5a0: 2e39 352c 2020 312e 3635 2c20 2032 2e37  .95,  1.65,  2.7
+0000f5b0: 202c 2020 312e 2020 5d29 0a20 2020 2020   ,  1.  ]).     
+0000f5c0: 2020 203e 3e3e 206e 6574 2e73 706c 6974     >>> net.split
+0000f5d0: 7465 645f 636f 7079 2829 2e6e 7369 5f64  ted_copy().nsi_d
+0000f5e0: 6567 7265 6528 7479 7069 6361 6c5f 7765  egree(typical_we
+0000f5f0: 6967 6874 3d32 2e30 290a 2020 2020 2020  ight=2.0).      
+0000f600: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
+0000f610: 732e 692e 2064 6567 7265 652e 2e2e 0a20  s.i. degree.... 
+0000f620: 2020 2020 2020 2061 7272 6179 285b 2033         array([ 3
+0000f630: 2e32 202c 2020 332e 2020 2c20 2031 2e39  .2 ,  3.  ,  1.9
+0000f640: 352c 2020 312e 3635 2c20 2032 2e37 202c  5,  1.65,  2.7 ,
+0000f650: 2020 312e 2020 2c20 2031 2e20 205d 290a    1.  ,  1.  ]).
+0000f660: 0a20 2020 2020 2020 2061 7320 636f 6d70  .        as comp
+0000f670: 6172 6564 2074 6f20 7468 6520 756e 7765  ared to the unwe
+0000f680: 6967 6874 6564 2076 6572 7369 6f6e 3a0a  ighted version:.
+0000f690: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
+0000f6a0: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
+0000f6b0: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
+0000f6c0: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
+0000f6d0: 6465 6772 6565 2829 290a 2020 2020 2020  degree()).      
+0000f6e0: 2020 6172 7261 7928 5b33 2c20 332c 2032    array([3, 3, 2
+0000f6f0: 2c20 322c 2033 2c20 315d 290a 2020 2020  , 2, 3, 1]).    
+0000f700: 2020 2020 3e3e 3e20 7228 6e65 742e 7370      >>> r(net.sp
+0000f710: 6c69 7474 6564 5f63 6f70 7928 292e 6465  litted_copy().de
+0000f720: 6772 6565 2829 290a 2020 2020 2020 2020  gree()).        
+0000f730: 6172 7261 7928 5b34 2c20 332c 2032 2c20  array([4, 3, 2, 
+0000f740: 322c 2033 2c20 322c 2032 5d29 0a0a 2020  2, 3, 2, 2])..  
+0000f750: 2020 2020 2020 3a61 7267 2073 7472 206b        :arg str k
+0000f760: 6579 3a20 6c69 6e6b 2061 7474 7269 6275  ey: link attribu
+0000f770: 7465 206b 6579 2028 6f70 7469 6f6e 616c  te key (optional
+0000f780: 290a 2020 2020 2020 2020 3a74 7970 6520  ).        :type 
+0000f790: 7479 7069 6361 6c5f 7765 6967 6874 3a20  typical_weight: 
+0000f7a0: 666c 6f61 7420 3e20 300a 2020 2020 2020  float > 0.      
+0000f7b0: 2020 3a61 7267 2066 6c6f 6174 2074 7970    :arg float typ
+0000f7c0: 6963 616c 5f77 6569 6768 743a 204f 7074  ical_weight: Opt
+0000f7d0: 696f 6e61 6c20 7479 7069 6361 6c20 6e6f  ional typical no
+0000f7e0: 6465 2077 6569 6768 7420 746f 2062 6520  de weight to be 
+0000f7f0: 7573 6564 2066 6f72 0a20 2020 2020 2020  used for.       
+0000f800: 2020 2020 2063 6f72 7265 6374 696f 6e2e       correction.
+0000f810: 2049 6620 4e6f 6e65 2c20 7468 6520 756e   If None, the un
+0000f820: 636f 7272 6563 7465 6420 6d65 6173 7572  corrected measur
+0000f830: 6520 6973 0a20 2020 2020 2020 2020 2020  e is.           
+0000f840: 2072 6574 7572 6e65 642e 2028 4465 6661   returned. (Defa
+0000f850: 756c 743a 204e 6f6e 6529 0a0a 2020 2020  ult: None)..    
+0000f860: 2020 2020 3a72 7479 7065 3a20 6172 7261      :rtype: arra
+0000f870: 7928 5b66 6c6f 6174 5d29 0a20 2020 2020  y([float]).     
+0000f880: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+0000f890: 6620 7365 6c66 2e64 6972 6563 7465 643a  f self.directed:
+0000f8a0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+0000f8b0: 203d 2073 656c 662e 6e73 695f 696e 6465   = self.nsi_inde
+0000f8c0: 6772 6565 286b 6579 2920 2b20 7365 6c66  gree(key) + self
+0000f8d0: 2e6e 7369 5f6f 7574 6465 6772 6565 286b  .nsi_outdegree(k
+0000f8e0: 6579 290a 2020 2020 2020 2020 656c 7365  ey).        else
+0000f8f0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000f900: 206b 6579 2069 7320 4e6f 6e65 3a0a 2020   key is None:.  
+0000f910: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0000f920: 7320 3d20 7365 6c66 2e73 705f 4170 6c75  s = self.sp_Aplu
+0000f930: 7328 2920 2a20 7365 6c66 2e6e 6f64 655f  s() * self.node_
+0000f940: 7765 6967 6874 730a 2020 2020 2020 2020  weights.        
+0000f950: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000f960: 2020 2020 2020 2020 2020 7720 3d20 7365            w = se
+0000f970: 6c66 2e6c 696e 6b5f 6174 7472 6962 7574  lf.link_attribut
+0000f980: 6528 6b65 7929 0a20 2020 2020 2020 2020  e(key).         
+0000f990: 2020 2020 2020 2072 6573 203d 2028 7365         res = (se
+0000f9a0: 6c66 2e6e 6f64 655f 7765 6967 6874 7320  lf.node_weights 
+0000f9b0: 4020 7729 2e73 7175 6565 7a65 2829 0a0a  @ w).squeeze()..
+0000f9c0: 2020 2020 2020 2020 6966 2074 7970 6963          if typic
+0000f9d0: 616c 5f77 6569 6768 7420 6973 204e 6f6e  al_weight is Non
+0000f9e0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0000f9f0: 6574 7572 6e20 7265 730a 2020 2020 2020  eturn res.      
+0000fa00: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000fa10: 2020 2020 7265 7475 726e 2072 6573 2f74      return res/t
+0000fa20: 7970 6963 616c 5f77 6569 6768 7420 2d20  ypical_weight - 
+0000fa30: 312e 300a 0a20 2020 2040 4361 6368 6564  1.0..    @Cached
+0000fa40: 2e6d 6574 686f 6428 6174 7472 733d 2822  .method(attrs=("
+0000fa50: 5f6d 7574 5f6e 7722 2c20 225f 6d75 745f  _mut_nw", "_mut_
+0000fa60: 6c61 2229 290a 2020 2020 6465 6620 6e73  la")).    def ns
+0000fa70: 695f 696e 6465 6772 6565 2873 656c 662c  i_indegree(self,
+0000fa80: 206b 6579 3d4e 6f6e 652c 2074 7970 6963   key=None, typic
+0000fa90: 616c 5f77 6569 6768 743d 4e6f 6e65 293a  al_weight=None):
+0000faa0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000fab0: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
+0000fac0: 6465 2c20 7265 7475 726e 2069 7473 206e  de, return its n
+0000fad0: 2e73 2e69 2e20 696e 6465 6772 6565 2e0a  .s.i. indegree..
+0000fae0: 0a20 2020 2020 2020 2049 6620 6120 6c69  .        If a li
+0000faf0: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
+0000fb00: 2069 7320 7370 6563 6966 6965 642c 2072   is specified, r
+0000fb10: 6574 7572 6e20 7468 6520 6173 736f 6369  eturn the associ
+0000fb20: 6174 6564 206e 2e73 2e69 2e0a 2020 2020  ated n.s.i..    
+0000fb30: 2020 2020 696e 2d73 7472 656e 6774 682e      in-strength.
+0000fb40: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
+0000fb50: 706c 6573 3a2a 2a0a 0a20 2020 2020 2020  ples:**..       
+0000fb60: 203e 3e3e 206e 6574 203d 204e 6574 776f   >>> net = Netwo
+0000fb70: 726b 2e53 6d61 6c6c 4469 7265 6374 6564  rk.SmallDirected
+0000fb80: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
+0000fb90: 2020 2020 2020 3e3e 3e20 6e65 742e 6e73        >>> net.ns
+0000fba0: 695f 696e 6465 6772 6565 2829 0a20 2020  i_indegree().   
+0000fbb0: 2020 2020 2061 7272 6179 285b 2036 2e33       array([ 6.3
+0000fbc0: 2c20 2035 2e33 2c20 2035 2e39 2c20 2033  ,  5.3,  5.9,  3
+0000fbd0: 2e36 2c20 2034 2e20 2c20 2032 2e35 5d29  .6,  4. ,  2.5])
+0000fbe0: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
+0000fbf0: 2e73 706c 6974 7465 645f 636f 7079 2829  .splitted_copy()
+0000fc00: 2e6e 7369 5f69 6e64 6567 7265 6528 290a  .nsi_indegree().
+0000fc10: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+0000fc20: 362e 332c 2020 352e 332c 2020 352e 392c  6.3,  5.3,  5.9,
+0000fc30: 2020 332e 362c 2020 342e 202c 2020 322e    3.6,  4. ,  2.
+0000fc40: 352c 2020 322e 355d 290a 0a20 2020 2020  5,  2.5])..     
+0000fc50: 2020 2061 7320 636f 6d70 6172 6564 2074     as compared t
+0000fc60: 6f20 7468 6520 756e 7765 6967 6874 6564  o the unweighted
+0000fc70: 2076 6572 7369 6f6e 3a0a 0a20 2020 2020   version:..     
+0000fc80: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
+0000fc90: 776f 726b 2e53 6d61 6c6c 4469 7265 6374  work.SmallDirect
+0000fca0: 6564 5465 7374 4e65 7477 6f72 6b28 290a  edTestNetwork().
+0000fcb0: 2020 2020 2020 2020 3e3e 3e20 6e65 742e          >>> net.
+0000fcc0: 696e 6465 6772 6565 2829 0a20 2020 2020  indegree().     
+0000fcd0: 2020 2061 7272 6179 285b 322c 2032 2c20     array([2, 2, 
+0000fce0: 322c 2031 2c20 312c 2030 5d29 0a20 2020  2, 1, 1, 0]).   
+0000fcf0: 2020 2020 203e 3e3e 206e 6574 2e73 706c       >>> net.spl
+0000fd00: 6974 7465 645f 636f 7079 2829 2e69 6e64  itted_copy().ind
+0000fd10: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
+0000fd20: 6172 7261 7928 5b33 2c20 322c 2032 2c20  array([3, 2, 2, 
+0000fd30: 312c 2031 2c20 312c 2031 5d29 0a0a 2020  1, 1, 1, 1])..  
+0000fd40: 2020 2020 2020 3a61 7267 2073 7472 206b        :arg str k
+0000fd50: 6579 3a20 6c69 6e6b 2061 7474 7269 6275  ey: link attribu
+0000fd60: 7465 206b 6579 205b 6f70 7469 6f6e 616c  te key [optional
+0000fd70: 5d0a 2020 2020 2020 2020 3a74 7970 6520  ].        :type 
+0000fd80: 7479 7069 6361 6c5f 7765 6967 6874 3a20  typical_weight: 
+0000fd90: 666c 6f61 7420 3e20 300a 2020 2020 2020  float > 0.      
+0000fda0: 2020 3a61 7267 2020 7479 7069 6361 6c5f    :arg  typical_
+0000fdb0: 7765 6967 6874 3a20 4f70 7469 6f6e 616c  weight: Optional
+0000fdc0: 2074 7970 6963 616c 206e 6f64 6520 7765   typical node we
+0000fdd0: 6967 6874 2074 6f20 6265 2075 7365 6420  ight to be used 
+0000fde0: 666f 720a 2020 2020 2020 2020 2020 2020  for.            
+0000fdf0: 636f 7272 6563 7469 6f6e 2e20 4966 204e  correction. If N
+0000fe00: 6f6e 652c 2074 6865 2075 6e63 6f72 7265  one, the uncorre
+0000fe10: 6374 6564 206d 6561 7375 7265 2069 730a  cted measure is.
+0000fe20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000fe30: 726e 6564 2e20 2844 6566 6175 6c74 3a20  rned. (Default: 
+0000fe40: 4e6f 6e65 290a 0a20 2020 2020 2020 203a  None)..        :
+0000fe50: 7274 7970 653a 2061 7272 6179 285b 666c  rtype: array([fl
+0000fe60: 6f61 745d 290a 2020 2020 2020 2020 2222  oat]).        ""
+0000fe70: 220a 2020 2020 2020 2020 6966 206b 6579  ".        if key
+0000fe80: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000fe90: 2020 2020 2020 7265 7320 3d20 7365 6c66        res = self
+0000fea0: 2e6e 6f64 655f 7765 6967 6874 7320 2a20  .node_weights * 
+0000feb0: 7365 6c66 2e73 705f 4170 6c75 7328 290a  self.sp_Aplus().
+0000fec0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000fed0: 2020 2020 2020 2020 2020 7265 7320 3d20            res = 
+0000fee0: 2873 656c 662e 6e6f 6465 5f77 6569 6768  (self.node_weigh
+0000fef0: 7473 2040 2073 656c 662e 6c69 6e6b 5f61  ts @ self.link_a
+0000ff00: 7474 7269 6275 7465 286b 6579 2929 2e73  ttribute(key)).s
+0000ff10: 7175 6565 7a65 2829 0a20 2020 2020 2020  queeze().       
+0000ff20: 2069 6620 7479 7069 6361 6c5f 7765 6967   if typical_weig
+0000ff30: 6874 2069 7320 4e6f 6e65 3a0a 2020 2020  ht is None:.    
+0000ff40: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+0000ff50: 6573 0a20 2020 2020 2020 2065 6c73 653a  es.        else:
+0000ff60: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000ff70: 7572 6e20 7265 732f 7479 7069 6361 6c5f  urn res/typical_
+0000ff80: 7765 6967 6874 202d 2031 2e30 0a0a 2020  weight - 1.0..  
+0000ff90: 2020 4043 6163 6865 642e 6d65 7468 6f64    @Cached.method
+0000ffa0: 2861 7474 7273 3d28 225f 6d75 745f 6e77  (attrs=("_mut_nw
+0000ffb0: 222c 2022 5f6d 7574 5f6c 6122 2929 0a20  ", "_mut_la")). 
+0000ffc0: 2020 2064 6566 206e 7369 5f6f 7574 6465     def nsi_outde
+0000ffd0: 6772 6565 2873 656c 662c 206b 6579 3d4e  gree(self, key=N
+0000ffe0: 6f6e 652c 2074 7970 6963 616c 5f77 6569  one, typical_wei
+0000fff0: 6768 743d 4e6f 6e65 293a 0a20 2020 2020  ght=None):.     
+00010000: 2020 2022 2222 0a20 2020 2020 2020 2046     """.        F
+00010010: 6f72 2065 6163 6820 6e6f 6465 2c20 7265  or each node, re
+00010020: 7475 726e 2069 7473 206e 2e73 2e69 2e20  turn its n.s.i. 
+00010030: 6f75 7464 6567 7265 652e 0a0a 2020 2020  outdegree...    
+00010040: 2020 2020 4966 2061 206c 696e 6b20 6174      If a link at
+00010050: 7472 6962 7574 6520 6b65 7920 6973 2073  tribute key is s
+00010060: 7065 6369 6669 6564 2c20 7265 7475 726e  pecified, return
+00010070: 2074 6865 2061 7373 6f63 6961 7465 6420   the associated 
+00010080: 6e2e 732e 692e 0a20 2020 2020 2020 206f  n.s.i..        o
+00010090: 7574 2d73 7472 656e 6774 682e 0a0a 2020  ut-strength...  
+000100a0: 2020 2020 2020 2a2a 4578 616d 706c 6573        **Examples
+000100b0: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+000100c0: 206e 6574 203d 204e 6574 776f 726b 2e53   net = Network.S
+000100d0: 6d61 6c6c 4469 7265 6374 6564 5465 7374  mallDirectedTest
+000100e0: 4e65 7477 6f72 6b28 290a 2020 2020 2020  Network().      
+000100f0: 2020 3e3e 3e20 6e65 742e 6e73 695f 6f75    >>> net.nsi_ou
+00010100: 7464 6567 7265 6528 290a 2020 2020 2020  tdegree().      
+00010110: 2020 6172 7261 7928 5b20 352e 332c 2020    array([ 5.3,  
+00010120: 352e 392c 2020 312e 392c 2020 332e 382c  5.9,  1.9,  3.8,
+00010130: 2020 352e 372c 2020 342e 205d 290a 2020    5.7,  4. ]).  
+00010140: 2020 2020 2020 3e3e 3e20 6e65 742e 7370        >>> net.sp
+00010150: 6c69 7474 6564 5f63 6f70 7928 292e 6e73  litted_copy().ns
+00010160: 695f 6f75 7464 6567 7265 6528 290a 2020  i_outdegree().  
+00010170: 2020 2020 2020 6172 7261 7928 5b20 352e        array([ 5.
+00010180: 332c 2020 352e 392c 2020 312e 392c 2020  3,  5.9,  1.9,  
+00010190: 332e 382c 2020 352e 372c 2020 342e 202c  3.8,  5.7,  4. ,
+000101a0: 2020 342e 205d 290a 0a20 2020 2020 2020    4. ])..       
+000101b0: 2061 7320 636f 6d70 6172 6564 2074 6f20   as compared to 
+000101c0: 7468 6520 756e 7765 6967 6874 6564 2076  the unweighted v
+000101d0: 6572 7369 6f6e 3a0a 0a20 2020 2020 2020  ersion:..       
+000101e0: 203e 3e3e 206e 6574 203d 204e 6574 776f   >>> net = Netwo
+000101f0: 726b 2e53 6d61 6c6c 4469 7265 6374 6564  rk.SmallDirected
+00010200: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
+00010210: 2020 2020 2020 3e3e 3e20 6e65 742e 6f75        >>> net.ou
+00010220: 7464 6567 7265 6528 290a 2020 2020 2020  tdegree().      
+00010230: 2020 6172 7261 7928 5b32 2c20 322c 2030    array([2, 2, 0
+00010240: 2c20 312c 2032 2c20 315d 290a 2020 2020  , 1, 2, 1]).    
+00010250: 2020 2020 3e3e 3e20 6e65 742e 7370 6c69      >>> net.spli
+00010260: 7474 6564 5f63 6f70 7928 292e 6f75 7464  tted_copy().outd
+00010270: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
+00010280: 6172 7261 7928 5b32 2c20 322c 2030 2c20  array([2, 2, 0, 
+00010290: 312c 2032 2c20 322c 2032 5d29 0a0a 2020  1, 2, 2, 2])..  
+000102a0: 2020 2020 2020 3a61 7267 2073 7472 206b        :arg str k
+000102b0: 6579 3a20 6c69 6e6b 2061 7474 7269 6275  ey: link attribu
+000102c0: 7465 206b 6579 205b 6f70 7469 6f6e 616c  te key [optional
+000102d0: 5d0a 2020 2020 2020 2020 3a74 7970 6520  ].        :type 
+000102e0: 7479 7069 6361 6c5f 7765 6967 6874 3a20  typical_weight: 
+000102f0: 666c 6f61 7420 3e20 300a 2020 2020 2020  float > 0.      
+00010300: 2020 3a61 7267 2020 7479 7069 6361 6c5f    :arg  typical_
+00010310: 7765 6967 6874 3a20 4f70 7469 6f6e 616c  weight: Optional
+00010320: 2074 7970 6963 616c 206e 6f64 6520 7765   typical node we
+00010330: 6967 6874 2074 6f20 6265 2075 7365 6420  ight to be used 
+00010340: 666f 720a 2020 2020 2020 2020 2020 2020  for.            
+00010350: 636f 7272 6563 7469 6f6e 2e20 4966 204e  correction. If N
+00010360: 6f6e 652c 2074 6865 2075 6e63 6f72 7265  one, the uncorre
+00010370: 6374 6564 206d 6561 7375 7265 2069 730a  cted measure is.
+00010380: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00010390: 726e 6564 2e20 2844 6566 6175 6c74 3a20  rned. (Default: 
+000103a0: 4e6f 6e65 290a 0a20 2020 2020 2020 203a  None)..        :
+000103b0: 7274 7970 653a 2061 7272 6179 285b 666c  rtype: array([fl
+000103c0: 6f61 745d 290a 2020 2020 2020 2020 2222  oat]).        ""
+000103d0: 220a 2020 2020 2020 2020 6966 206b 6579  ".        if key
+000103e0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+000103f0: 2020 2020 2020 7265 7320 3d20 7365 6c66        res = self
+00010400: 2e73 705f 4170 6c75 7328 2920 2a20 7365  .sp_Aplus() * se
+00010410: 6c66 2e6e 6f64 655f 7765 6967 6874 730a  lf.node_weights.
+00010420: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00010430: 2020 2020 2020 2020 2020 7265 7320 3d20            res = 
+00010440: 2873 656c 662e 6c69 6e6b 5f61 7474 7269  (self.link_attri
+00010450: 6275 7465 286b 6579 2920 4020 7365 6c66  bute(key) @ self
+00010460: 2e6e 6f64 655f 7765 6967 6874 7329 2e73  .node_weights).s
+00010470: 7175 6565 7a65 2829 0a20 2020 2020 2020  queeze().       
+00010480: 2069 6620 7479 7069 6361 6c5f 7765 6967   if typical_weig
+00010490: 6874 2069 7320 4e6f 6e65 3a0a 2020 2020  ht is None:.    
+000104a0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+000104b0: 6573 0a20 2020 2020 2020 2065 6c73 653a  es.        else:
+000104c0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000104d0: 7572 6e20 7265 732f 7479 7069 6361 6c5f  urn res/typical_
+000104e0: 7765 6967 6874 202d 2031 2e30 0a0a 2020  weight - 1.0..  
+000104f0: 2020 4043 6163 6865 642e 6d65 7468 6f64    @Cached.method
+00010500: 2861 7474 7273 3d28 225f 6d75 745f 6e77  (attrs=("_mut_nw
+00010510: 222c 2929 0a20 2020 2064 6566 206e 7369  ",)).    def nsi
+00010520: 5f62 696c 6465 6772 6565 2873 656c 662c  _bildegree(self,
+00010530: 206b 6579 3d4e 6f6e 652c 2074 7970 6963   key=None, typic
+00010540: 616c 5f77 6569 6768 743d 4e6f 6e65 293a  al_weight=None):
+00010550: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00010560: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
+00010570: 6465 2c20 7265 7475 726e 2069 7473 206e  de, return its n
+00010580: 2e73 2e69 2e20 6269 6c61 7465 7261 6c20  .s.i. bilateral 
+00010590: 6465 6772 6565 2e0a 0a20 2020 2020 2020  degree...       
+000105a0: 2049 6620 6120 6c69 6e6b 2061 7474 7269   If a link attri
+000105b0: 6275 7465 206b 6579 2069 7320 7370 6563  bute key is spec
+000105c0: 6966 6965 642c 2072 6574 7572 6e20 7468  ified, return th
+000105d0: 6520 6173 736f 6369 6174 6564 206e 2e73  e associated n.s
+000105e0: 2e69 2e0a 2020 2020 2020 2020 6269 6c61  .i..        bila
+000105f0: 7465 7261 6c20 7374 7265 6e67 7468 2e0a  teral strength..
+00010600: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
+00010610: 7220 6b65 793a 206c 696e 6b20 6174 7472  r key: link attr
+00010620: 6962 7574 6520 6b65 7920 5b6f 7074 696f  ibute key [optio
+00010630: 6e61 6c5d 0a20 2020 2020 2020 203a 7479  nal].        :ty
+00010640: 7065 2074 7970 6963 616c 5f77 6569 6768  pe typical_weigh
+00010650: 743a 2066 6c6f 6174 203e 2030 0a20 2020  t: float > 0.   
+00010660: 2020 2020 203a 6172 6720 2074 7970 6963       :arg  typic
+00010670: 616c 5f77 6569 6768 743a 204f 7074 696f  al_weight: Optio
+00010680: 6e61 6c20 7479 7069 6361 6c20 6e6f 6465  nal typical node
+00010690: 2077 6569 6768 7420 746f 2062 6520 7573   weight to be us
+000106a0: 6564 2066 6f72 0a20 2020 2020 2020 2020  ed for.         
+000106b0: 2020 2063 6f72 7265 6374 696f 6e2e 2049     correction. I
+000106c0: 6620 4e6f 6e65 2c20 7468 6520 756e 636f  f None, the unco
+000106d0: 7272 6563 7465 6420 6d65 6173 7572 6520  rrected measure 
+000106e0: 6973 0a20 2020 2020 2020 2020 2020 2072  is.            r
+000106f0: 6574 7572 6e65 642e 2028 4465 6661 756c  eturned. (Defaul
+00010700: 743a 204e 6f6e 6529 0a0a 2020 2020 2020  t: None)..      
+00010710: 2020 3a72 7479 7065 3a20 6172 7261 7928    :rtype: array(
+00010720: 5b66 6c6f 6174 5d29 0a20 2020 2020 2020  [float]).       
+00010730: 2022 2222 0a20 2020 2020 2020 2061 7373   """.        ass
+00010740: 6572 7420 6b65 7920 6973 204e 6f6e 652c  ert key is None,
+00010750: 2022 6e73 695f 6269 6c64 6567 7265 6520   "nsi_bildegree 
+00010760: 6973 206e 6f74 2069 6d70 6c65 6d65 6e74  is not implement
+00010770: 6564 2077 6974 6820 6b65 7920 7965 7422  ed with key yet"
+00010780: 0a20 2020 2020 2020 2041 7020 3d20 7365  .        Ap = se
+00010790: 6c66 2e73 705f 4170 6c75 7328 290a 2020  lf.sp_Aplus().  
+000107a0: 2020 2020 2020 7265 7320 3d20 2841 7020        res = (Ap 
+000107b0: 2a20 7370 2e64 6961 6773 2873 656c 662e  * sp.diags(self.
+000107c0: 6e6f 6465 5f77 6569 6768 7473 2920 2a20  node_weights) * 
+000107d0: 4170 292e 6469 6167 6f6e 616c 2829 0a20  Ap).diagonal(). 
+000107e0: 2020 2020 2020 2069 6620 7479 7069 6361         if typica
+000107f0: 6c5f 7765 6967 6874 2069 7320 4e6f 6e65  l_weight is None
+00010800: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00010810: 7475 726e 2072 6573 0a20 2020 2020 2020  turn res.       
+00010820: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00010830: 2020 2072 6574 7572 6e20 7265 732f 7479     return res/ty
+00010840: 7069 6361 6c5f 7765 6967 6874 202d 2031  pical_weight - 1
+00010850: 2e30 0a0a 2020 2020 4043 6163 6865 642e  .0..    @Cached.
+00010860: 6d65 7468 6f64 286e 616d 653d 2274 6865  method(name="the
+00010870: 2064 6567 7265 6520 6672 6571 7565 6e63   degree frequenc
+00010880: 7920 6469 7374 7269 6275 7469 6f6e 2229  y distribution")
+00010890: 0a20 2020 2064 6566 2064 6567 7265 655f  .    def degree_
+000108a0: 6469 7374 7269 6275 7469 6f6e 2873 656c  distribution(sel
+000108b0: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
+000108c0: 2020 2020 2020 2020 5265 7475 726e 2074          Return t
+000108d0: 6865 2064 6567 7265 6520 6672 6571 7565  he degree freque
+000108e0: 6e63 7920 6469 7374 7269 6275 7469 6f6e  ncy distribution
+000108f0: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+00010900: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+00010910: 203e 3e3e 2072 284e 6574 776f 726b 2e53   >>> r(Network.S
+00010920: 6d61 6c6c 5465 7374 4e65 7477 6f72 6b28  mallTestNetwork(
+00010930: 292e 6465 6772 6565 5f64 6973 7472 6962  ).degree_distrib
+00010940: 7574 696f 6e28 2929 0a20 2020 2020 2020  ution()).       
+00010950: 2043 616c 6375 6c61 7469 6e67 2074 6865   Calculating the
+00010960: 2064 6567 7265 6520 6672 6571 7565 6e63   degree frequenc
+00010970: 7920 6469 7374 7269 6275 7469 6f6e 2e2e  y distribution..
+00010980: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+00010990: 5b20 302e 3136 3637 2c20 302e 3333 3333  [ 0.1667, 0.3333
+000109a0: 2c20 302e 3520 5d29 0a0a 2020 2020 2020  , 0.5 ])..      
+000109b0: 2020 3a72 7479 7065 3a20 2031 6420 6e75    :rtype:  1d nu
+000109c0: 6d70 7920 6172 7261 7920 5b6b 5d20 6f66  mpy array [k] of
+000109d0: 2069 6e74 7320 3e3d 2030 0a20 2020 2020   ints >= 0.     
+000109e0: 2020 203a 7265 7475 726e 3a20 456e 7472     :return: Entr
+000109f0: 7920 5b6b 5d20 6973 2074 6865 206e 756d  y [k] is the num
+00010a00: 6265 7220 6f66 206e 6f64 6573 2068 6176  ber of nodes hav
+00010a10: 696e 6720 6465 6772 6565 206b 2e0a 2020  ing degree k..  
+00010a20: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00010a30: 2020 6b20 3d20 7365 6c66 2e64 6567 7265    k = self.degre
+00010a40: 6528 290a 2020 2020 2020 2020 7265 7475  e().        retu
+00010a50: 726e 2073 656c 662e 5f68 6973 746f 6772  rn self._histogr
+00010a60: 616d 2876 616c 7565 733d 6b2c 206e 5f62  am(values=k, n_b
+00010a70: 696e 733d 6b2e 6d61 7828 2929 5b30 5d0a  ins=k.max())[0].
+00010a80: 0a20 2020 2040 4361 6368 6564 2e6d 6574  .    @Cached.met
+00010a90: 686f 6428 6e61 6d65 3d22 7468 6520 696e  hod(name="the in
+00010aa0: 2d64 6567 7265 6520 6672 6571 7565 6e63  -degree frequenc
+00010ab0: 7920 6469 7374 7269 6275 7469 6f6e 2229  y distribution")
+00010ac0: 0a20 2020 2064 6566 2069 6e64 6567 7265  .    def indegre
+00010ad0: 655f 6469 7374 7269 6275 7469 6f6e 2873  e_distribution(s
+00010ae0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00010af0: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
+00010b00: 2074 6865 2069 6e2d 6465 6772 6565 2066   the in-degree f
+00010b10: 7265 7175 656e 6379 2064 6973 7472 6962  requency distrib
+00010b20: 7574 696f 6e2e 0a0a 2020 2020 2020 2020  ution...        
+00010b30: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
+00010b40: 2020 2020 2020 3e3e 3e20 7228 4e65 7477        >>> r(Netw
+00010b50: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
+00010b60: 776f 726b 2829 2e69 6e64 6567 7265 655f  work().indegree_
+00010b70: 6469 7374 7269 6275 7469 6f6e 2829 290a  distribution()).
+00010b80: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00010b90: 696e 6720 696e 2d64 6567 7265 6520 6672  ing in-degree fr
+00010ba0: 6571 7565 6e63 7920 6469 7374 7269 6275  equency distribu
+00010bb0: 7469 6f6e 2e2e 2e0a 2020 2020 2020 2020  tion....        
+00010bc0: 6172 7261 7928 5b20 302e 3136 3637 2c20  array([ 0.1667, 
+00010bd0: 302e 3333 3333 2c20 302e 3520 5d29 0a0a  0.3333, 0.5 ])..
+00010be0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00010bf0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
+00010c00: 5b6b 5d20 6f66 2069 6e74 7320 3e3d 2030  [k] of ints >= 0
+00010c10: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
+00010c20: 3a20 456e 7472 7920 5b6b 5d20 6973 2074  : Entry [k] is t
+00010c30: 6865 206e 756d 6265 7220 6f66 206e 6f64  he number of nod
+00010c40: 6573 2068 6176 696e 6720 696e 2d64 6567  es having in-deg
+00010c50: 7265 6520 6b2e 0a20 2020 2020 2020 2022  ree k..        "
+00010c60: 2222 0a20 2020 2020 2020 206b 6920 3d20  "".        ki = 
+00010c70: 7365 6c66 2e69 6e64 6567 7265 6528 290a  self.indegree().
+00010c80: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00010c90: 656c 662e 5f68 6973 746f 6772 616d 2876  elf._histogram(v
+00010ca0: 616c 7565 733d 6b69 2c20 6e5f 6269 6e73  alues=ki, n_bins
+00010cb0: 3d6b 692e 6d61 7828 2929 5b30 5d0a 0a20  =ki.max())[0].. 
+00010cc0: 2020 2040 4361 6368 6564 2e6d 6574 686f     @Cached.metho
+00010cd0: 6428 6e61 6d65 3d22 7468 6520 6f75 742d  d(name="the out-
+00010ce0: 6465 6772 6565 2066 7265 7175 656e 6379  degree frequency
+00010cf0: 2064 6973 7472 6962 7574 696f 6e22 290a   distribution").
+00010d00: 2020 2020 6465 6620 6f75 7464 6567 7265      def outdegre
+00010d10: 655f 6469 7374 7269 6275 7469 6f6e 2873  e_distribution(s
+00010d20: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00010d30: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
+00010d40: 2074 6865 206f 7574 2d64 6567 7265 6520   the out-degree 
+00010d50: 6672 6571 7565 6e63 7920 6469 7374 7269  frequency distri
+00010d60: 6275 7469 6f6e 2e0a 0a20 2020 2020 2020  bution...       
+00010d70: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
+00010d80: 2020 2020 2020 203e 3e3e 2072 284e 6574         >>> r(Net
+00010d90: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
+00010da0: 7477 6f72 6b28 292e 6f75 7464 6567 7265  twork().outdegre
+00010db0: 655f 6469 7374 7269 6275 7469 6f6e 2829  e_distribution()
+00010dc0: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
+00010dd0: 6174 696e 6720 6f75 742d 6465 6772 6565  ating out-degree
+00010de0: 2066 7265 7175 656e 6379 2064 6973 7472   frequency distr
+00010df0: 6962 7574 696f 6e2e 2e2e 0a20 2020 2020  ibution....     
+00010e00: 2020 2061 7272 6179 285b 2030 2e31 3636     array([ 0.166
+00010e10: 372c 2030 2e20 2c20 302e 3333 3333 2c20  7, 0. , 0.3333, 
+00010e20: 302e 3520 5d29 0a0a 2020 2020 2020 2020  0.5 ])..        
+00010e30: 3a72 7479 7065 3a20 2031 6420 6e75 6d70  :rtype:  1d nump
+00010e40: 7920 6172 7261 7920 5b6b 5d20 6f66 2069  y array [k] of i
+00010e50: 6e74 7320 3e3d 2030 0a20 2020 2020 2020  nts >= 0.       
+00010e60: 203a 7265 7475 726e 3a20 456e 7472 7920   :return: Entry 
+00010e70: 5b6b 5d20 6973 2074 6865 206e 756d 6265  [k] is the numbe
+00010e80: 7220 6f66 206e 6f64 6573 2068 6176 696e  r of nodes havin
+00010e90: 6720 6f75 742d 6465 6772 6565 206b 2e0a  g out-degree k..
+00010ea0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00010eb0: 2020 2020 6b6f 203d 2073 656c 662e 6f75      ko = self.ou
+00010ec0: 7464 6567 7265 6528 290a 2020 2020 2020  tdegree().      
+00010ed0: 2020 7265 7475 726e 2073 656c 662e 5f68    return self._h
+00010ee0: 6973 746f 6772 616d 2876 616c 7565 733d  istogram(values=
+00010ef0: 6b6f 2c20 6e5f 6269 6e73 3d6b 6f2e 6d61  ko, n_bins=ko.ma
+00010f00: 7828 292b 3129 5b30 5d0a 0a20 2020 2040  x()+1)[0]..    @
+00010f10: 4361 6368 6564 2e6d 6574 686f 6428 6e61  Cached.method(na
+00010f20: 6d65 3d22 7468 6520 6375 6d75 6c61 7469  me="the cumulati
+00010f30: 7665 2064 6567 7265 6520 6469 7374 7269  ve degree distri
+00010f40: 6275 7469 6f6e 2229 0a20 2020 2064 6566  bution").    def
+00010f50: 2064 6567 7265 655f 6364 6628 7365 6c66   degree_cdf(self
+00010f60: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00010f70: 2020 2020 2020 2052 6574 7572 6e20 7468         Return th
+00010f80: 6520 6375 6d75 6c61 7469 7665 2064 6567  e cumulative deg
+00010f90: 7265 6520 6672 6571 7565 6e63 7920 6469  ree frequency di
+00010fa0: 7374 7269 6275 7469 6f6e 2e0a 0a20 2020  stribution...   
+00010fb0: 2020 2020 202a 2a45 7861 6d70 6c65 3a2a       **Example:*
+00010fc0: 2a0a 0a20 2020 2020 2020 203e 3e3e 2072  *..        >>> r
+00010fd0: 284e 6574 776f 726b 2e53 6d61 6c6c 5465  (Network.SmallTe
+00010fe0: 7374 4e65 7477 6f72 6b28 292e 6465 6772  stNetwork().degr
+00010ff0: 6565 5f63 6466 2829 290a 2020 2020 2020  ee_cdf()).      
+00011000: 2020 4361 6c63 756c 6174 696e 6720 7468    Calculating th
+00011010: 6520 6375 6d75 6c61 7469 7665 2064 6567  e cumulative deg
+00011020: 7265 6520 6469 7374 7269 6275 7469 6f6e  ree distribution
+00011030: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
+00011040: 7928 5b20 312e 202c 2030 2e38 3333 332c  y([ 1. , 0.8333,
+00011050: 2020 302e 3520 5d29 0a0a 2020 2020 2020    0.5 ])..      
+00011060: 2020 3a72 7479 7065 3a20 2031 6420 6e75    :rtype:  1d nu
+00011070: 6d70 7920 6172 7261 7920 5b6b 5d20 6f66  mpy array [k] of
+00011080: 2069 6e74 7320 3e3d 2030 0a20 2020 2020   ints >= 0.     
+00011090: 2020 203a 7265 7475 726e 3a20 456e 7472     :return: Entr
+000110a0: 7920 5b6b 5d20 6973 2074 6865 206e 756d  y [k] is the num
+000110b0: 6265 7220 6f66 206e 6f64 6573 2068 6176  ber of nodes hav
+000110c0: 696e 6720 6465 6772 6565 206b 206f 7220  ing degree k or 
+000110d0: 6d6f 7265 2e0a 2020 2020 2020 2020 2222  more..        ""
+000110e0: 220a 2020 2020 2020 2020 6b20 3d20 7365  ".        k = se
+000110f0: 6c66 2e64 6567 7265 6528 290a 2020 2020  lf.degree().    
+00011100: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00011110: 5f63 756d 5f68 6973 746f 6772 616d 2876  _cum_histogram(v
+00011120: 616c 7565 733d 6b2c 206e 5f62 696e 733d  alues=k, n_bins=
+00011130: 6b2e 6d61 7828 2929 5b30 5d0a 0a20 2020  k.max())[0]..   
+00011140: 2040 4361 6368 6564 2e6d 6574 686f 6428   @Cached.method(
+00011150: 6e61 6d65 3d22 7468 6520 6375 6d75 6c61  name="the cumula
+00011160: 7469 7665 2069 6e2d 6465 6772 6565 2064  tive in-degree d
+00011170: 6973 7472 6962 7574 696f 6e22 290a 2020  istribution").  
+00011180: 2020 6465 6620 696e 6465 6772 6565 5f63    def indegree_c
+00011190: 6466 2873 656c 6629 3a0a 2020 2020 2020  df(self):.      
+000111a0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+000111b0: 7475 726e 2074 6865 2063 756d 756c 6174  turn the cumulat
+000111c0: 6976 6520 696e 2d64 6567 7265 6520 6672  ive in-degree fr
+000111d0: 6571 7565 6e63 7920 6469 7374 7269 6275  equency distribu
+000111e0: 7469 6f6e 2e0a 0a20 2020 2020 2020 202a  tion...        *
+000111f0: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+00011200: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
+00011210: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
+00011220: 6f72 6b28 292e 696e 6465 6772 6565 5f63  ork().indegree_c
+00011230: 6466 2829 290a 2020 2020 2020 2020 4361  df()).        Ca
+00011240: 6c63 756c 6174 696e 6720 7468 6520 6375  lculating the cu
+00011250: 6d75 6c61 7469 7665 2069 6e2d 6465 6772  mulative in-degr
+00011260: 6565 2064 6973 7472 6962 7574 696f 6e2e  ee distribution.
+00011270: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
+00011280: 285b 2031 2e20 2c20 302e 3833 3333 2c20  ([ 1. , 0.8333, 
+00011290: 302e 3833 3333 2c20 302e 3520 5d29 0a0a  0.8333, 0.5 ])..
+000112a0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+000112b0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
+000112c0: 5b6b 5d20 6f66 2069 6e74 7320 3e3d 2030  [k] of ints >= 0
+000112d0: 0a20 2020 2020 2020 203a 7265 7475 726e  .        :return
+000112e0: 3a20 456e 7472 7920 5b6b 5d20 6973 2074  : Entry [k] is t
+000112f0: 6865 206e 756d 6265 7220 6f66 206e 6f64  he number of nod
+00011300: 6573 2068 6176 696e 6720 696e 2d64 6567  es having in-deg
+00011310: 7265 6520 6b20 6f72 206d 6f72 652e 0a20  ree k or more.. 
+00011320: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00011330: 2020 206b 6920 3d20 7365 6c66 2e69 6e64     ki = self.ind
+00011340: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
+00011350: 7265 7475 726e 2073 656c 662e 5f63 756d  return self._cum
+00011360: 5f68 6973 746f 6772 616d 2876 616c 7565  _histogram(value
+00011370: 733d 6b69 2c20 6e5f 6269 6e73 3d6b 692e  s=ki, n_bins=ki.
+00011380: 6d61 7828 2920 2b20 3129 5b30 5d0a 0a20  max() + 1)[0].. 
+00011390: 2020 2040 4361 6368 6564 2e6d 6574 686f     @Cached.metho
+000113a0: 6428 6e61 6d65 3d22 7468 6520 6375 6d75  d(name="the cumu
+000113b0: 6c61 7469 7665 206f 7574 2d64 6567 7265  lative out-degre
+000113c0: 6520 6469 7374 7269 6275 7469 6f6e 2229  e distribution")
+000113d0: 0a20 2020 2064 6566 206f 7574 6465 6772  .    def outdegr
+000113e0: 6565 5f63 6466 2873 656c 6629 3a0a 2020  ee_cdf(self):.  
+000113f0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00011400: 2020 5265 7475 726e 2074 6865 2063 756d    Return the cum
+00011410: 756c 6174 6976 6520 6f75 742d 6465 6772  ulative out-degr
+00011420: 6565 2066 7265 7175 656e 6379 2064 6973  ee frequency dis
+00011430: 7472 6962 7574 696f 6e2e 0a0a 2020 2020  tribution...    
+00011440: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
+00011450: 0a0a 2020 2020 2020 2020 3e3e 3e20 7228  ..        >>> r(
+00011460: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
+00011470: 744e 6574 776f 726b 2829 2e6f 7574 6465  tNetwork().outde
+00011480: 6772 6565 5f63 6466 2829 290a 2020 2020  gree_cdf()).    
+00011490: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+000114a0: 7468 6520 6375 6d75 6c61 7469 7665 206f  the cumulative o
+000114b0: 7574 2d64 6567 7265 6520 6469 7374 7269  ut-degree distri
+000114c0: 6275 7469 6f6e 2e2e 2e0a 2020 2020 2020  bution....      
+000114d0: 2020 6172 7261 7928 5b20 312e 202c 2030    array([ 1. , 0
+000114e0: 2e38 3333 332c 2030 2e38 3333 332c 2030  .8333, 0.8333, 0
+000114f0: 2e35 205d 290a 0a20 2020 2020 2020 203a  .5 ])..        :
+00011500: 7274 7970 653a 2020 3164 206e 756d 7079  rtype:  1d numpy
+00011510: 2061 7272 6179 205b 6b5d 206f 6620 696e   array [k] of in
+00011520: 7473 203e 3d20 300a 2020 2020 2020 2020  ts >= 0.        
+00011530: 3a72 6574 7572 6e3a 2045 6e74 7279 205b  :return: Entry [
+00011540: 6b5d 2069 7320 7468 6520 6e75 6d62 6572  k] is the number
+00011550: 206f 6620 6e6f 6465 7320 6861 7669 6e67   of nodes having
+00011560: 206f 7574 2d64 6567 7265 6520 6b20 6f72   out-degree k or
+00011570: 206d 6f72 652e 0a20 2020 2020 2020 2022   more..        "
+00011580: 2222 0a20 2020 2020 2020 206b 6f20 3d20  "".        ko = 
+00011590: 7365 6c66 2e6f 7574 6465 6772 6565 2829  self.outdegree()
+000115a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000115b0: 7365 6c66 2e5f 6375 6d5f 6869 7374 6f67  self._cum_histog
+000115c0: 7261 6d28 7661 6c75 6573 3d6b 6f2c 206e  ram(values=ko, n
+000115d0: 5f62 696e 733d 6b6f 2e6d 6178 2829 202b  _bins=ko.max() +
+000115e0: 2031 295b 305d 0a0a 2020 2020 4043 6163   1)[0]..    @Cac
+000115f0: 6865 642e 6d65 7468 6f64 286e 616d 653d  hed.method(name=
+00011600: 2261 206e 2e73 2e69 2e20 6465 6772 6565  "a n.s.i. degree
+00011610: 2066 7265 7175 656e 6379 2068 6973 746f   frequency histo
+00011620: 6772 616d 222c 0a20 2020 2020 2020 2020  gram",.         
+00011630: 2020 2020 2020 2020 2020 6174 7472 733d            attrs=
+00011640: 2822 5f6d 7574 5f6e 7722 2c29 290a 2020  ("_mut_nw",)).  
+00011650: 2020 6465 6620 6e73 695f 6465 6772 6565    def nsi_degree
+00011660: 5f68 6973 746f 6772 616d 2873 656c 662c  _histogram(self,
+00011670: 2074 7970 6963 616c 5f77 6569 6768 743d   typical_weight=
+00011680: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
+00011690: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
+000116a0: 6e20 6120 6672 6571 7565 6e63 7920 2821  n a frequency (!
+000116b0: 2920 6869 7374 6f67 7261 6d20 6f66 206e  ) histogram of n
+000116c0: 2e73 2e69 2e20 6465 6772 6565 2e0a 0a20  .s.i. degree... 
+000116d0: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
+000116e0: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+000116f0: 2072 284e 6574 776f 726b 2e53 6d61 6c6c   r(Network.Small
+00011700: 5465 7374 4e65 7477 6f72 6b28 292e 6e73  TestNetwork().ns
+00011710: 695f 6465 6772 6565 5f68 6973 746f 6772  i_degree_histogr
+00011720: 616d 2829 290a 2020 2020 2020 2020 4361  am()).        Ca
+00011730: 6c63 756c 6174 696e 6720 6120 6e2e 732e  lculating a n.s.
+00011740: 692e 2064 6567 7265 6520 6672 6571 7565  i. degree freque
+00011750: 6e63 7920 6869 7374 6f67 7261 6d2e 2e2e  ncy histogram...
+00011760: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+00011770: 7469 6e67 206e 2e73 2e69 2e20 6465 6772  ting n.s.i. degr
+00011780: 6565 2e2e 2e0a 2020 2020 2020 2020 2861  ee....        (a
+00011790: 7272 6179 285b 2030 2e33 3333 332c 2030  rray([ 0.3333, 0
+000117a0: 2e31 3636 372c 2030 2e35 205d 292c 2061  .1667, 0.5 ]), a
+000117b0: 7272 6179 285b 2030 2e31 3137 392c 2030  rray([ 0.1179, 0
+000117c0: 2e31 3636 372c 2030 2e30 3936 325d 292c  .1667, 0.0962]),
+000117d0: 0a20 2020 2020 2020 2020 6172 7261 7928  .         array(
+000117e0: 5b20 342e 202c 2035 2e34 3636 372c 2036  [ 4. , 5.4667, 6
+000117f0: 2e39 3333 335d 2929 0a0a 2020 2020 2020  .9333]))..      
+00011800: 2020 3a74 7970 6520 7479 7069 6361 6c5f    :type typical_
+00011810: 7765 6967 6874 3a20 666c 6f61 7420 3e20  weight: float > 
+00011820: 300a 2020 2020 2020 2020 3a61 7267 2020  0.        :arg  
+00011830: 7479 7069 6361 6c5f 7765 6967 6874 3a20  typical_weight: 
+00011840: 4f70 7469 6f6e 616c 2074 7970 6963 616c  Optional typical
+00011850: 206e 6f64 6520 7765 6967 6874 2074 6f20   node weight to 
+00011860: 6265 2075 7365 6420 666f 720a 2020 2020  be used for.    
+00011870: 2020 2020 2020 2020 636f 7272 6563 7469          correcti
+00011880: 6f6e 2e20 4966 204e 6f6e 652c 2074 6865  on. If None, the
+00011890: 2075 6e63 6f72 7265 6374 6564 206d 6561   uncorrected mea
+000118a0: 7375 7265 2069 730a 2020 2020 2020 2020  sure is.        
+000118b0: 2020 2020 7265 7475 726e 6564 2e20 2844      returned. (D
+000118c0: 6566 6175 6c74 3a20 4e6f 6e65 290a 0a20  efault: None).. 
+000118d0: 2020 2020 2020 203a 7274 7970 653a 2020         :rtype:  
+000118e0: 7475 706c 6520 286c 6973 742c 6c69 7374  tuple (list,list
+000118f0: 290a 2020 2020 2020 2020 3a72 6574 7572  ).        :retur
+00011900: 6e3a 204c 6973 7420 6f66 2066 7265 7175  n: List of frequ
+00011910: 656e 6369 6573 2061 6e64 206c 6973 7420  encies and list 
+00011920: 6f66 206c 6f77 6572 2062 696e 2062 6f75  of lower bin bou
+00011930: 6e64 732e 0a20 2020 2020 2020 2022 2222  nds..        """
+00011940: 0a20 2020 2020 2020 206e 7369 5f6b 203d  .        nsi_k =
+00011950: 2073 656c 662e 6e73 695f 6465 6772 6565   self.nsi_degree
+00011960: 2874 7970 6963 616c 5f77 6569 6768 743d  (typical_weight=
+00011970: 7479 7069 6361 6c5f 7765 6967 6874 290a  typical_weight).
+00011980: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00011990: 656c 662e 5f68 6973 746f 6772 616d 2876  elf._histogram(v
+000119a0: 616c 7565 733d 6e73 695f 6b2c 0a20 2020  alues=nsi_k,.   
+000119b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000119c0: 2020 2020 2020 2020 2020 2020 6e5f 6269              n_bi
+000119d0: 6e73 3d69 6e74 286e 7369 5f6b 2e6d 6178  ns=int(nsi_k.max
+000119e0: 2829 2f6e 7369 5f6b 2e6d 696e 2829 2920  ()/nsi_k.min()) 
+000119f0: 2b20 3129 0a0a 2020 2020 4043 6163 6865  + 1)..    @Cache
+00011a00: 642e 6d65 7468 6f64 286e 616d 653d 2261  d.method(name="a
+00011a10: 2063 756d 756c 6174 6976 6520 6e2e 732e   cumulative n.s.
+00011a20: 692e 2064 6567 7265 6520 6672 6571 7565  i. degree freque
+00011a30: 6e63 7920 6869 7374 6f67 7261 6d22 2c0a  ncy histogram",.
+00011a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011a50: 2020 2061 7474 7273 3d28 225f 6d75 745f     attrs=("_mut_
+00011a60: 6e77 222c 2929 0a20 2020 2064 6566 206e  nw",)).    def n
+00011a70: 7369 5f64 6567 7265 655f 6375 6d75 6c61  si_degree_cumula
+00011a80: 7469 7665 5f68 6973 746f 6772 616d 2873  tive_histogram(s
+00011a90: 656c 662c 2074 7970 6963 616c 5f77 6569  elf, typical_wei
+00011aa0: 6768 743d 4e6f 6e65 293a 0a20 2020 2020  ght=None):.     
+00011ab0: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
+00011ac0: 6574 7572 6e20 6120 6375 6d75 6c61 7469  eturn a cumulati
+00011ad0: 7665 2066 7265 7175 656e 6379 2028 2129  ve frequency (!)
+00011ae0: 2068 6973 746f 6772 616d 206f 6620 6e2e   histogram of n.
+00011af0: 732e 692e 2064 6567 7265 652e 0a0a 2020  s.i. degree...  
+00011b00: 2020 2020 2020 2a2a 4578 616d 706c 653a        **Example:
+00011b10: 2a2a 0a0a 2020 2020 2020 2020 3e3e 3e20  **..        >>> 
+00011b20: 7228 4e65 7477 6f72 6b2e 536d 616c 6c54  r(Network.SmallT
+00011b30: 6573 744e 6574 776f 726b 2829 2e6e 7369  estNetwork().nsi
+00011b40: 5f64 6567 7265 655f 6375 6d75 6c61 7469  _degree_cumulati
+00011b50: 7665 5f68 6973 746f 6772 616d 2829 290a  ve_histogram()).
+00011b60: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00011b70: 696e 6720 6120 6375 6d75 6c61 7469 7665  ing a cumulative
+00011b80: 206e 2e73 2e69 2e20 6465 6772 6565 2066   n.s.i. degree f
+00011b90: 7265 7175 656e 6379 2068 6973 746f 6772  requency histogr
+00011ba0: 616d 2e2e 2e0a 2020 2020 2020 2020 4361  am....        Ca
+00011bb0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+00011bc0: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
+00011bd0: 2020 2028 6172 7261 7928 5b20 312e 202c     (array([ 1. ,
+00011be0: 2030 2e36 3636 372c 2030 2e35 205d 292c   0.6667, 0.5 ]),
+00011bf0: 2061 7272 6179 285b 2034 2e20 2c20 352e   array([ 4. , 5.
+00011c00: 3436 3637 2c20 362e 3933 3333 5d29 290a  4667, 6.9333])).
+00011c10: 0a20 2020 2020 2020 203a 7479 7065 2074  .        :type t
+00011c20: 7970 6963 616c 5f77 6569 6768 743a 2066  ypical_weight: f
+00011c30: 6c6f 6174 203e 2030 0a20 2020 2020 2020  loat > 0.       
+00011c40: 203a 6172 6720 2074 7970 6963 616c 5f77   :arg  typical_w
+00011c50: 6569 6768 743a 204f 7074 696f 6e61 6c20  eight: Optional 
+00011c60: 7479 7069 6361 6c20 6e6f 6465 2077 6569  typical node wei
+00011c70: 6768 7420 746f 2062 6520 7573 6564 2066  ght to be used f
+00011c80: 6f72 0a20 2020 2020 2020 2020 2020 2063  or.            c
+00011c90: 6f72 7265 6374 696f 6e2e 2049 6620 4e6f  orrection. If No
+00011ca0: 6e65 2c20 7468 6520 756e 636f 7272 6563  ne, the uncorrec
+00011cb0: 7465 6420 6d65 6173 7572 6520 6973 0a20  ted measure is. 
+00011cc0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00011cd0: 6e65 642e 2028 4465 6661 756c 743a 204e  ned. (Default: N
+00011ce0: 6f6e 6529 0a0a 2020 2020 2020 2020 3a72  one)..        :r
+00011cf0: 7479 7065 3a20 2074 7570 6c65 2028 6c69  type:  tuple (li
+00011d00: 7374 2c6c 6973 7429 0a20 2020 2020 2020  st,list).       
+00011d10: 203a 7265 7475 726e 3a20 4c69 7374 206f   :return: List o
+00011d20: 6620 6375 6d75 6c61 7469 7665 2066 7265  f cumulative fre
+00011d30: 7175 656e 6369 6573 2061 6e64 206c 6973  quencies and lis
+00011d40: 7420 6f66 206c 6f77 6572 2062 696e 2062  t of lower bin b
+00011d50: 6f75 6e64 732e 0a20 2020 2020 2020 2022  ounds..        "
+00011d60: 2222 0a20 2020 2020 2020 206e 7369 5f6b  "".        nsi_k
+00011d70: 203d 2073 656c 662e 6e73 695f 6465 6772   = self.nsi_degr
+00011d80: 6565 2874 7970 6963 616c 5f77 6569 6768  ee(typical_weigh
+00011d90: 743d 7479 7069 6361 6c5f 7765 6967 6874  t=typical_weight
+00011da0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00011db0: 2073 656c 662e 5f63 756d 5f68 6973 746f   self._cum_histo
+00011dc0: 6772 616d 2876 616c 7565 733d 6e73 695f  gram(values=nsi_
+00011dd0: 6b2c 0a20 2020 2020 2020 2020 2020 2020  k,.             
+00011de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011df0: 2020 2020 2020 6e5f 6269 6e73 3d69 6e74        n_bins=int
+00011e00: 286e 7369 5f6b 2e6d 6178 2829 2f6e 7369  (nsi_k.max()/nsi
+00011e10: 5f6b 2e6d 696e 2829 2920 2b20 3129 0a0a  _k.min()) + 1)..
+00011e20: 2020 2020 4043 6163 6865 642e 6d65 7468      @Cached.meth
+00011e30: 6f64 286e 616d 653d 2261 7665 7261 6765  od(name="average
+00011e40: 206e 6569 6768 626f 7572 7327 2064 6567   neighbours' deg
+00011e50: 7265 6573 2229 0a20 2020 2064 6566 2061  rees").    def a
+00011e60: 7665 7261 6765 5f6e 6569 6768 626f 7273  verage_neighbors
+00011e70: 5f64 6567 7265 6528 7365 6c66 293a 0a20  _degree(self):. 
+00011e80: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00011e90: 2020 2046 6f72 2065 6163 6820 6e6f 6465     For each node
+00011ea0: 2c20 7265 7475 726e 2074 6865 2061 7665  , return the ave
+00011eb0: 7261 6765 2064 6567 7265 6520 6f66 2069  rage degree of i
+00011ec0: 7473 206e 6569 6768 626f 7273 2e0a 0a20  ts neighbors... 
+00011ed0: 2020 2020 2020 2028 446f 6573 206e 6f74         (Does not
+00011ee0: 2075 7365 2064 6972 6563 7469 6f6e 616c   use directional
+00011ef0: 6974 7920 696e 666f 726d 6174 696f 6e2e  ity information.
+00011f00: 290a 0a20 2020 2020 2020 202a 2a45 7861  )..        **Exa
+00011f10: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+00011f20: 203e 3e3e 2072 284e 6574 776f 726b 2e53   >>> r(Network.S
+00011f30: 6d61 6c6c 5465 7374 4e65 7477 6f72 6b28  mallTestNetwork(
+00011f40: 292e 6176 6572 6167 655f 6e65 6967 6862  ).average_neighb
+00011f50: 6f72 735f 6465 6772 6565 2829 290a 2020  ors_degree()).  
+00011f60: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+00011f70: 6720 6176 6572 6167 6520 6e65 6967 6862  g average neighb
+00011f80: 6f75 7273 2720 6465 6772 6565 732e 2e2e  ours' degrees...
+00011f90: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+00011fa0: 2032 2e20 2c20 2032 2e33 3333 332c 2020   2. ,  2.3333,  
+00011fb0: 332e 202c 2033 2e20 2c20 2032 2e36 3636  3. , 3. ,  2.666
+00011fc0: 372c 2020 332e 205d 290a 0a20 2020 2020  7,  3. ])..     
+00011fd0: 2020 203a 7274 7970 653a 2031 6420 6e75     :rtype: 1d nu
+00011fe0: 6d70 7920 6172 7261 7920 5b6e 6f64 655d  mpy array [node]
+00011ff0: 206f 6620 666c 6f61 7473 203e 3d20 300a   of floats >= 0.
+00012000: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00012010: 2020 2020 6b20 3d20 7365 6c66 2e64 6567      k = self.deg
+00012020: 7265 6528 2920 2a20 312e 300a 2020 2020  ree() * 1.0.    
+00012030: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00012040: 756e 6469 7265 6374 6564 5f61 646a 6163  undirected_adjac
+00012050: 656e 6379 2829 202a 206b 202f 206b 5b6b  ency() * k / k[k
+00012060: 2021 3d20 305d 0a0a 2020 2020 4043 6163   != 0]..    @Cac
+00012070: 6865 642e 6d65 7468 6f64 286e 616d 653d  hed.method(name=
+00012080: 226d 6178 696d 756d 206e 6569 6768 626f  "maximum neighbo
+00012090: 7572 7327 2064 6567 7265 6573 2229 0a20  urs' degrees"). 
+000120a0: 2020 2064 6566 206d 6178 5f6e 6569 6768     def max_neigh
+000120b0: 626f 7273 5f64 6567 7265 6528 7365 6c66  bors_degree(self
+000120c0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+000120d0: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
+000120e0: 6e6f 6465 2c20 7265 7475 726e 2074 6865  node, return the
+000120f0: 206d 6178 696d 616c 2064 6567 7265 6520   maximal degree 
+00012100: 6f66 2069 7473 206e 6569 6768 626f 7273  of its neighbors
+00012110: 2e0a 0a20 2020 2020 2020 2028 446f 6573  ...        (Does
+00012120: 206e 6f74 2075 7365 2064 6972 6563 7469   not use directi
+00012130: 6f6e 616c 6974 7920 696e 666f 726d 6174  onality informat
+00012140: 696f 6e2e 290a 0a20 2020 2020 2020 202a  ion.)..        *
+00012150: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+00012160: 2020 2020 203e 3e3e 204e 6574 776f 726b       >>> Network
+00012170: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
+00012180: 6b28 292e 6d61 785f 6e65 6967 6862 6f72  k().max_neighbor
+00012190: 735f 6465 6772 6565 2829 0a20 2020 2020  s_degree().     
+000121a0: 2020 2043 616c 6375 6c61 7469 6e67 206d     Calculating m
+000121b0: 6178 696d 756d 206e 6569 6768 626f 7572  aximum neighbour
+000121c0: 7327 2064 6567 7265 652e 2e2e 0a20 2020  s' degree....   
+000121d0: 2020 2020 2061 7272 6179 285b 332c 2033       array([3, 3
+000121e0: 2c20 332c 2033 2c20 332c 2033 5d29 0a0a  , 3, 3, 3, 3])..
+000121f0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00012200: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
+00012210: 6e6f 6465 5d20 6f66 2069 6e74 7320 3e3d  node] of ints >=
+00012220: 2030 0a20 2020 2020 2020 2022 2222 0a20   0.        """. 
+00012230: 2020 2020 2020 206e 626b 7320 3d20 7365         nbks = se
+00012240: 6c66 2e75 6e64 6972 6563 7465 645f 6164  lf.undirected_ad
+00012250: 6a61 6365 6e63 7928 292e 6d75 6c74 6970  jacency().multip
+00012260: 6c79 2873 656c 662e 6465 6772 6565 2829  ly(self.degree()
+00012270: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00012280: 206e 626b 732e 6d61 7828 6178 6973 3d31   nbks.max(axis=1
+00012290: 292e 542e 412e 7371 7565 657a 6528 290a  ).T.A.squeeze().
+000122a0: 0a20 2020 2040 4361 6368 6564 2e6d 6574  .    @Cached.met
+000122b0: 686f 6428 6e61 6d65 3d22 6e2e 732e 692e  hod(name="n.s.i.
+000122c0: 2061 7665 7261 6765 206e 6569 6768 626f   average neighbo
+000122d0: 7572 7327 2064 6567 7265 6573 222c 0a20  urs' degrees",. 
+000122e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000122f0: 2020 6174 7472 733d 2822 5f6d 7574 5f6e    attrs=("_mut_n
+00012300: 7722 2c29 290a 2020 2020 6465 6620 6e73  w",)).    def ns
+00012310: 695f 6176 6572 6167 655f 6e65 6967 6862  i_average_neighb
+00012320: 6f72 735f 6465 6772 6565 2873 656c 6629  ors_degree(self)
+00012330: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00012340: 2020 2020 2020 466f 7220 6561 6368 206e        For each n
+00012350: 6f64 652c 2072 6574 7572 6e20 7468 6520  ode, return the 
+00012360: 6176 6572 6167 6520 6e2e 732e 692e 2064  average n.s.i. d
+00012370: 6567 7265 6520 6f66 2069 7473 206e 6569  egree of its nei
+00012380: 6768 626f 7273 2e0a 0a20 2020 2020 2020  ghbors...       
+00012390: 2028 6e6f 7420 7965 7420 696d 706c 656d   (not yet implem
+000123a0: 656e 7465 6420 666f 7220 6469 7265 6374  ented for direct
+000123b0: 6564 206e 6574 776f 726b 732e 290a 0a20  ed networks.).. 
+000123c0: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
+000123d0: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+000123e0: 206e 6574 203d 204e 6574 776f 726b 2e53   net = Network.S
+000123f0: 6d61 6c6c 5465 7374 4e65 7477 6f72 6b28  mallTestNetwork(
+00012400: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
+00012410: 6e65 742e 6e73 695f 6176 6572 6167 655f  net.nsi_average_
+00012420: 6e65 6967 6862 6f72 735f 6465 6772 6565  neighbors_degree
+00012430: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
+00012440: 756c 6174 696e 6720 6e2e 732e 692e 2061  ulating n.s.i. a
+00012450: 7665 7261 6765 206e 6569 6768 626f 7572  verage neighbour
+00012460: 7327 2064 6567 7265 652e 2e2e 0a20 2020  s' degree....   
+00012470: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+00012480: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
+00012490: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+000124a0: 5b20 362e 3034 3137 2c20 362e 3632 202c  [ 6.0417, 6.62 ,
+000124b0: 2037 2e30 3839 382c 2037 2e30 3433 342c   7.0898, 7.0434,
+000124c0: 2037 2e33 3535 342c 2035 2e36 3520 5d29   7.3554, 5.65 ])
+000124d0: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
+000124e0: 6574 2e73 706c 6974 7465 645f 636f 7079  et.splitted_copy
+000124f0: 2829 2e6e 7369 5f61 7665 7261 6765 5f6e  ().nsi_average_n
+00012500: 6569 6768 626f 7273 5f64 6567 7265 6528  eighbors_degree(
+00012510: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+00012520: 6c61 7469 6e67 206e 2e73 2e69 2e20 6176  lating n.s.i. av
+00012530: 6572 6167 6520 6e65 6967 6862 6f75 7273  erage neighbours
+00012540: 2720 6465 6772 6565 2e2e 2e0a 2020 2020  ' degree....    
+00012550: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+00012560: 6e2e 732e 692e 2064 6567 7265 652e 2e2e  n.s.i. degree...
+00012570: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+00012580: 2036 2e30 3431 372c 2036 2e36 3220 2c20   6.0417, 6.62 , 
+00012590: 372e 3038 3938 2c20 372e 3034 3334 2c20  7.0898, 7.0434, 
+000125a0: 372e 3335 3534 2c20 352e 3635 202c 2035  7.3554, 5.65 , 5
+000125b0: 2e36 3520 5d29 0a0a 2020 2020 2020 2020  .65 ])..        
+000125c0: 6173 2063 6f6d 7061 7265 6420 746f 2074  as compared to t
+000125d0: 6865 2075 6e77 6569 6768 7465 6420 7665  he unweighted ve
+000125e0: 7273 696f 6e3a 0a0a 2020 2020 2020 2020  rsion:..        
+000125f0: 3e3e 3e20 6e65 7420 3d20 4e65 7477 6f72  >>> net = Networ
+00012600: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
+00012610: 726b 2829 0a20 2020 2020 2020 203e 3e3e  rk().        >>>
+00012620: 2072 286e 6574 2e61 7665 7261 6765 5f6e   r(net.average_n
+00012630: 6569 6768 626f 7273 5f64 6567 7265 6528  eighbors_degree(
+00012640: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+00012650: 6c61 7469 6e67 2061 7665 7261 6765 206e  lating average n
+00012660: 6569 6768 626f 7572 7327 2064 6567 7265  eighbours' degre
+00012670: 6573 2e2e 2e0a 2020 2020 2020 2020 6172  es....        ar
+00012680: 7261 7928 5b20 322e 202c 2032 2e33 3333  ray([ 2. , 2.333
+00012690: 332c 2033 2e20 2c20 332e 202c 2032 2e36  3, 3. , 3. , 2.6
+000126a0: 3636 372c 2033 2e20 5d29 0a20 2020 2020  667, 3. ]).     
+000126b0: 2020 203e 3e3e 2072 286e 6574 2e73 706c     >>> r(net.spl
+000126c0: 6974 7465 645f 636f 7079 2829 2e61 7665  itted_copy().ave
+000126d0: 7261 6765 5f6e 6569 6768 626f 7273 5f64  rage_neighbors_d
+000126e0: 6567 7265 6528 2929 0a20 2020 2020 2020  egree()).       
+000126f0: 2043 616c 6375 6c61 7469 6e67 2061 7665   Calculating ave
+00012700: 7261 6765 206e 6569 6768 626f 7572 7327  rage neighbours'
+00012710: 2064 6567 7265 6573 2e2e 2e0a 2020 2020   degrees....    
+00012720: 2020 2020 6172 7261 7928 5b20 322e 3235      array([ 2.25
+00012730: 202c 2032 2e33 3333 332c 2033 2e20 2c20   , 2.3333, 3. , 
+00012740: 332e 3520 2c20 332e 202c 2033 2e20 2c20  3.5 , 3. , 3. , 
+00012750: 332e 205d 290a 0a20 2020 2020 2020 203a  3. ])..        :
+00012760: 7274 7970 653a 2031 6420 6e75 6d70 7920  rtype: 1d numpy 
+00012770: 6172 7261 7920 5b6e 6f64 655d 206f 6620  array [node] of 
+00012780: 666c 6f61 7473 203e 3d20 300a 2020 2020  floats >= 0.    
+00012790: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+000127a0: 6966 2073 656c 662e 6469 7265 6374 6564  if self.directed
+000127b0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+000127c0: 6973 6520 4e6f 7449 6d70 6c65 6d65 6e74  ise NotImplement
+000127d0: 6564 4572 726f 7228 224e 6f74 2069 6d70  edError("Not imp
+000127e0: 6c65 6d65 6e74 6564 2066 6f72 2064 6972  lemented for dir
+000127f0: 6563 7465 6420 6e65 7477 6f72 6b73 2e22  ected networks."
+00012800: 290a 0a20 2020 2020 2020 2023 2041 2b20  )..        # A+ 
+00012810: 2a20 2844 7720 2a20 6b29 2069 7320 6661  * (Dw * k) is fa
+00012820: 7374 6572 2074 6861 6e20 2841 2b20 2a20  ster than (A+ * 
+00012830: 4477 2920 2a20 6b0a 2020 2020 2020 2020  Dw) * k.        
+00012840: 6e73 695f 6b20 3d20 7365 6c66 2e6e 7369  nsi_k = self.nsi
+00012850: 5f64 6567 7265 6528 290a 2020 2020 2020  _degree().      
+00012860: 2020 7265 7475 726e 2073 656c 662e 7370    return self.sp
+00012870: 5f41 706c 7573 2829 202a 2028 7365 6c66  _Aplus() * (self
+00012880: 2e73 705f 6469 6167 5f77 2829 202a 206e  .sp_diag_w() * n
+00012890: 7369 5f6b 2920 2f20 6e73 695f 6b0a 2020  si_k) / nsi_k.  
+000128a0: 2020 2020 2020 2320 544f 444f 3a20 656e        # TODO: en
+000128b0: 6162 6c65 2063 6f72 7265 6374 696f 6e20  able correction 
+000128c0: 6279 2074 7970 6963 616c 5f77 6569 6768  by typical_weigh
+000128d0: 740a 0a20 2020 2040 4361 6368 6564 2e6d  t..    @Cached.m
+000128e0: 6574 686f 6428 6e61 6d65 3d22 6e2e 732e  ethod(name="n.s.
+000128f0: 692e 206d 6178 696d 756d 206e 6569 6768  i. maximum neigh
+00012900: 626f 7572 7327 2064 6567 7265 6573 222c  bours' degrees",
+00012910: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012920: 2020 2020 6174 7472 733d 2822 5f6d 7574      attrs=("_mut
+00012930: 5f6e 7722 2c29 290a 2020 2020 6465 6620  _nw",)).    def 
+00012940: 6e73 695f 6d61 785f 6e65 6967 6862 6f72  nsi_max_neighbor
+00012950: 735f 6465 6772 6565 2873 656c 6629 3a0a  s_degree(self):.
+00012960: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00012970: 2020 2020 466f 7220 6561 6368 206e 6f64      For each nod
+00012980: 652c 2072 6574 7572 6e20 7468 6520 6d61  e, return the ma
+00012990: 7869 6d61 6c20 6e2e 732e 692e 2064 6567  ximal n.s.i. deg
+000129a0: 7265 6520 6f66 2069 7473 206e 6569 6768  ree of its neigh
+000129b0: 626f 7273 2e0a 0a20 2020 2020 2020 2028  bors...        (
+000129c0: 6e6f 7420 7965 7420 696d 706c 656d 656e  not yet implemen
+000129d0: 7465 6420 666f 7220 6469 7265 6374 6564  ted for directed
+000129e0: 206e 6574 776f 726b 732e 290a 0a20 2020   networks.)..   
+000129f0: 2020 2020 202a 2a45 7861 6d70 6c65 3a2a       **Example:*
+00012a00: 2a0a 0a20 2020 2020 2020 203e 3e3e 204e  *..        >>> N
+00012a10: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
+00012a20: 4e65 7477 6f72 6b28 292e 6e73 695f 6d61  Network().nsi_ma
+00012a30: 785f 6e65 6967 6862 6f72 735f 6465 6772  x_neighbors_degr
+00012a40: 6565 2829 0a20 2020 2020 2020 2043 616c  ee().        Cal
+00012a50: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
+00012a60: 6d61 7869 6d75 6d20 6e65 6967 6862 6f75  maximum neighbou
+00012a70: 7220 6465 6772 6565 2e2e 2e0a 2020 2020  r degree....    
+00012a80: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+00012a90: 6e2e 732e 692e 2064 6567 7265 652e 2e2e  n.s.i. degree...
+00012aa0: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+00012ab0: 2038 2e34 2c20 2038 2e20 2c20 2038 2e20   8.4,  8. ,  8. 
+00012ac0: 2c20 2038 2e34 2c20 2038 2e34 2c20 2038  ,  8.4,  8.4,  8
+00012ad0: 2e34 5d29 0a0a 2020 2020 2020 2020 6173  .4])..        as
+00012ae0: 2063 6f6d 7061 7265 6420 746f 2074 6865   compared to the
+00012af0: 2075 6e77 6569 6768 7465 6420 7665 7273   unweighted vers
+00012b00: 696f 6e3a 0a0a 2020 2020 2020 2020 3e3e  ion:..        >>
+00012b10: 3e20 7072 696e 7428 4e65 7477 6f72 6b2e  > print(Network.
 00012b20: 536d 616c 6c54 6573 744e 6574 776f 726b  SmallTestNetwork
-00012b30: 2829 2e6c 6f63 616c 5f63 6c75 7374 6572  ().local_cluster
-00012b40: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
-00012b50: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
-00012b60: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-00012b70: 6669 6369 656e 7473 2e2e 2e0a 2020 2020  ficients....    
-00012b80: 2020 2020 6172 7261 7928 5b20 302e 202c      array([ 0. ,
-00012b90: 2030 2e33 3333 332c 2031 2e20 2c20 302e   0.3333, 1. , 0.
-00012ba0: 202c 2030 2e33 3333 332c 2030 2e20 5d29   , 0.3333, 0. ])
-00012bb0: 0a0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
-00012bc0: 3a20 3164 206e 756d 7079 2061 7272 6179  : 1d numpy array
-00012bd0: 205b 6e6f 6465 5d20 6f66 2066 6c6f 6174   [node] of float
-00012be0: 7320 6265 7477 6565 6e20 3020 616e 6420  s between 0 and 
-00012bf0: 310a 2020 2020 2020 2020 2222 220a 2020  1.        """.  
-00012c00: 2020 2020 2020 4320 3d20 6e70 2e61 7272        C = np.arr
-00012c10: 6179 2873 656c 662e 6772 6170 682e 7472  ay(self.graph.tr
-00012c20: 616e 7369 7469 7669 7479 5f6c 6f63 616c  ansitivity_local
-00012c30: 5f75 6e64 6972 6563 7465 6428 2929 0a20  _undirected()). 
-00012c40: 2020 2020 2020 2043 5b6e 702e 6973 6e61         C[np.isna
-00012c50: 6e28 4329 5d20 3d20 300a 2020 2020 2020  n(C)] = 0.      
-00012c60: 2020 7265 7475 726e 2043 0a0a 2020 2020    return C..    
-00012c70: 4063 6163 6865 645f 636f 6e73 7428 2762  @cached_const('b
-00012c80: 6173 6527 2c20 2767 6c6f 6261 6c20 636c  ase', 'global cl
-00012c90: 7573 7465 7269 6e67 272c 0a20 2020 2020  ustering',.     
-00012ca0: 2020 2020 2020 2020 2020 2020 2027 676c               'gl
-00012cb0: 6f62 616c 2063 6c75 7374 6572 696e 6720  obal clustering 
-00012cc0: 636f 6566 6669 6369 656e 7420 2843 5f32  coefficient (C_2
-00012cd0: 2927 290a 2020 2020 6465 6620 676c 6f62  )').    def glob
-00012ce0: 616c 5f63 6c75 7374 6572 696e 6728 7365  al_clustering(se
-00012cf0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-00012d00: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
-00012d10: 7468 6520 676c 6f62 616c 2028 5761 7474  the global (Watt
-00012d20: 732d 5374 726f 6761 747a 2920 636c 7573  s-Strogatz) clus
-00012d30: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
-00012d40: 6e74 2e0a 0a20 2020 2020 2020 2054 6869  nt...        Thi
-00012d50: 7320 6973 2074 6865 206d 6561 6e20 6f66  s is the mean of
-00012d60: 2074 6865 206c 6f63 616c 2063 6c75 7374   the local clust
-00012d70: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
-00012d80: 7473 2e20 5b4e 6577 6d61 6e32 3030 335d  ts. [Newman2003]
-00012d90: 5f0a 2020 2020 2020 2020 7265 6665 7273  _.        refers
-00012da0: 2074 6f20 7468 6973 206d 6561 7375 7265   to this measure
-00012db0: 2061 7320 435f 322e 0a0a 2020 2020 2020   as C_2...      
-00012dc0: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
-00012dd0: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
-00012de0: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-00012df0: 6574 776f 726b 2829 2e67 6c6f 6261 6c5f  etwork().global_
-00012e00: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
-00012e10: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-00012e20: 6720 676c 6f62 616c 2063 6c75 7374 6572  g global cluster
-00012e30: 696e 6720 636f 6566 6669 6369 656e 7420  ing coefficient 
-00012e40: 2843 5f32 292e 2e2e 0a20 2020 2020 2020  (C_2)....       
-00012e50: 2043 616c 6375 6c61 7469 6e67 206c 6f63   Calculating loc
-00012e60: 616c 2063 6c75 7374 6572 696e 6720 636f  al clustering co
-00012e70: 6566 6669 6369 656e 7473 2e2e 2e0a 2020  efficients....  
-00012e80: 2020 2020 2020 302e 3237 3738 0a0a 2020        0.2778..  
-00012e90: 2020 2020 2020 3a72 7479 7065 3a20 666c        :rtype: fl
-00012ea0: 6f61 7420 6265 7477 6565 6e20 3020 616e  oat between 0 an
-00012eb0: 6420 310a 2020 2020 2020 2020 2222 220a  d 1.        """.
-00012ec0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00012ed0: 656c 662e 6c6f 6361 6c5f 636c 7573 7465  elf.local_cluste
-00012ee0: 7269 6e67 2829 2e6d 6561 6e28 290a 0a20  ring().mean().. 
-00012ef0: 2020 2064 6566 205f 6d6f 7469 665f 636c     def _motif_cl
-00012f00: 7573 7465 7269 6e67 5f68 656c 7065 7228  ustering_helper(
-00012f10: 7365 6c66 2c20 745f 6675 6e63 2c20 542c  self, t_func, T,
-00012f20: 206b 6579 3d4e 6f6e 652c 206e 7369 3d46   key=None, nsi=F
-00012f30: 616c 7365 293a 0a20 2020 2020 2020 2022  alse):.        "
-00012f40: 2222 0a20 2020 2020 2020 2048 656c 7065  "".        Helpe
-00012f50: 7220 6675 6e63 7469 6f6e 2074 6f20 636f  r function to co
-00012f60: 6d70 7574 6520 7468 6520 6c6f 6361 6c20  mpute the local 
-00012f70: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
-00012f80: 2063 6f65 6666 6963 6965 6e74 732e 0a20   coefficients.. 
-00012f90: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
-00012fa0: 6e6f 6465 2c20 7265 7475 726e 7320 6120  node, returns a 
-00012fb0: 7370 6563 6966 6963 2063 6c75 7374 6572  specific cluster
-00012fc0: 696e 6720 636f 6566 6669 6369 656e 742c  ing coefficient,
-00012fd0: 2064 6570 656e 6469 6e67 0a20 2020 2020   depending.     
-00012fe0: 2020 206f 6e20 7468 6520 696e 7075 7420     on the input 
-00012ff0: 6172 6775 6d65 6e74 732e 0a0a 2020 2020  arguments...    
-00013000: 2020 2020 3a61 7267 2066 756e 6374 696f      :arg functio
-00013010: 6e20 745f 6675 6e63 3a20 6d75 6c74 6970  n t_func: multip
-00013020: 6c69 6361 7469 6f6e 206f 6620 6164 6a61  lication of adja
-00013030: 6365 6e63 792d 7479 7065 206d 6174 7269  cency-type matri
-00013040: 6365 730a 2020 2020 2020 2020 3a61 7267  ces.        :arg
-00013050: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
-00013060: 5b6e 6f64 655d 3a20 6465 6e6f 6d69 6e61  [node]: denomina
-00013070: 746f 7220 6d61 6465 206f 7574 206f 6620  tor made out of 
-00013080: 2869 6e2f 6f75 742f 6269 6c29 6465 6772  (in/out/bil)degr
-00013090: 6565 730a 2020 2020 2020 2020 3a61 7267  ees.        :arg
-000130a0: 2073 7472 206b 6579 3a20 6c69 6e6b 2061   str key: link a
-000130b0: 7474 7269 6275 7465 206b 6579 2028 6f70  ttribute key (op
-000130c0: 7469 6f6e 616c 290a 2020 2020 2020 2020  tional).        
-000130d0: 3a61 7267 2062 6f6f 6c20 6e73 693a 2066  :arg bool nsi: f
-000130e0: 6c61 6720 666f 7220 6e73 6920 6361 6c63  lag for nsi calc
-000130f0: 756c 6174 696f 6e20 2864 6566 6175 6c74  ulation (default
-00013100: 3a20 4661 6c73 6529 0a20 2020 2020 2020  : False).       
-00013110: 203a 7274 7970 653a 2031 6420 6e75 6d70   :rtype: 1d nump
-00013120: 7920 6172 7261 7920 5b6e 6f64 655d 206f  y array [node] o
-00013130: 6620 666c 6f61 7473 2062 6574 7765 656e  f floats between
-00013140: 2030 2061 6e64 2031 0a20 2020 2020 2020   0 and 1.       
-00013150: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
-00013160: 6e73 693a 0a20 2020 2020 2020 2020 2020  nsi:.           
-00013170: 206e 6f64 6577 203d 2073 702e 6373 635f   nodew = sp.csc_
-00013180: 6d61 7472 6978 286e 702e 6579 6528 7365  matrix(np.eye(se
-00013190: 6c66 2e4e 2920 2a20 7365 6c66 2e6e 6f64  lf.N) * self.nod
-000131a0: 655f 7765 6967 6874 7329 0a20 2020 2020  e_weights).     
-000131b0: 2020 2069 6620 6b65 7920 6973 204e 6f6e     if key is Non
-000131c0: 653a 0a20 2020 2020 2020 2020 2020 2041  e:.            A
-000131d0: 203d 2073 656c 662e 7370 5f41 706c 7573   = self.sp_Aplus
-000131e0: 2829 202a 206e 6f64 6577 2069 6620 6e73  () * nodew if ns
-000131f0: 6920 656c 7365 2073 656c 662e 7370 5f41  i else self.sp_A
-00013200: 0a20 2020 2020 2020 2020 2020 2041 5420  .            AT 
-00013210: 3d20 7365 6c66 2e73 705f 4170 6c75 7328  = self.sp_Aplus(
-00013220: 292e 5420 2a20 6e6f 6465 7720 6966 206e  ).T * nodew if n
-00013230: 7369 2065 6c73 6520 412e 540a 2020 2020  si else A.T.    
-00013240: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00013250: 2020 2020 2020 4d20 3d20 7370 2e63 7363        M = sp.csc
-00013260: 5f6d 6174 7269 7828 7365 6c66 2e6c 696e  _matrix(self.lin
-00013270: 6b5f 6174 7472 6962 7574 6528 6b65 7929  k_attribute(key)
-00013280: 2a2a 2831 2f33 2e29 290a 2020 2020 2020  **(1/3.)).      
-00013290: 2020 2020 2020 4120 3d20 4d20 2a20 6e6f        A = M * no
-000132a0: 6465 7720 6966 206e 7369 2065 6c73 6520  dew if nsi else 
-000132b0: 4d0a 2020 2020 2020 2020 2020 2020 4154  M.            AT
-000132c0: 203d 204d 2e54 202a 206e 6f64 6577 2069   = M.T * nodew i
-000132d0: 6620 6e73 6920 656c 7365 204d 2e54 0a0a  f nsi else M.T..
-000132e0: 2020 2020 2020 2020 7420 3d20 745f 6675          t = t_fu
-000132f0: 6e63 2841 2c20 4154 292e 6469 6167 6f6e  nc(A, AT).diagon
-00013300: 616c 2829 0a20 2020 2020 2020 2054 203d  al().        T =
-00013310: 2054 2e61 7374 7970 6528 666c 6f61 7429   T.astype(float)
-00013320: 0a20 2020 2020 2020 2054 5b54 203d 3d20  .        T[T == 
-00013330: 305d 203d 206e 702e 6e61 6e0a 2020 2020  0] = np.nan.    
-00013340: 2020 2020 4320 3d20 7420 2f20 2873 656c      C = t / (sel
-00013350: 662e 6e6f 6465 5f77 6569 6768 7473 202a  f.node_weights *
-00013360: 2054 2920 6966 206e 7369 2065 6c73 6520   T) if nsi else 
-00013370: 7420 2f20 540a 2020 2020 2020 2020 435b  t / T.        C[
-00013380: 6e70 2e69 736e 616e 2843 295d 203d 2030  np.isnan(C)] = 0
-00013390: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000133a0: 430a 0a20 2020 2040 6361 6368 6564 5f76  C..    @cached_v
-000133b0: 6172 2827 6c6f 6361 6c20 6379 636c 656d  ar('local cyclem
-000133c0: 6f74 6966 272c 2027 6c6f 6361 6c20 6379  otif', 'local cy
-000133d0: 636c 6520 6d6f 7469 6620 636c 7573 7465  cle motif cluste
-000133e0: 7269 6e67 2063 6f65 6666 6963 6965 6e74  ring coefficient
-000133f0: 2729 0a20 2020 2064 6566 206c 6f63 616c  ').    def local
-00013400: 5f63 7963 6c65 6d6f 7469 665f 636c 7573  _cyclemotif_clus
-00013410: 7465 7269 6e67 2873 656c 662c 206b 6579  tering(self, key
-00013420: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
-00013430: 2222 220a 2020 2020 2020 2020 466f 7220  """.        For 
-00013440: 6561 6368 206e 6f64 652c 2072 6574 7572  each node, retur
-00013450: 6e20 7468 6520 636c 7573 7465 7269 6e67  n the clustering
-00013460: 2063 6f65 6666 6963 6965 6e74 2077 6974   coefficient wit
-00013470: 6820 7265 7370 6563 7420 746f 2074 6865  h respect to the
-00013480: 0a20 2020 2020 2020 2063 7963 6c65 206d  .        cycle m
-00013490: 6f74 6966 2e0a 0a20 2020 2020 2020 2049  otif...        I
-000134a0: 6620 6120 6c69 6e6b 2061 7474 7269 6275  f a link attribu
-000134b0: 7465 206b 6579 2069 7320 7370 6563 6966  te key is specif
-000134c0: 6965 642c 2072 6574 7572 6e20 7468 6520  ied, return the 
-000134d0: 6173 736f 6369 6174 6564 206c 696e 6b0a  associated link.
-000134e0: 2020 2020 2020 2020 7765 6967 6874 6564          weighted
-000134f0: 2076 6572 7369 6f6e 0a0a 2020 2020 2020   version..      
-00013500: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
-00013510: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
-00013520: 7477 6f72 6b2e 536d 616c 6c44 6972 6563  twork.SmallDirec
-00013530: 7465 6454 6573 744e 6574 776f 726b 2829  tedTestNetwork()
-00013540: 2e6c 6f63 616c 5f63 7963 6c65 6d6f 7469  .local_cyclemoti
-00013550: 665f 636c 7573 7465 7269 6e67 2829 290a  f_clustering()).
-00013560: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-00013570: 696e 6720 6c6f 6361 6c20 6379 636c 6520  ing local cycle 
-00013580: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
-00013590: 2063 6f65 6666 6963 6965 6e74 2e2e 2e0a   coefficient....
-000135a0: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-000135b0: 302e 3235 2c20 2030 2e32 352c 2020 302e  0.25,  0.25,  0.
-000135c0: 2020 2c20 2030 2e20 202c 2020 302e 3520    ,  0.  ,  0.5 
-000135d0: 2c20 2030 2e20 205d 290a 0a20 2020 2020  ,  0.  ])..     
-000135e0: 2020 203a 6172 6720 7374 7220 6b65 793a     :arg str key:
-000135f0: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
-00013600: 6b65 7920 286f 7074 696f 6e61 6c29 0a20  key (optional). 
-00013610: 2020 2020 2020 203a 7274 7970 653a 2031         :rtype: 1
-00013620: 6420 6e75 6d70 7920 6172 7261 7920 5b6e  d numpy array [n
-00013630: 6f64 655d 206f 6620 666c 6f61 7473 2062  ode] of floats b
-00013640: 6574 7765 656e 2030 2061 6e64 2031 0a20  etween 0 and 1. 
-00013650: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00013660: 2020 2064 6566 2074 5f66 756e 6328 782c     def t_func(x,
-00013670: 2078 5429 3a0a 2020 2020 2020 2020 2020   xT):.          
-00013680: 2020 7265 7475 726e 2078 202a 2078 202a    return x * x *
-00013690: 2078 0a20 2020 2020 2020 2054 203d 2073   x.        T = s
-000136a0: 656c 662e 696e 6465 6772 6565 2829 202a  elf.indegree() *
-000136b0: 2073 656c 662e 6f75 7464 6567 7265 6528   self.outdegree(
-000136c0: 2920 2d20 7365 6c66 2e62 696c 6465 6772  ) - self.bildegr
-000136d0: 6565 2829 0a20 2020 2020 2020 2072 6574  ee().        ret
-000136e0: 7572 6e20 7365 6c66 2e5f 6d6f 7469 665f  urn self._motif_
-000136f0: 636c 7573 7465 7269 6e67 5f68 656c 7065  clustering_helpe
-00013700: 7228 745f 6675 6e63 2c20 542c 206b 6579  r(t_func, T, key
-00013710: 3d6b 6579 290a 0a20 2020 2040 6361 6368  =key)..    @cach
-00013720: 6564 5f76 6172 2827 6c6f 6361 6c20 6d69  ed_var('local mi
-00013730: 646d 6f74 6966 272c 2027 6c6f 6361 6c20  dmotif', 'local 
-00013740: 6d69 642e 206d 6f74 6966 2063 6c75 7374  mid. motif clust
-00013750: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
-00013760: 7427 290a 2020 2020 6465 6620 6c6f 6361  t').    def loca
-00013770: 6c5f 6d69 646d 6f74 6966 5f63 6c75 7374  l_midmotif_clust
-00013780: 6572 696e 6728 7365 6c66 2c20 6b65 793d  ering(self, key=
-00013790: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
-000137a0: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
-000137b0: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
-000137c0: 2074 6865 2063 6c75 7374 6572 696e 6720   the clustering 
-000137d0: 636f 6566 6669 6369 656e 7420 7769 7468  coefficient with
-000137e0: 2072 6573 7065 6374 2074 6f20 7468 650a   respect to the.
-000137f0: 2020 2020 2020 2020 6d69 642e 206d 6f74          mid. mot
-00013800: 6966 2e0a 0a20 2020 2020 2020 2049 6620  if...        If 
-00013810: 6120 6c69 6e6b 2061 7474 7269 6275 7465  a link attribute
-00013820: 206b 6579 2069 7320 7370 6563 6966 6965   key is specifie
-00013830: 642c 2072 6574 7572 6e20 7468 6520 6173  d, return the as
-00013840: 736f 6369 6174 6564 206c 696e 6b0a 2020  sociated link.  
-00013850: 2020 2020 2020 7765 6967 6874 6564 2076        weighted v
-00013860: 6572 7369 6f6e 0a0a 2020 2020 2020 2020  ersion..        
-00013870: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
-00013880: 2020 2020 2020 3e3e 3e20 7228 4e65 7477        >>> r(Netw
-00013890: 6f72 6b2e 536d 616c 6c44 6972 6563 7465  ork.SmallDirecte
-000138a0: 6454 6573 744e 6574 776f 726b 2829 2e6c  dTestNetwork().l
-000138b0: 6f63 616c 5f6d 6964 6d6f 7469 665f 636c  ocal_midmotif_cl
-000138c0: 7573 7465 7269 6e67 2829 290a 2020 2020  ustering()).    
-000138d0: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-000138e0: 6c6f 6361 6c20 6d69 642e 206d 6f74 6966  local mid. motif
-000138f0: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-00013900: 6669 6369 656e 742e 2e2e 0a20 2020 2020  ficient....     
-00013910: 2020 2061 7272 6179 285b 2030 2e20 2c20     array([ 0. , 
-00013920: 2030 2e20 2c20 2030 2e20 2c20 2031 2e20   0. ,  0. ,  1. 
-00013930: 2c20 2030 2e35 2c20 2030 2e20 5d29 0a0a  ,  0.5,  0. ])..
-00013940: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
-00013950: 206b 6579 3a20 6c69 6e6b 2061 7474 7269   key: link attri
-00013960: 6275 7465 206b 6579 2028 6f70 7469 6f6e  bute key (option
-00013970: 616c 290a 2020 2020 2020 2020 3a72 7479  al).        :rty
-00013980: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
-00013990: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
-000139a0: 6174 7320 6265 7477 6565 6e20 3020 616e  ats between 0 an
-000139b0: 6420 310a 2020 2020 2020 2020 2222 220a  d 1.        """.
-000139c0: 2020 2020 2020 2020 6465 6620 745f 6675          def t_fu
-000139d0: 6e63 2878 2c20 7854 293a 0a20 2020 2020  nc(x, xT):.     
-000139e0: 2020 2020 2020 2072 6574 7572 6e20 7820         return x 
-000139f0: 2a20 7854 202a 2078 0a20 2020 2020 2020  * xT * x.       
-00013a00: 2054 203d 2073 656c 662e 696e 6465 6772   T = self.indegr
-00013a10: 6565 2829 202a 2073 656c 662e 6f75 7464  ee() * self.outd
-00013a20: 6567 7265 6528 2920 2d20 7365 6c66 2e62  egree() - self.b
-00013a30: 696c 6465 6772 6565 2829 0a20 2020 2020  ildegree().     
-00013a40: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00013a50: 6d6f 7469 665f 636c 7573 7465 7269 6e67  motif_clustering
-00013a60: 5f68 656c 7065 7228 745f 6675 6e63 2c20  _helper(t_func, 
-00013a70: 542c 206b 6579 3d6b 6579 290a 0a20 2020  T, key=key)..   
-00013a80: 2040 6361 6368 6564 5f76 6172 2827 6c6f   @cached_var('lo
-00013a90: 6361 6c20 696e 6d6f 7469 6627 2c20 276c  cal inmotif', 'l
-00013aa0: 6f63 616c 2069 6e20 6d6f 7469 6620 636c  ocal in motif cl
-00013ab0: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
-00013ac0: 6965 6e74 2729 0a20 2020 2064 6566 206c  ient').    def l
-00013ad0: 6f63 616c 5f69 6e6d 6f74 6966 5f63 6c75  ocal_inmotif_clu
-00013ae0: 7374 6572 696e 6728 7365 6c66 2c20 6b65  stering(self, ke
-00013af0: 793d 4e6f 6e65 293a 0a20 2020 2020 2020  y=None):.       
-00013b00: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
-00013b10: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
-00013b20: 726e 2074 6865 2063 6c75 7374 6572 696e  rn the clusterin
-00013b30: 6720 636f 6566 6669 6369 656e 7420 7769  g coefficient wi
-00013b40: 7468 2072 6573 7065 6374 2074 6f20 7468  th respect to th
-00013b50: 650a 2020 2020 2020 2020 696e 206d 6f74  e.        in mot
-00013b60: 6966 2e0a 0a20 2020 2020 2020 2049 6620  if...        If 
-00013b70: 6120 6c69 6e6b 2061 7474 7269 6275 7465  a link attribute
-00013b80: 206b 6579 2069 7320 7370 6563 6966 6965   key is specifie
-00013b90: 642c 2072 6574 7572 6e20 7468 6520 6173  d, return the as
-00013ba0: 736f 6369 6174 6564 206c 696e 6b0a 2020  sociated link.  
-00013bb0: 2020 2020 2020 7765 6967 6874 6564 2076        weighted v
-00013bc0: 6572 7369 6f6e 0a0a 2020 2020 2020 2020  ersion..        
-00013bd0: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
-00013be0: 2020 2020 2020 3e3e 3e20 7228 4e65 7477        >>> r(Netw
-00013bf0: 6f72 6b2e 536d 616c 6c44 6972 6563 7465  ork.SmallDirecte
-00013c00: 6454 6573 744e 6574 776f 726b 2829 2e6c  dTestNetwork().l
-00013c10: 6f63 616c 5f69 6e6d 6f74 6966 5f63 6c75  ocal_inmotif_clu
-00013c20: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
-00013c30: 2020 2043 616c 6375 6c61 7469 6e67 206c     Calculating l
-00013c40: 6f63 616c 2069 6e20 6d6f 7469 6620 636c  ocal in motif cl
-00013c50: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
-00013c60: 6965 6e74 2e2e 2e0a 2020 2020 2020 2020  ient....        
-00013c70: 6172 7261 7928 5b20 302e 202c 2020 302e  array([ 0. ,  0.
-00013c80: 352c 2020 302e 352c 2020 302e 202c 2020  5,  0.5,  0. ,  
-00013c90: 302e 202c 2020 302e 205d 290a 0a20 2020  0. ,  0. ])..   
-00013ca0: 2020 2020 203a 6172 6720 7374 7220 6b65       :arg str ke
-00013cb0: 793a 206c 696e 6b20 6174 7472 6962 7574  y: link attribut
-00013cc0: 6520 6b65 7920 286f 7074 696f 6e61 6c29  e key (optional)
-00013cd0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-00013ce0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
-00013cf0: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
-00013d00: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
-00013d10: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00013d20: 2020 2020 2064 6566 2074 5f66 756e 6328       def t_func(
-00013d30: 782c 2078 5429 3a0a 2020 2020 2020 2020  x, xT):.        
-00013d40: 2020 2020 7265 7475 726e 2078 5420 2a20      return xT * 
-00013d50: 7820 2a20 780a 2020 2020 2020 2020 5420  x * x.        T 
-00013d60: 3d20 7365 6c66 2e69 6e64 6567 7265 6528  = self.indegree(
-00013d70: 2920 2a20 2873 656c 662e 696e 6465 6772  ) * (self.indegr
-00013d80: 6565 2829 202d 2031 290a 2020 2020 2020  ee() - 1).      
-00013d90: 2020 7265 7475 726e 2073 656c 662e 5f6d    return self._m
-00013da0: 6f74 6966 5f63 6c75 7374 6572 696e 675f  otif_clustering_
-00013db0: 6865 6c70 6572 2874 5f66 756e 632c 2054  helper(t_func, T
-00013dc0: 2c20 6b65 793d 6b65 7929 0a0a 2020 2020  , key=key)..    
-00013dd0: 4063 6163 6865 645f 7661 7228 276c 6f63  @cached_var('loc
-00013de0: 616c 206f 7574 6d6f 7469 6627 2c20 276c  al outmotif', 'l
-00013df0: 6f63 616c 206f 7574 206d 6f74 6966 2063  ocal out motif c
-00013e00: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
-00013e10: 6369 656e 7427 290a 2020 2020 6465 6620  cient').    def 
-00013e20: 6c6f 6361 6c5f 6f75 746d 6f74 6966 5f63  local_outmotif_c
-00013e30: 6c75 7374 6572 696e 6728 7365 6c66 2c20  lustering(self, 
-00013e40: 6b65 793d 4e6f 6e65 293a 0a20 2020 2020  key=None):.     
-00013e50: 2020 2022 2222 0a20 2020 2020 2020 2046     """.        F
-00013e60: 6f72 2065 6163 6820 6e6f 6465 2c20 7265  or each node, re
-00013e70: 7475 726e 2074 6865 2063 6c75 7374 6572  turn the cluster
-00013e80: 696e 6720 636f 6566 6669 6369 656e 7420  ing coefficient 
-00013e90: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-00013ea0: 7468 650a 2020 2020 2020 2020 6f75 7420  the.        out 
-00013eb0: 6d6f 7469 662e 0a0a 2020 2020 2020 2020  motif...        
-00013ec0: 4966 2061 206c 696e 6b20 6174 7472 6962  If a link attrib
-00013ed0: 7574 6520 6b65 7920 6973 2073 7065 6369  ute key is speci
-00013ee0: 6669 6564 2c20 7265 7475 726e 2074 6865  fied, return the
-00013ef0: 2061 7373 6f63 6961 7465 6420 6c69 6e6b   associated link
-00013f00: 0a20 2020 2020 2020 2077 6569 6768 7465  .        weighte
-00013f10: 6420 7665 7273 696f 6e0a 0a20 2020 2020  d version..     
-00013f20: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
-00013f30: 0a20 2020 2020 2020 203e 3e3e 2072 284e  .        >>> r(N
-00013f40: 6574 776f 726b 2e53 6d61 6c6c 4469 7265  etwork.SmallDire
-00013f50: 6374 6564 5465 7374 4e65 7477 6f72 6b28  ctedTestNetwork(
-00013f60: 292e 6c6f 6361 6c5f 6f75 746d 6f74 6966  ).local_outmotif
-00013f70: 5f63 6c75 7374 6572 696e 6728 2929 0a20  _clustering()). 
-00013f80: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-00013f90: 6e67 206c 6f63 616c 206f 7574 206d 6f74  ng local out mot
-00013fa0: 6966 2063 6c75 7374 6572 696e 6720 636f  if clustering co
-00013fb0: 6566 6669 6369 656e 742e 2e2e 0a20 2020  efficient....   
-00013fc0: 2020 2020 2061 7272 6179 285b 2030 2e35       array([ 0.5
-00013fd0: 2c20 2030 2e35 2c20 2030 2e20 2c20 2030  ,  0.5,  0. ,  0
-00013fe0: 2e20 2c20 2030 2e20 2c20 2030 2e20 5d29  . ,  0. ,  0. ])
-00013ff0: 0a0a 2020 2020 2020 2020 3a61 7267 2073  ..        :arg s
-00014000: 7472 206b 6579 3a20 6c69 6e6b 2061 7474  tr key: link att
-00014010: 7269 6275 7465 206b 6579 2028 6f70 7469  ribute key (opti
-00014020: 6f6e 616c 290a 2020 2020 2020 2020 3a72  onal).        :r
-00014030: 7479 7065 3a20 3164 206e 756d 7079 2061  type: 1d numpy a
-00014040: 7272 6179 205b 6e6f 6465 5d20 6f66 2066  rray [node] of f
-00014050: 6c6f 6174 7320 6265 7477 6565 6e20 3020  loats between 0 
-00014060: 616e 6420 310a 2020 2020 2020 2020 2222  and 1.        ""
-00014070: 220a 2020 2020 2020 2020 6465 6620 745f  ".        def t_
-00014080: 6675 6e63 2878 2c20 7854 293a 0a20 2020  func(x, xT):.   
-00014090: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000140a0: 7820 2a20 7820 2a20 7854 0a20 2020 2020  x * x * xT.     
-000140b0: 2020 2054 203d 2073 656c 662e 6f75 7464     T = self.outd
-000140c0: 6567 7265 6528 2920 2a20 2873 656c 662e  egree() * (self.
-000140d0: 6f75 7464 6567 7265 6528 2920 2d20 3129  outdegree() - 1)
-000140e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000140f0: 7365 6c66 2e5f 6d6f 7469 665f 636c 7573  self._motif_clus
-00014100: 7465 7269 6e67 5f68 656c 7065 7228 745f  tering_helper(t_
-00014110: 6675 6e63 2c20 542c 206b 6579 3d6b 6579  func, T, key=key
-00014120: 290a 0a20 2020 2040 6361 6368 6564 5f76  )..    @cached_v
-00014130: 6172 2827 6e73 6920 6c6f 6361 6c20 6379  ar('nsi local cy
-00014140: 636c 656d 6f74 6966 272c 0a20 2020 2020  clemotif',.     
-00014150: 2020 2020 2020 2020 2020 2027 6c6f 6361             'loca
-00014160: 6c20 6e73 6920 6379 636c 6520 6d6f 7469  l nsi cycle moti
-00014170: 6620 636c 7573 7465 7269 6e67 2063 6f65  f clustering coe
-00014180: 6666 6963 6965 6e74 2729 0a20 2020 2064  fficient').    d
-00014190: 6566 206e 7369 5f6c 6f63 616c 5f63 7963  ef nsi_local_cyc
-000141a0: 6c65 6d6f 7469 665f 636c 7573 7465 7269  lemotif_clusteri
-000141b0: 6e67 2873 656c 662c 206b 6579 3d4e 6f6e  ng(self, key=Non
-000141c0: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
-000141d0: 2020 2020 2020 2020 466f 7220 6561 6368          For each
-000141e0: 206e 6f64 652c 2072 6574 7572 6e20 7468   node, return th
-000141f0: 6520 6e73 6920 636c 7573 7465 7269 6e67  e nsi clustering
-00014200: 2063 6f65 6666 6963 6965 6e74 2077 6974   coefficient wit
-00014210: 6820 7265 7370 6563 7420 746f 0a20 2020  h respect to.   
-00014220: 2020 2020 2074 6865 2063 7963 6c65 206d       the cycle m
-00014230: 6f74 6966 2e0a 0a20 2020 2020 2020 2049  otif...        I
-00014240: 6620 6120 6c69 6e6b 2061 7474 7269 6275  f a link attribu
-00014250: 7465 206b 6579 2069 7320 7370 6563 6966  te key is specif
-00014260: 6965 642c 2072 6574 7572 6e20 7468 6520  ied, return the 
-00014270: 6173 736f 6369 6174 6564 206c 696e 6b0a  associated link.
-00014280: 2020 2020 2020 2020 7765 6967 6874 6564          weighted
-00014290: 2076 6572 7369 6f6e 0a0a 2020 2020 2020   version..      
-000142a0: 2020 5265 6665 7265 6e63 653a 205b 5a65    Reference: [Ze
-000142b0: 6d70 3230 3134 5d5f 0a0a 2020 2020 2020  mp2014]_..      
-000142c0: 2020 2a2a 4578 616d 706c 6573 3a2a 2a0a    **Examples:**.
-000142d0: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
-000142e0: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
-000142f0: 4469 7265 6374 6564 5465 7374 4e65 7477  DirectedTestNetw
-00014300: 6f72 6b28 290a 2020 2020 2020 2020 3e3e  ork().        >>
-00014310: 3e20 7228 6e65 742e 6e73 695f 6c6f 6361  > r(net.nsi_loca
-00014320: 6c5f 6379 636c 656d 6f74 6966 5f63 6c75  l_cyclemotif_clu
-00014330: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
-00014340: 2020 2043 616c 6375 6c61 7469 6e67 206c     Calculating l
-00014350: 6f63 616c 206e 7369 2063 7963 6c65 206d  ocal nsi cycle m
-00014360: 6f74 6966 2063 6c75 7374 6572 696e 6720  otif clustering 
-00014370: 636f 6566 6669 6369 656e 742e 2e2e 0a20  coefficient.... 
-00014380: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
-00014390: 2e31 3834 352c 2020 302e 3230 3238 2c20  .1845,  0.2028, 
-000143a0: 2030 2e33 3232 202c 2020 302e 3332 3234   0.322 ,  0.3224
-000143b0: 2c20 2030 2e33 3433 392c 2020 302e 3632  ,  0.3439,  0.62
-000143c0: 3520 5d29 0a20 2020 2020 2020 203e 3e3e  5 ]).        >>>
-000143d0: 2072 286e 6574 2e73 706c 6974 7465 645f   r(net.splitted_
-000143e0: 636f 7079 286e 6f64 653d 3129 2e6e 7369  copy(node=1).nsi
-000143f0: 5f6c 6f63 616c 5f63 7963 6c65 6d6f 7469  _local_cyclemoti
-00014400: 665f 636c 7573 7465 7269 6e67 2829 290a  f_clustering()).
-00014410: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-00014420: 696e 6720 6c6f 6361 6c20 6e73 6920 6379  ing local nsi cy
-00014430: 636c 6520 6d6f 7469 6620 636c 7573 7465  cle motif cluste
-00014440: 7269 6e67 2063 6f65 6666 6963 6965 6e74  ring coefficient
-00014450: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-00014460: 7928 5b20 302e 3138 3435 2c20 2030 2e32  y([ 0.1845,  0.2
-00014470: 3032 382c 2020 302e 3332 3220 2c20 2030  028,  0.322 ,  0
-00014480: 2e33 3232 342c 2020 302e 3334 3339 2c20  .3224,  0.3439, 
-00014490: 2030 2e36 3235 202c 2020 302e 3230 3238   0.625 ,  0.2028
-000144a0: 5d29 0a0a 2020 2020 2020 2020 6173 2063  ])..        as c
-000144b0: 6f6d 7061 7265 6420 746f 2074 6865 2075  ompared to the u
-000144c0: 6e77 6569 6768 7465 6420 7665 7273 696f  nweighted versio
-000144d0: 6e3a 0a0a 2020 2020 2020 2020 3e3e 3e20  n:..        >>> 
-000144e0: 6e65 7420 3d20 4e65 7477 6f72 6b2e 536d  net = Network.Sm
-000144f0: 616c 6c44 6972 6563 7465 6454 6573 744e  allDirectedTestN
-00014500: 6574 776f 726b 2829 0a20 2020 2020 2020  etwork().       
-00014510: 203e 3e3e 2072 286e 6574 2e6c 6f63 616c   >>> r(net.local
-00014520: 5f63 7963 6c65 6d6f 7469 665f 636c 7573  _cyclemotif_clus
-00014530: 7465 7269 6e67 2829 290a 2020 2020 2020  tering()).      
-00014540: 2020 4361 6c63 756c 6174 696e 6720 6c6f    Calculating lo
-00014550: 6361 6c20 6379 636c 6520 6d6f 7469 6620  cal cycle motif 
-00014560: 636c 7573 7465 7269 6e67 2063 6f65 6666  clustering coeff
-00014570: 6963 6965 6e74 2e2e 2e0a 2020 2020 2020  icient....      
-00014580: 2020 6172 7261 7928 5b20 302e 3235 2c20    array([ 0.25, 
-00014590: 2030 2e32 352c 2020 302e 2020 2c20 2030   0.25,  0.  ,  0
-000145a0: 2e20 202c 2020 302e 3520 2c20 2030 2e20  .  ,  0.5 ,  0. 
-000145b0: 205d 290a 2020 2020 2020 2020 3e3e 3e20   ]).        >>> 
-000145c0: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
-000145d0: 6f70 7928 6e6f 6465 3d31 292e 6c6f 6361  opy(node=1).loca
-000145e0: 6c5f 6379 636c 656d 6f74 6966 5f63 6c75  l_cyclemotif_clu
-000145f0: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
-00014600: 2020 2043 616c 6375 6c61 7469 6e67 206c     Calculating l
-00014610: 6f63 616c 2063 7963 6c65 206d 6f74 6966  ocal cycle motif
-00014620: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-00014630: 6669 6369 656e 742e 2e2e 0a20 2020 2020  ficient....     
-00014640: 2020 2061 7272 6179 285b 2030 2e33 3333     array([ 0.333
-00014650: 332c 2020 302e 3132 3520 2c20 2030 2e20  3,  0.125 ,  0. 
-00014660: 2020 202c 2020 302e 2020 2020 2c20 2030     ,  0.    ,  0
-00014670: 2e35 2020 202c 2020 302e 2020 2020 2c20  .5   ,  0.    , 
-00014680: 2030 2e31 3235 205d 290a 0a20 2020 2020   0.125 ])..     
-00014690: 2020 203a 6172 6720 7374 7220 6b65 793a     :arg str key:
-000146a0: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
-000146b0: 6b65 7920 286f 7074 696f 6e61 6c29 0a20  key (optional). 
-000146c0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-000146d0: 2020 2064 6566 2074 5f66 756e 6328 782c     def t_func(x,
-000146e0: 2078 5429 3a0a 2020 2020 2020 2020 2020   xT):.          
-000146f0: 2020 7265 7475 726e 2078 202a 2078 202a    return x * x *
-00014700: 2078 0a20 2020 2020 2020 2054 203d 2073   x.        T = s
-00014710: 656c 662e 6e73 695f 696e 6465 6772 6565  elf.nsi_indegree
-00014720: 2829 202a 2073 656c 662e 6e73 695f 6f75  () * self.nsi_ou
-00014730: 7464 6567 7265 6528 290a 2020 2020 2020  tdegree().      
-00014740: 2020 7265 7475 726e 2073 656c 662e 5f6d    return self._m
-00014750: 6f74 6966 5f63 6c75 7374 6572 696e 675f  otif_clustering_
-00014760: 6865 6c70 6572 2874 5f66 756e 632c 2054  helper(t_func, T
-00014770: 2c20 6b65 793d 6b65 792c 206e 7369 3d54  , key=key, nsi=T
-00014780: 7275 6529 0a0a 2020 2020 4063 6163 6865  rue)..    @cache
-00014790: 645f 7661 7228 276e 7369 206c 6f63 616c  d_var('nsi local
-000147a0: 206d 6964 656d 6f74 6966 272c 0a20 2020   midemotif',.   
-000147b0: 2020 2020 2020 2020 2020 2020 2027 6c6f               'lo
-000147c0: 6361 6c20 6e73 6920 6d69 642e 206d 6f74  cal nsi mid. mot
-000147d0: 6966 2063 6c75 7374 6572 696e 6720 636f  if clustering co
-000147e0: 6566 6669 6369 656e 7427 290a 2020 2020  efficient').    
-000147f0: 6465 6620 6e73 695f 6c6f 6361 6c5f 6d69  def nsi_local_mi
-00014800: 646d 6f74 6966 5f63 6c75 7374 6572 696e  dmotif_clusterin
-00014810: 6728 7365 6c66 2c20 6b65 793d 4e6f 6e65  g(self, key=None
-00014820: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00014830: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
-00014840: 6e6f 6465 2c20 7265 7475 726e 2074 6865  node, return the
-00014850: 206e 7369 2063 6c75 7374 6572 696e 6720   nsi clustering 
-00014860: 636f 6566 6669 6369 656e 7420 7769 7468  coefficient with
-00014870: 2072 6573 7065 6374 2074 6f0a 2020 2020   respect to.    
-00014880: 2020 2020 7468 6520 6d69 6420 6d6f 7469      the mid moti
-00014890: 662e 0a0a 2020 2020 2020 2020 4966 2061  f...        If a
-000148a0: 206c 696e 6b20 6174 7472 6962 7574 6520   link attribute 
-000148b0: 6b65 7920 6973 2073 7065 6369 6669 6564  key is specified
-000148c0: 2c20 7265 7475 726e 2074 6865 2061 7373  , return the ass
-000148d0: 6f63 6961 7465 6420 6c69 6e6b 0a20 2020  ociated link.   
-000148e0: 2020 2020 2077 6569 6768 7465 6420 7665       weighted ve
-000148f0: 7273 696f 6e0a 0a20 2020 2020 2020 2052  rsion..        R
-00014900: 6566 6572 656e 6365 3a20 5b5a 656d 7032  eference: [Zemp2
-00014910: 3031 345d 5f0a 0a20 2020 2020 2020 202a  014]_..        *
-00014920: 2a45 7861 6d70 6c65 733a 2a2a 0a0a 2020  *Examples:**..  
-00014930: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
-00014940: 4e65 7477 6f72 6b2e 536d 616c 6c44 6972  Network.SmallDir
-00014950: 6563 7465 6454 6573 744e 6574 776f 726b  ectedTestNetwork
-00014960: 2829 0a20 2020 2020 2020 203e 3e3e 2072  ().        >>> r
-00014970: 286e 6574 2e6e 7369 5f6c 6f63 616c 5f6d  (net.nsi_local_m
-00014980: 6964 6d6f 7469 665f 636c 7573 7465 7269  idmotif_clusteri
-00014990: 6e67 2829 290a 2020 2020 2020 2020 4361  ng()).        Ca
-000149a0: 6c63 756c 6174 696e 6720 6c6f 6361 6c20  lculating local 
-000149b0: 6e73 6920 6d69 642e 206d 6f74 6966 2063  nsi mid. motif c
-000149c0: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
-000149d0: 6369 656e 742e 2e2e 0a20 2020 2020 2020  cient....       
-000149e0: 2061 7272 6179 285b 2030 2e34 3533 372c   array([ 0.4537,
-000149f0: 2020 302e 3531 3635 2c20 2031 2e20 2020    0.5165,  1.   
-00014a00: 202c 2020 312e 2020 2020 2c20 2030 2e38   ,  1.    ,  0.8
-00014a10: 3838 322c 2020 312e 2020 2020 5d29 0a20  882,  1.    ]). 
-00014a20: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
-00014a30: 2e73 706c 6974 7465 645f 636f 7079 286e  .splitted_copy(n
-00014a40: 6f64 653d 3429 2e6e 7369 5f6c 6f63 616c  ode=4).nsi_local
-00014a50: 5f6d 6964 6d6f 7469 665f 636c 7573 7465  _midmotif_cluste
-00014a60: 7269 6e67 2829 290a 2020 2020 2020 2020  ring()).        
-00014a70: 4361 6c63 756c 6174 696e 6720 6c6f 6361  Calculating loca
-00014a80: 6c20 6e73 6920 6d69 642e 206d 6f74 6966  l nsi mid. motif
-00014a90: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-00014aa0: 6669 6369 656e 742e 2e2e 0a20 2020 2020  ficient....     
-00014ab0: 2020 2061 7272 6179 285b 2030 2e34 3533     array([ 0.453
-00014ac0: 372c 2020 302e 3531 3635 2c20 2031 2e20  7,  0.5165,  1. 
-00014ad0: 2020 202c 2020 312e 2020 2020 2c20 2030     ,  1.    ,  0
-00014ae0: 2e38 3838 322c 2020 312e 2020 2020 2c20  .8882,  1.    , 
-00014af0: 2030 2e38 3838 325d 290a 0a20 2020 2020   0.8882])..     
-00014b00: 2020 2061 7320 636f 6d70 6172 6564 2074     as compared t
-00014b10: 6f20 7468 6520 756e 7765 6967 6874 6564  o the unweighted
-00014b20: 2076 6572 7369 6f6e 3a0a 0a20 2020 2020   version:..     
-00014b30: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
-00014b40: 776f 726b 2e53 6d61 6c6c 4469 7265 6374  work.SmallDirect
-00014b50: 6564 5465 7374 4e65 7477 6f72 6b28 290a  edTestNetwork().
-00014b60: 2020 2020 2020 2020 3e3e 3e20 7228 6e65          >>> r(ne
-00014b70: 742e 6c6f 6361 6c5f 6d69 646d 6f74 6966  t.local_midmotif
-00014b80: 5f63 6c75 7374 6572 696e 6728 2929 0a20  _clustering()). 
-00014b90: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-00014ba0: 6e67 206c 6f63 616c 206d 6964 2e20 6d6f  ng local mid. mo
-00014bb0: 7469 6620 636c 7573 7465 7269 6e67 2063  tif clustering c
-00014bc0: 6f65 6666 6963 6965 6e74 2e2e 2e0a 2020  oefficient....  
-00014bd0: 2020 2020 2020 6172 7261 7928 5b20 302e        array([ 0.
-00014be0: 202c 2020 302e 202c 2020 302e 202c 2020   ,  0. ,  0. ,  
-00014bf0: 312e 202c 2020 302e 352c 2020 302e 205d  1. ,  0.5,  0. ]
-00014c00: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
-00014c10: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
-00014c20: 7928 6e6f 6465 3d34 292e 6c6f 6361 6c5f  y(node=4).local_
-00014c30: 6d69 646d 6f74 6966 5f63 6c75 7374 6572  midmotif_cluster
-00014c40: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
-00014c50: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
-00014c60: 206d 6964 2e20 6d6f 7469 6620 636c 7573   mid. motif clus
-00014c70: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
-00014c80: 6e74 2e2e 2e0a 2020 2020 2020 2020 6172  nt....        ar
-00014c90: 7261 7928 5b20 302e 202c 2020 302e 202c  ray([ 0. ,  0. ,
-00014ca0: 2020 302e 202c 2020 312e 202c 2020 302e    0. ,  1. ,  0.
-00014cb0: 382c 2020 302e 202c 2020 302e 385d 290a  8,  0. ,  0.8]).
-00014cc0: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
-00014cd0: 7220 6b65 793a 206c 696e 6b20 6174 7472  r key: link attr
-00014ce0: 6962 7574 6520 6b65 7920 286f 7074 696f  ibute key (optio
-00014cf0: 6e61 6c29 0a20 2020 2020 2020 2022 2222  nal).        """
-00014d00: 0a20 2020 2020 2020 2064 6566 2074 5f66  .        def t_f
-00014d10: 756e 6328 782c 2078 5429 3a0a 2020 2020  unc(x, xT):.    
-00014d20: 2020 2020 2020 2020 7265 7475 726e 2078          return x
-00014d30: 202a 2078 5420 2a20 780a 2020 2020 2020   * xT * x.      
-00014d40: 2020 5420 3d20 7365 6c66 2e6e 7369 5f69    T = self.nsi_i
-00014d50: 6e64 6567 7265 6528 2920 2a20 7365 6c66  ndegree() * self
-00014d60: 2e6e 7369 5f6f 7574 6465 6772 6565 2829  .nsi_outdegree()
-00014d70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00014d80: 7365 6c66 2e5f 6d6f 7469 665f 636c 7573  self._motif_clus
-00014d90: 7465 7269 6e67 5f68 656c 7065 7228 745f  tering_helper(t_
-00014da0: 6675 6e63 2c20 542c 206b 6579 3d6b 6579  func, T, key=key
-00014db0: 2c20 6e73 693d 5472 7565 290a 0a20 2020  , nsi=True)..   
-00014dc0: 2040 6361 6368 6564 5f76 6172 2827 6e73   @cached_var('ns
-00014dd0: 6920 6c6f 6361 6c20 696e 656d 6f74 6966  i local inemotif
-00014de0: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-00014df0: 2020 2027 6c6f 6361 6c20 6e73 6920 696e     'local nsi in
-00014e00: 206d 6f74 6966 2063 6c75 7374 6572 696e   motif clusterin
-00014e10: 6720 636f 6566 6669 6369 656e 7427 290a  g coefficient').
-00014e20: 2020 2020 6465 6620 6e73 695f 6c6f 6361      def nsi_loca
-00014e30: 6c5f 696e 6d6f 7469 665f 636c 7573 7465  l_inmotif_cluste
-00014e40: 7269 6e67 2873 656c 662c 206b 6579 3d4e  ring(self, key=N
-00014e50: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
-00014e60: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-00014e70: 6368 206e 6f64 652c 2072 6574 7572 6e20  ch node, return 
-00014e80: 7468 6520 6e73 6920 636c 7573 7465 7269  the nsi clusteri
-00014e90: 6e67 2063 6f65 6666 6963 6965 6e74 2077  ng coefficient w
-00014ea0: 6974 6820 7265 7370 6563 7420 746f 0a20  ith respect to. 
-00014eb0: 2020 2020 2020 2074 6865 2069 6e20 6d6f         the in mo
-00014ec0: 7469 662e 0a0a 2020 2020 2020 2020 4966  tif...        If
-00014ed0: 2061 206c 696e 6b20 6174 7472 6962 7574   a link attribut
-00014ee0: 6520 6b65 7920 6973 2073 7065 6369 6669  e key is specifi
-00014ef0: 6564 2c20 7265 7475 726e 2074 6865 2061  ed, return the a
-00014f00: 7373 6f63 6961 7465 6420 6c69 6e6b 0a20  ssociated link. 
-00014f10: 2020 2020 2020 2077 6569 6768 7465 6420         weighted 
-00014f20: 7665 7273 696f 6e0a 0a20 2020 2020 2020  version..       
-00014f30: 2052 6566 6572 656e 6365 3a20 5b5a 656d   Reference: [Zem
-00014f40: 7032 3031 345d 5f0a 0a20 2020 2020 2020  p2014]_..       
-00014f50: 202a 2a45 7861 6d70 6c65 733a 2a2a 0a0a   **Examples:**..
-00014f60: 2020 2020 2020 2020 3e3e 3e20 6e65 7420          >>> net 
-00014f70: 3d20 4e65 7477 6f72 6b2e 536d 616c 6c44  = Network.SmallD
-00014f80: 6972 6563 7465 6454 6573 744e 6574 776f  irectedTestNetwo
-00014f90: 726b 2829 0a20 2020 2020 2020 203e 3e3e  rk().        >>>
-00014fa0: 2072 286e 6574 2e6e 7369 5f6c 6f63 616c   r(net.nsi_local
-00014fb0: 5f69 6e6d 6f74 6966 5f63 6c75 7374 6572  _inmotif_cluster
-00014fc0: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
-00014fd0: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
-00014fe0: 206e 7369 2069 6e20 6d6f 7469 6620 636c   nsi in motif cl
-00014ff0: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
-00015000: 6965 6e74 2e2e 2e0a 2020 2020 2020 2020  ient....        
-00015010: 6172 7261 7928 5b20 302e 3532 3838 2c20  array([ 0.5288, 
-00015020: 2030 2e36 3720 202c 2020 302e 3636 3933   0.67  ,  0.6693
-00015030: 2c20 2030 2e37 3536 392c 2020 302e 3735  ,  0.7569,  0.75
-00015040: 3536 2c20 2031 2e20 2020 205d 290a 2020  56,  1.    ]).  
-00015050: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
-00015060: 7370 6c69 7474 6564 5f63 6f70 7928 6e6f  splitted_copy(no
-00015070: 6465 3d31 292e 6e73 695f 6c6f 6361 6c5f  de=1).nsi_local_
-00015080: 696e 6d6f 7469 665f 636c 7573 7465 7269  inmotif_clusteri
-00015090: 6e67 2829 290a 2020 2020 2020 2020 4361  ng()).        Ca
-000150a0: 6c63 756c 6174 696e 6720 6c6f 6361 6c20  lculating local 
-000150b0: 6e73 6920 696e 206d 6f74 6966 2063 6c75  nsi in motif clu
-000150c0: 7374 6572 696e 6720 636f 6566 6669 6369  stering coeffici
-000150d0: 656e 742e 2e2e 0a20 2020 2020 2020 2061  ent....        a
-000150e0: 7272 6179 285b 2030 2e35 3238 382c 2020  rray([ 0.5288,  
-000150f0: 302e 3637 2020 2c20 2030 2e36 3639 332c  0.67  ,  0.6693,
-00015100: 2020 302e 3735 3639 2c20 2030 2e37 3535    0.7569,  0.755
-00015110: 362c 2020 312e 2020 2020 2c20 2030 2e36  6,  1.    ,  0.6
-00015120: 3720 205d 290a 0a20 2020 2020 2020 2061  7  ])..        a
-00015130: 7320 636f 6d70 6172 6564 2074 6f20 7468  s compared to th
-00015140: 6520 756e 7765 6967 6874 6564 2076 6572  e unweighted ver
-00015150: 7369 6f6e 3a0a 0a20 2020 2020 2020 203e  sion:..        >
-00015160: 3e3e 206e 6574 203d 204e 6574 776f 726b  >> net = Network
-00015170: 2e53 6d61 6c6c 4469 7265 6374 6564 5465  .SmallDirectedTe
-00015180: 7374 4e65 7477 6f72 6b28 290a 2020 2020  stNetwork().    
-00015190: 2020 2020 3e3e 3e20 7228 6e65 742e 6c6f      >>> r(net.lo
-000151a0: 6361 6c5f 696e 6d6f 7469 665f 636c 7573  cal_inmotif_clus
-000151b0: 7465 7269 6e67 2829 290a 2020 2020 2020  tering()).      
-000151c0: 2020 4361 6c63 756c 6174 696e 6720 6c6f    Calculating lo
-000151d0: 6361 6c20 696e 206d 6f74 6966 2063 6c75  cal in motif clu
-000151e0: 7374 6572 696e 6720 636f 6566 6669 6369  stering coeffici
-000151f0: 656e 742e 2e2e 0a20 2020 2020 2020 2061  ent....        a
-00015200: 7272 6179 285b 2030 2e20 2c20 2030 2e35  rray([ 0. ,  0.5
-00015210: 2c20 2030 2e35 2c20 2030 2e20 2c20 2030  ,  0.5,  0. ,  0
-00015220: 2e20 2c20 2030 2e20 5d29 0a20 2020 2020  . ,  0. ]).     
-00015230: 2020 203e 3e3e 2072 286e 6574 2e73 706c     >>> r(net.spl
-00015240: 6974 7465 645f 636f 7079 286e 6f64 653d  itted_copy(node=
-00015250: 3129 2e6c 6f63 616c 5f69 6e6d 6f74 6966  1).local_inmotif
-00015260: 5f63 6c75 7374 6572 696e 6728 2929 0a20  _clustering()). 
-00015270: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-00015280: 6e67 206c 6f63 616c 2069 6e20 6d6f 7469  ng local in moti
-00015290: 6620 636c 7573 7465 7269 6e67 2063 6f65  f clustering coe
-000152a0: 6666 6963 6965 6e74 2e2e 2e0a 2020 2020  fficient....    
-000152b0: 2020 2020 6172 7261 7928 5b20 302e 2020      array([ 0.  
-000152c0: 2020 2c20 2030 2e35 2020 202c 2020 302e    ,  0.5   ,  0.
-000152d0: 3636 3637 2c20 2030 2e20 2020 202c 2020  6667,  0.    ,  
-000152e0: 312e 2020 2020 2c20 2030 2e20 2020 202c  1.    ,  0.    ,
-000152f0: 2020 302e 3520 2020 5d29 0a0a 0a20 2020    0.5   ])...   
-00015300: 2020 2020 203a 6172 6720 7374 7220 6b65       :arg str ke
-00015310: 793a 206c 696e 6b20 6174 7472 6962 7574  y: link attribut
-00015320: 6520 6b65 7920 286f 7074 696f 6e61 6c29  e key (optional)
-00015330: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00015340: 2020 2020 2064 6566 2074 5f66 756e 6328       def t_func(
-00015350: 782c 2078 5429 3a0a 2020 2020 2020 2020  x, xT):.        
-00015360: 2020 2020 7265 7475 726e 2078 5420 2a20      return xT * 
-00015370: 7820 2a20 780a 2020 2020 2020 2020 5420  x * x.        T 
-00015380: 3d20 7365 6c66 2e6e 7369 5f69 6e64 6567  = self.nsi_indeg
-00015390: 7265 6528 292a 2a32 0a20 2020 2020 2020  ree()**2.       
-000153a0: 2072 6574 7572 6e20 7365 6c66 2e5f 6d6f   return self._mo
-000153b0: 7469 665f 636c 7573 7465 7269 6e67 5f68  tif_clustering_h
-000153c0: 656c 7065 7228 745f 6675 6e63 2c20 542c  elper(t_func, T,
-000153d0: 206b 6579 3d6b 6579 2c20 6e73 693d 5472   key=key, nsi=Tr
-000153e0: 7565 290a 0a20 2020 2040 6361 6368 6564  ue)..    @cached
-000153f0: 5f76 6172 2827 6e73 6920 6c6f 6361 6c20  _var('nsi local 
-00015400: 6f75 7465 6d6f 7469 6627 2c0a 2020 2020  outemotif',.    
-00015410: 2020 2020 2020 2020 2020 2020 276c 6f63              'loc
-00015420: 616c 206e 7369 206f 7574 206d 6f74 6966  al nsi out motif
-00015430: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-00015440: 6669 6369 656e 7427 290a 2020 2020 6465  ficient').    de
-00015450: 6620 6e73 695f 6c6f 6361 6c5f 6f75 746d  f nsi_local_outm
-00015460: 6f74 6966 5f63 6c75 7374 6572 696e 6728  otif_clustering(
-00015470: 7365 6c66 2c20 6b65 793d 4e6f 6e65 293a  self, key=None):
-00015480: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00015490: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
-000154a0: 6465 2c20 7265 7475 726e 2074 6865 206e  de, return the n
-000154b0: 7369 2063 6c75 7374 6572 696e 6720 636f  si clustering co
-000154c0: 6566 6669 6369 656e 7420 7769 7468 2072  efficient with r
-000154d0: 6573 7065 6374 2074 6f0a 2020 2020 2020  espect to.      
-000154e0: 2020 7468 6520 6f75 7420 6d6f 7469 662e    the out motif.
-000154f0: 0a0a 2020 2020 2020 2020 4966 2061 206c  ..        If a l
-00015500: 696e 6b20 6174 7472 6962 7574 6520 6b65  ink attribute ke
-00015510: 7920 6973 2073 7065 6369 6669 6564 2c20  y is specified, 
-00015520: 7265 7475 726e 2074 6865 2061 7373 6f63  return the assoc
-00015530: 6961 7465 6420 6c69 6e6b 0a20 2020 2020  iated link.     
-00015540: 2020 2077 6569 6768 7465 6420 7665 7273     weighted vers
-00015550: 696f 6e0a 0a20 2020 2020 2020 2052 6566  ion..        Ref
-00015560: 6572 656e 6365 3a20 5b5a 656d 7032 3031  erence: [Zemp201
-00015570: 345d 5f0a 0a20 2020 2020 2020 202a 2a45  4]_..        **E
-00015580: 7861 6d70 6c65 733a 2a2a 0a0a 2020 2020  xamples:**..    
-00015590: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-000155a0: 7477 6f72 6b2e 536d 616c 6c44 6972 6563  twork.SmallDirec
-000155b0: 7465 6454 6573 744e 6574 776f 726b 2829  tedTestNetwork()
-000155c0: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
-000155d0: 6574 2e6e 7369 5f6c 6f63 616c 5f6f 7574  et.nsi_local_out
-000155e0: 6d6f 7469 665f 636c 7573 7465 7269 6e67  motif_clustering
-000155f0: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
-00015600: 756c 6174 696e 6720 6c6f 6361 6c20 6e73  ulating local ns
-00015610: 6920 6f75 7420 6d6f 7469 6620 636c 7573  i out motif clus
-00015620: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
-00015630: 6e74 2e2e 2e0a 2020 2020 2020 2020 6172  nt....        ar
-00015640: 7261 7928 5b20 302e 3637 2020 2c20 2030  ray([ 0.67  ,  0
-00015650: 2e36 3639 332c 2020 312e 2020 2020 2c20  .6693,  1.    , 
-00015660: 2030 2e37 3532 382c 2020 302e 3538 3339   0.7528,  0.5839
-00015670: 2c20 2030 2e37 3635 365d 290a 2020 2020  ,  0.7656]).    
-00015680: 2020 2020 3e3e 3e20 7228 6e65 742e 7370      >>> r(net.sp
-00015690: 6c69 7474 6564 5f63 6f70 7928 6e6f 6465  litted_copy(node
-000156a0: 3d30 292e 6e73 695f 6c6f 6361 6c5f 6f75  =0).nsi_local_ou
-000156b0: 746d 6f74 6966 5f63 6c75 7374 6572 696e  tmotif_clusterin
-000156c0: 6728 2929 0a20 2020 2020 2020 2043 616c  g()).        Cal
-000156d0: 6375 6c61 7469 6e67 206c 6f63 616c 206e  culating local n
-000156e0: 7369 206f 7574 206d 6f74 6966 2063 6c75  si out motif clu
-000156f0: 7374 6572 696e 6720 636f 6566 6669 6369  stering coeffici
-00015700: 656e 742e 2e2e 0a20 2020 2020 2020 2061  ent....        a
-00015710: 7272 6179 285b 2030 2e36 3720 202c 2020  rray([ 0.67  ,  
-00015720: 302e 3636 3933 2c20 2031 2e20 2020 202c  0.6693,  1.    ,
-00015730: 2020 302e 3735 3238 2c20 2030 2e35 3833    0.7528,  0.583
-00015740: 392c 2020 302e 3736 3536 2c20 2030 2e36  9,  0.7656,  0.6
-00015750: 3720 205d 290a 0a20 2020 2020 2020 2061  7  ])..        a
-00015760: 7320 636f 6d70 6172 6564 2074 6f20 7468  s compared to th
-00015770: 6520 756e 7765 6967 6874 6564 2076 6572  e unweighted ver
-00015780: 7369 6f6e 3a0a 0a20 2020 2020 2020 203e  sion:..        >
-00015790: 3e3e 206e 6574 203d 204e 6574 776f 726b  >> net = Network
-000157a0: 2e53 6d61 6c6c 4469 7265 6374 6564 5465  .SmallDirectedTe
-000157b0: 7374 4e65 7477 6f72 6b28 290a 2020 2020  stNetwork().    
-000157c0: 2020 2020 3e3e 3e20 7228 6e65 742e 6c6f      >>> r(net.lo
-000157d0: 6361 6c5f 6f75 746d 6f74 6966 5f63 6c75  cal_outmotif_clu
-000157e0: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
-000157f0: 2020 2043 616c 6375 6c61 7469 6e67 206c     Calculating l
-00015800: 6f63 616c 206f 7574 206d 6f74 6966 2063  ocal out motif c
-00015810: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
-00015820: 6369 656e 742e 2e2e 0a20 2020 2020 2020  cient....       
-00015830: 2061 7272 6179 285b 2030 2e35 2c20 2030   array([ 0.5,  0
-00015840: 2e35 2c20 2030 2e20 2c20 2030 2e20 2c20  .5,  0. ,  0. , 
-00015850: 2030 2e20 2c20 2030 2e20 5d29 0a20 2020   0. ,  0. ]).   
-00015860: 2020 2020 203e 3e3e 2072 286e 6574 2e73       >>> r(net.s
-00015870: 706c 6974 7465 645f 636f 7079 286e 6f64  plitted_copy(nod
-00015880: 653d 3029 2e6c 6f63 616c 5f6f 7574 6d6f  e=0).local_outmo
-00015890: 7469 665f 636c 7573 7465 7269 6e67 2829  tif_clustering()
-000158a0: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-000158b0: 6174 696e 6720 6c6f 6361 6c20 6f75 7420  ating local out 
-000158c0: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
-000158d0: 2063 6f65 6666 6963 6965 6e74 2e2e 2e0a   coefficient....
-000158e0: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-000158f0: 302e 3520 2020 2c20 2030 2e35 2020 202c  0.5   ,  0.5   ,
-00015900: 2020 302e 2020 2020 2c20 2030 2e20 2020    0.    ,  0.   
-00015910: 202c 2020 302e 3333 3333 2c20 2031 2e20   ,  0.3333,  1. 
-00015920: 2020 202c 2020 302e 3520 2020 5d29 0a0a     ,  0.5   ])..
-00015930: 2020 2020 2020 2020 3a61 7267 2073 7472          :arg str
-00015940: 206b 6579 3a20 6c69 6e6b 2061 7474 7269   key: link attri
-00015950: 6275 7465 206b 6579 2028 6f70 7469 6f6e  bute key (option
-00015960: 616c 290a 2020 2020 2020 2020 2222 220a  al).        """.
-00015970: 2020 2020 2020 2020 6465 6620 745f 6675          def t_fu
-00015980: 6e63 2878 2c20 7854 293a 0a20 2020 2020  nc(x, xT):.     
-00015990: 2020 2020 2020 2072 6574 7572 6e20 7820         return x 
-000159a0: 2a20 7820 2a20 7854 0a20 2020 2020 2020  * x * xT.       
-000159b0: 2054 203d 2073 656c 662e 6e73 695f 6f75   T = self.nsi_ou
-000159c0: 7464 6567 7265 6528 292a 2a32 0a20 2020  tdegree()**2.   
-000159d0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000159e0: 2e5f 6d6f 7469 665f 636c 7573 7465 7269  ._motif_clusteri
-000159f0: 6e67 5f68 656c 7065 7228 745f 6675 6e63  ng_helper(t_func
-00015a00: 2c20 542c 206b 6579 3d6b 6579 2c20 6e73  , T, key=key, ns
-00015a10: 693d 5472 7565 290a 0a20 2020 2040 6361  i=True)..    @ca
-00015a20: 6368 6564 5f63 6f6e 7374 2827 6261 7365  ched_const('base
-00015a30: 272c 2027 7472 616e 7369 7469 7669 7479  ', 'transitivity
-00015a40: 272c 2027 7472 616e 7369 7469 7669 7479  ', 'transitivity
-00015a50: 2063 6f65 6666 6963 6965 6e74 2028 435f   coefficient (C_
-00015a60: 3129 2729 0a20 2020 2064 6566 2074 7261  1)').    def tra
-00015a70: 6e73 6974 6976 6974 7928 7365 6c66 293a  nsitivity(self):
-00015a80: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00015a90: 2020 2020 2052 6574 7572 6e20 7468 6520       Return the 
-00015aa0: 7472 616e 7369 7469 7669 7479 2028 636f  transitivity (co
-00015ab0: 6566 6669 6369 656e 7429 2e0a 0a20 2020  efficient)...   
-00015ac0: 2020 2020 2054 6869 7320 6973 2074 6865       This is the
-00015ad0: 2072 6174 696f 206f 6620 7468 7265 6520   ratio of three 
-00015ae0: 7469 6d65 7320 7468 6520 6e75 6d62 6572  times the number
-00015af0: 206f 6620 7472 6961 6e67 6c65 7320 746f   of triangles to
-00015b00: 2074 6865 206e 756d 6265 720a 2020 2020   the number.    
-00015b10: 2020 2020 6f66 2063 6f6e 6e65 6374 6564      of connected
-00015b20: 2074 7269 706c 6573 206f 6620 7665 7274   triples of vert
-00015b30: 6963 6573 2e20 5b4e 6577 6d61 6e32 3030  ices. [Newman200
-00015b40: 335d 5f20 7265 6665 7273 2074 6f20 7468  3]_ refers to th
-00015b50: 6973 206d 6561 7375 7265 0a20 2020 2020  is measure.     
-00015b60: 2020 2061 7320 435f 312e 0a0a 2020 2020     as C_1...    
-00015b70: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
-00015b80: 0a0a 2020 2020 2020 2020 3e3e 3e20 7228  ..        >>> r(
-00015b90: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
-00015ba0: 744e 6574 776f 726b 2829 2e74 7261 6e73  tNetwork().trans
-00015bb0: 6974 6976 6974 7928 2929 0a20 2020 2020  itivity()).     
-00015bc0: 2020 2043 616c 6375 6c61 7469 6e67 2074     Calculating t
-00015bd0: 7261 6e73 6974 6976 6974 7920 636f 6566  ransitivity coef
-00015be0: 6669 6369 656e 7420 2843 5f31 292e 2e2e  ficient (C_1)...
-00015bf0: 0a20 2020 2020 2020 2030 2e32 3732 370a  .        0.2727.
-00015c00: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-00015c10: 2066 6c6f 6174 2062 6574 7765 656e 2030   float between 0
-00015c20: 2061 6e64 2031 0a20 2020 2020 2020 2022   and 1.        "
-00015c30: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00015c40: 6e20 7365 6c66 2e67 7261 7068 2e74 7261  n self.graph.tra
-00015c50: 6e73 6974 6976 6974 795f 756e 6469 7265  nsitivity_undire
-00015c60: 6374 6564 2829 0a0a 2020 2020 6465 6620  cted()..    def 
-00015c70: 6869 6768 6572 5f6f 7264 6572 5f74 7261  higher_order_tra
-00015c80: 6e73 6974 6976 6974 7928 7365 6c66 2c20  nsitivity(self, 
-00015c90: 6f72 6465 722c 2065 7374 696d 6174 653d  order, estimate=
-00015ca0: 4661 6c73 6529 3a0a 2020 2020 2020 2020  False):.        
-00015cb0: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
-00015cc0: 726e 2074 7261 6e73 6974 6976 6974 7920  rn transitivity 
-00015cd0: 6f66 2061 2063 6572 7461 696e 206f 7264  of a certain ord
-00015ce0: 6572 2e0a 0a20 2020 2020 2020 2054 6865  er...        The
-00015cf0: 2074 7261 6e73 6974 6976 6974 7920 6f66   transitivity of
-00015d00: 206f 7264 6572 206e 2069 7320 6465 6669   order n is defi
-00015d10: 6e65 6420 6173 3a0a 2020 2020 2020 2020  ned as:.        
-00015d20: 202d 2028 6e20 7820 4e75 6d62 6572 206f   - (n x Number o
-00015d30: 6620 636c 6971 7565 7320 6f66 206e 206e  f cliques of n n
-00015d40: 6f64 6573 2920 2f20 284e 756d 6265 7220  odes) / (Number 
-00015d50: 6f66 2073 7461 7273 206f 6620 6e20 6e6f  of stars of n no
-00015d60: 6465 7329 0a0a 2020 2020 2020 2020 4974  des)..        It
-00015d70: 2069 7320 6120 6765 6e65 7261 6c69 7a61   is a generaliza
-00015d80: 7469 6f6e 206f 6620 7468 6520 7374 616e  tion of the stan
-00015d90: 6461 7264 206e 6574 776f 726b 2074 7261  dard network tra
-00015da0: 6e73 6974 6976 6974 792c 2077 6869 6368  nsitivity, which
-00015db0: 2069 730a 2020 2020 2020 2020 696e 636c   is.        incl
-00015dc0: 7564 6564 2061 7320 6120 7370 6563 6961  uded as a specia
-00015dd0: 6c20 6361 7365 2066 6f72 206e 203d 2033  l case for n = 3
-00015de0: 2e0a 0a20 2020 2020 2020 203a 6172 6720  ...        :arg 
-00015df0: 696e 7420 6f72 6465 723a 2054 6865 206f  int order: The o
-00015e00: 7264 6572 2028 6e75 6d62 6572 206f 6620  rder (number of 
-00015e10: 6e6f 6465 7329 206f 6620 636c 6971 7565  nodes) of clique
-00015e20: 7320 746f 2062 650a 2020 2020 2020 2020  s to be.        
-00015e30: 2020 2020 636f 6e73 6964 6572 6564 2e0a      considered..
-00015e40: 2020 2020 2020 2020 3a61 7267 2062 6f6f          :arg boo
-00015e50: 6c20 6573 7469 6d61 7465 3a20 546f 6767  l estimate: Togg
-00015e60: 6c65 7320 7261 6e64 6f6d 2073 616d 706c  les random sampl
-00015e70: 696e 6720 666f 7220 6573 7469 6d61 7469  ing for estimati
-00015e80: 6e67 2068 6967 6865 7220 6f72 6465 720a  ng higher order.
-00015e90: 2020 2020 2020 2020 2020 2020 7472 616e              tran
-00015ea0: 7369 7469 7669 7479 2028 6d75 6368 2066  sitivity (much f
-00015eb0: 6173 7465 7220 7468 616e 2065 7861 6374  aster than exact
-00015ec0: 2063 616c 6375 6c61 7469 6f6e 292e 0a20   calculation).. 
-00015ed0: 2020 2020 2020 203a 7274 7970 653a 206e         :rtype: n
-00015ee0: 756d 6265 7220 2866 6c6f 6174 2920 6265  umber (float) be
-00015ef0: 7477 6565 6e20 3020 616e 6420 310a 2020  tween 0 and 1.  
-00015f00: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00015f10: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
-00015f20: 655f 6c65 7665 6c20 3c3d 2031 3a0a 2020  e_level <= 1:.  
-00015f30: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-00015f40: 2243 616c 6375 6c61 7469 6e67 2074 7261  "Calculating tra
-00015f50: 6e73 6974 6976 6974 7920 6f66 206f 7264  nsitivity of ord
-00015f60: 6572 222c 206f 7264 6572 2c20 222e 2e2e  er", order, "...
-00015f70: 2229 0a0a 2020 2020 2020 2020 6966 206f  ")..        if o
-00015f80: 7264 6572 2069 6e20 5b30 2c20 312c 2032  rder in [0, 1, 2
-00015f90: 5d3a 0a20 2020 2020 2020 2020 2020 2072  ]:.            r
-00015fa0: 6169 7365 204e 6574 776f 726b 4572 726f  aise NetworkErro
-00015fb0: 7228 2248 6967 6865 7220 6f72 6465 7220  r("Higher order 
-00015fc0: 7472 616e 7369 7469 7669 7479 2069 7320  transitivity is 
-00015fd0: 6e6f 7420 6465 6669 6e65 6420 666f 7220  not defined for 
-00015fe0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-00015ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016000: 206f 7264 6572 7320 302c 2031 2061 6e64   orders 0, 1 and
-00016010: 2032 2e22 290a 2020 2020 2020 2020 6966   2.").        if
-00016020: 206f 7264 6572 203d 3d20 333a 0a20 2020   order == 3:.   
-00016030: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00016040: 7365 6c66 2e74 7261 6e73 6974 6976 6974  self.transitivit
-00016050: 7928 290a 0a20 2020 2020 2020 2069 6620  y()..        if 
-00016060: 6f72 6465 7220 3d3d 2034 3a0a 2020 2020  order == 4:.    
-00016070: 2020 2020 2020 2020 2320 2047 6174 6865          #  Gathe
-00016080: 7269 6e67 0a20 2020 2020 2020 2020 2020  ring.           
-00016090: 2023 204e 203d 2073 656c 662e 4e0a 2020   # N = self.N.  
-000160a0: 2020 2020 2020 2020 2020 2320 4120 3d20            # A = 
-000160b0: 7365 6c66 2e61 646a 6163 656e 6379 0a20  self.adjacency. 
-000160c0: 2020 2020 2020 2020 2020 2023 2054 203d             # T =
-000160d0: 205f 6869 6768 6572 5f6f 7264 6572 5f74   _higher_order_t
-000160e0: 7261 6e73 6974 6976 6974 7934 284e 2c20  ransitivity4(N, 
-000160f0: 4129 0a20 2020 2020 2020 2020 2020 2023  A).            #
-00016100: 2072 6574 7572 6e20 540a 0a20 2020 2020   return T..     
-00016110: 2020 2020 2020 2069 6620 6573 7469 6d61         if estima
-00016120: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
-00016130: 2020 2020 6d6f 7469 665f 636f 756e 7473      motif_counts
-00016140: 203d 2073 656c 662e 6772 6170 682e 6d6f   = self.graph.mo
-00016150: 7469 6673 5f72 616e 6465 7375 280a 2020  tifs_randesu(.  
-00016160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016170: 2020 7369 7a65 3d34 2c20 6375 745f 7072    size=4, cut_pr
-00016180: 6f62 3d5b 302e 352c 2030 2e35 2c20 302e  ob=[0.5, 0.5, 0.
-00016190: 352c 2030 2e35 5d29 0a20 2020 2020 2020  5, 0.5]).       
-000161a0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000161b0: 2020 2020 2020 2020 2020 206d 6f74 6966             motif
-000161c0: 5f63 6f75 6e74 7320 3d20 7365 6c66 2e67  _counts = self.g
-000161d0: 7261 7068 2e6d 6f74 6966 735f 7261 6e64  raph.motifs_rand
-000161e0: 6573 7528 7369 7a65 3d34 290a 0a20 2020  esu(size=4)..   
-000161f0: 2020 2020 2020 2020 2023 2020 5375 6d20           #  Sum 
-00016200: 6f76 6572 2061 6c6c 206d 6f74 6966 7320  over all motifs 
-00016210: 7468 6174 2063 6f6e 7461 696e 2061 2073  that contain a s
-00016220: 7461 720a 2020 2020 2020 2020 2020 2020  tar.            
-00016230: 6e5f 7374 6172 7320 3d20 6d6f 7469 665f  n_stars = motif_
-00016240: 636f 756e 7473 5b34 5d20 2b20 6d6f 7469  counts[4] + moti
-00016250: 665f 636f 756e 7473 5b37 5d20 2b20 5c0a  f_counts[7] + \.
-00016260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016270: 3220 2a20 6d6f 7469 665f 636f 756e 7473  2 * motif_counts
-00016280: 5b39 5d20 2b20 3420 2a20 6d6f 7469 665f  [9] + 4 * motif_
-00016290: 636f 756e 7473 5b31 305d 0a20 2020 2020  counts[10].     
-000162a0: 2020 2020 2020 206e 5f63 6c69 7175 6573         n_cliques
-000162b0: 203d 206d 6f74 6966 5f63 6f75 6e74 735b   = motif_counts[
-000162c0: 3130 5d0a 0a20 2020 2020 2020 2020 2020  10]..           
-000162d0: 2023 2070 7269 6e74 286d 6f74 6966 5f63   # print(motif_c
-000162e0: 6f75 6e74 7329 0a0a 2020 2020 2020 2020  ounts)..        
-000162f0: 2020 2020 6966 206e 5f73 7461 7273 2021      if n_stars !
-00016300: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
-00016310: 2020 2020 2072 6574 7572 6e20 3420 2a20       return 4 * 
-00016320: 6e5f 636c 6971 7565 7320 2f20 666c 6f61  n_cliques / floa
-00016330: 7428 6e5f 7374 6172 7329 0a20 2020 2020  t(n_stars).     
-00016340: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00016350: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00016360: 7572 6e20 302e 0a0a 2020 2020 2020 2020  urn 0...        
-00016370: 6966 206f 7264 6572 203e 2034 3a0a 2020  if order > 4:.  
-00016380: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00016390: 4e6f 7449 6d70 6c65 6d65 6e74 6564 4572  NotImplementedEr
-000163a0: 726f 7228 2248 6967 6865 7220 6f72 6465  ror("Higher orde
-000163b0: 7220 7472 616e 7369 7469 7669 7479 2069  r transitivity i
-000163c0: 7320 6e6f 7420 7965 7420 5c0a 2020 2020  s not yet \.    
-000163d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163f0: 2020 696d 706c 656d 656e 7465 6420 666f    implemented fo
-00016400: 7220 6f72 6465 7273 206c 6172 6765 7220  r orders larger 
-00016410: 7468 616e 2034 2e22 290a 0a20 2020 2020  than 4.")..     
-00016420: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00016430: 726f 7228 224f 7264 6572 2068 6173 2074  ror("Order has t
-00016440: 6f20 6265 2061 2070 6f73 6974 6976 6520  o be a positive 
-00016450: 696e 7465 6765 722e 2229 0a0a 2020 2020  integer.")..    
-00016460: 6465 6620 6c6f 6361 6c5f 636c 6971 7569  def local_cliqui
-00016470: 7368 6e65 7373 2873 656c 662c 206f 7264  shness(self, ord
-00016480: 6572 293a 0a20 2020 2020 2020 2022 2222  er):.        """
-00016490: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
-000164a0: 6c6f 6361 6c20 636c 6971 7569 7368 6e65  local cliquishne
-000164b0: 7373 206f 6620 6120 6365 7274 6169 6e20  ss of a certain 
-000164c0: 6f72 6465 722e 0a0a 2020 2020 2020 2020  order...        
-000164d0: 5468 6520 6c6f 6361 6c20 636c 6971 7569  The local cliqui
-000164e0: 7368 6e65 7373 206d 6561 7375 7265 7320  shness measures 
-000164f0: 7468 6520 7265 6c61 7469 7665 206e 756d  the relative num
-00016500: 6265 7220 6f66 2063 6c69 7175 6573 2028  ber of cliques (
-00016510: 6675 6c6c 790a 2020 2020 2020 2020 636f  fully.        co
-00016520: 6e6e 6563 7465 6420 7375 6267 7261 7068  nnected subgraph
-00016530: 7329 206f 6620 6120 6365 7274 6169 6e20  s) of a certain 
-00016540: 6f72 6465 7220 7468 6174 2061 206e 6f64  order that a nod
-00016550: 6520 7061 7274 6963 6970 6174 6573 2069  e participates i
-00016560: 6e2e 0a0a 2020 2020 2020 2020 4c6f 6361  n...        Loca
-00016570: 6c20 636c 6971 7569 7368 6e65 7373 2069  l cliquishness i
-00016580: 7320 6e6f 7420 6465 6669 6e65 6420 666f  s not defined fo
-00016590: 7220 6f72 6465 7273 2031 2061 6e64 2032  r orders 1 and 2
-000165a0: 2e20 466f 7220 6f72 6465 7220 332c 0a20  . For order 3,. 
-000165b0: 2020 2020 2020 2069 7420 6973 2065 7175         it is equ
-000165c0: 6976 616c 656e 7420 746f 2074 6865 206c  ivalent to the l
-000165d0: 6f63 616c 2063 6c75 7374 6572 696e 6720  ocal clustering 
-000165e0: 636f 6566 6669 6369 656e 740a 2020 2020  coefficient.    
-000165f0: 2020 2020 3a6d 6574 683a 606c 6f63 616c      :meth:`local
-00016600: 5f63 6c75 7374 6572 696e 6760 2c20 7369  _clustering`, si
-00016610: 6e63 6520 636c 6971 7565 7320 6f66 206f  nce cliques of o
-00016620: 7264 6572 2033 2061 7265 2074 7269 616e  rder 3 are trian
-00016630: 676c 6573 2e0a 0a20 2020 2020 2020 204c  gles...        L
-00016640: 6f63 616c 2063 6c69 7175 6973 686e 6573  ocal cliquishnes
-00016650: 7320 6973 2061 6c77 6179 7320 626f 756e  s is always boun
-00016660: 6465 6420 6279 2030 2061 6e64 2031 2061  ded by 0 and 1 a
-00016670: 6e64 2073 6574 2074 6f20 7a65 726f 2066  nd set to zero f
-00016680: 6f72 0a20 2020 2020 2020 206e 6f64 6573  or.        nodes
-00016690: 2077 6974 6820 6465 6772 6565 2073 6d61   with degree sma
-000166a0: 6c6c 6572 2074 6861 6e20 6f72 6465 7220  ller than order 
-000166b0: 2d20 312e 0a0a 2020 2020 2020 2020 3a74  - 1...        :t
-000166c0: 7970 6520 6f72 6465 723a 206e 756d 6265  ype order: numbe
-000166d0: 7220 2869 6e74 290a 2020 2020 2020 2020  r (int).        
-000166e0: 3a61 7267 206f 7264 6572 3a20 5468 6520  :arg order: The 
-000166f0: 6f72 6465 7220 286e 756d 6265 7220 6f66  order (number of
-00016700: 206e 6f64 6573 2920 6f66 2063 6c69 7175   nodes) of cliqu
-00016710: 6573 2074 6f20 6265 2063 6f6e 7369 6465  es to be conside
-00016720: 7265 642e 0a0a 2020 2020 2020 2020 3a72  red...        :r
-00016730: 7479 7065 3a20 3164 206e 756d 7079 2061  type: 1d numpy a
-00016740: 7272 6179 205b 6e6f 6465 5d20 6f66 2066  rray [node] of f
-00016750: 6c6f 6174 7320 6265 7477 6565 6e20 3020  loats between 0 
-00016760: 616e 6420 310a 2020 2020 2020 2020 2222  and 1.        ""
-00016770: 220a 2020 2020 2020 2020 6966 2073 656c  ".        if sel
-00016780: 662e 6469 7265 6374 6564 3a0a 2020 2020  f.directed:.    
-00016790: 2020 2020 2020 2020 7261 6973 6520 4e65          raise Ne
-000167a0: 7477 6f72 6b45 7272 6f72 2822 4e6f 7420  tworkError("Not 
-000167b0: 696d 706c 656d 656e 7465 6420 7965 742e  implemented yet.
-000167c0: 2e2e 2229 0a0a 2020 2020 2020 2020 6966  ..")..        if
-000167d0: 2073 656c 662e 7369 6c65 6e63 655f 6c65   self.silence_le
-000167e0: 7665 6c20 3c3d 2031 3a0a 2020 2020 2020  vel <= 1:.      
-000167f0: 2020 2020 2020 7072 696e 7428 2243 616c        print("Cal
-00016800: 6375 6c61 7469 6e67 206c 6f63 616c 2063  culating local c
-00016810: 6c69 7175 6973 686e 6573 7320 6f66 206f  liquishness of o
-00016820: 7264 6572 222c 206f 7264 6572 2c20 222e  rder", order, ".
-00016830: 2e2e 2229 0a0a 2020 2020 2020 2020 6966  ..")..        if
-00016840: 206f 7264 6572 2069 6e20 5b30 2c20 312c   order in [0, 1,
-00016850: 2032 5d3a 0a20 2020 2020 2020 2020 2020   2]:.           
-00016860: 2072 6169 7365 204e 6574 776f 726b 4572   raise NetworkEr
-00016870: 726f 7228 224c 6f63 616c 2063 6c69 7175  ror("Local cliqu
-00016880: 6973 686e 6573 7320 6973 206e 6f74 2064  ishness is not d
-00016890: 6566 696e 6564 2066 6f72 206f 7264 6572  efined for order
-000168a0: 7320 5c0a 2020 2020 2020 2020 2020 2020  s \.            
-000168b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000168c0: 2020 2030 2c20 3120 616e 6420 322e 2229     0, 1 and 2.")
-000168d0: 0a0a 2020 2020 2020 2020 6966 206f 7264  ..        if ord
-000168e0: 6572 203d 3d20 333a 0a20 2020 2020 2020  er == 3:.       
-000168f0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00016900: 2e6c 6f63 616c 5f63 6c75 7374 6572 696e  .local_clusterin
-00016910: 6728 290a 0a20 2020 2020 2020 2069 6620  g()..        if 
-00016920: 6f72 6465 7220 3d3d 2034 3a0a 2020 2020  order == 4:.    
-00016930: 2020 2020 2020 2020 7265 7475 726e 205f          return _
-00016940: 6c6f 6361 6c5f 636c 6971 7569 7368 6e65  local_cliquishne
-00016950: 7373 5f34 7468 6f72 6465 7228 7365 6c66  ss_4thorder(self
-00016960: 2e4e 2c0a 2020 2020 2020 2020 2020 2020  .N,.            
-00016970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016990: 2020 2020 7365 6c66 2e61 646a 6163 656e      self.adjacen
-000169a0: 6379 2e61 7374 7970 6528 696e 7429 2c0a  cy.astype(int),.
-000169b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000169c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000169d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000169e0: 7365 6c66 2e64 6567 7265 6528 2929 0a20  self.degree()). 
-000169f0: 2020 2020 2020 2069 6620 6f72 6465 7220         if order 
-00016a00: 3d3d 2035 3a0a 2020 2020 2020 2020 2020  == 5:.          
-00016a10: 2020 7265 7475 726e 205f 6c6f 6361 6c5f    return _local_
-00016a20: 636c 6971 7569 7368 6e65 7373 5f35 7468  cliquishness_5th
-00016a30: 6f72 6465 7228 7365 6c66 2e4e 2c0a 2020  order(self.N,.  
-00016a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a60: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00016a70: 6c66 2e61 646a 6163 656e 6379 2e61 7374  lf.adjacency.ast
-00016a80: 7970 6528 696e 7429 2c0a 2020 2020 2020  ype(int),.      
-00016a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ab0: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00016ac0: 6567 7265 6528 2929 0a20 2020 2020 2020  egree()).       
-00016ad0: 2069 6620 6f72 6465 7220 3e20 353a 0a20   if order > 5:. 
-00016ae0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-00016af0: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
-00016b00: 7272 6f72 2822 4c6f 6361 6c20 636c 6971  rror("Local cliq
-00016b10: 7569 7368 6e65 7373 2069 7320 6e6f 7420  uishness is not 
-00016b20: 7965 7420 5c0a 2020 2020 2020 2020 2020  yet \.          
-00016b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b40: 2020 2020 2020 2020 2020 2020 696d 706c              impl
-00016b50: 656d 656e 7465 6420 666f 7220 6f72 6465  emented for orde
-00016b60: 7273 206c 6172 6765 7220 7468 616e 2035  rs larger than 5
-00016b70: 2e22 290a 0a20 2020 2020 2020 2072 6169  .")..        rai
-00016b80: 7365 2056 616c 7565 4572 726f 7228 224f  se ValueError("O
-00016b90: 7264 6572 2068 6173 2074 6f20 6265 2061  rder has to be a
-00016ba0: 2070 6f73 6974 6976 6520 696e 7465 6765   positive intege
-00016bb0: 722e 2229 0a0a 2020 2020 4073 7461 7469  r.")..    @stati
-00016bc0: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
-00016bd0: 7765 6967 6874 6564 5f6c 6f63 616c 5f63  weighted_local_c
-00016be0: 6c75 7374 6572 696e 6728 7765 6967 6874  lustering(weight
-00016bf0: 6564 5f41 293a 0a20 2020 2020 2020 2022  ed_A):.        "
-00016c00: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
-00016c10: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
-00016c20: 2069 7473 2077 6569 6768 7465 6420 636c   its weighted cl
-00016c30: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
-00016c40: 6965 6e74 2c0a 2020 2020 2020 2020 6769  ient,.        gi
-00016c50: 7665 6e20 6120 7765 6967 6874 6564 2061  ven a weighted a
-00016c60: 646a 6163 656e 6379 206d 6174 7269 782e  djacency matrix.
-00016c70: 0a0a 2020 2020 2020 2020 5468 6973 2066  ..        This f
-00016c80: 6f6c 6c6f 7773 205b 486f 6c6d 6532 3030  ollows [Holme200
-00016c90: 375d 5f2e 0a0a 2020 2020 2020 2020 2a2a  7]_...        **
-00016ca0: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-00016cb0: 2020 2020 3e3e 3e20 7072 696e 7428 7228      >>> print(r(
-00016cc0: 4e65 7477 6f72 6b2e 7765 6967 6874 6564  Network.weighted
-00016cd0: 5f6c 6f63 616c 5f63 6c75 7374 6572 696e  _local_clusterin
-00016ce0: 6728 7765 6967 6874 6564 5f41 3d5b 0a20  g(weighted_A=[. 
-00016cf0: 2020 2020 2020 202e 2e2e 2020 2020 205b         ...     [
-00016d00: 2030 2e20 202c 2030 2e20 202c 2030 2e20   0.  , 0.  , 0. 
-00016d10: 202c 2030 2e35 352c 2030 2e36 352c 2030   , 0.55, 0.65, 0
-00016d20: 2e37 355d 2c0a 2020 2020 2020 2020 2e2e  .75],.        ..
-00016d30: 2e20 2020 2020 5b20 302e 2020 2c20 302e  .     [ 0.  , 0.
-00016d40: 2020 2c20 302e 3633 2c20 302e 3737 2c20    , 0.63, 0.77, 
-00016d50: 302e 3931 2c20 302e 2020 5d2c 0a20 2020  0.91, 0.  ],.   
-00016d60: 2020 2020 202e 2e2e 2020 2020 205b 2030       ...     [ 0
-00016d70: 2e20 202c 2030 2e36 332c 2030 2e20 202c  .  , 0.63, 0.  ,
-00016d80: 2030 2e20 202c 2031 2e31 372c 2030 2e20   0.  , 1.17, 0. 
-00016d90: 205d 2c0a 2020 2020 2020 2020 2e2e 2e20   ],.        ... 
-00016da0: 2020 2020 5b20 302e 3535 2c20 302e 3737      [ 0.55, 0.77
-00016db0: 2c20 302e 2020 2c20 302e 2020 2c20 302e  , 0.  , 0.  , 0.
-00016dc0: 2020 2c20 302e 2020 5d2c 0a20 2020 2020    , 0.  ],.     
-00016dd0: 2020 202e 2e2e 2020 2020 205b 2030 2e36     ...     [ 0.6
-00016de0: 352c 2030 2e39 312c 2031 2e31 372c 2030  5, 0.91, 1.17, 0
-00016df0: 2e20 202c 2030 2e20 202c 2030 2e20 205d  .  , 0.  , 0.  ]
-00016e00: 2c0a 2020 2020 2020 2020 2e2e 2e20 2020  ,.        ...   
-00016e10: 2020 5b20 302e 3735 2c20 302e 2020 2c20    [ 0.75, 0.  , 
-00016e20: 302e 2020 2c20 302e 2020 2c20 302e 2020  0.  , 0.  , 0.  
-00016e30: 2c20 302e 2020 5d5d 2929 290a 2020 2020  , 0.  ]]))).    
-00016e40: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-00016e50: 6c6f 6361 6c20 7765 6967 6874 6564 2063  local weighted c
-00016e60: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
-00016e70: 6369 656e 742e 2e2e 0a20 2020 2020 2020  cient....       
-00016e80: 205b 2030 2e20 2030 2e32 3134 3920 2030   [ 0.  0.2149  0
-00016e90: 2e33 3533 3920 2030 2e20 2030 2e31 3533  .3539  0.  0.153
-00016ea0: 3820 2030 2e20 5d0a 0a20 2020 2020 2020  8  0. ]..       
-00016eb0: 2061 7320 636f 6d70 6172 6564 2074 6f20   as compared to 
-00016ec0: 7468 6520 756e 7765 6967 6874 6564 2076  the unweighted v
-00016ed0: 6572 7369 6f6e 3a0a 0a20 2020 2020 2020  ersion:..       
-00016ee0: 203e 3e3e 2070 7269 6e74 2872 284e 6574   >>> print(r(Net
-00016ef0: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
-00016f00: 7477 6f72 6b28 292e 6c6f 6361 6c5f 636c  twork().local_cl
-00016f10: 7573 7465 7269 6e67 2829 2929 0a20 2020  ustering())).   
-00016f20: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-00016f30: 206c 6f63 616c 2063 6c75 7374 6572 696e   local clusterin
-00016f40: 6720 636f 6566 6669 6369 656e 7473 2e2e  g coefficients..
-00016f50: 2e0a 2020 2020 2020 2020 5b20 302e 2020  ..        [ 0.  
-00016f60: 302e 3333 3333 2020 312e 2020 302e 2020  0.3333  1.  0.  
-00016f70: 302e 3333 3333 2020 302e 205d 0a0a 2020  0.3333  0. ]..  
-00016f80: 2020 2020 2020 3a74 7970 6520 7765 6967        :type weig
-00016f90: 6874 6564 5f41 3a20 7371 7561 7265 206e  hted_A: square n
-00016fa0: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
-00016fb0: 2c6e 6f64 655d 206f 6620 666c 6f61 7473  ,node] of floats
-00016fc0: 203e 3d20 300a 2020 2020 2020 2020 3a61   >= 0.        :a
-00016fd0: 7267 2020 7765 6967 6874 6564 5f41 3a20  rg  weighted_A: 
-00016fe0: 456e 7472 7920 5b69 2c6a 5d20 6973 2074  Entry [i,j] is t
-00016ff0: 6865 206c 696e 6b20 7765 6967 6874 2066  he link weight f
-00017000: 726f 6d20 6920 746f 206a 2e0a 2020 2020  rom i to j..    
-00017010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017020: 2020 2020 2020 4120 7661 6c75 6520 6f66        A value of
-00017030: 2030 206d 6561 6e73 2074 6865 7265 2069   0 means there i
-00017040: 7320 6e6f 206c 696e 6b2e 0a0a 2020 2020  s no link...    
-00017050: 2020 2020 3a72 7479 7065 3a20 3164 206e      :rtype: 1d n
-00017060: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
-00017070: 5d20 6f66 2066 6c6f 6174 7320 6265 7477  ] of floats betw
-00017080: 6565 6e20 3020 616e 6420 310a 2020 2020  een 0 and 1.    
-00017090: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-000170a0: 2320 544f 444f 3a20 6d75 7374 2062 6520  # TODO: must be 
-000170b0: 7379 6d6d 6574 7269 633f 2064 6972 6563  symmetric? direc
-000170c0: 7465 6420 7665 7273 696f 6e3f 0a20 2020  ted version?.   
-000170d0: 2020 2020 2070 7269 6e74 2822 4361 6c63       print("Calc
-000170e0: 756c 6174 696e 6720 6c6f 6361 6c20 7765  ulating local we
-000170f0: 6967 6874 6564 2063 6c75 7374 6572 696e  ighted clusterin
-00017100: 6720 636f 6566 6669 6369 656e 742e 2e2e  g coefficient...
-00017110: 2229 0a0a 2020 2020 2020 2020 7741 203d  ")..        wA =
-00017120: 206e 702e 6172 7261 7928 7765 6967 6874   np.array(weight
-00017130: 6564 5f41 290a 2020 2020 2020 2020 6d61  ed_A).        ma
-00017140: 785f 7720 3d20 6e70 2e6f 6e65 735f 6c69  x_w = np.ones_li
-00017150: 6b65 2877 4129 2e64 6f74 2877 412e 6d61  ke(wA).dot(wA.ma
-00017160: 7828 2929 0a20 2020 2020 2020 2072 6574  x()).        ret
-00017170: 7572 6e20 286e 702e 6c69 6e61 6c67 2e6d  urn (np.linalg.m
-00017180: 6174 7269 785f 706f 7765 7228 7741 2c20  atrix_power(wA, 
-00017190: 3329 2e64 6961 676f 6e61 6c28 290a 2020  3).diagonal().  
-000171a0: 2020 2020 2020 2020 2020 2020 2020 2f20                / 
-000171b0: 2877 412e 646f 7428 6d61 785f 7729 2e64  (wA.dot(max_w).d
-000171c0: 6f74 2877 4129 292e 6469 6167 6f6e 616c  ot(wA)).diagonal
-000171d0: 2829 290a 0a20 2020 2064 6566 206e 7369  ())..    def nsi
-000171e0: 5f74 7769 6e6e 6573 7328 7365 6c66 293a  _twinness(self):
-000171f0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00017200: 2020 2020 2046 6f72 2065 6163 6820 7061       For each pa
-00017210: 6972 206f 6620 6e6f 6465 732c 2072 6574  ir of nodes, ret
-00017220: 7572 6e20 616e 206e 2e73 2e69 2e20 6d65  urn an n.s.i. me
-00017230: 6173 7572 6520 6f66 2027 7477 696e 6e65  asure of 'twinne
-00017240: 7373 272e 0a0a 2020 2020 2020 2020 5468  ss'...        Th
-00017250: 6973 2076 6172 6965 7320 6672 6f6d 2030  is varies from 0
-00017260: 2e30 2066 6f72 2075 6e6c 696e 6b65 6420  .0 for unlinked 
-00017270: 6e6f 6465 7320 746f 2031 2e30 2066 6f72  nodes to 1.0 for
-00017280: 206c 696e 6b65 6420 6e6f 6465 7320 6861   linked nodes ha
-00017290: 7669 6e67 0a20 2020 2020 2020 2065 7861  ving.        exa
-000172a0: 6374 6c79 2074 6865 2073 616d 6520 6e65  ctly the same ne
-000172b0: 6967 6862 6f72 7320 2863 616c 6c65 6420  ighbors (called 
-000172c0: 7477 696e 7329 2e0a 0a20 2020 2020 2020  twins)...       
-000172d0: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
-000172e0: 2020 2020 2020 203e 3e3e 206e 6574 203d         >>> net =
-000172f0: 204e 6574 776f 726b 2e53 6d61 6c6c 5465   Network.SmallTe
-00017300: 7374 4e65 7477 6f72 6b28 290a 2020 2020  stNetwork().    
-00017310: 2020 2020 3e3e 3e20 7072 696e 7428 7228      >>> print(r(
-00017320: 6e65 742e 6e73 695f 7477 696e 6e65 7373  net.nsi_twinness
-00017330: 2829 2929 0a20 2020 2020 2020 2043 616c  ())).        Cal
-00017340: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
-00017350: 6465 6772 6565 2e2e 2e0a 2020 2020 2020  degree....      
-00017360: 2020 5b5b 2031 2e20 2020 2020 2030 2e20    [[ 1.      0. 
-00017370: 2020 2020 2030 2e20 2020 2020 2030 2e34       0.      0.4
-00017380: 3238 3620 2030 2e34 3532 3420 2030 2e34  286  0.4524  0.4
-00017390: 3736 325d 0a20 2020 2020 2020 2020 5b20  762].         [ 
-000173a0: 302e 2020 2020 2020 312e 2020 2020 2020  0.      1.      
-000173b0: 302e 3733 3735 2020 302e 3437 3520 2020  0.7375  0.475   
-000173c0: 302e 3733 3735 2020 302e 2020 2020 5d0a  0.7375  0.    ].
-000173d0: 2020 2020 2020 2020 205b 2030 2e20 2020           [ 0.   
-000173e0: 2020 2030 2e37 3337 3520 2031 2e20 2020     0.7375  1.   
-000173f0: 2020 2030 2e20 2020 2020 2030 2e37 3937     0.      0.797
-00017400: 3320 2030 2e20 2020 205d 0a20 2020 2020  3  0.    ].     
-00017410: 2020 2020 5b20 302e 3432 3836 2020 302e      [ 0.4286  0.
-00017420: 3437 3520 2020 302e 2020 2020 2020 312e  475   0.      1.
-00017430: 2020 2020 2020 302e 2020 2020 2020 302e        0.      0.
-00017440: 2020 2020 5d0a 2020 2020 2020 2020 205b      ].         [
-00017450: 2030 2e34 3532 3420 2030 2e37 3337 3520   0.4524  0.7375 
-00017460: 2030 2e37 3937 3320 2030 2e20 2020 2020   0.7973  0.     
-00017470: 2031 2e20 2020 2020 2030 2e20 2020 205d   1.      0.    ]
-00017480: 0a20 2020 2020 2020 2020 5b20 302e 3437  .         [ 0.47
-00017490: 3632 2020 302e 2020 2020 2020 302e 2020  62  0.      0.  
-000174a0: 2020 2020 302e 2020 2020 2020 302e 2020      0.      0.  
-000174b0: 2020 2020 312e 2020 2020 5d5d 0a20 2020      1.    ]].   
-000174c0: 2020 2020 203e 3e3e 2070 7269 6e74 2872       >>> print(r
-000174d0: 286e 6574 2e73 706c 6974 7465 645f 636f  (net.splitted_co
-000174e0: 7079 2829 2e6e 7369 5f74 7769 6e6e 6573  py().nsi_twinnes
-000174f0: 7328 2929 290a 2020 2020 2020 2020 4361  s())).        Ca
-00017500: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
-00017510: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
-00017520: 2020 205b 5b20 312e 2020 2020 2020 302e     [[ 1.      0.
-00017530: 2020 2020 2020 302e 2020 2020 2020 302e        0.      0.
-00017540: 3432 3836 2020 302e 3435 3234 2020 302e  4286  0.4524  0.
-00017550: 3437 3632 2020 302e 3437 3632 5d0a 2020  4762  0.4762].  
-00017560: 2020 2020 2020 205b 2030 2e20 2020 2020         [ 0.     
-00017570: 2031 2e20 2020 2020 2030 2e37 3337 3520   1.      0.7375 
-00017580: 2030 2e34 3735 2020 2030 2e37 3337 3520   0.475   0.7375 
-00017590: 2030 2e20 2020 2020 2030 2e20 2020 205d   0.      0.    ]
-000175a0: 0a20 2020 2020 2020 2020 5b20 302e 2020  .         [ 0.  
-000175b0: 2020 2020 302e 3733 3735 2020 312e 2020      0.7375  1.  
-000175c0: 2020 2020 302e 2020 2020 2020 302e 3739      0.      0.79
-000175d0: 3733 2020 302e 2020 2020 2020 302e 2020  73  0.      0.  
-000175e0: 2020 5d0a 2020 2020 2020 2020 205b 2030    ].         [ 0
-000175f0: 2e34 3238 3620 2030 2e34 3735 2020 2030  .4286  0.475   0
-00017600: 2e20 2020 2020 2031 2e20 2020 2020 2030  .      1.      0
-00017610: 2e20 2020 2020 2030 2e20 2020 2020 2030  .      0.      0
-00017620: 2e20 2020 205d 0a20 2020 2020 2020 2020  .    ].         
-00017630: 5b20 302e 3435 3234 2020 302e 3733 3735  [ 0.4524  0.7375
-00017640: 2020 302e 3739 3733 2020 302e 2020 2020    0.7973  0.    
-00017650: 2020 312e 2020 2020 2020 302e 2020 2020    1.      0.    
-00017660: 2020 302e 2020 2020 5d0a 2020 2020 2020    0.    ].      
-00017670: 2020 205b 2030 2e34 3736 3220 2030 2e20     [ 0.4762  0. 
-00017680: 2020 2020 2030 2e20 2020 2020 2030 2e20       0.      0. 
-00017690: 2020 2020 2030 2e20 2020 2020 2031 2e20       0.      1. 
-000176a0: 2020 2020 2031 2e20 2020 205d 0a20 2020       1.    ].   
-000176b0: 2020 2020 2020 5b20 302e 3437 3632 2020        [ 0.4762  
-000176c0: 302e 2020 2020 2020 302e 2020 2020 2020  0.      0.      
-000176d0: 302e 2020 2020 2020 302e 2020 2020 2020  0.      0.      
-000176e0: 312e 2020 2020 2020 312e 2020 2020 5d5d  1.      1.    ]]
-000176f0: 0a0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
-00017700: 3a20 7371 7561 7265 2061 7272 6179 205b  : square array [
-00017710: 6e6f 6465 2c6e 6f64 655d 206f 6620 666c  node,node] of fl
-00017720: 6f61 7473 2062 6574 7765 656e 2030 2061  oats between 0 a
-00017730: 6e64 2031 0a20 2020 2020 2020 2022 2222  nd 1.        """
-00017740: 0a20 2020 2020 2020 2023 2054 4f44 4f3a  .        # TODO:
-00017750: 2069 6d70 6c65 6d65 6e74 206f 7468 6572   implement other
-00017760: 2076 6572 7369 6f6e 7320 6173 2077 65c4   versions as we.
-00017770: ba6c 0a20 2020 2020 2020 204e 2c20 6b2c  .l.        N, k,
-00017780: 2041 7020 3d20 7365 6c66 2e4e 2c20 7365   Ap = self.N, se
-00017790: 6c66 2e6e 7369 5f64 6567 7265 6528 292c  lf.nsi_degree(),
-000177a0: 2073 656c 662e 7370 5f41 706c 7573 2829   self.sp_Aplus()
-000177b0: 0a20 2020 2020 2020 2063 6f6d 6d6f 6e73  .        commons
-000177c0: 203d 2041 7020 2a20 7365 6c66 2e73 705f   = Ap * self.sp_
-000177d0: 6469 6167 5f77 2829 202a 2041 700a 2020  diag_w() * Ap.  
-000177e0: 2020 2020 2020 6b6b 203d 206e 702e 7265        kk = np.re
-000177f0: 7065 6174 285b 6b5d 2c20 4e2c 2061 7869  peat([k], N, axi
-00017800: 733d 3029 0a20 2020 2020 2020 2072 6574  s=0).        ret
-00017810: 7572 6e20 4170 2e41 202a 2063 6f6d 6d6f  urn Ap.A * commo
-00017820: 6e73 2e41 202f 206e 702e 6d61 7869 6d75  ns.A / np.maximu
-00017830: 6d28 6b6b 2c20 6b6b 2e54 290a 0a20 2020  m(kk, kk.T)..   
-00017840: 2023 0a20 2020 2023 2020 4d65 6173 7572   #.    #  Measur
-00017850: 6520 4173 736f 7274 6174 6976 6974 7920  e Assortativity 
-00017860: 636f 6566 6669 6369 656e 740a 2020 2020  coefficient.    
-00017870: 230a 0a20 2020 2064 6566 2061 7373 6f72  #..    def assor
-00017880: 7461 7469 7669 7479 2873 656c 6629 3a0a  tativity(self):.
-00017890: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-000178a0: 2020 2020 5265 7475 726e 2074 6865 2061      Return the a
-000178b0: 7373 6f72 7461 7469 7669 7479 2063 6f65  ssortativity coe
-000178c0: 6666 6963 6965 6e74 2e0a 0a20 2020 2020  fficient...     
-000178d0: 2020 2054 6869 7320 666f 6c6c 6f77 7320     This follows 
-000178e0: 5b4e 6577 6d61 6e32 3030 325d 5f2e 0a0a  [Newman2002]_...
-000178f0: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
-00017900: 653a 2a2a 0a0a 2020 2020 2020 2020 3e3e  e:**..        >>
-00017910: 3e20 7228 4e65 7477 6f72 6b2e 536d 616c  > r(Network.Smal
-00017920: 6c54 6573 744e 6574 776f 726b 2829 2e61  lTestNetwork().a
-00017930: 7373 6f72 7461 7469 7669 7479 2829 290a  ssortativity()).
-00017940: 2020 2020 2020 2020 2d30 2e34 3733 370a          -0.4737.
-00017950: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-00017960: 2066 6c6f 6174 2062 6574 7765 656e 2030   float between 0
-00017970: 2061 6e64 2031 0a20 2020 2020 2020 2022   and 1.        "
-00017980: 2222 0a20 2020 2020 2020 2064 6567 7265  "".        degre
-00017990: 6573 203d 2073 656c 662e 6772 6170 682e  es = self.graph.
-000179a0: 6465 6772 6565 2829 0a20 2020 2020 2020  degree().       
-000179b0: 2064 6567 7265 6573 5f73 7120 3d20 5b64   degrees_sq = [d
-000179c0: 6567 2a2a 3220 666f 7220 6465 6720 696e  eg**2 for deg in
-000179d0: 2064 6567 7265 6573 5d0a 0a20 2020 2020   degrees]..     
-000179e0: 2020 206d 203d 2066 6c6f 6174 2873 656c     m = float(sel
-000179f0: 662e 6772 6170 682e 6563 6f75 6e74 2829  f.graph.ecount()
-00017a00: 290a 2020 2020 2020 2020 6e75 6d31 2c20  ).        num1, 
-00017a10: 6e75 6d32 2c20 6465 6e31 203d 2030 2c20  num2, den1 = 0, 
-00017a20: 302c 2030 0a0a 2020 2020 2020 2020 666f  0, 0..        fo
-00017a30: 7220 736f 7572 6365 2c20 7461 7267 6574  r source, target
-00017a40: 2069 6e20 7365 6c66 2e67 7261 7068 2e67   in self.graph.g
-00017a50: 6574 5f65 6467 656c 6973 7428 293a 0a20  et_edgelist():. 
-00017a60: 2020 2020 2020 2020 2020 206e 756d 3120             num1 
-00017a70: 2b3d 2064 6567 7265 6573 5b73 6f75 7263  += degrees[sourc
-00017a80: 655d 202a 2064 6567 7265 6573 5b74 6172  e] * degrees[tar
-00017a90: 6765 745d 0a20 2020 2020 2020 2020 2020  get].           
-00017aa0: 206e 756d 3220 2b3d 2064 6567 7265 6573   num2 += degrees
-00017ab0: 5b73 6f75 7263 655d 202b 2064 6567 7265  [source] + degre
-00017ac0: 6573 5b74 6172 6765 745d 0a20 2020 2020  es[target].     
-00017ad0: 2020 2020 2020 2064 656e 3120 2b3d 2064         den1 += d
-00017ae0: 6567 7265 6573 5f73 715b 736f 7572 6365  egrees_sq[source
-00017af0: 5d20 2b20 6465 6772 6565 735f 7371 5b74  ] + degrees_sq[t
-00017b00: 6172 6765 745d 0a0a 2020 2020 2020 2020  arget]..        
-00017b10: 6e75 6d31 202f 3d20 6d0a 2020 2020 2020  num1 /= m.      
-00017b20: 2020 6465 6e31 202f 3d20 322a 6d0a 2020    den1 /= 2*m.  
-00017b30: 2020 2020 2020 6e75 6d32 203d 2028 6e75        num2 = (nu
-00017b40: 6d32 202f 2028 3220 2a20 6d29 2920 2a2a  m2 / (2 * m)) **
-00017b50: 2032 0a20 2020 2020 2020 2072 6574 7572   2.        retur
-00017b60: 6e20 286e 756d 3120 2d20 6e75 6d32 2920  n (num1 - num2) 
-00017b70: 2f20 2864 656e 3120 2d20 6e75 6d32 290a  / (den1 - num2).
-00017b80: 0a20 2020 2040 6361 6368 6564 5f63 6f6e  .    @cached_con
-00017b90: 7374 2827 6e73 6927 2c20 276c 6f63 616c  st('nsi', 'local
-00017ba0: 2063 6c75 7374 6572 696e 6727 290a 2020   clustering').  
-00017bb0: 2020 6465 6620 6e73 695f 6c6f 6361 6c5f    def nsi_local_
-00017bc0: 636c 7573 7465 7269 6e67 5f75 6e63 6f72  clustering_uncor
-00017bd0: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
-00017be0: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
-00017bf0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
-00017c00: 726e 2069 7473 2075 6e63 6f72 7265 6374  rn its uncorrect
-00017c10: 6564 206e 2e73 2e69 2e20 636c 7573 7465  ed n.s.i. cluste
-00017c20: 7269 6e67 2063 6f65 6666 6963 6965 6e74  ring coefficient
-00017c30: 0a20 2020 2020 2020 2028 6265 7477 6565  .        (betwee
-00017c40: 6e20 3020 616e 6420 3129 2e0a 0a20 2020  n 0 and 1)...   
-00017c50: 2020 2020 2028 6e6f 7420 7965 7420 696d       (not yet im
-00017c60: 706c 656d 656e 7465 6420 666f 7220 6469  plemented for di
-00017c70: 7265 6374 6564 206e 6574 776f 726b 7329  rected networks)
-00017c80: 0a0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
-00017c90: 3a20 6172 7261 7928 5b66 6c6f 6174 5d29  : array([float])
-00017ca0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00017cb0: 2020 2020 2069 6620 7365 6c66 2e64 6972       if self.dir
-00017cc0: 6563 7465 643a 0a20 2020 2020 2020 2020  ected:.         
-00017cd0: 2020 2072 6169 7365 204e 6f74 496d 706c     raise NotImpl
-00017ce0: 656d 656e 7465 6445 7272 6f72 2822 4e6f  ementedError("No
-00017cf0: 7420 696d 706c 656d 656e 7465 6420 666f  t implemented fo
-00017d00: 7220 6469 7265 6374 6564 206e 6574 776f  r directed netwo
-00017d10: 726b 732e 2229 0a0a 2020 2020 2020 2020  rks.")..        
-00017d20: 772c 206b 203d 2073 656c 662e 6e6f 6465  w, k = self.node
-00017d30: 5f77 6569 6768 7473 2c20 7365 6c66 2e6e  _weights, self.n
-00017d40: 7369 5f64 6567 7265 6528 290a 2020 2020  si_degree().    
-00017d50: 2020 2020 415f 4477 203d 2073 656c 662e      A_Dw = self.
-00017d60: 7370 5f41 202a 2073 656c 662e 7370 5f64  sp_A * self.sp_d
-00017d70: 6961 675f 7728 290a 2020 2020 2020 2020  iag_w().        
-00017d80: 6e75 6d65 7261 746f 7220 3d20 2841 5f44  numerator = (A_D
-00017d90: 7720 2a20 7365 6c66 2e73 705f 4170 6c75  w * self.sp_Aplu
-00017da0: 7328 2920 2a20 415f 4477 2e54 292e 6469  s() * A_Dw.T).di
-00017db0: 6167 6f6e 616c 2829 0a20 2020 2020 2020  agonal().       
-00017dc0: 2072 6574 7572 6e20 286e 756d 6572 6174   return (numerat
-00017dd0: 6f72 202b 2032 2a6b 2a77 202d 2077 2a2a  or + 2*k*w - w**
-00017de0: 3229 202f 206b 2a2a 320a 0a20 2020 2064  2) / k**2..    d
-00017df0: 6566 206e 7369 5f6c 6f63 616c 5f63 6c75  ef nsi_local_clu
-00017e00: 7374 6572 696e 6728 7365 6c66 2c20 7479  stering(self, ty
-00017e10: 7069 6361 6c5f 7765 6967 6874 3d4e 6f6e  pical_weight=Non
-00017e20: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
-00017e30: 2020 2020 2020 2020 466f 7220 6561 6368          For each
-00017e40: 206e 6f64 652c 2072 6574 7572 6e20 6974   node, return it
-00017e50: 7320 756e 636f 7272 6563 7465 6420 2862  s uncorrected (b
-00017e60: 6574 7765 656e 2030 2061 6e64 2031 2920  etween 0 and 1) 
-00017e70: 6f72 2063 6f72 7265 6374 6564 0a20 2020  or corrected.   
-00017e80: 2020 2020 2028 6174 206d 6f73 7420 3120       (at most 1 
-00017e90: 2f20 6e65 6761 7469 7665 202f 204e 614e  / negative / NaN
-00017ea0: 2920 6e2e 732e 692e 2063 6c75 7374 6572  ) n.s.i. cluster
-00017eb0: 696e 6720 636f 6566 6669 6369 656e 742e  ing coefficient.
-00017ec0: 0a0a 2020 2020 2020 2020 286e 6f74 2079  ..        (not y
-00017ed0: 6574 2069 6d70 6c65 6d65 6e74 6564 2066  et implemented f
-00017ee0: 6f72 2064 6972 6563 7465 6420 6e65 7477  or directed netw
-00017ef0: 6f72 6b73 290a 0a20 2020 2020 2020 202a  orks)..        *
-00017f00: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-00017f10: 2020 2020 203e 3e3e 206e 6574 203d 204e       >>> net = N
-00017f20: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
-00017f30: 4e65 7477 6f72 6b28 290a 2020 2020 2020  Network().      
-00017f40: 2020 3e3e 3e20 7228 6e65 742e 6e73 695f    >>> r(net.nsi_
-00017f50: 6c6f 6361 6c5f 636c 7573 7465 7269 6e67  local_clustering
-00017f60: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
-00017f70: 756c 6174 696e 6720 6e2e 732e 692e 2064  ulating n.s.i. d
-00017f80: 6567 7265 652e 2e2e 0a20 2020 2020 2020  egree....       
-00017f90: 2061 7272 6179 285b 2030 2e35 3531 332c   array([ 0.5513,
-00017fa0: 2030 2e37 3234 342c 2031 2e20 2c20 302e   0.7244, 1. , 0.
-00017fb0: 3831 3834 2c20 302e 3830 3238 2c20 312e  8184, 0.8028, 1.
-00017fc0: 205d 290a 2020 2020 2020 2020 3e3e 3e20   ]).        >>> 
-00017fd0: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
-00017fe0: 6f70 7928 292e 6e73 695f 6c6f 6361 6c5f  opy().nsi_local_
-00017ff0: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
-00018000: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-00018010: 6720 6e2e 732e 692e 2064 6567 7265 652e  g n.s.i. degree.
-00018020: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-00018030: 285b 2030 2e35 3531 332c 2030 2e37 3234  ([ 0.5513, 0.724
-00018040: 342c 2031 2e20 2c20 302e 3831 3834 2c20  4, 1. , 0.8184, 
-00018050: 302e 3830 3238 2c20 312e 202c 2031 2e20  0.8028, 1. , 1. 
-00018060: 5d29 0a0a 2020 2020 2020 2020 6173 2063  ])..        as c
-00018070: 6f6d 7061 7265 6420 746f 2074 6865 2075  ompared to the u
-00018080: 6e77 6569 6768 7465 6420 7665 7273 696f  nweighted versio
-00018090: 6e3a 0a0a 2020 2020 2020 2020 3e3e 3e20  n:..        >>> 
-000180a0: 6e65 7420 3d20 4e65 7477 6f72 6b2e 536d  net = Network.Sm
-000180b0: 616c 6c54 6573 744e 6574 776f 726b 2829  allTestNetwork()
-000180c0: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
-000180d0: 6574 2e6c 6f63 616c 5f63 6c75 7374 6572  et.local_cluster
-000180e0: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
-000180f0: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
-00018100: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-00018110: 6669 6369 656e 7473 2e2e 2e0a 2020 2020  ficients....    
-00018120: 2020 2020 6172 7261 7928 5b20 302e 202c      array([ 0. ,
-00018130: 2030 2e33 3333 332c 2031 2e20 2c20 302e   0.3333, 1. , 0.
-00018140: 202c 2030 2e33 3333 332c 2030 2e20 5d29   , 0.3333, 0. ])
-00018150: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
-00018160: 6574 2e73 706c 6974 7465 645f 636f 7079  et.splitted_copy
-00018170: 2829 2e6c 6f63 616c 5f63 6c75 7374 6572  ().local_cluster
-00018180: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
-00018190: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
-000181a0: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
-000181b0: 6669 6369 656e 7473 2e2e 2e0a 2020 2020  ficients....    
-000181c0: 2020 2020 6172 7261 7928 5b20 302e 3136      array([ 0.16
-000181d0: 3637 2c20 302e 3333 3333 2c20 312e 202c  67, 0.3333, 1. ,
-000181e0: 2020 302e 202c 2030 2e33 3333 332c 2031    0. , 0.3333, 1
-000181f0: 2e20 2c20 312e 205d 290a 0a20 2020 2020  . , 1. ])..     
-00018200: 2020 203a 7479 7065 2074 7970 6963 616c     :type typical
-00018210: 5f77 6569 6768 743a 2066 6c6f 6174 203e  _weight: float >
-00018220: 2030 0a20 2020 2020 2020 203a 6172 6720   0.        :arg 
-00018230: 2074 7970 6963 616c 5f77 6569 6768 743a   typical_weight:
-00018240: 204f 7074 696f 6e61 6c20 7479 7069 6361   Optional typica
-00018250: 6c20 6e6f 6465 2077 6569 6768 7420 746f  l node weight to
-00018260: 2062 6520 7573 6564 2066 6f72 0a20 2020   be used for.   
-00018270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018280: 2020 2020 2020 2020 2020 2063 6f72 7265             corre
-00018290: 6374 696f 6e2e 2049 6620 4e6f 6e65 2c20  ction. If None, 
-000182a0: 7468 6520 756e 636f 7272 6563 7465 6420  the uncorrected 
-000182b0: 6d65 6173 7572 6520 6973 0a20 2020 2020  measure is.     
-000182c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000182d0: 2020 2020 2020 2020 2072 6574 7572 6e65           returne
-000182e0: 642e 2028 4465 6661 756c 743a 204e 6f6e  d. (Default: Non
-000182f0: 6529 0a0a 2020 2020 2020 2020 3a72 7479  e)..        :rty
-00018300: 7065 3a20 6172 7261 7928 5b66 6c6f 6174  pe: array([float
-00018310: 5d29 0a20 2020 2020 2020 2022 2222 0a20  ]).        """. 
-00018320: 2020 2020 2020 2069 6620 7479 7069 6361         if typica
-00018330: 6c5f 7765 6967 6874 2069 7320 4e6f 6e65  l_weight is None
-00018340: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00018350: 7475 726e 2073 656c 662e 6e73 695f 6c6f  turn self.nsi_lo
-00018360: 6361 6c5f 636c 7573 7465 7269 6e67 5f75  cal_clustering_u
-00018370: 6e63 6f72 7228 290a 2020 2020 2020 2020  ncorr().        
-00018380: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00018390: 2020 6b20 3d20 7365 6c66 2e6e 7369 5f64    k = self.nsi_d
-000183a0: 6567 7265 6528 7479 7069 6361 6c5f 7765  egree(typical_we
-000183b0: 6967 6874 3d74 7970 6963 616c 5f77 6569  ight=typical_wei
-000183c0: 6768 7429 0a20 2020 2020 2020 2020 2020  ght).           
-000183d0: 2069 6620 7365 6c66 2e73 696c 656e 6365   if self.silence
-000183e0: 5f6c 6576 656c 203c 3d20 313a 0a20 2020  _level <= 1:.   
-000183f0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00018400: 6e74 2822 4361 6c63 756c 6174 696e 6720  nt("Calculating 
-00018410: 636f 7272 6563 7465 6420 6e2e 732e 692e  corrected n.s.i.
-00018420: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
-00018430: 2020 2020 2020 2020 2022 6c6f 6361 6c20           "local 
-00018440: 636c 7573 7465 7269 6e67 2063 6f65 6666  clustering coeff
-00018450: 6963 6965 6e74 732e 2e2e 2229 0a0a 2020  icients...")..  
-00018460: 2020 2020 2020 2020 2020 4170 203d 2073            Ap = s
-00018470: 656c 662e 7370 5f41 706c 7573 2829 0a20  elf.sp_Aplus(). 
-00018480: 2020 2020 2020 2020 2020 2041 705f 4477             Ap_Dw
-00018490: 203d 2041 7020 2a20 7365 6c66 2e73 705f   = Ap * self.sp_
-000184a0: 6469 6167 5f77 2829 0a20 2020 2020 2020  diag_w().       
-000184b0: 2020 2020 206e 756d 6572 6174 6f72 203d       numerator =
-000184c0: 2028 4170 5f44 7720 2a20 4170 5f44 7720   (Ap_Dw * Ap_Dw 
-000184d0: 2a20 4170 292e 6469 6167 6f6e 616c 2829  * Ap).diagonal()
-000184e0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000184f0: 7572 6e20 286e 756d 6572 6174 6f72 2f74  urn (numerator/t
-00018500: 7970 6963 616c 5f77 6569 6768 742a 2a32  ypical_weight**2
-00018510: 202d 2033 2e30 2a6b 202d 2031 2e30 2920   - 3.0*k - 1.0) 
-00018520: 2f20 286b 202a 2028 6b2d 312e 3029 290a  / (k * (k-1.0)).
-00018530: 0a20 2020 2040 6361 6368 6564 5f63 6f6e  .    @cached_con
-00018540: 7374 2827 6e73 6927 2c20 2767 6c6f 6261  st('nsi', 'globa
-00018550: 6c20 636c 7573 7465 7269 6e67 272c 0a20  l clustering',. 
-00018560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018570: 2027 6e2e 732e 692e 2067 6c6f 6261 6c20   'n.s.i. global 
-00018580: 746f 706f 6c6f 6769 6361 6c20 636c 7573  topological clus
-00018590: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
-000185a0: 6e74 2729 0a20 2020 2064 6566 206e 7369  nt').    def nsi
-000185b0: 5f67 6c6f 6261 6c5f 636c 7573 7465 7269  _global_clusteri
-000185c0: 6e67 2873 656c 6629 3a0a 2020 2020 2020  ng(self):.      
-000185d0: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
-000185e0: 7475 726e 2074 6865 206e 2e73 2e69 2e20  turn the n.s.i. 
-000185f0: 676c 6f62 616c 2063 6c75 7374 6572 696e  global clusterin
-00018600: 6720 636f 6566 6669 6369 656e 742e 0a0a  g coefficient...
-00018610: 2020 2020 2020 2020 286e 6f74 2079 6574          (not yet
-00018620: 2069 6d70 6c65 6d65 6e74 6564 2066 6f72   implemented for
-00018630: 2064 6972 6563 7465 6420 6e65 7477 6f72   directed networ
-00018640: 6b73 2e29 0a0a 2020 2020 2020 2020 2a2a  ks.)..        **
-00018650: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-00018660: 2020 2020 3e3e 3e20 7228 4e65 7477 6f72      >>> r(Networ
-00018670: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
-00018680: 726b 2829 2e6e 7369 5f67 6c6f 6261 6c5f  rk().nsi_global_
-00018690: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
-000186a0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-000186b0: 6720 6e2e 732e 692e 2067 6c6f 6261 6c20  g n.s.i. global 
-000186c0: 746f 706f 6c6f 6769 6361 6c20 636c 7573  topological clus
-000186d0: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
-000186e0: 6e74 2e2e 2e0a 2020 2020 2020 2020 4361  nt....        Ca
-000186f0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
-00018700: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
-00018710: 2020 2030 2e38 3335 330a 0a20 2020 2020     0.8353..     
-00018720: 2020 2061 7320 636f 6d70 6172 6564 2074     as compared t
-00018730: 6f20 7468 6520 756e 7765 6967 6874 6564  o the unweighted
-00018740: 2076 6572 7369 6f6e 3a0a 0a20 2020 2020   version:..     
-00018750: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
-00018760: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-00018770: 6b28 292e 676c 6f62 616c 5f63 6c75 7374  k().global_clust
-00018780: 6572 696e 6728 2929 0a20 2020 2020 2020  ering()).       
-00018790: 2043 616c 6375 6c61 7469 6e67 2067 6c6f   Calculating glo
-000187a0: 6261 6c20 636c 7573 7465 7269 6e67 2063  bal clustering c
-000187b0: 6f65 6666 6963 6965 6e74 2028 435f 3229  oefficient (C_2)
-000187c0: 2e2e 2e0a 2020 2020 2020 2020 4361 6c63  ....        Calc
-000187d0: 756c 6174 696e 6720 6c6f 6361 6c20 636c  ulating local cl
-000187e0: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
-000187f0: 6965 6e74 732e 2e2e 0a20 2020 2020 2020  ients....       
-00018800: 2030 2e32 3737 380a 0a20 2020 2020 2020   0.2778..       
-00018810: 203a 7274 7970 653a 2066 6c6f 6174 2062   :rtype: float b
-00018820: 6574 7765 656e 2030 2061 6e64 2031 0a20  etween 0 and 1. 
-00018830: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00018840: 2020 2069 6620 7365 6c66 2e64 6972 6563     if self.direc
-00018850: 7465 643a 0a20 2020 2020 2020 2020 2020  ted:.           
-00018860: 2072 6169 7365 204e 6f74 496d 706c 656d   raise NotImplem
-00018870: 656e 7465 6445 7272 6f72 2822 4e6f 7420  entedError("Not 
-00018880: 696d 706c 656d 656e 7465 6420 666f 7220  implemented for 
-00018890: 6469 7265 6374 6564 206e 6574 776f 726b  directed network
-000188a0: 732e 2229 0a0a 2020 2020 2020 2020 7265  s.")..        re
-000188b0: 7475 726e 2028 7365 6c66 2e6e 7369 5f6c  turn (self.nsi_l
-000188c0: 6f63 616c 5f63 6c75 7374 6572 696e 6728  ocal_clustering(
-000188d0: 292e 646f 7428 7365 6c66 2e6e 6f64 655f  ).dot(self.node_
-000188e0: 7765 6967 6874 7329 0a20 2020 2020 2020  weights).       
-000188f0: 2020 2020 2020 2020 202f 2073 656c 662e           / self.
-00018900: 746f 7461 6c5f 6e6f 6465 5f77 6569 6768  total_node_weigh
-00018910: 7429 0a0a 2020 2020 4063 6163 6865 645f  t)..    @cached_
-00018920: 636f 6e73 7428 276e 7369 272c 2027 7472  const('nsi', 'tr
-00018930: 616e 7369 7469 7669 7479 272c 2027 6e2e  ansitivity', 'n.
-00018940: 732e 692e 2074 7261 6e73 6974 6976 6974  s.i. transitivit
-00018950: 7927 290a 2020 2020 6465 6620 6e73 695f  y').    def nsi_
-00018960: 7472 616e 7369 7469 7669 7479 2873 656c  transitivity(sel
-00018970: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-00018980: 2020 2020 2020 2020 5265 7475 726e 2074          Return t
-00018990: 6865 206e 2e73 2e69 2e20 7472 616e 7369  he n.s.i. transi
-000189a0: 7469 7669 7479 2e0a 0a20 2020 2020 2020  tivity...       
-000189b0: 202e 2e20 7761 726e 696e 673a 3a0a 2020   .. warning::.  
-000189c0: 2020 2020 2020 2020 204e 6f74 2079 6574           Not yet
-000189d0: 2069 6d70 6c65 6d65 6e74 6564 210a 0a20   implemented!.. 
-000189e0: 2020 2020 2020 203a 7274 7970 653a 2066         :rtype: f
-000189f0: 6c6f 6174 2062 6574 7765 656e 2030 2061  loat between 0 a
-00018a00: 6e64 2031 0a20 2020 2020 2020 2022 2222  nd 1.        """
-00018a10: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00018a20: 2e64 6972 6563 7465 643a 0a20 2020 2020  .directed:.     
-00018a30: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
-00018a40: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
-00018a50: 2822 4e6f 7420 696d 706c 656d 656e 7465  ("Not implemente
-00018a60: 6420 666f 7220 6469 7265 6374 6564 206e  d for directed n
-00018a70: 6574 776f 726b 732e 2229 0a0a 2020 2020  etworks.")..    
-00018a80: 2020 2020 4120 3d20 7365 6c66 2e73 705f      A = self.sp_
-00018a90: 4170 6c75 7328 290a 2020 2020 2020 2020  Aplus().        
-00018aa0: 415f 4477 203d 2041 202a 2073 656c 662e  A_Dw = A * self.
-00018ab0: 7370 5f64 6961 675f 7728 290a 2020 2020  sp_diag_w().    
-00018ac0: 2020 2020 6e75 6d20 3d20 2841 5f44 7720      num = (A_Dw 
-00018ad0: 2a20 415f 4477 202a 2041 5f44 7729 2e64  * A_Dw * A_Dw).d
-00018ae0: 6961 676f 6e61 6c28 292e 7375 6d28 290a  iagonal().sum().
-00018af0: 2020 2020 2020 2020 6465 6e75 6d20 3d20          denum = 
-00018b00: 2873 656c 662e 7370 5f64 6961 675f 7728  (self.sp_diag_w(
-00018b10: 2920 2a20 415f 4477 202a 2041 5f44 7729  ) * A_Dw * A_Dw)
-00018b20: 2e73 756d 2829 0a0a 2020 2020 2020 2020  .sum()..        
-00018b30: 7265 7475 726e 206e 756d 202f 2064 656e  return num / den
-00018b40: 756d 0a0a 2020 2020 4063 6163 6865 645f  um..    @cached_
-00018b50: 636f 6e73 7428 276e 7369 272c 2027 736f  const('nsi', 'so
-00018b60: 6666 6572 2063 6c75 7374 6572 696e 6727  ffer clustering'
-00018b70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00018b80: 2020 2020 276e 2e73 2e69 2e20 6c6f 6361      'n.s.i. loca
-00018b90: 6c20 536f 6666 6572 2063 6c75 7374 6572  l Soffer cluster
-00018ba0: 696e 6720 636f 6566 6669 6369 656e 7473  ing coefficients
-00018bb0: 2729 0a20 2020 2064 6566 206e 7369 5f6c  ').    def nsi_l
-00018bc0: 6f63 616c 5f73 6f66 6665 725f 636c 7573  ocal_soffer_clus
-00018bd0: 7465 7269 6e67 2873 656c 6629 3a0a 2020  tering(self):.  
-00018be0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00018bf0: 2020 466f 7220 6561 6368 206e 6f64 652c    For each node,
-00018c00: 2072 6574 7572 6e20 6974 7320 6e2e 732e   return its n.s.
-00018c10: 692e 2063 6c75 7374 6572 696e 6720 636f  i. clustering co
-00018c20: 6566 6669 6369 656e 740a 2020 2020 2020  efficient.      
-00018c30: 2020 7769 7468 2062 6961 732d 7265 6475    with bias-redu
-00018c40: 6374 696f 6e20 666f 6c6c 6f77 696e 6720  ction following 
-00018c50: 5b53 6f66 6665 7232 3030 355d 5f2e 0a0a  [Soffer2005]_...
-00018c60: 2020 2020 2020 2020 286e 6f74 2079 6574          (not yet
-00018c70: 2069 6d70 6c65 6d65 6e74 6564 2066 6f72   implemented for
-00018c80: 2064 6972 6563 7465 6420 6e65 7477 6f72   directed networ
-00018c90: 6b73 2e29 0a0a 2020 2020 2020 2020 2a2a  ks.)..        **
-00018ca0: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-00018cb0: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-00018cc0: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-00018cd0: 6574 776f 726b 2829 0a20 2020 2020 2020  etwork().       
-00018ce0: 203e 3e3e 2072 286e 6574 2e6e 7369 5f6c   >>> r(net.nsi_l
-00018cf0: 6f63 616c 5f73 6f66 6665 725f 636c 7573  ocal_soffer_clus
-00018d00: 7465 7269 6e67 2829 290a 2020 2020 2020  tering()).      
-00018d10: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
-00018d20: 732e 692e 206c 6f63 616c 2053 6f66 6665  s.i. local Soffe
-00018d30: 7220 636c 7573 7465 7269 6e67 2063 6f65  r clustering coe
-00018d40: 6666 6963 6965 6e74 732e 2e2e 0a20 2020  fficients....   
-00018d50: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-00018d60: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
-00018d70: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
-00018d80: 5b20 302e 3736 3635 2c20 302e 3837 3534  [ 0.7665, 0.8754
-00018d90: 2c20 312e 202c 2030 2e38 3138 342c 2030  , 1. , 0.8184, 0
-00018da0: 2e38 3436 392c 2031 2e20 5d29 0a20 2020  .8469, 1. ]).   
-00018db0: 2020 2020 203e 3e3e 2072 286e 6574 2e73       >>> r(net.s
-00018dc0: 706c 6974 7465 645f 636f 7079 2829 2e6e  plitted_copy().n
-00018dd0: 7369 5f6c 6f63 616c 5f73 6f66 6665 725f  si_local_soffer_
-00018de0: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
-00018df0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-00018e00: 6720 6e2e 732e 692e 206c 6f63 616c 2053  g n.s.i. local S
-00018e10: 6f66 6665 7220 636c 7573 7465 7269 6e67  offer clustering
-00018e20: 2063 6f65 6666 6963 6965 6e74 732e 2e2e   coefficients...
-00018e30: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
-00018e40: 7469 6e67 206e 2e73 2e69 2e20 6465 6772  ting n.s.i. degr
-00018e50: 6565 2e2e 2e0a 2020 2020 2020 2020 6172  ee....        ar
-00018e60: 7261 7928 5b20 302e 3736 3635 2c20 302e  ray([ 0.7665, 0.
-00018e70: 3837 3534 2c20 312e 202c 2030 2e38 3138  8754, 1. , 0.818
-00018e80: 342c 2030 2e38 3436 392c 2031 2e20 2c20  4, 0.8469, 1. , 
-00018e90: 312e 205d 290a 0a20 2020 2020 2020 2061  1. ])..        a
-00018ea0: 7320 636f 6d70 6172 6564 2074 6f20 7468  s compared to th
-00018eb0: 6520 7665 7273 696f 6e20 7769 7468 6f75  e version withou
-00018ec0: 7420 6269 6173 2d72 6564 7563 7469 6f6e  t bias-reduction
-00018ed0: 3a0a 0a20 2020 2020 2020 203e 3e3e 2072  :..        >>> r
-00018ee0: 284e 6574 776f 726b 2e53 6d61 6c6c 5465  (Network.SmallTe
-00018ef0: 7374 4e65 7477 6f72 6b28 292e 6e73 695f  stNetwork().nsi_
-00018f00: 6c6f 6361 6c5f 636c 7573 7465 7269 6e67  local_clustering
-00018f10: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
-00018f20: 756c 6174 696e 6720 6e2e 732e 692e 2064  ulating n.s.i. d
-00018f30: 6567 7265 652e 2e2e 0a20 2020 2020 2020  egree....       
-00018f40: 2061 7272 6179 285b 2030 2e35 3531 332c   array([ 0.5513,
-00018f50: 2030 2e37 3234 342c 2031 2e20 2c20 302e   0.7244, 1. , 0.
-00018f60: 3831 3834 2c20 302e 3830 3238 2c20 312e  8184, 0.8028, 1.
-00018f70: 205d 290a 0a20 2020 2020 2020 203a 7274   ])..        :rt
-00018f80: 7970 653a 2031 6420 6e75 6d70 7920 6172  ype: 1d numpy ar
-00018f90: 7261 7920 5b6e 6f64 655d 206f 6620 666c  ray [node] of fl
-00018fa0: 6f61 7473 2062 6574 7765 656e 2030 2061  oats between 0 a
-00018fb0: 6e64 2031 0a20 2020 2020 2020 2022 2222  nd 1.        """
-00018fc0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00018fd0: 2e64 6972 6563 7465 643a 0a20 2020 2020  .directed:.     
-00018fe0: 2020 2020 2020 2072 6169 7365 204e 6f74         raise Not
-00018ff0: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
-00019000: 2822 4e6f 7420 696d 706c 656d 656e 7465  ("Not implemente
-00019010: 6420 666f 7220 6469 7265 6374 6564 206e  d for directed n
-00019020: 6574 776f 726b 732e 2229 0a0a 2020 2020  etworks.")..    
-00019030: 2020 2020 2320 6e75 6d65 7261 746f 7220      # numerator 
-00019040: 6973 2064 6574 6572 6d69 6e65 6420 6173  is determined as
-00019050: 2061 626f 7665 0a20 2020 2020 2020 2041   above.        A
-00019060: 7020 3d20 7365 6c66 2e73 705f 4170 6c75  p = self.sp_Aplu
-00019070: 7328 290a 2020 2020 2020 2020 4170 5f44  s().        Ap_D
-00019080: 7720 3d20 4170 202a 2073 656c 662e 7370  w = Ap * self.sp
-00019090: 5f64 6961 675f 7728 290a 2020 2020 2020  _diag_w().      
-000190a0: 2020 6e75 6d65 7261 746f 7220 3d20 2841    numerator = (A
-000190b0: 705f 4477 202a 2041 705f 4477 202a 2041  p_Dw * Ap_Dw * A
-000190c0: 7029 2e64 6961 676f 6e61 6c28 290a 0a20  p).diagonal().. 
-000190d0: 2020 2020 2020 2023 2064 656e 6f6d 696e         # denomin
-000190e0: 6174 6f72 2064 6570 656e 6473 206f 6e20  ator depends on 
-000190f0: 6465 6772 6565 7320 6f66 206e 6569 6768  degrees of neigh
-00019100: 626f 7572 730a 2020 2020 2020 2020 4e2c  bours.        N,
-00019110: 206b 203d 2073 656c 662e 4e2c 2073 656c   k = self.N, sel
-00019120: 662e 6e73 695f 6465 6772 6565 2829 0a20  f.nsi_degree(). 
-00019130: 2020 2020 2020 206d 696e 6b20 3d20 6e70         mink = np
-00019140: 2e61 7272 6179 285b 5b6d 696e 286b 5b69  .array([[min(k[i
-00019150: 5d2c 206b 5b6a 5d29 2066 6f72 206a 2069  ], k[j]) for j i
-00019160: 6e20 7261 6e67 6528 4e29 5d0a 2020 2020  n range(N)].    
-00019170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019180: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
-00019190: 6e67 6528 4e29 5d29 0a20 2020 2020 2020  nge(N)]).       
-000191a0: 2064 656e 6f6d 696e 6174 6f72 203d 2028   denominator = (
-000191b0: 6d69 6e6b 202a 2028 7365 6c66 2e73 705f  mink * (self.sp_
-000191c0: 6469 6167 5f77 2829 202a 2041 7029 292e  diag_w() * Ap)).
-000191d0: 6469 6167 6f6e 616c 2829 0a20 2020 2020  diagonal().     
-000191e0: 2020 2072 6574 7572 6e20 6e75 6d65 7261     return numera
-000191f0: 746f 7220 2f20 6465 6e6f 6d69 6e61 746f  tor / denominato
-00019200: 720a 0a20 2020 2023 0a20 2020 2023 2020  r..    #.    #  
-00019210: 4d65 6173 7572 6520 7061 7468 206c 656e  Measure path len
-00019220: 6774 6873 0a20 2020 2023 0a0a 2020 2020  gths.    #..    
-00019230: 4063 6163 6865 645f 7661 7228 2770 6174  @cached_var('pat
-00019240: 6873 2729 0a20 2020 2064 6566 2070 6174  hs').    def pat
-00019250: 685f 6c65 6e67 7468 7328 7365 6c66 2c20  h_lengths(self, 
-00019260: 6c69 6e6b 5f61 7474 7269 6275 7465 3d4e  link_attribute=N
-00019270: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
-00019280: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-00019290: 6368 2070 6169 7220 6f66 206e 6f64 6573  ch pair of nodes
-000192a0: 2069 2c6a 2c20 7265 7475 726e 2074 6865   i,j, return the
-000192b0: 2028 7765 6967 6874 6564 2920 7368 6f72   (weighted) shor
-000192c0: 7465 7374 2070 6174 6820 6c65 6e67 7468  test path length
-000192d0: 0a20 2020 2020 2020 2066 726f 6d20 6920  .        from i 
-000192e0: 746f 206a 2028 616c 736f 2063 616c 6c65  to j (also calle
-000192f0: 6420 7468 6520 6469 7374 616e 6365 2066  d the distance f
-00019300: 726f 6d20 6920 746f 206a 292e 0a0a 2020  rom i to j)...  
-00019310: 2020 2020 2020 5468 6973 2069 7320 7468        This is th
-00019320: 6520 7368 6f72 7465 7374 206c 656e 6774  e shortest lengt
-00019330: 6820 6f66 2061 2070 6174 6820 6672 6f6d  h of a path from
-00019340: 2069 2074 6f20 6a20 616c 6f6e 6720 6c69   i to j along li
-00019350: 6e6b 732c 0a20 2020 2020 2020 206f 7220  nks,.        or 
-00019360: 696e 6669 6e69 7479 2069 6620 7468 6572  infinity if ther
-00019370: 6520 6973 206e 6f20 7375 6368 2070 6174  e is no such pat
-00019380: 682e 0a0a 2020 2020 2020 2020 5468 6520  h...        The 
-00019390: 6c65 6e67 7468 206f 6620 6c69 6e6b 7320  length of links 
-000193a0: 6361 6e20 6265 2073 7065 6369 6669 6564  can be specified
-000193b0: 2062 7920 616e 206f 7074 696f 6e61 6c20   by an optional 
-000193c0: 6c69 6e6b 2061 7474 7269 6275 7465 2e0a  link attribute..
-000193d0: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
-000193e0: 6c65 3a2a 2a0a 0a20 2020 2020 2020 203e  le:**..        >
-000193f0: 3e3e 2070 7269 6e74 284e 6574 776f 726b  >> print(Network
-00019400: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-00019410: 6b28 292e 7061 7468 5f6c 656e 6774 6873  k().path_lengths
-00019420: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
-00019430: 756c 6174 696e 6720 616c 6c20 7368 6f72  ulating all shor
-00019440: 7465 7374 2070 6174 6820 6c65 6e67 7468  test path length
-00019450: 732e 2e2e 0a20 2020 2020 2020 205b 5b20  s....        [[ 
-00019460: 302e 2020 322e 2020 322e 2020 312e 2020  0.  2.  2.  1.  
-00019470: 312e 2020 312e 5d0a 2020 2020 2020 2020  1.  1.].        
-00019480: 205b 2032 2e20 2030 2e20 2031 2e20 2031   [ 2.  0.  1.  1
-00019490: 2e20 2031 2e20 2033 2e5d 0a20 2020 2020  .  1.  3.].     
-000194a0: 2020 2020 5b20 322e 2020 312e 2020 302e      [ 2.  1.  0.
-000194b0: 2020 322e 2020 312e 2020 332e 5d0a 2020    2.  1.  3.].  
-000194c0: 2020 2020 2020 205b 2031 2e20 2031 2e20         [ 1.  1. 
-000194d0: 2032 2e20 2030 2e20 2032 2e20 2032 2e5d   2.  0.  2.  2.]
-000194e0: 0a20 2020 2020 2020 2020 5b20 312e 2020  .         [ 1.  
-000194f0: 312e 2020 312e 2020 322e 2020 302e 2020  1.  1.  2.  0.  
-00019500: 322e 5d0a 2020 2020 2020 2020 205b 2031  2.].         [ 1
-00019510: 2e20 2033 2e20 2033 2e20 2032 2e20 2032  .  3.  3.  2.  2
-00019520: 2e20 2030 2e5d 5d0a 0a20 2020 2020 2020  .  0.]]..       
-00019530: 203a 6172 6720 7374 7220 6c69 6e6b 5f61   :arg str link_a
-00019540: 7474 7269 6275 7465 3a20 4f70 7469 6f6e  ttribute: Option
-00019550: 616c 206e 616d 6520 6f66 2074 6865 206c  al name of the l
-00019560: 696e 6b20 6174 7472 6962 7574 6520 746f  ink attribute to
-00019570: 2062 6520 7573 6564 0a20 2020 2020 2020   be used.       
-00019580: 2020 2020 2061 7320 7468 6520 6c69 6e6b       as the link
-00019590: 7327 206c 656e 6774 682e 2049 6620 4e6f  s' length. If No
-000195a0: 6e65 2c20 6c69 6e6b 7320 6861 7665 206c  ne, links have l
-000195b0: 656e 6774 6820 312e 2028 4465 6661 756c  ength 1. (Defaul
-000195c0: 743a 204e 6f6e 6529 0a20 2020 2020 2020  t: None).       
-000195d0: 203a 7274 7970 653a 2073 7175 6172 6520   :rtype: square 
-000195e0: 6172 7261 7920 5b5b 666c 6f61 745d 5d0a  array [[float]].
-000195f0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00019600: 2020 2020 6966 206c 696e 6b5f 6174 7472      if link_attr
-00019610: 6962 7574 6520 3d3d 2022 746f 706f 6c6f  ibute == "topolo
-00019620: 6769 6361 6c22 3a0a 2020 2020 2020 2020  gical":.        
-00019630: 2020 2020 7072 696e 7428 2257 4152 4e49      print("WARNI
-00019640: 4e47 3a20 6c69 6e6b 5f61 7474 7269 6275  NG: link_attribu
-00019650: 7465 3d27 746f 706f 6c6f 6769 6361 6c27  te='topological'
-00019660: 2069 7320 6465 7072 6563 6174 6564 2e5c   is deprecated.\
-00019670: 6e22 0a20 2020 2020 2020 2020 2020 2020  n".             
-00019680: 2020 2020 202b 2022 5573 6520 6c69 6e6b       + "Use link
-00019690: 5f61 7474 7269 6275 7465 3d4e 6f6e 6520  _attribute=None 
-000196a0: 696e 7374 6561 642e 2229 0a20 2020 2020  instead.").     
-000196b0: 2020 2020 2020 206c 696e 6b5f 6174 7472         link_attr
-000196c0: 6962 7574 6520 3d20 4e6f 6e65 0a0a 2020  ibute = None..  
-000196d0: 2020 2020 2020 6966 206c 696e 6b5f 6174        if link_at
-000196e0: 7472 6962 7574 6520 6973 204e 6f6e 653a  tribute is None:
-000196f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00019700: 7365 6c66 2e73 696c 656e 6365 5f6c 6576  self.silence_lev
-00019710: 656c 203c 3d20 313a 0a20 2020 2020 2020  el <= 1:.       
-00019720: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
-00019730: 4361 6c63 756c 6174 696e 6720 616c 6c20  Calculating all 
-00019740: 7368 6f72 7465 7374 2070 6174 6820 6c65  shortest path le
-00019750: 6e67 7468 732e 2e2e 2229 0a0a 2020 2020  ngths...")..    
-00019760: 2020 2020 2020 2020 2320 6669 7865 6420          # fixed 
-00019770: 6e65 6761 7469 7665 206e 756d 6265 7273  negative numbers
-00019780: 2074 6f20 696e 6669 6e69 7479 210a 2020   to infinity!.  
-00019790: 2020 2020 2020 2020 2020 706c 203d 206e            pl = n
-000197a0: 702e 6172 7261 7928 7365 6c66 2e67 7261  p.array(self.gra
-000197b0: 7068 2e73 686f 7274 6573 745f 7061 7468  ph.shortest_path
-000197c0: 7328 292c 2064 7479 7065 3d66 6c6f 6174  s(), dtype=float
-000197d0: 290a 2020 2020 2020 2020 2020 2020 706c  ).            pl
-000197e0: 5b70 6c20 3c20 305d 203d 206e 702e 696e  [pl < 0] = np.in
-000197f0: 660a 2020 2020 2020 2020 2020 2020 7265  f.            re
-00019800: 7475 726e 2070 6c0a 2020 2020 2020 2020  turn pl.        
-00019810: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00019820: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
-00019830: 655f 6c65 7665 6c20 3c3d 2031 3a0a 2020  e_level <= 1:.  
-00019840: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00019850: 696e 7428 2243 616c 6375 6c61 7469 6e67  int("Calculating
-00019860: 2077 6569 6768 7465 6420 7368 6f72 7465   weighted shorte
-00019870: 7374 2070 6174 6820 6c65 6e67 7468 732e  st path lengths.
-00019880: 2e2e 2229 0a0a 2020 2020 2020 2020 2020  ..")..          
-00019890: 2020 7265 7475 726e 206e 702e 6172 7261    return np.arra
-000198a0: 7928 0a20 2020 2020 2020 2020 2020 2020  y(.             
-000198b0: 2020 2073 656c 662e 6772 6170 682e 7368     self.graph.sh
-000198c0: 6f72 7465 7374 5f70 6174 6873 2877 6569  ortest_paths(wei
-000198d0: 6768 7473 3d6c 696e 6b5f 6174 7472 6962  ghts=link_attrib
-000198e0: 7574 652c 206d 6f64 653d 3129 290a 0a20  ute, mode=1)).. 
-000198f0: 2020 2064 6566 2061 7665 7261 6765 5f70     def average_p
-00019900: 6174 685f 6c65 6e67 7468 2873 656c 662c  ath_length(self,
-00019910: 206c 696e 6b5f 6174 7472 6962 7574 653d   link_attribute=
-00019920: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
-00019930: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
-00019940: 6e20 7468 6520 6176 6572 6167 6520 2877  n the average (w
-00019950: 6569 6768 7465 6429 2073 686f 7274 6573  eighted) shortes
-00019960: 7420 7061 7468 206c 656e 6774 6820 6265  t path length be
-00019970: 7477 6565 6e20 616c 6c20 7061 6972 730a  tween all pairs.
-00019980: 2020 2020 2020 2020 6f66 206e 6f64 6573          of nodes
-00019990: 2066 6f72 2077 6869 6368 2061 2070 6174   for which a pat
-000199a0: 6820 6578 6973 7473 2e0a 0a20 2020 2020  h exists...     
-000199b0: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
-000199c0: 0a20 2020 2020 2020 203e 3e3e 2070 7269  .        >>> pri
-000199d0: 6e74 2872 284e 6574 776f 726b 2e53 6d61  nt(r(Network.Sma
-000199e0: 6c6c 5465 7374 4e65 7477 6f72 6b28 292e  llTestNetwork().
-000199f0: 6176 6572 6167 655f 7061 7468 5f6c 656e  average_path_len
-00019a00: 6774 6828 2929 290a 2020 2020 2020 2020  gth())).        
-00019a10: 4361 6c63 756c 6174 696e 6720 6176 6572  Calculating aver
-00019a20: 6167 6520 2877 6569 6768 7465 6429 2073  age (weighted) s
-00019a30: 686f 7274 6573 7420 7061 7468 206c 656e  hortest path len
-00019a40: 6774 682e 2e2e 0a20 2020 2020 2020 2031  gth....        1
-00019a50: 2e36 3636 370a 0a20 2020 2020 2020 203a  .6667..        :
-00019a60: 6172 6720 7374 7220 6c69 6e6b 5f61 7474  arg str link_att
-00019a70: 7269 6275 7465 3a20 4f70 7469 6f6e 616c  ribute: Optional
-00019a80: 206e 616d 6520 6f66 2074 6865 206c 696e   name of the lin
-00019a90: 6b20 6174 7472 6962 7574 6520 746f 2062  k attribute to b
-00019aa0: 6520 7573 6564 0a20 2020 2020 2020 2020  e used.         
-00019ab0: 2020 2061 7320 7468 6520 6c69 6e6b 7327     as the links'
-00019ac0: 206c 656e 6774 682e 2049 6620 4e6f 6e65   length. If None
-00019ad0: 2c20 6c69 6e6b 7320 6861 7665 206c 656e  , links have len
-00019ae0: 6774 6820 312e 2028 4465 6661 756c 743a  gth 1. (Default:
-00019af0: 204e 6f6e 6529 0a20 2020 2020 2020 203a   None).        :
-00019b00: 7274 7970 653a 2066 6c6f 6174 0a20 2020  rtype: float.   
-00019b10: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00019b20: 2069 6620 6c69 6e6b 5f61 7474 7269 6275   if link_attribu
-00019b30: 7465 203d 3d20 2274 6f70 6f6c 6f67 6963  te == "topologic
-00019b40: 616c 223a 0a20 2020 2020 2020 2020 2020  al":.           
-00019b50: 2070 7269 6e74 2822 5741 524e 494e 473a   print("WARNING:
-00019b60: 206c 696e 6b5f 6174 7472 6962 7574 653d   link_attribute=
-00019b70: 2774 6f70 6f6c 6f67 6963 616c 2720 6973  'topological' is
-00019b80: 2064 6570 7265 6361 7465 642e 5c6e 220a   deprecated.\n".
-00019b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019ba0: 2020 2b20 2255 7365 206c 696e 6b5f 6174    + "Use link_at
-00019bb0: 7472 6962 7574 653d 4e6f 6e65 2069 6e73  tribute=None ins
-00019bc0: 7465 6164 2e22 290a 2020 2020 2020 2020  tead.").        
-00019bd0: 2020 2020 6c69 6e6b 5f61 7474 7269 6275      link_attribu
-00019be0: 7465 203d 204e 6f6e 650a 0a20 2020 2020  te = None..     
-00019bf0: 2020 2069 6620 7365 6c66 2e73 696c 656e     if self.silen
-00019c00: 6365 5f6c 6576 656c 203c 3d20 313a 0a20  ce_level <= 1:. 
-00019c10: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00019c20: 2822 4361 6c63 756c 6174 696e 6720 6176  ("Calculating av
-00019c30: 6572 6167 6520 2877 6569 6768 7465 6429  erage (weighted)
-00019c40: 2073 686f 7274 6573 7420 7061 7468 206c   shortest path l
-00019c50: 656e 6774 682e 2e2e 2229 0a0a 2020 2020  ength...")..    
-00019c60: 2020 2020 6966 206c 696e 6b5f 6174 7472      if link_attr
-00019c70: 6962 7574 6520 6973 204e 6f6e 653a 0a20  ibute is None:. 
-00019c80: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00019c90: 6e20 7365 6c66 2e67 7261 7068 2e61 7665  n self.graph.ave
-00019ca0: 7261 6765 5f70 6174 685f 6c65 6e67 7468  rage_path_length
-00019cb0: 2829 0a20 2020 2020 2020 2065 6c73 653a  ().        else:
-00019cc0: 0a20 2020 2020 2020 2020 2020 2070 6174  .            pat
-00019cd0: 685f 6c65 6e67 7468 7320 3d20 7365 6c66  h_lengths = self
-00019ce0: 2e70 6174 685f 6c65 6e67 7468 7328 6c69  .path_lengths(li
-00019cf0: 6e6b 5f61 7474 7269 6275 7465 290a 0a20  nk_attribute).. 
-00019d00: 2020 2020 2020 2020 2020 2023 2020 4964             #  Id
-00019d10: 656e 7469 6679 2075 6e63 6f6e 6e65 6374  entify unconnect
-00019d20: 6564 2070 6169 7273 2061 6e64 2073 6176  ed pairs and sav
-00019d30: 6520 696e 2062 696e 6172 7920 6172 7261  e in binary arra
-00019d40: 7920 6973 696e 660a 2020 2020 2020 2020  y isinf.        
-00019d50: 2020 2020 756e 636f 6e6e 6563 7465 645f      unconnected_
-00019d60: 7061 6972 7320 3d20 6e70 2e69 7369 6e66  pairs = np.isinf
-00019d70: 2870 6174 685f 6c65 6e67 7468 7329 0a20  (path_lengths). 
-00019d80: 2020 2020 2020 2020 2020 2023 2020 436f             #  Co
-00019d90: 756e 7420 7468 6520 6e75 6d62 6572 206f  unt the number o
-00019da0: 6620 756e 636f 6e6e 6563 7465 6420 7061  f unconnected pa
-00019db0: 6972 730a 2020 2020 2020 2020 2020 2020  irs.            
-00019dc0: 6e5f 756e 636f 6e6e 6563 7465 645f 7061  n_unconnected_pa
-00019dd0: 6972 7320 3d20 756e 636f 6e6e 6563 7465  irs = unconnecte
-00019de0: 645f 7061 6972 732e 7375 6d28 290a 2020  d_pairs.sum().  
-00019df0: 2020 2020 2020 2020 2020 2320 2053 6574            #  Set
-00019e00: 2069 6e66 696e 6974 6520 656e 7472 6965   infinite entrie
-00019e10: 7320 636f 7272 6573 706f 6e64 696e 6720  s corresponding 
-00019e20: 746f 2075 6e63 6f6e 6e65 6374 6564 2070  to unconnected p
-00019e30: 6169 7273 2074 6f20 7a65 726f 0a20 2020  airs to zero.   
-00019e40: 2020 2020 2020 2020 2070 6174 685f 6c65           path_le
-00019e50: 6e67 7468 735b 756e 636f 6e6e 6563 7465  ngths[unconnecte
-00019e60: 645f 7061 6972 735d 203d 2030 0a0a 2020  d_pairs] = 0..  
-00019e70: 2020 2020 2020 2020 2020 2320 2054 616b            #  Tak
-00019e80: 6520 6176 6572 6167 6520 6f66 2073 686f  e average of sho
-00019e90: 7274 6573 7420 6765 6f67 7261 7068 6963  rtest geographic
-00019ea0: 616c 2070 6174 6820 6c65 6e67 7468 206d  al path length m
-00019eb0: 6174 7269 780a 2020 2020 2020 2020 2020  atrix.          
-00019ec0: 2020 2320 2065 7863 6c75 6469 6e67 2074    #  excluding t
-00019ed0: 6865 2064 6961 676f 6e61 6c2c 2073 696e  he diagonal, sin
-00019ee0: 6365 2069 7420 6973 2061 6c77 6179 7320  ce it is always 
-00019ef0: 7a65 726f 2c20 616e 6420 616c 6c0a 2020  zero, and all.  
-00019f00: 2020 2020 2020 2020 2020 2320 2075 6e63            #  unc
-00019f10: 6f6e 6e65 6374 6564 2070 6169 7273 2e20  onnected pairs. 
-00019f20: 2054 6865 2064 6961 676f 6e61 6c20 7368   The diagonal sh
-00019f30: 6f75 6c64 206e 6576 6572 2063 6f6e 7461  ould never conta
-00019f40: 696e 0a20 2020 2020 2020 2020 2020 2023  in.            #
-00019f50: 2020 696e 6669 6e69 7469 6573 2c20 736f    infinities, so
-00019f60: 2074 6861 7420 7368 6f75 6c64 206e 6f74   that should not
-00019f70: 2062 6520 6120 7072 6f62 6c65 6d2e 0a20   be a problem.. 
-00019f80: 2020 2020 2020 2020 2020 2061 7665 7261             avera
-00019f90: 6765 5f70 6174 685f 6c65 6e67 7468 203d  ge_path_length =
-00019fa0: 2028 7061 7468 5f6c 656e 6774 6873 2e73   (path_lengths.s
-00019fb0: 756d 2829 202f 2066 6c6f 6174 280a 2020  um() / float(.  
-00019fc0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00019fd0: 6c66 2e4e 202a 2028 7365 6c66 2e4e 202d  lf.N * (self.N -
-00019fe0: 2031 2920 2d20 6e5f 756e 636f 6e6e 6563   1) - n_unconnec
-00019ff0: 7465 645f 7061 6972 7329 290a 0a20 2020  ted_pairs))..   
-0001a000: 2020 2020 2020 2020 2023 2020 5265 7665           #  Reve
-0001a010: 7273 6520 6368 616e 6765 7320 746f 2070  rse changes to p
-0001a020: 6174 685f 6c65 6e67 7468 730a 2020 2020  ath_lengths.    
-0001a030: 2020 2020 2020 2020 7061 7468 5f6c 656e          path_len
-0001a040: 6774 6873 5b75 6e63 6f6e 6e65 6374 6564  gths[unconnected
-0001a050: 5f70 6169 7273 5d20 3d20 6e70 2e69 6e66  _pairs] = np.inf
-0001a060: 0a0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-0001a070: 7475 726e 2061 7665 7261 6765 5f70 6174  turn average_pat
-0001a080: 685f 6c65 6e67 7468 0a0a 2020 2020 4063  h_length..    @c
-0001a090: 6163 6865 645f 636f 6e73 7428 276e 7369  ached_const('nsi
-0001a0a0: 272c 2027 6176 6720 7061 7468 206c 656e  ', 'avg path len
-0001a0b0: 6774 6827 2c0a 2020 2020 2020 2020 2020  gth',.          
-0001a0c0: 2020 2020 2020 2020 276e 2e73 2e69 2e20          'n.s.i. 
-0001a0d0: 6176 6572 6167 6520 7368 6f72 7465 7374  average shortest
-0001a0e0: 2070 6174 6820 6c65 6e67 7468 2729 0a20   path length'). 
-0001a0f0: 2020 2064 6566 206e 7369 5f61 7665 7261     def nsi_avera
-0001a100: 6765 5f70 6174 685f 6c65 6e67 7468 2873  ge_path_length(s
-0001a110: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-0001a120: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
-0001a130: 2074 6865 206e 2e73 2e69 2e20 6176 6572   the n.s.i. aver
-0001a140: 6167 6520 7368 6f72 7465 7374 2070 6174  age shortest pat
-0001a150: 6820 6c65 6e67 7468 2062 6574 7765 656e  h length between
-0001a160: 2061 6c6c 2070 6169 7273 206f 660a 2020   all pairs of.  
-0001a170: 2020 2020 2020 6e6f 6465 7320 666f 7220        nodes for 
-0001a180: 7768 6963 6820 6120 7061 7468 2065 7869  which a path exi
-0001a190: 7374 732e 0a0a 2020 2020 2020 2020 5468  sts...        Th
-0001a1a0: 6520 7061 7468 206c 656e 6774 6820 6672  e path length fr
-0001a1b0: 6f6d 2061 206e 6f64 6520 746f 2069 7473  om a node to its
-0001a1c0: 656c 6620 6973 2063 6f6e 7369 6465 7265  elf is considere
-0001a1d0: 6420 746f 2062 6520 3120 746f 2061 6368  d to be 1 to ach
-0001a1e0: 6965 7665 0a20 2020 2020 2020 206e 6f64  ieve.        nod
-0001a1f0: 6520 7370 6c69 7474 696e 6720 696e 7661  e splitting inva
-0001a200: 7269 616e 6365 2e0a 0a20 2020 2020 2020  riance...       
-0001a210: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
-0001a220: 2020 2020 2020 203e 3e3e 206e 6574 203d         >>> net =
-0001a230: 204e 6574 776f 726b 2e53 6d61 6c6c 5465   Network.SmallTe
-0001a240: 7374 4e65 7477 6f72 6b28 290a 2020 2020  stNetwork().    
-0001a250: 2020 2020 3e3e 3e20 7228 6e65 742e 6e73      >>> r(net.ns
-0001a260: 695f 6176 6572 6167 655f 7061 7468 5f6c  i_average_path_l
-0001a270: 656e 6774 6828 2929 0a20 2020 2020 2020  ength()).       
-0001a280: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
-0001a290: 2e69 2e20 6176 6572 6167 6520 7368 6f72  .i. average shor
-0001a2a0: 7465 7374 2070 6174 6820 6c65 6e67 7468  test path length
-0001a2b0: 2e2e 2e0a 2020 2020 2020 2020 4361 6c63  ....        Calc
-0001a2c0: 756c 6174 696e 6720 616c 6c20 7368 6f72  ulating all shor
-0001a2d0: 7465 7374 2070 6174 6820 6c65 6e67 7468  test path length
-0001a2e0: 732e 2e2e 0a20 2020 2020 2020 2031 2e36  s....        1.6
-0001a2f0: 3030 330a 2020 2020 2020 2020 3e3e 3e20  003.        >>> 
-0001a300: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
-0001a310: 6f70 7928 292e 6e73 695f 6176 6572 6167  opy().nsi_averag
-0001a320: 655f 7061 7468 5f6c 656e 6774 6828 2929  e_path_length())
-0001a330: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
-0001a340: 7469 6e67 206e 2e73 2e69 2e20 6176 6572  ting n.s.i. aver
-0001a350: 6167 6520 7368 6f72 7465 7374 2070 6174  age shortest pat
-0001a360: 6820 6c65 6e67 7468 2e2e 2e0a 2020 2020  h length....    
-0001a370: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-0001a380: 616c 6c20 7368 6f72 7465 7374 2070 6174  all shortest pat
-0001a390: 6820 6c65 6e67 7468 732e 2e2e 0a20 2020  h lengths....   
-0001a3a0: 2020 2020 2031 2e36 3030 330a 0a20 2020       1.6003..   
-0001a3b0: 2020 2020 2061 7320 636f 6d70 6172 6564       as compared
-0001a3c0: 2074 6f20 7468 6520 756e 7765 6967 6874   to the unweight
-0001a3d0: 6564 2076 6572 7369 6f6e 3a0a 0a20 2020  ed version:..   
-0001a3e0: 2020 2020 203e 3e3e 206e 6574 203d 204e       >>> net = N
-0001a3f0: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
-0001a400: 4e65 7477 6f72 6b28 290a 2020 2020 2020  Network().      
-0001a410: 2020 3e3e 3e20 7228 6e65 742e 6176 6572    >>> r(net.aver
-0001a420: 6167 655f 7061 7468 5f6c 656e 6774 6828  age_path_length(
-0001a430: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
-0001a440: 6c61 7469 6e67 2061 7665 7261 6765 2028  lating average (
-0001a450: 7765 6967 6874 6564 2920 7368 6f72 7465  weighted) shorte
-0001a460: 7374 2070 6174 6820 6c65 6e67 7468 2e2e  st path length..
-0001a470: 2e0a 2020 2020 2020 2020 312e 3636 3637  ..        1.6667
-0001a480: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
-0001a490: 6574 2e73 706c 6974 7465 645f 636f 7079  et.splitted_copy
-0001a4a0: 2829 2e61 7665 7261 6765 5f70 6174 685f  ().average_path_
-0001a4b0: 6c65 6e67 7468 2829 290a 2020 2020 2020  length()).      
-0001a4c0: 2020 4361 6c63 756c 6174 696e 6720 6176    Calculating av
-0001a4d0: 6572 6167 6520 2877 6569 6768 7465 6429  erage (weighted)
-0001a4e0: 2073 686f 7274 6573 7420 7061 7468 206c   shortest path l
-0001a4f0: 656e 6774 682e 2e2e 0a20 2020 2020 2020  ength....       
-0001a500: 2031 2e37 3631 390a 0a20 2020 2020 2020   1.7619..       
-0001a510: 203a 7274 7970 653a 2066 6c6f 6174 0a20   :rtype: float. 
-0001a520: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0001a530: 2020 2077 203d 2073 656c 662e 6e6f 6465     w = self.node
-0001a540: 5f77 6569 6768 7473 0a20 2020 2020 2020  _weights.       
-0001a550: 2023 2073 6574 2064 6961 676f 6e61 6c20   # set diagonal 
-0001a560: 746f 2031 2028 6e6f 6465 7320 6765 7420  to 1 (nodes get 
-0001a570: 756e 6974 2064 6973 7461 6e63 6520 746f  unit distance to
-0001a580: 2074 6865 6d73 656c 7665 7329 0a20 2020   themselves).   
-0001a590: 2020 2020 206e 7369 5f64 6973 7461 6e63       nsi_distanc
-0001a5a0: 6573 203d 2073 656c 662e 7061 7468 5f6c  es = self.path_l
-0001a5b0: 656e 6774 6873 2829 202b 206e 702e 6964  engths() + np.id
-0001a5c0: 656e 7469 7479 2873 656c 662e 4e29 0a20  entity(self.N). 
-0001a5d0: 2020 2020 2020 2077 6569 6768 745f 7072         weight_pr
-0001a5e0: 6f64 7563 7473 203d 206e 702e 6f75 7465  oducts = np.oute
-0001a5f0: 7228 772c 2077 290a 0a20 2020 2020 2020  r(w, w)..       
-0001a600: 2023 2020 5365 7420 696e 6669 6e69 7465   #  Set infinite
-0001a610: 2065 6e74 7269 6573 2063 6f72 7265 7370   entries corresp
-0001a620: 6f6e 6469 6e67 2074 6f20 756e 636f 6e6e  onding to unconn
-0001a630: 6563 7465 6420 7061 6972 7320 746f 207a  ected pairs to z
-0001a640: 6572 6f0a 2020 2020 2020 2020 756e 636f  ero.        unco
-0001a650: 6e6e 6563 7465 645f 7061 6972 7320 3d20  nnected_pairs = 
-0001a660: 6e70 2e69 7369 6e66 286e 7369 5f64 6973  np.isinf(nsi_dis
-0001a670: 7461 6e63 6573 290a 2020 2020 2020 2020  tances).        
-0001a680: 6e73 695f 6469 7374 616e 6365 735b 756e  nsi_distances[un
-0001a690: 636f 6e6e 6563 7465 645f 7061 6972 735d  connected_pairs]
-0001a6a0: 203d 2030 0a20 2020 2020 2020 2077 6569   = 0.        wei
-0001a6b0: 6768 745f 7072 6f64 7563 7473 5b75 6e63  ght_products[unc
-0001a6c0: 6f6e 6e65 6374 6564 5f70 6169 7273 5d20  onnected_pairs] 
-0001a6d0: 3d20 300a 0a20 2020 2020 2020 2023 206e  = 0..        # n
-0001a6e0: 7369 5f64 6973 7461 6e63 6573 2069 7320  si_distances is 
-0001a6f0: 6e6f 7420 7370 6172 7365 2c20 736f 2077  not sparse, so w
-0001a700: 6520 7573 6520 6d61 7472 6978 2070 726f  e use matrix pro
-0001a710: 6475 6374 0a20 2020 2020 2020 2072 6574  duct.        ret
-0001a720: 7572 6e20 772e 646f 7428 6e73 695f 6469  urn w.dot(nsi_di
-0001a730: 7374 616e 6365 732e 646f 7428 7729 2920  stances.dot(w)) 
-0001a740: 2f20 7765 6967 6874 5f70 726f 6475 6374  / weight_product
-0001a750: 732e 7375 6d28 290a 0a20 2020 2064 6566  s.sum()..    def
-0001a760: 2064 6961 6d65 7465 7228 7365 6c66 2c20   diameter(self, 
-0001a770: 6469 7265 6374 6564 3d54 7275 652c 206f  directed=True, o
-0001a780: 6e6c 795f 636f 6e6e 6563 7465 643d 5472  nly_connected=Tr
-0001a790: 7565 293a 0a20 2020 2020 2020 2022 2222  ue):.        """
-0001a7a0: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
-0001a7b0: 7468 6520 6469 616d 6574 6572 2028 6c61  the diameter (la
-0001a7c0: 7267 6573 7420 7368 6f72 7465 7374 2070  rgest shortest p
-0001a7d0: 6174 6820 6c65 6e67 7468 2062 6574 7765  ath length betwe
-0001a7e0: 656e 2061 6e79 206e 6f64 6573 292e 0a0a  en any nodes)...
-0001a7f0: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
-0001a800: 653a 2a2a 0a0a 2020 2020 2020 2020 3e3e  e:**..        >>
-0001a810: 3e20 7072 696e 7428 4e65 7477 6f72 6b2e  > print(Network.
-0001a820: 536d 616c 6c54 6573 744e 6574 776f 726b  SmallTestNetwork
-0001a830: 2829 2e64 6961 6d65 7465 7228 2929 0a20  ().diameter()). 
-0001a840: 2020 2020 2020 2033 0a0a 2020 2020 2020         3..      
-0001a850: 2020 3a61 7267 2062 6f6f 6c20 6469 7265    :arg bool dire
-0001a860: 6374 6564 3a20 496e 6469 6361 7465 7320  cted: Indicates 
-0001a870: 7768 6574 6865 7220 746f 2072 6573 7065  whether to respe
-0001a880: 6374 206c 696e 6b20 6469 7265 6374 696f  ct link directio
-0001a890: 6e73 2069 6620 7468 650a 2020 2020 2020  ns if the.      
-0001a8a0: 2020 2020 2020 6e65 7477 6f72 6b20 6973        network is
-0001a8b0: 2064 6972 6563 7465 642e 2028 4465 6661   directed. (Defa
-0001a8c0: 756c 743a 2054 7275 6529 0a20 2020 2020  ult: True).     
-0001a8d0: 2020 203a 6172 6720 626f 6f6c 206f 6e6c     :arg bool onl
-0001a8e0: 795f 636f 6e6e 6563 7465 643a 2049 6e64  y_connected: Ind
-0001a8f0: 6963 6174 6573 2077 6865 7468 6572 2074  icates whether t
-0001a900: 6f20 7573 6520 6f6e 6c79 2070 6169 7273  o use only pairs
-0001a910: 206f 6620 6e6f 6465 730a 2020 2020 2020   of nodes.      
-0001a920: 2020 2020 2020 7769 7468 2061 2063 6f6e        with a con
-0001a930: 6e65 6374 696e 6720 7061 7468 2e20 4966  necting path. If
-0001a940: 2046 616c 7365 2061 6e64 2074 6865 206e   False and the n
-0001a950: 6574 776f 726b 2069 7320 756e 636f 6e6e  etwork is unconn
-0001a960: 6563 7465 642c 0a20 2020 2020 2020 2020  ected,.         
-0001a970: 2020 2074 6865 206e 756d 6265 7220 6f66     the number of
-0001a980: 2061 6c6c 206e 6f64 6573 2069 7320 7265   all nodes is re
-0001a990: 7475 726e 6564 2e20 2028 4465 6661 756c  turned.  (Defaul
-0001a9a0: 743a 2054 7275 6529 0a20 2020 2020 2020  t: True).       
-0001a9b0: 203a 7274 7970 653a 2069 6e74 203e 3d20   :rtype: int >= 
-0001a9c0: 300a 2020 2020 2020 2020 2222 220a 2020  0.        """.  
-0001a9d0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-0001a9e0: 662e 6772 6170 682e 6469 616d 6574 6572  f.graph.diameter
-0001a9f0: 2864 6972 6563 7465 643d 6469 7265 6374  (directed=direct
-0001aa00: 6564 2c20 756e 636f 6e6e 3d6f 6e6c 795f  ed, unconn=only_
-0001aa10: 636f 6e6e 6563 7465 6429 0a0a 2020 2020  connected)..    
-0001aa20: 230a 2020 2020 2320 204c 696e 6b20 7661  #.    #  Link va
-0001aa30: 6c75 6564 206d 6561 7375 7265 730a 2020  lued measures.  
-0001aa40: 2020 230a 0a20 2020 2040 6361 6368 6564    #..    @cached
-0001aa50: 5f63 6f6e 7374 2827 6261 7365 272c 2027  _const('base', '
-0001aa60: 6d61 7463 6869 6e67 2069 6478 272c 2027  matching idx', '
-0001aa70: 6d61 7463 6869 6e67 2069 6e64 6578 206d  matching index m
-0001aa80: 6174 7269 7827 290a 2020 2020 6465 6620  atrix').    def 
-0001aa90: 6d61 7463 6869 6e67 5f69 6e64 6578 2873  matching_index(s
-0001aaa0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-0001aab0: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-0001aac0: 6368 2070 6169 7220 6f66 206e 6f64 6573  ch pair of nodes
-0001aad0: 2c20 7265 7475 726e 2074 6865 6972 206d  , return their m
-0001aae0: 6174 6368 696e 6720 696e 6465 782e 0a0a  atching index...
-0001aaf0: 2020 2020 2020 2020 5468 6973 2069 7320          This is 
-0001ab00: 7468 6520 7261 7469 6f20 6f66 2074 6865  the ratio of the
-0001ab10: 206e 756d 6265 7220 6f66 2063 6f6d 6d6f   number of commo
-0001ab20: 6e20 6e65 6967 6862 6f72 7320 616e 6420  n neighbors and 
-0001ab30: 7468 6520 6e75 6d62 6572 206f 660a 2020  the number of.  
-0001ab40: 2020 2020 2020 6e6f 6465 7320 6c69 6e6b        nodes link
-0001ab50: 6564 2074 6f20 6174 206c 6561 7374 206f  ed to at least o
-0001ab60: 6e65 206f 6620 7468 6520 7477 6f20 6e6f  ne of the two no
-0001ab70: 6465 732e 0a0a 2020 2020 2020 2020 2a2a  des...        **
-0001ab80: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-0001ab90: 2020 2020 3e3e 3e20 7072 696e 7428 7228      >>> print(r(
-0001aba0: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
-0001abb0: 744e 6574 776f 726b 2829 2e6d 6174 6368  tNetwork().match
-0001abc0: 696e 675f 696e 6465 7828 2929 290a 2020  ing_index())).  
-0001abd0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-0001abe0: 6720 6d61 7463 6869 6e67 2069 6e64 6578  g matching index
-0001abf0: 206d 6174 7269 782e 2e2e 0a20 2020 2020   matrix....     
-0001ac00: 2020 205b 5b20 312e 2020 2020 302e 3520     [[ 1.    0.5 
-0001ac10: 2020 302e 3235 2020 2020 302e 2020 2020    0.25    0.    
-0001ac20: 2020 302e 2020 2020 2020 302e 2020 2020    0.      0.    
-0001ac30: 5d0a 2020 2020 2020 2020 205b 2030 2e35  ].         [ 0.5
-0001ac40: 2020 2031 2e20 2020 2030 2e32 3520 2020     1.    0.25   
-0001ac50: 2030 2e20 2020 2020 2030 2e32 2020 2020   0.      0.2    
-0001ac60: 2030 2e20 2020 205d 0a20 2020 2020 2020   0.    ].       
-0001ac70: 2020 5b20 302e 3235 2020 302e 3235 2020    [ 0.25  0.25  
-0001ac80: 312e 2020 2020 2020 302e 3333 3333 2020  1.      0.3333  
-0001ac90: 302e 3235 2020 2020 302e 2020 2020 5d0a  0.25    0.    ].
-0001aca0: 2020 2020 2020 2020 205b 2030 2e20 2020           [ 0.   
-0001acb0: 2030 2e20 2020 2030 2e33 3333 3320 2031   0.    0.3333  1
-0001acc0: 2e20 2020 2020 2030 2e36 3636 3720 2030  .      0.6667  0
-0001acd0: 2e35 2020 205d 0a20 2020 2020 2020 2020  .5   ].         
-0001ace0: 5b20 302e 2020 2020 302e 3220 2020 302e  [ 0.    0.2   0.
-0001acf0: 3235 2020 2020 302e 3636 3637 2020 312e  25    0.6667  1.
-0001ad00: 2020 2020 2020 302e 3333 3333 5d0a 2020        0.3333].  
-0001ad10: 2020 2020 2020 205b 2030 2e20 2020 2030         [ 0.    0
-0001ad20: 2e20 2020 2030 2e20 2020 2020 2030 2e35  .    0.      0.5
-0001ad30: 2020 2020 2030 2e33 3333 3320 2031 2e20       0.3333  1. 
-0001ad40: 2020 205d 5d0a 0a20 2020 2020 2020 203a     ]]..        :
-0001ad50: 7274 7970 653a 2061 7272 6179 285b 5b30  rtype: array([[0
-0001ad60: 3c3d 666c 6f61 743c 3d31 2c30 3c3d 666c  <=float<=1,0<=fl
-0001ad70: 6f61 743c 3d31 5d5d 290a 2020 2020 2020  oat<=1]]).      
-0001ad80: 2020 2222 220a 2020 2020 2020 2020 636f    """.        co
-0001ad90: 6d6d 6f6e 7320 3d20 2873 656c 662e 7370  mmons = (self.sp
-0001ada0: 5f41 202a 2073 656c 662e 7370 5f41 292e  _A * self.sp_A).
-0001adb0: 6173 7479 7065 286e 702e 666c 6f61 7429  astype(np.float)
-0001adc0: 2e41 0a20 2020 2020 2020 206b 6b20 3d20  .A.        kk = 
-0001add0: 6e70 2e72 6570 6561 7428 5b73 656c 662e  np.repeat([self.
-0001ade0: 6465 6772 6565 2829 5d2c 2073 656c 662e  degree()], self.
-0001adf0: 4e2c 2061 7869 733d 3029 0a20 2020 2020  N, axis=0).     
-0001ae00: 2020 2072 6574 7572 6e20 636f 6d6d 6f6e     return common
-0001ae10: 7320 2f20 286b 6b20 2b20 6b6b 2e54 202d  s / (kk + kk.T -
-0001ae20: 2063 6f6d 6d6f 6e73 290a 0a20 2020 2040   commons)..    @
-0001ae30: 6361 6368 6564 5f63 6f6e 7374 2827 6261  cached_const('ba
-0001ae40: 7365 272c 2027 6c69 6e6b 2062 7477 272c  se', 'link btw',
-0001ae50: 2027 6c69 6e6b 2062 6574 7765 656e 6e65   'link betweenne
-0001ae60: 7373 2729 0a20 2020 2064 6566 206c 696e  ss').    def lin
-0001ae70: 6b5f 6265 7477 6565 6e6e 6573 7328 7365  k_betweenness(se
-0001ae80: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0001ae90: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
-0001aea0: 6820 6c69 6e6b 2c20 7265 7475 726e 2069  h link, return i
-0001aeb0: 7473 2062 6574 7765 656e 6e65 7373 2e0a  ts betweenness..
-0001aec0: 0a20 2020 2020 2020 2054 6869 7320 6d65  .        This me
-0001aed0: 6173 7572 6573 206f 6e20 686f 7720 6c69  asures on how li
-0001aee0: 6b65 6c79 2074 6865 206c 696e 6b20 6973  kely the link is
-0001aef0: 206f 6e20 6120 7261 6e64 6f6d 6c79 2063   on a randomly c
-0001af00: 686f 7365 6e20 7368 6f72 7465 7374 0a20  hosen shortest. 
-0001af10: 2020 2020 2020 2070 6174 6820 696e 2074         path in t
-0001af20: 6865 206e 6574 776f 726b 2e0a 0a20 2020  he network...   
-0001af30: 2020 2020 2028 446f 6573 206e 6f74 2072       (Does not r
-0001af40: 6573 7065 6374 2064 6972 6563 7469 6f6e  espect direction
-0001af50: 616c 6974 7920 6f66 206c 696e 6b73 2e29  ality of links.)
-0001af60: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
-0001af70: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
-0001af80: 3e3e 3e20 7072 696e 7428 4e65 7477 6f72  >>> print(Networ
-0001af90: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
-0001afa0: 726b 2829 2e6c 696e 6b5f 6265 7477 6565  rk().link_betwee
-0001afb0: 6e6e 6573 7328 2929 0a20 2020 2020 2020  nness()).       
-0001afc0: 2043 616c 6375 6c61 7469 6e67 206c 696e   Calculating lin
-0001afd0: 6b20 6265 7477 6565 6e6e 6573 732e 2e2e  k betweenness...
-0001afe0: 0a20 2020 2020 2020 205b 5b20 302e 2020  .        [[ 0.  
-0001aff0: 2030 2e20 2020 302e 2020 2033 2e35 2020   0.   0.   3.5  
-0001b000: 352e 3520 2035 2e20 5d20 5b20 302e 2020  5.5  5. ] [ 0.  
-0001b010: 2030 2e20 2020 322e 2020 2033 2e35 2020   0.   2.   3.5  
-0001b020: 322e 3520 2030 2e20 5d0a 2020 2020 2020  2.5  0. ].      
-0001b030: 2020 205b 2030 2e20 2020 322e 2020 2030     [ 0.   2.   0
-0001b040: 2e20 2020 302e 2020 2033 2e20 2020 302e  .   0.   3.   0.
-0001b050: 205d 205b 2033 2e35 2020 332e 3520 2030   ] [ 3.5  3.5  0
-0001b060: 2e20 2020 302e 2020 2030 2e20 2020 302e  .   0.   0.   0.
-0001b070: 205d 0a20 2020 2020 2020 2020 5b20 352e   ].         [ 5.
-0001b080: 3520 2032 2e35 2020 332e 2020 2030 2e20  5  2.5  3.   0. 
-0001b090: 2020 302e 2020 2030 2e20 5d20 5b20 352e    0.   0. ] [ 5.
-0001b0a0: 2020 2030 2e20 2020 302e 2020 2030 2e20     0.   0.   0. 
-0001b0b0: 2020 302e 2020 2030 2e20 5d5d 0a0a 2020    0.   0. ]]..  
-0001b0c0: 2020 2020 2020 3a72 7479 7065 3a20 2073        :rtype:  s
-0001b0d0: 7175 6172 6520 6e75 6d70 7920 6172 7261  quare numpy arra
-0001b0e0: 7920 5b6e 6f64 652c 6e6f 6465 5d20 6f66  y [node,node] of
-0001b0f0: 2066 6c6f 6174 7320 6265 7477 6565 6e20   floats between 
-0001b100: 3020 616e 6420 310a 2020 2020 2020 2020  0 and 1.        
-0001b110: 3a72 6574 7572 6e3a 2045 6e74 7279 205b  :return: Entry [
-0001b120: 692c 6a5d 2069 7320 7468 6520 6265 7477  i,j] is the betw
-0001b130: 6565 6e6e 6573 7320 6f66 2074 6865 206c  eenness of the l
-0001b140: 696e 6b20 6265 7477 6565 6e20 6920 616e  ink between i an
-0001b150: 6420 6a2c 0a20 2020 2020 2020 2020 2020  d j,.           
-0001b160: 2020 2020 2020 6f72 2030 2069 6620 6920        or 0 if i 
-0001b170: 6973 206e 6f74 206c 696e 6b65 6420 746f  is not linked to
-0001b180: 206a 2e0a 2020 2020 2020 2020 2222 220a   j..        """.
-0001b190: 2020 2020 2020 2020 2320 2043 616c 6375          #  Calcu
-0001b1a0: 6c61 7465 206c 696e 6b20 6265 7477 6565  late link betwee
-0001b1b0: 6e6e 6573 730a 2020 2020 2020 2020 6c69  nness.        li
-0001b1c0: 6e6b 5f62 6574 7765 656e 6e65 7373 203d  nk_betweenness =
-0001b1d0: 2073 656c 662e 6772 6170 682e 6564 6765   self.graph.edge
-0001b1e0: 5f62 6574 7765 656e 6e65 7373 2829 0a0a  _betweenness()..
-0001b1f0: 2020 2020 2020 2020 2320 2049 6e69 7469          #  Initi
-0001b200: 616c 697a 650a 2020 2020 2020 2020 7265  alize.        re
-0001b210: 7375 6c74 2c20 6563 6f75 6e74 203d 206e  sult, ecount = n
-0001b220: 702e 7a65 726f 7328 2873 656c 662e 4e2c  p.zeros((self.N,
-0001b230: 2073 656c 662e 4e29 292c 2030 0a0a 2020   self.N)), 0..  
-0001b240: 2020 2020 2020 2320 2047 6574 2067 7261        #  Get gra
-0001b250: 7068 2061 646a 6163 656e 6379 206c 6973  ph adjacency lis
-0001b260: 740a 2020 2020 2020 2020 415f 6c69 7374  t.        A_list
-0001b270: 203d 2073 656c 662e 6772 6170 682e 6765   = self.graph.ge
-0001b280: 745f 6164 6a6c 6973 7428 290a 0a20 2020  t_adjlist()..   
-0001b290: 2020 2020 2023 2020 5772 6974 6520 6c69       #  Write li
-0001b2a0: 6e6b 2062 6574 7765 656e 6e65 7373 2076  nk betweenness v
-0001b2b0: 616c 7565 7320 746f 206d 6174 7269 780a  alues to matrix.
-0001b2c0: 2020 2020 2020 2020 666f 7220 692c 2041          for i, A
-0001b2d0: 6920 696e 2065 6e75 6d65 7261 7465 2841  i in enumerate(A
-0001b2e0: 5f6c 6973 7429 3a0a 2020 2020 2020 2020  _list):.        
-0001b2f0: 2020 2020 666f 7220 6a20 696e 2041 693a      for j in Ai:
-0001b300: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001b310: 2023 2020 4f6e 6c79 2076 6973 6974 206c   #  Only visit l
-0001b320: 696e 6b73 206f 6e63 650a 2020 2020 2020  inks once.      
-0001b330: 2020 2020 2020 2020 2020 6966 2069 203c            if i <
-0001b340: 206a 3a0a 2020 2020 2020 2020 2020 2020   j:.            
-0001b350: 2020 2020 2020 2020 7265 7375 6c74 5b69          result[i
-0001b360: 2c20 6a5d 203d 2072 6573 756c 745b 6a2c  , j] = result[j,
-0001b370: 2069 5d20 3d20 6c69 6e6b 5f62 6574 7765   i] = link_betwe
-0001b380: 656e 6e65 7373 5b65 636f 756e 745d 0a20  enness[ecount]. 
-0001b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3a0: 2020 2065 636f 756e 7420 2b3d 2031 0a20     ecount += 1. 
-0001b3b0: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-0001b3c0: 7375 6c74 0a0a 2020 2020 6465 6620 6564  sult..    def ed
-0001b3d0: 6765 5f62 6574 7765 656e 6e65 7373 2873  ge_betweenness(s
-0001b3e0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-0001b3f0: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-0001b400: 6368 206c 696e 6b2c 2072 6574 7572 6e20  ch link, return 
-0001b410: 6974 7320 6265 7477 6565 6e6e 6573 732e  its betweenness.
-0001b420: 0a0a 2020 2020 2020 2020 416c 6961 7320  ..        Alias 
-0001b430: 746f 203a 6d65 7468 3a60 6c69 6e6b 5f62  to :meth:`link_b
-0001b440: 6574 7765 656e 6e65 7373 602e 2054 6869  etweenness`. Thi
-0001b450: 7320 6d65 6173 7572 6573 206f 6e20 686f  s measures on ho
-0001b460: 7720 6c69 6b65 6c79 2074 6865 0a20 2020  w likely the.   
-0001b470: 2020 2020 206c 696e 6b20 6973 206f 6e20       link is on 
-0001b480: 6120 7261 6e64 6f6d 6c79 2063 686f 7365  a randomly chose
-0001b490: 6e20 7368 6f72 7465 7374 2070 6174 6820  n shortest path 
-0001b4a0: 696e 2074 6865 206e 6574 776f 726b 2e0a  in the network..
-0001b4b0: 0a20 2020 2020 2020 2028 446f 6573 206e  .        (Does n
-0001b4c0: 6f74 2072 6573 7065 6374 2064 6972 6563  ot respect direc
-0001b4d0: 7469 6f6e 616c 6974 7920 6f66 206c 696e  tionality of lin
-0001b4e0: 6b73 2e29 0a0a 2020 2020 2020 2020 2a2a  ks.)..        **
-0001b4f0: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
-0001b500: 2020 2020 3e3e 3e20 7072 696e 7428 4e65      >>> print(Ne
-0001b510: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-0001b520: 6574 776f 726b 2829 2e65 6467 655f 6265  etwork().edge_be
-0001b530: 7477 6565 6e6e 6573 7328 2929 0a20 2020  tweenness()).   
-0001b540: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-0001b550: 206c 696e 6b20 6265 7477 6565 6e6e 6573   link betweennes
-0001b560: 732e 2e2e 0a20 2020 2020 2020 205b 5b20  s....        [[ 
-0001b570: 302e 2020 2030 2e20 2020 302e 2020 2033  0.   0.   0.   3
-0001b580: 2e35 2020 352e 3520 2035 2e20 5d20 5b20  .5  5.5  5. ] [ 
-0001b590: 302e 2020 2030 2e20 2020 322e 2020 2033  0.   0.   2.   3
-0001b5a0: 2e35 2020 322e 3520 2030 2e20 5d0a 2020  .5  2.5  0. ].  
-0001b5b0: 2020 2020 2020 205b 2030 2e20 2020 322e         [ 0.   2.
-0001b5c0: 2020 2030 2e20 2020 302e 2020 2033 2e20     0.   0.   3. 
-0001b5d0: 2020 302e 205d 205b 2033 2e35 2020 332e    0. ] [ 3.5  3.
-0001b5e0: 3520 2030 2e20 2020 302e 2020 2030 2e20  5  0.   0.   0. 
-0001b5f0: 2020 302e 205d 0a20 2020 2020 2020 2020    0. ].         
-0001b600: 5b20 352e 3520 2032 2e35 2020 332e 2020  [ 5.5  2.5  3.  
-0001b610: 2030 2e20 2020 302e 2020 2030 2e20 5d20   0.   0.   0. ] 
-0001b620: 5b20 352e 2020 2030 2e20 2020 302e 2020  [ 5.   0.   0.  
-0001b630: 2030 2e20 2020 302e 2020 2030 2e20 5d5d   0.   0.   0. ]]
-0001b640: 0a0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
-0001b650: 3a20 2073 7175 6172 6520 6e75 6d70 7920  :  square numpy 
-0001b660: 6172 7261 7920 5b6e 6f64 652c 6e6f 6465  array [node,node
-0001b670: 5d20 6f66 2066 6c6f 6174 7320 6265 7477  ] of floats betw
-0001b680: 6565 6e20 3020 616e 6420 310a 2020 2020  een 0 and 1.    
-0001b690: 2020 2020 3a72 6574 7572 6e3a 2045 6e74      :return: Ent
-0001b6a0: 7279 205b 692c 6a5d 2069 7320 7468 6520  ry [i,j] is the 
-0001b6b0: 6265 7477 6565 6e6e 6573 7320 6f66 2074  betweenness of t
-0001b6c0: 6865 206c 696e 6b20 6265 7477 6565 6e20  he link between 
-0001b6d0: 6920 616e 6420 6a2c 0a20 2020 2020 2020  i and j,.       
-0001b6e0: 2020 2020 2020 2020 2020 6f72 2030 2069            or 0 i
-0001b6f0: 6620 6920 6973 206e 6f74 206c 696e 6b65  f i is not linke
-0001b700: 6420 746f 206a 2e0a 2020 2020 2020 2020  d to j..        
-0001b710: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-0001b720: 726e 2073 656c 662e 6c69 6e6b 5f62 6574  rn self.link_bet
-0001b730: 7765 656e 6e65 7373 2829 0a0a 2020 2020  weenness()..    
-0001b740: 230a 2020 2020 2320 204e 6f64 6520 7661  #.    #  Node va
-0001b750: 6c75 6564 2063 656e 7472 616c 6974 7920  lued centrality 
-0001b760: 6d65 6173 7572 6573 0a20 2020 2023 0a0a  measures.    #..
-0001b770: 2020 2020 4063 6163 6865 645f 636f 6e73      @cached_cons
-0001b780: 7428 2762 6173 6527 2c20 2762 7477 272c  t('base', 'btw',
-0001b790: 2027 6e6f 6465 2062 6574 7765 656e 6e65   'node betweenne
-0001b7a0: 7373 2729 0a20 2020 2064 6566 2062 6574  ss').    def bet
-0001b7b0: 7765 656e 6e65 7373 2873 656c 662c 206e  weenness(self, n
-0001b7c0: 6f5f 6269 675f 696e 743d 5472 7565 293a  o_big_int=True):
-0001b7d0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0001b7e0: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
-0001b7f0: 6465 2c20 7265 7475 726e 2069 7473 2062  de, return its b
-0001b800: 6574 7765 656e 6e65 7373 2e0a 0a20 2020  etweenness...   
-0001b810: 2020 2020 2054 6869 7320 6d65 6173 7572       This measur
-0001b820: 6573 2072 6f75 6768 6c79 2068 6f77 206d  es roughly how m
-0001b830: 616e 7920 7368 6f72 7465 7374 2070 6174  any shortest pat
-0001b840: 6873 2070 6173 7320 7468 726f 7567 6820  hs pass through 
-0001b850: 7468 6520 6e6f 6465 2e0a 0a20 2020 2020  the node...     
-0001b860: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
-0001b870: 0a20 2020 2020 2020 203e 3e3e 204e 6574  .        >>> Net
-0001b880: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
-0001b890: 7477 6f72 6b28 292e 6265 7477 6565 6e6e  twork().betweenn
-0001b8a0: 6573 7328 290a 2020 2020 2020 2020 4361  ess().        Ca
-0001b8b0: 6c63 756c 6174 696e 6720 6e6f 6465 2062  lculating node b
-0001b8c0: 6574 7765 656e 6e65 7373 2e2e 2e0a 2020  etweenness....  
-0001b8d0: 2020 2020 2020 6172 7261 7928 5b20 342e        array([ 4.
-0001b8e0: 352c 2020 312e 352c 2020 302e 202c 2020  5,  1.5,  0. ,  
-0001b8f0: 312e 202c 2020 332e 202c 2020 302e 205d  1. ,  3. ,  0. ]
-0001b900: 290a 0a20 2020 2020 2020 203a 6172 6720  )..        :arg 
-0001b910: 626f 6f6c 206e 6f5f 6269 675f 696e 743a  bool no_big_int:
-0001b920: 2054 6f67 676c 6573 2075 7365 206f 6620   Toggles use of 
-0001b930: 6269 6720 696e 7465 6765 7220 6361 6c63  big integer calc
-0001b940: 756c 6174 696f 6e20 2873 6c6f 7720 6966  ulation (slow if
-0001b950: 0a20 2020 2020 2020 2020 2020 2046 616c  .            Fal
-0001b960: 7365 292e 0a20 2020 2020 2020 203a 7274  se)..        :rt
-0001b970: 7970 653a 2031 6420 6e75 6d70 7920 6172  ype: 1d numpy ar
-0001b980: 7261 7920 5b6e 6f64 655d 206f 6620 666c  ray [node] of fl
-0001b990: 6f61 7473 203e 3d20 300a 2020 2020 2020  oats >= 0.      
-0001b9a0: 2020 2222 220a 2020 2020 2020 2020 2320    """.        # 
-0001b9b0: 2052 6574 7572 6e20 7468 6520 6162 736f   Return the abso
-0001b9c0: 6c75 7465 2076 616c 7565 206f 6620 6e6f  lute value of no
-0001b9d0: 726d 6564 2074 6263 2c20 7369 6e63 6520  rmed tbc, since 
-0001b9e0: 6120 6275 6720 736f 6d65 7469 6d65 730a  a bug sometimes.
-0001b9f0: 2020 2020 2020 2020 2320 2072 6573 756c          #  resul
-0001ba00: 7473 2069 6e20 6e65 6761 7469 7665 2073  ts in negative s
-0001ba10: 6967 6e73 0a20 2020 2020 2020 2023 2020  igns.        #  
-0001ba20: 5468 6520 6d65 6173 7572 6520 6973 206e  The measure is n
-0001ba30: 6f72 6d65 6420 6279 2074 6865 206d 6178  ormed by the max
-0001ba40: 696d 756d 2062 6574 7765 656e 6e65 7373  imum betweenness
-0001ba50: 2063 656e 7472 616c 6974 7920 6163 6869   centrality achi
-0001ba60: 6576 6564 0a20 2020 2020 2020 2023 2020  eved.        #  
-0001ba70: 6f6e 6c79 2062 7920 7468 6520 7374 6172  only by the star
-0001ba80: 2028 4672 6565 6d61 6e20 3139 3738 293a   (Freeman 1978):
-0001ba90: 2028 6e2a 2a32 2d33 2a6e 2b32 292f 320a   (n**2-3*n+2)/2.
-0001baa0: 2020 2020 2020 2020 2320 2054 6869 7320          #  This 
-0001bab0: 7265 7374 7269 6374 7320 5442 4320 746f  restricts TBC to
-0001bac0: 2030 203c 3d20 5442 4320 3c3d 2031 0a20   0 <= TBC <= 1. 
-0001bad0: 2020 2020 2020 2023 206d 6178 5442 4320         # maxTBC 
-0001bae0: 3d20 2028 2073 656c 662e 4e2a 2a32 202d  =  ( self.N**2 -
-0001baf0: 2033 202a 2073 656c 662e 4e20 2b20 3220   3 * self.N + 2 
-0001bb00: 2920 2f20 320a 0a20 2020 2020 2020 2072  ) / 2..        r
-0001bb10: 6574 7572 6e20 6e70 2e61 6273 286e 702e  eturn np.abs(np.
-0001bb20: 6172 7261 7928 7365 6c66 2e67 7261 7068  array(self.graph
-0001bb30: 2e62 6574 7765 656e 6e65 7373 286e 6f62  .betweenness(nob
-0001bb40: 6967 696e 743d 6e6f 5f62 6967 5f69 6e74  igint=no_big_int
-0001bb50: 2929 290a 0a20 2020 2023 2040 6361 6368  )))..    # @cach
-0001bb60: 6564 5f63 6f6e 7374 2827 6261 7365 272c  ed_const('base',
-0001bb70: 2027 696e 7465 7220 6274 7727 2c20 2769   'inter btw', 'i
-0001bb80: 6e74 6572 7265 6769 6f6e 616c 2062 6574  nterregional bet
-0001bb90: 7765 656e 6e65 7373 2729 0a20 2020 2064  weenness').    d
-0001bba0: 6566 2069 6e74 6572 7265 6769 6f6e 616c  ef interregional
-0001bbb0: 5f62 6574 7765 656e 6e65 7373 2873 656c  _betweenness(sel
-0001bbc0: 662c 2073 6f75 7263 6573 3d4e 6f6e 652c  f, sources=None,
-0001bbd0: 2074 6172 6765 7473 3d4e 6f6e 6529 3a0a   targets=None):.
-0001bbe0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0001bbf0: 2020 2020 466f 7220 6561 6368 206e 6f64      For each nod
-0001bc00: 652c 2072 6574 7572 6e20 6974 7320 696e  e, return its in
-0001bc10: 7465 7272 6567 696f 6e61 6c20 6265 7477  terregional betw
-0001bc20: 6565 6e6e 6573 7320 666f 7220 6769 7665  eenness for give
-0001bc30: 6e20 7365 7473 0a20 2020 2020 2020 206f  n sets.        o
-0001bc40: 6620 736f 7572 6365 2061 6e64 2074 6172  f source and tar
-0001bc50: 6765 7420 6e6f 6465 732e 0a0a 2020 2020  get nodes...    
-0001bc60: 2020 2020 5468 6973 206d 6561 7375 7265      This measure
-0001bc70: 7320 726f 7567 686c 7920 686f 7720 6d61  s roughly how ma
-0001bc80: 6e79 2073 686f 7274 6573 7420 7061 7468  ny shortest path
-0001bc90: 7320 6672 6f6d 206f 6e65 206f 6620 7468  s from one of th
-0001bca0: 6520 736f 7572 6365 730a 2020 2020 2020  e sources.      
-0001bcb0: 2020 746f 206f 6e65 206f 6620 7468 6520    to one of the 
-0001bcc0: 7461 7267 6574 7320 7061 7373 2074 6872  targets pass thr
-0001bcd0: 6f75 6768 2074 6865 206e 6f64 652e 0a0a  ough the node...
-0001bce0: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
-0001bcf0: 6573 3a2a 2a0a 0a20 2020 2020 2020 203e  es:**..        >
-0001bd00: 3e3e 204e 6574 776f 726b 2e53 6d61 6c6c  >> Network.Small
-0001bd10: 5465 7374 4e65 7477 6f72 6b28 292e 696e  TestNetwork().in
-0001bd20: 7465 7272 6567 696f 6e61 6c5f 6265 7477  terregional_betw
-0001bd30: 6565 6e6e 6573 7328 0a20 2020 2020 2020  eenness(.       
-0001bd40: 202e 2e2e 2020 2020 2073 6f75 7263 6573   ...     sources
-0001bd50: 3d5b 325d 2c20 7461 7267 6574 733d 5b33  =[2], targets=[3
-0001bd60: 2c35 5d29 0a20 2020 2020 2020 2043 616c  ,5]).        Cal
-0001bd70: 6375 6c61 7469 6e67 2069 6e74 6572 7265  culating interre
-0001bd80: 6769 6f6e 616c 2062 6574 7765 656e 6e65  gional betweenne
-0001bd90: 7373 2e2e 2e0a 2020 2020 2020 2020 6172  ss....        ar
-0001bda0: 7261 7928 5b20 312e 2c20 2031 2e2c 2020  ray([ 1.,  1.,  
-0001bdb0: 302e 2c20 2030 2e2c 2020 312e 2c20 2030  0.,  0.,  1.,  0
-0001bdc0: 2e5d 290a 2020 2020 2020 2020 3e3e 3e20  .]).        >>> 
-0001bdd0: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
-0001bde0: 744e 6574 776f 726b 2829 2e69 6e74 6572  tNetwork().inter
-0001bdf0: 7265 6769 6f6e 616c 5f62 6574 7765 656e  regional_between
-0001be00: 6e65 7373 280a 2020 2020 2020 2020 2e2e  ness(.        ..
-0001be10: 2e20 2020 2020 736f 7572 6365 733d 7261  .     sources=ra
-0001be20: 6e67 6528 302c 3629 2c20 7461 7267 6574  nge(0,6), target
-0001be30: 733d 7261 6e67 6528 302c 3629 290a 2020  s=range(0,6)).  
-0001be40: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-0001be50: 6720 696e 7465 7272 6567 696f 6e61 6c20  g interregional 
-0001be60: 6265 7477 6565 6e6e 6573 732e 2e2e 0a20  betweenness.... 
-0001be70: 2020 2020 2020 2061 7272 6179 285b 2039         array([ 9
-0001be80: 2e2c 2020 332e 2c20 2030 2e2c 2020 322e  .,  3.,  0.,  2.
-0001be90: 2c20 2036 2e2c 2020 302e 5d29 0a0a 2020  ,  6.,  0.])..  
-0001bea0: 2020 2020 2020 6173 2063 6f6d 7061 7265        as compare
-0001beb0: 6420 746f 0a0a 2020 2020 2020 2020 3e3e  d to..        >>
-0001bec0: 3e20 4e65 7477 6f72 6b2e 536d 616c 6c54  > Network.SmallT
-0001bed0: 6573 744e 6574 776f 726b 2829 2e62 6574  estNetwork().bet
-0001bee0: 7765 656e 6e65 7373 2829 0a20 2020 2020  weenness().     
-0001bef0: 2020 2043 616c 6375 6c61 7469 6e67 206e     Calculating n
-0001bf00: 6f64 6520 6265 7477 6565 6e6e 6573 732e  ode betweenness.
-0001bf10: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-0001bf20: 285b 2034 2e35 2c20 2031 2e35 2c20 2030  ([ 4.5,  1.5,  0
-0001bf30: 2e20 2c20 2031 2e20 2c20 2033 2e20 2c20  . ,  1. ,  3. , 
-0001bf40: 2030 2e20 5d29 0a0a 2020 2020 2020 2020   0. ])..        
-0001bf50: 3a74 7970 6520 736f 7572 6365 733a 2031  :type sources: 1
-0001bf60: 6420 6e75 6d70 7920 6172 7261 7920 6f72  d numpy array or
-0001bf70: 206c 6973 7420 6f66 2069 6e74 7320 6672   list of ints fr
-0001bf80: 6f6d 2030 2074 6f20 6e5f 6e6f 6465 732d  om 0 to n_nodes-
-0001bf90: 310a 2020 2020 2020 2020 3a61 7267 2020  1.        :arg  
-0001bfa0: 736f 7572 6365 733a 2053 6574 206f 6620  sources: Set of 
-0001bfb0: 736f 7572 6365 206e 6f64 6520 696e 6469  source node indi
-0001bfc0: 6365 732e 0a0a 2020 2020 2020 2020 3a74  ces...        :t
-0001bfd0: 7970 6520 7461 7267 6574 733a 2031 6420  ype targets: 1d 
-0001bfe0: 6e75 6d70 7920 6172 7261 7920 6f72 206c  numpy array or l
-0001bff0: 6973 7420 6f66 2069 6e74 7320 6672 6f6d  ist of ints from
-0001c000: 2030 2074 6f20 6e5f 6e6f 6465 732d 310a   0 to n_nodes-1.
-0001c010: 2020 2020 2020 2020 3a61 7267 2020 7461          :arg  ta
-0001c020: 7267 6574 733a 2053 6574 206f 6620 7461  rgets: Set of ta
-0001c030: 7267 6574 206e 6f64 6520 696e 6469 6365  rget node indice
-0001c040: 732e 0a0a 2020 2020 2020 2020 3a72 7479  s...        :rty
-0001c050: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
-0001c060: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
-0001c070: 6174 7320 6265 7477 6565 6e20 3020 616e  ats between 0 an
-0001c080: 6420 310a 2020 2020 2020 2020 2222 220a  d 1.        """.
-0001c090: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0001c0a0: 656c 662e 6e73 695f 6265 7477 6565 6e6e  elf.nsi_betweenn
-0001c0b0: 6573 7328 736f 7572 6365 733d 736f 7572  ess(sources=sour
-0001c0c0: 6365 732c 2074 6172 6765 7473 3d74 6172  ces, targets=tar
-0001c0d0: 6765 7473 2c0a 2020 2020 2020 2020 2020  gets,.          
-0001c0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c0f0: 2020 2020 2020 2020 2020 6177 3d30 2c20            aw=0, 
-0001c100: 7369 6c65 6e74 3d31 290a 0a20 2020 2023  silent=1)..    #
-0001c110: 2040 6361 6368 6564 5f63 6f6e 7374 2827   @cached_const('
-0001c120: 6e73 6927 2c20 2769 6e74 6572 2062 7477  nsi', 'inter btw
-0001c130: 272c 2027 6e2e 732e 692e 2069 6e74 6572  ', 'n.s.i. inter
-0001c140: 7265 6769 6f6e 616c 2062 6574 7765 656e  regional between
-0001c150: 6e65 7373 2729 0a20 2020 2064 6566 206e  ness').    def n
-0001c160: 7369 5f69 6e74 6572 7265 6769 6f6e 616c  si_interregional
-0001c170: 5f62 6574 7765 656e 6e65 7373 2873 656c  _betweenness(sel
-0001c180: 662c 2073 6f75 7263 6573 2c20 7461 7267  f, sources, targ
-0001c190: 6574 7329 3a0a 2020 2020 2020 2020 2222  ets):.        ""
-0001c1a0: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-0001c1b0: 6368 206e 6f64 652c 2072 6574 7572 6e20  ch node, return 
-0001c1c0: 6974 7320 6e2e 732e 692e 2069 6e74 6572  its n.s.i. inter
-0001c1d0: 7265 6769 6f6e 616c 2062 6574 7765 656e  regional between
-0001c1e0: 6e65 7373 2066 6f72 2067 6976 656e 0a20  ness for given. 
-0001c1f0: 2020 2020 2020 2073 6574 7320 6f66 2073         sets of s
-0001c200: 6f75 7263 6520 616e 6420 7461 7267 6574  ource and target
-0001c210: 206e 6f64 6573 2e0a 0a20 2020 2020 2020   nodes...       
-0001c220: 2054 6869 7320 6d65 6173 7572 6573 2072   This measures r
-0001c230: 6f75 6768 6c79 2068 6f77 206d 616e 7920  oughly how many 
-0001c240: 7368 6f72 7465 7374 2070 6174 6873 2066  shortest paths f
-0001c250: 726f 6d20 6f6e 6520 6f66 2074 6865 2073  rom one of the s
-0001c260: 6f75 7263 6573 0a20 2020 2020 2020 2074  ources.        t
-0001c270: 6f20 6f6e 6520 6f66 2074 6865 2074 6172  o one of the tar
-0001c280: 6765 7473 2070 6173 7320 7468 726f 7567  gets pass throug
-0001c290: 6820 7468 6520 6e6f 6465 2c20 7461 6b69  h the node, taki
-0001c2a0: 6e67 206e 6f64 6520 7765 6967 6874 7320  ng node weights 
-0001c2b0: 696e 746f 0a20 2020 2020 2020 2061 6363  into.        acc
-0001c2c0: 6f75 6e74 2e0a 0a20 2020 2020 2020 202a  ount...        *
-0001c2d0: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-0001c2e0: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
-0001c2f0: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-0001c300: 6f72 6b28 292e 6e73 695f 696e 7465 7272  ork().nsi_interr
-0001c310: 6567 696f 6e61 6c5f 6265 7477 6565 6e6e  egional_betweenn
-0001c320: 6573 7328 0a20 2020 2020 2020 202e 2e2e  ess(.        ...
-0001c330: 2020 2020 2073 6f75 7263 6573 3d5b 325d       sources=[2]
-0001c340: 2c20 7461 7267 6574 733d 5b33 2c35 5d29  , targets=[3,5])
-0001c350: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-0001c360: 6174 696e 6720 6e2e 732e 692e 2069 6e74  ating n.s.i. int
-0001c370: 6572 7265 6769 6f6e 616c 2062 6574 7765  erregional betwe
-0001c380: 656e 6e65 7373 2e2e 2e0a 2020 2020 2020  enness....      
-0001c390: 2020 6172 7261 7928 5b20 332e 3136 3637    array([ 3.1667
-0001c3a0: 2c20 322e 3334 3731 2c20 302e 202c 2030  , 2.3471, 0. , 0
-0001c3b0: 2e20 2c20 322e 3036 3532 2c20 302e 205d  . , 2.0652, 0. ]
-0001c3c0: 290a 0a20 2020 2020 2020 2061 7320 636f  )..        as co
-0001c3d0: 6d70 6172 6564 2074 6f20 7468 6520 756e  mpared to the un
-0001c3e0: 7765 6967 6874 6564 2076 6572 7369 6f6e  weighted version
-0001c3f0: 3a0a 0a20 2020 2020 2020 203e 3e3e 204e  :..        >>> N
-0001c400: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
-0001c410: 4e65 7477 6f72 6b28 292e 696e 7465 7272  Network().interr
-0001c420: 6567 696f 6e61 6c5f 6265 7477 6565 6e6e  egional_betweenn
-0001c430: 6573 7328 0a20 2020 2020 2020 202e 2e2e  ess(.        ...
-0001c440: 2020 2020 2073 6f75 7263 6573 3d5b 325d       sources=[2]
-0001c450: 2c20 7461 7267 6574 733d 5b33 2c35 5d29  , targets=[3,5])
-0001c460: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
-0001c470: 7469 6e67 2069 6e74 6572 7265 6769 6f6e  ting interregion
-0001c480: 616c 2062 6574 7765 656e 6e65 7373 2e2e  al betweenness..
-0001c490: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
-0001c4a0: 5b20 312e 2c20 2031 2e2c 2020 302e 2c20  [ 1.,  1.,  0., 
-0001c4b0: 2030 2e2c 2020 312e 2c20 2030 2e5d 290a   0.,  1.,  0.]).
-0001c4c0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-0001c4d0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
-0001c4e0: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
-0001c4f0: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
-0001c500: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0001c510: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001c520: 2e6e 7369 5f62 6574 7765 656e 6e65 7373  .nsi_betweenness
-0001c530: 2873 6f75 7263 6573 3d73 6f75 7263 6573  (sources=sources
-0001c540: 2c20 7461 7267 6574 733d 7461 7267 6574  , targets=target
-0001c550: 732c 2073 696c 656e 743d 3129 0a0a 2020  s, silent=1)..  
-0001c560: 2020 6465 6620 6e73 695f 6265 7477 6565    def nsi_betwee
-0001c570: 6e6e 6573 7328 7365 6c66 2c20 2a2a 6b77  nness(self, **kw
-0001c580: 6172 6773 293a 0a20 2020 2020 2020 2022  args):.        "
-0001c590: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
-0001c5a0: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
-0001c5b0: 2069 7473 206e 2e73 2e69 2e20 6265 7477   its n.s.i. betw
-0001c5c0: 6565 6e6e 6573 732e 0a0a 2020 2020 2020  eenness...      
-0001c5d0: 2020 5468 6973 206d 6561 7375 7265 7320    This measures 
-0001c5e0: 726f 7567 686c 7920 686f 7720 6d61 6e79  roughly how many
-0001c5f0: 2073 686f 7274 6573 7420 7061 7468 7320   shortest paths 
-0001c600: 7061 7373 2074 6872 6f75 6768 2074 6865  pass through the
-0001c610: 206e 6f64 652c 0a20 2020 2020 2020 2074   node,.        t
-0001c620: 616b 696e 6720 6e6f 6465 2077 6569 6768  aking node weigh
-0001c630: 7473 2069 6e74 6f20 6163 636f 756e 742e  ts into account.
-0001c640: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
-0001c650: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
-0001c660: 3e3e 3e20 6e65 7420 3d20 4e65 7477 6f72  >>> net = Networ
-0001c670: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
-0001c680: 726b 2829 0a20 2020 2020 2020 203e 3e3e  rk().        >>>
-0001c690: 2072 286e 6574 2e6e 7369 5f62 6574 7765   r(net.nsi_betwe
-0001c6a0: 656e 6e65 7373 2829 290a 2020 2020 2020  enness()).      
-0001c6b0: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
-0001c6c0: 732e 692e 2062 6574 7765 656e 6e65 7373  s.i. betweenness
-0001c6d0: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-0001c6e0: 7928 5b20 3239 2e36 3835 342c 2037 2e37  y([ 29.6854, 7.7
-0001c6f0: 3132 392c 2030 2e20 2c20 332e 3039 3039  129, 0. , 3.0909
-0001c700: 2c20 392e 3639 3936 2c20 302e 205d 290a  , 9.6996, 0. ]).
-0001c710: 2020 2020 2020 2020 3e3e 3e20 7228 6e65          >>> r(ne
-0001c720: 742e 7370 6c69 7474 6564 5f63 6f70 7928  t.splitted_copy(
-0001c730: 292e 6e73 695f 6265 7477 6565 6e6e 6573  ).nsi_betweennes
-0001c740: 7328 2929 0a20 2020 2020 2020 2043 616c  s()).        Cal
-0001c750: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
-0001c760: 6265 7477 6565 6e6e 6573 732e 2e2e 0a20  betweenness.... 
-0001c770: 2020 2020 2020 2061 7272 6179 285b 2032         array([ 2
-0001c780: 392e 3638 3534 2c20 372e 3731 3239 2c20  9.6854, 7.7129, 
-0001c790: 302e 202c 2033 2e30 3930 392c 2039 2e36  0. , 3.0909, 9.6
-0001c7a0: 3939 362c 2030 2e20 2c20 302e 205d 290a  996, 0. , 0. ]).
-0001c7b0: 0a20 2020 2020 2020 2061 7320 636f 6d70  .        as comp
-0001c7c0: 6172 6564 2074 6f20 7468 6520 756e 7765  ared to the unwe
-0001c7d0: 6967 6874 6564 2076 6572 7369 6f6e 3a0a  ighted version:.
-0001c7e0: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
-0001c7f0: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
-0001c800: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
-0001c810: 2020 2020 2020 3e3e 3e20 6e65 742e 6265        >>> net.be
-0001c820: 7477 6565 6e6e 6573 7328 290a 2020 2020  tweenness().    
-0001c830: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-0001c840: 6e6f 6465 2062 6574 7765 656e 6e65 7373  node betweenness
-0001c850: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-0001c860: 7928 5b20 342e 352c 2020 312e 352c 2020  y([ 4.5,  1.5,  
-0001c870: 302e 202c 2020 312e 202c 2020 332e 202c  0. ,  1. ,  3. ,
-0001c880: 2020 302e 205d 290a 2020 2020 2020 2020    0. ]).        
-0001c890: 3e3e 3e20 6e65 742e 7370 6c69 7474 6564  >>> net.splitted
-0001c8a0: 5f63 6f70 7928 292e 6265 7477 6565 6e6e  _copy().betweenn
-0001c8b0: 6573 7328 290a 2020 2020 2020 2020 4361  ess().        Ca
-0001c8c0: 6c63 756c 6174 696e 6720 6e6f 6465 2062  lculating node b
-0001c8d0: 6574 7765 656e 6e65 7373 2e2e 2e0a 2020  etweenness....  
-0001c8e0: 2020 2020 2020 6172 7261 7928 5b20 382e        array([ 8.
-0001c8f0: 352c 2020 312e 352c 2020 302e 202c 2020  5,  1.5,  0. ,  
-0001c900: 312e 352c 2020 342e 352c 2020 302e 202c  1.5,  4.5,  0. ,
-0001c910: 2020 302e 205d 290a 0a20 2020 2020 2020    0. ])..       
-0001c920: 203a 7274 7970 653a 2031 6420 6e75 6d70   :rtype: 1d nump
-0001c930: 7920 6172 7261 7920 5b6e 6f64 655d 206f  y array [node] o
-0001c940: 6620 666c 6f61 7473 2062 6574 7765 656e  f floats between
-0001c950: 2030 2061 6e64 2031 0a20 2020 2020 2020   0 and 1.       
-0001c960: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
-0001c970: 7365 6c66 2e73 696c 656e 6365 5f6c 6576  self.silence_lev
-0001c980: 656c 203c 3d20 313a 0a20 2020 2020 2020  el <= 1:.       
-0001c990: 2020 2020 2069 6620 2273 696c 656e 7422       if "silent"
-0001c9a0: 206e 6f74 2069 6e20 6b77 6172 6773 3a0a   not in kwargs:.
-0001c9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c9c0: 7072 696e 7428 2243 616c 6375 6c61 7469  print("Calculati
-0001c9d0: 6e67 206e 2e73 2e69 2e20 6265 7477 6565  ng n.s.i. betwee
-0001c9e0: 6e6e 6573 732e 2e2e 2229 0a0a 2020 2020  nness...")..    
-0001c9f0: 2020 2020 7720 3d20 7365 6c66 2e6e 6f64      w = self.nod
-0001ca00: 655f 7765 6967 6874 730a 2020 2020 2020  e_weights.      
-0001ca10: 2020 6966 2022 6177 2220 696e 206b 7761    if "aw" in kwa
-0001ca20: 7267 733a 0a20 2020 2020 2020 2020 2020  rgs:.           
-0001ca30: 2069 6620 6b77 6172 6773 5b22 6177 225d   if kwargs["aw"]
-0001ca40: 203d 3d20 303a 0a20 2020 2020 2020 2020   == 0:.         
-0001ca50: 2020 2020 2020 2077 203d 2030 2e30 2a77         w = 0.0*w
-0001ca60: 202b 2031 2e30 0a0a 2020 2020 2020 2020   + 1.0..        
-0001ca70: 4e2c 206b 203d 2073 656c 662e 4e2c 2073  N, k = self.N, s
-0001ca80: 656c 662e 6465 6772 6565 2829 0a20 2020  elf.degree().   
-0001ca90: 2020 2020 2072 4e20 3d20 7261 6e67 6528       rN = range(
-0001caa0: 302c 204e 290a 2020 2020 2020 2020 7a6e  0, N).        zn
-0001cab0: 203d 206e 702e 7a65 726f 7328 4e2c 2064   = np.zeros(N, d
-0001cac0: 7479 7065 3d6e 702e 666c 6f61 7429 0a20  type=np.float). 
-0001cad0: 2020 2020 2020 2062 6574 7765 656e 6e65         betweenne
-0001cae0: 7373 5f74 696d 6573 5f77 203d 207a 6e2e  ss_times_w = zn.
-0001caf0: 636f 7079 2829 0a0a 2020 2020 2020 2020  copy()..        
-0001cb00: 2320 696e 6974 6961 6c69 7a65 206e 6f64  # initialize nod
-0001cb10: 6520 6c69 7374 733a 0a20 2020 2020 2020  e lists:.       
-0001cb20: 2069 735f 736f 7572 6365 203d 207a 6e2e   is_source = zn.
-0001cb30: 636f 7079 2829 0a20 2020 2020 2020 2069  copy().        i
-0001cb40: 6620 2273 6f75 7263 6573 2220 696e 206b  f "sources" in k
-0001cb50: 7761 7267 7320 616e 6420 6b77 6172 6773  wargs and kwargs
-0001cb60: 5b22 736f 7572 6365 7322 5d20 6973 206e  ["sources"] is n
-0001cb70: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-0001cb80: 2020 2020 2066 6f72 2069 2069 6e20 6b77       for i in kw
-0001cb90: 6172 6773 5b22 736f 7572 6365 7322 5d3a  args["sources"]:
-0001cba0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001cbb0: 2069 735f 736f 7572 6365 5b69 5d20 3d20   is_source[i] = 
-0001cbc0: 310a 2020 2020 2020 2020 656c 7365 3a0a  1.        else:.
-0001cbd0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0001cbe0: 6920 696e 2072 4e3a 0a20 2020 2020 2020  i in rN:.       
-0001cbf0: 2020 2020 2020 2020 2069 735f 736f 7572           is_sour
-0001cc00: 6365 5b69 5d20 3d20 310a 2020 2020 2020  ce[i] = 1.      
-0001cc10: 2020 6966 2022 7461 7267 6574 7322 2069    if "targets" i
-0001cc20: 6e20 6b77 6172 6773 2061 6e64 206b 7761  n kwargs and kwa
-0001cc30: 7267 735b 2274 6172 6765 7473 225d 2069  rgs["targets"] i
-0001cc40: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0001cc50: 2020 2020 2020 2020 7461 7267 6574 7320          targets 
-0001cc60: 3d20 6b77 6172 6773 5b22 7461 7267 6574  = kwargs["target
-0001cc70: 7322 5d0a 2020 2020 2020 2020 656c 7365  s"].        else
-0001cc80: 3a0a 2020 2020 2020 2020 2020 2020 7461  :.            ta
-0001cc90: 7267 6574 7320 3d20 724e 0a0a 2020 2020  rgets = rN..    
-0001cca0: 2020 2020 2320 6e6f 6465 206f 6666 7365      # node offse
-0001ccb0: 7473 2066 6f72 2066 6c61 7420 6172 7261  ts for flat arra
-0001ccc0: 7973 3a0a 2020 2020 2020 2020 6f66 6673  ys:.        offs
-0001ccd0: 6574 7320 3d20 6e70 2e7a 6572 6f73 284e  ets = np.zeros(N
-0001cce0: 290a 2020 2020 2020 2020 666f 7220 6920  ).        for i 
-0001ccf0: 696e 2072 616e 6765 2831 2c20 4e29 3a0a  in range(1, N):.
-0001cd00: 2020 2020 2020 2020 2020 2020 6f66 6673              offs
-0001cd10: 6574 735b 695d 203d 206f 6666 7365 7473  ets[i] = offsets
-0001cd20: 5b69 2d31 5d20 2b20 6b5b 692d 315d 0a20  [i-1] + k[i-1]. 
-0001cd30: 2020 2020 2020 2023 204e 6f74 653a 2057         # Note: W
-0001cd40: 6520 646f 6e27 7420 7573 6520 6b2e 6375  e don't use k.cu
-0001cd50: 6d73 756d 2829 2073 696e 6365 2074 6861  msum() since tha
-0001cd60: 7420 7573 6573 2074 6f20 6d75 6368 206d  t uses to much m
-0001cd70: 656d 6f72 7921 0a0a 2020 2020 2020 2020  emory!..        
-0001cd80: 2320 736f 7274 206c 696e 6b73 2062 7920  # sort links by 
-0001cd90: 6e6f 6465 2069 6e64 6963 6573 2028 636f  node indices (co
-0001cda0: 6e74 6169 6e73 2065 6163 6820 6c69 6e6b  ntains each link
-0001cdb0: 2074 7769 6365 2129 3a0a 2020 2020 2020   twice!):.      
-0001cdc0: 2020 6c69 6e6b 7320 3d20 6e7a 5f63 6f6f    links = nz_coo
-0001cdd0: 7264 7328 7365 6c66 2e73 705f 4129 0a0a  rds(self.sp_A)..
-0001cde0: 2020 2020 2020 2020 2320 6e65 6967 6862          # neighb
-0001cdf0: 6f75 7273 206f 6620 6561 6368 206e 6f64  ours of each nod
-0001ce00: 653a 0a20 2020 2020 2020 2066 6c61 745f  e:.        flat_
-0001ce10: 6e65 6967 6862 6f72 7320 3d20 6e70 2e61  neighbors = np.a
-0001ce20: 7272 6179 286c 696e 6b73 295b 3a2c 2031  rray(links)[:, 1
-0001ce30: 5d2e 6173 7479 7065 2869 6e74 290a 2020  ].astype(int).  
-0001ce40: 2020 2020 2020 4520 3d20 6c65 6e28 666c        E = len(fl
-0001ce50: 6174 5f6e 6569 6768 626f 7273 290a 0a20  at_neighbors).. 
-0001ce60: 2020 2020 2020 2023 2074 6869 7320 6d61         # this ma
-0001ce70: 696e 206c 6f6f 7020 6d69 6768 7420 6265  in loop might be
-0001ce80: 2070 6172 616c 6c65 6c69 7a65 643a 0a20   parallelized:. 
-0001ce90: 2020 2020 2020 2066 6f72 206a 3020 696e         for j0 in
-0001cea0: 2074 6172 6765 7473 3a0a 2020 2020 2020   targets:.      
-0001ceb0: 2020 2020 2020 6a20 3d20 696e 7428 6a30        j = int(j0
-0001cec0: 290a 0a20 2020 2020 2020 2020 2020 2062  )..            b
-0001ced0: 6574 7765 656e 6e65 7373 5f74 6f5f 6a20  etweenness_to_j 
-0001cee0: 3d20 772e 636f 7079 2829 2e61 7374 7970  = w.copy().astyp
-0001cef0: 6528 666c 6f61 7429 0a20 2020 2020 2020  e(float).       
-0001cf00: 2020 2020 2065 7863 6573 735f 746f 5f6a       excess_to_j
-0001cf10: 203d 2077 2e63 6f70 7928 292e 6173 7479   = w.copy().asty
-0001cf20: 7065 2866 6c6f 6174 290a 2020 2020 2020  pe(float).      
-0001cf30: 2020 2020 2020 666c 6174 5f70 7265 6465        flat_prede
-0001cf40: 6365 7373 6f72 7320 3d20 6c69 7374 286e  cessors = list(n
-0001cf50: 702e 7a65 726f 7328 452c 2064 7479 7065  p.zeros(E, dtype
-0001cf60: 3d69 6e74 2929 0a20 2020 2020 2020 2020  =int)).         
-0001cf70: 2020 2023 204e 6f74 653a 2074 6869 7320     # Note: this 
-0001cf80: 6361 6e6e 6f74 2062 6520 7472 616e 7366  cannot be transf
-0001cf90: 6572 7265 6420 6173 206e 756d 7079 2061  erred as numpy a
-0001cfa0: 7272 6179 2073 696e 6365 2069 6620 746f  rray since if to
-0001cfb0: 6f0a 2020 2020 2020 2020 2020 2020 2320  o.            # 
-0001cfc0: 6c61 7267 6520 7765 2067 6574 2061 6e20  large we get an 
-0001cfd0: 676c 6962 6320 6572 726f 722e 2e2e 0a20  glibc error.... 
-0001cfe0: 2020 2020 2020 2020 2020 205f 6e73 695f             _nsi_
-0001cff0: 6265 7477 6565 6e6e 6573 7328 4e2c 2045  betweenness(N, E
-0001d000: 2c20 772c 206b 2c20 6a2c 2062 6574 7765  , w, k, j, betwe
-0001d010: 656e 6e65 7373 5f74 6f5f 6a2c 0a20 2020  enness_to_j,.   
-0001d020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d030: 2020 2020 2020 2020 2020 6578 6365 7373            excess
-0001d040: 5f74 6f5f 6a2c 206f 6666 7365 7473 2e61  _to_j, offsets.a
-0001d050: 7374 7970 6528 696e 7429 2c0a 2020 2020  stype(int),.    
-0001d060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d070: 2020 2020 2020 2020 2066 6c61 745f 6e65           flat_ne
-0001d080: 6967 6862 6f72 732c 0a20 2020 2020 2020  ighbors,.       
-0001d090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d0a0: 2020 2020 2020 6973 5f73 6f75 7263 652c        is_source,
-0001d0b0: 206e 702e 6172 7261 7928 666c 6174 5f70   np.array(flat_p
-0001d0c0: 7265 6465 6365 7373 6f72 7329 290a 2020  redecessors)).  
-0001d0d0: 2020 2020 2020 2020 2020 6465 6c20 666c            del fl
-0001d0e0: 6174 5f70 7265 6465 6365 7373 6f72 730a  at_predecessors.
-0001d0f0: 2020 2020 2020 2020 2020 2020 6265 7477              betw
-0001d100: 6565 6e6e 6573 735f 7469 6d65 735f 7720  eenness_times_w 
-0001d110: 2b3d 2077 5b6a 5d20 2a20 2862 6574 7765  += w[j] * (betwe
-0001d120: 656e 6e65 7373 5f74 6f5f 6a20 2d20 6578  enness_to_j - ex
-0001d130: 6365 7373 5f74 6f5f 6a29 0a0a 2020 2020  cess_to_j)..    
-0001d140: 2020 2020 7265 7475 726e 2062 6574 7765      return betwe
-0001d150: 656e 6e65 7373 5f74 696d 6573 5f77 202f  enness_times_w /
-0001d160: 2077 0a0a 2020 2020 6465 6620 5f65 6967   w..    def _eig
-0001d170: 656e 7665 6374 6f72 5f63 656e 7472 616c  envector_central
-0001d180: 6974 795f 736c 6f77 2873 656c 662c 206c  ity_slow(self, l
-0001d190: 696e 6b5f 6174 7472 6962 7574 653d 4e6f  ink_attribute=No
-0001d1a0: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
-0001d1b0: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
-0001d1c0: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
-0001d1d0: 7473 2028 7765 6967 6874 6564 2920 6569  ts (weighted) ei
-0001d1e0: 6765 6e76 6563 746f 7220 6365 6e74 7261  genvector centra
-0001d1f0: 6c69 7479 2e0a 0a20 2020 2020 2020 2054  lity...        T
-0001d200: 6869 7320 6973 2074 6865 206c 6f61 6420  his is the load 
-0001d210: 6f6e 2074 6869 7320 6e6f 6465 2066 726f  on this node fro
-0001d220: 6d20 7468 6520 6569 6765 6e76 6563 746f  m the eigenvecto
-0001d230: 7220 636f 7272 6573 706f 6e64 696e 6720  r corresponding 
-0001d240: 746f 2074 6865 0a20 2020 2020 2020 206c  to the.        l
-0001d250: 6172 6765 7374 2065 6967 656e 7661 6c75  argest eigenvalu
-0001d260: 6520 6f66 2074 6865 2028 7765 6967 6874  e of the (weight
-0001d270: 6564 2920 6164 6a61 6365 6e63 7920 6d61  ed) adjacency ma
-0001d280: 7472 6978 2c20 6e6f 726d 616c 697a 6564  trix, normalized
-0001d290: 2074 6f20 610a 2020 2020 2020 2020 6d61   to a.        ma
-0001d2a0: 7869 6d75 6d20 6f66 2031 2e0a 0a20 2020  ximum of 1...   
-0001d2b0: 2020 2020 203a 6172 6720 7374 7220 6c69       :arg str li
-0001d2c0: 6e6b 5f61 7474 7269 6275 7465 3a20 4f70  nk_attribute: Op
-0001d2d0: 7469 6f6e 616c 206e 616d 6520 6f66 2074  tional name of t
-0001d2e0: 6865 206c 696e 6b20 6174 7472 6962 7574  he link attribut
-0001d2f0: 6520 746f 2062 6520 7573 6564 0a20 2020  e to be used.   
-0001d300: 2020 2020 2020 2020 2061 7320 7468 6520           as the 
-0001d310: 6c69 6e6b 7327 2077 6569 6768 742e 2049  links' weight. I
-0001d320: 6620 4e6f 6e65 2c20 6c69 6e6b 7320 6861  f None, links ha
-0001d330: 7665 2077 6569 6768 7420 312e 2028 4465  ve weight 1. (De
-0001d340: 6661 756c 743a 204e 6f6e 6529 0a20 2020  fault: None).   
-0001d350: 2020 2020 203a 7274 7970 653a 2031 6420       :rtype: 1d 
-0001d360: 6e75 6d70 7920 6172 7261 7920 5b6e 6f64  numpy array [nod
-0001d370: 655d 206f 6620 666c 6f61 7473 0a20 2020  e] of floats.   
-0001d380: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0001d390: 2069 6620 6c69 6e6b 5f61 7474 7269 6275   if link_attribu
-0001d3a0: 7465 203d 3d20 2274 6f70 6f6c 6f67 6963  te == "topologic
-0001d3b0: 616c 223a 0a20 2020 2020 2020 2020 2020  al":.           
-0001d3c0: 2070 7269 6e74 2822 5741 524e 494e 473a   print("WARNING:
-0001d3d0: 206c 696e 6b5f 6174 7472 6962 7574 653d   link_attribute=
-0001d3e0: 2774 6f70 6f6c 6f67 6963 616c 2720 6973  'topological' is
-0001d3f0: 2064 6570 7265 6361 7465 642e 5c6e 220a   deprecated.\n".
-0001d400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d410: 2020 2b20 2255 7365 206c 696e 6b5f 6174    + "Use link_at
-0001d420: 7472 6962 7574 653d 4e6f 6e65 2069 6e73  tribute=None ins
-0001d430: 7465 6164 2e22 290a 2020 2020 2020 2020  tead.").        
-0001d440: 2020 2020 6c69 6e6b 5f61 7474 7269 6275      link_attribu
-0001d450: 7465 203d 204e 6f6e 650a 0a20 2020 2020  te = None..     
-0001d460: 2020 2069 6620 6c69 6e6b 5f61 7474 7269     if link_attri
-0001d470: 6275 7465 2069 7320 4e6f 6e65 3a0a 2020  bute is None:.  
-0001d480: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0001d490: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
-0001d4a0: 3c3d 2031 3a0a 2020 2020 2020 2020 2020  <= 1:.          
-0001d4b0: 2020 2020 2020 7072 696e 7428 2243 616c        print("Cal
-0001d4c0: 6375 6c61 7469 6e67 2074 6f70 6f6c 6f67  culating topolog
-0001d4d0: 6963 616c 2065 6967 656e 7665 6374 6f72  ical eigenvector
-0001d4e0: 2063 656e 7472 616c 6974 792e 2e2e 2229   centrality...")
-0001d4f0: 0a0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-0001d500: 7475 726e 206e 702e 6172 7261 7928 7365  turn np.array(se
-0001d510: 6c66 2e67 7261 7068 2e65 6967 656e 7665  lf.graph.eigenve
-0001d520: 6374 6f72 5f63 656e 7472 616c 6974 7928  ctor_centrality(
-0001d530: 7765 6967 6874 733d 4e6f 6e65 2929 0a20  weights=None)). 
-0001d540: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0001d550: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-0001d560: 2e73 696c 656e 6365 5f6c 6576 656c 203c  .silence_level <
-0001d570: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
-0001d580: 2020 2020 2070 7269 6e74 2822 4361 6c63       print("Calc
-0001d590: 756c 6174 696e 6720 7765 6967 6874 6564  ulating weighted
-0001d5a0: 2065 6967 656e 7665 6374 6f72 2063 656e   eigenvector cen
-0001d5b0: 7472 616c 6974 792e 2e2e 2229 0a0a 2020  trality...")..  
-0001d5c0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001d5d0: 206e 702e 6172 7261 7928 7365 6c66 2e67   np.array(self.g
-0001d5e0: 7261 7068 2e65 6967 656e 7665 6374 6f72  raph.eigenvector
-0001d5f0: 5f63 656e 7472 616c 6974 7928 0a20 2020  _centrality(.   
-0001d600: 2020 2020 2020 2020 2020 2020 2077 6569               wei
-0001d610: 6768 7473 3d6c 696e 6b5f 6174 7472 6962  ghts=link_attrib
-0001d620: 7574 6529 290a 0a20 2020 2023 2066 6173  ute))..    # fas
-0001d630: 7465 7220 7665 7273 696f 6e20 6f66 2074  ter version of t
-0001d640: 6865 2061 626f 7665 3a0a 2020 2020 4063  he above:.    @c
-0001d650: 6163 6865 645f 636f 6e73 7428 2762 6173  ached_const('bas
-0001d660: 6527 2c20 2765 7620 6365 6e74 7261 6c69  e', 'ev centrali
-0001d670: 7479 272c 2027 6569 6765 6e76 6563 746f  ty', 'eigenvecto
-0001d680: 7220 6365 6e74 7261 6c69 7479 2729 0a20  r centrality'). 
-0001d690: 2020 2064 6566 2065 6967 656e 7665 6374     def eigenvect
-0001d6a0: 6f72 5f63 656e 7472 616c 6974 7928 7365  or_centrality(se
-0001d6b0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0001d6c0: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
-0001d6d0: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
-0001d6e0: 7473 2065 6967 656e 7665 6374 6f72 2063  ts eigenvector c
-0001d6f0: 656e 7472 616c 6974 792e 0a0a 2020 2020  entrality...    
-0001d700: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
-0001d710: 6c6f 6164 206f 6e20 7468 6973 206e 6f64  load on this nod
-0001d720: 6520 6672 6f6d 2074 6865 2065 6967 656e  e from the eigen
-0001d730: 7665 6374 6f72 2063 6f72 7265 7370 6f6e  vector correspon
-0001d740: 6469 6e67 2074 6f20 7468 650a 2020 2020  ding to the.    
-0001d750: 2020 2020 6c61 7267 6573 7420 6569 6765      largest eige
-0001d760: 6e76 616c 7565 206f 6620 7468 6520 6164  nvalue of the ad
-0001d770: 6a61 6365 6e63 7920 6d61 7472 6978 2c20  jacency matrix, 
-0001d780: 6e6f 726d 616c 697a 6564 2074 6f20 610a  normalized to a.
-0001d790: 2020 2020 2020 2020 6d61 7869 6d75 6d20          maximum 
-0001d7a0: 6f66 2031 2e0a 0a20 2020 2020 2020 202a  of 1...        *
-0001d7b0: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-0001d7c0: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
-0001d7d0: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-0001d7e0: 6f72 6b28 292e 6569 6765 6e76 6563 746f  ork().eigenvecto
-0001d7f0: 725f 6365 6e74 7261 6c69 7479 2829 290a  r_centrality()).
-0001d800: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-0001d810: 696e 6720 6569 6765 6e76 6563 746f 7220  ing eigenvector 
-0001d820: 6365 6e74 7261 6c69 7479 2e2e 2e0a 2020  centrality....  
-0001d830: 2020 2020 2020 6172 7261 7928 5b20 302e        array([ 0.
-0001d840: 3738 3935 2c20 302e 3937 3320 2c20 302e  7895, 0.973 , 0.
-0001d850: 3737 3639 2c20 302e 3639 3431 2c20 312e  7769, 0.6941, 1.
-0001d860: 202c 2030 2e33 3130 395d 290a 0a20 2020   , 0.3109])..   
-0001d870: 2020 2020 203a 7274 7970 653a 2031 6420       :rtype: 1d 
-0001d880: 6e75 6d70 7920 6172 7261 7920 5b6e 6f64  numpy array [nod
-0001d890: 655d 206f 6620 666c 6f61 7473 0a20 2020  e] of floats.   
-0001d8a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0001d8b0: 2023 2054 4f44 4f3a 2061 6c6c 6f77 2066   # TODO: allow f
-0001d8c0: 6f72 2077 6569 6768 7473 0a20 2020 2020  or weights.     
-0001d8d0: 2020 205f 2c20 6576 6563 7320 3d20 6569     _, evecs = ei
-0001d8e0: 6773 6828 7365 6c66 2e73 705f 412e 6173  gsh(self.sp_A.as
-0001d8f0: 7479 7065 2866 6c6f 6174 292c 206b 3d31  type(float), k=1
-0001d900: 2c20 7369 676d 613d 7365 6c66 2e4e 2a2a  , sigma=self.N**
-0001d910: 322c 0a20 2020 2020 2020 2020 2020 2020  2,.             
-0001d920: 2020 2020 2020 2020 2020 2020 6d61 7869              maxi
-0001d930: 7465 723d 3130 302c 2074 6f6c 3d31 652d  ter=100, tol=1e-
-0001d940: 3829 0a20 2020 2020 2020 2065 6320 3d20  8).        ec = 
-0001d950: 6576 6563 732e 545b 305d 0a20 2020 2020  evecs.T[0].     
-0001d960: 2020 2065 6320 2a3d 206e 702e 7369 676e     ec *= np.sign
-0001d970: 2865 635b 305d 290a 2020 2020 2020 2020  (ec[0]).        
-0001d980: 7265 7475 726e 2065 6320 2f20 6563 2e6d  return ec / ec.m
-0001d990: 6178 2829 0a0a 2020 2020 4063 6163 6865  ax()..    @cache
-0001d9a0: 645f 636f 6e73 7428 276e 7369 272c 2027  d_const('nsi', '
-0001d9b0: 6576 2063 656e 7472 616c 6974 7927 2c20  ev centrality', 
-0001d9c0: 276e 2e73 2e69 2e20 6569 6765 6e76 6563  'n.s.i. eigenvec
-0001d9d0: 746f 7220 6365 6e74 7261 6c69 7479 2729  tor centrality')
-0001d9e0: 0a20 2020 2064 6566 206e 7369 5f65 6967  .    def nsi_eig
-0001d9f0: 656e 7665 6374 6f72 5f63 656e 7472 616c  envector_central
-0001da00: 6974 7928 7365 6c66 293a 0a20 2020 2020  ity(self):.     
-0001da10: 2020 2022 2222 0a20 2020 2020 2020 2046     """.        F
-0001da20: 6f72 2065 6163 6820 6e6f 6465 2c20 7265  or each node, re
-0001da30: 7475 726e 2069 7473 206e 2e73 2e69 2e20  turn its n.s.i. 
-0001da40: 6569 6765 6e76 6563 746f 7220 6365 6e74  eigenvector cent
-0001da50: 7261 6c69 7479 2e0a 0a20 2020 2020 2020  rality...       
-0001da60: 2054 6869 7320 6973 2074 6865 206c 6f61   This is the loa
-0001da70: 6420 6f6e 2074 6869 7320 6e6f 6465 2066  d on this node f
-0001da80: 726f 6d20 7468 6520 6569 6765 6e76 6563  rom the eigenvec
-0001da90: 746f 7220 636f 7272 6573 706f 6e64 696e  tor correspondin
-0001daa0: 6720 746f 2074 6865 0a20 2020 2020 2020  g to the.       
-0001dab0: 206c 6172 6765 7374 2065 6967 656e 7661   largest eigenva
-0001dac0: 6c75 6520 6f66 2074 6865 206e 2e73 2e69  lue of the n.s.i
-0001dad0: 2e20 6164 6a61 6365 6e63 7920 6d61 7472  . adjacency matr
-0001dae0: 6978 2c20 6469 7669 6465 6420 6279 0a20  ix, divided by. 
-0001daf0: 2020 2020 2020 2073 7172 7428 6e6f 6465         sqrt(node
-0001db00: 2077 6569 6768 7429 2061 6e64 206e 6f72   weight) and nor
-0001db10: 6d61 6c69 7a65 6420 746f 2061 206d 6178  malized to a max
-0001db20: 696d 756d 206f 6620 312e 0a0a 2020 2020  imum of 1...    
-0001db30: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
-0001db40: 0a0a 2020 2020 2020 2020 3e3e 3e20 6e65  ..        >>> ne
-0001db50: 7420 3d20 4e65 7477 6f72 6b2e 536d 616c  t = Network.Smal
-0001db60: 6c54 6573 744e 6574 776f 726b 2829 0a20  lTestNetwork(). 
-0001db70: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
-0001db80: 2e6e 7369 5f65 6967 656e 7665 6374 6f72  .nsi_eigenvector
-0001db90: 5f63 656e 7472 616c 6974 7928 2929 0a20  _centrality()). 
-0001dba0: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-0001dbb0: 6e67 206e 2e73 2e69 2e20 6569 6765 6e76  ng n.s.i. eigenv
-0001dbc0: 6563 746f 7220 6365 6e74 7261 6c69 7479  ector centrality
-0001dbd0: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-0001dbe0: 7928 5b20 302e 3830 3435 2c20 312e 202c  y([ 0.8045, 1. ,
-0001dbf0: 2030 2e38 3039 332c 2030 2e36 3137 392c   0.8093, 0.6179,
-0001dc00: 2030 2e39 3836 372c 2030 2e32 3830 345d   0.9867, 0.2804]
-0001dc10: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
-0001dc20: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
-0001dc30: 7928 292e 6e73 695f 6569 6765 6e76 6563  y().nsi_eigenvec
-0001dc40: 746f 725f 6365 6e74 7261 6c69 7479 2829  tor_centrality()
-0001dc50: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-0001dc60: 6174 696e 6720 6e2e 732e 692e 2065 6967  ating n.s.i. eig
-0001dc70: 656e 7665 6374 6f72 2063 656e 7472 616c  envector central
-0001dc80: 6974 792e 2e2e 0a20 2020 2020 2020 2061  ity....        a
-0001dc90: 7272 6179 285b 2030 2e38 3034 352c 2031  rray([ 0.8045, 1
-0001dca0: 2e20 2c20 302e 3830 3933 2c20 302e 3631  . , 0.8093, 0.61
-0001dcb0: 3739 2c20 302e 3938 3637 2c20 302e 3238  79, 0.9867, 0.28
-0001dcc0: 3034 2c20 302e 3238 3034 5d29 0a0a 2020  04, 0.2804])..  
-0001dcd0: 2020 2020 2020 6173 2063 6f6d 7061 7265        as compare
-0001dce0: 6420 746f 2074 6865 2075 6e77 6569 6768  d to the unweigh
-0001dcf0: 7465 6420 7665 7273 696f 6e3a 0a0a 2020  ted version:..  
-0001dd00: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
-0001dd10: 6569 6765 6e76 6563 746f 725f 6365 6e74  eigenvector_cent
-0001dd20: 7261 6c69 7479 2829 290a 2020 2020 2020  rality()).      
-0001dd30: 2020 4361 6c63 756c 6174 696e 6720 6569    Calculating ei
-0001dd40: 6765 6e76 6563 746f 7220 6365 6e74 7261  genvector centra
-0001dd50: 6c69 7479 2e2e 2e0a 2020 2020 2020 2020  lity....        
-0001dd60: 6172 7261 7928 5b20 302e 3738 3935 2c20  array([ 0.7895, 
-0001dd70: 302e 3937 3320 2c20 302e 3737 3639 2c20  0.973 , 0.7769, 
-0001dd80: 302e 3639 3431 2c20 312e 202c 2030 2e33  0.6941, 1. , 0.3
-0001dd90: 3130 395d 290a 2020 2020 2020 2020 3e3e  109]).        >>
-0001dda0: 3e20 7228 6e65 742e 7370 6c69 7474 6564  > r(net.splitted
-0001ddb0: 5f63 6f70 7928 292e 6569 6765 6e76 6563  _copy().eigenvec
-0001ddc0: 746f 725f 6365 6e74 7261 6c69 7479 2829  tor_centrality()
-0001ddd0: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-0001dde0: 6174 696e 6720 6569 6765 6e76 6563 746f  ating eigenvecto
-0001ddf0: 7220 6365 6e74 7261 6c69 7479 2e2e 2e0a  r centrality....
-0001de00: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-0001de10: 312e 202c 2030 2e38 3030 382c 2030 2e36  1. , 0.8008, 0.6
-0001de20: 3232 362c 2030 2e36 3632 352c 2030 2e38  226, 0.6625, 0.8
-0001de30: 3931 362c 2030 2e35 3832 202c 2030 2e35  916, 0.582 , 0.5
-0001de40: 3832 205d 290a 0a20 2020 2020 2020 203a  82 ])..        :
-0001de50: 7274 7970 653a 2031 6420 6e75 6d70 7920  rtype: 1d numpy 
-0001de60: 6172 7261 7920 5b6e 6f64 655d 206f 6620  array [node] of 
-0001de70: 666c 6f61 7473 0a20 2020 2020 2020 2022  floats.        "
-0001de80: 2222 0a20 2020 2020 2020 2044 7752 203d  "".        DwR =
-0001de90: 2073 656c 662e 7370 5f64 6961 675f 7371   self.sp_diag_sq
-0001dea0: 7274 5f77 2829 0a20 2020 2020 2020 2073  rt_w().        s
-0001deb0: 705f 4173 7461 7220 3d20 4477 5220 2a20  p_Astar = DwR * 
-0001dec0: 7365 6c66 2e73 705f 4170 6c75 7328 2920  self.sp_Aplus() 
-0001ded0: 2a20 4477 520a 2020 2020 2020 2020 5f2c  * DwR.        _,
-0001dee0: 2065 7665 6373 203d 2065 6967 7368 2873   evecs = eigsh(s
-0001def0: 705f 4173 7461 722c 206b 3d31 2c20 7369  p_Astar, k=1, si
-0001df00: 676d 613d 7365 6c66 2e74 6f74 616c 5f6e  gma=self.total_n
-0001df10: 6f64 655f 7765 6967 6874 2a2a 322c 0a20  ode_weight**2,. 
-0001df20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001df30: 2020 2020 2020 2020 6d61 7869 7465 723d          maxiter=
-0001df40: 3130 302c 2074 6f6c 3d31 652d 3829 0a20  100, tol=1e-8). 
-0001df50: 2020 2020 2020 2065 6320 3d20 6576 6563         ec = evec
-0001df60: 732e 545b 305d 202f 206e 702e 7371 7274  s.T[0] / np.sqrt
-0001df70: 2873 656c 662e 6e6f 6465 5f77 6569 6768  (self.node_weigh
-0001df80: 7473 290a 2020 2020 2020 2020 6563 202a  ts).        ec *
-0001df90: 3d20 6e70 2e73 6967 6e28 6563 5b30 5d29  = np.sign(ec[0])
-0001dfa0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001dfb0: 6563 202f 2065 632e 6d61 7828 290a 0a20  ec / ec.max().. 
-0001dfc0: 2020 2064 6566 2070 6167 6572 616e 6b28     def pagerank(
-0001dfd0: 7365 6c66 2c20 6c69 6e6b 5f61 7474 7269  self, link_attri
-0001dfe0: 6275 7465 3d4e 6f6e 652c 2075 7365 5f64  bute=None, use_d
-0001dff0: 6972 6563 7465 643d 5472 7565 293a 0a20  irected=True):. 
-0001e000: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0001e010: 2020 2046 6f72 2065 6163 6820 6e6f 6465     For each node
-0001e020: 2c20 7265 7475 726e 2069 7473 2028 7765  , return its (we
-0001e030: 6967 6874 6564 2920 5061 6765 5261 6e6b  ighted) PageRank
-0001e040: 2e0a 0a20 2020 2020 2020 2054 6869 7320  ...        This 
-0001e050: 6973 2074 6865 206c 6f61 6420 6f6e 2074  is the load on t
-0001e060: 6869 7320 6e6f 6465 2066 726f 6d20 7468  his node from th
-0001e070: 6520 6569 6765 6e76 6563 746f 7220 636f  e eigenvector co
-0001e080: 7272 6573 706f 6e64 696e 6720 746f 2074  rresponding to t
-0001e090: 6865 0a20 2020 2020 2020 206c 6172 6765  he.        large
-0001e0a0: 7374 2065 6967 656e 7661 6c75 6520 6f66  st eigenvalue of
-0001e0b0: 2061 206d 6f64 6966 6965 6420 6164 6a61   a modified adja
-0001e0c0: 6365 6e63 7920 6d61 7472 6978 2c20 6e6f  cency matrix, no
-0001e0d0: 726d 616c 697a 6564 2074 6f20 610a 2020  rmalized to a.  
-0001e0e0: 2020 2020 2020 6d61 7869 6d75 6d20 6f66        maximum of
-0001e0f0: 2031 2e0a 0a20 2020 2020 2020 202a 2a45   1...        **E
-0001e100: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
-0001e110: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
-0001e120: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-0001e130: 6b28 292e 7061 6765 7261 6e6b 2829 290a  k().pagerank()).
-0001e140: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-0001e150: 696e 6720 5061 6765 5261 6e6b 2e2e 2e0a  ing PageRank....
-0001e160: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-0001e170: 302e 3231 3834 2c20 302e 3230 3434 2c20  0.2184, 0.2044, 
-0001e180: 302e 3134 3039 2c20 302e 3134 3438 2c20  0.1409, 0.1448, 
-0001e190: 302e 3230 3437 2c20 302e 3038 3639 5d29  0.2047, 0.0869])
-0001e1a0: 0a0a 2020 2020 2020 2020 3a61 7267 2073  ..        :arg s
-0001e1b0: 7472 206c 696e 6b5f 6174 7472 6962 7574  tr link_attribut
-0001e1c0: 653a 204f 7074 696f 6e61 6c20 6e61 6d65  e: Optional name
-0001e1d0: 206f 6620 7468 6520 6c69 6e6b 2061 7474   of the link att
-0001e1e0: 7269 6275 7465 2074 6f20 6265 2075 7365  ribute to be use
-0001e1f0: 640a 2020 2020 2020 2020 2020 2020 6173  d.            as
-0001e200: 2074 6865 206c 696e 6b73 2720 7765 6967   the links' weig
-0001e210: 6874 2e20 4966 204e 6f6e 652c 206c 696e  ht. If None, lin
-0001e220: 6b73 2068 6176 6520 7765 6967 6874 2031  ks have weight 1
-0001e230: 2e20 2844 6566 6175 6c74 3a20 4e6f 6e65  . (Default: None
-0001e240: 290a 2020 2020 2020 2020 3a72 7479 7065  ).        :rtype
-0001e250: 3a20 3164 206e 756d 7079 2061 7272 6179  : 1d numpy array
-0001e260: 205b 6e6f 6465 5d20 6f66 0a20 2020 2020   [node] of.     
-0001e270: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
-0001e280: 6620 6c69 6e6b 5f61 7474 7269 6275 7465  f link_attribute
-0001e290: 203d 3d20 2274 6f70 6f6c 6f67 6963 616c   == "topological
-0001e2a0: 223a 0a20 2020 2020 2020 2020 2020 2070  ":.            p
-0001e2b0: 7269 6e74 2822 5741 524e 494e 473a 206c  rint("WARNING: l
-0001e2c0: 696e 6b5f 6174 7472 6962 7574 653d 2774  ink_attribute='t
-0001e2d0: 6f70 6f6c 6f67 6963 616c 2720 6973 2064  opological' is d
-0001e2e0: 6570 7265 6361 7465 642e 5c6e 220a 2020  eprecated.\n".  
-0001e2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e300: 2b20 2255 7365 206c 696e 6b5f 6174 7472  + "Use link_attr
-0001e310: 6962 7574 653d 4e6f 6e65 2069 6e73 7465  ibute=None inste
-0001e320: 6164 2e22 290a 2020 2020 2020 2020 2020  ad.").          
-0001e330: 2020 6c69 6e6b 5f61 7474 7269 6275 7465    link_attribute
-0001e340: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
-0001e350: 6966 206c 696e 6b5f 6174 7472 6962 7574  if link_attribut
-0001e360: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
-0001e370: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
-0001e380: 696c 656e 6365 5f6c 6576 656c 203c 3d20  ilence_level <= 
-0001e390: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
-0001e3a0: 2020 2070 7269 6e74 2822 4361 6c63 756c     print("Calcul
-0001e3b0: 6174 696e 6720 5061 6765 5261 6e6b 2e2e  ating PageRank..
-0001e3c0: 2e22 290a 2020 2020 2020 2020 2020 2020  .").            
-0001e3d0: 7265 7475 726e 206e 702e 6172 7261 7928  return np.array(
-0001e3e0: 7365 6c66 2e67 7261 7068 2e70 6572 736f  self.graph.perso
-0001e3f0: 6e61 6c69 7a65 645f 7061 6765 7261 6e6b  nalized_pagerank
-0001e400: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0001e410: 2020 6469 7265 6374 6564 3d75 7365 5f64    directed=use_d
-0001e420: 6972 6563 7465 642c 2077 6569 6768 7473  irected, weights
-0001e430: 3d4e 6f6e 6529 290a 2020 2020 2020 2020  =None)).        
-0001e440: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0001e450: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
-0001e460: 655f 6c65 7665 6c20 3c3d 2031 3a0a 2020  e_level <= 1:.  
-0001e470: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-0001e480: 696e 7428 2243 616c 6375 6c61 7469 6e67  int("Calculating
-0001e490: 2077 6569 6768 7465 6420 5061 6765 5261   weighted PageRa
-0001e4a0: 6e6b 2e2e 2e22 290a 2020 2020 2020 2020  nk...").        
-0001e4b0: 2020 2020 7265 7475 726e 206e 702e 6172      return np.ar
-0001e4c0: 7261 7928 7365 6c66 2e67 7261 7068 2e70  ray(self.graph.p
-0001e4d0: 6572 736f 6e61 6c69 7a65 645f 7061 6765  ersonalized_page
-0001e4e0: 7261 6e6b 280a 2020 2020 2020 2020 2020  rank(.          
-0001e4f0: 2020 2020 2020 6469 7265 6374 6564 3d75        directed=u
-0001e500: 7365 5f64 6972 6563 7465 642c 2077 6569  se_directed, wei
-0001e510: 6768 7473 3d6c 696e 6b5f 6174 7472 6962  ghts=link_attrib
-0001e520: 7574 6529 290a 0a20 2020 2064 6566 2063  ute))..    def c
-0001e530: 6c6f 7365 6e65 7373 2873 656c 662c 206c  loseness(self, l
-0001e540: 696e 6b5f 6174 7472 6962 7574 653d 4e6f  ink_attribute=No
-0001e550: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
-0001e560: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
-0001e570: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
-0001e580: 7473 2028 7765 6967 6874 6564 2920 636c  ts (weighted) cl
-0001e590: 6f73 656e 6573 732e 0a0a 2020 2020 2020  oseness...      
-0001e5a0: 2020 5468 6973 2069 7320 7468 6520 696e    This is the in
-0001e5b0: 7665 7273 6520 6f66 2074 6865 206d 6561  verse of the mea
-0001e5c0: 6e20 7368 6f72 7465 7374 2070 6174 6820  n shortest path 
-0001e5d0: 6c65 6e67 7468 2066 726f 6d20 7468 6520  length from the 
-0001e5e0: 6e6f 6465 2074 6f0a 2020 2020 2020 2020  node to.        
-0001e5f0: 616c 6c20 6f74 6865 7220 6e6f 6465 732e  all other nodes.
-0001e600: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
-0001e610: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
-0001e620: 3e3e 3e20 7228 4e65 7477 6f72 6b2e 536d  >>> r(Network.Sm
-0001e630: 616c 6c54 6573 744e 6574 776f 726b 2829  allTestNetwork()
-0001e640: 2e63 6c6f 7365 6e65 7373 2829 290a 2020  .closeness()).  
-0001e650: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-0001e660: 6720 636c 6f73 656e 6573 732e 2e2e 0a20  g closeness.... 
-0001e670: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
-0001e680: 2e37 3134 332c 2030 2e36 3235 202c 2030  .7143, 0.625 , 0
-0001e690: 2e35 3535 362c 2030 2e36 3235 202c 2030  .5556, 0.625 , 0
-0001e6a0: 2e37 3134 332c 2030 2e34 3534 355d 290a  .7143, 0.4545]).
-0001e6b0: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
-0001e6c0: 7220 6c69 6e6b 5f61 7474 7269 6275 7465  r link_attribute
-0001e6d0: 3a20 4f70 7469 6f6e 616c 206e 616d 6520  : Optional name 
-0001e6e0: 6f66 2074 6865 206c 696e 6b20 6174 7472  of the link attr
-0001e6f0: 6962 7574 6520 746f 2062 6520 7573 6564  ibute to be used
-0001e700: 0a20 2020 2020 2020 2020 2020 2061 7320  .            as 
-0001e710: 7468 6520 6c69 6e6b 7327 206c 656e 6774  the links' lengt
-0001e720: 682e 2049 6620 4e6f 6e65 2c20 6c69 6e6b  h. If None, link
-0001e730: 7320 6861 7665 206c 656e 6774 6820 312e  s have length 1.
-0001e740: 2028 4465 6661 756c 743a 204e 6f6e 6529   (Default: None)
-0001e750: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-0001e760: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
-0001e770: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
-0001e780: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
-0001e790: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0001e7a0: 2020 2020 2023 2054 4f44 4f3a 2063 6865       # TODO: che
-0001e7b0: 636b 2061 6e64 2064 6573 6372 6962 6520  ck and describe 
-0001e7c0: 6265 6861 7669 6f75 7220 666f 7220 756e  behaviour for un
-0001e7d0: 636f 6e6e 6563 7465 6420 6e65 7477 6f72  connected networ
-0001e7e0: 6b73 2e0a 2020 2020 2020 2020 6966 206c  ks..        if l
-0001e7f0: 696e 6b5f 6174 7472 6962 7574 6520 3d3d  ink_attribute ==
-0001e800: 2022 746f 706f 6c6f 6769 6361 6c22 3a0a   "topological":.
-0001e810: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0001e820: 7428 2257 4152 4e49 4e47 3a20 6c69 6e6b  t("WARNING: link
-0001e830: 5f61 7474 7269 6275 7465 3d27 746f 706f  _attribute='topo
-0001e840: 6c6f 6769 6361 6c27 2069 7320 6465 7072  logical' is depr
-0001e850: 6563 6174 6564 2e5c 6e22 0a20 2020 2020  ecated.\n".     
-0001e860: 2020 2020 2020 2020 2020 2020 202b 2022               + "
-0001e870: 5573 6520 6c69 6e6b 5f61 7474 7269 6275  Use link_attribu
-0001e880: 7465 3d4e 6f6e 6520 696e 7374 6561 642e  te=None instead.
-0001e890: 2229 0a20 2020 2020 2020 2020 2020 206c  ").            l
-0001e8a0: 696e 6b5f 6174 7472 6962 7574 6520 3d20  ink_attribute = 
-0001e8b0: 4e6f 6e65 0a0a 2020 2020 2020 2020 6966  None..        if
-0001e8c0: 206c 696e 6b5f 6174 7472 6962 7574 6520   link_attribute 
-0001e8d0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0001e8e0: 2020 2020 2069 6620 7365 6c66 2e73 696c       if self.sil
-0001e8f0: 656e 6365 5f6c 6576 656c 203c 3d20 313a  ence_level <= 1:
-0001e900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e910: 2070 7269 6e74 2822 4361 6c63 756c 6174   print("Calculat
-0001e920: 696e 6720 636c 6f73 656e 6573 732e 2e2e  ing closeness...
-0001e930: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
-0001e940: 2320 2052 6574 7572 6e20 7468 6520 6162  #  Return the ab
-0001e950: 736f 6c75 7465 2076 616c 7565 206f 6620  solute value of 
-0001e960: 7463 632c 2073 696e 6365 2061 2062 7567  tcc, since a bug
-0001e970: 2073 6f6d 6574 696d 6573 2072 6573 756c   sometimes resul
-0001e980: 7473 0a20 2020 2020 2020 2020 2020 2023  ts.            #
-0001e990: 2020 696e 206e 6567 6174 6976 6520 7369    in negative si
-0001e9a0: 676e 730a 2020 2020 2020 2020 2020 2020  gns.            
-0001e9b0: 7265 7475 726e 206e 702e 6162 7328 6e70  return np.abs(np
-0001e9c0: 2e61 7272 6179 2873 656c 662e 6772 6170  .array(self.grap
-0001e9d0: 682e 636c 6f73 656e 6573 7328 2929 290a  h.closeness())).
-0001e9e0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0001e9f0: 2020 2020 2020 2020 2020 2043 4320 3d20             CC = 
-0001ea00: 6e70 2e7a 6572 6f73 2873 656c 662e 4e29  np.zeros(self.N)
-0001ea10: 0a20 2020 2020 2020 2020 2020 2070 6174  .            pat
-0001ea20: 685f 6c65 6e67 7468 7320 3d20 7365 6c66  h_lengths = self
-0001ea30: 2e70 6174 685f 6c65 6e67 7468 7328 6c69  .path_lengths(li
-0001ea40: 6e6b 5f61 7474 7269 6275 7465 290a 0a20  nk_attribute).. 
-0001ea50: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-0001ea60: 6c66 2e73 696c 656e 6365 5f6c 6576 656c  lf.silence_level
-0001ea70: 203c 3d20 313a 0a20 2020 2020 2020 2020   <= 1:.         
-0001ea80: 2020 2020 2020 2070 7269 6e74 2822 4361         print("Ca
-0001ea90: 6c63 756c 6174 696e 6720 7765 6967 6874  lculating weight
-0001eaa0: 6564 2063 6c6f 7365 6e65 7373 2e2e 2e22  ed closeness..."
-0001eab0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
-0001eac0: 2020 4964 656e 7469 6679 2075 6e63 6f6e    Identify uncon
-0001ead0: 6e65 6374 6564 2070 6169 7273 2061 6e64  nected pairs and
-0001eae0: 2073 6176 6520 696e 2062 696e 6172 7920   save in binary 
-0001eaf0: 6172 7261 7920 6973 696e 660a 2020 2020  array isinf.    
-0001eb00: 2020 2020 2020 2020 756e 636f 6e6e 6563          unconnec
-0001eb10: 7465 645f 7061 6972 7320 3d20 6e70 2e69  ted_pairs = np.i
-0001eb20: 7369 6e66 2870 6174 685f 6c65 6e67 7468  sinf(path_length
-0001eb30: 7329 0a20 2020 2020 2020 2020 2020 2023  s).            #
-0001eb40: 2020 5365 7420 696e 6669 6e69 7465 2065    Set infinite e
-0001eb50: 6e74 7269 6573 2063 6f72 7265 7370 6f6e  ntries correspon
-0001eb60: 6469 6e67 2074 6f20 756e 636f 6e6e 6563  ding to unconnec
-0001eb70: 7465 6420 7061 6972 7320 746f 0a20 2020  ted pairs to.   
-0001eb80: 2020 2020 2020 2020 2023 2020 6e75 6d62           #  numb
-0001eb90: 6572 206f 6620 7665 7274 6963 6573 0a20  er of vertices. 
-0001eba0: 2020 2020 2020 2020 2020 2070 6174 685f             path_
-0001ebb0: 6c65 6e67 7468 735b 756e 636f 6e6e 6563  lengths[unconnec
-0001ebc0: 7465 645f 7061 6972 735d 203d 2073 656c  ted_pairs] = sel
-0001ebd0: 662e 4e0a 0a20 2020 2020 2020 2020 2020  f.N..           
-0001ebe0: 2023 2020 536f 6d65 2070 6f6c 6172 206e   #  Some polar n
-0001ebf0: 6f64 6573 2068 6176 6520 616e 2061 7373  odes have an ass
-0001ec00: 6967 6e65 6420 6469 7374 616e 6365 206f  igned distance o
-0001ec10: 6620 7a65 726f 2074 6f20 616c 6c20 7468  f zero to all th
-0001ec20: 6569 720a 2020 2020 2020 2020 2020 2020  eir.            
-0001ec30: 2320 206e 6569 6768 626f 7273 2e20 5468  #  neighbors. Th
-0001ec40: 6573 6520 6e6f 6465 7320 6765 7420 7a65  ese nodes get ze
-0001ec50: 726f 2067 656f 6772 6170 6869 6361 6c20  ro geographical 
-0001ec60: 636c 6f73 656e 6573 730a 2020 2020 2020  closeness.      
-0001ec70: 2020 2020 2020 2320 2063 656e 7472 616c        #  central
-0001ec80: 6974 792e 0a20 2020 2020 2020 2020 2020  ity..           
-0001ec90: 2070 6174 685f 6c65 6e67 7468 5f73 756d   path_length_sum
-0001eca0: 203d 2070 6174 685f 6c65 6e67 7468 732e   = path_lengths.
-0001ecb0: 7375 6d28 6178 6973 3d31 290a 2020 2020  sum(axis=1).    
-0001ecc0: 2020 2020 2020 2020 4343 5b70 6174 685f          CC[path_
-0001ecd0: 6c65 6e67 7468 5f73 756d 2021 3d20 305d  length_sum != 0]
-0001ece0: 203d 205c 0a20 2020 2020 2020 2020 2020   = \.           
-0001ecf0: 2020 2020 2028 7365 6c66 2e4e 202d 2031       (self.N - 1
-0001ed00: 2920 2f20 7061 7468 5f6c 656e 6774 685f  ) / path_length_
-0001ed10: 7375 6d5b 7061 7468 5f6c 656e 6774 685f  sum[path_length_
-0001ed20: 7375 6d20 213d 2030 5d0a 0a20 2020 2020  sum != 0]..     
-0001ed30: 2020 2020 2020 2023 2020 5265 7665 7273         #  Revers
-0001ed40: 6520 6368 616e 6765 7320 746f 2077 6569  e changes to wei
-0001ed50: 6768 7465 6450 6174 684c 656e 6774 6873  ghtedPathLengths
-0001ed60: 0a20 2020 2020 2020 2020 2020 2070 6174  .            pat
-0001ed70: 685f 6c65 6e67 7468 735b 756e 636f 6e6e  h_lengths[unconn
-0001ed80: 6563 7465 645f 7061 6972 735d 203d 206e  ected_pairs] = n
-0001ed90: 702e 696e 660a 0a20 2020 2020 2020 2020  p.inf..         
-0001eda0: 2020 2072 6574 7572 6e20 4343 0a0a 2020     return CC..  
-0001edb0: 2020 4063 6163 6865 645f 636f 6e73 7428    @cached_const(
-0001edc0: 276e 7369 272c 2027 636c 6f73 656e 6573  'nsi', 'closenes
-0001edd0: 7327 2c20 276e 2e73 2e69 2e20 636c 6f73  s', 'n.s.i. clos
-0001ede0: 656e 6573 7327 290a 2020 2020 6465 6620  eness').    def 
-0001edf0: 6e73 695f 636c 6f73 656e 6573 7328 7365  nsi_closeness(se
-0001ee00: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0001ee10: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
-0001ee20: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
-0001ee30: 7473 206e 2e73 2e69 2e20 636c 6f73 656e  ts n.s.i. closen
-0001ee40: 6573 732e 0a0a 2020 2020 2020 2020 5468  ess...        Th
-0001ee50: 6973 2069 7320 7468 6520 696e 7665 7273  is is the invers
-0001ee60: 6520 6f66 2074 6865 206d 6561 6e20 7368  e of the mean sh
-0001ee70: 6f72 7465 7374 2070 6174 6820 6c65 6e67  ortest path leng
-0001ee80: 7468 2066 726f 6d20 7468 6520 6e6f 6465  th from the node
-0001ee90: 2074 6f0a 2020 2020 2020 2020 616c 6c20   to.        all 
-0001eea0: 6f74 6865 7220 6e6f 6465 732e 2049 6620  other nodes. If 
-0001eeb0: 7468 6520 6e65 7477 6f72 6b20 6973 206e  the network is n
-0001eec0: 6f74 2063 6f6e 6e65 6374 6564 2c20 7468  ot connected, th
-0001eed0: 6520 7265 7375 6c74 2069 7320 302e 0a0a  e result is 0...
-0001eee0: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
-0001eef0: 653a 2a2a 0a0a 2020 2020 2020 2020 3e3e  e:**..        >>
-0001ef00: 3e20 6e65 7420 3d20 4e65 7477 6f72 6b2e  > net = Network.
-0001ef10: 536d 616c 6c54 6573 744e 6574 776f 726b  SmallTestNetwork
-0001ef20: 2829 0a20 2020 2020 2020 203e 3e3e 2072  ().        >>> r
-0001ef30: 286e 6574 2e6e 7369 5f63 6c6f 7365 6e65  (net.nsi_closene
-0001ef40: 7373 2829 290a 2020 2020 2020 2020 4361  ss()).        Ca
-0001ef50: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
-0001ef60: 2063 6c6f 7365 6e65 7373 2e2e 2e0a 2020   closeness....  
-0001ef70: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-0001ef80: 6720 616c 6c20 7368 6f72 7465 7374 2070  g all shortest p
-0001ef90: 6174 6820 6c65 6e67 7468 732e 2e2e 0a20  ath lengths.... 
-0001efa0: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
-0001efb0: 2e37 3639 322c 2030 2e36 3438 362c 2030  .7692, 0.6486, 0
-0001efc0: 2e35 3832 352c 2030 2e36 3431 372c 2030  .5825, 0.6417, 0
-0001efd0: 2e37 3232 392c 2030 2e35 3038 355d 290a  .7229, 0.5085]).
-0001efe0: 2020 2020 2020 2020 3e3e 3e20 7228 6e65          >>> r(ne
-0001eff0: 742e 7370 6c69 7474 6564 5f63 6f70 7928  t.splitted_copy(
-0001f000: 292e 6e73 695f 636c 6f73 656e 6573 7328  ).nsi_closeness(
-0001f010: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
-0001f020: 6c61 7469 6e67 206e 2e73 2e69 2e20 636c  lating n.s.i. cl
-0001f030: 6f73 656e 6573 732e 2e2e 0a20 2020 2020  oseness....     
-0001f040: 2020 2043 616c 6375 6c61 7469 6e67 2061     Calculating a
-0001f050: 6c6c 2073 686f 7274 6573 7420 7061 7468  ll shortest path
-0001f060: 206c 656e 6774 6873 2e2e 2e0a 2020 2020   lengths....    
-0001f070: 2020 2020 6172 7261 7928 5b20 302e 3736      array([ 0.76
-0001f080: 3932 2c20 302e 3634 3836 2c20 302e 3538  92, 0.6486, 0.58
-0001f090: 3235 2c20 302e 3634 3137 2c20 302e 3732  25, 0.6417, 0.72
-0001f0a0: 3239 2c20 302e 3530 3835 2c20 302e 3530  29, 0.5085, 0.50
-0001f0b0: 3835 5d29 0a0a 2020 2020 2020 2020 6173  85])..        as
-0001f0c0: 2063 6f6d 7061 7265 6420 746f 2074 6865   compared to the
-0001f0d0: 2075 6e77 6569 6768 7465 6420 7665 7273   unweighted vers
-0001f0e0: 696f 6e3a 0a0a 2020 2020 2020 2020 3e3e  ion:..        >>
-0001f0f0: 3e20 6e65 7420 3d20 4e65 7477 6f72 6b2e  > net = Network.
-0001f100: 536d 616c 6c54 6573 744e 6574 776f 726b  SmallTestNetwork
-0001f110: 2829 0a20 2020 2020 2020 203e 3e3e 2072  ().        >>> r
-0001f120: 286e 6574 2e63 6c6f 7365 6e65 7373 2829  (net.closeness()
-0001f130: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-0001f140: 6174 696e 6720 636c 6f73 656e 6573 732e  ating closeness.
-0001f150: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-0001f160: 285b 2030 2e37 3134 332c 2030 2e36 3235  ([ 0.7143, 0.625
-0001f170: 202c 2030 2e35 3535 362c 2030 2e36 3235   , 0.5556, 0.625
-0001f180: 202c 2030 2e37 3134 332c 2030 2e34 3534   , 0.7143, 0.454
-0001f190: 355d 290a 2020 2020 2020 2020 3e3e 3e20  5]).        >>> 
-0001f1a0: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
-0001f1b0: 6f70 7928 292e 636c 6f73 656e 6573 7328  opy().closeness(
-0001f1c0: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
-0001f1d0: 6c61 7469 6e67 2063 6c6f 7365 6e65 7373  lating closeness
-0001f1e0: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-0001f1f0: 7928 5b20 302e 3735 202c 2030 2e35 3435  y([ 0.75 , 0.545
-0001f200: 352c 2030 2e35 202c 2030 2e36 202c 2030  5, 0.5 , 0.6 , 0
-0001f210: 2e36 3636 372c 2030 2e35 202c 2030 2e35  .6667, 0.5 , 0.5
-0001f220: 205d 290a 0a20 2020 2020 2020 203a 7274   ])..        :rt
-0001f230: 7970 653a 2031 6420 6e75 6d70 7920 6172  ype: 1d numpy ar
-0001f240: 7261 7920 5b6e 6f64 655d 206f 6620 666c  ray [node] of fl
-0001f250: 6f61 7473 2062 6574 7765 656e 2030 2061  oats between 0 a
-0001f260: 6e64 2031 0a20 2020 2020 2020 2022 2222  nd 1.        """
-0001f270: 0a20 2020 2020 2020 2023 2073 696d 696c  .        # simil
-0001f280: 6172 2074 6f20 6e73 695f 6176 6572 6167  ar to nsi_averag
-0001f290: 655f 7061 7468 5f6c 656e 6774 683a 0a20  e_path_length:. 
-0001f2a0: 2020 2020 2020 206e 7369 5f64 6973 7461         nsi_dista
-0001f2b0: 6e63 6573 203d 2073 656c 662e 7061 7468  nces = self.path
-0001f2c0: 5f6c 656e 6774 6873 2829 202b 206e 702e  _lengths() + np.
-0001f2d0: 6964 656e 7469 7479 2873 656c 662e 4e29  identity(self.N)
-0001f2e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001f2f0: 2873 656c 662e 746f 7461 6c5f 6e6f 6465  (self.total_node
-0001f300: 5f77 6569 6768 740a 2020 2020 2020 2020  _weight.        
-0001f310: 2020 2020 2020 2020 2f20 6e70 2e64 6f74          / np.dot
-0001f320: 286e 7369 5f64 6973 7461 6e63 6573 2c20  (nsi_distances, 
-0001f330: 7365 6c66 2e6e 6f64 655f 7765 6967 6874  self.node_weight
-0001f340: 7329 290a 0a20 2020 2040 6361 6368 6564  s))..    @cached
-0001f350: 5f63 6f6e 7374 2827 6e73 6927 2c20 2768  _const('nsi', 'h
-0001f360: 6172 6d20 636c 6f73 656e 6573 7327 2c20  arm closeness', 
-0001f370: 276e 2e73 2e69 2e20 6861 726d 6f6e 6963  'n.s.i. harmonic
-0001f380: 2063 6c6f 7365 6e65 7373 2729 0a20 2020   closeness').   
-0001f390: 2064 6566 206e 7369 5f68 6172 6d6f 6e69   def nsi_harmoni
-0001f3a0: 635f 636c 6f73 656e 6573 7328 7365 6c66  c_closeness(self
-0001f3b0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0001f3c0: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
-0001f3d0: 6e6f 6465 2c20 7265 7475 726e 2069 7473  node, return its
-0001f3e0: 206e 2e73 2e69 2e20 6861 726d 6f6e 6963   n.s.i. harmonic
-0001f3f0: 2063 6c6f 7365 6e65 7373 2e0a 0a20 2020   closeness...   
-0001f400: 2020 2020 2054 6869 7320 6973 2074 6865       This is the
-0001f410: 2069 6e76 6572 7365 206f 6620 7468 6520   inverse of the 
-0001f420: 6861 726d 6f6e 6963 206d 6561 6e20 7368  harmonic mean sh
-0001f430: 6f72 7465 7374 2070 6174 6820 6c65 6e67  ortest path leng
-0001f440: 7468 2066 726f 6d20 7468 650a 2020 2020  th from the.    
-0001f450: 2020 2020 6e6f 6465 2074 6f20 616c 6c20      node to all 
-0001f460: 6f74 6865 7220 6e6f 6465 732e 2049 6620  other nodes. If 
-0001f470: 7468 6520 6e65 7477 6f72 6b20 6973 206e  the network is n
-0001f480: 6f74 2063 6f6e 6e65 6374 6564 2c20 7468  ot connected, th
-0001f490: 6520 7265 7375 6c74 2069 730a 2020 2020  e result is.    
-0001f4a0: 2020 2020 6e6f 7420 6e65 6365 7373 6172      not necessar
-0001f4b0: 696c 7920 302e 0a0a 2020 2020 2020 2020  ily 0...        
-0001f4c0: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
-0001f4d0: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
-0001f4e0: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
-0001f4f0: 744e 6574 776f 726b 2829 0a20 2020 2020  tNetwork().     
-0001f500: 2020 203e 3e3e 2072 286e 6574 2e6e 7369     >>> r(net.nsi
-0001f510: 5f68 6172 6d6f 6e69 635f 636c 6f73 656e  _harmonic_closen
-0001f520: 6573 7328 2929 0a20 2020 2020 2020 2043  ess()).        C
-0001f530: 616c 6375 6c61 7469 6e67 206e 2e73 2e69  alculating n.s.i
-0001f540: 2e20 6861 726d 6f6e 6963 2063 6c6f 7365  . harmonic close
-0001f550: 6e65 7373 2e2e 2e0a 2020 2020 2020 2020  ness....        
-0001f560: 4361 6c63 756c 6174 696e 6720 616c 6c20  Calculating all 
-0001f570: 7368 6f72 7465 7374 2070 6174 6820 6c65  shortest path le
-0001f580: 6e67 7468 732e 2e2e 0a20 2020 2020 2020  ngths....       
-0001f590: 2061 7272 6179 285b 2030 2e38 3520 2c20   array([ 0.85 , 
-0001f5a0: 302e 3739 3836 2c20 302e 3731 3131 2c20  0.7986, 0.7111, 
-0001f5b0: 302e 3732 3038 2c20 302e 3830 3833 2c20  0.7208, 0.8083, 
-0001f5c0: 302e 3631 3637 5d29 0a20 2020 2020 2020  0.6167]).       
-0001f5d0: 203e 3e3e 2072 286e 6574 2e73 706c 6974   >>> r(net.split
-0001f5e0: 7465 645f 636f 7079 2829 2e6e 7369 5f68  ted_copy().nsi_h
-0001f5f0: 6172 6d6f 6e69 635f 636c 6f73 656e 6573  armonic_closenes
-0001f600: 7328 2929 0a20 2020 2020 2020 2043 616c  s()).        Cal
-0001f610: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
-0001f620: 6861 726d 6f6e 6963 2063 6c6f 7365 6e65  harmonic closene
-0001f630: 7373 2e2e 2e0a 2020 2020 2020 2020 4361  ss....        Ca
-0001f640: 6c63 756c 6174 696e 6720 616c 6c20 7368  lculating all sh
-0001f650: 6f72 7465 7374 2070 6174 6820 6c65 6e67  ortest path leng
-0001f660: 7468 732e 2e2e 0a20 2020 2020 2020 2061  ths....        a
-0001f670: 7272 6179 285b 2030 2e38 3520 2c20 302e  rray([ 0.85 , 0.
-0001f680: 3739 3836 2c20 302e 3731 3131 2c20 302e  7986, 0.7111, 0.
-0001f690: 3732 3038 2c20 302e 3830 3833 2c20 302e  7208, 0.8083, 0.
-0001f6a0: 3631 3637 2c20 302e 3631 3637 5d29 0a0a  6167, 0.6167])..
-0001f6b0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
-0001f6c0: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
-0001f6d0: 6e6f 6465 5d20 6f66 2066 6c6f 6174 7320  node] of floats 
-0001f6e0: 6265 7477 6565 6e20 3020 616e 6420 310a  between 0 and 1.
-0001f6f0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0001f700: 2020 2020 2320 7369 6d69 6c61 7220 746f      # similar to
-0001f710: 206e 7369 5f61 7665 7261 6765 5f70 6174   nsi_average_pat
-0001f720: 685f 6c65 6e67 7468 3a0a 2020 2020 2020  h_length:.      
-0001f730: 2020 6e73 695f 6469 7374 616e 6365 7320    nsi_distances 
-0001f740: 3d20 7365 6c66 2e70 6174 685f 6c65 6e67  = self.path_leng
-0001f750: 7468 7328 2920 2b20 6e70 2e69 6465 6e74  ths() + np.ident
-0001f760: 6974 7928 7365 6c66 2e4e 290a 2020 2020  ity(self.N).    
-0001f770: 2020 2020 7265 7475 726e 2028 6e70 2e64      return (np.d
-0001f780: 6f74 2831 2e30 202f 206e 7369 5f64 6973  ot(1.0 / nsi_dis
-0001f790: 7461 6e63 6573 2c20 7365 6c66 2e6e 6f64  tances, self.nod
-0001f7a0: 655f 7765 6967 6874 7329 0a20 2020 2020  e_weights).     
-0001f7b0: 2020 2020 2020 2020 2020 202f 2073 656c             / sel
-0001f7c0: 662e 746f 7461 6c5f 6e6f 6465 5f77 6569  f.total_node_wei
-0001f7d0: 6768 7429 0a0a 2020 2020 4063 6163 6865  ght)..    @cache
-0001f7e0: 645f 636f 6e73 7428 276e 7369 272c 2027  d_const('nsi', '
-0001f7f0: 6578 7020 636c 6f73 656e 6573 7327 2c0a  exp closeness',.
-0001f800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f810: 2020 276e 2e73 2e69 2e20 6578 706f 6e65    'n.s.i. expone
-0001f820: 6e74 6961 6c20 636c 6f73 656e 6573 7320  ntial closeness 
-0001f830: 6365 6e74 7261 6c69 7479 2729 0a20 2020  centrality').   
-0001f840: 2064 6566 206e 7369 5f65 7870 6f6e 656e   def nsi_exponen
-0001f850: 7469 616c 5f63 6c6f 7365 6e65 7373 2873  tial_closeness(s
-0001f860: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-0001f870: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-0001f880: 6368 206e 6f64 652c 2072 6574 7572 6e20  ch node, return 
-0001f890: 6974 7320 6e2e 732e 692e 2065 7870 6f6e  its n.s.i. expon
-0001f8a0: 656e 7469 616c 2068 6172 6d6f 6e69 6320  ential harmonic 
-0001f8b0: 636c 6f73 656e 6573 732e 0a0a 2020 2020  closeness...    
-0001f8c0: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
-0001f8d0: 6d65 616e 206f 6620 2032 2a2a 282d 2073  mean of  2**(- s
-0001f8e0: 686f 7274 6573 7420 7061 7468 206c 656e  hortest path len
-0001f8f0: 6774 6829 2020 6672 6f6d 2074 6865 0a20  gth)  from the. 
-0001f900: 2020 2020 2020 206e 6f64 6520 746f 2061         node to a
-0001f910: 6c6c 206f 7468 6572 206e 6f64 6573 2e20  ll other nodes. 
-0001f920: 4966 2074 6865 206e 6574 776f 726b 2069  If the network i
-0001f930: 7320 6e6f 7420 636f 6e6e 6563 7465 642c  s not connected,
-0001f940: 2074 6865 2072 6573 756c 7420 6973 0a20   the result is. 
-0001f950: 2020 2020 2020 206e 6f74 206e 6563 6573         not neces
-0001f960: 7361 7269 6c79 2030 2e0a 0a20 2020 2020  sarily 0...     
-0001f970: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
-0001f980: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
-0001f990: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
-0001f9a0: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
-0001f9b0: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
-0001f9c0: 6e73 695f 6578 706f 6e65 6e74 6961 6c5f  nsi_exponential_
-0001f9d0: 636c 6f73 656e 6573 7328 2929 0a20 2020  closeness()).   
-0001f9e0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-0001f9f0: 206e 2e73 2e69 2e20 6578 706f 6e65 6e74   n.s.i. exponent
-0001fa00: 6961 6c20 636c 6f73 656e 6573 7320 6365  ial closeness ce
-0001fa10: 6e74 7261 6c69 7479 2e2e 2e0a 2020 2020  ntrality....    
-0001fa20: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-0001fa30: 616c 6c20 7368 6f72 7465 7374 2070 6174  all shortest pat
-0001fa40: 6820 6c65 6e67 7468 732e 2e2e 0a20 2020  h lengths....   
-0001fa50: 2020 2020 2061 7272 6179 285b 2030 2e34       array([ 0.4
-0001fa60: 3235 202c 2030 2e33 3930 362c 2030 2e33  25 , 0.3906, 0.3
-0001fa70: 3436 392c 2030 2e33 3630 342c 2030 2e34  469, 0.3604, 0.4
-0001fa80: 3034 322c 2030 2e32 3935 385d 290a 2020  042, 0.2958]).  
-0001fa90: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
-0001faa0: 7370 6c69 7474 6564 5f63 6f70 7928 292e  splitted_copy().
-0001fab0: 6e73 695f 6578 706f 6e65 6e74 6961 6c5f  nsi_exponential_
-0001fac0: 636c 6f73 656e 6573 7328 2929 0a20 2020  closeness()).   
-0001fad0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-0001fae0: 206e 2e73 2e69 2e20 6578 706f 6e65 6e74   n.s.i. exponent
-0001faf0: 6961 6c20 636c 6f73 656e 6573 7320 6365  ial closeness ce
-0001fb00: 6e74 7261 6c69 7479 2e2e 2e0a 2020 2020  ntrality....    
-0001fb10: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-0001fb20: 616c 6c20 7368 6f72 7465 7374 2070 6174  all shortest pat
-0001fb30: 6820 6c65 6e67 7468 732e 2e2e 0a20 2020  h lengths....   
-0001fb40: 2020 2020 2061 7272 6179 285b 2030 2e34       array([ 0.4
-0001fb50: 3235 202c 2030 2e33 3930 362c 2030 2e33  25 , 0.3906, 0.3
-0001fb60: 3436 392c 2030 2e33 3630 342c 2030 2e34  469, 0.3604, 0.4
-0001fb70: 3034 322c 2030 2e32 3935 382c 2030 2e32  042, 0.2958, 0.2
-0001fb80: 3935 385d 290a 0a20 2020 2020 2020 203a  958])..        :
-0001fb90: 7274 7970 653a 2031 6420 6e75 6d70 7920  rtype: 1d numpy 
-0001fba0: 6172 7261 7920 5b6e 6f64 655d 206f 6620  array [node] of 
-0001fbb0: 666c 6f61 7473 2062 6574 7765 656e 2030  floats between 0
-0001fbc0: 2061 6e64 2031 0a20 2020 2020 2020 2022   and 1.        "
-0001fbd0: 2222 0a20 2020 2020 2020 2023 2073 696d  "".        # sim
-0001fbe0: 696c 6172 2074 6f20 6e73 695f 6176 6572  ilar to nsi_aver
-0001fbf0: 6167 655f 7061 7468 5f6c 656e 6774 683a  age_path_length:
-0001fc00: 0a20 2020 2020 2020 206e 7369 5f64 6973  .        nsi_dis
-0001fc10: 7461 6e63 6573 203d 2073 656c 662e 7061  tances = self.pa
-0001fc20: 7468 5f6c 656e 6774 6873 2829 202b 206e  th_lengths() + n
-0001fc30: 702e 6964 656e 7469 7479 2873 656c 662e  p.identity(self.
-0001fc40: 4e29 0a20 2020 2020 2020 2072 6574 7572  N).        retur
-0001fc50: 6e20 286e 702e 646f 7428 322e 302a 2a28  n (np.dot(2.0**(
-0001fc60: 2d6e 7369 5f64 6973 7461 6e63 6573 292c  -nsi_distances),
-0001fc70: 2073 656c 662e 6e6f 6465 5f77 6569 6768   self.node_weigh
-0001fc80: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
-0001fc90: 2020 2020 2f20 7365 6c66 2e74 6f74 616c      / self.total
-0001fca0: 5f6e 6f64 655f 7765 6967 6874 290a 0a20  _node_weight).. 
-0001fcb0: 2020 2040 6361 6368 6564 5f63 6f6e 7374     @cached_const
-0001fcc0: 2827 6261 7365 272c 2027 6172 656e 6173  ('base', 'arenas
-0001fcd0: 2062 7477 272c 2027 4172 656e 6173 2d74   btw', 'Arenas-t
-0001fce0: 7970 6520 7261 6e64 6f6d 2077 616c 6b20  ype random walk 
-0001fcf0: 6265 7477 6565 6e6e 6573 7327 290a 2020  betweenness').  
-0001fd00: 2020 6465 6620 6172 656e 6173 5f62 6574    def arenas_bet
-0001fd10: 7765 656e 6e65 7373 2873 656c 6629 3a0a  weenness(self):.
-0001fd20: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0001fd30: 2020 2020 466f 7220 6561 6368 206e 6f64      For each nod
-0001fd40: 652c 2072 6574 7572 6e20 6974 7320 4172  e, return its Ar
-0001fd50: 656e 6173 2d74 7970 6520 7261 6e64 6f6d  enas-type random
-0001fd60: 2077 616c 6b20 6265 7477 6565 6e6e 6573   walk betweennes
-0001fd70: 732e 0a0a 2020 2020 2020 2020 5468 6973  s...        This
-0001fd80: 206d 6561 7375 7265 7320 686f 7720 6f66   measures how of
-0001fd90: 7465 6e20 6120 7261 6e64 6f6d 2077 616c  ten a random wal
-0001fda0: 6b20 7365 6172 6368 2066 6f72 2061 2072  k search for a r
-0001fdb0: 616e 646f 6d20 7461 7267 6574 206e 6f64  andom target nod
-0001fdc0: 650a 2020 2020 2020 2020 6672 6f6d 2061  e.        from a
-0001fdd0: 2072 616e 646f 6d20 736f 7572 6365 206e   random source n
-0001fde0: 6f64 6520 6973 2065 7870 6563 7465 6420  ode is expected 
-0001fdf0: 746f 2070 6173 7320 7468 6973 206e 6f64  to pass this nod
-0001fe00: 652e 2020 2873 6565 0a20 2020 2020 2020  e.  (see.       
-0001fe10: 205b 4172 656e 6173 3230 3033 5d5f 290a   [Arenas2003]_).
-0001fe20: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
-0001fe30: 6c65 3a2a 2a0a 0a20 2020 2020 2020 203e  le:**..        >
-0001fe40: 3e3e 2072 284e 6574 776f 726b 2e53 6d61  >> r(Network.Sma
-0001fe50: 6c6c 5465 7374 4e65 7477 6f72 6b28 292e  llTestNetwork().
-0001fe60: 6172 656e 6173 5f62 6574 7765 656e 6e65  arenas_betweenne
-0001fe70: 7373 2829 290a 2020 2020 2020 2020 4361  ss()).        Ca
-0001fe80: 6c63 756c 6174 696e 6720 4172 656e 6173  lculating Arenas
-0001fe90: 2d74 7970 6520 7261 6e64 6f6d 2077 616c  -type random wal
-0001fea0: 6b20 6265 7477 6565 6e6e 6573 732e 2e2e  k betweenness...
-0001feb0: 0a20 2020 2020 2020 2020 2020 2867 6961  .           (gia
-0001fec0: 6e74 2063 6f6d 706f 6e65 6e74 2073 697a  nt component siz
-0001fed0: 653a 2036 2028 312e 3029 290a 2020 2020  e: 6 (1.0)).    
-0001fee0: 2020 2020 6172 7261 7928 5b20 3530 2e31      array([ 50.1
-0001fef0: 3831 382c 2035 302e 3138 3138 2c20 3333  818, 50.1818, 33
-0001ff00: 2e34 3534 352c 2033 332e 3435 3435 2c20  .4545, 33.4545, 
-0001ff10: 3530 2e31 3831 382c 2031 362e 3732 3733  50.1818, 16.7273
-0001ff20: 5d29 0a0a 2020 2020 2020 2020 3a72 7479  ])..        :rty
-0001ff30: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
-0001ff40: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
-0001ff50: 6174 7320 3e3d 2030 0a20 2020 2020 2020  ats >= 0.       
-0001ff60: 2022 2222 0a20 2020 2020 2020 2074 3020   """.        t0 
-0001ff70: 3d20 7469 6d65 2e74 696d 6528 290a 0a20  = time.time().. 
-0001ff80: 2020 2020 2020 2023 2020 496e 6974 6961         #  Initia
-0001ff90: 6c69 7a65 2074 6865 2061 7272 6179 2074  lize the array t
-0001ffa0: 6f20 686f 6c64 2072 616e 646f 6d20 7761  o hold random wa
-0001ffb0: 6c6b 2062 6574 7765 656e 6e65 7373 0a20  lk betweenness. 
-0001ffc0: 2020 2020 2020 2061 7265 6e61 735f 6265         arenas_be
-0001ffd0: 7477 6565 6e6e 6573 7320 3d20 6e70 2e7a  tweenness = np.z
-0001ffe0: 6572 6f73 2873 656c 662e 4e29 0a0a 2020  eros(self.N)..  
-0001fff0: 2020 2020 2020 2320 2052 616e 646f 6d20        #  Random 
-00020000: 7761 6c6b 2062 6574 7765 656e 6e65 7373  walk betweenness
-00020010: 2068 6173 2074 6f20 6265 2063 616c 6375   has to be calcu
-00020020: 6c61 7465 6420 666f 7220 6561 6368 2063  lated for each c
-00020030: 6f6d 706f 6e65 6e74 0a20 2020 2020 2020  omponent.       
-00020040: 2023 2020 7365 7061 7261 7465 6c79 2054   #  separately T
-00020050: 6865 7265 666f 7265 2067 6574 2064 6966  herefore get dif
-00020060: 6665 7265 6e74 2063 6f6d 706f 6e65 6e74  ferent component
-00020070: 7320 6f66 2074 6865 2067 7261 7068 2066  s of the graph f
-00020080: 6972 7374 0a20 2020 2020 2020 2063 6f6d  irst.        com
-00020090: 706f 6e65 6e74 7320 3d20 7365 6c66 2e67  ponents = self.g
-000200a0: 7261 7068 2e63 6c75 7374 6572 7328 290a  raph.clusters().
-000200b0: 0a20 2020 2020 2020 2023 2020 5072 696e  .        #  Prin
-000200c0: 7420 6769 616e 7420 636f 6d70 6f6e 656e  t giant componen
-000200d0: 7420 7369 7a65 0a20 2020 2020 2020 2069  t size.        i
-000200e0: 6620 7365 6c66 2e73 696c 656e 6365 5f6c  f self.silence_l
-000200f0: 6576 656c 203c 3d20 313a 0a20 2020 2020  evel <= 1:.     
-00020100: 2020 2020 2020 2070 7269 6e74 2822 2020         print("  
-00020110: 2028 6769 616e 7420 636f 6d70 6f6e 656e   (giant componen
-00020120: 7420 7369 7a65 3a20 220a 2020 2020 2020  t size: ".      
-00020130: 2020 2020 2020 2020 2020 2020 2b20 7374              + st
-00020140: 7228 636f 6d70 6f6e 656e 7473 2e67 6961  r(components.gia
-00020150: 6e74 2829 2e76 636f 756e 7428 2929 202b  nt().vcount()) +
-00020160: 2022 2028 220a 2020 2020 2020 2020 2020   " (".          
-00020170: 2020 2020 2020 2020 2b20 7374 7228 636f          + str(co
-00020180: 6d70 6f6e 656e 7473 2e67 6961 6e74 2829  mponents.giant()
-00020190: 2e76 636f 756e 7428 290a 2020 2020 2020  .vcount().      
-000201a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000201b0: 2020 2f20 666c 6f61 7428 7365 6c66 2e67    / float(self.g
-000201c0: 7261 7068 2e76 636f 756e 7428 2929 2920  raph.vcount())) 
-000201d0: 2b20 2229 2922 290a 0a20 2020 2020 2020  + "))")..       
-000201e0: 2066 6f72 2063 2c20 636f 6d70 2069 6e20   for c, comp in 
-000201f0: 656e 756d 6572 6174 6528 636f 6d70 6f6e  enumerate(compon
-00020200: 656e 7473 293a 0a20 2020 2020 2020 2020  ents):.         
-00020210: 2020 2023 2020 4966 2074 6865 2063 6f6d     #  If the com
-00020220: 706f 6e65 6e74 2068 6173 2073 697a 6520  ponent has size 
-00020230: 312c 2073 6574 2072 616e 646f 6d20 7761  1, set random wa
-00020240: 6c6b 2062 6574 7765 656e 6e65 7373 2074  lk betweenness t
-00020250: 6f20 7a65 726f 0a20 2020 2020 2020 2020  o zero.         
-00020260: 2020 2069 6620 6c65 6e28 636f 6d70 2920     if len(comp) 
-00020270: 3d3d 2031 3a0a 2020 2020 2020 2020 2020  == 1:.          
-00020280: 2020 2020 2020 6172 656e 6173 5f62 6574        arenas_bet
-00020290: 7765 656e 6e65 7373 5b63 6f6d 705b 305d  weenness[comp[0]
-000202a0: 5d20 3d20 300a 2020 2020 2020 2020 2020  ] = 0.          
-000202b0: 2020 2320 2046 6f72 206c 6172 6765 7220    #  For larger 
-000202c0: 636f 6d70 6f6e 656e 7473 2c20 636f 6e74  components, cont
-000202d0: 696e 7565 2077 6974 6820 7468 6520 6361  inue with the ca
-000202e0: 6c63 756c 6174 696f 6e0a 2020 2020 2020  lculation.      
-000202f0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00020300: 2020 2020 2020 2020 2020 2020 2320 2047              #  G
-00020310: 6574 2074 6865 2073 7562 6772 6170 6820  et the subgraph 
-00020320: 636f 7272 6573 706f 6e64 696e 6720 746f  corresponding to
-00020330: 2063 6f6d 706f 6e65 6e74 2069 0a20 2020   component i.   
-00020340: 2020 2020 2020 2020 2020 2020 2073 7562               sub
-00020350: 6772 6170 6820 3d20 636f 6d70 6f6e 656e  graph = componen
-00020360: 7473 2e73 7562 6772 6170 6828 6329 0a0a  ts.subgraph(c)..
-00020370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020380: 2320 2047 6574 2074 6865 2073 7562 6772  #  Get the subgr
-00020390: 6170 6820 4120 6d61 7472 6978 0a20 2020  aph A matrix.   
-000203a0: 2020 2020 2020 2020 2020 2020 2041 203d               A =
-000203b0: 206e 702e 6172 7261 7928 7375 6267 7261   np.array(subgra
-000203c0: 7068 2e67 6574 5f61 646a 6163 656e 6379  ph.get_adjacency
-000203d0: 2874 7970 653d 3229 2e64 6174 6129 0a0a  (type=2).data)..
-000203e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000203f0: 2320 2047 656e 6572 6174 6520 6120 4e65  #  Generate a Ne
-00020400: 7477 6f72 6b20 6f62 6a65 6374 2072 6570  twork object rep
-00020410: 7265 7365 6e74 696e 6720 7468 6520 7375  resenting the su
-00020420: 6267 7261 7068 0a20 2020 2020 2020 2020  bgraph.         
-00020430: 2020 2020 2020 2073 7562 6e65 7477 6f72         subnetwor
-00020440: 6b20 3d20 4e65 7477 6f72 6b28 6164 6a61  k = Network(adja
-00020450: 6365 6e63 793d 412c 2064 6972 6563 7465  cency=A, directe
-00020460: 643d 4661 6c73 6529 0a0a 2020 2020 2020  d=False)..      
-00020470: 2020 2020 2020 2020 2020 2320 2047 6574            #  Get
-00020480: 2074 6865 206e 756d 6265 7220 6f66 206e   the number of n
-00020490: 6f64 6573 206f 6620 7468 6520 7375 6267  odes of the subg
-000204a0: 7261 7068 2028 7468 6520 636f 6d70 6f6e  raph (the compon
-000204b0: 656e 7420 7369 7a65 290a 2020 2020 2020  ent size).      
-000204c0: 2020 2020 2020 2020 2020 4e20 3d20 7375            N = su
-000204d0: 626e 6574 776f 726b 2e4e 0a0a 2020 2020  bnetwork.N..    
-000204e0: 2020 2020 2020 2020 2020 2020 2320 2049              #  I
-000204f0: 6e69 7469 616c 697a 6520 7468 6520 5257  nitialize the RW
-00020500: 4220 6172 7261 790a 2020 2020 2020 2020  B array.        
-00020510: 2020 2020 2020 2020 636f 6d70 6f6e 656e          componen
-00020520: 745f 6265 7477 6565 6e6e 6573 7320 3d20  t_betweenness = 
-00020530: 6e70 2e7a 6572 6f73 284e 290a 0a20 2020  np.zeros(N)..   
-00020540: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-00020550: 4765 7420 7468 6520 7375 626e 6574 776f  Get the subnetwo
-00020560: 726b 7320 6465 6772 6565 2073 6571 7565  rks degree seque
-00020570: 6e63 650a 2020 2020 2020 2020 2020 2020  nce.            
-00020580: 2020 2020 6b20 3d20 7375 626e 6574 776f      k = subnetwo
-00020590: 726b 2e64 6567 7265 6528 292e 6173 7479  rk.degree().asty
-000205a0: 7065 2827 666c 6f61 7436 3427 290a 0a20  pe('float64').. 
-000205b0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000205c0: 2020 436c 6561 6e20 7570 0a20 2020 2020    Clean up.     
-000205d0: 2020 2020 2020 2020 2020 2064 656c 2073             del s
-000205e0: 7562 6772 6170 682c 2073 7562 6e65 7477  ubgraph, subnetw
-000205f0: 6f72 6b0a 0a20 2020 2020 2020 2020 2020  ork..           
-00020600: 2020 2020 2023 2020 4765 7420 7468 6520       #  Get the 
-00020610: 5020 7468 6174 2069 7320 6d6f 6469 6669  P that is modifi
-00020620: 6564 2061 6e64 2069 6e76 6572 7465 6420  ed and inverted 
-00020630: 6279 2074 6865 2043 2b2b 2063 6f64 650a  by the C++ code.
-00020640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020650: 5020 3d20 6e70 2e64 6f74 286e 702e 6469  P = np.dot(np.di
-00020660: 6167 2831 202f 206b 292c 2041 290a 0a20  ag(1 / k), A).. 
-00020670: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00020680: 6f72 2069 2069 6e20 7261 6e67 6528 4e29  or i in range(N)
-00020690: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000206a0: 2020 2020 2020 2320 2053 746f 7265 2074        #  Store t
-000206b0: 6865 206b 7468 2072 6f77 206f 6620 7468  he kth row of th
-000206c0: 6520 500a 2020 2020 2020 2020 2020 2020  e P.            
-000206d0: 2020 2020 2020 2020 726f 775f 6920 3d20          row_i = 
-000206e0: 6e70 2e63 6f70 7928 505b 692c 203a 5d29  np.copy(P[i, :])
-000206f0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00020700: 2020 2020 2020 2320 2053 6574 2074 6865        #  Set the
-00020710: 2069 2d74 6820 726f 7720 6f66 2074 6865   i-th row of the
-00020720: 2050 2074 6f20 7a65 726f 2074 6f20 6163   P to zero to ac
-00020730: 636f 756e 7420 666f 7220 7468 650a 2020  count for the.  
-00020740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020750: 2020 2320 2061 6273 6f72 7074 696f 6e20    #  absorption 
-00020760: 6f66 2072 616e 646f 6d20 7761 6c6b 6572  of random walker
-00020770: 7320 6174 2074 6865 6972 2064 6573 7469  s at their desti
-00020780: 6e61 7469 6f6e 0a20 2020 2020 2020 2020  nation.         
-00020790: 2020 2020 2020 2020 2020 2050 5b69 2c20             P[i, 
-000207a0: 3a5d 203d 2030 0a0a 2020 2020 2020 2020  :] = 0..        
-000207b0: 2020 2020 2020 2020 2020 2020 2320 2043              #  C
-000207c0: 616c 6375 6c61 7465 2074 6865 2062 5e69  alculate the b^i
-000207d0: 206d 6174 7269 780a 2020 2020 2020 2020   matrix.        
-000207e0: 2020 2020 2020 2020 2020 2020 4220 3d20              B = 
-000207f0: 6e70 2e64 6f74 286e 702e 6c69 6e61 6c67  np.dot(np.linalg
-00020800: 2e69 6e76 286e 702e 6964 656e 7469 7479  .inv(np.identity
-00020810: 284e 2920 2d20 5029 2c20 5029 0a0a 2020  (N) - P), P)..  
-00020820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020830: 2020 2320 2050 6572 666f 726d 2074 6865    #  Perform the
-00020840: 2073 756d 6d61 7469 6f6e 206f 7665 7220   summation over 
-00020850: 736f 7572 6365 206e 6f64 6520 630a 2020  source node c.  
-00020860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020870: 2020 636f 6d70 6f6e 656e 745f 6265 7477    component_betw
-00020880: 6565 6e6e 6573 7320 2b3d 2042 2e73 756d  eenness += B.sum
-00020890: 2861 7869 733d 3029 0a0a 2020 2020 2020  (axis=0)..      
-000208a0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000208b0: 2052 6573 746f 7265 2074 6865 2050 0a20   Restore the P. 
-000208c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000208d0: 2020 2050 5b69 2c20 3a5d 203d 2072 6f77     P[i, :] = row
-000208e0: 5f69 0a0a 2020 2020 2020 2020 2020 2020  _i..            
-000208f0: 2020 2020 2320 204e 6f72 6d61 6c69 7a65      #  Normalize
-00020900: 2052 5742 2062 7920 636f 6d70 6f6e 656e   RWB by componen
-00020910: 7420 7369 7a65 0a20 2020 2020 2020 2020  t size.         
-00020920: 2020 2020 2020 2023 2063 6f6d 706f 6e65         # compone
-00020930: 6e74 5f62 6574 7765 656e 6e65 7373 202a  nt_betweenness *
-00020940: 3d20 4e0a 0a20 2020 2020 2020 2020 2020  = N..           
-00020950: 2020 2020 2023 2020 4765 7420 7468 6520       #  Get the 
-00020960: 6c69 7374 206f 6620 7665 7274 6578 206e  list of vertex n
-00020970: 756d 6265 7273 2069 6e20 7468 6520 7375  umbers in the su
-00020980: 6267 7261 7068 0a20 2020 2020 2020 2020  bgraph.         
-00020990: 2020 2020 2020 206e 6f64 6573 203d 2063         nodes = c
-000209a0: 6f6d 700a 0a20 2020 2020 2020 2020 2020  omp..           
-000209b0: 2020 2020 2023 2020 436f 7079 2072 6573       #  Copy res
-000209c0: 756c 7473 2069 6e74 6f20 7261 6e64 6f6d  ults into random
-000209d0: 5761 6c6b 4265 7477 6565 6e6e 6573 7341  WalkBetweennessA
-000209e0: 7272 6179 2061 7420 7468 6520 636f 7272  rray at the corr
-000209f0: 6563 740a 2020 2020 2020 2020 2020 2020  ect.            
-00020a00: 2020 2020 2320 2070 6f73 6974 696f 6e73      #  positions
-00020a10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00020a20: 2066 6f72 206a 2c20 6e6f 6465 2069 6e20   for j, node in 
-00020a30: 656e 756d 6572 6174 6528 6e6f 6465 7329  enumerate(nodes)
-00020a40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00020a50: 2020 2020 2020 6172 656e 6173 5f62 6574        arenas_bet
-00020a60: 7765 656e 6e65 7373 5b6e 6f64 655d 203d  weenness[node] =
-00020a70: 2063 6f6d 706f 6e65 6e74 5f62 6574 7765   component_betwe
-00020a80: 656e 6e65 7373 5b6a 5d0a 0a20 2020 2020  enness[j]..     
-00020a90: 2020 2069 6620 7365 6c66 2e73 696c 656e     if self.silen
-00020aa0: 6365 5f6c 6576 656c 203c 3d20 303a 0a20  ce_level <= 0:. 
-00020ab0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00020ac0: 2822 2e2e 2e74 6f6f 6b22 2c20 7469 6d65  ("...took", time
-00020ad0: 2e74 696d 6528 292d 7430 2c20 2273 6563  .time()-t0, "sec
-00020ae0: 6f6e 6473 2229 0a0a 2020 2020 2020 2020  onds")..        
-00020af0: 7265 7475 726e 2061 7265 6e61 735f 6265  return arenas_be
-00020b00: 7477 6565 6e6e 6573 730a 0a20 2020 2023  tweenness..    #
-00020b10: 2054 4f44 4f3a 2072 656d 6f76 6520 7468   TODO: remove th
-00020b20: 6973 2073 6c6f 7720 7665 7273 696f 6e20  is slow version 
-00020b30: 6166 7465 7220 7265 6772 6573 7369 6f6e  after regression
-00020b40: 2074 6573 743a 0a20 2020 2064 6566 205f   test:.    def _
-00020b50: 6172 656e 6173 5f62 6574 7765 656e 6e65  arenas_betweenne
-00020b60: 7373 5f73 6c6f 7728 7365 6c66 293a 0a20  ss_slow(self):. 
-00020b70: 2020 2020 2020 2070 7269 6e74 2822 5741         print("WA
-00020b80: 524e 494e 473a 205f 6172 656e 6173 5f62  RNING: _arenas_b
-00020b90: 6574 7765 656e 6e65 7373 5f73 6c6f 7728  etweenness_slow(
-00020ba0: 2920 6973 2064 6570 7265 6361 7465 6421  ) is deprecated!
-00020bb0: 2229 0a0a 2020 2020 2020 2020 7430 203d  ")..        t0 =
-00020bc0: 2074 696d 652e 7469 6d65 2829 0a0a 2020   time.time()..  
-00020bd0: 2020 2020 2020 2320 2049 6e69 7469 616c        #  Initial
-00020be0: 697a 6520 7468 6520 6172 7261 7920 746f  ize the array to
-00020bf0: 2068 6f6c 6420 7261 6e64 6f6d 2077 616c   hold random wal
-00020c00: 6b20 6265 7477 6565 6e6e 6573 730a 2020  k betweenness.  
-00020c10: 2020 2020 2020 6177 5261 6e64 6f6d 5761        awRandomWa
-00020c20: 6c6b 4265 7477 6565 6e6e 6573 7320 3d20  lkBetweenness = 
-00020c30: 6e70 2e7a 6572 6f73 2873 656c 662e 4e29  np.zeros(self.N)
-00020c40: 0a0a 2020 2020 2020 2020 2320 2052 616e  ..        #  Ran
-00020c50: 646f 6d20 7761 6c6b 2062 6574 7765 656e  dom walk between
-00020c60: 6e65 7373 2068 6173 2074 6f20 6265 2063  ness has to be c
-00020c70: 616c 6375 6c61 7465 6420 666f 7220 6561  alculated for ea
-00020c80: 6368 2063 6f6d 706f 6e65 6e74 0a20 2020  ch component.   
-00020c90: 2020 2020 2023 2020 7365 7061 7261 7465       #  separate
-00020ca0: 6c79 2e20 5468 6572 6566 6f72 6520 6765  ly. Therefore ge
-00020cb0: 7420 6469 6666 6572 656e 7420 636f 6d70  t different comp
-00020cc0: 6f6e 656e 7473 206f 6620 7468 6520 6772  onents of the gr
-00020cd0: 6170 6820 6669 7273 740a 2020 2020 2020  aph first.      
-00020ce0: 2020 636f 6d70 6f6e 656e 7473 203d 2073    components = s
-00020cf0: 656c 662e 6772 6170 682e 636c 7573 7465  elf.graph.cluste
-00020d00: 7273 2829 0a0a 2020 2020 2020 2020 2320  rs()..        # 
-00020d10: 2050 7269 6e74 2067 6961 6e74 2063 6f6d   Print giant com
-00020d20: 706f 6e65 6e74 2073 697a 650a 2020 2020  ponent size.    
-00020d30: 2020 2020 6966 2073 656c 662e 7369 6c65      if self.sile
-00020d40: 6e63 655f 6c65 7665 6c20 3c3d 2031 3a0a  nce_level <= 1:.
-00020d50: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00020d60: 7428 2220 2020 2867 6961 6e74 2063 6f6d  t("   (giant com
-00020d70: 706f 6e65 6e74 2073 697a 653a 2022 0a20  ponent size: ". 
-00020d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020d90: 202b 2073 7472 2863 6f6d 706f 6e65 6e74   + str(component
-00020da0: 732e 6769 616e 7428 292e 7663 6f75 6e74  s.giant().vcount
-00020db0: 2829 2920 2b20 2220 2822 0a20 2020 2020  ()) + " (".     
-00020dc0: 2020 2020 2020 2020 2020 2020 202b 2073               + s
-00020dd0: 7472 2863 6f6d 706f 6e65 6e74 732e 6769  tr(components.gi
-00020de0: 616e 7428 292e 7663 6f75 6e74 2829 0a20  ant().vcount(). 
-00020df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020e00: 2020 2020 2020 202f 2066 6c6f 6174 2873         / float(s
-00020e10: 656c 662e 6772 6170 682e 7663 6f75 6e74  elf.graph.vcount
-00020e20: 2829 2929 202b 2022 2929 2229 0a0a 2020  ())) + "))")..  
-00020e30: 2020 2020 2020 666f 7220 692c 2063 6f6d        for i, com
-00020e40: 7020 696e 2065 6e75 6d65 7261 7465 2863  p in enumerate(c
-00020e50: 6f6d 706f 6e65 6e74 7329 3a0a 2020 2020  omponents):.    
-00020e60: 2020 2020 2020 2020 2320 2049 6620 7468          #  If th
-00020e70: 6520 636f 6d70 6f6e 656e 7420 6861 7320  e component has 
-00020e80: 7369 7a65 2031 2c20 7365 7420 7261 6e64  size 1, set rand
-00020e90: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
-00020ea0: 6573 7320 746f 207a 6572 6f0a 2020 2020  ess to zero.    
-00020eb0: 2020 2020 2020 2020 6966 206c 656e 2863          if len(c
-00020ec0: 6f6d 7029 203d 3d20 313a 0a20 2020 2020  omp) == 1:.     
-00020ed0: 2020 2020 2020 2020 2020 2061 7752 616e             awRan
-00020ee0: 646f 6d57 616c 6b42 6574 7765 656e 6e65  domWalkBetweenne
-00020ef0: 7373 5b63 6f6d 705b 305d 5d20 3d20 300a  ss[comp[0]] = 0.
-00020f00: 2020 2020 2020 2020 2020 2020 2320 2046              #  F
-00020f10: 6f72 206c 6172 6765 7220 636f 6d70 6f6e  or larger compon
-00020f20: 656e 7473 2c20 636f 6e74 696e 7565 2077  ents, continue w
-00020f30: 6974 6820 7468 6520 6361 6c63 756c 6174  ith the calculat
-00020f40: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-00020f50: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00020f60: 2020 2020 2020 2320 2047 6574 2074 6865        #  Get the
-00020f70: 2073 7562 6772 6170 6820 636f 7272 6573   subgraph corres
-00020f80: 706f 6e64 696e 6720 746f 2063 6f6d 706f  ponding to compo
-00020f90: 6e65 6e74 2069 0a20 2020 2020 2020 2020  nent i.         
-00020fa0: 2020 2020 2020 2073 7562 6772 6170 6820         subgraph 
-00020fb0: 3d20 636f 6d70 6f6e 656e 7473 2e73 7562  = components.sub
-00020fc0: 6772 6170 6828 6929 0a0a 2020 2020 2020  graph(i)..      
-00020fd0: 2020 2020 2020 2020 2020 2320 2047 6574            #  Get
-00020fe0: 2074 6865 2073 7562 6772 6170 6820 6164   the subgraph ad
-00020ff0: 6a61 6365 6e63 7920 6d61 7472 6978 0a20  jacency matrix. 
-00021000: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-00021010: 646a 6163 656e 6379 203d 206e 702e 6172  djacency = np.ar
-00021020: 7261 7928 7375 6267 7261 7068 2e67 6574  ray(subgraph.get
-00021030: 5f61 646a 6163 656e 6379 2874 7970 653d  _adjacency(type=
-00021040: 3229 2e64 6174 6129 0a0a 2020 2020 2020  2).data)..      
-00021050: 2020 2020 2020 2020 2020 2320 2047 6574            #  Get
-00021060: 2074 6865 206c 6973 7420 6f66 2076 6572   the list of ver
-00021070: 7465 7820 6e75 6d62 6572 7320 696e 2074  tex numbers in t
-00021080: 6865 2073 7562 6772 6170 680a 2020 2020  he subgraph.    
-00021090: 2020 2020 2020 2020 2020 2020 7665 7274              vert
-000210a0: 6578 4c69 7374 203d 2063 6f6d 700a 0a20  exList = comp.. 
-000210b0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000210c0: 2045 7874 7261 6374 2063 6f72 7265 7370   Extract corresp
-000210d0: 6f6e 6469 6e67 2061 7265 6120 7765 6967  onding area weig
-000210e0: 6874 2076 6563 746f 723a 0a20 2020 2020  ht vector:.     
-000210f0: 2020 2020 2020 2020 2020 2061 7720 3d20             aw = 
-00021100: 6e70 2e7a 6572 6f73 286c 656e 2876 6572  np.zeros(len(ver
-00021110: 7465 784c 6973 7429 290a 2020 2020 2020  texList)).      
-00021120: 2020 2020 2020 2020 2020 666f 7220 6a2c            for j,
-00021130: 2076 7320 696e 2065 6e75 6d65 7261 7465   vs in enumerate
-00021140: 2876 6572 7465 784c 6973 7429 3a0a 2020  (vertexList):.  
-00021150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021160: 2020 6177 5b6a 5d20 3d20 7365 6c66 2e6e    aw[j] = self.n
-00021170: 6f64 655f 7765 6967 6874 735b 7673 5d0a  ode_weights[vs].
-00021180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021190: 2023 2020 4765 6e65 7261 7465 2061 204e   #  Generate a N
-000211a0: 6574 776f 726b 206f 626a 6563 7420 7265  etwork object re
-000211b0: 7072 6573 656e 7469 6e67 2074 6865 2073  presenting the s
-000211c0: 7562 6772 6170 680a 2020 2020 2020 2020  ubgraph.        
-000211d0: 2020 2020 2020 2020 7375 626e 6574 776f          subnetwo
-000211e0: 726b 203d 204e 6574 776f 726b 2861 646a  rk = Network(adj
-000211f0: 6163 656e 6379 2c20 6469 7265 6374 6564  acency, directed
-00021200: 3d46 616c 7365 290a 0a20 2020 2020 2020  =False)..       
-00021210: 2020 2020 2020 2020 2023 2020 4765 7420           #  Get 
-00021220: 7468 6520 6e75 6d62 6572 206f 6620 6e6f  the number of no
-00021230: 6465 7320 6f66 2074 6865 2073 7562 6772  des of the subgr
-00021240: 6170 6820 2874 6865 2063 6f6d 706f 6e65  aph (the compone
-00021250: 6e74 2073 697a 6529 0a20 2020 2020 2020  nt size).       
-00021260: 2020 2020 2020 2020 206e 4e6f 6465 7320           nNodes 
-00021270: 3d20 7375 626e 6574 776f 726b 2e4e 0a0a  = subnetwork.N..
-00021280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021290: 2320 2049 6e69 7469 616c 697a 6520 7468  #  Initialize th
-000212a0: 6520 5257 4220 6172 7261 790a 2020 2020  e RWB array.    
-000212b0: 2020 2020 2020 2020 2020 2020 7277 6220              rwb 
-000212c0: 3d20 6e70 2e7a 6572 6f73 286e 4e6f 6465  = np.zeros(nNode
-000212d0: 7329 0a0a 2020 2020 2020 2020 2020 2020  s)..            
-000212e0: 2020 2020 2320 2047 6574 2074 6865 2073      #  Get the s
-000212f0: 7562 6e65 7477 6f72 6b73 2064 6567 7265  ubnetworks degre
-00021300: 6520 7365 7175 656e 6365 0a20 2020 2020  e sequence.     
-00021310: 2020 2020 2020 2020 2020 2061 7744 6567             awDeg
-00021320: 7265 6553 6571 7565 6e63 6520 3d20 7375  reeSequence = su
-00021330: 626e 6574 776f 726b 2e6e 7369 5f64 6567  bnetwork.nsi_deg
-00021340: 7265 6528 290a 0a20 2020 2020 2020 2020  ree()..         
-00021350: 2020 2020 2020 2023 2020 436c 6561 6e20         #  Clean 
-00021360: 7570 0a20 2020 2020 2020 2020 2020 2020  up.             
-00021370: 2020 2064 656c 2073 7562 6772 6170 682c     del subgraph,
-00021380: 2073 7562 6e65 7477 6f72 6b0a 0a20 2020   subnetwork..   
-00021390: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-000213a0: 4765 7420 7468 6520 704d 6174 7269 7820  Get the pMatrix 
-000213b0: 7468 6174 2069 7320 6d6f 6469 6669 6564  that is modified
-000213c0: 2061 6e64 2069 6e76 6572 7465 640a 2020   and inverted.  
-000213d0: 2020 2020 2020 2020 2020 2020 2020 4964                Id
-000213e0: 656e 7469 7479 203d 206e 702e 6964 656e  entity = np.iden
-000213f0: 7469 7479 286e 4e6f 6465 7329 0a20 2020  tity(nNodes).   
-00021400: 2020 2020 2020 2020 2020 2020 2041 7020               Ap 
-00021410: 3d20 6164 6a61 6365 6e63 7920 2b20 4964  = adjacency + Id
-00021420: 656e 7469 7479 0a20 2020 2020 2020 2020  entity.         
-00021430: 2020 2020 2020 2070 4d61 7472 6978 203d         pMatrix =
-00021440: 206e 702e 6469 6167 2831 2f61 7744 6567   np.diag(1/awDeg
-00021450: 7265 6553 6571 7565 6e63 6529 2e64 6f74  reeSequence).dot
-00021460: 2841 7029 2e64 6f74 286e 702e 6469 6167  (Ap).dot(np.diag
-00021470: 2861 7729 290a 0a20 2020 2020 2020 2020  (aw))..         
-00021480: 2020 2020 2020 2066 6f72 206b 2069 6e20         for k in 
-00021490: 7261 6e67 6528 6e4e 6f64 6573 293a 0a20  range(nNodes):. 
-000214a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000214b0: 2020 2023 2020 466f 7220 6b20 616e 6420     #  For k and 
-000214c0: 6561 6368 206e 6569 6768 626f 7572 206f  each neighbour o
-000214d0: 6620 6974 2c20 7365 7420 7468 6520 636f  f it, set the co
-000214e0: 7272 6573 706f 6e64 696e 670a 2020 2020  rresponding.    
-000214f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021500: 2320 2072 6f77 206f 6620 7468 6520 704d  #  row of the pM
-00021510: 6174 7269 7820 746f 207a 6572 6f20 746f  atrix to zero to
-00021520: 2061 6363 6f75 6e74 2066 6f72 2074 6865   account for the
-00021530: 2061 6273 6f72 7074 696f 6e0a 2020 2020   absorption.    
-00021540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021550: 2320 206f 6620 7261 6e64 6f6d 2077 616c  #  of random wal
-00021560: 6b65 7273 2061 7420 7468 6569 7220 6465  kers at their de
-00021570: 7374 696e 6174 696f 6e0a 2020 2020 2020  stination.      
-00021580: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
-00021590: 736b 203d 2031 2d41 705b 6b2c 203a 5d0a  sk = 1-Ap[k, :].
+00012b30: 2829 2e6d 6178 5f6e 6569 6768 626f 7273  ().max_neighbors
+00012b40: 5f64 6567 7265 6528 2929 0a20 2020 2020  _degree()).     
+00012b50: 2020 2043 616c 6375 6c61 7469 6e67 206d     Calculating m
+00012b60: 6178 696d 756d 206e 6569 6768 626f 7572  aximum neighbour
+00012b70: 7327 2064 6567 7265 652e 2e2e 0a20 2020  s' degree....   
+00012b80: 2020 2020 205b 3320 3320 3320 3320 3320       [3 3 3 3 3 
+00012b90: 335d 0a0a 2020 2020 2020 2020 3a72 7479  3]..        :rty
+00012ba0: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
+00012bb0: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
+00012bc0: 6174 7320 3e3d 2030 0a20 2020 2020 2020  ats >= 0.       
+00012bd0: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+00012be0: 7365 6c66 2e64 6972 6563 7465 643a 0a20  self.directed:. 
+00012bf0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00012c00: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
+00012c10: 7272 6f72 2822 4e6f 7420 696d 706c 656d  rror("Not implem
+00012c20: 656e 7465 6420 666f 7220 6469 7265 6374  ented for direct
+00012c30: 6564 206e 6574 776f 726b 732e 2229 0a0a  ed networks.")..
+00012c40: 2020 2020 2020 2020 7365 6c66 2e6e 7369          self.nsi
+00012c50: 5f64 6567 7265 6528 290a 2020 2020 2020  _degree().      
+00012c60: 2020 2320 6d61 7472 6978 2077 6974 6820    # matrix with 
+00012c70: 7468 6520 6465 6772 6565 7320 6f66 206e  the degrees of n
+00012c80: 6f64 6573 2720 6e65 6967 6862 6f75 7273  odes' neighbours
+00012c90: 2061 7320 726f 7773 0a20 2020 2020 2020   as rows.       
+00012ca0: 2072 6574 7572 6e20 2873 656c 662e 7370   return (self.sp
+00012cb0: 5f41 706c 7573 2829 202a 2073 656c 662e  _Aplus() * self.
+00012cc0: 7370 5f6e 7369 5f64 6961 675f 6b28 2929  sp_nsi_diag_k())
+00012cd0: 2e6d 6178 2861 7869 733d 3129 2e54 2e41  .max(axis=1).T.A
+00012ce0: 5b30 5d0a 2020 2020 2020 2020 2320 544f  [0].        # TO
+00012cf0: 444f 3a20 656e 6162 6c65 2063 6f72 7265  DO: enable corre
+00012d00: 6374 696f 6e20 6279 2074 7970 6963 616c  ction by typical
+00012d10: 5f77 6569 6768 740a 0a20 2020 2023 0a20  _weight..    #. 
+00012d20: 2020 2023 2020 204d 6561 7375 7265 7320     #   Measures 
+00012d30: 6f66 2063 6c75 7374 6572 696e 672c 2074  of clustering, t
+00012d40: 7261 6e73 6974 6976 6974 7920 616e 6420  ransitivity and 
+00012d50: 636c 6971 7569 7368 6e65 7373 0a20 2020  cliquishness.   
+00012d60: 2023 0a0a 2020 2020 4043 6163 6865 642e   #..    @Cached.
+00012d70: 6d65 7468 6f64 286e 616d 653d 226c 6f63  method(name="loc
+00012d80: 616c 2063 6c75 7374 6572 696e 6720 636f  al clustering co
+00012d90: 6566 6669 6369 656e 7473 2229 0a20 2020  efficients").   
+00012da0: 2064 6566 206c 6f63 616c 5f63 6c75 7374   def local_clust
+00012db0: 6572 696e 6728 7365 6c66 293a 0a20 2020  ering(self):.   
+00012dc0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00012dd0: 2046 6f72 2065 6163 6820 6e6f 6465 2c20   For each node, 
+00012de0: 7265 7475 726e 2069 7473 2028 5761 7474  return its (Watt
+00012df0: 732d 5374 726f 6761 747a 2920 636c 7573  s-Strogatz) clus
+00012e00: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
+00012e10: 6e74 2e0a 0a20 2020 2020 2020 2054 6869  nt...        Thi
+00012e20: 7320 6973 2074 6865 2070 726f 706f 7274  s is the proport
+00012e30: 696f 6e20 6f66 2061 6c6c 2070 6169 7273  ion of all pairs
+00012e40: 206f 6620 6974 7320 6e65 6967 6862 6f72   of its neighbor
+00012e50: 7320 7768 6963 6820 6172 650a 2020 2020  s which are.    
+00012e60: 2020 2020 7468 656d 7365 6c76 6573 2069      themselves i
+00012e70: 6e74 6572 6c69 6e6b 6564 2e0a 0a20 2020  nterlinked...   
+00012e80: 2020 2020 2028 5573 6573 2064 6972 6563       (Uses direc
+00012e90: 7469 6f6e 616c 6974 7920 696e 666f 726d  tionality inform
+00012ea0: 6174 696f 6e2c 2069 6620 6176 6169 6c61  ation, if availa
+00012eb0: 626c 6529 0a0a 2020 2020 2020 2020 2a2a  ble)..        **
+00012ec0: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
+00012ed0: 2020 2020 3e3e 3e20 7228 4e65 7477 6f72      >>> r(Networ
+00012ee0: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
+00012ef0: 726b 2829 2e6c 6f63 616c 5f63 6c75 7374  rk().local_clust
+00012f00: 6572 696e 6728 2929 0a20 2020 2020 2020  ering()).       
+00012f10: 2043 616c 6375 6c61 7469 6e67 206c 6f63   Calculating loc
+00012f20: 616c 2063 6c75 7374 6572 696e 6720 636f  al clustering co
+00012f30: 6566 6669 6369 656e 7473 2e2e 2e0a 2020  efficients....  
+00012f40: 2020 2020 2020 6172 7261 7928 5b20 302e        array([ 0.
+00012f50: 202c 2030 2e33 3333 332c 2031 2e20 2c20   , 0.3333, 1. , 
+00012f60: 302e 202c 2030 2e33 3333 332c 2030 2e20  0. , 0.3333, 0. 
+00012f70: 5d29 0a0a 2020 2020 2020 2020 3a72 7479  ])..        :rty
+00012f80: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
+00012f90: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
+00012fa0: 6174 7320 6265 7477 6565 6e20 3020 616e  ats between 0 an
+00012fb0: 6420 310a 2020 2020 2020 2020 2222 220a  d 1.        """.
+00012fc0: 2020 2020 2020 2020 4320 3d20 6e70 2e61          C = np.a
+00012fd0: 7272 6179 2873 656c 662e 6772 6170 682e  rray(self.graph.
+00012fe0: 7472 616e 7369 7469 7669 7479 5f6c 6f63  transitivity_loc
+00012ff0: 616c 5f75 6e64 6972 6563 7465 6428 2929  al_undirected())
+00013000: 0a20 2020 2020 2020 2043 5b6e 702e 6973  .        C[np.is
+00013010: 6e61 6e28 4329 5d20 3d20 300a 2020 2020  nan(C)] = 0.    
+00013020: 2020 2020 7265 7475 726e 2043 0a0a 2020      return C..  
+00013030: 2020 4043 6163 6865 642e 6d65 7468 6f64    @Cached.method
+00013040: 286e 616d 653d 2274 6865 2067 6c6f 6261  (name="the globa
+00013050: 6c20 636c 7573 7465 7269 6e67 2063 6f65  l clustering coe
+00013060: 6666 6963 6965 6e74 2028 435f 3229 2229  fficient (C_2)")
+00013070: 0a20 2020 2064 6566 2067 6c6f 6261 6c5f  .    def global_
+00013080: 636c 7573 7465 7269 6e67 2873 656c 6629  clustering(self)
+00013090: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+000130a0: 2020 2020 2020 5265 7475 726e 2074 6865        Return the
+000130b0: 2067 6c6f 6261 6c20 2857 6174 7473 2d53   global (Watts-S
+000130c0: 7472 6f67 6174 7a29 2063 6c75 7374 6572  trogatz) cluster
+000130d0: 696e 6720 636f 6566 6669 6369 656e 742e  ing coefficient.
+000130e0: 0a0a 2020 2020 2020 2020 5468 6973 2069  ..        This i
+000130f0: 7320 7468 6520 6d65 616e 206f 6620 7468  s the mean of th
+00013100: 6520 6c6f 6361 6c20 636c 7573 7465 7269  e local clusteri
+00013110: 6e67 2063 6f65 6666 6963 6965 6e74 732e  ng coefficients.
+00013120: 205b 4e65 776d 616e 3230 3033 5d5f 0a20   [Newman2003]_. 
+00013130: 2020 2020 2020 2072 6566 6572 7320 746f         refers to
+00013140: 2074 6869 7320 6d65 6173 7572 6520 6173   this measure as
+00013150: 2043 5f32 2e0a 0a20 2020 2020 2020 202a   C_2...        *
+00013160: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+00013170: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
+00013180: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
+00013190: 6f72 6b28 292e 676c 6f62 616c 5f63 6c75  ork().global_clu
+000131a0: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
+000131b0: 2020 2043 616c 6375 6c61 7469 6e67 2067     Calculating g
+000131c0: 6c6f 6261 6c20 636c 7573 7465 7269 6e67  lobal clustering
+000131d0: 2063 6f65 6666 6963 6965 6e74 2028 435f   coefficient (C_
+000131e0: 3229 2e2e 2e0a 2020 2020 2020 2020 4361  2)....        Ca
+000131f0: 6c63 756c 6174 696e 6720 6c6f 6361 6c20  lculating local 
+00013200: 636c 7573 7465 7269 6e67 2063 6f65 6666  clustering coeff
+00013210: 6963 6965 6e74 732e 2e2e 0a20 2020 2020  icients....     
+00013220: 2020 2030 2e32 3737 380a 0a20 2020 2020     0.2778..     
+00013230: 2020 203a 7274 7970 653a 2066 6c6f 6174     :rtype: float
+00013240: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
+00013250: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00013260: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00013270: 2e6c 6f63 616c 5f63 6c75 7374 6572 696e  .local_clusterin
+00013280: 6728 292e 6d65 616e 2829 0a0a 2020 2020  g().mean()..    
+00013290: 6465 6620 5f6d 6f74 6966 5f63 6c75 7374  def _motif_clust
+000132a0: 6572 696e 675f 6865 6c70 6572 2873 656c  ering_helper(sel
+000132b0: 662c 2074 5f66 756e 632c 2054 2c20 6b65  f, t_func, T, ke
+000132c0: 793d 4e6f 6e65 2c20 6e73 693d 4661 6c73  y=None, nsi=Fals
+000132d0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+000132e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000132f0: 2020 2020 7479 7069 6361 6c5f 7765 6967      typical_weig
+00013300: 6874 3d4e 6f6e 652c 206b 7375 6d3d 4e6f  ht=None, ksum=No
+00013310: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
+00013320: 0a20 2020 2020 2020 2048 656c 7065 7220  .        Helper 
+00013330: 6675 6e63 7469 6f6e 2074 6f20 636f 6d70  function to comp
+00013340: 7574 6520 7468 6520 6c6f 6361 6c20 6d6f  ute the local mo
+00013350: 7469 6620 636c 7573 7465 7269 6e67 2063  tif clustering c
+00013360: 6f65 6666 6963 6965 6e74 732e 0a20 2020  oefficients..   
+00013370: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
+00013380: 6465 2c20 7265 7475 726e 7320 6120 7370  de, returns a sp
+00013390: 6563 6966 6963 2063 6c75 7374 6572 696e  ecific clusterin
+000133a0: 6720 636f 6566 6669 6369 656e 742c 2064  g coefficient, d
+000133b0: 6570 656e 6469 6e67 0a20 2020 2020 2020  epending.       
+000133c0: 206f 6e20 7468 6520 696e 7075 7420 6172   on the input ar
+000133d0: 6775 6d65 6e74 732e 0a0a 2020 2020 2020  guments...      
+000133e0: 2020 3a61 7267 2066 756e 6374 696f 6e20    :arg function 
+000133f0: 745f 6675 6e63 3a20 6d75 6c74 6970 6c69  t_func: multipli
+00013400: 6361 7469 6f6e 206f 6620 6164 6a61 6365  cation of adjace
+00013410: 6e63 792d 7479 7065 206d 6174 7269 6365  ncy-type matrice
+00013420: 730a 2020 2020 2020 2020 3a61 7267 2031  s.        :arg 1
+00013430: 6420 6e75 6d70 7920 6172 7261 7920 5b6e  d numpy array [n
+00013440: 6f64 655d 3a20 6465 6e6f 6d69 6e61 746f  ode]: denominato
+00013450: 7220 6d61 6465 206f 7574 206f 6620 2869  r made out of (i
+00013460: 6e2f 6f75 742f 6269 6c29 6465 6772 6565  n/out/bil)degree
+00013470: 730a 2020 2020 2020 2020 3a61 7267 2073  s.        :arg s
+00013480: 7472 206b 6579 3a20 6c69 6e6b 2061 7474  tr key: link att
+00013490: 7269 6275 7465 206b 6579 2028 6f70 7469  ribute key (opti
+000134a0: 6f6e 616c 290a 2020 2020 2020 2020 3a61  onal).        :a
+000134b0: 7267 2062 6f6f 6c20 6e73 693a 2066 6c61  rg bool nsi: fla
+000134c0: 6720 666f 7220 6e73 6920 6361 6c63 756c  g for nsi calcul
+000134d0: 6174 696f 6e20 2864 6566 6175 6c74 3a20  ation (default: 
+000134e0: 4661 6c73 6529 0a20 2020 2020 2020 203a  False).        :
+000134f0: 7479 7065 2074 7970 6963 616c 5f77 6569  type typical_wei
+00013500: 6768 743a 2066 6c6f 6174 203e 2030 0a20  ght: float > 0. 
+00013510: 2020 2020 2020 203a 6172 6720 666c 6f61         :arg floa
+00013520: 7420 7479 7069 6361 6c5f 7765 6967 6874  t typical_weight
+00013530: 3a20 4f70 7469 6f6e 616c 2074 7970 6963  : Optional typic
+00013540: 616c 206e 6f64 6520 7765 6967 6874 2074  al node weight t
+00013550: 6f20 6265 2075 7365 6420 666f 720a 2020  o be used for.  
+00013560: 2020 2020 2020 2020 2020 636f 7272 6563            correc
+00013570: 7469 6f6e 2e20 4966 204e 6f6e 652c 2074  tion. If None, t
+00013580: 6865 2075 6e63 6f72 7265 6374 6564 206d  he uncorrected m
+00013590: 6561 7375 7265 2069 730a 2020 2020 2020  easure is.      
+000135a0: 2020 2020 2020 7265 7475 726e 6564 2e20        returned. 
+000135b0: 2844 6566 6175 6c74 3a20 4e6f 6e65 290a  (Default: None).
+000135c0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+000135d0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
+000135e0: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
+000135f0: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
+00013600: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00013610: 2020 2020 2069 6620 6e73 693a 0a20 2020       if nsi:.   
+00013620: 2020 2020 2020 2020 206e 6f64 6577 203d           nodew =
+00013630: 2073 702e 6373 635f 6d61 7472 6978 286e   sp.csc_matrix(n
+00013640: 702e 6579 6528 7365 6c66 2e4e 2920 2a20  p.eye(self.N) * 
+00013650: 7365 6c66 2e6e 6f64 655f 7765 6967 6874  self.node_weight
+00013660: 7329 0a20 2020 2020 2020 2069 6620 6b65  s).        if ke
+00013670: 7920 6973 204e 6f6e 653a 0a20 2020 2020  y is None:.     
+00013680: 2020 2020 2020 2041 203d 2073 656c 662e         A = self.
+00013690: 7370 5f41 706c 7573 2829 202a 206e 6f64  sp_Aplus() * nod
+000136a0: 6577 2069 6620 6e73 6920 656c 7365 2073  ew if nsi else s
+000136b0: 656c 662e 7370 5f41 0a20 2020 2020 2020  elf.sp_A.       
+000136c0: 2020 2020 2041 5420 3d20 7365 6c66 2e73       AT = self.s
+000136d0: 705f 4170 6c75 7328 292e 5420 2a20 6e6f  p_Aplus().T * no
+000136e0: 6465 7720 6966 206e 7369 2065 6c73 6520  dew if nsi else 
+000136f0: 412e 540a 2020 2020 2020 2020 656c 7365  A.T.        else
+00013700: 3a0a 2020 2020 2020 2020 2020 2020 4d20  :.            M 
+00013710: 3d20 7370 2e63 7363 5f6d 6174 7269 7828  = sp.csc_matrix(
+00013720: 7365 6c66 2e6c 696e 6b5f 6174 7472 6962  self.link_attrib
+00013730: 7574 6528 6b65 7929 2a2a 2831 2f33 2e29  ute(key)**(1/3.)
+00013740: 290a 2020 2020 2020 2020 2020 2020 4120  ).            A 
+00013750: 3d20 4d20 2a20 6e6f 6465 7720 6966 206e  = M * nodew if n
+00013760: 7369 2065 6c73 6520 4d0a 2020 2020 2020  si else M.      
+00013770: 2020 2020 2020 4154 203d 204d 2e54 202a        AT = M.T *
+00013780: 206e 6f64 6577 2069 6620 6e73 6920 656c   nodew if nsi el
+00013790: 7365 204d 2e54 0a0a 2020 2020 2020 2020  se M.T..        
+000137a0: 7420 3d20 745f 6675 6e63 2841 2c20 4154  t = t_func(A, AT
+000137b0: 292e 6469 6167 6f6e 616c 2829 0a20 2020  ).diagonal().   
+000137c0: 2020 2020 2054 203d 2054 2e61 7374 7970       T = T.astyp
+000137d0: 6528 666c 6f61 7429 0a20 2020 2020 2020  e(float).       
+000137e0: 2054 5b54 203d 3d20 305d 203d 206e 702e   T[T == 0] = np.
+000137f0: 6e61 6e0a 2020 2020 2020 2020 6966 2074  nan.        if t
+00013800: 7970 6963 616c 5f77 6569 6768 7420 6973  ypical_weight is
+00013810: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00013820: 2020 2043 203d 2074 202f 2028 7365 6c66     C = t / (self
+00013830: 2e6e 6f64 655f 7765 6967 6874 7320 2a20  .node_weights * 
+00013840: 5429 2069 6620 6e73 6920 656c 7365 2074  T) if nsi else t
+00013850: 202f 2054 0a20 2020 2020 2020 2020 2020   / T.           
+00013860: 2043 5b6e 702e 6973 6e61 6e28 4329 5d20   C[np.isnan(C)] 
+00013870: 3d20 300a 2020 2020 2020 2020 2020 2020  = 0.            
+00013880: 7265 7475 726e 2043 0a20 2020 2020 2020  return C.       
+00013890: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000138a0: 2020 2062 696c 6b20 3d20 7365 6c66 2e6e     bilk = self.n
+000138b0: 7369 5f62 696c 6465 6772 6565 2874 7970  si_bildegree(typ
+000138c0: 6963 616c 5f77 6569 6768 743d 7479 7069  ical_weight=typi
+000138d0: 6361 6c5f 7765 6967 6874 290a 2020 2020  cal_weight).    
+000138e0: 2020 2020 2020 2020 6e75 6d65 7261 746f          numerato
+000138f0: 7220 3d20 7420 2f20 7365 6c66 2e6e 6f64  r = t / self.nod
+00013900: 655f 7765 6967 6874 730a 2020 2020 2020  e_weights.      
+00013910: 2020 2020 2020 7265 7475 726e 2028 286e        return ((n
+00013920: 756d 6572 6174 6f72 2f74 7970 6963 616c  umerator/typical
+00013930: 5f77 6569 6768 742a 2a32 202d 2033 2e30  _weight**2 - 3.0
+00013940: 2a62 696c 6b20 2d20 312e 3029 0a20 2020  *bilk - 1.0).   
+00013950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013960: 202f 2028 5420 2d20 6b73 756d 2f74 7970   / (T - ksum/typ
+00013970: 6963 616c 5f77 6569 6768 7420 2d20 6269  ical_weight - bi
+00013980: 6c6b 202b 2032 2929 0a0a 2020 2020 4043  lk + 2))..    @C
+00013990: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+000139a0: 653d 2274 6865 206c 6f63 616c 2063 7963  e="the local cyc
+000139b0: 6c65 206d 6f74 6966 2063 6c75 7374 6572  le motif cluster
+000139c0: 696e 6720 636f 6566 6669 6369 656e 7473  ing coefficients
+000139d0: 2229 0a20 2020 2064 6566 206c 6f63 616c  ").    def local
+000139e0: 5f63 7963 6c65 6d6f 7469 665f 636c 7573  _cyclemotif_clus
+000139f0: 7465 7269 6e67 2873 656c 662c 206b 6579  tering(self, key
+00013a00: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
+00013a10: 2222 220a 2020 2020 2020 2020 466f 7220  """.        For 
+00013a20: 6561 6368 206e 6f64 652c 2072 6574 7572  each node, retur
+00013a30: 6e20 7468 6520 636c 7573 7465 7269 6e67  n the clustering
+00013a40: 2063 6f65 6666 6963 6965 6e74 2077 6974   coefficient wit
+00013a50: 6820 7265 7370 6563 7420 746f 2074 6865  h respect to the
+00013a60: 0a20 2020 2020 2020 2063 7963 6c65 206d  .        cycle m
+00013a70: 6f74 6966 2e0a 0a20 2020 2020 2020 2049  otif...        I
+00013a80: 6620 6120 6c69 6e6b 2061 7474 7269 6275  f a link attribu
+00013a90: 7465 206b 6579 2069 7320 7370 6563 6966  te key is specif
+00013aa0: 6965 642c 2072 6574 7572 6e20 7468 6520  ied, return the 
+00013ab0: 6173 736f 6369 6174 6564 206c 696e 6b0a  associated link.
+00013ac0: 2020 2020 2020 2020 7765 6967 6874 6564          weighted
+00013ad0: 2076 6572 7369 6f6e 2e0a 0a20 2020 2020   version...     
+00013ae0: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
+00013af0: 0a20 2020 2020 2020 203e 3e3e 2072 284e  .        >>> r(N
+00013b00: 6574 776f 726b 2e53 6d61 6c6c 4469 7265  etwork.SmallDire
+00013b10: 6374 6564 5465 7374 4e65 7477 6f72 6b28  ctedTestNetwork(
+00013b20: 292e 6c6f 6361 6c5f 6379 636c 656d 6f74  ).local_cyclemot
+00013b30: 6966 5f63 6c75 7374 6572 696e 6728 2929  if_clustering())
+00013b40: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+00013b50: 7469 6e67 206c 6f63 616c 2063 7963 6c65  ting local cycle
+00013b60: 206d 6f74 6966 2063 6c75 7374 6572 696e   motif clusterin
+00013b70: 6720 636f 6566 6669 6369 656e 742e 2e2e  g coefficient...
+00013b80: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+00013b90: 2030 2e32 352c 2020 302e 3235 2c20 2030   0.25,  0.25,  0
+00013ba0: 2e20 202c 2020 302e 2020 2c20 2030 2e35  .  ,  0.  ,  0.5
+00013bb0: 202c 2020 302e 2020 5d29 0a0a 2020 2020   ,  0.  ])..    
+00013bc0: 2020 2020 3a61 7267 2073 7472 206b 6579      :arg str key
+00013bd0: 3a20 6c69 6e6b 2061 7474 7269 6275 7465  : link attribute
+00013be0: 206b 6579 2028 6f70 7469 6f6e 616c 290a   key (optional).
+00013bf0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00013c00: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
+00013c10: 6e6f 6465 5d20 6f66 2066 6c6f 6174 7320  node] of floats 
+00013c20: 6265 7477 6565 6e20 3020 616e 6420 310a  between 0 and 1.
+00013c30: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00013c40: 2020 2020 6465 6620 745f 6675 6e63 2878      def t_func(x
+00013c50: 2c20 7854 293a 0a20 2020 2020 2020 2020  , xT):.         
+00013c60: 2020 2072 6574 7572 6e20 7820 2a20 7820     return x * x 
+00013c70: 2a20 780a 2020 2020 2020 2020 5420 3d20  * x.        T = 
+00013c80: 7365 6c66 2e69 6e64 6567 7265 6528 2920  self.indegree() 
+00013c90: 2a20 7365 6c66 2e6f 7574 6465 6772 6565  * self.outdegree
+00013ca0: 2829 202d 2073 656c 662e 6269 6c64 6567  () - self.bildeg
+00013cb0: 7265 6528 290a 2020 2020 2020 2020 7265  ree().        re
+00013cc0: 7475 726e 2073 656c 662e 5f6d 6f74 6966  turn self._motif
+00013cd0: 5f63 6c75 7374 6572 696e 675f 6865 6c70  _clustering_help
+00013ce0: 6572 2874 5f66 756e 632c 2054 2c20 6b65  er(t_func, T, ke
+00013cf0: 793d 6b65 7929 0a0a 2020 2020 4043 6163  y=key)..    @Cac
+00013d00: 6865 642e 6d65 7468 6f64 286e 616d 653d  hed.method(name=
+00013d10: 2274 6865 206c 6f63 616c 206d 6964 2e20  "the local mid. 
+00013d20: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
+00013d30: 2063 6f65 6666 6963 6965 6e74 7322 290a   coefficients").
+00013d40: 2020 2020 6465 6620 6c6f 6361 6c5f 6d69      def local_mi
+00013d50: 646d 6f74 6966 5f63 6c75 7374 6572 696e  dmotif_clusterin
+00013d60: 6728 7365 6c66 2c20 6b65 793d 4e6f 6e65  g(self, key=None
+00013d70: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00013d80: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
+00013d90: 6e6f 6465 2c20 7265 7475 726e 2074 6865  node, return the
+00013da0: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
+00013db0: 6669 6369 656e 7420 7769 7468 2072 6573  ficient with res
+00013dc0: 7065 6374 2074 6f20 7468 650a 2020 2020  pect to the.    
+00013dd0: 2020 2020 6d69 642e 206d 6f74 6966 2e0a      mid. motif..
+00013de0: 0a20 2020 2020 2020 2049 6620 6120 6c69  .        If a li
+00013df0: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
+00013e00: 2069 7320 7370 6563 6966 6965 642c 2072   is specified, r
+00013e10: 6574 7572 6e20 7468 6520 6173 736f 6369  eturn the associ
+00013e20: 6174 6564 206c 696e 6b0a 2020 2020 2020  ated link.      
+00013e30: 2020 7765 6967 6874 6564 2076 6572 7369    weighted versi
+00013e40: 6f6e 2e0a 0a20 2020 2020 2020 202a 2a45  on...        **E
+00013e50: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
+00013e60: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
+00013e70: 2e53 6d61 6c6c 4469 7265 6374 6564 5465  .SmallDirectedTe
+00013e80: 7374 4e65 7477 6f72 6b28 292e 6c6f 6361  stNetwork().loca
+00013e90: 6c5f 6d69 646d 6f74 6966 5f63 6c75 7374  l_midmotif_clust
+00013ea0: 6572 696e 6728 2929 0a20 2020 2020 2020  ering()).       
+00013eb0: 2043 616c 6375 6c61 7469 6e67 206c 6f63   Calculating loc
+00013ec0: 616c 206d 6964 2e20 6d6f 7469 6620 636c  al mid. motif cl
+00013ed0: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
+00013ee0: 6965 6e74 2e2e 2e0a 2020 2020 2020 2020  ient....        
+00013ef0: 6172 7261 7928 5b20 302e 202c 2020 302e  array([ 0. ,  0.
+00013f00: 202c 2020 302e 202c 2020 312e 202c 2020   ,  0. ,  1. ,  
+00013f10: 302e 352c 2020 302e 205d 290a 0a20 2020  0.5,  0. ])..   
+00013f20: 2020 2020 203a 6172 6720 7374 7220 6b65       :arg str ke
+00013f30: 793a 206c 696e 6b20 6174 7472 6962 7574  y: link attribut
+00013f40: 6520 6b65 7920 286f 7074 696f 6e61 6c29  e key (optional)
+00013f50: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+00013f60: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
+00013f70: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
+00013f80: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
+00013f90: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00013fa0: 2020 2020 2064 6566 2074 5f66 756e 6328       def t_func(
+00013fb0: 782c 2078 5429 3a0a 2020 2020 2020 2020  x, xT):.        
+00013fc0: 2020 2020 7265 7475 726e 2078 202a 2078      return x * x
+00013fd0: 5420 2a20 780a 2020 2020 2020 2020 5420  T * x.        T 
+00013fe0: 3d20 7365 6c66 2e69 6e64 6567 7265 6528  = self.indegree(
+00013ff0: 2920 2a20 7365 6c66 2e6f 7574 6465 6772  ) * self.outdegr
+00014000: 6565 2829 202d 2073 656c 662e 6269 6c64  ee() - self.bild
+00014010: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
+00014020: 7265 7475 726e 2073 656c 662e 5f6d 6f74  return self._mot
+00014030: 6966 5f63 6c75 7374 6572 696e 675f 6865  if_clustering_he
+00014040: 6c70 6572 2874 5f66 756e 632c 2054 2c20  lper(t_func, T, 
+00014050: 6b65 793d 6b65 7929 0a0a 2020 2020 4043  key=key)..    @C
+00014060: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+00014070: 653d 2274 6865 206c 6f63 616c 2069 6e20  e="the local in 
+00014080: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
+00014090: 2063 6f65 6666 6963 6965 6e74 7322 290a   coefficients").
+000140a0: 2020 2020 6465 6620 6c6f 6361 6c5f 696e      def local_in
+000140b0: 6d6f 7469 665f 636c 7573 7465 7269 6e67  motif_clustering
+000140c0: 2873 656c 662c 206b 6579 3d4e 6f6e 6529  (self, key=None)
+000140d0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+000140e0: 2020 2020 2020 466f 7220 6561 6368 206e        For each n
+000140f0: 6f64 652c 2072 6574 7572 6e20 7468 6520  ode, return the 
+00014100: 636c 7573 7465 7269 6e67 2063 6f65 6666  clustering coeff
+00014110: 6963 6965 6e74 2077 6974 6820 7265 7370  icient with resp
+00014120: 6563 7420 746f 2074 6865 0a20 2020 2020  ect to the.     
+00014130: 2020 2069 6e20 6d6f 7469 662e 0a0a 2020     in motif...  
+00014140: 2020 2020 2020 4966 2061 206c 696e 6b20        If a link 
+00014150: 6174 7472 6962 7574 6520 6b65 7920 6973  attribute key is
+00014160: 2073 7065 6369 6669 6564 2c20 7265 7475   specified, retu
+00014170: 726e 2074 6865 2061 7373 6f63 6961 7465  rn the associate
+00014180: 6420 6c69 6e6b 0a20 2020 2020 2020 2077  d link.        w
+00014190: 6569 6768 7465 6420 7665 7273 696f 6e2e  eighted version.
+000141a0: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
+000141b0: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
+000141c0: 3e3e 3e20 7228 4e65 7477 6f72 6b2e 536d  >>> r(Network.Sm
+000141d0: 616c 6c44 6972 6563 7465 6454 6573 744e  allDirectedTestN
+000141e0: 6574 776f 726b 2829 2e6c 6f63 616c 5f69  etwork().local_i
+000141f0: 6e6d 6f74 6966 5f63 6c75 7374 6572 696e  nmotif_clusterin
+00014200: 6728 2929 0a20 2020 2020 2020 2043 616c  g()).        Cal
+00014210: 6375 6c61 7469 6e67 206c 6f63 616c 2069  culating local i
+00014220: 6e20 6d6f 7469 6620 636c 7573 7465 7269  n motif clusteri
+00014230: 6e67 2063 6f65 6666 6963 6965 6e74 2e2e  ng coefficient..
+00014240: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+00014250: 5b20 302e 202c 2020 302e 352c 2020 302e  [ 0. ,  0.5,  0.
+00014260: 352c 2020 302e 202c 2020 302e 202c 2020  5,  0. ,  0. ,  
+00014270: 302e 205d 290a 0a20 2020 2020 2020 203a  0. ])..        :
+00014280: 6172 6720 7374 7220 6b65 793a 206c 696e  arg str key: lin
+00014290: 6b20 6174 7472 6962 7574 6520 6b65 7920  k attribute key 
+000142a0: 286f 7074 696f 6e61 6c29 0a20 2020 2020  (optional).     
+000142b0: 2020 203a 7274 7970 653a 2031 6420 6e75     :rtype: 1d nu
+000142c0: 6d70 7920 6172 7261 7920 5b6e 6f64 655d  mpy array [node]
+000142d0: 206f 6620 666c 6f61 7473 2062 6574 7765   of floats betwe
+000142e0: 656e 2030 2061 6e64 2031 0a20 2020 2020  en 0 and 1.     
+000142f0: 2020 2022 2222 0a20 2020 2020 2020 2064     """.        d
+00014300: 6566 2074 5f66 756e 6328 782c 2078 5429  ef t_func(x, xT)
+00014310: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00014320: 7475 726e 2078 5420 2a20 7820 2a20 780a  turn xT * x * x.
+00014330: 2020 2020 2020 2020 5420 3d20 7365 6c66          T = self
+00014340: 2e69 6e64 6567 7265 6528 2920 2a20 2873  .indegree() * (s
+00014350: 656c 662e 696e 6465 6772 6565 2829 202d  elf.indegree() -
+00014360: 2031 290a 2020 2020 2020 2020 7265 7475   1).        retu
+00014370: 726e 2073 656c 662e 5f6d 6f74 6966 5f63  rn self._motif_c
+00014380: 6c75 7374 6572 696e 675f 6865 6c70 6572  lustering_helper
+00014390: 2874 5f66 756e 632c 2054 2c20 6b65 793d  (t_func, T, key=
+000143a0: 6b65 7929 0a0a 2020 2020 4043 6163 6865  key)..    @Cache
+000143b0: 642e 6d65 7468 6f64 286e 616d 653d 2274  d.method(name="t
+000143c0: 6865 206c 6f63 616c 206f 7574 206d 6f74  he local out mot
+000143d0: 6966 2063 6c75 7374 6572 696e 6720 636f  if clustering co
+000143e0: 6566 6669 6369 656e 7473 2229 0a20 2020  efficients").   
+000143f0: 2064 6566 206c 6f63 616c 5f6f 7574 6d6f   def local_outmo
+00014400: 7469 665f 636c 7573 7465 7269 6e67 2873  tif_clustering(s
+00014410: 656c 662c 206b 6579 3d4e 6f6e 6529 3a0a  elf, key=None):.
+00014420: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00014430: 2020 2020 466f 7220 6561 6368 206e 6f64      For each nod
+00014440: 652c 2072 6574 7572 6e20 7468 6520 636c  e, return the cl
+00014450: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
+00014460: 6965 6e74 2077 6974 6820 7265 7370 6563  ient with respec
+00014470: 7420 746f 2074 6865 0a20 2020 2020 2020  t to the.       
+00014480: 206f 7574 206d 6f74 6966 2e0a 0a20 2020   out motif...   
+00014490: 2020 2020 2049 6620 6120 6c69 6e6b 2061       If a link a
+000144a0: 7474 7269 6275 7465 206b 6579 2069 7320  ttribute key is 
+000144b0: 7370 6563 6966 6965 642c 2072 6574 7572  specified, retur
+000144c0: 6e20 7468 6520 6173 736f 6369 6174 6564  n the associated
+000144d0: 206c 696e 6b0a 2020 2020 2020 2020 7765   link.        we
+000144e0: 6967 6874 6564 2076 6572 7369 6f6e 2e0a  ighted version..
+000144f0: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
+00014500: 6c65 3a2a 2a0a 0a20 2020 2020 2020 203e  le:**..        >
+00014510: 3e3e 2072 284e 6574 776f 726b 2e53 6d61  >> r(Network.Sma
+00014520: 6c6c 4469 7265 6374 6564 5465 7374 4e65  llDirectedTestNe
+00014530: 7477 6f72 6b28 292e 6c6f 6361 6c5f 6f75  twork().local_ou
+00014540: 746d 6f74 6966 5f63 6c75 7374 6572 696e  tmotif_clusterin
+00014550: 6728 2929 0a20 2020 2020 2020 2043 616c  g()).        Cal
+00014560: 6375 6c61 7469 6e67 206c 6f63 616c 206f  culating local o
+00014570: 7574 206d 6f74 6966 2063 6c75 7374 6572  ut motif cluster
+00014580: 696e 6720 636f 6566 6669 6369 656e 742e  ing coefficient.
+00014590: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
+000145a0: 285b 2030 2e35 2c20 2030 2e35 2c20 2030  ([ 0.5,  0.5,  0
+000145b0: 2e20 2c20 2030 2e20 2c20 2030 2e20 2c20  . ,  0. ,  0. , 
+000145c0: 2030 2e20 5d29 0a0a 2020 2020 2020 2020   0. ])..        
+000145d0: 3a61 7267 2073 7472 206b 6579 3a20 6c69  :arg str key: li
+000145e0: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
+000145f0: 2028 6f70 7469 6f6e 616c 290a 2020 2020   (optional).    
+00014600: 2020 2020 3a72 7479 7065 3a20 3164 206e      :rtype: 1d n
+00014610: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
+00014620: 5d20 6f66 2066 6c6f 6174 7320 6265 7477  ] of floats betw
+00014630: 6565 6e20 3020 616e 6420 310a 2020 2020  een 0 and 1.    
+00014640: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00014650: 6465 6620 745f 6675 6e63 2878 2c20 7854  def t_func(x, xT
+00014660: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00014670: 6574 7572 6e20 7820 2a20 7820 2a20 7854  eturn x * x * xT
+00014680: 0a20 2020 2020 2020 2054 203d 2073 656c  .        T = sel
+00014690: 662e 6f75 7464 6567 7265 6528 2920 2a20  f.outdegree() * 
+000146a0: 2873 656c 662e 6f75 7464 6567 7265 6528  (self.outdegree(
+000146b0: 2920 2d20 3129 0a20 2020 2020 2020 2072  ) - 1).        r
+000146c0: 6574 7572 6e20 7365 6c66 2e5f 6d6f 7469  eturn self._moti
+000146d0: 665f 636c 7573 7465 7269 6e67 5f68 656c  f_clustering_hel
+000146e0: 7065 7228 745f 6675 6e63 2c20 542c 206b  per(t_func, T, k
+000146f0: 6579 3d6b 6579 290a 0a20 2020 2040 4361  ey=key)..    @Ca
+00014700: 6368 6564 2e6d 6574 686f 6428 6e61 6d65  ched.method(name
+00014710: 3d22 7468 6520 6c6f 6361 6c20 6e2e 732e  ="the local n.s.
+00014720: 692e 2063 7963 6c65 206d 6f74 6966 2063  i. cycle motif c
+00014730: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
+00014740: 6369 656e 7473 222c 0a20 2020 2020 2020  cients",.       
+00014750: 2020 2020 2020 2020 2020 2020 6174 7472              attr
+00014760: 733d 2822 5f6d 7574 5f6e 7722 2c29 290a  s=("_mut_nw",)).
+00014770: 2020 2020 6465 6620 6e73 695f 6c6f 6361      def nsi_loca
+00014780: 6c5f 6379 636c 656d 6f74 6966 5f63 6c75  l_cyclemotif_clu
+00014790: 7374 6572 696e 6728 7365 6c66 2c20 6b65  stering(self, ke
+000147a0: 793d 4e6f 6e65 2c20 7479 7069 6361 6c5f  y=None, typical_
+000147b0: 7765 6967 6874 3d4e 6f6e 6529 3a0a 2020  weight=None):.  
+000147c0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000147d0: 2020 466f 7220 6561 6368 206e 6f64 652c    For each node,
+000147e0: 2072 6574 7572 6e20 7468 6520 6e73 6920   return the nsi 
+000147f0: 636c 7573 7465 7269 6e67 2063 6f65 6666  clustering coeff
+00014800: 6963 6965 6e74 2077 6974 6820 7265 7370  icient with resp
+00014810: 6563 7420 746f 0a20 2020 2020 2020 2074  ect to.        t
+00014820: 6865 2063 7963 6c65 206d 6f74 6966 2e0a  he cycle motif..
+00014830: 0a20 2020 2020 2020 2049 6620 6120 6c69  .        If a li
+00014840: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
+00014850: 2069 7320 7370 6563 6966 6965 642c 2072   is specified, r
+00014860: 6574 7572 6e20 7468 6520 6173 736f 6369  eturn the associ
+00014870: 6174 6564 206c 696e 6b0a 2020 2020 2020  ated link.      
+00014880: 2020 7765 6967 6874 6564 2076 6572 7369    weighted versi
+00014890: 6f6e 2e0a 0a20 2020 2020 2020 2052 6566  on...        Ref
+000148a0: 6572 656e 6365 3a20 5b5a 656d 7032 3031  erence: [Zemp201
+000148b0: 345d 5f0a 0a20 2020 2020 2020 202a 2a45  4]_..        **E
+000148c0: 7861 6d70 6c65 733a 2a2a 0a0a 2020 2020  xamples:**..    
+000148d0: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
+000148e0: 7477 6f72 6b2e 536d 616c 6c44 6972 6563  twork.SmallDirec
+000148f0: 7465 6454 6573 744e 6574 776f 726b 2829  tedTestNetwork()
+00014900: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
+00014910: 6574 2e6e 7369 5f6c 6f63 616c 5f63 7963  et.nsi_local_cyc
+00014920: 6c65 6d6f 7469 665f 636c 7573 7465 7269  lemotif_clusteri
+00014930: 6e67 2829 290a 2020 2020 2020 2020 4361  ng()).        Ca
+00014940: 6c63 756c 6174 696e 6720 6c6f 6361 6c20  lculating local 
+00014950: 6e73 6920 6379 636c 6520 6d6f 7469 6620  nsi cycle motif 
+00014960: 636c 7573 7465 7269 6e67 2063 6f65 6666  clustering coeff
+00014970: 6963 6965 6e74 2e2e 2e0a 2020 2020 2020  icient....      
+00014980: 2020 6172 7261 7928 5b20 302e 3138 3435    array([ 0.1845
+00014990: 2c20 2030 2e32 3032 382c 2020 302e 3332  ,  0.2028,  0.32
+000149a0: 3220 2c20 2030 2e33 3232 342c 2020 302e  2 ,  0.3224,  0.
+000149b0: 3334 3339 2c20 2030 2e36 3235 205d 290a  3439,  0.625 ]).
+000149c0: 2020 2020 2020 2020 3e3e 3e20 7228 6e65          >>> r(ne
+000149d0: 742e 7370 6c69 7474 6564 5f63 6f70 7928  t.splitted_copy(
+000149e0: 6e6f 6465 3d31 292e 6e73 695f 6c6f 6361  node=1).nsi_loca
+000149f0: 6c5f 6379 636c 656d 6f74 6966 5f63 6c75  l_cyclemotif_clu
+00014a00: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
+00014a10: 2020 2043 616c 6375 6c61 7469 6e67 206c     Calculating l
+00014a20: 6f63 616c 206e 7369 2063 7963 6c65 206d  ocal nsi cycle m
+00014a30: 6f74 6966 2063 6c75 7374 6572 696e 6720  otif clustering 
+00014a40: 636f 6566 6669 6369 656e 742e 2e2e 0a20  coefficient.... 
+00014a50: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
+00014a60: 2e31 3834 352c 2020 302e 3230 3238 2c20  .1845,  0.2028, 
+00014a70: 2030 2e33 3232 202c 2020 302e 3332 3234   0.322 ,  0.3224
+00014a80: 2c20 2030 2e33 3433 392c 2020 302e 3632  ,  0.3439,  0.62
+00014a90: 3520 2c20 2030 2e32 3032 385d 290a 0a20  5 ,  0.2028]).. 
+00014aa0: 2020 2020 2020 2061 7320 636f 6d70 6172         as compar
+00014ab0: 6564 2074 6f20 7468 6520 756e 7765 6967  ed to the unweig
+00014ac0: 6874 6564 2076 6572 7369 6f6e 3a0a 0a20  hted version:.. 
+00014ad0: 2020 2020 2020 203e 3e3e 206e 6574 203d         >>> net =
+00014ae0: 204e 6574 776f 726b 2e53 6d61 6c6c 4469   Network.SmallDi
+00014af0: 7265 6374 6564 5465 7374 4e65 7477 6f72  rectedTestNetwor
+00014b00: 6b28 290a 2020 2020 2020 2020 3e3e 3e20  k().        >>> 
+00014b10: 7228 6e65 742e 6c6f 6361 6c5f 6379 636c  r(net.local_cycl
+00014b20: 656d 6f74 6966 5f63 6c75 7374 6572 696e  emotif_clusterin
+00014b30: 6728 2929 0a20 2020 2020 2020 2043 616c  g()).        Cal
+00014b40: 6375 6c61 7469 6e67 206c 6f63 616c 2063  culating local c
+00014b50: 7963 6c65 206d 6f74 6966 2063 6c75 7374  ycle motif clust
+00014b60: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+00014b70: 742e 2e2e 0a20 2020 2020 2020 2061 7272  t....        arr
+00014b80: 6179 285b 2030 2e32 352c 2020 302e 3235  ay([ 0.25,  0.25
+00014b90: 2c20 2030 2e20 202c 2020 302e 2020 2c20  ,  0.  ,  0.  , 
+00014ba0: 2030 2e35 202c 2020 302e 2020 5d29 0a20   0.5 ,  0.  ]). 
+00014bb0: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+00014bc0: 2e73 706c 6974 7465 645f 636f 7079 286e  .splitted_copy(n
+00014bd0: 6f64 653d 3129 2e6c 6f63 616c 5f63 7963  ode=1).local_cyc
+00014be0: 6c65 6d6f 7469 665f 636c 7573 7465 7269  lemotif_clusteri
+00014bf0: 6e67 2829 290a 2020 2020 2020 2020 4361  ng()).        Ca
+00014c00: 6c63 756c 6174 696e 6720 6c6f 6361 6c20  lculating local 
+00014c10: 6379 636c 6520 6d6f 7469 6620 636c 7573  cycle motif clus
+00014c20: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
+00014c30: 6e74 2e2e 2e0a 2020 2020 2020 2020 6172  nt....        ar
+00014c40: 7261 7928 5b20 302e 3333 3333 2c20 2030  ray([ 0.3333,  0
+00014c50: 2e31 3235 202c 2020 302e 2020 2020 2c20  .125 ,  0.    , 
+00014c60: 2030 2e20 2020 202c 2020 302e 3520 2020   0.    ,  0.5   
+00014c70: 2c20 2030 2e20 2020 202c 2020 302e 3132  ,  0.    ,  0.12
+00014c80: 3520 5d29 0a0a 2020 2020 2020 2020 3a61  5 ])..        :a
+00014c90: 7267 2073 7472 206b 6579 3a20 6c69 6e6b  rg str key: link
+00014ca0: 2061 7474 7269 6275 7465 206b 6579 2028   attribute key (
+00014cb0: 6f70 7469 6f6e 616c 290a 2020 2020 2020  optional).      
+00014cc0: 2020 3a74 7970 6520 7479 7069 6361 6c5f    :type typical_
+00014cd0: 7765 6967 6874 3a20 666c 6f61 7420 3e20  weight: float > 
+00014ce0: 300a 2020 2020 2020 2020 3a61 7267 2066  0.        :arg f
+00014cf0: 6c6f 6174 2074 7970 6963 616c 5f77 6569  loat typical_wei
+00014d00: 6768 743a 204f 7074 696f 6e61 6c20 7479  ght: Optional ty
+00014d10: 7069 6361 6c20 6e6f 6465 2077 6569 6768  pical node weigh
+00014d20: 7420 746f 2062 6520 7573 6564 2066 6f72  t to be used for
+00014d30: 0a20 2020 2020 2020 2020 2020 2063 6f72  .            cor
+00014d40: 7265 6374 696f 6e2e 2049 6620 4e6f 6e65  rection. If None
+00014d50: 2c20 7468 6520 756e 636f 7272 6563 7465  , the uncorrecte
+00014d60: 6420 6d65 6173 7572 6520 6973 0a20 2020  d measure is.   
+00014d70: 2020 2020 2020 2020 2072 6574 7572 6e65           returne
+00014d80: 642e 2028 4465 6661 756c 743a 204e 6f6e  d. (Default: Non
+00014d90: 6529 0a20 2020 2020 2020 2022 2222 0a20  e).        """. 
+00014da0: 2020 2020 2020 2064 6566 2074 5f66 756e         def t_fun
+00014db0: 6328 782c 2078 5429 3a0a 2020 2020 2020  c(x, xT):.      
+00014dc0: 2020 2020 2020 7265 7475 726e 2078 202a        return x *
+00014dd0: 2078 202a 2078 0a20 2020 2020 2020 2069   x * x.        i
+00014de0: 6e6b 203d 2073 656c 662e 6e73 695f 696e  nk = self.nsi_in
+00014df0: 6465 6772 6565 2874 7970 6963 616c 5f77  degree(typical_w
+00014e00: 6569 6768 743d 7479 7069 6361 6c5f 7765  eight=typical_we
+00014e10: 6967 6874 290a 2020 2020 2020 2020 6f75  ight).        ou
+00014e20: 746b 203d 2073 656c 662e 6e73 695f 6f75  tk = self.nsi_ou
+00014e30: 7464 6567 7265 6528 7479 7069 6361 6c5f  tdegree(typical_
+00014e40: 7765 6967 6874 3d74 7970 6963 616c 5f77  weight=typical_w
+00014e50: 6569 6768 7429 0a20 2020 2020 2020 2054  eight).        T
+00014e60: 203d 2069 6e6b 202a 206f 7574 6b0a 2020   = ink * outk.  
+00014e70: 2020 2020 2020 6b73 756d 203d 2069 6e6b        ksum = ink
+00014e80: 202b 206f 7574 6b0a 2020 2020 2020 2020   + outk.        
+00014e90: 7265 7475 726e 2073 656c 662e 5f6d 6f74  return self._mot
+00014ea0: 6966 5f63 6c75 7374 6572 696e 675f 6865  if_clustering_he
+00014eb0: 6c70 6572 280a 2020 2020 2020 2020 2020  lper(.          
+00014ec0: 2020 745f 6675 6e63 2c20 542c 206b 6579    t_func, T, key
+00014ed0: 3d6b 6579 2c20 6e73 693d 5472 7565 2c0a  =key, nsi=True,.
+00014ee0: 2020 2020 2020 2020 2020 2020 7479 7069              typi
+00014ef0: 6361 6c5f 7765 6967 6874 3d74 7970 6963  cal_weight=typic
+00014f00: 616c 5f77 6569 6768 742c 206b 7375 6d3d  al_weight, ksum=
+00014f10: 6b73 756d 290a 0a20 2020 2040 4361 6368  ksum)..    @Cach
+00014f20: 6564 2e6d 6574 686f 6428 6e61 6d65 3d22  ed.method(name="
+00014f30: 7468 6520 6c6f 6361 6c20 6e2e 732e 692e  the local n.s.i.
+00014f40: 206d 6964 2e20 6d6f 7469 6620 636c 7573   mid. motif clus
+00014f50: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
+00014f60: 6e74 7322 2c0a 2020 2020 2020 2020 2020  nts",.          
+00014f70: 2020 2020 2020 2020 2061 7474 7273 3d28           attrs=(
+00014f80: 225f 6d75 745f 6e77 222c 2929 0a20 2020  "_mut_nw",)).   
+00014f90: 2064 6566 206e 7369 5f6c 6f63 616c 5f6d   def nsi_local_m
+00014fa0: 6964 6d6f 7469 665f 636c 7573 7465 7269  idmotif_clusteri
+00014fb0: 6e67 2873 656c 662c 206b 6579 3d4e 6f6e  ng(self, key=Non
+00014fc0: 652c 2074 7970 6963 616c 5f77 6569 6768  e, typical_weigh
+00014fd0: 743d 4e6f 6e65 293a 0a20 2020 2020 2020  t=None):.       
+00014fe0: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
+00014ff0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
+00015000: 726e 2074 6865 206e 7369 2063 6c75 7374  rn the nsi clust
+00015010: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+00015020: 7420 7769 7468 2072 6573 7065 6374 2074  t with respect t
+00015030: 6f0a 2020 2020 2020 2020 7468 6520 6d69  o.        the mi
+00015040: 6420 6d6f 7469 662e 0a0a 2020 2020 2020  d motif...      
+00015050: 2020 4966 2061 206c 696e 6b20 6174 7472    If a link attr
+00015060: 6962 7574 6520 6b65 7920 6973 2073 7065  ibute key is spe
+00015070: 6369 6669 6564 2c20 7265 7475 726e 2074  cified, return t
+00015080: 6865 2061 7373 6f63 6961 7465 6420 6c69  he associated li
+00015090: 6e6b 0a20 2020 2020 2020 2077 6569 6768  nk.        weigh
+000150a0: 7465 6420 7665 7273 696f 6e2e 0a0a 2020  ted version...  
+000150b0: 2020 2020 2020 5265 6665 7265 6e63 653a        Reference:
+000150c0: 205b 5a65 6d70 3230 3134 5d5f 0a0a 2020   [Zemp2014]_..  
+000150d0: 2020 2020 2020 2a2a 4578 616d 706c 6573        **Examples
+000150e0: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+000150f0: 206e 6574 203d 204e 6574 776f 726b 2e53   net = Network.S
+00015100: 6d61 6c6c 4469 7265 6374 6564 5465 7374  mallDirectedTest
+00015110: 4e65 7477 6f72 6b28 290a 2020 2020 2020  Network().      
+00015120: 2020 3e3e 3e20 7228 6e65 742e 6e73 695f    >>> r(net.nsi_
+00015130: 6c6f 6361 6c5f 6d69 646d 6f74 6966 5f63  local_midmotif_c
+00015140: 6c75 7374 6572 696e 6728 2929 0a20 2020  lustering()).   
+00015150: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+00015160: 206c 6f63 616c 206e 7369 206d 6964 2e20   local nsi mid. 
+00015170: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
+00015180: 2063 6f65 6666 6963 6965 6e74 2e2e 2e0a   coefficient....
+00015190: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+000151a0: 302e 3435 3337 2c20 2030 2e35 3136 352c  0.4537,  0.5165,
+000151b0: 2020 312e 2020 2020 2c20 2031 2e20 2020    1.    ,  1.   
+000151c0: 202c 2020 302e 3838 3832 2c20 2031 2e20   ,  0.8882,  1. 
+000151d0: 2020 205d 290a 2020 2020 2020 2020 3e3e     ]).        >>
+000151e0: 3e20 7228 6e65 742e 7370 6c69 7474 6564  > r(net.splitted
+000151f0: 5f63 6f70 7928 6e6f 6465 3d34 292e 6e73  _copy(node=4).ns
+00015200: 695f 6c6f 6361 6c5f 6d69 646d 6f74 6966  i_local_midmotif
+00015210: 5f63 6c75 7374 6572 696e 6728 2929 0a20  _clustering()). 
+00015220: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
+00015230: 6e67 206c 6f63 616c 206e 7369 206d 6964  ng local nsi mid
+00015240: 2e20 6d6f 7469 6620 636c 7573 7465 7269  . motif clusteri
+00015250: 6e67 2063 6f65 6666 6963 6965 6e74 2e2e  ng coefficient..
+00015260: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+00015270: 5b20 302e 3435 3337 2c20 2030 2e35 3136  [ 0.4537,  0.516
+00015280: 352c 2020 312e 2020 2020 2c20 2031 2e20  5,  1.    ,  1. 
+00015290: 2020 202c 2020 302e 3838 3832 2c20 2031     ,  0.8882,  1
+000152a0: 2e20 2020 202c 2020 302e 3838 3832 5d29  .    ,  0.8882])
+000152b0: 0a0a 2020 2020 2020 2020 6173 2063 6f6d  ..        as com
+000152c0: 7061 7265 6420 746f 2074 6865 2075 6e77  pared to the unw
+000152d0: 6569 6768 7465 6420 7665 7273 696f 6e3a  eighted version:
+000152e0: 0a0a 2020 2020 2020 2020 3e3e 3e20 6e65  ..        >>> ne
+000152f0: 7420 3d20 4e65 7477 6f72 6b2e 536d 616c  t = Network.Smal
+00015300: 6c44 6972 6563 7465 6454 6573 744e 6574  lDirectedTestNet
+00015310: 776f 726b 2829 0a20 2020 2020 2020 203e  work().        >
+00015320: 3e3e 2072 286e 6574 2e6c 6f63 616c 5f6d  >> r(net.local_m
+00015330: 6964 6d6f 7469 665f 636c 7573 7465 7269  idmotif_clusteri
+00015340: 6e67 2829 290a 2020 2020 2020 2020 4361  ng()).        Ca
+00015350: 6c63 756c 6174 696e 6720 6c6f 6361 6c20  lculating local 
+00015360: 6d69 642e 206d 6f74 6966 2063 6c75 7374  mid. motif clust
+00015370: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+00015380: 742e 2e2e 0a20 2020 2020 2020 2061 7272  t....        arr
+00015390: 6179 285b 2030 2e20 2c20 2030 2e20 2c20  ay([ 0. ,  0. , 
+000153a0: 2030 2e20 2c20 2031 2e20 2c20 2030 2e35   0. ,  1. ,  0.5
+000153b0: 2c20 2030 2e20 5d29 0a20 2020 2020 2020  ,  0. ]).       
+000153c0: 203e 3e3e 2072 286e 6574 2e73 706c 6974   >>> r(net.split
+000153d0: 7465 645f 636f 7079 286e 6f64 653d 3429  ted_copy(node=4)
+000153e0: 2e6c 6f63 616c 5f6d 6964 6d6f 7469 665f  .local_midmotif_
+000153f0: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
+00015400: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+00015410: 6720 6c6f 6361 6c20 6d69 642e 206d 6f74  g local mid. mot
+00015420: 6966 2063 6c75 7374 6572 696e 6720 636f  if clustering co
+00015430: 6566 6669 6369 656e 742e 2e2e 0a20 2020  efficient....   
+00015440: 2020 2020 2061 7272 6179 285b 2030 2e20       array([ 0. 
+00015450: 2c20 2030 2e20 2c20 2030 2e20 2c20 2031  ,  0. ,  0. ,  1
+00015460: 2e20 2c20 2030 2e38 2c20 2030 2e20 2c20  . ,  0.8,  0. , 
+00015470: 2030 2e38 5d29 0a0a 2020 2020 2020 2020   0.8])..        
+00015480: 3a61 7267 2073 7472 206b 6579 3a20 6c69  :arg str key: li
+00015490: 6e6b 2061 7474 7269 6275 7465 206b 6579  nk attribute key
+000154a0: 2028 6f70 7469 6f6e 616c 290a 2020 2020   (optional).    
+000154b0: 2020 2020 3a74 7970 6520 7479 7069 6361      :type typica
+000154c0: 6c5f 7765 6967 6874 3a20 666c 6f61 7420  l_weight: float 
+000154d0: 3e20 300a 2020 2020 2020 2020 3a61 7267  > 0.        :arg
+000154e0: 2066 6c6f 6174 2074 7970 6963 616c 5f77   float typical_w
+000154f0: 6569 6768 743a 204f 7074 696f 6e61 6c20  eight: Optional 
+00015500: 7479 7069 6361 6c20 6e6f 6465 2077 6569  typical node wei
+00015510: 6768 7420 746f 2062 6520 7573 6564 2066  ght to be used f
+00015520: 6f72 0a20 2020 2020 2020 2020 2020 2063  or.            c
+00015530: 6f72 7265 6374 696f 6e2e 2049 6620 4e6f  orrection. If No
+00015540: 6e65 2c20 7468 6520 756e 636f 7272 6563  ne, the uncorrec
+00015550: 7465 6420 6d65 6173 7572 6520 6973 0a20  ted measure is. 
+00015560: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00015570: 6e65 642e 2028 4465 6661 756c 743a 204e  ned. (Default: N
+00015580: 6f6e 6529 0a20 2020 2020 2020 2022 2222  one).        """
+00015590: 0a20 2020 2020 2020 2064 6566 2074 5f66  .        def t_f
+000155a0: 756e 6328 782c 2078 5429 3a0a 2020 2020  unc(x, xT):.    
+000155b0: 2020 2020 2020 2020 7265 7475 726e 2078          return x
+000155c0: 202a 2078 5420 2a20 780a 2020 2020 2020   * xT * x.      
+000155d0: 2020 696e 6b20 3d20 7365 6c66 2e6e 7369    ink = self.nsi
+000155e0: 5f69 6e64 6567 7265 6528 7479 7069 6361  _indegree(typica
+000155f0: 6c5f 7765 6967 6874 3d74 7970 6963 616c  l_weight=typical
+00015600: 5f77 6569 6768 7429 0a20 2020 2020 2020  _weight).       
+00015610: 206f 7574 6b20 3d20 7365 6c66 2e6e 7369   outk = self.nsi
+00015620: 5f6f 7574 6465 6772 6565 2874 7970 6963  _outdegree(typic
+00015630: 616c 5f77 6569 6768 743d 7479 7069 6361  al_weight=typica
+00015640: 6c5f 7765 6967 6874 290a 2020 2020 2020  l_weight).      
+00015650: 2020 5420 3d20 696e 6b20 2a20 6f75 746b    T = ink * outk
+00015660: 0a20 2020 2020 2020 206b 7375 6d20 3d20  .        ksum = 
+00015670: 696e 6b20 2b20 6f75 746b 0a20 2020 2020  ink + outk.     
+00015680: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+00015690: 6d6f 7469 665f 636c 7573 7465 7269 6e67  motif_clustering
+000156a0: 5f68 656c 7065 7228 0a20 2020 2020 2020  _helper(.       
+000156b0: 2020 2020 2074 5f66 756e 632c 2054 2c20       t_func, T, 
+000156c0: 6b65 793d 6b65 792c 206e 7369 3d54 7275  key=key, nsi=Tru
+000156d0: 652c 0a20 2020 2020 2020 2020 2020 2074  e,.            t
+000156e0: 7970 6963 616c 5f77 6569 6768 743d 7479  ypical_weight=ty
+000156f0: 7069 6361 6c5f 7765 6967 6874 2c20 6b73  pical_weight, ks
+00015700: 756d 3d6b 7375 6d29 0a0a 2020 2020 4043  um=ksum)..    @C
+00015710: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+00015720: 653d 2274 6865 206c 6f63 616c 206e 2e73  e="the local n.s
+00015730: 2e69 2e20 696e 206d 6f74 6966 2063 6c75  .i. in motif clu
+00015740: 7374 6572 696e 6720 636f 6566 6669 6369  stering coeffici
+00015750: 656e 7473 222c 0a20 2020 2020 2020 2020  ents",.         
+00015760: 2020 2020 2020 2020 2020 6174 7472 733d            attrs=
+00015770: 2822 5f6d 7574 5f6e 7722 2c29 290a 2020  ("_mut_nw",)).  
+00015780: 2020 6465 6620 6e73 695f 6c6f 6361 6c5f    def nsi_local_
+00015790: 696e 6d6f 7469 665f 636c 7573 7465 7269  inmotif_clusteri
+000157a0: 6e67 2873 656c 662c 206b 6579 3d4e 6f6e  ng(self, key=Non
+000157b0: 652c 2074 7970 6963 616c 5f77 6569 6768  e, typical_weigh
+000157c0: 743d 4e6f 6e65 293a 0a20 2020 2020 2020  t=None):.       
+000157d0: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
+000157e0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
+000157f0: 726e 2074 6865 206e 7369 2063 6c75 7374  rn the nsi clust
+00015800: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+00015810: 7420 7769 7468 2072 6573 7065 6374 2074  t with respect t
+00015820: 6f0a 2020 2020 2020 2020 7468 6520 696e  o.        the in
+00015830: 206d 6f74 6966 2e0a 0a20 2020 2020 2020   motif...       
+00015840: 2049 6620 6120 6c69 6e6b 2061 7474 7269   If a link attri
+00015850: 6275 7465 206b 6579 2069 7320 7370 6563  bute key is spec
+00015860: 6966 6965 642c 2072 6574 7572 6e20 7468  ified, return th
+00015870: 6520 6173 736f 6369 6174 6564 206c 696e  e associated lin
+00015880: 6b0a 2020 2020 2020 2020 7765 6967 6874  k.        weight
+00015890: 6564 2076 6572 7369 6f6e 2e0a 0a20 2020  ed version...   
+000158a0: 2020 2020 2052 6566 6572 656e 6365 3a20       Reference: 
+000158b0: 5b5a 656d 7032 3031 345d 5f0a 0a20 2020  [Zemp2014]_..   
+000158c0: 2020 2020 202a 2a45 7861 6d70 6c65 733a       **Examples:
+000158d0: 2a2a 0a0a 2020 2020 2020 2020 3e3e 3e20  **..        >>> 
+000158e0: 6e65 7420 3d20 4e65 7477 6f72 6b2e 536d  net = Network.Sm
+000158f0: 616c 6c44 6972 6563 7465 6454 6573 744e  allDirectedTestN
+00015900: 6574 776f 726b 2829 0a20 2020 2020 2020  etwork().       
+00015910: 203e 3e3e 2072 286e 6574 2e6e 7369 5f6c   >>> r(net.nsi_l
+00015920: 6f63 616c 5f69 6e6d 6f74 6966 5f63 6c75  ocal_inmotif_clu
+00015930: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
+00015940: 2020 2043 616c 6375 6c61 7469 6e67 206c     Calculating l
+00015950: 6f63 616c 206e 7369 2069 6e20 6d6f 7469  ocal nsi in moti
+00015960: 6620 636c 7573 7465 7269 6e67 2063 6f65  f clustering coe
+00015970: 6666 6963 6965 6e74 2e2e 2e0a 2020 2020  fficient....    
+00015980: 2020 2020 6172 7261 7928 5b20 302e 3532      array([ 0.52
+00015990: 3838 2c20 2030 2e36 3720 202c 2020 302e  88,  0.67  ,  0.
+000159a0: 3636 3933 2c20 2030 2e37 3536 392c 2020  6693,  0.7569,  
+000159b0: 302e 3735 3536 2c20 2031 2e20 2020 205d  0.7556,  1.    ]
+000159c0: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
+000159d0: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
+000159e0: 7928 6e6f 6465 3d31 292e 6e73 695f 6c6f  y(node=1).nsi_lo
+000159f0: 6361 6c5f 696e 6d6f 7469 665f 636c 7573  cal_inmotif_clus
+00015a00: 7465 7269 6e67 2829 290a 2020 2020 2020  tering()).      
+00015a10: 2020 4361 6c63 756c 6174 696e 6720 6c6f    Calculating lo
+00015a20: 6361 6c20 6e73 6920 696e 206d 6f74 6966  cal nsi in motif
+00015a30: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
+00015a40: 6669 6369 656e 742e 2e2e 0a20 2020 2020  ficient....     
+00015a50: 2020 2061 7272 6179 285b 2030 2e35 3238     array([ 0.528
+00015a60: 382c 2020 302e 3637 2020 2c20 2030 2e36  8,  0.67  ,  0.6
+00015a70: 3639 332c 2020 302e 3735 3639 2c20 2030  693,  0.7569,  0
+00015a80: 2e37 3535 362c 2020 312e 2020 2020 2c20  .7556,  1.    , 
+00015a90: 2030 2e36 3720 205d 290a 0a20 2020 2020   0.67  ])..     
+00015aa0: 2020 2061 7320 636f 6d70 6172 6564 2074     as compared t
+00015ab0: 6f20 7468 6520 756e 7765 6967 6874 6564  o the unweighted
+00015ac0: 2076 6572 7369 6f6e 3a0a 0a20 2020 2020   version:..     
+00015ad0: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
+00015ae0: 776f 726b 2e53 6d61 6c6c 4469 7265 6374  work.SmallDirect
+00015af0: 6564 5465 7374 4e65 7477 6f72 6b28 290a  edTestNetwork().
+00015b00: 2020 2020 2020 2020 3e3e 3e20 7228 6e65          >>> r(ne
+00015b10: 742e 6c6f 6361 6c5f 696e 6d6f 7469 665f  t.local_inmotif_
+00015b20: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
+00015b30: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+00015b40: 6720 6c6f 6361 6c20 696e 206d 6f74 6966  g local in motif
+00015b50: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
+00015b60: 6669 6369 656e 742e 2e2e 0a20 2020 2020  ficient....     
+00015b70: 2020 2061 7272 6179 285b 2030 2e20 2c20     array([ 0. , 
+00015b80: 2030 2e35 2c20 2030 2e35 2c20 2030 2e20   0.5,  0.5,  0. 
+00015b90: 2c20 2030 2e20 2c20 2030 2e20 5d29 0a20  ,  0. ,  0. ]). 
+00015ba0: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+00015bb0: 2e73 706c 6974 7465 645f 636f 7079 286e  .splitted_copy(n
+00015bc0: 6f64 653d 3129 2e6c 6f63 616c 5f69 6e6d  ode=1).local_inm
+00015bd0: 6f74 6966 5f63 6c75 7374 6572 696e 6728  otif_clustering(
+00015be0: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+00015bf0: 6c61 7469 6e67 206c 6f63 616c 2069 6e20  lating local in 
+00015c00: 6d6f 7469 6620 636c 7573 7465 7269 6e67  motif clustering
+00015c10: 2063 6f65 6666 6963 6965 6e74 2e2e 2e0a   coefficient....
+00015c20: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+00015c30: 302e 2020 2020 2c20 2030 2e35 2020 202c  0.    ,  0.5   ,
+00015c40: 2020 302e 3636 3637 2c20 2030 2e20 2020    0.6667,  0.   
+00015c50: 202c 2020 312e 2020 2020 2c20 2030 2e20   ,  1.    ,  0. 
+00015c60: 2020 202c 2020 302e 3520 2020 5d29 0a0a     ,  0.5   ])..
+00015c70: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
+00015c80: 7220 6b65 793a 206c 696e 6b20 6174 7472  r key: link attr
+00015c90: 6962 7574 6520 6b65 7920 286f 7074 696f  ibute key (optio
+00015ca0: 6e61 6c29 0a20 2020 2020 2020 203a 7479  nal).        :ty
+00015cb0: 7065 2074 7970 6963 616c 5f77 6569 6768  pe typical_weigh
+00015cc0: 743a 2066 6c6f 6174 203e 2030 0a20 2020  t: float > 0.   
+00015cd0: 2020 2020 203a 6172 6720 666c 6f61 7420       :arg float 
+00015ce0: 7479 7069 6361 6c5f 7765 6967 6874 3a20  typical_weight: 
+00015cf0: 4f70 7469 6f6e 616c 2074 7970 6963 616c  Optional typical
+00015d00: 206e 6f64 6520 7765 6967 6874 2074 6f20   node weight to 
+00015d10: 6265 2075 7365 6420 666f 720a 2020 2020  be used for.    
+00015d20: 2020 2020 2020 2020 636f 7272 6563 7469          correcti
+00015d30: 6f6e 2e20 4966 204e 6f6e 652c 2074 6865  on. If None, the
+00015d40: 2075 6e63 6f72 7265 6374 6564 206d 6561   uncorrected mea
+00015d50: 7375 7265 2069 730a 2020 2020 2020 2020  sure is.        
+00015d60: 2020 2020 7265 7475 726e 6564 2e20 2844      returned. (D
+00015d70: 6566 6175 6c74 3a20 4e6f 6e65 290a 2020  efault: None).  
+00015d80: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00015d90: 2020 6465 6620 745f 6675 6e63 2878 2c20    def t_func(x, 
+00015da0: 7854 293a 0a20 2020 2020 2020 2020 2020  xT):.           
+00015db0: 2072 6574 7572 6e20 7854 202a 2078 202a   return xT * x *
+00015dc0: 2078 0a20 2020 2020 2020 2069 6e6b 203d   x.        ink =
+00015dd0: 2073 656c 662e 6e73 695f 696e 6465 6772   self.nsi_indegr
+00015de0: 6565 2874 7970 6963 616c 5f77 6569 6768  ee(typical_weigh
+00015df0: 743d 7479 7069 6361 6c5f 7765 6967 6874  t=typical_weight
+00015e00: 290a 2020 2020 2020 2020 5420 3d20 696e  ).        T = in
+00015e10: 6b2a 2a32 0a20 2020 2020 2020 206b 7375  k**2.        ksu
+00015e20: 6d20 3d20 696e 6b20 2a20 320a 2020 2020  m = ink * 2.    
+00015e30: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00015e40: 5f6d 6f74 6966 5f63 6c75 7374 6572 696e  _motif_clusterin
+00015e50: 675f 6865 6c70 6572 280a 2020 2020 2020  g_helper(.      
+00015e60: 2020 2020 2020 745f 6675 6e63 2c20 542c        t_func, T,
+00015e70: 206b 6579 3d6b 6579 2c20 6e73 693d 5472   key=key, nsi=Tr
+00015e80: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
+00015e90: 7479 7069 6361 6c5f 7765 6967 6874 3d74  typical_weight=t
+00015ea0: 7970 6963 616c 5f77 6569 6768 742c 206b  ypical_weight, k
+00015eb0: 7375 6d3d 6b73 756d 290a 0a20 2020 2040  sum=ksum)..    @
+00015ec0: 4361 6368 6564 2e6d 6574 686f 6428 6e61  Cached.method(na
+00015ed0: 6d65 3d22 7468 6520 6c6f 6361 6c20 6e2e  me="the local n.
+00015ee0: 732e 692e 206f 7574 206d 6f74 6966 2063  s.i. out motif c
+00015ef0: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
+00015f00: 6369 656e 7473 222c 0a20 2020 2020 2020  cients",.       
+00015f10: 2020 2020 2020 2020 2020 2020 6174 7472              attr
+00015f20: 733d 2822 5f6d 7574 5f6e 7722 2c29 290a  s=("_mut_nw",)).
+00015f30: 2020 2020 6465 6620 6e73 695f 6c6f 6361      def nsi_loca
+00015f40: 6c5f 6f75 746d 6f74 6966 5f63 6c75 7374  l_outmotif_clust
+00015f50: 6572 696e 6728 7365 6c66 2c20 6b65 793d  ering(self, key=
+00015f60: 4e6f 6e65 2c20 7479 7069 6361 6c5f 7765  None, typical_we
+00015f70: 6967 6874 3d4e 6f6e 6529 3a0a 2020 2020  ight=None):.    
+00015f80: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00015f90: 466f 7220 6561 6368 206e 6f64 652c 2072  For each node, r
+00015fa0: 6574 7572 6e20 7468 6520 6e73 6920 636c  eturn the nsi cl
+00015fb0: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
+00015fc0: 6965 6e74 2077 6974 6820 7265 7370 6563  ient with respec
+00015fd0: 7420 746f 0a20 2020 2020 2020 2074 6865  t to.        the
+00015fe0: 206f 7574 206d 6f74 6966 2e0a 0a20 2020   out motif...   
+00015ff0: 2020 2020 2049 6620 6120 6c69 6e6b 2061       If a link a
+00016000: 7474 7269 6275 7465 206b 6579 2069 7320  ttribute key is 
+00016010: 7370 6563 6966 6965 642c 2072 6574 7572  specified, retur
+00016020: 6e20 7468 6520 6173 736f 6369 6174 6564  n the associated
+00016030: 206c 696e 6b0a 2020 2020 2020 2020 7765   link.        we
+00016040: 6967 6874 6564 2076 6572 7369 6f6e 2e0a  ighted version..
+00016050: 0a20 2020 2020 2020 2052 6566 6572 656e  .        Referen
+00016060: 6365 3a20 5b5a 656d 7032 3031 345d 5f0a  ce: [Zemp2014]_.
+00016070: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
+00016080: 6c65 733a 2a2a 0a0a 2020 2020 2020 2020  les:**..        
+00016090: 3e3e 3e20 6e65 7420 3d20 4e65 7477 6f72  >>> net = Networ
+000160a0: 6b2e 536d 616c 6c44 6972 6563 7465 6454  k.SmallDirectedT
+000160b0: 6573 744e 6574 776f 726b 2829 0a20 2020  estNetwork().   
+000160c0: 2020 2020 203e 3e3e 2072 286e 6574 2e6e       >>> r(net.n
+000160d0: 7369 5f6c 6f63 616c 5f6f 7574 6d6f 7469  si_local_outmoti
+000160e0: 665f 636c 7573 7465 7269 6e67 2829 290a  f_clustering()).
+000160f0: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00016100: 696e 6720 6c6f 6361 6c20 6e73 6920 6f75  ing local nsi ou
+00016110: 7420 6d6f 7469 6620 636c 7573 7465 7269  t motif clusteri
+00016120: 6e67 2063 6f65 6666 6963 6965 6e74 2e2e  ng coefficient..
+00016130: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+00016140: 5b20 302e 3637 2020 2c20 2030 2e36 3639  [ 0.67  ,  0.669
+00016150: 332c 2020 312e 2020 2020 2c20 2030 2e37  3,  1.    ,  0.7
+00016160: 3532 382c 2020 302e 3538 3339 2c20 2030  528,  0.5839,  0
+00016170: 2e37 3635 365d 290a 2020 2020 2020 2020  .7656]).        
+00016180: 3e3e 3e20 7228 6e65 742e 7370 6c69 7474  >>> r(net.splitt
+00016190: 6564 5f63 6f70 7928 6e6f 6465 3d30 292e  ed_copy(node=0).
+000161a0: 6e73 695f 6c6f 6361 6c5f 6f75 746d 6f74  nsi_local_outmot
+000161b0: 6966 5f63 6c75 7374 6572 696e 6728 2929  if_clustering())
+000161c0: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+000161d0: 7469 6e67 206c 6f63 616c 206e 7369 206f  ting local nsi o
+000161e0: 7574 206d 6f74 6966 2063 6c75 7374 6572  ut motif cluster
+000161f0: 696e 6720 636f 6566 6669 6369 656e 742e  ing coefficient.
+00016200: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
+00016210: 285b 2030 2e36 3720 202c 2020 302e 3636  ([ 0.67  ,  0.66
+00016220: 3933 2c20 2031 2e20 2020 202c 2020 302e  93,  1.    ,  0.
+00016230: 3735 3238 2c20 2030 2e35 3833 392c 2020  7528,  0.5839,  
+00016240: 302e 3736 3536 2c20 2030 2e36 3720 205d  0.7656,  0.67  ]
+00016250: 290a 0a20 2020 2020 2020 2061 7320 636f  )..        as co
+00016260: 6d70 6172 6564 2074 6f20 7468 6520 756e  mpared to the un
+00016270: 7765 6967 6874 6564 2076 6572 7369 6f6e  weighted version
+00016280: 3a0a 0a20 2020 2020 2020 203e 3e3e 206e  :..        >>> n
+00016290: 6574 203d 204e 6574 776f 726b 2e53 6d61  et = Network.Sma
+000162a0: 6c6c 4469 7265 6374 6564 5465 7374 4e65  llDirectedTestNe
+000162b0: 7477 6f72 6b28 290a 2020 2020 2020 2020  twork().        
+000162c0: 3e3e 3e20 7228 6e65 742e 6c6f 6361 6c5f  >>> r(net.local_
+000162d0: 6f75 746d 6f74 6966 5f63 6c75 7374 6572  outmotif_cluster
+000162e0: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
+000162f0: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
+00016300: 206f 7574 206d 6f74 6966 2063 6c75 7374   out motif clust
+00016310: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+00016320: 742e 2e2e 0a20 2020 2020 2020 2061 7272  t....        arr
+00016330: 6179 285b 2030 2e35 2c20 2030 2e35 2c20  ay([ 0.5,  0.5, 
+00016340: 2030 2e20 2c20 2030 2e20 2c20 2030 2e20   0. ,  0. ,  0. 
+00016350: 2c20 2030 2e20 5d29 0a20 2020 2020 2020  ,  0. ]).       
+00016360: 203e 3e3e 2072 286e 6574 2e73 706c 6974   >>> r(net.split
+00016370: 7465 645f 636f 7079 286e 6f64 653d 3029  ted_copy(node=0)
+00016380: 2e6c 6f63 616c 5f6f 7574 6d6f 7469 665f  .local_outmotif_
+00016390: 636c 7573 7465 7269 6e67 2829 290a 2020  clustering()).  
+000163a0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+000163b0: 6720 6c6f 6361 6c20 6f75 7420 6d6f 7469  g local out moti
+000163c0: 6620 636c 7573 7465 7269 6e67 2063 6f65  f clustering coe
+000163d0: 6666 6963 6965 6e74 2e2e 2e0a 2020 2020  fficient....    
+000163e0: 2020 2020 6172 7261 7928 5b20 302e 3520      array([ 0.5 
+000163f0: 2020 2c20 2030 2e35 2020 202c 2020 302e    ,  0.5   ,  0.
+00016400: 2020 2020 2c20 2030 2e20 2020 202c 2020      ,  0.    ,  
+00016410: 302e 3333 3333 2c20 2031 2e20 2020 202c  0.3333,  1.    ,
+00016420: 2020 302e 3520 2020 5d29 0a0a 2020 2020    0.5   ])..    
+00016430: 2020 2020 3a61 7267 2073 7472 206b 6579      :arg str key
+00016440: 3a20 6c69 6e6b 2061 7474 7269 6275 7465  : link attribute
+00016450: 206b 6579 2028 6f70 7469 6f6e 616c 290a   key (optional).
+00016460: 2020 2020 2020 2020 3a74 7970 6520 7479          :type ty
+00016470: 7069 6361 6c5f 7765 6967 6874 3a20 666c  pical_weight: fl
+00016480: 6f61 7420 3e20 300a 2020 2020 2020 2020  oat > 0.        
+00016490: 3a61 7267 2066 6c6f 6174 2074 7970 6963  :arg float typic
+000164a0: 616c 5f77 6569 6768 743a 204f 7074 696f  al_weight: Optio
+000164b0: 6e61 6c20 7479 7069 6361 6c20 6e6f 6465  nal typical node
+000164c0: 2077 6569 6768 7420 746f 2062 6520 7573   weight to be us
+000164d0: 6564 2066 6f72 0a20 2020 2020 2020 2020  ed for.         
+000164e0: 2020 2063 6f72 7265 6374 696f 6e2e 2049     correction. I
+000164f0: 6620 4e6f 6e65 2c20 7468 6520 756e 636f  f None, the unco
+00016500: 7272 6563 7465 6420 6d65 6173 7572 6520  rrected measure 
+00016510: 6973 0a20 2020 2020 2020 2020 2020 2072  is.            r
+00016520: 6574 7572 6e65 642e 2028 4465 6661 756c  eturned. (Defaul
+00016530: 743a 204e 6f6e 6529 0a20 2020 2020 2020  t: None).       
+00016540: 2022 2222 0a20 2020 2020 2020 2064 6566   """.        def
+00016550: 2074 5f66 756e 6328 782c 2078 5429 3a0a   t_func(x, xT):.
+00016560: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00016570: 726e 2078 202a 2078 202a 2078 540a 2020  rn x * x * xT.  
+00016580: 2020 2020 2020 6f75 746b 203d 2073 656c        outk = sel
+00016590: 662e 6e73 695f 6f75 7464 6567 7265 6528  f.nsi_outdegree(
+000165a0: 7479 7069 6361 6c5f 7765 6967 6874 3d74  typical_weight=t
+000165b0: 7970 6963 616c 5f77 6569 6768 7429 0a20  ypical_weight). 
+000165c0: 2020 2020 2020 2054 203d 206f 7574 6b2a         T = outk*
+000165d0: 2a32 0a20 2020 2020 2020 206b 7375 6d20  *2.        ksum 
+000165e0: 3d20 6f75 746b 202a 2032 0a20 2020 2020  = outk * 2.     
+000165f0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+00016600: 6d6f 7469 665f 636c 7573 7465 7269 6e67  motif_clustering
+00016610: 5f68 656c 7065 7228 0a20 2020 2020 2020  _helper(.       
+00016620: 2020 2020 2074 5f66 756e 632c 2054 2c20       t_func, T, 
+00016630: 6b65 793d 6b65 792c 206e 7369 3d54 7275  key=key, nsi=Tru
+00016640: 652c 0a20 2020 2020 2020 2020 2020 2074  e,.            t
+00016650: 7970 6963 616c 5f77 6569 6768 743d 7479  ypical_weight=ty
+00016660: 7069 6361 6c5f 7765 6967 6874 2c20 6b73  pical_weight, ks
+00016670: 756d 3d6b 7375 6d29 0a0a 2020 2020 4043  um=ksum)..    @C
+00016680: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+00016690: 653d 2274 7261 6e73 6974 6976 6974 7920  e="transitivity 
+000166a0: 636f 6566 6669 6369 656e 7420 2843 5f31  coefficient (C_1
+000166b0: 2922 290a 2020 2020 6465 6620 7472 616e  )").    def tran
+000166c0: 7369 7469 7669 7479 2873 656c 6629 3a0a  sitivity(self):.
+000166d0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000166e0: 2020 2020 5265 7475 726e 2074 6865 2074      Return the t
+000166f0: 7261 6e73 6974 6976 6974 7920 2863 6f65  ransitivity (coe
+00016700: 6666 6963 6965 6e74 292e 0a0a 2020 2020  fficient)...    
+00016710: 2020 2020 5468 6973 2069 7320 7468 6520      This is the 
+00016720: 7261 7469 6f20 6f66 2074 6872 6565 2074  ratio of three t
+00016730: 696d 6573 2074 6865 206e 756d 6265 7220  imes the number 
+00016740: 6f66 2074 7269 616e 676c 6573 2074 6f20  of triangles to 
+00016750: 7468 6520 6e75 6d62 6572 0a20 2020 2020  the number.     
+00016760: 2020 206f 6620 636f 6e6e 6563 7465 6420     of connected 
+00016770: 7472 6970 6c65 7320 6f66 2076 6572 7469  triples of verti
+00016780: 6365 732e 205b 4e65 776d 616e 3230 3033  ces. [Newman2003
+00016790: 5d5f 2072 6566 6572 7320 746f 2074 6869  ]_ refers to thi
+000167a0: 7320 6d65 6173 7572 650a 2020 2020 2020  s measure.      
+000167b0: 2020 6173 2043 5f31 2e0a 0a20 2020 2020    as C_1...     
+000167c0: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
+000167d0: 0a20 2020 2020 2020 203e 3e3e 2072 284e  .        >>> r(N
+000167e0: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
+000167f0: 4e65 7477 6f72 6b28 292e 7472 616e 7369  Network().transi
+00016800: 7469 7669 7479 2829 290a 2020 2020 2020  tivity()).      
+00016810: 2020 4361 6c63 756c 6174 696e 6720 7472    Calculating tr
+00016820: 616e 7369 7469 7669 7479 2063 6f65 6666  ansitivity coeff
+00016830: 6963 6965 6e74 2028 435f 3129 2e2e 2e0a  icient (C_1)....
+00016840: 2020 2020 2020 2020 302e 3237 3237 0a0a          0.2727..
+00016850: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00016860: 666c 6f61 7420 6265 7477 6565 6e20 3020  float between 0 
+00016870: 616e 6420 310a 2020 2020 2020 2020 2222  and 1.        ""
+00016880: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+00016890: 2073 656c 662e 6772 6170 682e 7472 616e   self.graph.tran
+000168a0: 7369 7469 7669 7479 5f75 6e64 6972 6563  sitivity_undirec
+000168b0: 7465 6428 290a 0a20 2020 2064 6566 2068  ted()..    def h
+000168c0: 6967 6865 725f 6f72 6465 725f 7472 616e  igher_order_tran
+000168d0: 7369 7469 7669 7479 2873 656c 662c 206f  sitivity(self, o
+000168e0: 7264 6572 2c20 6573 7469 6d61 7465 3d46  rder, estimate=F
+000168f0: 616c 7365 293a 0a20 2020 2020 2020 2022  alse):.        "
+00016900: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
+00016910: 6e20 7472 616e 7369 7469 7669 7479 206f  n transitivity o
+00016920: 6620 6120 6365 7274 6169 6e20 6f72 6465  f a certain orde
+00016930: 722e 0a0a 2020 2020 2020 2020 5468 6520  r...        The 
+00016940: 7472 616e 7369 7469 7669 7479 206f 6620  transitivity of 
+00016950: 6f72 6465 7220 6e20 6973 2064 6566 696e  order n is defin
+00016960: 6564 2061 733a 0a20 2020 2020 2020 2020  ed as:.         
+00016970: 2d20 286e 2078 204e 756d 6265 7220 6f66  - (n x Number of
+00016980: 2063 6c69 7175 6573 206f 6620 6e20 6e6f   cliques of n no
+00016990: 6465 7329 202f 2028 4e75 6d62 6572 206f  des) / (Number o
+000169a0: 6620 7374 6172 7320 6f66 206e 206e 6f64  f stars of n nod
+000169b0: 6573 290a 0a20 2020 2020 2020 2049 7420  es)..        It 
+000169c0: 6973 2061 2067 656e 6572 616c 697a 6174  is a generalizat
+000169d0: 696f 6e20 6f66 2074 6865 2073 7461 6e64  ion of the stand
+000169e0: 6172 6420 6e65 7477 6f72 6b20 7472 616e  ard network tran
+000169f0: 7369 7469 7669 7479 2c20 7768 6963 6820  sitivity, which 
+00016a00: 6973 0a20 2020 2020 2020 2069 6e63 6c75  is.        inclu
+00016a10: 6465 6420 6173 2061 2073 7065 6369 616c  ded as a special
+00016a20: 2063 6173 6520 666f 7220 6e20 3d20 332e   case for n = 3.
+00016a30: 0a0a 2020 2020 2020 2020 3a61 7267 2069  ..        :arg i
+00016a40: 6e74 206f 7264 6572 3a20 5468 6520 6f72  nt order: The or
+00016a50: 6465 7220 286e 756d 6265 7220 6f66 206e  der (number of n
+00016a60: 6f64 6573 2920 6f66 2063 6c69 7175 6573  odes) of cliques
+00016a70: 2074 6f20 6265 0a20 2020 2020 2020 2020   to be.         
+00016a80: 2020 2063 6f6e 7369 6465 7265 642e 0a20     considered.. 
+00016a90: 2020 2020 2020 203a 6172 6720 626f 6f6c         :arg bool
+00016aa0: 2065 7374 696d 6174 653a 2054 6f67 676c   estimate: Toggl
+00016ab0: 6573 2072 616e 646f 6d20 7361 6d70 6c69  es random sampli
+00016ac0: 6e67 2066 6f72 2065 7374 696d 6174 696e  ng for estimatin
+00016ad0: 6720 6869 6768 6572 206f 7264 6572 0a20  g higher order. 
+00016ae0: 2020 2020 2020 2020 2020 2074 7261 6e73             trans
+00016af0: 6974 6976 6974 7920 286d 7563 6820 6661  itivity (much fa
+00016b00: 7374 6572 2074 6861 6e20 6578 6163 7420  ster than exact 
+00016b10: 6361 6c63 756c 6174 696f 6e29 2e0a 2020  calculation)..  
+00016b20: 2020 2020 2020 3a72 7479 7065 3a20 6e75        :rtype: nu
+00016b30: 6d62 6572 2028 666c 6f61 7429 2062 6574  mber (float) bet
+00016b40: 7765 656e 2030 2061 6e64 2031 0a20 2020  ween 0 and 1.   
+00016b50: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00016b60: 2069 6620 7365 6c66 2e73 696c 656e 6365   if self.silence
+00016b70: 5f6c 6576 656c 203c 3d20 313a 0a20 2020  _level <= 1:.   
+00016b80: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+00016b90: 4361 6c63 756c 6174 696e 6720 7472 616e  Calculating tran
+00016ba0: 7369 7469 7669 7479 206f 6620 6f72 6465  sitivity of orde
+00016bb0: 7222 2c20 6f72 6465 722c 2022 2e2e 2e22  r", order, "..."
+00016bc0: 290a 0a20 2020 2020 2020 2069 6620 6f72  )..        if or
+00016bd0: 6465 7220 696e 205b 302c 2031 2c20 325d  der in [0, 1, 2]
+00016be0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00016bf0: 6973 6520 4e65 7477 6f72 6b45 7272 6f72  ise NetworkError
+00016c00: 2822 4869 6768 6572 206f 7264 6572 2074  ("Higher order t
+00016c10: 7261 6e73 6974 6976 6974 7920 6973 206e  ransitivity is n
+00016c20: 6f74 2064 6566 696e 6564 2066 6f72 205c  ot defined for \
+00016c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016c50: 6f72 6465 7273 2030 2c20 3120 616e 6420  orders 0, 1 and 
+00016c60: 322e 2229 0a20 2020 2020 2020 2069 6620  2.").        if 
+00016c70: 6f72 6465 7220 3d3d 2033 3a0a 2020 2020  order == 3:.    
+00016c80: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00016c90: 656c 662e 7472 616e 7369 7469 7669 7479  elf.transitivity
+00016ca0: 2829 0a0a 2020 2020 2020 2020 6966 206f  ()..        if o
+00016cb0: 7264 6572 203d 3d20 343a 0a20 2020 2020  rder == 4:.     
+00016cc0: 2020 2020 2020 2069 6620 6573 7469 6d61         if estima
+00016cd0: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
+00016ce0: 2020 2020 6d6f 7469 665f 636f 756e 7473      motif_counts
+00016cf0: 203d 2073 656c 662e 6772 6170 682e 6d6f   = self.graph.mo
+00016d00: 7469 6673 5f72 616e 6465 7375 280a 2020  tifs_randesu(.  
+00016d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016d20: 2020 7369 7a65 3d34 2c20 6375 745f 7072    size=4, cut_pr
+00016d30: 6f62 3d5b 302e 352c 2030 2e35 2c20 302e  ob=[0.5, 0.5, 0.
+00016d40: 352c 2030 2e35 5d29 0a20 2020 2020 2020  5, 0.5]).       
+00016d50: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00016d60: 2020 2020 2020 2020 2020 206d 6f74 6966             motif
+00016d70: 5f63 6f75 6e74 7320 3d20 7365 6c66 2e67  _counts = self.g
+00016d80: 7261 7068 2e6d 6f74 6966 735f 7261 6e64  raph.motifs_rand
+00016d90: 6573 7528 7369 7a65 3d34 290a 0a20 2020  esu(size=4)..   
+00016da0: 2020 2020 2020 2020 2023 2020 5375 6d20           #  Sum 
+00016db0: 6f76 6572 2061 6c6c 206d 6f74 6966 7320  over all motifs 
+00016dc0: 7468 6174 2063 6f6e 7461 696e 2061 2073  that contain a s
+00016dd0: 7461 720a 2020 2020 2020 2020 2020 2020  tar.            
+00016de0: 6e5f 7374 6172 7320 3d20 6d6f 7469 665f  n_stars = motif_
+00016df0: 636f 756e 7473 5b34 5d20 2b20 6d6f 7469  counts[4] + moti
+00016e00: 665f 636f 756e 7473 5b37 5d20 2b20 5c0a  f_counts[7] + \.
+00016e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016e20: 3220 2a20 6d6f 7469 665f 636f 756e 7473  2 * motif_counts
+00016e30: 5b39 5d20 2b20 3420 2a20 6d6f 7469 665f  [9] + 4 * motif_
+00016e40: 636f 756e 7473 5b31 305d 0a20 2020 2020  counts[10].     
+00016e50: 2020 2020 2020 206e 5f63 6c69 7175 6573         n_cliques
+00016e60: 203d 206d 6f74 6966 5f63 6f75 6e74 735b   = motif_counts[
+00016e70: 3130 5d0a 0a20 2020 2020 2020 2020 2020  10]..           
+00016e80: 2023 2070 7269 6e74 286d 6f74 6966 5f63   # print(motif_c
+00016e90: 6f75 6e74 7329 0a0a 2020 2020 2020 2020  ounts)..        
+00016ea0: 2020 2020 6966 206e 5f73 7461 7273 2021      if n_stars !
+00016eb0: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+00016ec0: 2020 2020 2072 6574 7572 6e20 3420 2a20       return 4 * 
+00016ed0: 6e5f 636c 6971 7565 7320 2f20 666c 6f61  n_cliques / floa
+00016ee0: 7428 6e5f 7374 6172 7329 0a20 2020 2020  t(n_stars).     
+00016ef0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00016f00: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00016f10: 7572 6e20 302e 0a0a 2020 2020 2020 2020  urn 0...        
+00016f20: 6966 206f 7264 6572 203e 2034 3a0a 2020  if order > 4:.  
+00016f30: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00016f40: 4e6f 7449 6d70 6c65 6d65 6e74 6564 4572  NotImplementedEr
+00016f50: 726f 7228 2248 6967 6865 7220 6f72 6465  ror("Higher orde
+00016f60: 7220 7472 616e 7369 7469 7669 7479 2069  r transitivity i
+00016f70: 7320 6e6f 7420 7965 7420 5c0a 2020 2020  s not yet \.    
+00016f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016fa0: 2020 696d 706c 656d 656e 7465 6420 666f    implemented fo
+00016fb0: 7220 6f72 6465 7273 206c 6172 6765 7220  r orders larger 
+00016fc0: 7468 616e 2034 2e22 290a 0a20 2020 2020  than 4.")..     
+00016fd0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00016fe0: 726f 7228 224f 7264 6572 2068 6173 2074  ror("Order has t
+00016ff0: 6f20 6265 2061 2070 6f73 6974 6976 6520  o be a positive 
+00017000: 696e 7465 6765 722e 2229 0a0a 2020 2020  integer.")..    
+00017010: 6465 6620 6c6f 6361 6c5f 636c 6971 7569  def local_cliqui
+00017020: 7368 6e65 7373 2873 656c 662c 206f 7264  shness(self, ord
+00017030: 6572 293a 0a20 2020 2020 2020 2022 2222  er):.        """
+00017040: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
+00017050: 6c6f 6361 6c20 636c 6971 7569 7368 6e65  local cliquishne
+00017060: 7373 206f 6620 6120 6365 7274 6169 6e20  ss of a certain 
+00017070: 6f72 6465 722e 0a0a 2020 2020 2020 2020  order...        
+00017080: 5468 6520 6c6f 6361 6c20 636c 6971 7569  The local cliqui
+00017090: 7368 6e65 7373 206d 6561 7375 7265 7320  shness measures 
+000170a0: 7468 6520 7265 6c61 7469 7665 206e 756d  the relative num
+000170b0: 6265 7220 6f66 2063 6c69 7175 6573 2028  ber of cliques (
+000170c0: 6675 6c6c 790a 2020 2020 2020 2020 636f  fully.        co
+000170d0: 6e6e 6563 7465 6420 7375 6267 7261 7068  nnected subgraph
+000170e0: 7329 206f 6620 6120 6365 7274 6169 6e20  s) of a certain 
+000170f0: 6f72 6465 7220 7468 6174 2061 206e 6f64  order that a nod
+00017100: 6520 7061 7274 6963 6970 6174 6573 2069  e participates i
+00017110: 6e2e 0a0a 2020 2020 2020 2020 4c6f 6361  n...        Loca
+00017120: 6c20 636c 6971 7569 7368 6e65 7373 2069  l cliquishness i
+00017130: 7320 6e6f 7420 6465 6669 6e65 6420 666f  s not defined fo
+00017140: 7220 6f72 6465 7273 2031 2061 6e64 2032  r orders 1 and 2
+00017150: 2e20 466f 7220 6f72 6465 7220 332c 0a20  . For order 3,. 
+00017160: 2020 2020 2020 2069 7420 6973 2065 7175         it is equ
+00017170: 6976 616c 656e 7420 746f 2074 6865 206c  ivalent to the l
+00017180: 6f63 616c 2063 6c75 7374 6572 696e 6720  ocal clustering 
+00017190: 636f 6566 6669 6369 656e 740a 2020 2020  coefficient.    
+000171a0: 2020 2020 3a6d 6574 683a 606c 6f63 616c      :meth:`local
+000171b0: 5f63 6c75 7374 6572 696e 6760 2c20 7369  _clustering`, si
+000171c0: 6e63 6520 636c 6971 7565 7320 6f66 206f  nce cliques of o
+000171d0: 7264 6572 2033 2061 7265 2074 7269 616e  rder 3 are trian
+000171e0: 676c 6573 2e0a 0a20 2020 2020 2020 204c  gles...        L
+000171f0: 6f63 616c 2063 6c69 7175 6973 686e 6573  ocal cliquishnes
+00017200: 7320 6973 2061 6c77 6179 7320 626f 756e  s is always boun
+00017210: 6465 6420 6279 2030 2061 6e64 2031 2061  ded by 0 and 1 a
+00017220: 6e64 2073 6574 2074 6f20 7a65 726f 2066  nd set to zero f
+00017230: 6f72 0a20 2020 2020 2020 206e 6f64 6573  or.        nodes
+00017240: 2077 6974 6820 6465 6772 6565 2073 6d61   with degree sma
+00017250: 6c6c 6572 2074 6861 6e20 6f72 6465 7220  ller than order 
+00017260: 2d20 312e 0a0a 2020 2020 2020 2020 3a74  - 1...        :t
+00017270: 7970 6520 6f72 6465 723a 206e 756d 6265  ype order: numbe
+00017280: 7220 2869 6e74 290a 2020 2020 2020 2020  r (int).        
+00017290: 3a61 7267 206f 7264 6572 3a20 5468 6520  :arg order: The 
+000172a0: 6f72 6465 7220 286e 756d 6265 7220 6f66  order (number of
+000172b0: 206e 6f64 6573 2920 6f66 2063 6c69 7175   nodes) of cliqu
+000172c0: 6573 2074 6f20 6265 2063 6f6e 7369 6465  es to be conside
+000172d0: 7265 642e 0a0a 2020 2020 2020 2020 3a72  red...        :r
+000172e0: 7479 7065 3a20 3164 206e 756d 7079 2061  type: 1d numpy a
+000172f0: 7272 6179 205b 6e6f 6465 5d20 6f66 2066  rray [node] of f
+00017300: 6c6f 6174 7320 6265 7477 6565 6e20 3020  loats between 0 
+00017310: 616e 6420 310a 2020 2020 2020 2020 2222  and 1.        ""
+00017320: 220a 2020 2020 2020 2020 6966 2073 656c  ".        if sel
+00017330: 662e 6469 7265 6374 6564 3a0a 2020 2020  f.directed:.    
+00017340: 2020 2020 2020 2020 7261 6973 6520 4e65          raise Ne
+00017350: 7477 6f72 6b45 7272 6f72 2822 4e6f 7420  tworkError("Not 
+00017360: 696d 706c 656d 656e 7465 6420 7965 742e  implemented yet.
+00017370: 2e2e 2229 0a0a 2020 2020 2020 2020 6966  ..")..        if
+00017380: 2073 656c 662e 7369 6c65 6e63 655f 6c65   self.silence_le
+00017390: 7665 6c20 3c3d 2031 3a0a 2020 2020 2020  vel <= 1:.      
+000173a0: 2020 2020 2020 7072 696e 7428 2243 616c        print("Cal
+000173b0: 6375 6c61 7469 6e67 206c 6f63 616c 2063  culating local c
+000173c0: 6c69 7175 6973 686e 6573 7320 6f66 206f  liquishness of o
+000173d0: 7264 6572 222c 206f 7264 6572 2c20 222e  rder", order, ".
+000173e0: 2e2e 2229 0a0a 2020 2020 2020 2020 6966  ..")..        if
+000173f0: 206f 7264 6572 2069 6e20 5b30 2c20 312c   order in [0, 1,
+00017400: 2032 5d3a 0a20 2020 2020 2020 2020 2020   2]:.           
+00017410: 2072 6169 7365 204e 6574 776f 726b 4572   raise NetworkEr
+00017420: 726f 7228 224c 6f63 616c 2063 6c69 7175  ror("Local cliqu
+00017430: 6973 686e 6573 7320 6973 206e 6f74 2064  ishness is not d
+00017440: 6566 696e 6564 2066 6f72 206f 7264 6572  efined for order
+00017450: 7320 5c0a 2020 2020 2020 2020 2020 2020  s \.            
+00017460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017470: 2020 2030 2c20 3120 616e 6420 322e 2229     0, 1 and 2.")
+00017480: 0a0a 2020 2020 2020 2020 6966 206f 7264  ..        if ord
+00017490: 6572 203d 3d20 333a 0a20 2020 2020 2020  er == 3:.       
+000174a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+000174b0: 2e6c 6f63 616c 5f63 6c75 7374 6572 696e  .local_clusterin
+000174c0: 6728 290a 0a20 2020 2020 2020 2069 6620  g()..        if 
+000174d0: 6f72 6465 7220 3d3d 2034 3a0a 2020 2020  order == 4:.    
+000174e0: 2020 2020 2020 2020 7265 7475 726e 205f          return _
+000174f0: 6c6f 6361 6c5f 636c 6971 7569 7368 6e65  local_cliquishne
+00017500: 7373 5f34 7468 6f72 6465 7228 0a20 2020  ss_4thorder(.   
+00017510: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00017520: 662e 4e2c 2074 6f5f 6379 2873 656c 662e  f.N, to_cy(self.
+00017530: 6164 6a61 6365 6e63 792c 2041 444a 292c  adjacency, ADJ),
+00017540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00017550: 2074 6f5f 6379 2873 656c 662e 6465 6772   to_cy(self.degr
+00017560: 6565 2829 2c20 4445 4752 4545 2929 0a20  ee(), DEGREE)). 
+00017570: 2020 2020 2020 2069 6620 6f72 6465 7220         if order 
+00017580: 3d3d 2035 3a0a 2020 2020 2020 2020 2020  == 5:.          
+00017590: 2020 7265 7475 726e 205f 6c6f 6361 6c5f    return _local_
+000175a0: 636c 6971 7569 7368 6e65 7373 5f35 7468  cliquishness_5th
+000175b0: 6f72 6465 7228 0a20 2020 2020 2020 2020  order(.         
+000175c0: 2020 2020 2020 2073 656c 662e 4e2c 2074         self.N, t
+000175d0: 6f5f 6379 2873 656c 662e 6164 6a61 6365  o_cy(self.adjace
+000175e0: 6e63 792c 2041 444a 292c 0a20 2020 2020  ncy, ADJ),.     
+000175f0: 2020 2020 2020 2020 2020 2074 6f5f 6379             to_cy
+00017600: 2873 656c 662e 6465 6772 6565 2829 2c20  (self.degree(), 
+00017610: 4445 4752 4545 2929 0a20 2020 2020 2020  DEGREE)).       
+00017620: 2069 6620 6f72 6465 7220 3e20 353a 0a20   if order > 5:. 
+00017630: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00017640: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
+00017650: 7272 6f72 2822 4c6f 6361 6c20 636c 6971  rror("Local cliq
+00017660: 7569 7368 6e65 7373 2069 7320 6e6f 7420  uishness is not 
+00017670: 7965 7420 5c0a 2020 2020 2020 2020 2020  yet \.          
+00017680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017690: 2020 2020 2020 2020 2020 2020 696d 706c              impl
+000176a0: 656d 656e 7465 6420 666f 7220 6f72 6465  emented for orde
+000176b0: 7273 206c 6172 6765 7220 7468 616e 2035  rs larger than 5
+000176c0: 2e22 290a 0a20 2020 2020 2020 2072 6169  .")..        rai
+000176d0: 7365 2056 616c 7565 4572 726f 7228 224f  se ValueError("O
+000176e0: 7264 6572 2068 6173 2074 6f20 6265 2061  rder has to be a
+000176f0: 2070 6f73 6974 6976 6520 696e 7465 6765   positive intege
+00017700: 722e 2229 0a0a 2020 2020 4073 7461 7469  r.")..    @stati
+00017710: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
+00017720: 7765 6967 6874 6564 5f6c 6f63 616c 5f63  weighted_local_c
+00017730: 6c75 7374 6572 696e 6728 7765 6967 6874  lustering(weight
+00017740: 6564 5f41 293a 0a20 2020 2020 2020 2022  ed_A):.        "
+00017750: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
+00017760: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
+00017770: 2069 7473 2077 6569 6768 7465 6420 636c   its weighted cl
+00017780: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
+00017790: 6965 6e74 2c0a 2020 2020 2020 2020 6769  ient,.        gi
+000177a0: 7665 6e20 6120 7765 6967 6874 6564 2061  ven a weighted a
+000177b0: 646a 6163 656e 6379 206d 6174 7269 782e  djacency matrix.
+000177c0: 0a0a 2020 2020 2020 2020 5468 6973 2066  ..        This f
+000177d0: 6f6c 6c6f 7773 205b 486f 6c6d 6532 3030  ollows [Holme200
+000177e0: 375d 5f2e 0a0a 2020 2020 2020 2020 2a2a  7]_...        **
+000177f0: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
+00017800: 2020 2020 3e3e 3e20 7072 696e 7428 7228      >>> print(r(
+00017810: 4e65 7477 6f72 6b2e 7765 6967 6874 6564  Network.weighted
+00017820: 5f6c 6f63 616c 5f63 6c75 7374 6572 696e  _local_clusterin
+00017830: 6728 7765 6967 6874 6564 5f41 3d5b 0a20  g(weighted_A=[. 
+00017840: 2020 2020 2020 202e 2e2e 2020 2020 205b         ...     [
+00017850: 2030 2e20 202c 2030 2e20 202c 2030 2e20   0.  , 0.  , 0. 
+00017860: 202c 2030 2e35 352c 2030 2e36 352c 2030   , 0.55, 0.65, 0
+00017870: 2e37 355d 2c0a 2020 2020 2020 2020 2e2e  .75],.        ..
+00017880: 2e20 2020 2020 5b20 302e 2020 2c20 302e  .     [ 0.  , 0.
+00017890: 2020 2c20 302e 3633 2c20 302e 3737 2c20    , 0.63, 0.77, 
+000178a0: 302e 3931 2c20 302e 2020 5d2c 0a20 2020  0.91, 0.  ],.   
+000178b0: 2020 2020 202e 2e2e 2020 2020 205b 2030       ...     [ 0
+000178c0: 2e20 202c 2030 2e36 332c 2030 2e20 202c  .  , 0.63, 0.  ,
+000178d0: 2030 2e20 202c 2031 2e31 372c 2030 2e20   0.  , 1.17, 0. 
+000178e0: 205d 2c0a 2020 2020 2020 2020 2e2e 2e20   ],.        ... 
+000178f0: 2020 2020 5b20 302e 3535 2c20 302e 3737      [ 0.55, 0.77
+00017900: 2c20 302e 2020 2c20 302e 2020 2c20 302e  , 0.  , 0.  , 0.
+00017910: 2020 2c20 302e 2020 5d2c 0a20 2020 2020    , 0.  ],.     
+00017920: 2020 202e 2e2e 2020 2020 205b 2030 2e36     ...     [ 0.6
+00017930: 352c 2030 2e39 312c 2031 2e31 372c 2030  5, 0.91, 1.17, 0
+00017940: 2e20 202c 2030 2e20 202c 2030 2e20 205d  .  , 0.  , 0.  ]
+00017950: 2c0a 2020 2020 2020 2020 2e2e 2e20 2020  ,.        ...   
+00017960: 2020 5b20 302e 3735 2c20 302e 2020 2c20    [ 0.75, 0.  , 
+00017970: 302e 2020 2c20 302e 2020 2c20 302e 2020  0.  , 0.  , 0.  
+00017980: 2c20 302e 2020 5d5d 2929 290a 2020 2020  , 0.  ]]))).    
+00017990: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+000179a0: 6c6f 6361 6c20 7765 6967 6874 6564 2063  local weighted c
+000179b0: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
+000179c0: 6369 656e 742e 2e2e 0a20 2020 2020 2020  cient....       
+000179d0: 205b 2030 2e20 2030 2e32 3134 3920 2030   [ 0.  0.2149  0
+000179e0: 2e33 3533 3920 2030 2e20 2030 2e31 3533  .3539  0.  0.153
+000179f0: 3820 2030 2e20 5d0a 0a20 2020 2020 2020  8  0. ]..       
+00017a00: 2061 7320 636f 6d70 6172 6564 2074 6f20   as compared to 
+00017a10: 7468 6520 756e 7765 6967 6874 6564 2076  the unweighted v
+00017a20: 6572 7369 6f6e 3a0a 0a20 2020 2020 2020  ersion:..       
+00017a30: 203e 3e3e 2070 7269 6e74 2872 284e 6574   >>> print(r(Net
+00017a40: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
+00017a50: 7477 6f72 6b28 292e 6c6f 6361 6c5f 636c  twork().local_cl
+00017a60: 7573 7465 7269 6e67 2829 2929 0a20 2020  ustering())).   
+00017a70: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+00017a80: 206c 6f63 616c 2063 6c75 7374 6572 696e   local clusterin
+00017a90: 6720 636f 6566 6669 6369 656e 7473 2e2e  g coefficients..
+00017aa0: 2e0a 2020 2020 2020 2020 5b20 302e 2020  ..        [ 0.  
+00017ab0: 302e 3333 3333 2020 312e 2020 302e 2020  0.3333  1.  0.  
+00017ac0: 302e 3333 3333 2020 302e 205d 0a0a 2020  0.3333  0. ]..  
+00017ad0: 2020 2020 2020 3a74 7970 6520 7765 6967        :type weig
+00017ae0: 6874 6564 5f41 3a20 7371 7561 7265 206e  hted_A: square n
+00017af0: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
+00017b00: 2c6e 6f64 655d 206f 6620 666c 6f61 7473  ,node] of floats
+00017b10: 203e 3d20 300a 2020 2020 2020 2020 3a61   >= 0.        :a
+00017b20: 7267 2020 7765 6967 6874 6564 5f41 3a20  rg  weighted_A: 
+00017b30: 456e 7472 7920 5b69 2c6a 5d20 6973 2074  Entry [i,j] is t
+00017b40: 6865 206c 696e 6b20 7765 6967 6874 2066  he link weight f
+00017b50: 726f 6d20 6920 746f 206a 2e0a 2020 2020  rom i to j..    
+00017b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017b70: 2020 2020 2020 4120 7661 6c75 6520 6f66        A value of
+00017b80: 2030 206d 6561 6e73 2074 6865 7265 2069   0 means there i
+00017b90: 7320 6e6f 206c 696e 6b2e 0a0a 2020 2020  s no link...    
+00017ba0: 2020 2020 3a72 7479 7065 3a20 3164 206e      :rtype: 1d n
+00017bb0: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
+00017bc0: 5d20 6f66 2066 6c6f 6174 7320 6265 7477  ] of floats betw
+00017bd0: 6565 6e20 3020 616e 6420 310a 2020 2020  een 0 and 1.    
+00017be0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00017bf0: 2320 544f 444f 3a20 6d75 7374 2062 6520  # TODO: must be 
+00017c00: 7379 6d6d 6574 7269 633f 2064 6972 6563  symmetric? direc
+00017c10: 7465 6420 7665 7273 696f 6e3f 0a20 2020  ted version?.   
+00017c20: 2020 2020 2070 7269 6e74 2822 4361 6c63       print("Calc
+00017c30: 756c 6174 696e 6720 6c6f 6361 6c20 7765  ulating local we
+00017c40: 6967 6874 6564 2063 6c75 7374 6572 696e  ighted clusterin
+00017c50: 6720 636f 6566 6669 6369 656e 742e 2e2e  g coefficient...
+00017c60: 2229 0a0a 2020 2020 2020 2020 7741 203d  ")..        wA =
+00017c70: 206e 702e 6172 7261 7928 7765 6967 6874   np.array(weight
+00017c80: 6564 5f41 290a 2020 2020 2020 2020 6d61  ed_A).        ma
+00017c90: 785f 7720 3d20 6e70 2e6f 6e65 735f 6c69  x_w = np.ones_li
+00017ca0: 6b65 2877 4129 2e64 6f74 2877 412e 6d61  ke(wA).dot(wA.ma
+00017cb0: 7828 2929 0a20 2020 2020 2020 2072 6574  x()).        ret
+00017cc0: 7572 6e20 286e 702e 6c69 6e61 6c67 2e6d  urn (np.linalg.m
+00017cd0: 6174 7269 785f 706f 7765 7228 7741 2c20  atrix_power(wA, 
+00017ce0: 3329 2e64 6961 676f 6e61 6c28 290a 2020  3).diagonal().  
+00017cf0: 2020 2020 2020 2020 2020 2020 2020 2f20                / 
+00017d00: 2877 412e 646f 7428 6d61 785f 7729 2e64  (wA.dot(max_w).d
+00017d10: 6f74 2877 4129 292e 6469 6167 6f6e 616c  ot(wA)).diagonal
+00017d20: 2829 290a 0a20 2020 2064 6566 206e 7369  ())..    def nsi
+00017d30: 5f74 7769 6e6e 6573 7328 7365 6c66 293a  _twinness(self):
+00017d40: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00017d50: 2020 2020 2046 6f72 2065 6163 6820 7061       For each pa
+00017d60: 6972 206f 6620 6e6f 6465 732c 2072 6574  ir of nodes, ret
+00017d70: 7572 6e20 616e 206e 2e73 2e69 2e20 6d65  urn an n.s.i. me
+00017d80: 6173 7572 6520 6f66 2027 7477 696e 6e65  asure of 'twinne
+00017d90: 7373 272e 0a0a 2020 2020 2020 2020 5468  ss'...        Th
+00017da0: 6973 2076 6172 6965 7320 6672 6f6d 2030  is varies from 0
+00017db0: 2e30 2066 6f72 2075 6e6c 696e 6b65 6420  .0 for unlinked 
+00017dc0: 6e6f 6465 7320 746f 2031 2e30 2066 6f72  nodes to 1.0 for
+00017dd0: 206c 696e 6b65 6420 6e6f 6465 7320 6861   linked nodes ha
+00017de0: 7669 6e67 0a20 2020 2020 2020 2065 7861  ving.        exa
+00017df0: 6374 6c79 2074 6865 2073 616d 6520 6e65  ctly the same ne
+00017e00: 6967 6862 6f72 7320 2863 616c 6c65 6420  ighbors (called 
+00017e10: 7477 696e 7329 2e0a 0a20 2020 2020 2020  twins)...       
+00017e20: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
+00017e30: 2020 2020 2020 203e 3e3e 206e 6574 203d         >>> net =
+00017e40: 204e 6574 776f 726b 2e53 6d61 6c6c 5465   Network.SmallTe
+00017e50: 7374 4e65 7477 6f72 6b28 290a 2020 2020  stNetwork().    
+00017e60: 2020 2020 3e3e 3e20 7072 696e 7428 7228      >>> print(r(
+00017e70: 6e65 742e 6e73 695f 7477 696e 6e65 7373  net.nsi_twinness
+00017e80: 2829 2929 0a20 2020 2020 2020 2043 616c  ())).        Cal
+00017e90: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
+00017ea0: 6465 6772 6565 2e2e 2e0a 2020 2020 2020  degree....      
+00017eb0: 2020 5b5b 2031 2e20 2020 2020 2030 2e20    [[ 1.      0. 
+00017ec0: 2020 2020 2030 2e20 2020 2020 2030 2e34       0.      0.4
+00017ed0: 3238 3620 2030 2e34 3532 3420 2030 2e34  286  0.4524  0.4
+00017ee0: 3736 325d 0a20 2020 2020 2020 2020 5b20  762].         [ 
+00017ef0: 302e 2020 2020 2020 312e 2020 2020 2020  0.      1.      
+00017f00: 302e 3733 3735 2020 302e 3437 3520 2020  0.7375  0.475   
+00017f10: 302e 3733 3735 2020 302e 2020 2020 5d0a  0.7375  0.    ].
+00017f20: 2020 2020 2020 2020 205b 2030 2e20 2020           [ 0.   
+00017f30: 2020 2030 2e37 3337 3520 2031 2e20 2020     0.7375  1.   
+00017f40: 2020 2030 2e20 2020 2020 2030 2e37 3937     0.      0.797
+00017f50: 3320 2030 2e20 2020 205d 0a20 2020 2020  3  0.    ].     
+00017f60: 2020 2020 5b20 302e 3432 3836 2020 302e      [ 0.4286  0.
+00017f70: 3437 3520 2020 302e 2020 2020 2020 312e  475   0.      1.
+00017f80: 2020 2020 2020 302e 2020 2020 2020 302e        0.      0.
+00017f90: 2020 2020 5d0a 2020 2020 2020 2020 205b      ].         [
+00017fa0: 2030 2e34 3532 3420 2030 2e37 3337 3520   0.4524  0.7375 
+00017fb0: 2030 2e37 3937 3320 2030 2e20 2020 2020   0.7973  0.     
+00017fc0: 2031 2e20 2020 2020 2030 2e20 2020 205d   1.      0.    ]
+00017fd0: 0a20 2020 2020 2020 2020 5b20 302e 3437  .         [ 0.47
+00017fe0: 3632 2020 302e 2020 2020 2020 302e 2020  62  0.      0.  
+00017ff0: 2020 2020 302e 2020 2020 2020 302e 2020      0.      0.  
+00018000: 2020 2020 312e 2020 2020 5d5d 0a20 2020      1.    ]].   
+00018010: 2020 2020 203e 3e3e 2070 7269 6e74 2872       >>> print(r
+00018020: 286e 6574 2e73 706c 6974 7465 645f 636f  (net.splitted_co
+00018030: 7079 2829 2e6e 7369 5f74 7769 6e6e 6573  py().nsi_twinnes
+00018040: 7328 2929 290a 2020 2020 2020 2020 4361  s())).        Ca
+00018050: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+00018060: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
+00018070: 2020 205b 5b20 312e 2020 2020 2020 302e     [[ 1.      0.
+00018080: 2020 2020 2020 302e 2020 2020 2020 302e        0.      0.
+00018090: 3432 3836 2020 302e 3435 3234 2020 302e  4286  0.4524  0.
+000180a0: 3437 3632 2020 302e 3437 3632 5d0a 2020  4762  0.4762].  
+000180b0: 2020 2020 2020 205b 2030 2e20 2020 2020         [ 0.     
+000180c0: 2031 2e20 2020 2020 2030 2e37 3337 3520   1.      0.7375 
+000180d0: 2030 2e34 3735 2020 2030 2e37 3337 3520   0.475   0.7375 
+000180e0: 2030 2e20 2020 2020 2030 2e20 2020 205d   0.      0.    ]
+000180f0: 0a20 2020 2020 2020 2020 5b20 302e 2020  .         [ 0.  
+00018100: 2020 2020 302e 3733 3735 2020 312e 2020      0.7375  1.  
+00018110: 2020 2020 302e 2020 2020 2020 302e 3739      0.      0.79
+00018120: 3733 2020 302e 2020 2020 2020 302e 2020  73  0.      0.  
+00018130: 2020 5d0a 2020 2020 2020 2020 205b 2030    ].         [ 0
+00018140: 2e34 3238 3620 2030 2e34 3735 2020 2030  .4286  0.475   0
+00018150: 2e20 2020 2020 2031 2e20 2020 2020 2030  .      1.      0
+00018160: 2e20 2020 2020 2030 2e20 2020 2020 2030  .      0.      0
+00018170: 2e20 2020 205d 0a20 2020 2020 2020 2020  .    ].         
+00018180: 5b20 302e 3435 3234 2020 302e 3733 3735  [ 0.4524  0.7375
+00018190: 2020 302e 3739 3733 2020 302e 2020 2020    0.7973  0.    
+000181a0: 2020 312e 2020 2020 2020 302e 2020 2020    1.      0.    
+000181b0: 2020 302e 2020 2020 5d0a 2020 2020 2020    0.    ].      
+000181c0: 2020 205b 2030 2e34 3736 3220 2030 2e20     [ 0.4762  0. 
+000181d0: 2020 2020 2030 2e20 2020 2020 2030 2e20       0.      0. 
+000181e0: 2020 2020 2030 2e20 2020 2020 2031 2e20       0.      1. 
+000181f0: 2020 2020 2031 2e20 2020 205d 0a20 2020       1.    ].   
+00018200: 2020 2020 2020 5b20 302e 3437 3632 2020        [ 0.4762  
+00018210: 302e 2020 2020 2020 302e 2020 2020 2020  0.      0.      
+00018220: 302e 2020 2020 2020 302e 2020 2020 2020  0.      0.      
+00018230: 312e 2020 2020 2020 312e 2020 2020 5d5d  1.      1.    ]]
+00018240: 0a0a 2020 2020 2020 2020 3a72 7479 7065  ..        :rtype
+00018250: 3a20 7371 7561 7265 2061 7272 6179 205b  : square array [
+00018260: 6e6f 6465 2c6e 6f64 655d 206f 6620 666c  node,node] of fl
+00018270: 6f61 7473 2062 6574 7765 656e 2030 2061  oats between 0 a
+00018280: 6e64 2031 0a20 2020 2020 2020 2022 2222  nd 1.        """
+00018290: 0a20 2020 2020 2020 2023 2054 4f44 4f3a  .        # TODO:
+000182a0: 2069 6d70 6c65 6d65 6e74 206f 7468 6572   implement other
+000182b0: 2076 6572 7369 6f6e 7320 6173 2077 65c4   versions as we.
+000182c0: ba6c 0a20 2020 2020 2020 204e 2c20 6b2c  .l.        N, k,
+000182d0: 2041 7020 3d20 7365 6c66 2e4e 2c20 7365   Ap = self.N, se
+000182e0: 6c66 2e6e 7369 5f64 6567 7265 6528 292c  lf.nsi_degree(),
+000182f0: 2073 656c 662e 7370 5f41 706c 7573 2829   self.sp_Aplus()
+00018300: 0a20 2020 2020 2020 2063 6f6d 6d6f 6e73  .        commons
+00018310: 203d 2041 7020 2a20 7365 6c66 2e73 705f   = Ap * self.sp_
+00018320: 6469 6167 5f77 2829 202a 2041 700a 2020  diag_w() * Ap.  
+00018330: 2020 2020 2020 6b6b 203d 206e 702e 7265        kk = np.re
+00018340: 7065 6174 285b 6b5d 2c20 4e2c 2061 7869  peat([k], N, axi
+00018350: 733d 3029 0a20 2020 2020 2020 2072 6574  s=0).        ret
+00018360: 7572 6e20 4170 2e41 202a 2063 6f6d 6d6f  urn Ap.A * commo
+00018370: 6e73 2e41 202f 206e 702e 6d61 7869 6d75  ns.A / np.maximu
+00018380: 6d28 6b6b 2c20 6b6b 2e54 290a 0a20 2020  m(kk, kk.T)..   
+00018390: 2023 0a20 2020 2023 2020 4d65 6173 7572   #.    #  Measur
+000183a0: 6520 4173 736f 7274 6174 6976 6974 7920  e Assortativity 
+000183b0: 636f 6566 6669 6369 656e 740a 2020 2020  coefficient.    
+000183c0: 230a 0a20 2020 2064 6566 2061 7373 6f72  #..    def assor
+000183d0: 7461 7469 7669 7479 2873 656c 6629 3a0a  tativity(self):.
+000183e0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000183f0: 2020 2020 5265 7475 726e 2074 6865 2061      Return the a
+00018400: 7373 6f72 7461 7469 7669 7479 2063 6f65  ssortativity coe
+00018410: 6666 6963 6965 6e74 2e0a 0a20 2020 2020  fficient...     
+00018420: 2020 2054 6869 7320 666f 6c6c 6f77 7320     This follows 
+00018430: 5b4e 6577 6d61 6e32 3030 325d 5f2e 0a0a  [Newman2002]_...
+00018440: 2020 2020 2020 2020 2a2a 4578 616d 706c          **Exampl
+00018450: 653a 2a2a 0a0a 2020 2020 2020 2020 3e3e  e:**..        >>
+00018460: 3e20 7228 4e65 7477 6f72 6b2e 536d 616c  > r(Network.Smal
+00018470: 6c54 6573 744e 6574 776f 726b 2829 2e61  lTestNetwork().a
+00018480: 7373 6f72 7461 7469 7669 7479 2829 290a  ssortativity()).
+00018490: 2020 2020 2020 2020 2d30 2e34 3733 370a          -0.4737.
+000184a0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+000184b0: 2066 6c6f 6174 0a20 2020 2020 2020 2022   float.        "
+000184c0: 2222 0a20 2020 2020 2020 2064 6567 7265  "".        degre
+000184d0: 6573 203d 2073 656c 662e 6772 6170 682e  es = self.graph.
+000184e0: 6465 6772 6565 2829 0a20 2020 2020 2020  degree().       
+000184f0: 2064 6567 7265 6573 5f73 7120 3d20 5b64   degrees_sq = [d
+00018500: 6567 2a2a 3220 666f 7220 6465 6720 696e  eg**2 for deg in
+00018510: 2064 6567 7265 6573 5d0a 0a20 2020 2020   degrees]..     
+00018520: 2020 206d 203d 2066 6c6f 6174 2873 656c     m = float(sel
+00018530: 662e 6772 6170 682e 6563 6f75 6e74 2829  f.graph.ecount()
+00018540: 290a 2020 2020 2020 2020 6e75 6d31 2c20  ).        num1, 
+00018550: 6e75 6d32 2c20 6465 6e31 203d 2030 2c20  num2, den1 = 0, 
+00018560: 302c 2030 0a0a 2020 2020 2020 2020 666f  0, 0..        fo
+00018570: 7220 736f 7572 6365 2c20 7461 7267 6574  r source, target
+00018580: 2069 6e20 7365 6c66 2e67 7261 7068 2e67   in self.graph.g
+00018590: 6574 5f65 6467 656c 6973 7428 293a 0a20  et_edgelist():. 
+000185a0: 2020 2020 2020 2020 2020 206e 756d 3120             num1 
+000185b0: 2b3d 2064 6567 7265 6573 5b73 6f75 7263  += degrees[sourc
+000185c0: 655d 202a 2064 6567 7265 6573 5b74 6172  e] * degrees[tar
+000185d0: 6765 745d 0a20 2020 2020 2020 2020 2020  get].           
+000185e0: 206e 756d 3220 2b3d 2064 6567 7265 6573   num2 += degrees
+000185f0: 5b73 6f75 7263 655d 202b 2064 6567 7265  [source] + degre
+00018600: 6573 5b74 6172 6765 745d 0a20 2020 2020  es[target].     
+00018610: 2020 2020 2020 2064 656e 3120 2b3d 2064         den1 += d
+00018620: 6567 7265 6573 5f73 715b 736f 7572 6365  egrees_sq[source
+00018630: 5d20 2b20 6465 6772 6565 735f 7371 5b74  ] + degrees_sq[t
+00018640: 6172 6765 745d 0a0a 2020 2020 2020 2020  arget]..        
+00018650: 6e75 6d31 202f 3d20 6d0a 2020 2020 2020  num1 /= m.      
+00018660: 2020 6465 6e31 202f 3d20 322a 6d0a 2020    den1 /= 2*m.  
+00018670: 2020 2020 2020 6e75 6d32 203d 2028 6e75        num2 = (nu
+00018680: 6d32 202f 2028 3220 2a20 6d29 2920 2a2a  m2 / (2 * m)) **
+00018690: 2032 0a20 2020 2020 2020 2072 6574 7572   2.        retur
+000186a0: 6e20 286e 756d 3120 2d20 6e75 6d32 2920  n (num1 - num2) 
+000186b0: 2f20 2864 656e 3120 2d20 6e75 6d32 290a  / (den1 - num2).
+000186c0: 0a20 2020 2040 4361 6368 6564 2e6d 6574  .    @Cached.met
+000186d0: 686f 6428 6e61 6d65 3d22 6e2e 732e 692e  hod(name="n.s.i.
+000186e0: 206c 6f63 616c 2063 6c75 7374 6572 696e   local clusterin
+000186f0: 6722 2c20 6174 7472 733d 2822 5f6d 7574  g", attrs=("_mut
+00018700: 5f6e 7722 2c29 290a 2020 2020 6465 6620  _nw",)).    def 
+00018710: 6e73 695f 6c6f 6361 6c5f 636c 7573 7465  nsi_local_cluste
+00018720: 7269 6e67 2873 656c 662c 2074 7970 6963  ring(self, typic
+00018730: 616c 5f77 6569 6768 743d 4e6f 6e65 293a  al_weight=None):
+00018740: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00018750: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
+00018760: 6465 2c20 7265 7475 726e 2069 7473 2075  de, return its u
+00018770: 6e63 6f72 7265 6374 6564 2028 6265 7477  ncorrected (betw
+00018780: 6565 6e20 3020 616e 6420 3129 206f 7220  een 0 and 1) or 
+00018790: 636f 7272 6563 7465 640a 2020 2020 2020  corrected.      
+000187a0: 2020 2861 7420 6d6f 7374 2031 202f 206e    (at most 1 / n
+000187b0: 6567 6174 6976 6520 2f20 4e61 4e29 206e  egative / NaN) n
+000187c0: 2e73 2e69 2e20 636c 7573 7465 7269 6e67  .s.i. clustering
+000187d0: 2063 6f65 6666 6963 6965 6e74 2e0a 0a20   coefficient... 
+000187e0: 2020 2020 2020 2028 6e6f 7420 7965 7420         (not yet 
+000187f0: 696d 706c 656d 656e 7465 6420 666f 7220  implemented for 
+00018800: 6469 7265 6374 6564 206e 6574 776f 726b  directed network
+00018810: 7329 0a0a 2020 2020 2020 2020 2a2a 4578  s)..        **Ex
+00018820: 616d 706c 653a 2a2a 0a0a 2020 2020 2020  ample:**..      
+00018830: 2020 3e3e 3e20 6e65 7420 3d20 4e65 7477    >>> net = Netw
+00018840: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
+00018850: 776f 726b 2829 0a20 2020 2020 2020 203e  work().        >
+00018860: 3e3e 2072 286e 6574 2e6e 7369 5f6c 6f63  >> r(net.nsi_loc
+00018870: 616c 5f63 6c75 7374 6572 696e 6728 2929  al_clustering())
+00018880: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+00018890: 7469 6e67 206e 2e73 2e69 2e20 6465 6772  ting n.s.i. degr
+000188a0: 6565 2e2e 2e0a 2020 2020 2020 2020 6172  ee....        ar
+000188b0: 7261 7928 5b20 302e 3535 3133 2c20 302e  ray([ 0.5513, 0.
+000188c0: 3732 3434 2c20 312e 202c 2030 2e38 3138  7244, 1. , 0.818
+000188d0: 342c 2030 2e38 3032 382c 2031 2e20 5d29  4, 0.8028, 1. ])
+000188e0: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
+000188f0: 6574 2e73 706c 6974 7465 645f 636f 7079  et.splitted_copy
+00018900: 2829 2e6e 7369 5f6c 6f63 616c 5f63 6c75  ().nsi_local_clu
+00018910: 7374 6572 696e 6728 2929 0a20 2020 2020  stering()).     
+00018920: 2020 2043 616c 6375 6c61 7469 6e67 206e     Calculating n
+00018930: 2e73 2e69 2e20 6465 6772 6565 2e2e 2e0a  .s.i. degree....
+00018940: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+00018950: 302e 3535 3133 2c20 302e 3732 3434 2c20  0.5513, 0.7244, 
+00018960: 312e 202c 2030 2e38 3138 342c 2030 2e38  1. , 0.8184, 0.8
+00018970: 3032 382c 2031 2e20 2c20 312e 205d 290a  028, 1. , 1. ]).
+00018980: 0a20 2020 2020 2020 2061 7320 636f 6d70  .        as comp
+00018990: 6172 6564 2074 6f20 7468 6520 756e 7765  ared to the unwe
+000189a0: 6967 6874 6564 2076 6572 7369 6f6e 3a0a  ighted version:.
+000189b0: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
+000189c0: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
+000189d0: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
+000189e0: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
+000189f0: 6c6f 6361 6c5f 636c 7573 7465 7269 6e67  local_clustering
+00018a00: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
+00018a10: 756c 6174 696e 6720 6c6f 6361 6c20 636c  ulating local cl
+00018a20: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
+00018a30: 6965 6e74 732e 2e2e 0a20 2020 2020 2020  ients....       
+00018a40: 2061 7272 6179 285b 2030 2e20 2c20 302e   array([ 0. , 0.
+00018a50: 3333 3333 2c20 312e 202c 2030 2e20 2c20  3333, 1. , 0. , 
+00018a60: 302e 3333 3333 2c20 302e 205d 290a 2020  0.3333, 0. ]).  
+00018a70: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
+00018a80: 7370 6c69 7474 6564 5f63 6f70 7928 292e  splitted_copy().
+00018a90: 6c6f 6361 6c5f 636c 7573 7465 7269 6e67  local_clustering
+00018aa0: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
+00018ab0: 756c 6174 696e 6720 6c6f 6361 6c20 636c  ulating local cl
+00018ac0: 7573 7465 7269 6e67 2063 6f65 6666 6963  ustering coeffic
+00018ad0: 6965 6e74 732e 2e2e 0a20 2020 2020 2020  ients....       
+00018ae0: 2061 7272 6179 285b 2030 2e31 3636 372c   array([ 0.1667,
+00018af0: 2030 2e33 3333 332c 2031 2e20 2c20 2030   0.3333, 1. ,  0
+00018b00: 2e20 2c20 302e 3333 3333 2c20 312e 202c  . , 0.3333, 1. ,
+00018b10: 2031 2e20 5d29 0a0a 2020 2020 2020 2020   1. ])..        
+00018b20: 3a74 7970 6520 7479 7069 6361 6c5f 7765  :type typical_we
+00018b30: 6967 6874 3a20 666c 6f61 7420 3e20 300a  ight: float > 0.
+00018b40: 2020 2020 2020 2020 3a61 7267 2020 7479          :arg  ty
+00018b50: 7069 6361 6c5f 7765 6967 6874 3a20 4f70  pical_weight: Op
+00018b60: 7469 6f6e 616c 2074 7970 6963 616c 206e  tional typical n
+00018b70: 6f64 6520 7765 6967 6874 2074 6f20 6265  ode weight to be
+00018b80: 2075 7365 6420 666f 720a 2020 2020 2020   used for.      
+00018b90: 2020 2020 2020 636f 7272 6563 7469 6f6e        correction
+00018ba0: 2e20 4966 204e 6f6e 652c 2074 6865 2075  . If None, the u
+00018bb0: 6e63 6f72 7265 6374 6564 206d 6561 7375  ncorrected measu
+00018bc0: 7265 2069 730a 2020 2020 2020 2020 2020  re is.          
+00018bd0: 2020 7265 7475 726e 6564 2e20 2844 6566    returned. (Def
+00018be0: 6175 6c74 3a20 4e6f 6e65 290a 0a20 2020  ault: None)..   
+00018bf0: 2020 2020 203a 7274 7970 653a 2061 7272       :rtype: arr
+00018c00: 6179 285b 666c 6f61 745d 290a 2020 2020  ay([float]).    
+00018c10: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00018c20: 6966 2073 656c 662e 6469 7265 6374 6564  if self.directed
+00018c30: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00018c40: 6973 6520 4e6f 7449 6d70 6c65 6d65 6e74  ise NotImplement
+00018c50: 6564 4572 726f 7228 224e 6f74 2069 6d70  edError("Not imp
+00018c60: 6c65 6d65 6e74 6564 2066 6f72 2064 6972  lemented for dir
+00018c70: 6563 7465 6420 6e65 7477 6f72 6b73 2e22  ected networks."
+00018c80: 290a 0a20 2020 2020 2020 206b 203d 2073  )..        k = s
+00018c90: 656c 662e 6e73 695f 6465 6772 6565 2874  elf.nsi_degree(t
+00018ca0: 7970 6963 616c 5f77 6569 6768 743d 7479  ypical_weight=ty
+00018cb0: 7069 6361 6c5f 7765 6967 6874 290a 0a20  pical_weight).. 
+00018cc0: 2020 2020 2020 2069 6620 7479 7069 6361         if typica
+00018cd0: 6c5f 7765 6967 6874 2069 7320 4e6f 6e65  l_weight is None
+00018ce0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00018cf0: 2073 656c 662e 7369 6c65 6e63 655f 6c65   self.silence_le
+00018d00: 7665 6c20 3c3d 2031 3a0a 2020 2020 2020  vel <= 1:.      
+00018d10: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00018d20: 2243 616c 6375 6c61 7469 6e67 2075 6e63  "Calculating unc
+00018d30: 6f72 7265 6374 6564 206e 2e73 2e69 2e20  orrected n.s.i. 
+00018d40: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00018d50: 2020 2020 2020 2020 226c 6f63 616c 2063          "local c
+00018d60: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
+00018d70: 6369 656e 7473 2e2e 2e22 290a 2020 2020  cients...").    
+00018d80: 2020 2020 2020 2020 7720 3d20 7365 6c66          w = self
+00018d90: 2e6e 6f64 655f 7765 6967 6874 730a 2020  .node_weights.  
+00018da0: 2020 2020 2020 2020 2020 415f 4477 203d            A_Dw =
+00018db0: 2073 656c 662e 7370 5f41 202a 2073 656c   self.sp_A * sel
+00018dc0: 662e 7370 5f64 6961 675f 7728 290a 2020  f.sp_diag_w().  
+00018dd0: 2020 2020 2020 2020 2020 6e75 6d65 7261            numera
+00018de0: 746f 7220 3d20 2841 5f44 7720 2a20 7365  tor = (A_Dw * se
+00018df0: 6c66 2e73 705f 4170 6c75 7328 2920 2a20  lf.sp_Aplus() * 
+00018e00: 415f 4477 2e54 292e 6469 6167 6f6e 616c  A_Dw.T).diagonal
+00018e10: 2829 0a20 2020 2020 2020 2020 2020 2072  ().            r
+00018e20: 6574 7572 6e20 286e 756d 6572 6174 6f72  eturn (numerator
+00018e30: 202b 2032 2a6b 2a77 202d 2077 2a2a 3229   + 2*k*w - w**2)
+00018e40: 202f 206b 2a2a 320a 2020 2020 2020 2020   / k**2.        
+00018e50: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00018e60: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
+00018e70: 655f 6c65 7665 6c20 3c3d 2031 3a0a 2020  e_level <= 1:.  
+00018e80: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00018e90: 696e 7428 2243 616c 6375 6c61 7469 6e67  int("Calculating
+00018ea0: 2063 6f72 7265 6374 6564 206e 2e73 2e69   corrected n.s.i
+00018eb0: 2e20 220a 2020 2020 2020 2020 2020 2020  . ".            
+00018ec0: 2020 2020 2020 2020 2020 226c 6f63 616c            "local
+00018ed0: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
+00018ee0: 6669 6369 656e 7473 2e2e 2e22 290a 2020  ficients...").  
+00018ef0: 2020 2020 2020 2020 2020 4170 203d 2073            Ap = s
+00018f00: 656c 662e 7370 5f41 706c 7573 2829 0a20  elf.sp_Aplus(). 
+00018f10: 2020 2020 2020 2020 2020 2041 705f 4477             Ap_Dw
+00018f20: 203d 2041 7020 2a20 7365 6c66 2e73 705f   = Ap * self.sp_
+00018f30: 6469 6167 5f77 2829 0a20 2020 2020 2020  diag_w().       
+00018f40: 2020 2020 206e 756d 6572 6174 6f72 203d       numerator =
+00018f50: 2028 4170 5f44 7720 2a20 4170 5f44 7720   (Ap_Dw * Ap_Dw 
+00018f60: 2a20 4170 292e 6469 6167 6f6e 616c 2829  * Ap).diagonal()
+00018f70: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00018f80: 7572 6e20 286e 756d 6572 6174 6f72 2f74  urn (numerator/t
+00018f90: 7970 6963 616c 5f77 6569 6768 742a 2a32  ypical_weight**2
+00018fa0: 202d 2033 2e30 2a6b 202d 2031 2e30 2920   - 3.0*k - 1.0) 
+00018fb0: 2f20 286b 202a 2028 6b2d 312e 3029 290a  / (k * (k-1.0)).
+00018fc0: 0a20 2020 2040 4361 6368 6564 2e6d 6574  .    @Cached.met
+00018fd0: 686f 6428 6e61 6d65 3d22 7468 6520 6e2e  hod(name="the n.
+00018fe0: 732e 692e 2067 6c6f 6261 6c20 746f 706f  s.i. global topo
+00018ff0: 6c6f 6769 6361 6c20 636c 7573 7465 7269  logical clusteri
+00019000: 6e67 2063 6f65 6666 6963 6965 6e74 222c  ng coefficient",
+00019010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019020: 2020 2020 6174 7472 733d 2822 5f6d 7574      attrs=("_mut
+00019030: 5f6e 7722 2c29 290a 2020 2020 6465 6620  _nw",)).    def 
+00019040: 6e73 695f 676c 6f62 616c 5f63 6c75 7374  nsi_global_clust
+00019050: 6572 696e 6728 7365 6c66 293a 0a20 2020  ering(self):.   
+00019060: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00019070: 2052 6574 7572 6e20 7468 6520 6e2e 732e   Return the n.s.
+00019080: 692e 2067 6c6f 6261 6c20 636c 7573 7465  i. global cluste
+00019090: 7269 6e67 2063 6f65 6666 6963 6965 6e74  ring coefficient
+000190a0: 2e0a 0a20 2020 2020 2020 2028 6e6f 7420  ...        (not 
+000190b0: 7965 7420 696d 706c 656d 656e 7465 6420  yet implemented 
+000190c0: 666f 7220 6469 7265 6374 6564 206e 6574  for directed net
+000190d0: 776f 726b 732e 290a 0a20 2020 2020 2020  works.)..       
+000190e0: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
+000190f0: 2020 2020 2020 203e 3e3e 2072 284e 6574         >>> r(Net
+00019100: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
+00019110: 7477 6f72 6b28 292e 6e73 695f 676c 6f62  twork().nsi_glob
+00019120: 616c 5f63 6c75 7374 6572 696e 6728 2929  al_clustering())
+00019130: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+00019140: 7469 6e67 206e 2e73 2e69 2e20 676c 6f62  ting n.s.i. glob
+00019150: 616c 2074 6f70 6f6c 6f67 6963 616c 2063  al topological c
+00019160: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
+00019170: 6369 656e 742e 2e2e 0a20 2020 2020 2020  cient....       
+00019180: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
+00019190: 2e69 2e20 6465 6772 6565 2e2e 2e0a 2020  .i. degree....  
+000191a0: 2020 2020 2020 302e 3833 3533 0a0a 2020        0.8353..  
+000191b0: 2020 2020 2020 6173 2063 6f6d 7061 7265        as compare
+000191c0: 6420 746f 2074 6865 2075 6e77 6569 6768  d to the unweigh
+000191d0: 7465 6420 7665 7273 696f 6e3a 0a0a 2020  ted version:..  
+000191e0: 2020 2020 2020 3e3e 3e20 7228 4e65 7477        >>> r(Netw
+000191f0: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
+00019200: 776f 726b 2829 2e67 6c6f 6261 6c5f 636c  work().global_cl
+00019210: 7573 7465 7269 6e67 2829 290a 2020 2020  ustering()).    
+00019220: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+00019230: 676c 6f62 616c 2063 6c75 7374 6572 696e  global clusterin
+00019240: 6720 636f 6566 6669 6369 656e 7420 2843  g coefficient (C
+00019250: 5f32 292e 2e2e 0a20 2020 2020 2020 2043  _2)....        C
+00019260: 616c 6375 6c61 7469 6e67 206c 6f63 616c  alculating local
+00019270: 2063 6c75 7374 6572 696e 6720 636f 6566   clustering coef
+00019280: 6669 6369 656e 7473 2e2e 2e0a 2020 2020  ficients....    
+00019290: 2020 2020 302e 3237 3738 0a0a 2020 2020      0.2778..    
+000192a0: 2020 2020 3a72 7479 7065 3a20 666c 6f61      :rtype: floa
+000192b0: 7420 6265 7477 6565 6e20 3020 616e 6420  t between 0 and 
+000192c0: 310a 2020 2020 2020 2020 2222 220a 2020  1.        """.  
+000192d0: 2020 2020 2020 6966 2073 656c 662e 6469        if self.di
+000192e0: 7265 6374 6564 3a0a 2020 2020 2020 2020  rected:.        
+000192f0: 2020 2020 7261 6973 6520 4e6f 7449 6d70      raise NotImp
+00019300: 6c65 6d65 6e74 6564 4572 726f 7228 224e  lementedError("N
+00019310: 6f74 2069 6d70 6c65 6d65 6e74 6564 2066  ot implemented f
+00019320: 6f72 2064 6972 6563 7465 6420 6e65 7477  or directed netw
+00019330: 6f72 6b73 2e22 290a 0a20 2020 2020 2020  orks.")..       
+00019340: 2072 6574 7572 6e20 2873 656c 662e 6e73   return (self.ns
+00019350: 695f 6c6f 6361 6c5f 636c 7573 7465 7269  i_local_clusteri
+00019360: 6e67 2829 2e64 6f74 2873 656c 662e 6e6f  ng().dot(self.no
+00019370: 6465 5f77 6569 6768 7473 290a 2020 2020  de_weights).    
+00019380: 2020 2020 2020 2020 2020 2020 2f20 7365              / se
+00019390: 6c66 2e74 6f74 616c 5f6e 6f64 655f 7765  lf.total_node_we
+000193a0: 6967 6874 290a 0a20 2020 2040 4361 6368  ight)..    @Cach
+000193b0: 6564 2e6d 6574 686f 6428 6e61 6d65 3d22  ed.method(name="
+000193c0: 6e2e 732e 692e 2074 7261 6e73 6974 6976  n.s.i. transitiv
+000193d0: 6974 7922 2c20 6174 7472 733d 2822 5f6d  ity", attrs=("_m
+000193e0: 7574 5f6e 7722 2c29 290a 2020 2020 6465  ut_nw",)).    de
+000193f0: 6620 6e73 695f 7472 616e 7369 7469 7669  f nsi_transitivi
+00019400: 7479 2873 656c 6629 3a0a 2020 2020 2020  ty(self):.      
+00019410: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+00019420: 7475 726e 2074 6865 206e 2e73 2e69 2e20  turn the n.s.i. 
+00019430: 7472 616e 7369 7469 7669 7479 2e0a 0a20  transitivity... 
+00019440: 2020 2020 2020 202e 2e20 7761 726e 696e         .. warnin
+00019450: 673a 3a0a 2020 2020 2020 2020 2020 204e  g::.           N
+00019460: 6f74 2079 6574 2069 6d70 6c65 6d65 6e74  ot yet implement
+00019470: 6564 210a 0a20 2020 2020 2020 203a 7274  ed!..        :rt
+00019480: 7970 653a 2066 6c6f 6174 2062 6574 7765  ype: float betwe
+00019490: 656e 2030 2061 6e64 2031 0a20 2020 2020  en 0 and 1.     
+000194a0: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+000194b0: 6620 7365 6c66 2e64 6972 6563 7465 643a  f self.directed:
+000194c0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+000194d0: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
+000194e0: 6445 7272 6f72 2822 4e6f 7420 696d 706c  dError("Not impl
+000194f0: 656d 656e 7465 6420 666f 7220 6469 7265  emented for dire
+00019500: 6374 6564 206e 6574 776f 726b 732e 2229  cted networks.")
+00019510: 0a0a 2020 2020 2020 2020 4120 3d20 7365  ..        A = se
+00019520: 6c66 2e73 705f 4170 6c75 7328 290a 2020  lf.sp_Aplus().  
+00019530: 2020 2020 2020 415f 4477 203d 2041 202a        A_Dw = A *
+00019540: 2073 656c 662e 7370 5f64 6961 675f 7728   self.sp_diag_w(
+00019550: 290a 2020 2020 2020 2020 6e75 6d20 3d20  ).        num = 
+00019560: 2841 5f44 7720 2a20 415f 4477 202a 2041  (A_Dw * A_Dw * A
+00019570: 5f44 7729 2e64 6961 676f 6e61 6c28 292e  _Dw).diagonal().
+00019580: 7375 6d28 290a 2020 2020 2020 2020 6465  sum().        de
+00019590: 6e75 6d20 3d20 2873 656c 662e 7370 5f64  num = (self.sp_d
+000195a0: 6961 675f 7728 2920 2a20 415f 4477 202a  iag_w() * A_Dw *
+000195b0: 2041 5f44 7729 2e73 756d 2829 0a0a 2020   A_Dw).sum()..  
+000195c0: 2020 2020 2020 7265 7475 726e 206e 756d        return num
+000195d0: 202f 2064 656e 756d 0a0a 2020 2020 4043   / denum..    @C
+000195e0: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+000195f0: 653d 2274 6865 206e 2e73 2e69 2e20 6c6f  e="the n.s.i. lo
+00019600: 6361 6c20 536f 6666 6572 2063 6c75 7374  cal Soffer clust
+00019610: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+00019620: 7473 222c 0a20 2020 2020 2020 2020 2020  ts",.           
+00019630: 2020 2020 2020 2020 6174 7472 733d 2822          attrs=("
+00019640: 5f6d 7574 5f6e 7722 2c29 290a 2020 2020  _mut_nw",)).    
+00019650: 6465 6620 6e73 695f 6c6f 6361 6c5f 736f  def nsi_local_so
+00019660: 6666 6572 5f63 6c75 7374 6572 696e 6728  ffer_clustering(
+00019670: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+00019680: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
+00019690: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
+000196a0: 2069 7473 206e 2e73 2e69 2e20 636c 7573   its n.s.i. clus
+000196b0: 7465 7269 6e67 2063 6f65 6666 6963 6965  tering coefficie
+000196c0: 6e74 0a20 2020 2020 2020 2077 6974 6820  nt.        with 
+000196d0: 6269 6173 2d72 6564 7563 7469 6f6e 2066  bias-reduction f
+000196e0: 6f6c 6c6f 7769 6e67 205b 536f 6666 6572  ollowing [Soffer
+000196f0: 3230 3035 5d5f 2e0a 0a20 2020 2020 2020  2005]_...       
+00019700: 2028 6e6f 7420 7965 7420 696d 706c 656d   (not yet implem
+00019710: 656e 7465 6420 666f 7220 6469 7265 6374  ented for direct
+00019720: 6564 206e 6574 776f 726b 732e 290a 0a20  ed networks.).. 
+00019730: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
+00019740: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+00019750: 206e 6574 203d 204e 6574 776f 726b 2e53   net = Network.S
+00019760: 6d61 6c6c 5465 7374 4e65 7477 6f72 6b28  mallTestNetwork(
+00019770: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
+00019780: 6e65 742e 6e73 695f 6c6f 6361 6c5f 736f  net.nsi_local_so
+00019790: 6666 6572 5f63 6c75 7374 6572 696e 6728  ffer_clustering(
+000197a0: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+000197b0: 6c61 7469 6e67 206e 2e73 2e69 2e20 6c6f  lating n.s.i. lo
+000197c0: 6361 6c20 536f 6666 6572 2063 6c75 7374  cal Soffer clust
+000197d0: 6572 696e 6720 636f 6566 6669 6369 656e  ering coefficien
+000197e0: 7473 2e2e 2e0a 2020 2020 2020 2020 4361  ts....        Ca
+000197f0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+00019800: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
+00019810: 2020 2061 7272 6179 285b 2030 2e37 3636     array([ 0.766
+00019820: 352c 2030 2e38 3735 342c 2031 2e20 2c20  5, 0.8754, 1. , 
+00019830: 302e 3831 3834 2c20 302e 3834 3639 2c20  0.8184, 0.8469, 
+00019840: 312e 205d 290a 2020 2020 2020 2020 3e3e  1. ]).        >>
+00019850: 3e20 7228 6e65 742e 7370 6c69 7474 6564  > r(net.splitted
+00019860: 5f63 6f70 7928 292e 6e73 695f 6c6f 6361  _copy().nsi_loca
+00019870: 6c5f 736f 6666 6572 5f63 6c75 7374 6572  l_soffer_cluster
+00019880: 696e 6728 2929 0a20 2020 2020 2020 2043  ing()).        C
+00019890: 616c 6375 6c61 7469 6e67 206e 2e73 2e69  alculating n.s.i
+000198a0: 2e20 6c6f 6361 6c20 536f 6666 6572 2063  . local Soffer c
+000198b0: 6c75 7374 6572 696e 6720 636f 6566 6669  lustering coeffi
+000198c0: 6369 656e 7473 2e2e 2e0a 2020 2020 2020  cients....      
+000198d0: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
+000198e0: 732e 692e 2064 6567 7265 652e 2e2e 0a20  s.i. degree.... 
+000198f0: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
+00019900: 2e37 3636 352c 2030 2e38 3735 342c 2031  .7665, 0.8754, 1
+00019910: 2e20 2c20 302e 3831 3834 2c20 302e 3834  . , 0.8184, 0.84
+00019920: 3639 2c20 312e 202c 2031 2e20 5d29 0a0a  69, 1. , 1. ])..
+00019930: 2020 2020 2020 2020 6173 2063 6f6d 7061          as compa
+00019940: 7265 6420 746f 2074 6865 2076 6572 7369  red to the versi
+00019950: 6f6e 2077 6974 686f 7574 2062 6961 732d  on without bias-
+00019960: 7265 6475 6374 696f 6e3a 0a0a 2020 2020  reduction:..    
+00019970: 2020 2020 3e3e 3e20 7228 4e65 7477 6f72      >>> r(Networ
+00019980: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
+00019990: 726b 2829 2e6e 7369 5f6c 6f63 616c 5f63  rk().nsi_local_c
+000199a0: 6c75 7374 6572 696e 6728 2929 0a20 2020  lustering()).   
+000199b0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+000199c0: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
+000199d0: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+000199e0: 5b20 302e 3535 3133 2c20 302e 3732 3434  [ 0.5513, 0.7244
+000199f0: 2c20 312e 202c 2030 2e38 3138 342c 2030  , 1. , 0.8184, 0
+00019a00: 2e38 3032 382c 2031 2e20 5d29 0a0a 2020  .8028, 1. ])..  
+00019a10: 2020 2020 2020 3a72 7479 7065 3a20 3164        :rtype: 1d
+00019a20: 206e 756d 7079 2061 7272 6179 205b 6e6f   numpy array [no
+00019a30: 6465 5d20 6f66 2066 6c6f 6174 7320 6265  de] of floats be
+00019a40: 7477 6565 6e20 3020 616e 6420 310a 2020  tween 0 and 1.  
+00019a50: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00019a60: 2020 6966 2073 656c 662e 6469 7265 6374    if self.direct
+00019a70: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
+00019a80: 7261 6973 6520 4e6f 7449 6d70 6c65 6d65  raise NotImpleme
+00019a90: 6e74 6564 4572 726f 7228 224e 6f74 2069  ntedError("Not i
+00019aa0: 6d70 6c65 6d65 6e74 6564 2066 6f72 2064  mplemented for d
+00019ab0: 6972 6563 7465 6420 6e65 7477 6f72 6b73  irected networks
+00019ac0: 2e22 290a 0a20 2020 2020 2020 2023 206e  .")..        # n
+00019ad0: 756d 6572 6174 6f72 2069 7320 6465 7465  umerator is dete
+00019ae0: 726d 696e 6564 2061 7320 6162 6f76 650a  rmined as above.
+00019af0: 2020 2020 2020 2020 4170 203d 2073 656c          Ap = sel
+00019b00: 662e 7370 5f41 706c 7573 2829 0a20 2020  f.sp_Aplus().   
+00019b10: 2020 2020 2041 705f 4477 203d 2041 7020       Ap_Dw = Ap 
+00019b20: 2a20 7365 6c66 2e73 705f 6469 6167 5f77  * self.sp_diag_w
+00019b30: 2829 0a20 2020 2020 2020 206e 756d 6572  ().        numer
+00019b40: 6174 6f72 203d 2028 4170 5f44 7720 2a20  ator = (Ap_Dw * 
+00019b50: 4170 5f44 7720 2a20 4170 292e 6469 6167  Ap_Dw * Ap).diag
+00019b60: 6f6e 616c 2829 0a0a 2020 2020 2020 2020  onal()..        
+00019b70: 2320 6465 6e6f 6d69 6e61 746f 7220 6465  # denominator de
+00019b80: 7065 6e64 7320 6f6e 2064 6567 7265 6573  pends on degrees
+00019b90: 206f 6620 6e65 6967 6862 6f75 7273 0a20   of neighbours. 
+00019ba0: 2020 2020 2020 204e 2c20 6b20 3d20 7365         N, k = se
+00019bb0: 6c66 2e4e 2c20 7365 6c66 2e6e 7369 5f64  lf.N, self.nsi_d
+00019bc0: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
+00019bd0: 6d69 6e6b 203d 206e 702e 6172 7261 7928  mink = np.array(
+00019be0: 5b5b 6d69 6e28 6b5b 695d 2c20 6b5b 6a5d  [[min(k[i], k[j]
+00019bf0: 2920 666f 7220 6a20 696e 2072 616e 6765  ) for j in range
+00019c00: 284e 295d 0a20 2020 2020 2020 2020 2020  (N)].           
+00019c10: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00019c20: 7220 6920 696e 2072 616e 6765 284e 295d  r i in range(N)]
+00019c30: 290a 2020 2020 2020 2020 6465 6e6f 6d69  ).        denomi
+00019c40: 6e61 746f 7220 3d20 286d 696e 6b20 2a20  nator = (mink * 
+00019c50: 2873 656c 662e 7370 5f64 6961 675f 7728  (self.sp_diag_w(
+00019c60: 2920 2a20 4170 2929 2e64 6961 676f 6e61  ) * Ap)).diagona
+00019c70: 6c28 290a 2020 2020 2020 2020 7265 7475  l().        retu
+00019c80: 726e 206e 756d 6572 6174 6f72 202f 2064  rn numerator / d
+00019c90: 656e 6f6d 696e 6174 6f72 0a0a 2020 2020  enominator..    
+00019ca0: 230a 2020 2020 2320 204d 6561 7375 7265  #.    #  Measure
+00019cb0: 2070 6174 6820 6c65 6e67 7468 730a 2020   path lengths.  
+00019cc0: 2020 230a 0a20 2020 2040 4361 6368 6564    #..    @Cached
+00019cd0: 2e6d 6574 686f 6428 6e61 6d65 3d22 7061  .method(name="pa
+00019ce0: 7468 206c 656e 6774 6873 2229 0a20 2020  th lengths").   
+00019cf0: 2064 6566 2070 6174 685f 6c65 6e67 7468   def path_length
+00019d00: 7328 7365 6c66 2c20 6c69 6e6b 5f61 7474  s(self, link_att
+00019d10: 7269 6275 7465 3d4e 6f6e 6529 3a0a 2020  ribute=None):.  
+00019d20: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00019d30: 2020 466f 7220 6561 6368 2070 6169 7220    For each pair 
+00019d40: 6f66 206e 6f64 6573 2069 2c6a 2c20 7265  of nodes i,j, re
+00019d50: 7475 726e 2074 6865 2028 7765 6967 6874  turn the (weight
+00019d60: 6564 2920 7368 6f72 7465 7374 2070 6174  ed) shortest pat
+00019d70: 6820 6c65 6e67 7468 0a20 2020 2020 2020  h length.       
+00019d80: 2066 726f 6d20 6920 746f 206a 2028 616c   from i to j (al
+00019d90: 736f 2063 616c 6c65 6420 7468 6520 6469  so called the di
+00019da0: 7374 616e 6365 2066 726f 6d20 6920 746f  stance from i to
+00019db0: 206a 292e 0a0a 2020 2020 2020 2020 5468   j)...        Th
+00019dc0: 6973 2069 7320 7468 6520 7368 6f72 7465  is is the shorte
+00019dd0: 7374 206c 656e 6774 6820 6f66 2061 2070  st length of a p
+00019de0: 6174 6820 6672 6f6d 2069 2074 6f20 6a20  ath from i to j 
+00019df0: 616c 6f6e 6720 6c69 6e6b 732c 0a20 2020  along links,.   
+00019e00: 2020 2020 206f 7220 696e 6669 6e69 7479       or infinity
+00019e10: 2069 6620 7468 6572 6520 6973 206e 6f20   if there is no 
+00019e20: 7375 6368 2070 6174 682e 0a0a 2020 2020  such path...    
+00019e30: 2020 2020 5468 6520 6c65 6e67 7468 206f      The length o
+00019e40: 6620 6c69 6e6b 7320 6361 6e20 6265 2073  f links can be s
+00019e50: 7065 6369 6669 6564 2062 7920 616e 206f  pecified by an o
+00019e60: 7074 696f 6e61 6c20 6c69 6e6b 2061 7474  ptional link att
+00019e70: 7269 6275 7465 2e0a 0a20 2020 2020 2020  ribute...       
+00019e80: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
+00019e90: 2020 2020 2020 203e 3e3e 2070 7269 6e74         >>> print
+00019ea0: 284e 6574 776f 726b 2e53 6d61 6c6c 5465  (Network.SmallTe
+00019eb0: 7374 4e65 7477 6f72 6b28 292e 7061 7468  stNetwork().path
+00019ec0: 5f6c 656e 6774 6873 2829 290a 2020 2020  _lengths()).    
+00019ed0: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+00019ee0: 616c 6c20 7368 6f72 7465 7374 2070 6174  all shortest pat
+00019ef0: 6820 6c65 6e67 7468 732e 2e2e 0a20 2020  h lengths....   
+00019f00: 2020 2020 205b 5b20 302e 2020 322e 2020       [[ 0.  2.  
+00019f10: 322e 2020 312e 2020 312e 2020 312e 5d0a  2.  1.  1.  1.].
+00019f20: 2020 2020 2020 2020 205b 2032 2e20 2030           [ 2.  0
+00019f30: 2e20 2031 2e20 2031 2e20 2031 2e20 2033  .  1.  1.  1.  3
+00019f40: 2e5d 0a20 2020 2020 2020 2020 5b20 322e  .].         [ 2.
+00019f50: 2020 312e 2020 302e 2020 322e 2020 312e    1.  0.  2.  1.
+00019f60: 2020 332e 5d0a 2020 2020 2020 2020 205b    3.].         [
+00019f70: 2031 2e20 2031 2e20 2032 2e20 2030 2e20   1.  1.  2.  0. 
+00019f80: 2032 2e20 2032 2e5d 0a20 2020 2020 2020   2.  2.].       
+00019f90: 2020 5b20 312e 2020 312e 2020 312e 2020    [ 1.  1.  1.  
+00019fa0: 322e 2020 302e 2020 322e 5d0a 2020 2020  2.  0.  2.].    
+00019fb0: 2020 2020 205b 2031 2e20 2033 2e20 2033       [ 1.  3.  3
+00019fc0: 2e20 2032 2e20 2032 2e20 2030 2e5d 5d0a  .  2.  2.  0.]].
+00019fd0: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
+00019fe0: 7220 6c69 6e6b 5f61 7474 7269 6275 7465  r link_attribute
+00019ff0: 3a20 4f70 7469 6f6e 616c 206e 616d 6520  : Optional name 
+0001a000: 6f66 2074 6865 206c 696e 6b20 6174 7472  of the link attr
+0001a010: 6962 7574 6520 746f 2062 6520 7573 6564  ibute to be used
+0001a020: 0a20 2020 2020 2020 2020 2020 2061 7320  .            as 
+0001a030: 7468 6520 6c69 6e6b 7327 206c 656e 6774  the links' lengt
+0001a040: 682e 2049 6620 4e6f 6e65 2c20 6c69 6e6b  h. If None, link
+0001a050: 7320 6861 7665 206c 656e 6774 6820 312e  s have length 1.
+0001a060: 2028 4465 6661 756c 743a 204e 6f6e 6529   (Default: None)
+0001a070: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+0001a080: 2073 7175 6172 6520 6172 7261 7920 5b5b   square array [[
+0001a090: 666c 6f61 745d 5d0a 2020 2020 2020 2020  float]].        
+0001a0a0: 2222 220a 2020 2020 2020 2020 6966 206c  """.        if l
+0001a0b0: 696e 6b5f 6174 7472 6962 7574 6520 3d3d  ink_attribute ==
+0001a0c0: 2022 746f 706f 6c6f 6769 6361 6c22 3a0a   "topological":.
+0001a0d0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0001a0e0: 7428 2257 4152 4e49 4e47 3a20 6c69 6e6b  t("WARNING: link
+0001a0f0: 5f61 7474 7269 6275 7465 3d27 746f 706f  _attribute='topo
+0001a100: 6c6f 6769 6361 6c27 2069 7320 6465 7072  logical' is depr
+0001a110: 6563 6174 6564 2e5c 6e22 0a20 2020 2020  ecated.\n".     
+0001a120: 2020 2020 2020 2020 2020 2020 202b 2022               + "
+0001a130: 5573 6520 6c69 6e6b 5f61 7474 7269 6275  Use link_attribu
+0001a140: 7465 3d4e 6f6e 6520 696e 7374 6561 642e  te=None instead.
+0001a150: 2229 0a20 2020 2020 2020 2020 2020 206c  ").            l
+0001a160: 696e 6b5f 6174 7472 6962 7574 6520 3d20  ink_attribute = 
+0001a170: 4e6f 6e65 0a0a 2020 2020 2020 2020 6966  None..        if
+0001a180: 206c 696e 6b5f 6174 7472 6962 7574 6520   link_attribute 
+0001a190: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0001a1a0: 2020 2020 2069 6620 7365 6c66 2e73 696c       if self.sil
+0001a1b0: 656e 6365 5f6c 6576 656c 203c 3d20 313a  ence_level <= 1:
+0001a1c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a1d0: 2070 7269 6e74 2822 4361 6c63 756c 6174   print("Calculat
+0001a1e0: 696e 6720 616c 6c20 7368 6f72 7465 7374  ing all shortest
+0001a1f0: 2070 6174 6820 6c65 6e67 7468 732e 2e2e   path lengths...
+0001a200: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
+0001a210: 2320 6669 7865 6420 6e65 6761 7469 7665  # fixed negative
+0001a220: 206e 756d 6265 7273 2074 6f20 696e 6669   numbers to infi
+0001a230: 6e69 7479 210a 2020 2020 2020 2020 2020  nity!.          
+0001a240: 2020 706c 203d 206e 702e 6172 7261 7928    pl = np.array(
+0001a250: 7365 6c66 2e67 7261 7068 2e64 6973 7461  self.graph.dista
+0001a260: 6e63 6573 2829 2c20 6474 7970 653d 666c  nces(), dtype=fl
+0001a270: 6f61 7429 0a20 2020 2020 2020 2020 2020  oat).           
+0001a280: 2070 6c5b 706c 203c 2030 5d20 3d20 6e70   pl[pl < 0] = np
+0001a290: 2e69 6e66 0a20 2020 2020 2020 2020 2020  .inf.           
+0001a2a0: 2072 6574 7572 6e20 706c 0a20 2020 2020   return pl.     
+0001a2b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001a2c0: 2020 2020 2069 6620 7365 6c66 2e73 696c       if self.sil
+0001a2d0: 656e 6365 5f6c 6576 656c 203c 3d20 313a  ence_level <= 1:
+0001a2e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a2f0: 2070 7269 6e74 2822 4361 6c63 756c 6174   print("Calculat
+0001a300: 696e 6720 7765 6967 6874 6564 2073 686f  ing weighted sho
+0001a310: 7274 6573 7420 7061 7468 206c 656e 6774  rtest path lengt
+0001a320: 6873 2e2e 2e22 290a 0a20 2020 2020 2020  hs...")..       
+0001a330: 2020 2020 2072 6574 7572 6e20 6e70 2e61       return np.a
+0001a340: 7272 6179 280a 2020 2020 2020 2020 2020  rray(.          
+0001a350: 2020 2020 2020 7365 6c66 2e67 7261 7068        self.graph
+0001a360: 2e64 6973 7461 6e63 6573 2877 6569 6768  .distances(weigh
+0001a370: 7473 3d6c 696e 6b5f 6174 7472 6962 7574  ts=link_attribut
+0001a380: 652c 206d 6f64 653d 3129 290a 0a20 2020  e, mode=1))..   
+0001a390: 2064 6566 2061 7665 7261 6765 5f70 6174   def average_pat
+0001a3a0: 685f 6c65 6e67 7468 2873 656c 662c 206c  h_length(self, l
+0001a3b0: 696e 6b5f 6174 7472 6962 7574 653d 4e6f  ink_attribute=No
+0001a3c0: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
+0001a3d0: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
+0001a3e0: 7468 6520 6176 6572 6167 6520 2877 6569  the average (wei
+0001a3f0: 6768 7465 6429 2073 686f 7274 6573 7420  ghted) shortest 
+0001a400: 7061 7468 206c 656e 6774 6820 6265 7477  path length betw
+0001a410: 6565 6e20 616c 6c20 7061 6972 730a 2020  een all pairs.  
+0001a420: 2020 2020 2020 6f66 206e 6f64 6573 2066        of nodes f
+0001a430: 6f72 2077 6869 6368 2061 2070 6174 6820  or which a path 
+0001a440: 6578 6973 7473 2e0a 0a20 2020 2020 2020  exists...       
+0001a450: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
+0001a460: 2020 2020 2020 203e 3e3e 2070 7269 6e74         >>> print
+0001a470: 2872 284e 6574 776f 726b 2e53 6d61 6c6c  (r(Network.Small
+0001a480: 5465 7374 4e65 7477 6f72 6b28 292e 6176  TestNetwork().av
+0001a490: 6572 6167 655f 7061 7468 5f6c 656e 6774  erage_path_lengt
+0001a4a0: 6828 2929 290a 2020 2020 2020 2020 4361  h())).        Ca
+0001a4b0: 6c63 756c 6174 696e 6720 6176 6572 6167  lculating averag
+0001a4c0: 6520 2877 6569 6768 7465 6429 2073 686f  e (weighted) sho
+0001a4d0: 7274 6573 7420 7061 7468 206c 656e 6774  rtest path lengt
+0001a4e0: 682e 2e2e 0a20 2020 2020 2020 2031 2e36  h....        1.6
+0001a4f0: 3636 370a 0a20 2020 2020 2020 203a 6172  667..        :ar
+0001a500: 6720 7374 7220 6c69 6e6b 5f61 7474 7269  g str link_attri
+0001a510: 6275 7465 3a20 4f70 7469 6f6e 616c 206e  bute: Optional n
+0001a520: 616d 6520 6f66 2074 6865 206c 696e 6b20  ame of the link 
+0001a530: 6174 7472 6962 7574 6520 746f 2062 6520  attribute to be 
+0001a540: 7573 6564 0a20 2020 2020 2020 2020 2020  used.           
+0001a550: 2061 7320 7468 6520 6c69 6e6b 7327 206c   as the links' l
+0001a560: 656e 6774 682e 2049 6620 4e6f 6e65 2c20  ength. If None, 
+0001a570: 6c69 6e6b 7320 6861 7665 206c 656e 6774  links have lengt
+0001a580: 6820 312e 2028 4465 6661 756c 743a 204e  h 1. (Default: N
+0001a590: 6f6e 6529 0a20 2020 2020 2020 203a 7274  one).        :rt
+0001a5a0: 7970 653a 2066 6c6f 6174 0a20 2020 2020  ype: float.     
+0001a5b0: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+0001a5c0: 6620 6c69 6e6b 5f61 7474 7269 6275 7465  f link_attribute
+0001a5d0: 203d 3d20 2274 6f70 6f6c 6f67 6963 616c   == "topological
+0001a5e0: 223a 0a20 2020 2020 2020 2020 2020 2070  ":.            p
+0001a5f0: 7269 6e74 2822 5741 524e 494e 473a 206c  rint("WARNING: l
+0001a600: 696e 6b5f 6174 7472 6962 7574 653d 2774  ink_attribute='t
+0001a610: 6f70 6f6c 6f67 6963 616c 2720 6973 2064  opological' is d
+0001a620: 6570 7265 6361 7465 642e 5c6e 220a 2020  eprecated.\n".  
+0001a630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a640: 2b20 2255 7365 206c 696e 6b5f 6174 7472  + "Use link_attr
+0001a650: 6962 7574 653d 4e6f 6e65 2069 6e73 7465  ibute=None inste
+0001a660: 6164 2e22 290a 2020 2020 2020 2020 2020  ad.").          
+0001a670: 2020 6c69 6e6b 5f61 7474 7269 6275 7465    link_attribute
+0001a680: 203d 204e 6f6e 650a 0a20 2020 2020 2020   = None..       
+0001a690: 2069 6620 7365 6c66 2e73 696c 656e 6365   if self.silence
+0001a6a0: 5f6c 6576 656c 203c 3d20 313a 0a20 2020  _level <= 1:.   
+0001a6b0: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+0001a6c0: 4361 6c63 756c 6174 696e 6720 6176 6572  Calculating aver
+0001a6d0: 6167 6520 2877 6569 6768 7465 6429 2073  age (weighted) s
+0001a6e0: 686f 7274 6573 7420 7061 7468 206c 656e  hortest path len
+0001a6f0: 6774 682e 2e2e 2229 0a0a 2020 2020 2020  gth...")..      
+0001a700: 2020 6966 206c 696e 6b5f 6174 7472 6962    if link_attrib
+0001a710: 7574 6520 6973 204e 6f6e 653a 0a20 2020  ute is None:.   
+0001a720: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001a730: 7365 6c66 2e67 7261 7068 2e61 7665 7261  self.graph.avera
+0001a740: 6765 5f70 6174 685f 6c65 6e67 7468 2829  ge_path_length()
+0001a750: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0001a760: 2020 2020 2020 2020 2020 2070 6174 685f             path_
+0001a770: 6c65 6e67 7468 7320 3d20 7365 6c66 2e70  lengths = self.p
+0001a780: 6174 685f 6c65 6e67 7468 7328 6c69 6e6b  ath_lengths(link
+0001a790: 5f61 7474 7269 6275 7465 290a 0a20 2020  _attribute)..   
+0001a7a0: 2020 2020 2020 2020 2023 2020 4964 656e           #  Iden
+0001a7b0: 7469 6679 2075 6e63 6f6e 6e65 6374 6564  tify unconnected
+0001a7c0: 2070 6169 7273 2061 6e64 2073 6176 6520   pairs and save 
+0001a7d0: 696e 2062 696e 6172 7920 6172 7261 7920  in binary array 
+0001a7e0: 6973 696e 660a 2020 2020 2020 2020 2020  isinf.          
+0001a7f0: 2020 756e 636f 6e6e 6563 7465 645f 7061    unconnected_pa
+0001a800: 6972 7320 3d20 6e70 2e69 7369 6e66 2870  irs = np.isinf(p
+0001a810: 6174 685f 6c65 6e67 7468 7329 0a20 2020  ath_lengths).   
+0001a820: 2020 2020 2020 2020 2023 2020 436f 756e           #  Coun
+0001a830: 7420 7468 6520 6e75 6d62 6572 206f 6620  t the number of 
+0001a840: 756e 636f 6e6e 6563 7465 6420 7061 6972  unconnected pair
+0001a850: 730a 2020 2020 2020 2020 2020 2020 6e5f  s.            n_
+0001a860: 756e 636f 6e6e 6563 7465 645f 7061 6972  unconnected_pair
+0001a870: 7320 3d20 756e 636f 6e6e 6563 7465 645f  s = unconnected_
+0001a880: 7061 6972 732e 7375 6d28 290a 2020 2020  pairs.sum().    
+0001a890: 2020 2020 2020 2020 2320 2053 6574 2069          #  Set i
+0001a8a0: 6e66 696e 6974 6520 656e 7472 6965 7320  nfinite entries 
+0001a8b0: 636f 7272 6573 706f 6e64 696e 6720 746f  corresponding to
+0001a8c0: 2075 6e63 6f6e 6e65 6374 6564 2070 6169   unconnected pai
+0001a8d0: 7273 2074 6f20 7a65 726f 0a20 2020 2020  rs to zero.     
+0001a8e0: 2020 2020 2020 2070 6174 685f 6c65 6e67         path_leng
+0001a8f0: 7468 735b 756e 636f 6e6e 6563 7465 645f  ths[unconnected_
+0001a900: 7061 6972 735d 203d 2030 0a0a 2020 2020  pairs] = 0..    
+0001a910: 2020 2020 2020 2020 2320 2054 616b 6520          #  Take 
+0001a920: 6176 6572 6167 6520 6f66 2073 686f 7274  average of short
+0001a930: 6573 7420 6765 6f67 7261 7068 6963 616c  est geographical
+0001a940: 2070 6174 6820 6c65 6e67 7468 206d 6174   path length mat
+0001a950: 7269 780a 2020 2020 2020 2020 2020 2020  rix.            
+0001a960: 2320 2065 7863 6c75 6469 6e67 2074 6865  #  excluding the
+0001a970: 2064 6961 676f 6e61 6c2c 2073 696e 6365   diagonal, since
+0001a980: 2069 7420 6973 2061 6c77 6179 7320 7a65   it is always ze
+0001a990: 726f 2c20 616e 6420 616c 6c0a 2020 2020  ro, and all.    
+0001a9a0: 2020 2020 2020 2020 2320 2075 6e63 6f6e          #  uncon
+0001a9b0: 6e65 6374 6564 2070 6169 7273 2e20 2054  nected pairs.  T
+0001a9c0: 6865 2064 6961 676f 6e61 6c20 7368 6f75  he diagonal shou
+0001a9d0: 6c64 206e 6576 6572 2063 6f6e 7461 696e  ld never contain
+0001a9e0: 0a20 2020 2020 2020 2020 2020 2023 2020  .            #  
+0001a9f0: 696e 6669 6e69 7469 6573 2c20 736f 2074  infinities, so t
+0001aa00: 6861 7420 7368 6f75 6c64 206e 6f74 2062  hat should not b
+0001aa10: 6520 6120 7072 6f62 6c65 6d2e 0a20 2020  e a problem..   
+0001aa20: 2020 2020 2020 2020 2061 7665 7261 6765           average
+0001aa30: 5f70 6174 685f 6c65 6e67 7468 203d 2028  _path_length = (
+0001aa40: 7061 7468 5f6c 656e 6774 6873 2e73 756d  path_lengths.sum
+0001aa50: 2829 202f 2066 6c6f 6174 280a 2020 2020  () / float(.    
+0001aa60: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001aa70: 2e4e 202a 2028 7365 6c66 2e4e 202d 2031  .N * (self.N - 1
+0001aa80: 2920 2d20 6e5f 756e 636f 6e6e 6563 7465  ) - n_unconnecte
+0001aa90: 645f 7061 6972 7329 290a 0a20 2020 2020  d_pairs))..     
+0001aaa0: 2020 2020 2020 2023 2020 5265 7665 7273         #  Revers
+0001aab0: 6520 6368 616e 6765 7320 746f 2070 6174  e changes to pat
+0001aac0: 685f 6c65 6e67 7468 730a 2020 2020 2020  h_lengths.      
+0001aad0: 2020 2020 2020 7061 7468 5f6c 656e 6774        path_lengt
+0001aae0: 6873 5b75 6e63 6f6e 6e65 6374 6564 5f70  hs[unconnected_p
+0001aaf0: 6169 7273 5d20 3d20 6e70 2e69 6e66 0a0a  airs] = np.inf..
+0001ab00: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0001ab10: 726e 2061 7665 7261 6765 5f70 6174 685f  rn average_path_
+0001ab20: 6c65 6e67 7468 0a0a 2020 2020 4043 6163  length..    @Cac
+0001ab30: 6865 642e 6d65 7468 6f64 286e 616d 653d  hed.method(name=
+0001ab40: 2274 6865 206e 2e73 2e69 2e20 6176 6572  "the n.s.i. aver
+0001ab50: 6167 6520 7368 6f72 7465 7374 2070 6174  age shortest pat
+0001ab60: 6820 6c65 6e67 7468 222c 0a20 2020 2020  h length",.     
+0001ab70: 2020 2020 2020 2020 2020 2020 2020 6174                at
+0001ab80: 7472 733d 2822 5f6d 7574 5f6e 7722 2c29  trs=("_mut_nw",)
+0001ab90: 290a 2020 2020 6465 6620 6e73 695f 6176  ).    def nsi_av
+0001aba0: 6572 6167 655f 7061 7468 5f6c 656e 6774  erage_path_lengt
+0001abb0: 6828 7365 6c66 293a 0a20 2020 2020 2020  h(self):.       
+0001abc0: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
+0001abd0: 7572 6e20 7468 6520 6e2e 732e 692e 2061  urn the n.s.i. a
+0001abe0: 7665 7261 6765 2073 686f 7274 6573 7420  verage shortest 
+0001abf0: 7061 7468 206c 656e 6774 6820 6265 7477  path length betw
+0001ac00: 6565 6e20 616c 6c20 7061 6972 7320 6f66  een all pairs of
+0001ac10: 0a20 2020 2020 2020 206e 6f64 6573 2066  .        nodes f
+0001ac20: 6f72 2077 6869 6368 2061 2070 6174 6820  or which a path 
+0001ac30: 6578 6973 7473 2e0a 0a20 2020 2020 2020  exists...       
+0001ac40: 2054 6865 2070 6174 6820 6c65 6e67 7468   The path length
+0001ac50: 2066 726f 6d20 6120 6e6f 6465 2074 6f20   from a node to 
+0001ac60: 6974 7365 6c66 2069 7320 636f 6e73 6964  itself is consid
+0001ac70: 6572 6564 2074 6f20 6265 2031 2074 6f20  ered to be 1 to 
+0001ac80: 6163 6869 6576 650a 2020 2020 2020 2020  achieve.        
+0001ac90: 6e6f 6465 2073 706c 6974 7469 6e67 2069  node splitting i
+0001aca0: 6e76 6172 6961 6e63 652e 0a0a 2020 2020  nvariance...    
+0001acb0: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
+0001acc0: 0a0a 2020 2020 2020 2020 3e3e 3e20 6e65  ..        >>> ne
+0001acd0: 7420 3d20 4e65 7477 6f72 6b2e 536d 616c  t = Network.Smal
+0001ace0: 6c54 6573 744e 6574 776f 726b 2829 0a20  lTestNetwork(). 
+0001acf0: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+0001ad00: 2e6e 7369 5f61 7665 7261 6765 5f70 6174  .nsi_average_pat
+0001ad10: 685f 6c65 6e67 7468 2829 290a 2020 2020  h_length()).    
+0001ad20: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+0001ad30: 6e2e 732e 692e 2061 7665 7261 6765 2073  n.s.i. average s
+0001ad40: 686f 7274 6573 7420 7061 7468 206c 656e  hortest path len
+0001ad50: 6774 682e 2e2e 0a20 2020 2020 2020 2043  gth....        C
+0001ad60: 616c 6375 6c61 7469 6e67 2061 6c6c 2073  alculating all s
+0001ad70: 686f 7274 6573 7420 7061 7468 206c 656e  hortest path len
+0001ad80: 6774 6873 2e2e 2e0a 2020 2020 2020 2020  gths....        
+0001ad90: 312e 3630 3033 0a20 2020 2020 2020 203e  1.6003.        >
+0001ada0: 3e3e 2072 286e 6574 2e73 706c 6974 7465  >> r(net.splitte
+0001adb0: 645f 636f 7079 2829 2e6e 7369 5f61 7665  d_copy().nsi_ave
+0001adc0: 7261 6765 5f70 6174 685f 6c65 6e67 7468  rage_path_length
+0001add0: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
+0001ade0: 756c 6174 696e 6720 6e2e 732e 692e 2061  ulating n.s.i. a
+0001adf0: 7665 7261 6765 2073 686f 7274 6573 7420  verage shortest 
+0001ae00: 7061 7468 206c 656e 6774 682e 2e2e 0a20  path length.... 
+0001ae10: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
+0001ae20: 6e67 2061 6c6c 2073 686f 7274 6573 7420  ng all shortest 
+0001ae30: 7061 7468 206c 656e 6774 6873 2e2e 2e0a  path lengths....
+0001ae40: 2020 2020 2020 2020 312e 3630 3033 0a0a          1.6003..
+0001ae50: 2020 2020 2020 2020 6173 2063 6f6d 7061          as compa
+0001ae60: 7265 6420 746f 2074 6865 2075 6e77 6569  red to the unwei
+0001ae70: 6768 7465 6420 7665 7273 696f 6e3a 0a0a  ghted version:..
+0001ae80: 2020 2020 2020 2020 3e3e 3e20 6e65 7420          >>> net 
+0001ae90: 3d20 4e65 7477 6f72 6b2e 536d 616c 6c54  = Network.SmallT
+0001aea0: 6573 744e 6574 776f 726b 2829 0a20 2020  estNetwork().   
+0001aeb0: 2020 2020 203e 3e3e 2072 286e 6574 2e61       >>> r(net.a
+0001aec0: 7665 7261 6765 5f70 6174 685f 6c65 6e67  verage_path_leng
+0001aed0: 7468 2829 290a 2020 2020 2020 2020 4361  th()).        Ca
+0001aee0: 6c63 756c 6174 696e 6720 6176 6572 6167  lculating averag
+0001aef0: 6520 2877 6569 6768 7465 6429 2073 686f  e (weighted) sho
+0001af00: 7274 6573 7420 7061 7468 206c 656e 6774  rtest path lengt
+0001af10: 682e 2e2e 0a20 2020 2020 2020 2031 2e36  h....        1.6
+0001af20: 3636 370a 2020 2020 2020 2020 3e3e 3e20  667.        >>> 
+0001af30: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
+0001af40: 6f70 7928 292e 6176 6572 6167 655f 7061  opy().average_pa
+0001af50: 7468 5f6c 656e 6774 6828 2929 0a20 2020  th_length()).   
+0001af60: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+0001af70: 2061 7665 7261 6765 2028 7765 6967 6874   average (weight
+0001af80: 6564 2920 7368 6f72 7465 7374 2070 6174  ed) shortest pat
+0001af90: 6820 6c65 6e67 7468 2e2e 2e0a 2020 2020  h length....    
+0001afa0: 2020 2020 312e 3736 3139 0a0a 2020 2020      1.7619..    
+0001afb0: 2020 2020 3a72 7479 7065 3a20 666c 6f61      :rtype: floa
+0001afc0: 740a 2020 2020 2020 2020 2222 220a 2020  t.        """.  
+0001afd0: 2020 2020 2020 7720 3d20 7365 6c66 2e6e        w = self.n
+0001afe0: 6f64 655f 7765 6967 6874 730a 2020 2020  ode_weights.    
+0001aff0: 2020 2020 2320 7365 7420 6469 6167 6f6e      # set diagon
+0001b000: 616c 2074 6f20 3120 286e 6f64 6573 2067  al to 1 (nodes g
+0001b010: 6574 2075 6e69 7420 6469 7374 616e 6365  et unit distance
+0001b020: 2074 6f20 7468 656d 7365 6c76 6573 290a   to themselves).
+0001b030: 2020 2020 2020 2020 6e73 695f 6469 7374          nsi_dist
+0001b040: 616e 6365 7320 3d20 7365 6c66 2e70 6174  ances = self.pat
+0001b050: 685f 6c65 6e67 7468 7328 2920 2b20 6e70  h_lengths() + np
+0001b060: 2e69 6465 6e74 6974 7928 7365 6c66 2e4e  .identity(self.N
+0001b070: 290a 2020 2020 2020 2020 7765 6967 6874  ).        weight
+0001b080: 5f70 726f 6475 6374 7320 3d20 6e70 2e6f  _products = np.o
+0001b090: 7574 6572 2877 2c20 7729 0a0a 2020 2020  uter(w, w)..    
+0001b0a0: 2020 2020 2320 2053 6574 2069 6e66 696e      #  Set infin
+0001b0b0: 6974 6520 656e 7472 6965 7320 636f 7272  ite entries corr
+0001b0c0: 6573 706f 6e64 696e 6720 746f 2075 6e63  esponding to unc
+0001b0d0: 6f6e 6e65 6374 6564 2070 6169 7273 2074  onnected pairs t
+0001b0e0: 6f20 7a65 726f 0a20 2020 2020 2020 2075  o zero.        u
+0001b0f0: 6e63 6f6e 6e65 6374 6564 5f70 6169 7273  nconnected_pairs
+0001b100: 203d 206e 702e 6973 696e 6628 6e73 695f   = np.isinf(nsi_
+0001b110: 6469 7374 616e 6365 7329 0a20 2020 2020  distances).     
+0001b120: 2020 206e 7369 5f64 6973 7461 6e63 6573     nsi_distances
+0001b130: 5b75 6e63 6f6e 6e65 6374 6564 5f70 6169  [unconnected_pai
+0001b140: 7273 5d20 3d20 300a 2020 2020 2020 2020  rs] = 0.        
+0001b150: 7765 6967 6874 5f70 726f 6475 6374 735b  weight_products[
+0001b160: 756e 636f 6e6e 6563 7465 645f 7061 6972  unconnected_pair
+0001b170: 735d 203d 2030 0a0a 2020 2020 2020 2020  s] = 0..        
+0001b180: 2320 6e73 695f 6469 7374 616e 6365 7320  # nsi_distances 
+0001b190: 6973 206e 6f74 2073 7061 7273 652c 2073  is not sparse, s
+0001b1a0: 6f20 7765 2075 7365 206d 6174 7269 7820  o we use matrix 
+0001b1b0: 7072 6f64 7563 740a 2020 2020 2020 2020  product.        
+0001b1c0: 7265 7475 726e 2077 2e64 6f74 286e 7369  return w.dot(nsi
+0001b1d0: 5f64 6973 7461 6e63 6573 2e64 6f74 2877  _distances.dot(w
+0001b1e0: 2929 202f 2077 6569 6768 745f 7072 6f64  )) / weight_prod
+0001b1f0: 7563 7473 2e73 756d 2829 0a0a 2020 2020  ucts.sum()..    
+0001b200: 6465 6620 6469 616d 6574 6572 2873 656c  def diameter(sel
+0001b210: 662c 2064 6972 6563 7465 643d 5472 7565  f, directed=True
+0001b220: 2c20 6f6e 6c79 5f63 6f6e 6e65 6374 6564  , only_connected
+0001b230: 3d54 7275 6529 3a0a 2020 2020 2020 2020  =True):.        
+0001b240: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
+0001b250: 726e 2074 6865 2064 6961 6d65 7465 7220  rn the diameter 
+0001b260: 286c 6172 6765 7374 2073 686f 7274 6573  (largest shortes
+0001b270: 7420 7061 7468 206c 656e 6774 6820 6265  t path length be
+0001b280: 7477 6565 6e20 616e 7920 6e6f 6465 7329  tween any nodes)
+0001b290: 2e0a 0a20 2020 2020 2020 202a 2a45 7861  ...        **Exa
+0001b2a0: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+0001b2b0: 203e 3e3e 2070 7269 6e74 284e 6574 776f   >>> print(Netwo
+0001b2c0: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
+0001b2d0: 6f72 6b28 292e 6469 616d 6574 6572 2829  ork().diameter()
+0001b2e0: 290a 2020 2020 2020 2020 330a 0a20 2020  ).        3..   
+0001b2f0: 2020 2020 203a 6172 6720 626f 6f6c 2064       :arg bool d
+0001b300: 6972 6563 7465 643a 2049 6e64 6963 6174  irected: Indicat
+0001b310: 6573 2077 6865 7468 6572 2074 6f20 7265  es whether to re
+0001b320: 7370 6563 7420 6c69 6e6b 2064 6972 6563  spect link direc
+0001b330: 7469 6f6e 7320 6966 2074 6865 0a20 2020  tions if the.   
+0001b340: 2020 2020 2020 2020 206e 6574 776f 726b           network
+0001b350: 2069 7320 6469 7265 6374 6564 2e20 2844   is directed. (D
+0001b360: 6566 6175 6c74 3a20 5472 7565 290a 2020  efault: True).  
+0001b370: 2020 2020 2020 3a61 7267 2062 6f6f 6c20        :arg bool 
+0001b380: 6f6e 6c79 5f63 6f6e 6e65 6374 6564 3a20  only_connected: 
+0001b390: 496e 6469 6361 7465 7320 7768 6574 6865  Indicates whethe
+0001b3a0: 7220 746f 2075 7365 206f 6e6c 7920 7061  r to use only pa
+0001b3b0: 6972 7320 6f66 206e 6f64 6573 0a20 2020  irs of nodes.   
+0001b3c0: 2020 2020 2020 2020 2077 6974 6820 6120           with a 
+0001b3d0: 636f 6e6e 6563 7469 6e67 2070 6174 682e  connecting path.
+0001b3e0: 2049 6620 4661 6c73 6520 616e 6420 7468   If False and th
+0001b3f0: 6520 6e65 7477 6f72 6b20 6973 2075 6e63  e network is unc
+0001b400: 6f6e 6e65 6374 6564 2c0a 2020 2020 2020  onnected,.      
+0001b410: 2020 2020 2020 7468 6520 6e75 6d62 6572        the number
+0001b420: 206f 6620 616c 6c20 6e6f 6465 7320 6973   of all nodes is
+0001b430: 2072 6574 7572 6e65 642e 2020 2844 6566   returned.  (Def
+0001b440: 6175 6c74 3a20 5472 7565 290a 2020 2020  ault: True).    
+0001b450: 2020 2020 3a72 7479 7065 3a20 696e 7420      :rtype: int 
+0001b460: 3e3d 2030 0a20 2020 2020 2020 2022 2222  >= 0.        """
+0001b470: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001b480: 7365 6c66 2e67 7261 7068 2e64 6961 6d65  self.graph.diame
+0001b490: 7465 7228 6469 7265 6374 6564 3d64 6972  ter(directed=dir
+0001b4a0: 6563 7465 642c 2075 6e63 6f6e 6e3d 6f6e  ected, unconn=on
+0001b4b0: 6c79 5f63 6f6e 6e65 6374 6564 290a 0a20  ly_connected).. 
+0001b4c0: 2020 2023 0a20 2020 2023 2020 4c69 6e6b     #.    #  Link
+0001b4d0: 2076 616c 7565 6420 6d65 6173 7572 6573   valued measures
+0001b4e0: 0a20 2020 2023 0a0a 2020 2020 4043 6163  .    #..    @Cac
+0001b4f0: 6865 642e 6d65 7468 6f64 286e 616d 653d  hed.method(name=
+0001b500: 226d 6174 6368 696e 6720 696e 6465 7820  "matching index 
+0001b510: 6d61 7472 6978 2229 0a20 2020 2064 6566  matrix").    def
+0001b520: 206d 6174 6368 696e 675f 696e 6465 7828   matching_index(
+0001b530: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+0001b540: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
+0001b550: 6163 6820 7061 6972 206f 6620 6e6f 6465  ach pair of node
+0001b560: 732c 2072 6574 7572 6e20 7468 6569 7220  s, return their 
+0001b570: 6d61 7463 6869 6e67 2069 6e64 6578 2e0a  matching index..
+0001b580: 0a20 2020 2020 2020 2054 6869 7320 6973  .        This is
+0001b590: 2074 6865 2072 6174 696f 206f 6620 7468   the ratio of th
+0001b5a0: 6520 6e75 6d62 6572 206f 6620 636f 6d6d  e number of comm
+0001b5b0: 6f6e 206e 6569 6768 626f 7273 2061 6e64  on neighbors and
+0001b5c0: 2074 6865 206e 756d 6265 7220 6f66 0a20   the number of. 
+0001b5d0: 2020 2020 2020 206e 6f64 6573 206c 696e         nodes lin
+0001b5e0: 6b65 6420 746f 2061 7420 6c65 6173 7420  ked to at least 
+0001b5f0: 6f6e 6520 6f66 2074 6865 2074 776f 206e  one of the two n
+0001b600: 6f64 6573 2e0a 0a20 2020 2020 2020 202a  odes...        *
+0001b610: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+0001b620: 2020 2020 203e 3e3e 2070 7269 6e74 2872       >>> print(r
+0001b630: 284e 6574 776f 726b 2e53 6d61 6c6c 5465  (Network.SmallTe
+0001b640: 7374 4e65 7477 6f72 6b28 292e 6d61 7463  stNetwork().matc
+0001b650: 6869 6e67 5f69 6e64 6578 2829 2929 0a20  hing_index())). 
+0001b660: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
+0001b670: 6e67 206d 6174 6368 696e 6720 696e 6465  ng matching inde
+0001b680: 7820 6d61 7472 6978 2e2e 2e0a 2020 2020  x matrix....    
+0001b690: 2020 2020 5b5b 2031 2e20 2020 2030 2e35      [[ 1.    0.5
+0001b6a0: 2020 2030 2e32 3520 2020 2030 2e20 2020     0.25    0.   
+0001b6b0: 2020 2030 2e20 2020 2020 2030 2e20 2020     0.      0.   
+0001b6c0: 205d 0a20 2020 2020 2020 2020 5b20 302e   ].         [ 0.
+0001b6d0: 3520 2020 312e 2020 2020 302e 3235 2020  5   1.    0.25  
+0001b6e0: 2020 302e 2020 2020 2020 302e 3220 2020    0.      0.2   
+0001b6f0: 2020 302e 2020 2020 5d0a 2020 2020 2020    0.    ].      
+0001b700: 2020 205b 2030 2e32 3520 2030 2e32 3520     [ 0.25  0.25 
+0001b710: 2031 2e20 2020 2020 2030 2e33 3333 3320   1.      0.3333 
+0001b720: 2030 2e32 3520 2020 2030 2e20 2020 205d   0.25    0.    ]
+0001b730: 0a20 2020 2020 2020 2020 5b20 302e 2020  .         [ 0.  
+0001b740: 2020 302e 2020 2020 302e 3333 3333 2020    0.    0.3333  
+0001b750: 312e 2020 2020 2020 302e 3636 3637 2020  1.      0.6667  
+0001b760: 302e 3520 2020 5d0a 2020 2020 2020 2020  0.5   ].        
+0001b770: 205b 2030 2e20 2020 2030 2e32 2020 2030   [ 0.    0.2   0
+0001b780: 2e32 3520 2020 2030 2e36 3636 3720 2031  .25    0.6667  1
+0001b790: 2e20 2020 2020 2030 2e33 3333 335d 0a20  .      0.3333]. 
+0001b7a0: 2020 2020 2020 2020 5b20 302e 2020 2020          [ 0.    
+0001b7b0: 302e 2020 2020 302e 2020 2020 2020 302e  0.    0.      0.
+0001b7c0: 3520 2020 2020 302e 3333 3333 2020 312e  5     0.3333  1.
+0001b7d0: 2020 2020 5d5d 0a0a 2020 2020 2020 2020      ]]..        
+0001b7e0: 3a72 7479 7065 3a20 6172 7261 7928 5b5b  :rtype: array([[
+0001b7f0: 303c 3d66 6c6f 6174 3c3d 312c 303c 3d66  0<=float<=1,0<=f
+0001b800: 6c6f 6174 3c3d 315d 5d29 0a20 2020 2020  loat<=1]]).     
+0001b810: 2020 2022 2222 0a20 2020 2020 2020 2063     """.        c
+0001b820: 6f6d 6d6f 6e73 203d 2028 7365 6c66 2e73  ommons = (self.s
+0001b830: 705f 4120 2a20 7365 6c66 2e73 705f 4129  p_A * self.sp_A)
+0001b840: 2e61 7374 7970 6528 4446 4945 4c44 292e  .astype(DFIELD).
+0001b850: 410a 2020 2020 2020 2020 6b6b 203d 206e  A.        kk = n
+0001b860: 702e 7265 7065 6174 285b 7365 6c66 2e64  p.repeat([self.d
+0001b870: 6567 7265 6528 295d 2c20 7365 6c66 2e4e  egree()], self.N
+0001b880: 2c20 6178 6973 3d30 290a 2020 2020 2020  , axis=0).      
+0001b890: 2020 7265 7475 726e 2063 6f6d 6d6f 6e73    return commons
+0001b8a0: 202f 2028 6b6b 202b 206b 6b2e 5420 2d20   / (kk + kk.T - 
+0001b8b0: 636f 6d6d 6f6e 7329 0a0a 2020 2020 4043  commons)..    @C
+0001b8c0: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+0001b8d0: 653d 226c 696e 6b20 6265 7477 6565 6e6e  e="link betweenn
+0001b8e0: 6573 7322 290a 2020 2020 6465 6620 6c69  ess").    def li
+0001b8f0: 6e6b 5f62 6574 7765 656e 6e65 7373 2873  nk_betweenness(s
+0001b900: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+0001b910: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
+0001b920: 6368 206c 696e 6b2c 2072 6574 7572 6e20  ch link, return 
+0001b930: 6974 7320 6265 7477 6565 6e6e 6573 732e  its betweenness.
+0001b940: 0a0a 2020 2020 2020 2020 5468 6973 206d  ..        This m
+0001b950: 6561 7375 7265 7320 6f6e 2068 6f77 206c  easures on how l
+0001b960: 696b 656c 7920 7468 6520 6c69 6e6b 2069  ikely the link i
+0001b970: 7320 6f6e 2061 2072 616e 646f 6d6c 7920  s on a randomly 
+0001b980: 6368 6f73 656e 2073 686f 7274 6573 740a  chosen shortest.
+0001b990: 2020 2020 2020 2020 7061 7468 2069 6e20          path in 
+0001b9a0: 7468 6520 6e65 7477 6f72 6b2e 0a0a 2020  the network...  
+0001b9b0: 2020 2020 2020 2844 6f65 7320 6e6f 7420        (Does not 
+0001b9c0: 7265 7370 6563 7420 6469 7265 6374 696f  respect directio
+0001b9d0: 6e61 6c69 7479 206f 6620 6c69 6e6b 732e  nality of links.
+0001b9e0: 290a 0a20 2020 2020 2020 202a 2a45 7861  )..        **Exa
+0001b9f0: 6d70 6c65 3a2a 2a0a 0a20 2020 2020 2020  mple:**..       
+0001ba00: 203e 3e3e 2070 7269 6e74 284e 6574 776f   >>> print(Netwo
+0001ba10: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
+0001ba20: 6f72 6b28 292e 6c69 6e6b 5f62 6574 7765  ork().link_betwe
+0001ba30: 656e 6e65 7373 2829 290a 2020 2020 2020  enness()).      
+0001ba40: 2020 4361 6c63 756c 6174 696e 6720 6c69    Calculating li
+0001ba50: 6e6b 2062 6574 7765 656e 6e65 7373 2e2e  nk betweenness..
+0001ba60: 2e0a 2020 2020 2020 2020 5b5b 2030 2e20  ..        [[ 0. 
+0001ba70: 2020 302e 2020 2030 2e20 2020 332e 3520    0.   0.   3.5 
+0001ba80: 2035 2e35 2020 352e 205d 205b 2030 2e20   5.5  5. ] [ 0. 
+0001ba90: 2020 302e 2020 2032 2e20 2020 332e 3520    0.   2.   3.5 
+0001baa0: 2032 2e35 2020 302e 205d 0a20 2020 2020   2.5  0. ].     
+0001bab0: 2020 2020 5b20 302e 2020 2032 2e20 2020      [ 0.   2.   
+0001bac0: 302e 2020 2030 2e20 2020 332e 2020 2030  0.   0.   3.   0
+0001bad0: 2e20 5d20 5b20 332e 3520 2033 2e35 2020  . ] [ 3.5  3.5  
+0001bae0: 302e 2020 2030 2e20 2020 302e 2020 2030  0.   0.   0.   0
+0001baf0: 2e20 5d0a 2020 2020 2020 2020 205b 2035  . ].         [ 5
+0001bb00: 2e35 2020 322e 3520 2033 2e20 2020 302e  .5  2.5  3.   0.
+0001bb10: 2020 2030 2e20 2020 302e 205d 205b 2035     0.   0. ] [ 5
+0001bb20: 2e20 2020 302e 2020 2030 2e20 2020 302e  .   0.   0.   0.
+0001bb30: 2020 2030 2e20 2020 302e 205d 5d0a 0a20     0.   0. ]].. 
+0001bb40: 2020 2020 2020 203a 7274 7970 653a 2020         :rtype:  
+0001bb50: 7371 7561 7265 206e 756d 7079 2061 7272  square numpy arr
+0001bb60: 6179 205b 6e6f 6465 2c6e 6f64 655d 206f  ay [node,node] o
+0001bb70: 6620 666c 6f61 7473 0a20 2020 2020 2020  f floats.       
+0001bb80: 203a 7265 7475 726e 3a20 456e 7472 7920   :return: Entry 
+0001bb90: 5b69 2c6a 5d20 6973 2074 6865 2062 6574  [i,j] is the bet
+0001bba0: 7765 656e 6e65 7373 206f 6620 7468 6520  weenness of the 
+0001bbb0: 6c69 6e6b 2062 6574 7765 656e 2069 2061  link between i a
+0001bbc0: 6e64 206a 2c0a 2020 2020 2020 2020 2020  nd j,.          
+0001bbd0: 2020 2020 2020 206f 7220 3020 6966 2069         or 0 if i
+0001bbe0: 2069 7320 6e6f 7420 6c69 6e6b 6564 2074   is not linked t
+0001bbf0: 6f20 6a2e 0a20 2020 2020 2020 2022 2222  o j..        """
+0001bc00: 0a20 2020 2020 2020 2023 2020 4361 6c63  .        #  Calc
+0001bc10: 756c 6174 6520 6c69 6e6b 2062 6574 7765  ulate link betwe
+0001bc20: 656e 6e65 7373 0a20 2020 2020 2020 206c  enness.        l
+0001bc30: 696e 6b5f 6265 7477 6565 6e6e 6573 7320  ink_betweenness 
+0001bc40: 3d20 7365 6c66 2e67 7261 7068 2e65 6467  = self.graph.edg
+0001bc50: 655f 6265 7477 6565 6e6e 6573 7328 290a  e_betweenness().
+0001bc60: 0a20 2020 2020 2020 2023 2020 496e 6974  .        #  Init
+0001bc70: 6961 6c69 7a65 0a20 2020 2020 2020 2072  ialize.        r
+0001bc80: 6573 756c 742c 2065 636f 756e 7420 3d20  esult, ecount = 
+0001bc90: 6e70 2e7a 6572 6f73 2828 7365 6c66 2e4e  np.zeros((self.N
+0001bca0: 2c20 7365 6c66 2e4e 2929 2c20 300a 0a20  , self.N)), 0.. 
+0001bcb0: 2020 2020 2020 2023 2020 4765 7420 6772         #  Get gr
+0001bcc0: 6170 6820 6164 6a61 6365 6e63 7920 6c69  aph adjacency li
+0001bcd0: 7374 0a20 2020 2020 2020 2041 5f6c 6973  st.        A_lis
+0001bce0: 7420 3d20 7365 6c66 2e67 7261 7068 2e67  t = self.graph.g
+0001bcf0: 6574 5f61 646a 6c69 7374 2829 0a0a 2020  et_adjlist()..  
+0001bd00: 2020 2020 2020 2320 2057 7269 7465 206c        #  Write l
+0001bd10: 696e 6b20 6265 7477 6565 6e6e 6573 7320  ink betweenness 
+0001bd20: 7661 6c75 6573 2074 6f20 6d61 7472 6978  values to matrix
+0001bd30: 0a20 2020 2020 2020 2066 6f72 2069 2c20  .        for i, 
+0001bd40: 4169 2069 6e20 656e 756d 6572 6174 6528  Ai in enumerate(
+0001bd50: 415f 6c69 7374 293a 0a20 2020 2020 2020  A_list):.       
+0001bd60: 2020 2020 2066 6f72 206a 2069 6e20 4169       for j in Ai
+0001bd70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001bd80: 2020 2320 204f 6e6c 7920 7669 7369 7420    #  Only visit 
+0001bd90: 6c69 6e6b 7320 6f6e 6365 0a20 2020 2020  links once.     
+0001bda0: 2020 2020 2020 2020 2020 2069 6620 6920             if i 
+0001bdb0: 3c20 6a3a 0a20 2020 2020 2020 2020 2020  < j:.           
+0001bdc0: 2020 2020 2020 2020 2072 6573 756c 745b           result[
+0001bdd0: 692c 206a 5d20 3d20 7265 7375 6c74 5b6a  i, j] = result[j
+0001bde0: 2c20 695d 203d 206c 696e 6b5f 6265 7477  , i] = link_betw
+0001bdf0: 6565 6e6e 6573 735b 6563 6f75 6e74 5d0a  eenness[ecount].
+0001be00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001be10: 2020 2020 6563 6f75 6e74 202b 3d20 310a      ecount += 1.
+0001be20: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+0001be30: 6573 756c 740a 0a20 2020 2064 6566 2065  esult..    def e
+0001be40: 6467 655f 6265 7477 6565 6e6e 6573 7328  dge_betweenness(
+0001be50: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+0001be60: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
+0001be70: 6163 6820 6c69 6e6b 2c20 7265 7475 726e  ach link, return
+0001be80: 2069 7473 2062 6574 7765 656e 6e65 7373   its betweenness
+0001be90: 2e0a 0a20 2020 2020 2020 2041 6c69 6173  ...        Alias
+0001bea0: 2074 6f20 3a6d 6574 683a 606c 696e 6b5f   to :meth:`link_
+0001beb0: 6265 7477 6565 6e6e 6573 7360 2e20 5468  betweenness`. Th
+0001bec0: 6973 206d 6561 7375 7265 7320 6f6e 2068  is measures on h
+0001bed0: 6f77 206c 696b 656c 7920 7468 650a 2020  ow likely the.  
+0001bee0: 2020 2020 2020 6c69 6e6b 2069 7320 6f6e        link is on
+0001bef0: 2061 2072 616e 646f 6d6c 7920 6368 6f73   a randomly chos
+0001bf00: 656e 2073 686f 7274 6573 7420 7061 7468  en shortest path
+0001bf10: 2069 6e20 7468 6520 6e65 7477 6f72 6b2e   in the network.
+0001bf20: 0a0a 2020 2020 2020 2020 2844 6f65 7320  ..        (Does 
+0001bf30: 6e6f 7420 7265 7370 6563 7420 6469 7265  not respect dire
+0001bf40: 6374 696f 6e61 6c69 7479 206f 6620 6c69  ctionality of li
+0001bf50: 6e6b 732e 290a 0a20 2020 2020 2020 202a  nks.)..        *
+0001bf60: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+0001bf70: 2020 2020 203e 3e3e 2070 7269 6e74 284e       >>> print(N
+0001bf80: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
+0001bf90: 4e65 7477 6f72 6b28 292e 6564 6765 5f62  Network().edge_b
+0001bfa0: 6574 7765 656e 6e65 7373 2829 290a 2020  etweenness()).  
+0001bfb0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+0001bfc0: 6720 6c69 6e6b 2062 6574 7765 656e 6e65  g link betweenne
+0001bfd0: 7373 2e2e 2e0a 2020 2020 2020 2020 5b5b  ss....        [[
+0001bfe0: 2030 2e20 2020 302e 2020 2030 2e20 2020   0.   0.   0.   
+0001bff0: 332e 3520 2035 2e35 2020 352e 205d 205b  3.5  5.5  5. ] [
+0001c000: 2030 2e20 2020 302e 2020 2032 2e20 2020   0.   0.   2.   
+0001c010: 332e 3520 2032 2e35 2020 302e 205d 0a20  3.5  2.5  0. ]. 
+0001c020: 2020 2020 2020 2020 5b20 302e 2020 2032          [ 0.   2
+0001c030: 2e20 2020 302e 2020 2030 2e20 2020 332e  .   0.   0.   3.
+0001c040: 2020 2030 2e20 5d20 5b20 332e 3520 2033     0. ] [ 3.5  3
+0001c050: 2e35 2020 302e 2020 2030 2e20 2020 302e  .5  0.   0.   0.
+0001c060: 2020 2030 2e20 5d0a 2020 2020 2020 2020     0. ].        
+0001c070: 205b 2035 2e35 2020 322e 3520 2033 2e20   [ 5.5  2.5  3. 
+0001c080: 2020 302e 2020 2030 2e20 2020 302e 205d    0.   0.   0. ]
+0001c090: 205b 2035 2e20 2020 302e 2020 2030 2e20   [ 5.   0.   0. 
+0001c0a0: 2020 302e 2020 2030 2e20 2020 302e 205d    0.   0.   0. ]
+0001c0b0: 5d0a 0a20 2020 2020 2020 203a 7274 7970  ]..        :rtyp
+0001c0c0: 653a 2020 7371 7561 7265 206e 756d 7079  e:  square numpy
+0001c0d0: 2061 7272 6179 205b 6e6f 6465 2c6e 6f64   array [node,nod
+0001c0e0: 655d 206f 6620 666c 6f61 7473 0a20 2020  e] of floats.   
+0001c0f0: 2020 2020 203a 7265 7475 726e 3a20 456e       :return: En
+0001c100: 7472 7920 5b69 2c6a 5d20 6973 2074 6865  try [i,j] is the
+0001c110: 2062 6574 7765 656e 6e65 7373 206f 6620   betweenness of 
+0001c120: 7468 6520 6c69 6e6b 2062 6574 7765 656e  the link between
+0001c130: 2069 2061 6e64 206a 2c0a 2020 2020 2020   i and j,.      
+0001c140: 2020 2020 2020 2020 2020 206f 7220 3020             or 0 
+0001c150: 6966 2069 2069 7320 6e6f 7420 6c69 6e6b  if i is not link
+0001c160: 6564 2074 6f20 6a2e 0a20 2020 2020 2020  ed to j..       
+0001c170: 2022 2222 0a20 2020 2020 2020 2072 6574   """.        ret
+0001c180: 7572 6e20 7365 6c66 2e6c 696e 6b5f 6265  urn self.link_be
+0001c190: 7477 6565 6e6e 6573 7328 290a 0a20 2020  tweenness()..   
+0001c1a0: 2023 0a20 2020 2023 2020 4e6f 6465 2076   #.    #  Node v
+0001c1b0: 616c 7565 6420 6365 6e74 7261 6c69 7479  alued centrality
+0001c1c0: 206d 6561 7375 7265 730a 2020 2020 230a   measures.    #.
+0001c1d0: 0a20 2020 2040 4361 6368 6564 2e6d 6574  .    @Cached.met
+0001c1e0: 686f 6428 6e61 6d65 3d22 6e6f 6465 2062  hod(name="node b
+0001c1f0: 6574 7765 656e 6e65 7373 2229 0a20 2020  etweenness").   
+0001c200: 2064 6566 2062 6574 7765 656e 6e65 7373   def betweenness
+0001c210: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0001c220: 2222 220a 2020 2020 2020 2020 466f 7220  """.        For 
+0001c230: 6561 6368 206e 6f64 652c 2072 6574 7572  each node, retur
+0001c240: 6e20 6974 7320 6265 7477 6565 6e6e 6573  n its betweennes
+0001c250: 732e 0a0a 2020 2020 2020 2020 5468 6973  s...        This
+0001c260: 206d 6561 7375 7265 7320 726f 7567 686c   measures roughl
+0001c270: 7920 686f 7720 6d61 6e79 2073 686f 7274  y how many short
+0001c280: 6573 7420 7061 7468 7320 7061 7373 2074  est paths pass t
+0001c290: 6872 6f75 6768 2074 6865 206e 6f64 652e  hrough the node.
+0001c2a0: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
+0001c2b0: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
+0001c2c0: 3e3e 3e20 4e65 7477 6f72 6b2e 536d 616c  >>> Network.Smal
+0001c2d0: 6c54 6573 744e 6574 776f 726b 2829 2e62  lTestNetwork().b
+0001c2e0: 6574 7765 656e 6e65 7373 2829 0a20 2020  etweenness().   
+0001c2f0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+0001c300: 206e 6f64 6520 6265 7477 6565 6e6e 6573   node betweennes
+0001c310: 732e 2e2e 0a20 2020 2020 2020 2061 7272  s....        arr
+0001c320: 6179 285b 2034 2e35 2c20 2031 2e35 2c20  ay([ 4.5,  1.5, 
+0001c330: 2030 2e20 2c20 2031 2e20 2c20 2033 2e20   0. ,  1. ,  3. 
+0001c340: 2c20 2030 2e20 5d29 0a0a 2020 2020 2020  ,  0. ])..      
+0001c350: 2020 3a72 7479 7065 3a20 3164 206e 756d    :rtype: 1d num
+0001c360: 7079 2061 7272 6179 205b 6e6f 6465 5d20  py array [node] 
+0001c370: 6f66 2066 6c6f 6174 7320 3e3d 2030 0a20  of floats >= 0. 
+0001c380: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001c390: 2020 2023 2020 5265 7475 726e 2074 6865     #  Return the
+0001c3a0: 2061 6273 6f6c 7574 6520 7661 6c75 6520   absolute value 
+0001c3b0: 6f66 206e 6f72 6d65 6420 7462 632c 2073  of normed tbc, s
+0001c3c0: 696e 6365 2061 2062 7567 2073 6f6d 6574  ince a bug somet
+0001c3d0: 696d 6573 0a20 2020 2020 2020 2023 2020  imes.        #  
+0001c3e0: 7265 7375 6c74 7320 696e 206e 6567 6174  results in negat
+0001c3f0: 6976 6520 7369 676e 730a 2020 2020 2020  ive signs.      
+0001c400: 2020 2320 2054 6865 206d 6561 7375 7265    #  The measure
+0001c410: 2069 7320 6e6f 726d 6564 2062 7920 7468   is normed by th
+0001c420: 6520 6d61 7869 6d75 6d20 6265 7477 6565  e maximum betwee
+0001c430: 6e6e 6573 7320 6365 6e74 7261 6c69 7479  nness centrality
+0001c440: 2061 6368 6965 7665 640a 2020 2020 2020   achieved.      
+0001c450: 2020 2320 206f 6e6c 7920 6279 2074 6865    #  only by the
+0001c460: 2073 7461 7220 2846 7265 656d 616e 2031   star (Freeman 1
+0001c470: 3937 3829 3a20 286e 2a2a 322d 332a 6e2b  978): (n**2-3*n+
+0001c480: 3229 2f32 0a20 2020 2020 2020 2023 2020  2)/2.        #  
+0001c490: 5468 6973 2072 6573 7472 6963 7473 2054  This restricts T
+0001c4a0: 4243 2074 6f20 3020 3c3d 2054 4243 203c  BC to 0 <= TBC <
+0001c4b0: 3d20 310a 2020 2020 2020 2020 2320 6d61  = 1.        # ma
+0001c4c0: 7854 4243 203d 2020 2820 7365 6c66 2e4e  xTBC =  ( self.N
+0001c4d0: 2a2a 3220 2d20 3320 2a20 7365 6c66 2e4e  **2 - 3 * self.N
+0001c4e0: 202b 2032 2029 202f 2032 0a0a 2020 2020   + 2 ) / 2..    
+0001c4f0: 2020 2020 7265 7475 726e 206e 702e 6162      return np.ab
+0001c500: 7328 6e70 2e61 7272 6179 2873 656c 662e  s(np.array(self.
+0001c510: 6772 6170 682e 6265 7477 6565 6e6e 6573  graph.betweennes
+0001c520: 7328 2929 290a 0a20 2020 2064 6566 2069  s()))..    def i
+0001c530: 6e74 6572 7265 6769 6f6e 616c 5f62 6574  nterregional_bet
+0001c540: 7765 656e 6e65 7373 2873 656c 662c 2073  weenness(self, s
+0001c550: 6f75 7263 6573 3d4e 6f6e 652c 2074 6172  ources=None, tar
+0001c560: 6765 7473 3d4e 6f6e 6529 3a0a 2020 2020  gets=None):.    
+0001c570: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0001c580: 466f 7220 6561 6368 206e 6f64 652c 2072  For each node, r
+0001c590: 6574 7572 6e20 6974 7320 696e 7465 7272  eturn its interr
+0001c5a0: 6567 696f 6e61 6c20 6265 7477 6565 6e6e  egional betweenn
+0001c5b0: 6573 7320 666f 7220 6769 7665 6e20 7365  ess for given se
+0001c5c0: 7473 0a20 2020 2020 2020 206f 6620 736f  ts.        of so
+0001c5d0: 7572 6365 2061 6e64 2074 6172 6765 7420  urce and target 
+0001c5e0: 6e6f 6465 732e 0a0a 2020 2020 2020 2020  nodes...        
+0001c5f0: 5468 6973 206d 6561 7375 7265 7320 726f  This measures ro
+0001c600: 7567 686c 7920 686f 7720 6d61 6e79 2073  ughly how many s
+0001c610: 686f 7274 6573 7420 7061 7468 7320 6672  hortest paths fr
+0001c620: 6f6d 206f 6e65 206f 6620 7468 6520 736f  om one of the so
+0001c630: 7572 6365 730a 2020 2020 2020 2020 746f  urces.        to
+0001c640: 206f 6e65 206f 6620 7468 6520 7461 7267   one of the targ
+0001c650: 6574 7320 7061 7373 2074 6872 6f75 6768  ets pass through
+0001c660: 2074 6865 206e 6f64 652e 0a0a 2020 2020   the node...    
+0001c670: 2020 2020 2a2a 4578 616d 706c 6573 3a2a      **Examples:*
+0001c680: 2a0a 0a20 2020 2020 2020 203e 3e3e 204e  *..        >>> N
+0001c690: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
+0001c6a0: 4e65 7477 6f72 6b28 292e 696e 7465 7272  Network().interr
+0001c6b0: 6567 696f 6e61 6c5f 6265 7477 6565 6e6e  egional_betweenn
+0001c6c0: 6573 7328 0a20 2020 2020 2020 202e 2e2e  ess(.        ...
+0001c6d0: 2020 2020 2073 6f75 7263 6573 3d5b 325d       sources=[2]
+0001c6e0: 2c20 7461 7267 6574 733d 5b33 2c35 5d29  , targets=[3,5])
+0001c6f0: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+0001c700: 7469 6e67 2069 6e74 6572 7265 6769 6f6e  ting interregion
+0001c710: 616c 2062 6574 7765 656e 6e65 7373 2e2e  al betweenness..
+0001c720: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+0001c730: 5b20 312e 2c20 2031 2e2c 2020 302e 2c20  [ 1.,  1.,  0., 
+0001c740: 2030 2e2c 2020 312e 2c20 2030 2e5d 290a   0.,  1.,  0.]).
+0001c750: 2020 2020 2020 2020 3e3e 3e20 4e65 7477          >>> Netw
+0001c760: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
+0001c770: 776f 726b 2829 2e69 6e74 6572 7265 6769  work().interregi
+0001c780: 6f6e 616c 5f62 6574 7765 656e 6e65 7373  onal_betweenness
+0001c790: 280a 2020 2020 2020 2020 2e2e 2e20 2020  (.        ...   
+0001c7a0: 2020 736f 7572 6365 733d 7261 6e67 6528    sources=range(
+0001c7b0: 302c 3629 2c20 7461 7267 6574 733d 7261  0,6), targets=ra
+0001c7c0: 6e67 6528 302c 3629 290a 2020 2020 2020  nge(0,6)).      
+0001c7d0: 2020 4361 6c63 756c 6174 696e 6720 696e    Calculating in
+0001c7e0: 7465 7272 6567 696f 6e61 6c20 6265 7477  terregional betw
+0001c7f0: 6565 6e6e 6573 732e 2e2e 0a20 2020 2020  eenness....     
+0001c800: 2020 2061 7272 6179 285b 2039 2e2c 2020     array([ 9.,  
+0001c810: 332e 2c20 2030 2e2c 2020 322e 2c20 2036  3.,  0.,  2.,  6
+0001c820: 2e2c 2020 302e 5d29 0a0a 2020 2020 2020  .,  0.])..      
+0001c830: 2020 6173 2063 6f6d 7061 7265 6420 746f    as compared to
+0001c840: 0a0a 2020 2020 2020 2020 3e3e 3e20 4e65  ..        >>> Ne
+0001c850: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
+0001c860: 6574 776f 726b 2829 2e62 6574 7765 656e  etwork().between
+0001c870: 6e65 7373 2829 0a20 2020 2020 2020 2043  ness().        C
+0001c880: 616c 6375 6c61 7469 6e67 206e 6f64 6520  alculating node 
+0001c890: 6265 7477 6565 6e6e 6573 732e 2e2e 0a20  betweenness.... 
+0001c8a0: 2020 2020 2020 2061 7272 6179 285b 2034         array([ 4
+0001c8b0: 2e35 2c20 2031 2e35 2c20 2030 2e20 2c20  .5,  1.5,  0. , 
+0001c8c0: 2031 2e20 2c20 2033 2e20 2c20 2030 2e20   1. ,  3. ,  0. 
+0001c8d0: 5d29 0a0a 2020 2020 2020 2020 3a74 7970  ])..        :typ
+0001c8e0: 6520 736f 7572 6365 733a 2031 6420 6e75  e sources: 1d nu
+0001c8f0: 6d70 7920 6172 7261 7920 6f72 206c 6973  mpy array or lis
+0001c900: 7420 6f66 2069 6e74 7320 6672 6f6d 2030  t of ints from 0
+0001c910: 2074 6f20 6e5f 6e6f 6465 732d 310a 2020   to n_nodes-1.  
+0001c920: 2020 2020 2020 3a61 7267 2020 736f 7572        :arg  sour
+0001c930: 6365 733a 2053 6574 206f 6620 736f 7572  ces: Set of sour
+0001c940: 6365 206e 6f64 6520 696e 6469 6365 732e  ce node indices.
+0001c950: 0a0a 2020 2020 2020 2020 3a74 7970 6520  ..        :type 
+0001c960: 7461 7267 6574 733a 2031 6420 6e75 6d70  targets: 1d nump
+0001c970: 7920 6172 7261 7920 6f72 206c 6973 7420  y array or list 
+0001c980: 6f66 2069 6e74 7320 6672 6f6d 2030 2074  of ints from 0 t
+0001c990: 6f20 6e5f 6e6f 6465 732d 310a 2020 2020  o n_nodes-1.    
+0001c9a0: 2020 2020 3a61 7267 2020 7461 7267 6574      :arg  target
+0001c9b0: 733a 2053 6574 206f 6620 7461 7267 6574  s: Set of target
+0001c9c0: 206e 6f64 6520 696e 6469 6365 732e 0a0a   node indices...
+0001c9d0: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+0001c9e0: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
+0001c9f0: 6e6f 6465 5d20 6f66 2066 6c6f 6174 730a  node] of floats.
+0001ca00: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0001ca10: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0001ca20: 6e73 695f 6265 7477 6565 6e6e 6573 7328  nsi_betweenness(
+0001ca30: 736f 7572 6365 733d 736f 7572 6365 732c  sources=sources,
+0001ca40: 2074 6172 6765 7473 3d74 6172 6765 7473   targets=targets
+0001ca50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001ca60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ca70: 2020 2020 2020 6e73 693d 4661 6c73 6529        nsi=False)
+0001ca80: 0a0a 2020 2020 6465 6620 6e73 695f 696e  ..    def nsi_in
+0001ca90: 7465 7272 6567 696f 6e61 6c5f 6265 7477  terregional_betw
+0001caa0: 6565 6e6e 6573 7328 7365 6c66 2c20 736f  eenness(self, so
+0001cab0: 7572 6365 732c 2074 6172 6765 7473 293a  urces, targets):
+0001cac0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001cad0: 2020 2020 2046 6f72 2065 6163 6820 6e6f       For each no
+0001cae0: 6465 2c20 7265 7475 726e 2069 7473 206e  de, return its n
+0001caf0: 2e73 2e69 2e20 696e 7465 7272 6567 696f  .s.i. interregio
+0001cb00: 6e61 6c20 6265 7477 6565 6e6e 6573 7320  nal betweenness 
+0001cb10: 666f 7220 6769 7665 6e0a 2020 2020 2020  for given.      
+0001cb20: 2020 7365 7473 206f 6620 736f 7572 6365    sets of source
+0001cb30: 2061 6e64 2074 6172 6765 7420 6e6f 6465   and target node
+0001cb40: 732e 0a0a 2020 2020 2020 2020 5468 6973  s...        This
+0001cb50: 206d 6561 7375 7265 7320 726f 7567 686c   measures roughl
+0001cb60: 7920 686f 7720 6d61 6e79 2073 686f 7274  y how many short
+0001cb70: 6573 7420 7061 7468 7320 6672 6f6d 206f  est paths from o
+0001cb80: 6e65 206f 6620 7468 6520 736f 7572 6365  ne of the source
+0001cb90: 730a 2020 2020 2020 2020 746f 206f 6e65  s.        to one
+0001cba0: 206f 6620 7468 6520 7461 7267 6574 7320   of the targets 
+0001cbb0: 7061 7373 2074 6872 6f75 6768 2074 6865  pass through the
+0001cbc0: 206e 6f64 652c 2074 616b 696e 6720 6e6f   node, taking no
+0001cbd0: 6465 2077 6569 6768 7473 2069 6e74 6f0a  de weights into.
+0001cbe0: 2020 2020 2020 2020 6163 636f 756e 742e          account.
+0001cbf0: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
+0001cc00: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
+0001cc10: 3e3e 3e20 7228 4e65 7477 6f72 6b2e 536d  >>> r(Network.Sm
+0001cc20: 616c 6c54 6573 744e 6574 776f 726b 2829  allTestNetwork()
+0001cc30: 2e6e 7369 5f69 6e74 6572 7265 6769 6f6e  .nsi_interregion
+0001cc40: 616c 5f62 6574 7765 656e 6e65 7373 280a  al_betweenness(.
+0001cc50: 2020 2020 2020 2020 2e2e 2e20 2020 2020          ...     
+0001cc60: 736f 7572 6365 733d 5b32 5d2c 2074 6172  sources=[2], tar
+0001cc70: 6765 7473 3d5b 332c 355d 2929 0a20 2020  gets=[3,5])).   
+0001cc80: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+0001cc90: 206e 2e73 2e69 2e20 696e 7465 7272 6567   n.s.i. interreg
+0001cca0: 696f 6e61 6c20 6265 7477 6565 6e6e 6573  ional betweennes
+0001ccb0: 732e 2e2e 0a20 2020 2020 2020 2061 7272  s....        arr
+0001ccc0: 6179 285b 2033 2e31 3636 372c 2032 2e33  ay([ 3.1667, 2.3
+0001ccd0: 3437 312c 2030 2e20 2c20 302e 202c 2032  471, 0. , 0. , 2
+0001cce0: 2e30 3635 322c 2030 2e20 5d29 0a0a 2020  .0652, 0. ])..  
+0001ccf0: 2020 2020 2020 6173 2063 6f6d 7061 7265        as compare
+0001cd00: 6420 746f 2074 6865 2075 6e77 6569 6768  d to the unweigh
+0001cd10: 7465 6420 7665 7273 696f 6e3a 0a0a 2020  ted version:..  
+0001cd20: 2020 2020 2020 3e3e 3e20 4e65 7477 6f72        >>> Networ
+0001cd30: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
+0001cd40: 726b 2829 2e69 6e74 6572 7265 6769 6f6e  rk().interregion
+0001cd50: 616c 5f62 6574 7765 656e 6e65 7373 280a  al_betweenness(.
+0001cd60: 2020 2020 2020 2020 2e2e 2e20 2020 2020          ...     
+0001cd70: 736f 7572 6365 733d 5b32 5d2c 2074 6172  sources=[2], tar
+0001cd80: 6765 7473 3d5b 332c 355d 290a 2020 2020  gets=[3,5]).    
+0001cd90: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+0001cda0: 696e 7465 7272 6567 696f 6e61 6c20 6265  interregional be
+0001cdb0: 7477 6565 6e6e 6573 732e 2e2e 0a20 2020  tweenness....   
+0001cdc0: 2020 2020 2061 7272 6179 285b 2031 2e2c       array([ 1.,
+0001cdd0: 2020 312e 2c20 2030 2e2c 2020 302e 2c20    1.,  0.,  0., 
+0001cde0: 2031 2e2c 2020 302e 5d29 0a0a 2020 2020   1.,  0.])..    
+0001cdf0: 2020 2020 3a72 7479 7065 3a20 3164 206e      :rtype: 1d n
+0001ce00: 756d 7079 2061 7272 6179 205b 6e6f 6465  umpy array [node
+0001ce10: 5d20 6f66 2066 6c6f 6174 730a 2020 2020  ] of floats.    
+0001ce20: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0001ce30: 7265 7475 726e 2073 656c 662e 6e73 695f  return self.nsi_
+0001ce40: 6265 7477 6565 6e6e 6573 7328 736f 7572  betweenness(sour
+0001ce50: 6365 733d 736f 7572 6365 732c 2074 6172  ces=sources, tar
+0001ce60: 6765 7473 3d74 6172 6765 7473 290a 0a20  gets=targets).. 
+0001ce70: 2020 2064 6566 206e 7369 5f62 6574 7765     def nsi_betwe
+0001ce80: 656e 6e65 7373 2873 656c 662c 2073 6f75  enness(self, sou
+0001ce90: 7263 6573 3d4e 6f6e 652c 2074 6172 6765  rces=None, targe
+0001cea0: 7473 3d4e 6f6e 652c 0a20 2020 2020 2020  ts=None,.       
+0001ceb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cec0: 206e 7369 3a20 626f 6f6c 203d 2054 7275   nsi: bool = Tru
+0001ced0: 652c 2070 6172 616c 6c65 6c69 7a65 3a20  e, parallelize: 
+0001cee0: 626f 6f6c 203d 2046 616c 7365 293a 0a20  bool = False):. 
+0001cef0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001cf00: 2020 2046 6f72 2065 6163 6820 6e6f 6465     For each node
+0001cf10: 2c20 7265 7475 726e 2069 7473 206e 2e73  , return its n.s
+0001cf20: 2e69 2e20 6265 7477 6565 6e6e 6573 732e  .i. betweenness.
+0001cf30: 205b 4e65 776d 616e 3230 3031 5d5f 0a0a   [Newman2001]_..
+0001cf40: 2020 2020 2020 2020 5468 6973 206d 6561          This mea
+0001cf50: 7375 7265 7320 726f 7567 686c 7920 686f  sures roughly ho
+0001cf60: 7720 6d61 6e79 2073 686f 7274 6573 7420  w many shortest 
+0001cf70: 7061 7468 7320 7061 7373 2074 6872 6f75  paths pass throu
+0001cf80: 6768 2074 6865 206e 6f64 652c 0a20 2020  gh the node,.   
+0001cf90: 2020 2020 2074 616b 696e 6720 6e6f 6465       taking node
+0001cfa0: 2077 6569 6768 7473 2069 6e74 6f20 6163   weights into ac
+0001cfb0: 636f 756e 742e 0a0a 2020 2020 2020 2020  count...        
+0001cfc0: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
+0001cfd0: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
+0001cfe0: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
+0001cff0: 744e 6574 776f 726b 2829 0a20 2020 2020  tNetwork().     
+0001d000: 2020 203e 3e3e 2072 286e 6574 2e6e 7369     >>> r(net.nsi
+0001d010: 5f62 6574 7765 656e 6e65 7373 2829 290a  _betweenness()).
+0001d020: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+0001d030: 696e 6720 6e2e 732e 692e 2062 6574 7765  ing n.s.i. betwe
+0001d040: 656e 6e65 7373 2e2e 2e0a 2020 2020 2020  enness....      
+0001d050: 2020 6172 7261 7928 5b20 3239 2e36 3835    array([ 29.685
+0001d060: 342c 2037 2e37 3132 392c 2030 2e20 2c20  4, 7.7129, 0. , 
+0001d070: 332e 3039 3039 2c20 392e 3639 3936 2c20  3.0909, 9.6996, 
+0001d080: 302e 205d 290a 2020 2020 2020 2020 3e3e  0. ]).        >>
+0001d090: 3e20 7228 6e65 742e 7370 6c69 7474 6564  > r(net.splitted
+0001d0a0: 5f63 6f70 7928 292e 6e73 695f 6265 7477  _copy().nsi_betw
+0001d0b0: 6565 6e6e 6573 7328 2929 0a20 2020 2020  eenness()).     
+0001d0c0: 2020 2043 616c 6375 6c61 7469 6e67 206e     Calculating n
+0001d0d0: 2e73 2e69 2e20 6265 7477 6565 6e6e 6573  .s.i. betweennes
+0001d0e0: 732e 2e2e 0a20 2020 2020 2020 2061 7272  s....        arr
+0001d0f0: 6179 285b 2032 392e 3638 3534 2c20 372e  ay([ 29.6854, 7.
+0001d100: 3731 3239 2c20 302e 202c 2033 2e30 3930  7129, 0. , 3.090
+0001d110: 392c 2039 2e36 3939 362c 2030 2e20 2c20  9, 9.6996, 0. , 
+0001d120: 302e 205d 290a 0a20 2020 2020 2020 2061  0. ])..        a
+0001d130: 7320 636f 6d70 6172 6564 2074 6f20 7468  s compared to th
+0001d140: 6520 756e 7765 6967 6874 6564 2076 6572  e unweighted ver
+0001d150: 7369 6f6e 3a0a 0a20 2020 2020 2020 203e  sion:..        >
+0001d160: 3e3e 206e 6574 203d 204e 6574 776f 726b  >> net = Network
+0001d170: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
+0001d180: 6b28 290a 2020 2020 2020 2020 3e3e 3e20  k().        >>> 
+0001d190: 6e65 742e 6265 7477 6565 6e6e 6573 7328  net.betweenness(
+0001d1a0: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
+0001d1b0: 6174 696e 6720 6e6f 6465 2062 6574 7765  ating node betwe
+0001d1c0: 656e 6e65 7373 2e2e 2e0a 2020 2020 2020  enness....      
+0001d1d0: 2020 6172 7261 7928 5b20 342e 352c 2020    array([ 4.5,  
+0001d1e0: 312e 352c 2020 302e 202c 2020 312e 202c  1.5,  0. ,  1. ,
+0001d1f0: 2020 332e 202c 2020 302e 205d 290a 2020    3. ,  0. ]).  
+0001d200: 2020 2020 2020 3e3e 3e20 6e65 742e 7370        >>> net.sp
+0001d210: 6c69 7474 6564 5f63 6f70 7928 292e 6265  litted_copy().be
+0001d220: 7477 6565 6e6e 6573 7328 290a 2020 2020  tweenness().    
+0001d230: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+0001d240: 6e6f 6465 2062 6574 7765 656e 6e65 7373  node betweenness
+0001d250: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
+0001d260: 7928 5b20 382e 352c 2020 312e 352c 2020  y([ 8.5,  1.5,  
+0001d270: 302e 202c 2020 312e 352c 2020 342e 352c  0. ,  1.5,  4.5,
+0001d280: 2020 302e 202c 2020 302e 205d 290a 0a20    0. ,  0. ]).. 
+0001d290: 2020 2020 2020 203a 6172 6720 626f 6f6c         :arg bool
+0001d2a0: 2070 6172 616c 6c65 6c69 7a65 3a20 546f   parallelize: To
+0001d2b0: 6767 6c65 206d 756c 7469 7072 6f63 6573  ggle multiproces
+0001d2c0: 7369 6e67 0a20 2020 2020 2020 203a 7274  sing.        :rt
+0001d2d0: 7970 653a 2031 6420 6e75 6d70 7920 6172  ype: 1d numpy ar
+0001d2e0: 7261 7920 5b6e 6f64 655d 206f 6620 666c  ray [node] of fl
+0001d2f0: 6f61 7473 0a20 2020 2020 2020 2022 2222  oats.        """
+0001d300: 0a20 2020 2020 2020 2023 2069 6e69 7469  .        # initi
+0001d310: 616c 697a 6520 6e6f 6465 206c 6973 7473  alize node lists
+0001d320: 0a20 2020 2020 2020 2069 735f 736f 7572  .        is_sour
+0001d330: 6365 203d 206e 702e 7a65 726f 7328 7365  ce = np.zeros(se
+0001d340: 6c66 2e4e 2c20 6474 7970 653d 4d41 534b  lf.N, dtype=MASK
+0001d350: 290a 2020 2020 2020 2020 6966 2073 6f75  ).        if sou
+0001d360: 7263 6573 2069 7320 6e6f 7420 4e6f 6e65  rces is not None
+0001d370: 3a0a 2020 2020 2020 2020 2020 2020 6973  :.            is
+0001d380: 5f73 6f75 7263 655b 736f 7572 6365 735d  _source[sources]
+0001d390: 203d 2031 0a20 2020 2020 2020 2065 6c73   = 1.        els
+0001d3a0: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
+0001d3b0: 735f 736f 7572 6365 5b72 616e 6765 2830  s_source[range(0
+0001d3c0: 2c20 7365 6c66 2e4e 295d 203d 2031 0a20  , self.N)] = 1. 
+0001d3d0: 2020 2020 2020 2069 6620 7461 7267 6574         if target
+0001d3e0: 7320 6973 206e 6f74 204e 6f6e 653a 0a20  s is not None:. 
+0001d3f0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
+0001d400: 7473 203d 206e 702e 6172 7261 7928 6c69  ts = np.array(li
+0001d410: 7374 286d 6170 2869 6e74 2c20 7461 7267  st(map(int, targ
+0001d420: 6574 7329 2929 0a20 2020 2020 2020 2065  ets))).        e
+0001d430: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0001d440: 2074 6172 6765 7473 203d 206e 702e 6172   targets = np.ar
+0001d450: 616e 6765 2830 2c20 7365 6c66 2e4e 290a  ange(0, self.N).
+0001d460: 0a20 2020 2020 2020 2023 2063 616c 6c20  .        # call 
+0001d470: 6361 6368 6564 2077 6f72 6b65 7220 6d65  cached worker me
+0001d480: 7468 6f64 2077 6974 6820 6861 7368 6162  thod with hashab
+0001d490: 6c65 2061 7267 756d 656e 7473 0a20 2020  le arguments.   
+0001d4a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0001d4b0: 2e5f 6e73 695f 6265 7477 6565 6e6e 6573  ._nsi_betweennes
+0001d4c0: 7328 0a20 2020 2020 2020 2020 2020 2074  s(.            t
+0001d4d0: 7570 6c65 2869 735f 736f 7572 6365 292c  uple(is_source),
+0001d4e0: 2074 7570 6c65 2874 6172 6765 7473 292c   tuple(targets),
+0001d4f0: 206e 7369 2c20 7061 7261 6c6c 656c 697a   nsi, paralleliz
+0001d500: 6529 0a0a 2020 2020 4043 6163 6865 642e  e)..    @Cached.
+0001d510: 6d65 7468 6f64 286e 616d 653d 226e 2e73  method(name="n.s
+0001d520: 2e69 2e20 6265 7477 6565 6e6e 6573 7322  .i. betweenness"
+0001d530: 2c20 6174 7472 733d 2822 5f6d 7574 5f6e  , attrs=("_mut_n
+0001d540: 7722 2c29 290a 2020 2020 6465 6620 5f6e  w",)).    def _n
+0001d550: 7369 5f62 6574 7765 656e 6e65 7373 2873  si_betweenness(s
+0001d560: 656c 662c 2069 735f 736f 7572 6365 3a20  elf, is_source: 
+0001d570: 5475 706c 655b 4d41 534b 5d2c 2074 6172  Tuple[MASK], tar
+0001d580: 6765 7473 3a20 5475 706c 655b 4e4f 4445  gets: Tuple[NODE
+0001d590: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001d5a0: 2020 2020 2020 2020 2020 2020 6e73 693a              nsi:
+0001d5b0: 2062 6f6f 6c2c 2070 6172 616c 6c65 6c69   bool, paralleli
+0001d5c0: 7a65 3a20 626f 6f6c 293a 0a20 2020 2020  ze: bool):.     
+0001d5d0: 2020 2023 2074 7970 6520 6361 7374 2069     # type cast i
+0001d5e0: 6e70 7574 730a 2020 2020 2020 2020 6173  nputs.        as
+0001d5f0: 7365 7274 2061 6c6c 2869 7369 6e73 7461  sert all(isinsta
+0001d600: 6e63 6528 6172 672c 2074 7570 6c65 2920  nce(arg, tuple) 
+0001d610: 666f 7220 6172 6720 696e 205b 6973 5f73  for arg in [is_s
+0001d620: 6f75 7263 652c 2074 6172 6765 7473 5d29  ource, targets])
+0001d630: 0a20 2020 2020 2020 2069 735f 736f 7572  .        is_sour
+0001d640: 6365 203d 206e 702e 6172 7261 7928 6973  ce = np.array(is
+0001d650: 5f73 6f75 7263 652c 2064 7479 7065 3d4d  _source, dtype=M
+0001d660: 4153 4b29 0a20 2020 2020 2020 2074 6172  ASK).        tar
+0001d670: 6765 7473 203d 206e 702e 6172 7261 7928  gets = np.array(
+0001d680: 7461 7267 6574 732c 2064 7479 7065 3d4e  targets, dtype=N
+0001d690: 4f44 4529 0a20 2020 2020 2020 206b 203d  ODE).        k =
+0001d6a0: 2074 6f5f 6379 2873 656c 662e 6f75 7464   to_cy(self.outd
+0001d6b0: 6567 7265 6528 292c 2044 4547 5245 4529  egree(), DEGREE)
+0001d6c0: 0a0a 2020 2020 2020 2020 2320 696e 6974  ..        # init
+0001d6d0: 6961 6c69 7a65 206e 6f64 6520 7765 6967  ialize node weig
+0001d6e0: 6874 730a 2020 2020 2020 2020 7720 3d20  hts.        w = 
+0001d6f0: 746f 5f63 7928 7365 6c66 2e6e 6f64 655f  to_cy(self.node_
+0001d700: 7765 6967 6874 732c 2044 5745 4947 4854  weights, DWEIGHT
+0001d710: 290a 2020 2020 2020 2020 7720 3d20 7720  ).        w = w 
+0001d720: 6966 206e 7369 2065 6c73 6520 6e70 2e6f  if nsi else np.o
+0001d730: 6e65 735f 6c69 6b65 2877 290a 0a20 2020  nes_like(w)..   
+0001d740: 2020 2020 2023 2073 6f72 7420 6c69 6e6b       # sort link
+0001d750: 7320 6279 206e 6f64 6520 696e 6469 6365  s by node indice
+0001d760: 7320 2863 6f6e 7461 696e 7320 6561 6368  s (contains each
+0001d770: 206c 696e 6b20 7477 6963 6521 290a 2020   link twice!).  
+0001d780: 2020 2020 2020 6c69 6e6b 7320 3d20 6e7a        links = nz
+0001d790: 5f63 6f6f 7264 7328 7365 6c66 2e73 705f  _coords(self.sp_
+0001d7a0: 4129 0a0a 2020 2020 2020 2020 2320 6e65  A)..        # ne
+0001d7b0: 6967 6862 6f75 7273 206f 6620 6561 6368  ighbours of each
+0001d7c0: 206e 6f64 650a 2020 2020 2020 2020 666c   node.        fl
+0001d7d0: 6174 5f6e 6569 6768 626f 7273 203d 2074  at_neighbors = t
+0001d7e0: 6f5f 6379 286e 702e 6172 7261 7928 6c69  o_cy(np.array(li
+0001d7f0: 6e6b 7329 5b3a 2c20 315d 2c20 4e4f 4445  nks)[:, 1], NODE
+0001d800: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
+0001d810: 206b 2e73 756d 2829 203d 3d20 6c65 6e28   k.sum() == len(
+0001d820: 666c 6174 5f6e 6569 6768 626f 7273 2920  flat_neighbors) 
+0001d830: 3d3d 2032 202a 2073 656c 662e 6e5f 6c69  == 2 * self.n_li
+0001d840: 6e6b 730a 0a20 2020 2020 2020 2023 2063  nks..        # c
+0001d850: 616c 6c20 4379 7468 6f6e 2069 6d70 6c65  all Cython imple
+0001d860: 6d65 6e74 6174 696f 6e0a 2020 2020 2020  mentation.      
+0001d870: 2020 776f 726b 6572 203d 2070 6172 7469    worker = parti
+0001d880: 616c 285f 6e73 695f 6265 7477 6565 6e6e  al(_nsi_betweenn
+0001d890: 6573 732c 0a20 2020 2020 2020 2020 2020  ess,.           
+0001d8a0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0001d8b0: 6c66 2e4e 2c20 772c 206b 2c20 666c 6174  lf.N, w, k, flat
+0001d8c0: 5f6e 6569 6768 626f 7273 2c20 6973 5f73  _neighbors, is_s
+0001d8d0: 6f75 7263 6529 0a20 2020 2020 2020 2069  ource).        i
+0001d8e0: 6620 7061 7261 6c6c 656c 697a 653a 0a20  f parallelize:. 
+0001d8f0: 2020 2020 2020 2020 2020 2023 2028 6e61             # (na
+0001d900: 6976 656c 7929 2070 6172 616c 6c65 6c69  ively) paralleli
+0001d910: 7a65 206c 6f6f 7020 6f76 6572 206e 6f64  ze loop over nod
+0001d920: 6573 0a20 2020 2020 2020 2020 2020 206e  es.            n
+0001d930: 5f77 6f72 6b65 7273 203d 2063 7075 5f63  _workers = cpu_c
+0001d940: 6f75 6e74 2829 0a20 2020 2020 2020 2020  ount().         
+0001d950: 2020 2062 6174 6368 6573 203d 206e 702e     batches = np.
+0001d960: 6172 7261 795f 7370 6c69 7428 7461 7267  array_split(targ
+0001d970: 6574 732c 206e 5f77 6f72 6b65 7273 290a  ets, n_workers).
+0001d980: 2020 2020 2020 2020 2020 2020 7769 7468              with
+0001d990: 2067 6574 5f63 6f6e 7465 7874 2822 7370   get_context("sp
+0001d9a0: 6177 6e22 292e 506f 6f6c 2829 2061 7320  awn").Pool() as 
+0001d9b0: 706f 6f6c 3a0a 2020 2020 2020 2020 2020  pool:.          
+0001d9c0: 2020 2020 2020 6265 7477 5f77 203d 206e        betw_w = n
+0001d9d0: 702e 7375 6d28 706f 6f6c 2e6d 6170 2877  p.sum(pool.map(w
+0001d9e0: 6f72 6b65 722c 2062 6174 6368 6573 292c  orker, batches),
+0001d9f0: 2061 7869 733d 3029 0a20 2020 2020 2020   axis=0).       
+0001da00: 2020 2020 2020 2020 2070 6f6f 6c2e 636c           pool.cl
+0001da10: 6f73 6528 290a 2020 2020 2020 2020 2020  ose().          
+0001da20: 2020 2020 2020 706f 6f6c 2e6a 6f69 6e28        pool.join(
+0001da30: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0001da40: 2020 2020 2020 2020 2020 2020 6265 7477              betw
+0001da50: 5f77 203d 2077 6f72 6b65 7228 7461 7267  _w = worker(targ
+0001da60: 6574 7329 0a20 2020 2020 2020 2072 6574  ets).        ret
+0001da70: 7572 6e20 6265 7477 5f77 202f 2077 0a0a  urn betw_w / w..
+0001da80: 2020 2020 4043 6163 6865 642e 6d65 7468      @Cached.meth
+0001da90: 6f64 286e 616d 653d 2265 6967 656e 7665  od(name="eigenve
+0001daa0: 6374 6f72 2063 656e 7472 616c 6974 7922  ctor centrality"
+0001dab0: 290a 2020 2020 6465 6620 6569 6765 6e76  ).    def eigenv
+0001dac0: 6563 746f 725f 6365 6e74 7261 6c69 7479  ector_centrality
+0001dad0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0001dae0: 2222 220a 2020 2020 2020 2020 466f 7220  """.        For 
+0001daf0: 6561 6368 206e 6f64 652c 2072 6574 7572  each node, retur
+0001db00: 6e20 6974 7320 6569 6765 6e76 6563 746f  n its eigenvecto
+0001db10: 7220 6365 6e74 7261 6c69 7479 2e0a 0a20  r centrality... 
+0001db20: 2020 2020 2020 2054 6869 7320 6973 2074         This is t
+0001db30: 6865 206c 6f61 6420 6f6e 2074 6869 7320  he load on this 
+0001db40: 6e6f 6465 2066 726f 6d20 7468 6520 6569  node from the ei
+0001db50: 6765 6e76 6563 746f 7220 636f 7272 6573  genvector corres
+0001db60: 706f 6e64 696e 6720 746f 2074 6865 0a20  ponding to the. 
+0001db70: 2020 2020 2020 206c 6172 6765 7374 2065         largest e
+0001db80: 6967 656e 7661 6c75 6520 6f66 2074 6865  igenvalue of the
+0001db90: 2061 646a 6163 656e 6379 206d 6174 7269   adjacency matri
+0001dba0: 782c 206e 6f72 6d61 6c69 7a65 6420 746f  x, normalized to
+0001dbb0: 2061 0a20 2020 2020 2020 206d 6178 696d   a.        maxim
+0001dbc0: 756d 206f 6620 312e 0a0a 2020 2020 2020  um of 1...      
+0001dbd0: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
+0001dbe0: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
+0001dbf0: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
+0001dc00: 6574 776f 726b 2829 2e65 6967 656e 7665  etwork().eigenve
+0001dc10: 6374 6f72 5f63 656e 7472 616c 6974 7928  ctor_centrality(
+0001dc20: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+0001dc30: 6c61 7469 6e67 2065 6967 656e 7665 6374  lating eigenvect
+0001dc40: 6f72 2063 656e 7472 616c 6974 792e 2e2e  or centrality...
+0001dc50: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+0001dc60: 2030 2e37 3839 352c 2030 2e39 3733 202c   0.7895, 0.973 ,
+0001dc70: 2030 2e37 3736 392c 2030 2e36 3934 312c   0.7769, 0.6941,
+0001dc80: 2031 2e20 2c20 302e 3331 3039 5d29 0a0a   1. , 0.3109])..
+0001dc90: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+0001dca0: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
+0001dcb0: 6e6f 6465 5d20 6f66 2066 6c6f 6174 730a  node] of floats.
+0001dcc0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0001dcd0: 2020 2020 2320 544f 444f 3a20 616c 6c6f      # TODO: allo
+0001dce0: 7720 666f 7220 7765 6967 6874 730a 2020  w for weights.  
+0001dcf0: 2020 2020 2020 5f2c 2065 7665 6373 203d        _, evecs =
+0001dd00: 2065 6967 7368 2873 656c 662e 7370 5f41   eigsh(self.sp_A
+0001dd10: 2e61 7374 7970 6528 666c 6f61 7429 2c20  .astype(float), 
+0001dd20: 6b3d 312c 2073 6967 6d61 3d73 656c 662e  k=1, sigma=self.
+0001dd30: 4e2a 2a32 2c0a 2020 2020 2020 2020 2020  N**2,.          
+0001dd40: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+0001dd50: 6178 6974 6572 3d31 3030 2c20 746f 6c3d  axiter=100, tol=
+0001dd60: 3165 2d38 290a 2020 2020 2020 2020 6563  1e-8).        ec
+0001dd70: 203d 2065 7665 6373 2e54 5b30 5d0a 2020   = evecs.T[0].  
+0001dd80: 2020 2020 2020 6563 202a 3d20 6e70 2e73        ec *= np.s
+0001dd90: 6967 6e28 6563 5b30 5d29 0a20 2020 2020  ign(ec[0]).     
+0001dda0: 2020 2072 6574 7572 6e20 6563 202f 2065     return ec / e
+0001ddb0: 632e 6d61 7828 290a 0a20 2020 2040 4361  c.max()..    @Ca
+0001ddc0: 6368 6564 2e6d 6574 686f 6428 6e61 6d65  ched.method(name
+0001ddd0: 3d22 6e2e 732e 692e 2065 6967 656e 7665  ="n.s.i. eigenve
+0001dde0: 6374 6f72 2063 656e 7472 616c 6974 7922  ctor centrality"
+0001ddf0: 2c20 6174 7472 733d 2822 5f6d 7574 5f6e  , attrs=("_mut_n
+0001de00: 7722 2c29 290a 2020 2020 6465 6620 6e73  w",)).    def ns
+0001de10: 695f 6569 6765 6e76 6563 746f 725f 6365  i_eigenvector_ce
+0001de20: 6e74 7261 6c69 7479 2873 656c 6629 3a0a  ntrality(self):.
+0001de30: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0001de40: 2020 2020 466f 7220 6561 6368 206e 6f64      For each nod
+0001de50: 652c 2072 6574 7572 6e20 6974 7320 6e2e  e, return its n.
+0001de60: 732e 692e 2065 6967 656e 7665 6374 6f72  s.i. eigenvector
+0001de70: 2063 656e 7472 616c 6974 792e 0a0a 2020   centrality...  
+0001de80: 2020 2020 2020 5468 6973 2069 7320 7468        This is th
+0001de90: 6520 6c6f 6164 206f 6e20 7468 6973 206e  e load on this n
+0001dea0: 6f64 6520 6672 6f6d 2074 6865 2065 6967  ode from the eig
+0001deb0: 656e 7665 6374 6f72 2063 6f72 7265 7370  envector corresp
+0001dec0: 6f6e 6469 6e67 2074 6f20 7468 650a 2020  onding to the.  
+0001ded0: 2020 2020 2020 6c61 7267 6573 7420 6569        largest ei
+0001dee0: 6765 6e76 616c 7565 206f 6620 7468 6520  genvalue of the 
+0001def0: 6e2e 732e 692e 2061 646a 6163 656e 6379  n.s.i. adjacency
+0001df00: 206d 6174 7269 782c 2064 6976 6964 6564   matrix, divided
+0001df10: 2062 790a 2020 2020 2020 2020 7371 7274   by.        sqrt
+0001df20: 286e 6f64 6520 7765 6967 6874 2920 616e  (node weight) an
+0001df30: 6420 6e6f 726d 616c 697a 6564 2074 6f20  d normalized to 
+0001df40: 6120 6d61 7869 6d75 6d20 6f66 2031 2e0a  a maximum of 1..
+0001df50: 0a20 2020 2020 2020 2046 6f72 2061 2064  .        For a d
+0001df60: 6972 6563 7465 6420 6e65 7477 6f72 6b2c  irected network,
+0001df70: 2074 6869 7320 7573 6573 2074 6865 2072   this uses the r
+0001df80: 6967 6874 2065 6967 656e 7665 6374 6f72  ight eigenvector
+0001df90: 732e 2054 6f20 6765 7420 7468 650a 2020  s. To get the.  
+0001dfa0: 2020 2020 2020 7661 6c75 6573 2066 6f72        values for
+0001dfb0: 2074 6865 206c 6566 7420 6569 6765 6e76   the left eigenv
+0001dfc0: 6563 746f 7273 2c20 6170 706c 7920 7468  ectors, apply th
+0001dfd0: 6973 2074 6f20 7468 6520 696e 7665 7273  is to the invers
+0001dfe0: 6520 6e65 7477 6f72 6b21 0a0a 2020 2020  e network!..    
+0001dff0: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
+0001e000: 0a0a 2020 2020 2020 2020 3e3e 3e20 6e65  ..        >>> ne
+0001e010: 7420 3d20 4e65 7477 6f72 6b2e 536d 616c  t = Network.Smal
+0001e020: 6c54 6573 744e 6574 776f 726b 2829 0a20  lTestNetwork(). 
+0001e030: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+0001e040: 2e6e 7369 5f65 6967 656e 7665 6374 6f72  .nsi_eigenvector
+0001e050: 5f63 656e 7472 616c 6974 7928 2929 0a20  _centrality()). 
+0001e060: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
+0001e070: 6e67 206e 2e73 2e69 2e20 6569 6765 6e76  ng n.s.i. eigenv
+0001e080: 6563 746f 7220 6365 6e74 7261 6c69 7479  ector centrality
+0001e090: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
+0001e0a0: 7928 5b20 302e 3830 3435 2c20 312e 202c  y([ 0.8045, 1. ,
+0001e0b0: 2030 2e38 3039 332c 2030 2e36 3137 392c   0.8093, 0.6179,
+0001e0c0: 2030 2e39 3836 372c 2030 2e32 3830 345d   0.9867, 0.2804]
+0001e0d0: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
+0001e0e0: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
+0001e0f0: 7928 292e 6e73 695f 6569 6765 6e76 6563  y().nsi_eigenvec
+0001e100: 746f 725f 6365 6e74 7261 6c69 7479 2829  tor_centrality()
+0001e110: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
+0001e120: 6174 696e 6720 6e2e 732e 692e 2065 6967  ating n.s.i. eig
+0001e130: 656e 7665 6374 6f72 2063 656e 7472 616c  envector central
+0001e140: 6974 792e 2e2e 0a20 2020 2020 2020 2061  ity....        a
+0001e150: 7272 6179 285b 2030 2e38 3034 352c 2031  rray([ 0.8045, 1
+0001e160: 2e20 2c20 302e 3830 3933 2c20 302e 3631  . , 0.8093, 0.61
+0001e170: 3739 2c20 302e 3938 3637 2c20 302e 3238  79, 0.9867, 0.28
+0001e180: 3034 2c20 302e 3238 3034 5d29 0a0a 2020  04, 0.2804])..  
+0001e190: 2020 2020 2020 6173 2063 6f6d 7061 7265        as compare
+0001e1a0: 6420 746f 2074 6865 2075 6e77 6569 6768  d to the unweigh
+0001e1b0: 7465 6420 7665 7273 696f 6e3a 0a0a 2020  ted version:..  
+0001e1c0: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
+0001e1d0: 6569 6765 6e76 6563 746f 725f 6365 6e74  eigenvector_cent
+0001e1e0: 7261 6c69 7479 2829 290a 2020 2020 2020  rality()).      
+0001e1f0: 2020 4361 6c63 756c 6174 696e 6720 6569    Calculating ei
+0001e200: 6765 6e76 6563 746f 7220 6365 6e74 7261  genvector centra
+0001e210: 6c69 7479 2e2e 2e0a 2020 2020 2020 2020  lity....        
+0001e220: 6172 7261 7928 5b20 302e 3738 3935 2c20  array([ 0.7895, 
+0001e230: 302e 3937 3320 2c20 302e 3737 3639 2c20  0.973 , 0.7769, 
+0001e240: 302e 3639 3431 2c20 312e 202c 2030 2e33  0.6941, 1. , 0.3
+0001e250: 3130 395d 290a 2020 2020 2020 2020 3e3e  109]).        >>
+0001e260: 3e20 7228 6e65 742e 7370 6c69 7474 6564  > r(net.splitted
+0001e270: 5f63 6f70 7928 292e 6569 6765 6e76 6563  _copy().eigenvec
+0001e280: 746f 725f 6365 6e74 7261 6c69 7479 2829  tor_centrality()
+0001e290: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
+0001e2a0: 6174 696e 6720 6569 6765 6e76 6563 746f  ating eigenvecto
+0001e2b0: 7220 6365 6e74 7261 6c69 7479 2e2e 2e0a  r centrality....
+0001e2c0: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+0001e2d0: 312e 202c 2030 2e38 3030 382c 2030 2e36  1. , 0.8008, 0.6
+0001e2e0: 3232 362c 2030 2e36 3632 352c 2030 2e38  226, 0.6625, 0.8
+0001e2f0: 3931 362c 2030 2e35 3832 202c 2030 2e35  916, 0.582 , 0.5
+0001e300: 3832 205d 290a 0a20 2020 2020 2020 203a  82 ])..        :
+0001e310: 7274 7970 653a 2031 6420 6e75 6d70 7920  rtype: 1d numpy 
+0001e320: 6172 7261 7920 5b6e 6f64 655d 206f 6620  array [node] of 
+0001e330: 666c 6f61 7473 0a20 2020 2020 2020 2022  floats.        "
+0001e340: 2222 0a20 2020 2020 2020 2044 7752 203d  "".        DwR =
+0001e350: 2073 656c 662e 7370 5f64 6961 675f 7371   self.sp_diag_sq
+0001e360: 7274 5f77 2829 0a20 2020 2020 2020 2073  rt_w().        s
+0001e370: 705f 4173 7461 7220 3d20 4477 5220 2a20  p_Astar = DwR * 
+0001e380: 7365 6c66 2e73 705f 4170 6c75 7328 2920  self.sp_Aplus() 
+0001e390: 2a20 4477 520a 2020 2020 2020 2020 5f2c  * DwR.        _,
+0001e3a0: 2065 7665 6373 203d 2065 6967 7368 2873   evecs = eigsh(s
+0001e3b0: 705f 4173 7461 722c 206b 3d31 2c20 7369  p_Astar, k=1, si
+0001e3c0: 676d 613d 7365 6c66 2e74 6f74 616c 5f6e  gma=self.total_n
+0001e3d0: 6f64 655f 7765 6967 6874 2a2a 322c 0a20  ode_weight**2,. 
+0001e3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e3f0: 2020 2020 2020 2020 6d61 7869 7465 723d          maxiter=
+0001e400: 3130 302c 2074 6f6c 3d31 652d 3829 0a20  100, tol=1e-8). 
+0001e410: 2020 2020 2020 2065 6320 3d20 6576 6563         ec = evec
+0001e420: 732e 545b 305d 202f 206e 702e 7371 7274  s.T[0] / np.sqrt
+0001e430: 2873 656c 662e 6e6f 6465 5f77 6569 6768  (self.node_weigh
+0001e440: 7473 290a 2020 2020 2020 2020 6563 202a  ts).        ec *
+0001e450: 3d20 6e70 2e73 6967 6e28 6563 5b30 5d29  = np.sign(ec[0])
+0001e460: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001e470: 6563 202f 2065 632e 6d61 7828 290a 0a20  ec / ec.max().. 
+0001e480: 2020 2064 6566 2070 6167 6572 616e 6b28     def pagerank(
+0001e490: 7365 6c66 2c20 6c69 6e6b 5f61 7474 7269  self, link_attri
+0001e4a0: 6275 7465 3d4e 6f6e 652c 2075 7365 5f64  bute=None, use_d
+0001e4b0: 6972 6563 7465 643d 5472 7565 293a 0a20  irected=True):. 
+0001e4c0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001e4d0: 2020 2046 6f72 2065 6163 6820 6e6f 6465     For each node
+0001e4e0: 2c20 7265 7475 726e 2069 7473 2028 7765  , return its (we
+0001e4f0: 6967 6874 6564 2920 5061 6765 5261 6e6b  ighted) PageRank
+0001e500: 2e0a 0a20 2020 2020 2020 2054 6869 7320  ...        This 
+0001e510: 6973 2074 6865 206c 6f61 6420 6f6e 2074  is the load on t
+0001e520: 6869 7320 6e6f 6465 2066 726f 6d20 7468  his node from th
+0001e530: 6520 6569 6765 6e76 6563 746f 7220 636f  e eigenvector co
+0001e540: 7272 6573 706f 6e64 696e 6720 746f 2074  rresponding to t
+0001e550: 6865 0a20 2020 2020 2020 206c 6172 6765  he.        large
+0001e560: 7374 2065 6967 656e 7661 6c75 6520 6f66  st eigenvalue of
+0001e570: 2061 206d 6f64 6966 6965 6420 6164 6a61   a modified adja
+0001e580: 6365 6e63 7920 6d61 7472 6978 2c20 6e6f  cency matrix, no
+0001e590: 726d 616c 697a 6564 2074 6f20 610a 2020  rmalized to a.  
+0001e5a0: 2020 2020 2020 6d61 7869 6d75 6d20 6f66        maximum of
+0001e5b0: 2031 2e0a 0a20 2020 2020 2020 202a 2a45   1...        **E
+0001e5c0: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
+0001e5d0: 2020 203e 3e3e 2072 284e 6574 776f 726b     >>> r(Network
+0001e5e0: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
+0001e5f0: 6b28 292e 7061 6765 7261 6e6b 2829 290a  k().pagerank()).
+0001e600: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+0001e610: 696e 6720 5061 6765 5261 6e6b 2e2e 2e0a  ing PageRank....
+0001e620: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+0001e630: 302e 3231 3834 2c20 302e 3230 3434 2c20  0.2184, 0.2044, 
+0001e640: 302e 3134 3039 2c20 302e 3134 3438 2c20  0.1409, 0.1448, 
+0001e650: 302e 3230 3437 2c20 302e 3038 3639 5d29  0.2047, 0.0869])
+0001e660: 0a0a 2020 2020 2020 2020 3a61 7267 2073  ..        :arg s
+0001e670: 7472 206c 696e 6b5f 6174 7472 6962 7574  tr link_attribut
+0001e680: 653a 204f 7074 696f 6e61 6c20 6e61 6d65  e: Optional name
+0001e690: 206f 6620 7468 6520 6c69 6e6b 2061 7474   of the link att
+0001e6a0: 7269 6275 7465 2074 6f20 6265 2075 7365  ribute to be use
+0001e6b0: 640a 2020 2020 2020 2020 2020 2020 6173  d.            as
+0001e6c0: 2074 6865 206c 696e 6b73 2720 7765 6967   the links' weig
+0001e6d0: 6874 2e20 4966 204e 6f6e 652c 206c 696e  ht. If None, lin
+0001e6e0: 6b73 2068 6176 6520 7765 6967 6874 2031  ks have weight 1
+0001e6f0: 2e20 2844 6566 6175 6c74 3a20 4e6f 6e65  . (Default: None
+0001e700: 290a 2020 2020 2020 2020 3a72 7479 7065  ).        :rtype
+0001e710: 3a20 3164 206e 756d 7079 2061 7272 6179  : 1d numpy array
+0001e720: 205b 6e6f 6465 5d20 6f66 0a20 2020 2020   [node] of.     
+0001e730: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+0001e740: 6620 6c69 6e6b 5f61 7474 7269 6275 7465  f link_attribute
+0001e750: 203d 3d20 2274 6f70 6f6c 6f67 6963 616c   == "topological
+0001e760: 223a 0a20 2020 2020 2020 2020 2020 2070  ":.            p
+0001e770: 7269 6e74 2822 5741 524e 494e 473a 206c  rint("WARNING: l
+0001e780: 696e 6b5f 6174 7472 6962 7574 653d 2774  ink_attribute='t
+0001e790: 6f70 6f6c 6f67 6963 616c 2720 6973 2064  opological' is d
+0001e7a0: 6570 7265 6361 7465 642e 5c6e 220a 2020  eprecated.\n".  
+0001e7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e7c0: 2b20 2255 7365 206c 696e 6b5f 6174 7472  + "Use link_attr
+0001e7d0: 6962 7574 653d 4e6f 6e65 2069 6e73 7465  ibute=None inste
+0001e7e0: 6164 2e22 290a 2020 2020 2020 2020 2020  ad.").          
+0001e7f0: 2020 6c69 6e6b 5f61 7474 7269 6275 7465    link_attribute
+0001e800: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
+0001e810: 6966 206c 696e 6b5f 6174 7472 6962 7574  if link_attribut
+0001e820: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
+0001e830: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+0001e840: 696c 656e 6365 5f6c 6576 656c 203c 3d20  ilence_level <= 
+0001e850: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+0001e860: 2020 2070 7269 6e74 2822 4361 6c63 756c     print("Calcul
+0001e870: 6174 696e 6720 5061 6765 5261 6e6b 2e2e  ating PageRank..
+0001e880: 2e22 290a 2020 2020 2020 2020 2020 2020  .").            
+0001e890: 7265 7475 726e 206e 702e 6172 7261 7928  return np.array(
+0001e8a0: 7365 6c66 2e67 7261 7068 2e70 6572 736f  self.graph.perso
+0001e8b0: 6e61 6c69 7a65 645f 7061 6765 7261 6e6b  nalized_pagerank
+0001e8c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001e8d0: 2020 6469 7265 6374 6564 3d75 7365 5f64    directed=use_d
+0001e8e0: 6972 6563 7465 642c 2077 6569 6768 7473  irected, weights
+0001e8f0: 3d4e 6f6e 6529 290a 2020 2020 2020 2020  =None)).        
+0001e900: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001e910: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
+0001e920: 655f 6c65 7665 6c20 3c3d 2031 3a0a 2020  e_level <= 1:.  
+0001e930: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+0001e940: 696e 7428 2243 616c 6375 6c61 7469 6e67  int("Calculating
+0001e950: 2077 6569 6768 7465 6420 5061 6765 5261   weighted PageRa
+0001e960: 6e6b 2e2e 2e22 290a 2020 2020 2020 2020  nk...").        
+0001e970: 2020 2020 7265 7475 726e 206e 702e 6172      return np.ar
+0001e980: 7261 7928 7365 6c66 2e67 7261 7068 2e70  ray(self.graph.p
+0001e990: 6572 736f 6e61 6c69 7a65 645f 7061 6765  ersonalized_page
+0001e9a0: 7261 6e6b 280a 2020 2020 2020 2020 2020  rank(.          
+0001e9b0: 2020 2020 2020 6469 7265 6374 6564 3d75        directed=u
+0001e9c0: 7365 5f64 6972 6563 7465 642c 2077 6569  se_directed, wei
+0001e9d0: 6768 7473 3d6c 696e 6b5f 6174 7472 6962  ghts=link_attrib
+0001e9e0: 7574 6529 290a 0a20 2020 2064 6566 2063  ute))..    def c
+0001e9f0: 6c6f 7365 6e65 7373 2873 656c 662c 206c  loseness(self, l
+0001ea00: 696e 6b5f 6174 7472 6962 7574 653d 4e6f  ink_attribute=No
+0001ea10: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
+0001ea20: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
+0001ea30: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
+0001ea40: 7473 2028 7765 6967 6874 6564 2920 636c  ts (weighted) cl
+0001ea50: 6f73 656e 6573 732e 0a0a 2020 2020 2020  oseness...      
+0001ea60: 2020 5468 6973 2069 7320 7468 6520 696e    This is the in
+0001ea70: 7665 7273 6520 6f66 2074 6865 206d 6561  verse of the mea
+0001ea80: 6e20 7368 6f72 7465 7374 2070 6174 6820  n shortest path 
+0001ea90: 6c65 6e67 7468 2066 726f 6d20 7468 6520  length from the 
+0001eaa0: 6e6f 6465 2074 6f0a 2020 2020 2020 2020  node to.        
+0001eab0: 616c 6c20 6f74 6865 7220 6e6f 6465 732e  all other nodes.
+0001eac0: 0a0a 2020 2020 2020 2020 2a2a 4578 616d  ..        **Exam
+0001ead0: 706c 653a 2a2a 0a0a 2020 2020 2020 2020  ple:**..        
+0001eae0: 3e3e 3e20 7228 4e65 7477 6f72 6b2e 536d  >>> r(Network.Sm
+0001eaf0: 616c 6c54 6573 744e 6574 776f 726b 2829  allTestNetwork()
+0001eb00: 2e63 6c6f 7365 6e65 7373 2829 290a 2020  .closeness()).  
+0001eb10: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+0001eb20: 6720 636c 6f73 656e 6573 732e 2e2e 0a20  g closeness.... 
+0001eb30: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
+0001eb40: 2e37 3134 332c 2030 2e36 3235 202c 2030  .7143, 0.625 , 0
+0001eb50: 2e35 3535 362c 2030 2e36 3235 202c 2030  .5556, 0.625 , 0
+0001eb60: 2e37 3134 332c 2030 2e34 3534 355d 290a  .7143, 0.4545]).
+0001eb70: 0a20 2020 2020 2020 203a 6172 6720 7374  .        :arg st
+0001eb80: 7220 6c69 6e6b 5f61 7474 7269 6275 7465  r link_attribute
+0001eb90: 3a20 4f70 7469 6f6e 616c 206e 616d 6520  : Optional name 
+0001eba0: 6f66 2074 6865 206c 696e 6b20 6174 7472  of the link attr
+0001ebb0: 6962 7574 6520 746f 2062 6520 7573 6564  ibute to be used
+0001ebc0: 0a20 2020 2020 2020 2020 2020 2061 7320  .            as 
+0001ebd0: 7468 6520 6c69 6e6b 7327 206c 656e 6774  the links' lengt
+0001ebe0: 682e 2049 6620 4e6f 6e65 2c20 6c69 6e6b  h. If None, link
+0001ebf0: 7320 6861 7665 206c 656e 6774 6820 312e  s have length 1.
+0001ec00: 2028 4465 6661 756c 743a 204e 6f6e 6529   (Default: None)
+0001ec10: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+0001ec20: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
+0001ec30: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
+0001ec40: 2062 6574 7765 656e 2030 2061 6e64 2031   between 0 and 1
+0001ec50: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001ec60: 2020 2020 2023 2054 4f44 4f3a 2063 6865       # TODO: che
+0001ec70: 636b 2061 6e64 2064 6573 6372 6962 6520  ck and describe 
+0001ec80: 6265 6861 7669 6f75 7220 666f 7220 756e  behaviour for un
+0001ec90: 636f 6e6e 6563 7465 6420 6e65 7477 6f72  connected networ
+0001eca0: 6b73 0a20 2020 2020 2020 2069 6620 6c69  ks.        if li
+0001ecb0: 6e6b 5f61 7474 7269 6275 7465 203d 3d20  nk_attribute == 
+0001ecc0: 2274 6f70 6f6c 6f67 6963 616c 223a 0a20  "topological":. 
+0001ecd0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0001ece0: 2822 5741 524e 494e 473a 206c 696e 6b5f  ("WARNING: link_
+0001ecf0: 6174 7472 6962 7574 653d 2774 6f70 6f6c  attribute='topol
+0001ed00: 6f67 6963 616c 2720 6973 2064 6570 7265  ogical' is depre
+0001ed10: 6361 7465 642e 5c6e 220a 2020 2020 2020  cated.\n".      
+0001ed20: 2020 2020 2020 2020 2020 2020 2b20 2255              + "U
+0001ed30: 7365 206c 696e 6b5f 6174 7472 6962 7574  se link_attribut
+0001ed40: 653d 4e6f 6e65 2069 6e73 7465 6164 2e22  e=None instead."
+0001ed50: 290a 2020 2020 2020 2020 2020 2020 6c69  ).            li
+0001ed60: 6e6b 5f61 7474 7269 6275 7465 203d 204e  nk_attribute = N
+0001ed70: 6f6e 650a 0a20 2020 2020 2020 2069 6620  one..        if 
+0001ed80: 6c69 6e6b 5f61 7474 7269 6275 7465 2069  link_attribute i
+0001ed90: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0001eda0: 2020 2020 6966 2073 656c 662e 7369 6c65      if self.sile
+0001edb0: 6e63 655f 6c65 7665 6c20 3c3d 2031 3a0a  nce_level <= 1:.
+0001edc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001edd0: 7072 696e 7428 2243 616c 6375 6c61 7469  print("Calculati
+0001ede0: 6e67 2063 6c6f 7365 6e65 7373 2e2e 2e22  ng closeness..."
+0001edf0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
+0001ee00: 2020 5265 7475 726e 2074 6865 2061 6273    Return the abs
+0001ee10: 6f6c 7574 6520 7661 6c75 6520 6f66 2074  olute value of t
+0001ee20: 6363 2c20 7369 6e63 6520 6120 6275 6720  cc, since a bug 
+0001ee30: 736f 6d65 7469 6d65 7320 7265 7375 6c74  sometimes result
+0001ee40: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+0001ee50: 2069 6e20 6e65 6761 7469 7665 2073 6967   in negative sig
+0001ee60: 6e73 0a20 2020 2020 2020 2020 2020 2072  ns.            r
+0001ee70: 6574 7572 6e20 6e70 2e61 6273 286e 702e  eturn np.abs(np.
+0001ee80: 6172 7261 7928 7365 6c66 2e67 7261 7068  array(self.graph
+0001ee90: 2e63 6c6f 7365 6e65 7373 2829 2929 0a0a  .closeness()))..
+0001eea0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001eeb0: 2020 2020 2020 2020 2020 4343 203d 206e            CC = n
+0001eec0: 702e 7a65 726f 7328 7365 6c66 2e4e 290a  p.zeros(self.N).
+0001eed0: 2020 2020 2020 2020 2020 2020 7061 7468              path
+0001eee0: 5f6c 656e 6774 6873 203d 2073 656c 662e  _lengths = self.
+0001eef0: 7061 7468 5f6c 656e 6774 6873 286c 696e  path_lengths(lin
+0001ef00: 6b5f 6174 7472 6962 7574 6529 0a0a 2020  k_attribute)..  
+0001ef10: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+0001ef20: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
+0001ef30: 3c3d 2031 3a0a 2020 2020 2020 2020 2020  <= 1:.          
+0001ef40: 2020 2020 2020 7072 696e 7428 2243 616c        print("Cal
+0001ef50: 6375 6c61 7469 6e67 2077 6569 6768 7465  culating weighte
+0001ef60: 6420 636c 6f73 656e 6573 732e 2e2e 2229  d closeness...")
+0001ef70: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+0001ef80: 2049 6465 6e74 6966 7920 756e 636f 6e6e   Identify unconn
+0001ef90: 6563 7465 6420 7061 6972 7320 616e 6420  ected pairs and 
+0001efa0: 7361 7665 2069 6e20 6269 6e61 7279 2061  save in binary a
+0001efb0: 7272 6179 2069 7369 6e66 0a20 2020 2020  rray isinf.     
+0001efc0: 2020 2020 2020 2075 6e63 6f6e 6e65 6374         unconnect
+0001efd0: 6564 5f70 6169 7273 203d 206e 702e 6973  ed_pairs = np.is
+0001efe0: 696e 6628 7061 7468 5f6c 656e 6774 6873  inf(path_lengths
+0001eff0: 290a 2020 2020 2020 2020 2020 2020 2320  ).            # 
+0001f000: 2053 6574 2069 6e66 696e 6974 6520 656e   Set infinite en
+0001f010: 7472 6965 7320 636f 7272 6573 706f 6e64  tries correspond
+0001f020: 696e 6720 746f 2075 6e63 6f6e 6e65 6374  ing to unconnect
+0001f030: 6564 2070 6169 7273 2074 6f0a 2020 2020  ed pairs to.    
+0001f040: 2020 2020 2020 2020 2320 206e 756d 6265          #  numbe
+0001f050: 7220 6f66 2076 6572 7469 6365 730a 2020  r of vertices.  
+0001f060: 2020 2020 2020 2020 2020 7061 7468 5f6c            path_l
+0001f070: 656e 6774 6873 5b75 6e63 6f6e 6e65 6374  engths[unconnect
+0001f080: 6564 5f70 6169 7273 5d20 3d20 7365 6c66  ed_pairs] = self
+0001f090: 2e4e 0a0a 2020 2020 2020 2020 2020 2020  .N..            
+0001f0a0: 2320 2053 6f6d 6520 706f 6c61 7220 6e6f  #  Some polar no
+0001f0b0: 6465 7320 6861 7665 2061 6e20 6173 7369  des have an assi
+0001f0c0: 676e 6564 2064 6973 7461 6e63 6520 6f66  gned distance of
+0001f0d0: 207a 6572 6f20 746f 2061 6c6c 2074 6865   zero to all the
+0001f0e0: 6972 0a20 2020 2020 2020 2020 2020 2023  ir.            #
+0001f0f0: 2020 6e65 6967 6862 6f72 732e 2054 6865    neighbors. The
+0001f100: 7365 206e 6f64 6573 2067 6574 207a 6572  se nodes get zer
+0001f110: 6f20 6765 6f67 7261 7068 6963 616c 2063  o geographical c
+0001f120: 6c6f 7365 6e65 7373 0a20 2020 2020 2020  loseness.       
+0001f130: 2020 2020 2023 2020 6365 6e74 7261 6c69       #  centrali
+0001f140: 7479 2e0a 2020 2020 2020 2020 2020 2020  ty..            
+0001f150: 7061 7468 5f6c 656e 6774 685f 7375 6d20  path_length_sum 
+0001f160: 3d20 7061 7468 5f6c 656e 6774 6873 2e73  = path_lengths.s
+0001f170: 756d 2861 7869 733d 3129 0a20 2020 2020  um(axis=1).     
+0001f180: 2020 2020 2020 2043 435b 7061 7468 5f6c         CC[path_l
+0001f190: 656e 6774 685f 7375 6d20 213d 2030 5d20  ength_sum != 0] 
+0001f1a0: 3d20 5c0a 2020 2020 2020 2020 2020 2020  = \.            
+0001f1b0: 2020 2020 2873 656c 662e 4e20 2d20 3129      (self.N - 1)
+0001f1c0: 202f 2070 6174 685f 6c65 6e67 7468 5f73   / path_length_s
+0001f1d0: 756d 5b70 6174 685f 6c65 6e67 7468 5f73  um[path_length_s
+0001f1e0: 756d 2021 3d20 305d 0a0a 2020 2020 2020  um != 0]..      
+0001f1f0: 2020 2020 2020 2320 2052 6576 6572 7365        #  Reverse
+0001f200: 2063 6861 6e67 6573 2074 6f20 7765 6967   changes to weig
+0001f210: 6874 6564 5061 7468 4c65 6e67 7468 730a  htedPathLengths.
+0001f220: 2020 2020 2020 2020 2020 2020 7061 7468              path
+0001f230: 5f6c 656e 6774 6873 5b75 6e63 6f6e 6e65  _lengths[unconne
+0001f240: 6374 6564 5f70 6169 7273 5d20 3d20 6e70  cted_pairs] = np
+0001f250: 2e69 6e66 0a0a 2020 2020 2020 2020 2020  .inf..          
+0001f260: 2020 7265 7475 726e 2043 430a 0a20 2020    return CC..   
+0001f270: 2040 4361 6368 6564 2e6d 6574 686f 6428   @Cached.method(
+0001f280: 6e61 6d65 3d22 6e2e 732e 692e 2063 6c6f  name="n.s.i. clo
+0001f290: 7365 6e65 7373 222c 2061 7474 7273 3d28  seness", attrs=(
+0001f2a0: 225f 6d75 745f 6e77 222c 2929 0a20 2020  "_mut_nw",)).   
+0001f2b0: 2064 6566 206e 7369 5f63 6c6f 7365 6e65   def nsi_closene
+0001f2c0: 7373 2873 656c 6629 3a0a 2020 2020 2020  ss(self):.      
+0001f2d0: 2020 2222 220a 2020 2020 2020 2020 466f    """.        Fo
+0001f2e0: 7220 6561 6368 206e 6f64 652c 2072 6574  r each node, ret
+0001f2f0: 7572 6e20 6974 7320 6e2e 732e 692e 2063  urn its n.s.i. c
+0001f300: 6c6f 7365 6e65 7373 2e0a 0a20 2020 2020  loseness...     
+0001f310: 2020 2054 6869 7320 6973 2074 6865 2069     This is the i
+0001f320: 6e76 6572 7365 206f 6620 7468 6520 6d65  nverse of the me
+0001f330: 616e 2073 686f 7274 6573 7420 7061 7468  an shortest path
+0001f340: 206c 656e 6774 6820 6672 6f6d 2074 6865   length from the
+0001f350: 206e 6f64 6520 746f 0a20 2020 2020 2020   node to.       
+0001f360: 2061 6c6c 206f 7468 6572 206e 6f64 6573   all other nodes
+0001f370: 2e20 4966 2074 6865 206e 6574 776f 726b  . If the network
+0001f380: 2069 7320 6e6f 7420 636f 6e6e 6563 7465   is not connecte
+0001f390: 642c 2074 6865 2072 6573 756c 7420 6973  d, the result is
+0001f3a0: 2030 2e0a 0a20 2020 2020 2020 202a 2a45   0...        **E
+0001f3b0: 7861 6d70 6c65 3a2a 2a0a 0a20 2020 2020  xample:**..     
+0001f3c0: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
+0001f3d0: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
+0001f3e0: 7477 6f72 6b28 290a 2020 2020 2020 2020  twork().        
+0001f3f0: 3e3e 3e20 7228 6e65 742e 6e73 695f 636c  >>> r(net.nsi_cl
+0001f400: 6f73 656e 6573 7328 2929 0a20 2020 2020  oseness()).     
+0001f410: 2020 2043 616c 6375 6c61 7469 6e67 206e     Calculating n
+0001f420: 2e73 2e69 2e20 636c 6f73 656e 6573 732e  .s.i. closeness.
+0001f430: 2e2e 0a20 2020 2020 2020 2043 616c 6375  ...        Calcu
+0001f440: 6c61 7469 6e67 2061 6c6c 2073 686f 7274  lating all short
+0001f450: 6573 7420 7061 7468 206c 656e 6774 6873  est path lengths
+0001f460: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
+0001f470: 7928 5b20 302e 3736 3932 2c20 302e 3634  y([ 0.7692, 0.64
+0001f480: 3836 2c20 302e 3538 3235 2c20 302e 3634  86, 0.5825, 0.64
+0001f490: 3137 2c20 302e 3732 3239 2c20 302e 3530  17, 0.7229, 0.50
+0001f4a0: 3835 5d29 0a20 2020 2020 2020 203e 3e3e  85]).        >>>
+0001f4b0: 2072 286e 6574 2e73 706c 6974 7465 645f   r(net.splitted_
+0001f4c0: 636f 7079 2829 2e6e 7369 5f63 6c6f 7365  copy().nsi_close
+0001f4d0: 6e65 7373 2829 290a 2020 2020 2020 2020  ness()).        
+0001f4e0: 4361 6c63 756c 6174 696e 6720 6e2e 732e  Calculating n.s.
+0001f4f0: 692e 2063 6c6f 7365 6e65 7373 2e2e 2e0a  i. closeness....
+0001f500: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+0001f510: 696e 6720 616c 6c20 7368 6f72 7465 7374  ing all shortest
+0001f520: 2070 6174 6820 6c65 6e67 7468 732e 2e2e   path lengths...
+0001f530: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+0001f540: 2030 2e37 3639 322c 2030 2e36 3438 362c   0.7692, 0.6486,
+0001f550: 2030 2e35 3832 352c 2030 2e36 3431 372c   0.5825, 0.6417,
+0001f560: 2030 2e37 3232 392c 2030 2e35 3038 352c   0.7229, 0.5085,
+0001f570: 2030 2e35 3038 355d 290a 0a20 2020 2020   0.5085])..     
+0001f580: 2020 2061 7320 636f 6d70 6172 6564 2074     as compared t
+0001f590: 6f20 7468 6520 756e 7765 6967 6874 6564  o the unweighted
+0001f5a0: 2076 6572 7369 6f6e 3a0a 0a20 2020 2020   version:..     
+0001f5b0: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
+0001f5c0: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
+0001f5d0: 7477 6f72 6b28 290a 2020 2020 2020 2020  twork().        
+0001f5e0: 3e3e 3e20 7228 6e65 742e 636c 6f73 656e  >>> r(net.closen
+0001f5f0: 6573 7328 2929 0a20 2020 2020 2020 2043  ess()).        C
+0001f600: 616c 6375 6c61 7469 6e67 2063 6c6f 7365  alculating close
+0001f610: 6e65 7373 2e2e 2e0a 2020 2020 2020 2020  ness....        
+0001f620: 6172 7261 7928 5b20 302e 3731 3433 2c20  array([ 0.7143, 
+0001f630: 302e 3632 3520 2c20 302e 3535 3536 2c20  0.625 , 0.5556, 
+0001f640: 302e 3632 3520 2c20 302e 3731 3433 2c20  0.625 , 0.7143, 
+0001f650: 302e 3435 3435 5d29 0a20 2020 2020 2020  0.4545]).       
+0001f660: 203e 3e3e 2072 286e 6574 2e73 706c 6974   >>> r(net.split
+0001f670: 7465 645f 636f 7079 2829 2e63 6c6f 7365  ted_copy().close
+0001f680: 6e65 7373 2829 290a 2020 2020 2020 2020  ness()).        
+0001f690: 4361 6c63 756c 6174 696e 6720 636c 6f73  Calculating clos
+0001f6a0: 656e 6573 732e 2e2e 0a20 2020 2020 2020  eness....       
+0001f6b0: 2061 7272 6179 285b 2030 2e37 3520 2c20   array([ 0.75 , 
+0001f6c0: 302e 3534 3535 2c20 302e 3520 2c20 302e  0.5455, 0.5 , 0.
+0001f6d0: 3620 2c20 302e 3636 3637 2c20 302e 3520  6 , 0.6667, 0.5 
+0001f6e0: 2c20 302e 3520 5d29 0a0a 2020 2020 2020  , 0.5 ])..      
+0001f6f0: 2020 3a72 7479 7065 3a20 3164 206e 756d    :rtype: 1d num
+0001f700: 7079 2061 7272 6179 205b 6e6f 6465 5d20  py array [node] 
+0001f710: 6f66 2066 6c6f 6174 7320 6265 7477 6565  of floats betwee
+0001f720: 6e20 3020 616e 6420 310a 2020 2020 2020  n 0 and 1.      
+0001f730: 2020 2222 220a 2020 2020 2020 2020 2320    """.        # 
+0001f740: 7369 6d69 6c61 7220 746f 206e 7369 5f61  similar to nsi_a
+0001f750: 7665 7261 6765 5f70 6174 685f 6c65 6e67  verage_path_leng
+0001f760: 7468 3a0a 2020 2020 2020 2020 6e73 695f  th:.        nsi_
+0001f770: 6469 7374 616e 6365 7320 3d20 7365 6c66  distances = self
+0001f780: 2e70 6174 685f 6c65 6e67 7468 7328 2920  .path_lengths() 
+0001f790: 2b20 6e70 2e69 6465 6e74 6974 7928 7365  + np.identity(se
+0001f7a0: 6c66 2e4e 290a 2020 2020 2020 2020 7265  lf.N).        re
+0001f7b0: 7475 726e 2028 7365 6c66 2e74 6f74 616c  turn (self.total
+0001f7c0: 5f6e 6f64 655f 7765 6967 6874 0a20 2020  _node_weight.   
+0001f7d0: 2020 2020 2020 2020 2020 2020 202f 206e               / n
+0001f7e0: 702e 646f 7428 6e73 695f 6469 7374 616e  p.dot(nsi_distan
+0001f7f0: 6365 732c 2073 656c 662e 6e6f 6465 5f77  ces, self.node_w
+0001f800: 6569 6768 7473 2929 0a0a 2020 2020 4043  eights))..    @C
+0001f810: 6163 6865 642e 6d65 7468 6f64 286e 616d  ached.method(nam
+0001f820: 653d 226e 2e73 2e69 2e20 6861 726d 6f6e  e="n.s.i. harmon
+0001f830: 6963 2063 6c6f 7365 6e65 7373 222c 2061  ic closeness", a
+0001f840: 7474 7273 3d28 225f 6d75 745f 6e77 222c  ttrs=("_mut_nw",
+0001f850: 2929 0a20 2020 2064 6566 206e 7369 5f68  )).    def nsi_h
+0001f860: 6172 6d6f 6e69 635f 636c 6f73 656e 6573  armonic_closenes
+0001f870: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
+0001f880: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
+0001f890: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
+0001f8a0: 726e 2069 7473 206e 2e73 2e69 2e20 6861  rn its n.s.i. ha
+0001f8b0: 726d 6f6e 6963 2063 6c6f 7365 6e65 7373  rmonic closeness
+0001f8c0: 2e0a 0a20 2020 2020 2020 2054 6869 7320  ...        This 
+0001f8d0: 6973 2074 6865 2069 6e76 6572 7365 206f  is the inverse o
+0001f8e0: 6620 7468 6520 6861 726d 6f6e 6963 206d  f the harmonic m
+0001f8f0: 6561 6e20 7368 6f72 7465 7374 2070 6174  ean shortest pat
+0001f900: 6820 6c65 6e67 7468 2066 726f 6d20 7468  h length from th
+0001f910: 650a 2020 2020 2020 2020 6e6f 6465 2074  e.        node t
+0001f920: 6f20 616c 6c20 6f74 6865 7220 6e6f 6465  o all other node
+0001f930: 732e 2049 6620 7468 6520 6e65 7477 6f72  s. If the networ
+0001f940: 6b20 6973 206e 6f74 2063 6f6e 6e65 6374  k is not connect
+0001f950: 6564 2c20 7468 6520 7265 7375 6c74 2069  ed, the result i
+0001f960: 730a 2020 2020 2020 2020 6e6f 7420 6e65  s.        not ne
+0001f970: 6365 7373 6172 696c 7920 302e 0a0a 2020  cessarily 0...  
+0001f980: 2020 2020 2020 2a2a 4578 616d 706c 653a        **Example:
+0001f990: 2a2a 0a0a 2020 2020 2020 2020 3e3e 3e20  **..        >>> 
+0001f9a0: 6e65 7420 3d20 4e65 7477 6f72 6b2e 536d  net = Network.Sm
+0001f9b0: 616c 6c54 6573 744e 6574 776f 726b 2829  allTestNetwork()
+0001f9c0: 0a20 2020 2020 2020 203e 3e3e 2072 286e  .        >>> r(n
+0001f9d0: 6574 2e6e 7369 5f68 6172 6d6f 6e69 635f  et.nsi_harmonic_
+0001f9e0: 636c 6f73 656e 6573 7328 2929 0a20 2020  closeness()).   
+0001f9f0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+0001fa00: 206e 2e73 2e69 2e20 6861 726d 6f6e 6963   n.s.i. harmonic
+0001fa10: 2063 6c6f 7365 6e65 7373 2e2e 2e0a 2020   closeness....  
+0001fa20: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+0001fa30: 6720 616c 6c20 7368 6f72 7465 7374 2070  g all shortest p
+0001fa40: 6174 6820 6c65 6e67 7468 732e 2e2e 0a20  ath lengths.... 
+0001fa50: 2020 2020 2020 2061 7272 6179 285b 2030         array([ 0
+0001fa60: 2e38 3520 2c20 302e 3739 3836 2c20 302e  .85 , 0.7986, 0.
+0001fa70: 3731 3131 2c20 302e 3732 3038 2c20 302e  7111, 0.7208, 0.
+0001fa80: 3830 3833 2c20 302e 3631 3637 5d29 0a20  8083, 0.6167]). 
+0001fa90: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+0001faa0: 2e73 706c 6974 7465 645f 636f 7079 2829  .splitted_copy()
+0001fab0: 2e6e 7369 5f68 6172 6d6f 6e69 635f 636c  .nsi_harmonic_cl
+0001fac0: 6f73 656e 6573 7328 2929 0a20 2020 2020  oseness()).     
+0001fad0: 2020 2043 616c 6375 6c61 7469 6e67 206e     Calculating n
+0001fae0: 2e73 2e69 2e20 6861 726d 6f6e 6963 2063  .s.i. harmonic c
+0001faf0: 6c6f 7365 6e65 7373 2e2e 2e0a 2020 2020  loseness....    
+0001fb00: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+0001fb10: 616c 6c20 7368 6f72 7465 7374 2070 6174  all shortest pat
+0001fb20: 6820 6c65 6e67 7468 732e 2e2e 0a20 2020  h lengths....   
+0001fb30: 2020 2020 2061 7272 6179 285b 2030 2e38       array([ 0.8
+0001fb40: 3520 2c20 302e 3739 3836 2c20 302e 3731  5 , 0.7986, 0.71
+0001fb50: 3131 2c20 302e 3732 3038 2c20 302e 3830  11, 0.7208, 0.80
+0001fb60: 3833 2c20 302e 3631 3637 2c20 302e 3631  83, 0.6167, 0.61
+0001fb70: 3637 5d29 0a0a 2020 2020 2020 2020 3a72  67])..        :r
+0001fb80: 7479 7065 3a20 3164 206e 756d 7079 2061  type: 1d numpy a
+0001fb90: 7272 6179 205b 6e6f 6465 5d20 6f66 2066  rray [node] of f
+0001fba0: 6c6f 6174 7320 6265 7477 6565 6e20 3020  loats between 0 
+0001fbb0: 616e 6420 310a 2020 2020 2020 2020 2222  and 1.        ""
+0001fbc0: 220a 2020 2020 2020 2020 2320 7369 6d69  ".        # simi
+0001fbd0: 6c61 7220 746f 206e 7369 5f61 7665 7261  lar to nsi_avera
+0001fbe0: 6765 5f70 6174 685f 6c65 6e67 7468 3a0a  ge_path_length:.
+0001fbf0: 2020 2020 2020 2020 6e73 695f 6469 7374          nsi_dist
+0001fc00: 616e 6365 7320 3d20 7365 6c66 2e70 6174  ances = self.pat
+0001fc10: 685f 6c65 6e67 7468 7328 2920 2b20 6e70  h_lengths() + np
+0001fc20: 2e69 6465 6e74 6974 7928 7365 6c66 2e4e  .identity(self.N
+0001fc30: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0001fc40: 2028 6e70 2e64 6f74 2831 2e30 202f 206e   (np.dot(1.0 / n
+0001fc50: 7369 5f64 6973 7461 6e63 6573 2c20 7365  si_distances, se
+0001fc60: 6c66 2e6e 6f64 655f 7765 6967 6874 7329  lf.node_weights)
+0001fc70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001fc80: 202f 2073 656c 662e 746f 7461 6c5f 6e6f   / self.total_no
+0001fc90: 6465 5f77 6569 6768 7429 0a0a 2020 2020  de_weight)..    
+0001fca0: 4043 6163 6865 642e 6d65 7468 6f64 286e  @Cached.method(n
+0001fcb0: 616d 653d 226e 2e73 2e69 2e20 6578 706f  ame="n.s.i. expo
+0001fcc0: 6e65 6e74 6961 6c20 636c 6f73 656e 6573  nential closenes
+0001fcd0: 7320 6365 6e74 7261 6c69 7479 222c 0a20  s centrality",. 
+0001fce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fcf0: 2020 6174 7472 733d 2822 5f6d 7574 5f6e    attrs=("_mut_n
+0001fd00: 7722 2c29 290a 2020 2020 6465 6620 6e73  w",)).    def ns
+0001fd10: 695f 6578 706f 6e65 6e74 6961 6c5f 636c  i_exponential_cl
+0001fd20: 6f73 656e 6573 7328 7365 6c66 293a 0a20  oseness(self):. 
+0001fd30: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001fd40: 2020 2046 6f72 2065 6163 6820 6e6f 6465     For each node
+0001fd50: 2c20 7265 7475 726e 2069 7473 206e 2e73  , return its n.s
+0001fd60: 2e69 2e20 6578 706f 6e65 6e74 6961 6c20  .i. exponential 
+0001fd70: 6861 726d 6f6e 6963 2063 6c6f 7365 6e65  harmonic closene
+0001fd80: 7373 2e0a 0a20 2020 2020 2020 2054 6869  ss...        Thi
+0001fd90: 7320 6973 2074 6865 206d 6561 6e20 6f66  s is the mean of
+0001fda0: 2020 322a 2a28 2d20 7368 6f72 7465 7374    2**(- shortest
+0001fdb0: 2070 6174 6820 6c65 6e67 7468 2920 2066   path length)  f
+0001fdc0: 726f 6d20 7468 650a 2020 2020 2020 2020  rom the.        
+0001fdd0: 6e6f 6465 2074 6f20 616c 6c20 6f74 6865  node to all othe
+0001fde0: 7220 6e6f 6465 732e 2049 6620 7468 6520  r nodes. If the 
+0001fdf0: 6e65 7477 6f72 6b20 6973 206e 6f74 2063  network is not c
+0001fe00: 6f6e 6e65 6374 6564 2c20 7468 6520 7265  onnected, the re
+0001fe10: 7375 6c74 2069 730a 2020 2020 2020 2020  sult is.        
+0001fe20: 6e6f 7420 6e65 6365 7373 6172 696c 7920  not necessarily 
+0001fe30: 302e 0a0a 2020 2020 2020 2020 2a2a 4578  0...        **Ex
+0001fe40: 616d 706c 653a 2a2a 0a0a 2020 2020 2020  ample:**..      
+0001fe50: 2020 3e3e 3e20 6e65 7420 3d20 4e65 7477    >>> net = Netw
+0001fe60: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
+0001fe70: 776f 726b 2829 0a20 2020 2020 2020 203e  work().        >
+0001fe80: 3e3e 2072 286e 6574 2e6e 7369 5f65 7870  >> r(net.nsi_exp
+0001fe90: 6f6e 656e 7469 616c 5f63 6c6f 7365 6e65  onential_closene
+0001fea0: 7373 2829 290a 2020 2020 2020 2020 4361  ss()).        Ca
+0001feb0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+0001fec0: 2065 7870 6f6e 656e 7469 616c 2063 6c6f   exponential clo
+0001fed0: 7365 6e65 7373 2063 656e 7472 616c 6974  seness centralit
+0001fee0: 792e 2e2e 0a20 2020 2020 2020 2043 616c  y....        Cal
+0001fef0: 6375 6c61 7469 6e67 2061 6c6c 2073 686f  culating all sho
+0001ff00: 7274 6573 7420 7061 7468 206c 656e 6774  rtest path lengt
+0001ff10: 6873 2e2e 2e0a 2020 2020 2020 2020 6172  hs....        ar
+0001ff20: 7261 7928 5b20 302e 3432 3520 2c20 302e  ray([ 0.425 , 0.
+0001ff30: 3339 3036 2c20 302e 3334 3639 2c20 302e  3906, 0.3469, 0.
+0001ff40: 3336 3034 2c20 302e 3430 3432 2c20 302e  3604, 0.4042, 0.
+0001ff50: 3239 3538 5d29 0a20 2020 2020 2020 203e  2958]).        >
+0001ff60: 3e3e 2072 286e 6574 2e73 706c 6974 7465  >> r(net.splitte
+0001ff70: 645f 636f 7079 2829 2e6e 7369 5f65 7870  d_copy().nsi_exp
+0001ff80: 6f6e 656e 7469 616c 5f63 6c6f 7365 6e65  onential_closene
+0001ff90: 7373 2829 290a 2020 2020 2020 2020 4361  ss()).        Ca
+0001ffa0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+0001ffb0: 2065 7870 6f6e 656e 7469 616c 2063 6c6f   exponential clo
+0001ffc0: 7365 6e65 7373 2063 656e 7472 616c 6974  seness centralit
+0001ffd0: 792e 2e2e 0a20 2020 2020 2020 2043 616c  y....        Cal
+0001ffe0: 6375 6c61 7469 6e67 2061 6c6c 2073 686f  culating all sho
+0001fff0: 7274 6573 7420 7061 7468 206c 656e 6774  rtest path lengt
+00020000: 6873 2e2e 2e0a 2020 2020 2020 2020 6172  hs....        ar
+00020010: 7261 7928 5b20 302e 3432 3520 2c20 302e  ray([ 0.425 , 0.
+00020020: 3339 3036 2c20 302e 3334 3639 2c20 302e  3906, 0.3469, 0.
+00020030: 3336 3034 2c20 302e 3430 3432 2c20 302e  3604, 0.4042, 0.
+00020040: 3239 3538 2c20 302e 3239 3538 5d29 0a0a  2958, 0.2958])..
+00020050: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00020060: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
+00020070: 6e6f 6465 5d20 6f66 2066 6c6f 6174 7320  node] of floats 
+00020080: 6265 7477 6565 6e20 3020 616e 6420 310a  between 0 and 1.
+00020090: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000200a0: 2020 2020 2320 7369 6d69 6c61 7220 746f      # similar to
+000200b0: 206e 7369 5f61 7665 7261 6765 5f70 6174   nsi_average_pat
+000200c0: 685f 6c65 6e67 7468 3a0a 2020 2020 2020  h_length:.      
+000200d0: 2020 6e73 695f 6469 7374 616e 6365 7320    nsi_distances 
+000200e0: 3d20 7365 6c66 2e70 6174 685f 6c65 6e67  = self.path_leng
+000200f0: 7468 7328 2920 2b20 6e70 2e69 6465 6e74  ths() + np.ident
+00020100: 6974 7928 7365 6c66 2e4e 290a 2020 2020  ity(self.N).    
+00020110: 2020 2020 7265 7475 726e 2028 6e70 2e64      return (np.d
+00020120: 6f74 2832 2e30 2a2a 282d 6e73 695f 6469  ot(2.0**(-nsi_di
+00020130: 7374 616e 6365 7329 2c20 7365 6c66 2e6e  stances), self.n
+00020140: 6f64 655f 7765 6967 6874 7329 0a20 2020  ode_weights).   
+00020150: 2020 2020 2020 2020 2020 2020 202f 2073               / s
+00020160: 656c 662e 746f 7461 6c5f 6e6f 6465 5f77  elf.total_node_w
+00020170: 6569 6768 7429 0a0a 2020 2020 4043 6163  eight)..    @Cac
+00020180: 6865 642e 6d65 7468 6f64 286e 616d 653d  hed.method(name=
+00020190: 2241 7265 6e61 732d 7479 7065 2072 616e  "Arenas-type ran
+000201a0: 646f 6d20 7761 6c6b 2062 6574 7765 656e  dom walk between
+000201b0: 6e65 7373 2229 0a20 2020 2064 6566 2061  ness").    def a
+000201c0: 7265 6e61 735f 6265 7477 6565 6e6e 6573  renas_betweennes
+000201d0: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
+000201e0: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
+000201f0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
+00020200: 726e 2069 7473 2041 7265 6e61 732d 7479  rn its Arenas-ty
+00020210: 7065 2072 616e 646f 6d20 7761 6c6b 2062  pe random walk b
+00020220: 6574 7765 656e 6e65 7373 2e0a 0a20 2020  etweenness...   
+00020230: 2020 2020 2054 6869 7320 6d65 6173 7572       This measur
+00020240: 6573 2068 6f77 206f 6674 656e 2061 2072  es how often a r
+00020250: 616e 646f 6d20 7761 6c6b 2073 6561 7263  andom walk searc
+00020260: 6820 666f 7220 6120 7261 6e64 6f6d 2074  h for a random t
+00020270: 6172 6765 7420 6e6f 6465 0a20 2020 2020  arget node.     
+00020280: 2020 2066 726f 6d20 6120 7261 6e64 6f6d     from a random
+00020290: 2073 6f75 7263 6520 6e6f 6465 2069 7320   source node is 
+000202a0: 6578 7065 6374 6564 2074 6f20 7061 7373  expected to pass
+000202b0: 2074 6869 7320 6e6f 6465 2e20 2028 7365   this node.  (se
+000202c0: 650a 2020 2020 2020 2020 5b41 7265 6e61  e.        [Arena
+000202d0: 7332 3030 335d 5f29 0a0a 2020 2020 2020  s2003]_)..      
+000202e0: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
+000202f0: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
+00020300: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
+00020310: 6574 776f 726b 2829 2e61 7265 6e61 735f  etwork().arenas_
+00020320: 6265 7477 6565 6e6e 6573 7328 2929 0a20  betweenness()). 
+00020330: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
+00020340: 6e67 2041 7265 6e61 732d 7479 7065 2072  ng Arenas-type r
+00020350: 616e 646f 6d20 7761 6c6b 2062 6574 7765  andom walk betwe
+00020360: 656e 6e65 7373 2e2e 2e0a 2020 2020 2020  enness....      
+00020370: 2020 2020 2028 6769 616e 7420 636f 6d70       (giant comp
+00020380: 6f6e 656e 7420 7369 7a65 3a20 3620 2831  onent size: 6 (1
+00020390: 2e30 2929 0a20 2020 2020 2020 2061 7272  .0)).        arr
+000203a0: 6179 285b 2035 302e 3138 3138 2c20 3530  ay([ 50.1818, 50
+000203b0: 2e31 3831 382c 2033 332e 3435 3435 2c20  .1818, 33.4545, 
+000203c0: 3333 2e34 3534 352c 2035 302e 3138 3138  33.4545, 50.1818
+000203d0: 2c20 3136 2e37 3237 335d 290a 0a20 2020  , 16.7273])..   
+000203e0: 2020 2020 203a 7274 7970 653a 2031 6420       :rtype: 1d 
+000203f0: 6e75 6d70 7920 6172 7261 7920 5b6e 6f64  numpy array [nod
+00020400: 655d 206f 6620 666c 6f61 7473 203e 3d20  e] of floats >= 
+00020410: 300a 2020 2020 2020 2020 2222 220a 2020  0.        """.  
+00020420: 2020 2020 2020 7430 203d 2074 696d 652e        t0 = time.
+00020430: 7469 6d65 2829 0a0a 2020 2020 2020 2020  time()..        
+00020440: 2320 2049 6e69 7469 616c 697a 6520 7468  #  Initialize th
+00020450: 6520 6172 7261 7920 746f 2068 6f6c 6420  e array to hold 
+00020460: 7261 6e64 6f6d 2077 616c 6b20 6265 7477  random walk betw
+00020470: 6565 6e6e 6573 730a 2020 2020 2020 2020  eenness.        
+00020480: 6172 656e 6173 5f62 6574 7765 656e 6e65  arenas_betweenne
+00020490: 7373 203d 206e 702e 7a65 726f 7328 7365  ss = np.zeros(se
+000204a0: 6c66 2e4e 290a 0a20 2020 2020 2020 2023  lf.N)..        #
+000204b0: 2020 5261 6e64 6f6d 2077 616c 6b20 6265    Random walk be
+000204c0: 7477 6565 6e6e 6573 7320 6861 7320 746f  tweenness has to
+000204d0: 2062 6520 6361 6c63 756c 6174 6564 2066   be calculated f
+000204e0: 6f72 2065 6163 6820 636f 6d70 6f6e 656e  or each componen
+000204f0: 740a 2020 2020 2020 2020 2320 2073 6570  t.        #  sep
+00020500: 6172 6174 656c 7920 5468 6572 6566 6f72  arately Therefor
+00020510: 6520 6765 7420 6469 6666 6572 656e 7420  e get different 
+00020520: 636f 6d70 6f6e 656e 7473 206f 6620 7468  components of th
+00020530: 6520 6772 6170 6820 6669 7273 740a 2020  e graph first.  
+00020540: 2020 2020 2020 636f 6d70 6f6e 656e 7473        components
+00020550: 203d 2073 656c 662e 6772 6170 682e 636f   = self.graph.co
+00020560: 6e6e 6563 7465 645f 636f 6d70 6f6e 656e  nnected_componen
+00020570: 7473 2829 0a0a 2020 2020 2020 2020 2320  ts()..        # 
+00020580: 2050 7269 6e74 2067 6961 6e74 2063 6f6d   Print giant com
+00020590: 706f 6e65 6e74 2073 697a 650a 2020 2020  ponent size.    
+000205a0: 2020 2020 6966 2073 656c 662e 7369 6c65      if self.sile
+000205b0: 6e63 655f 6c65 7665 6c20 3c3d 2031 3a0a  nce_level <= 1:.
+000205c0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+000205d0: 7428 2220 2020 2867 6961 6e74 2063 6f6d  t("   (giant com
+000205e0: 706f 6e65 6e74 2073 697a 653a 2022 0a20  ponent size: ". 
+000205f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020600: 202b 2073 7472 2863 6f6d 706f 6e65 6e74   + str(component
+00020610: 732e 6769 616e 7428 292e 7663 6f75 6e74  s.giant().vcount
+00020620: 2829 2920 2b20 2220 2822 0a20 2020 2020  ()) + " (".     
+00020630: 2020 2020 2020 2020 2020 2020 202b 2073               + s
+00020640: 7472 2863 6f6d 706f 6e65 6e74 732e 6769  tr(components.gi
+00020650: 616e 7428 292e 7663 6f75 6e74 2829 0a20  ant().vcount(). 
+00020660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020670: 2020 2020 2020 202f 2066 6c6f 6174 2873         / float(s
+00020680: 656c 662e 6772 6170 682e 7663 6f75 6e74  elf.graph.vcount
+00020690: 2829 2929 202b 2022 2929 2229 0a0a 2020  ())) + "))")..  
+000206a0: 2020 2020 2020 666f 7220 632c 2063 6f6d        for c, com
+000206b0: 7020 696e 2065 6e75 6d65 7261 7465 2863  p in enumerate(c
+000206c0: 6f6d 706f 6e65 6e74 7329 3a0a 2020 2020  omponents):.    
+000206d0: 2020 2020 2020 2020 2320 2049 6620 7468          #  If th
+000206e0: 6520 636f 6d70 6f6e 656e 7420 6861 7320  e component has 
+000206f0: 7369 7a65 2031 2c20 7365 7420 7261 6e64  size 1, set rand
+00020700: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
+00020710: 6573 7320 746f 207a 6572 6f0a 2020 2020  ess to zero.    
+00020720: 2020 2020 2020 2020 6966 206c 656e 2863          if len(c
+00020730: 6f6d 7029 203d 3d20 313a 0a20 2020 2020  omp) == 1:.     
+00020740: 2020 2020 2020 2020 2020 2061 7265 6e61             arena
+00020750: 735f 6265 7477 6565 6e6e 6573 735b 636f  s_betweenness[co
+00020760: 6d70 5b30 5d5d 203d 2030 0a20 2020 2020  mp[0]] = 0.     
+00020770: 2020 2020 2020 2023 2020 466f 7220 6c61         #  For la
+00020780: 7267 6572 2063 6f6d 706f 6e65 6e74 732c  rger components,
+00020790: 2063 6f6e 7469 6e75 6520 7769 7468 2074   continue with t
+000207a0: 6865 2063 616c 6375 6c61 7469 6f6e 0a20  he calculation. 
+000207b0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+000207c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000207d0: 2023 2020 4765 7420 7468 6520 7375 6267   #  Get the subg
+000207e0: 7261 7068 2063 6f72 7265 7370 6f6e 6469  raph correspondi
+000207f0: 6e67 2074 6f20 636f 6d70 6f6e 656e 7420  ng to component 
+00020800: 690a 2020 2020 2020 2020 2020 2020 2020  i.              
+00020810: 2020 7375 6267 7261 7068 203d 2063 6f6d    subgraph = com
+00020820: 706f 6e65 6e74 732e 7375 6267 7261 7068  ponents.subgraph
+00020830: 2863 290a 0a20 2020 2020 2020 2020 2020  (c)..           
+00020840: 2020 2020 2023 2020 4765 7420 7468 6520       #  Get the 
+00020850: 7375 6267 7261 7068 2041 206d 6174 7269  subgraph A matri
+00020860: 780a 2020 2020 2020 2020 2020 2020 2020  x.              
+00020870: 2020 4120 3d20 6e70 2e61 7272 6179 2873    A = np.array(s
+00020880: 7562 6772 6170 682e 6765 745f 6164 6a61  ubgraph.get_adja
+00020890: 6365 6e63 7928 7479 7065 3d32 292e 6461  cency(type=2).da
+000208a0: 7461 290a 0a20 2020 2020 2020 2020 2020  ta)..           
+000208b0: 2020 2020 2023 2020 4765 6e65 7261 7465       #  Generate
+000208c0: 2061 204e 6574 776f 726b 206f 626a 6563   a Network objec
+000208d0: 7420 7265 7072 6573 656e 7469 6e67 2074  t representing t
+000208e0: 6865 2073 7562 6772 6170 680a 2020 2020  he subgraph.    
+000208f0: 2020 2020 2020 2020 2020 2020 7375 626e              subn
+00020900: 6574 776f 726b 203d 204e 6574 776f 726b  etwork = Network
+00020910: 2861 646a 6163 656e 6379 3d41 2c20 6469  (adjacency=A, di
+00020920: 7265 6374 6564 3d46 616c 7365 290a 0a20  rected=False).. 
+00020930: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00020940: 2020 4765 7420 7468 6520 6e75 6d62 6572    Get the number
+00020950: 206f 6620 6e6f 6465 7320 6f66 2074 6865   of nodes of the
+00020960: 2073 7562 6772 6170 6820 2874 6865 2063   subgraph (the c
+00020970: 6f6d 706f 6e65 6e74 2073 697a 6529 0a20  omponent size). 
+00020980: 2020 2020 2020 2020 2020 2020 2020 204e                 N
+00020990: 203d 2073 7562 6e65 7477 6f72 6b2e 4e0a   = subnetwork.N.
+000209a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000209b0: 2023 2020 496e 6974 6961 6c69 7a65 2074   #  Initialize t
+000209c0: 6865 2052 5742 2061 7272 6179 0a20 2020  he RWB array.   
+000209d0: 2020 2020 2020 2020 2020 2020 2063 6f6d               com
+000209e0: 706f 6e65 6e74 5f62 6574 7765 656e 6e65  ponent_betweenne
+000209f0: 7373 203d 206e 702e 7a65 726f 7328 4e29  ss = np.zeros(N)
+00020a00: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00020a10: 2020 2320 2047 6574 2074 6865 2073 7562    #  Get the sub
+00020a20: 6e65 7477 6f72 6b73 2064 6567 7265 6520  networks degree 
+00020a30: 7365 7175 656e 6365 0a20 2020 2020 2020  sequence.       
+00020a40: 2020 2020 2020 2020 206b 203d 2073 7562           k = sub
+00020a50: 6e65 7477 6f72 6b2e 6465 6772 6565 2829  network.degree()
+00020a60: 2e61 7374 7970 6528 2766 6c6f 6174 3634  .astype('float64
+00020a70: 2729 0a0a 2020 2020 2020 2020 2020 2020  ')..            
+00020a80: 2020 2020 2320 2043 6c65 616e 2075 700a      #  Clean up.
+00020a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020aa0: 6465 6c20 7375 6267 7261 7068 2c20 7375  del subgraph, su
+00020ab0: 626e 6574 776f 726b 0a0a 2020 2020 2020  bnetwork..      
+00020ac0: 2020 2020 2020 2020 2020 2320 2047 6574            #  Get
+00020ad0: 2074 6865 2050 2074 6861 7420 6973 206d   the P that is m
+00020ae0: 6f64 6966 6965 6420 616e 6420 696e 7665  odified and inve
+00020af0: 7274 6564 2062 7920 7468 6520 432b 2b20  rted by the C++ 
+00020b00: 636f 6465 0a20 2020 2020 2020 2020 2020  code.           
+00020b10: 2020 2020 2050 203d 206e 702e 646f 7428       P = np.dot(
+00020b20: 6e70 2e64 6961 6728 3120 2f20 6b29 2c20  np.diag(1 / k), 
+00020b30: 4129 0a0a 2020 2020 2020 2020 2020 2020  A)..            
+00020b40: 2020 2020 666f 7220 6920 696e 2072 616e      for i in ran
+00020b50: 6765 284e 293a 0a20 2020 2020 2020 2020  ge(N):.         
+00020b60: 2020 2020 2020 2020 2020 2023 2020 5374             #  St
+00020b70: 6f72 6520 7468 6520 6b74 6820 726f 7720  ore the kth row 
+00020b80: 6f66 2074 6865 2050 0a20 2020 2020 2020  of the P.       
+00020b90: 2020 2020 2020 2020 2020 2020 2072 6f77               row
+00020ba0: 5f69 203d 206e 702e 636f 7079 2850 5b69  _i = np.copy(P[i
+00020bb0: 2c20 3a5d 290a 0a20 2020 2020 2020 2020  , :])..         
+00020bc0: 2020 2020 2020 2020 2020 2023 2020 5365             #  Se
+00020bd0: 7420 7468 6520 692d 7468 2072 6f77 206f  t the i-th row o
+00020be0: 6620 7468 6520 5020 746f 207a 6572 6f20  f the P to zero 
+00020bf0: 746f 2061 6363 6f75 6e74 2066 6f72 2074  to account for t
+00020c00: 6865 0a20 2020 2020 2020 2020 2020 2020  he.             
+00020c10: 2020 2020 2020 2023 2020 6162 736f 7270         #  absorp
+00020c20: 7469 6f6e 206f 6620 7261 6e64 6f6d 2077  tion of random w
+00020c30: 616c 6b65 7273 2061 7420 7468 6569 7220  alkers at their 
+00020c40: 6465 7374 696e 6174 696f 6e0a 2020 2020  destination.    
+00020c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020c60: 505b 692c 203a 5d20 3d20 300a 0a20 2020  P[i, :] = 0..   
+00020c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020c80: 2023 2020 4361 6c63 756c 6174 6520 7468   #  Calculate th
+00020c90: 6520 625e 6920 6d61 7472 6978 0a20 2020  e b^i matrix.   
+00020ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020cb0: 2042 203d 206e 702e 646f 7428 6e70 2e6c   B = np.dot(np.l
+00020cc0: 696e 616c 672e 696e 7628 6e70 2e69 6465  inalg.inv(np.ide
+00020cd0: 6e74 6974 7928 4e29 202d 2050 292c 2050  ntity(N) - P), P
+00020ce0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+00020cf0: 2020 2020 2020 2023 2020 5065 7266 6f72         #  Perfor
+00020d00: 6d20 7468 6520 7375 6d6d 6174 696f 6e20  m the summation 
+00020d10: 6f76 6572 2073 6f75 7263 6520 6e6f 6465  over source node
+00020d20: 2063 0a20 2020 2020 2020 2020 2020 2020   c.             
+00020d30: 2020 2020 2020 2063 6f6d 706f 6e65 6e74         component
+00020d40: 5f62 6574 7765 656e 6e65 7373 202b 3d20  _betweenness += 
+00020d50: 422e 7375 6d28 6178 6973 3d30 290a 0a20  B.sum(axis=0).. 
+00020d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020d70: 2020 2023 2020 5265 7374 6f72 6520 7468     #  Restore th
+00020d80: 6520 500a 2020 2020 2020 2020 2020 2020  e P.            
+00020d90: 2020 2020 2020 2020 505b 692c 203a 5d20          P[i, :] 
+00020da0: 3d20 726f 775f 690a 0a20 2020 2020 2020  = row_i..       
+00020db0: 2020 2020 2020 2020 2023 2020 4e6f 726d           #  Norm
+00020dc0: 616c 697a 6520 5257 4220 6279 2063 6f6d  alize RWB by com
+00020dd0: 706f 6e65 6e74 2073 697a 650a 2020 2020  ponent size.    
+00020de0: 2020 2020 2020 2020 2020 2020 2320 636f              # co
+00020df0: 6d70 6f6e 656e 745f 6265 7477 6565 6e6e  mponent_betweenn
+00020e00: 6573 7320 2a3d 204e 0a0a 2020 2020 2020  ess *= N..      
+00020e10: 2020 2020 2020 2020 2020 2320 2047 6574            #  Get
+00020e20: 2074 6865 206c 6973 7420 6f66 2076 6572   the list of ver
+00020e30: 7465 7820 6e75 6d62 6572 7320 696e 2074  tex numbers in t
+00020e40: 6865 2073 7562 6772 6170 680a 2020 2020  he subgraph.    
+00020e50: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
+00020e60: 7320 3d20 636f 6d70 0a0a 2020 2020 2020  s = comp..      
+00020e70: 2020 2020 2020 2020 2020 2320 2043 6f70            #  Cop
+00020e80: 7920 7265 7375 6c74 7320 696e 746f 2072  y results into r
+00020e90: 616e 646f 6d57 616c 6b42 6574 7765 656e  andomWalkBetween
+00020ea0: 6e65 7373 4172 7261 7920 6174 2074 6865  nessArray at the
+00020eb0: 2063 6f72 7265 6374 0a20 2020 2020 2020   correct.       
+00020ec0: 2020 2020 2020 2020 2023 2020 706f 7369           #  posi
+00020ed0: 7469 6f6e 730a 2020 2020 2020 2020 2020  tions.          
+00020ee0: 2020 2020 2020 666f 7220 6a2c 206e 6f64        for j, nod
+00020ef0: 6520 696e 2065 6e75 6d65 7261 7465 286e  e in enumerate(n
+00020f00: 6f64 6573 293a 0a20 2020 2020 2020 2020  odes):.         
+00020f10: 2020 2020 2020 2020 2020 2061 7265 6e61             arena
+00020f20: 735f 6265 7477 6565 6e6e 6573 735b 6e6f  s_betweenness[no
+00020f30: 6465 5d20 3d20 636f 6d70 6f6e 656e 745f  de] = component_
+00020f40: 6265 7477 6565 6e6e 6573 735b 6a5d 0a0a  betweenness[j]..
+00020f50: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00020f60: 7369 6c65 6e63 655f 6c65 7665 6c20 3c3d  silence_level <=
+00020f70: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00020f80: 7072 696e 7428 222e 2e2e 746f 6f6b 222c  print("...took",
+00020f90: 2074 696d 652e 7469 6d65 2829 2d74 302c   time.time()-t0,
+00020fa0: 2022 7365 636f 6e64 7322 290a 0a20 2020   "seconds")..   
+00020fb0: 2020 2020 2072 6574 7572 6e20 6172 656e       return aren
+00020fc0: 6173 5f62 6574 7765 656e 6e65 7373 0a0a  as_betweenness..
+00020fd0: 2020 2020 2320 7061 7261 6c6c 656c 697a      # paralleliz
+00020fe0: 6564 206d 6169 6e20 6c6f 6f70 0a20 2020  ed main loop.   
+00020ff0: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+00021000: 2020 2064 6566 205f 6d70 695f 6e73 695f     def _mpi_nsi_
+00021010: 6172 656e 6173 5f62 6574 7765 656e 6e65  arenas_betweenne
+00021020: 7373 280a 2020 2020 2020 2020 2020 2020  ss(.            
+00021030: 4e2c 2073 705f 502c 2074 6869 735f 4170  N, sp_P, this_Ap
+00021040: 6c75 732c 2077 2c20 7468 6973 5f77 2c20  lus, w, this_w, 
+00021050: 7374 6172 745f 692c 2065 6e64 5f69 2c0a  start_i, end_i,.
+00021060: 2020 2020 2020 2020 2020 2020 6578 636c              excl
+00021070: 7564 655f 6e65 6967 6862 6f72 732c 2073  ude_neighbors, s
+00021080: 746f 7070 696e 675f 6d6f 6465 2c20 7468  topping_mode, th
+00021090: 6973 5f74 7769 6e6e 6573 7329 3a0a 2020  is_twinness):.  
+000210a0: 2020 2020 2020 6572 726f 725f 6d65 7373        error_mess
+000210b0: 6167 652c 2072 6573 756c 7420 3d20 2727  age, result = ''
+000210c0: 2c20 4e6f 6e65 0a20 2020 2020 2020 2074  , None.        t
+000210d0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+000210e0: 636f 6d70 6f6e 656e 745f 6265 7477 6565  component_betwee
+000210f0: 6e6e 6573 7320 3d20 6e70 2e7a 6572 6f73  nness = np.zeros
+00021100: 284e 290a 2020 2020 2020 2020 2020 2020  (N).            
+00021110: 666f 7220 6920 696e 2072 616e 6765 2873  for i in range(s
+00021120: 7461 7274 5f69 2c20 656e 645f 6929 3a0a  tart_i, end_i):.
+00021130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021140: 2320 466f 7220 6920 616e 6420 6561 6368  # For i and each
+00021150: 206e 6569 6768 626f 7572 206f 6620 6974   neighbour of it
+00021160: 2c20 6d6f 6469 6679 2074 6865 2063 6f72  , modify the cor
+00021170: 7265 7370 6f6e 6469 6e67 2072 6f77 0a20  responding row. 
+00021180: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00021190: 206f 6620 5020 746f 2061 6363 6f75 6e74   of P to account
+000211a0: 2066 6f72 2074 6865 2061 6273 6f72 7074   for the absorpt
+000211b0: 696f 6e20 6f66 2072 616e 646f 6d20 7761  ion of random wa
+000211c0: 6c6b 6572 7320 6174 2074 6865 6972 0a20  lkers at their. 
+000211d0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000211e0: 2064 6573 7469 6e61 7469 6f6e 0a20 2020   destination.   
+000211f0: 2020 2020 2020 2020 2020 2020 2073 705f               sp_
+00021200: 5069 203d 2073 705f 502e 636f 7079 2829  Pi = sp_P.copy()
+00021210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00021220: 2041 706c 7573 5f69 203d 2074 6869 735f   Aplus_i = this_
+00021230: 4170 6c75 735b 692d 7374 6172 745f 692c  Aplus[i-start_i,
+00021240: 203a 5d0a 2020 2020 2020 2020 2020 2020   :].            
+00021250: 2020 2020 7570 6461 7465 5f6b 6579 7320      update_keys 
+00021260: 3d20 5b6b 2066 6f72 206b 2069 6e20 7370  = [k for k in sp
+00021270: 5f50 692e 6b65 7973 2829 2069 6620 4170  _Pi.keys() if Ap
+00021280: 6c75 735f 695b 6b5b 305d 5d20 3d3d 2031  lus_i[k[0]] == 1
+00021290: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000212a0: 2020 6966 2073 746f 7070 696e 675f 6d6f    if stopping_mo
+000212b0: 6465 203d 3d20 2274 7769 6e6e 6573 7322  de == "twinness"
+000212c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000212d0: 2020 2020 2020 7477 696e 6e65 7373 5f69        twinness_i
+000212e0: 203d 2074 6869 735f 7477 696e 6e65 7373   = this_twinness
+000212f0: 5b69 2d73 7461 7274 5f69 2c20 3a5d 0a20  [i-start_i, :]. 
+00021300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021310: 2020 2075 7064 6174 655f 7661 6c73 203d     update_vals =
+00021320: 205b 7370 5f50 695b 6b5d 202a 2028 312e   [sp_Pi[k] * (1.
+00021330: 3020 2d20 7477 696e 6e65 7373 5f69 5b6b  0 - twinness_i[k
+00021340: 5b30 5d5d 290a 2020 2020 2020 2020 2020  [0]]).          
+00021350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021360: 2020 2020 2020 2020 2066 6f72 206b 2069           for k i
+00021370: 6e20 7570 6461 7465 5f6b 6579 735d 0a20  n update_keys]. 
+00021380: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00021390: 6c73 653a 2020 2320 226e 6569 6768 626f  lse:  # "neighbo
+000213a0: 7273 220a 2020 2020 2020 2020 2020 2020  rs".            
+000213b0: 2020 2020 2020 2020 7570 6461 7465 5f76          update_v
+000213c0: 616c 7320 3d20 6e70 2e7a 6572 6f73 286c  als = np.zeros(l
+000213d0: 656e 2875 7064 6174 655f 6b65 7973 2929  en(update_keys))
+000213e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000213f0: 2075 7064 6174 655f 726f 7773 2c20 7570   update_rows, up
+00021400: 6461 7465 5f63 6f6c 7320 3d20 7a69 7028  date_cols = zip(
+00021410: 2a75 7064 6174 655f 6b65 7973 290a 2020  *update_keys).  
+00021420: 2020 2020 2020 2020 2020 2020 2020 7370                sp
+00021430: 5f50 695b 7570 6461 7465 5f72 6f77 732c  _Pi[update_rows,
+00021440: 2075 7064 6174 655f 636f 6c73 5d20 3d20   update_cols] = 
+00021450: 7570 6461 7465 5f76 616c 730a 2020 2020  update_vals.    
+00021460: 2020 2020 2020 2020 2020 2020 7370 5f50              sp_P
+00021470: 6920 3d20 7370 5f50 692e 746f 6373 6328  i = sp_Pi.tocsc(
+00021480: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00021490: 2020 7370 5f50 692e 656c 696d 696e 6174    sp_Pi.eliminat
+000214a0: 655f 7a65 726f 7328 290a 0a20 2020 2020  e_zeros()..     
+000214b0: 2020 2020 2020 2020 2020 2023 2073 6f6c             # sol
+000214c0: 7665 2028 3120 2d20 7370 5f50 6929 202a  ve (1 - sp_Pi) *
+000214d0: 2056 203d 2073 705f 5069 0a20 2020 2020   V = sp_Pi.     
+000214e0: 2020 2020 2020 2020 2020 2056 203d 2073             V = s
+000214f0: 706c 7528 7370 2e69 6465 6e74 6974 7928  plu(sp.identity(
+00021500: 4e2c 2066 6f72 6d61 743d 2763 7363 2729  N, format='csc')
+00021510: 202d 2073 705f 5069 292e 736f 6c76 6528   - sp_Pi).solve(
+00021520: 7370 5f50 692e 4129 0a0a 2020 2020 2020  sp_Pi.A)..      
+00021530: 2020 2020 2020 2020 2020 6966 2065 7863            if exc
+00021540: 6c75 6465 5f6e 6569 6768 626f 7273 3a0a  lude_neighbors:.
+00021550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021560: 2020 2020 2320 666f 7220 7468 6520 7265      # for the re
+00021570: 7375 6c74 2c20 7765 2075 7365 206f 6e6c  sult, we use onl
+00021580: 7920 7468 6f73 6520 7461 7267 6574 7320  y those targets 
+00021590: 6920 7768 6963 6820 6172 6520 6e6f 740a  i which are not.
 000215a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000215b0: 2020 2020 704d 6b20 3d20 704d 6174 7269      pMk = pMatri
-000215c0: 782a 286d 6173 6b2e 7265 7368 6170 6528  x*(mask.reshape(
-000215d0: 286e 4e6f 6465 732c 2031 2929 290a 0a20  (nNodes, 1))).. 
+000215b0: 2020 2020 2320 6e65 6967 6862 6f75 7265      # neighboure
+000215c0: 6420 746f 206f 7572 206e 6f64 6520 6f66  d to our node of
+000215d0: 2069 6e74 6572 6573 7420 6a0a 2020 2020   interest j.    
 000215e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000215f0: 2020 2023 2020 4361 6c63 756c 6174 6520     #  Calculate 
-00021600: 7468 6520 625e 6b20 6d61 7472 6978 0a20  the b^k matrix. 
-00021610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021620: 2020 2062 4d61 7472 6978 203d 206e 702e     bMatrix = np.
-00021630: 646f 7428 6e70 2e6c 696e 616c 672e 696e  dot(np.linalg.in
-00021640: 7628 4964 656e 7469 7479 2d70 4d6b 292c  v(Identity-pMk),
-00021650: 2070 4d6b 290a 0a20 2020 2020 2020 2020   pMk)..         
-00021660: 2020 2020 2020 2020 2020 2023 2020 5065             #  Pe
-00021670: 7266 6f72 6d20 7468 6520 7375 6d6d 6174  rform the summat
-00021680: 696f 6e20 6f76 6572 2073 6f75 7263 6520  ion over source 
-00021690: 6e6f 6465 2069 0a20 2020 2020 2020 2020  node i.         
-000216a0: 2020 2020 2020 2020 2020 2072 7762 202b             rwb +
-000216b0: 3d20 6177 5b6b 5d20 2a20 6e70 2e64 6f74  = aw[k] * np.dot
-000216c0: 2861 772e 7265 7368 6170 6528 2831 2c20  (aw.reshape((1, 
-000216d0: 7365 6c66 2e4e 2929 2c0a 2020 2020 2020  self.N)),.      
-000216e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000216f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021700: 2020 2020 624d 6174 7269 7829 2e66 6c61      bMatrix).fla
-00021710: 7474 656e 2829 202a 206d 6173 6b0a 0a20  tten() * mask.. 
-00021720: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00021730: 7762 202f 3d20 6177 0a0a 2020 2020 2020  wb /= aw..      
-00021740: 2020 2020 2020 2020 2020 2320 2043 6f70            #  Cop
-00021750: 7920 7265 7375 6c74 7320 696e 746f 2072  y results into r
-00021760: 616e 646f 6d57 616c 6b42 6574 7765 656e  andomWalkBetween
-00021770: 6e65 7373 4172 7261 7920 6174 2074 6865  nessArray at the
-00021780: 2063 6f72 7265 6374 0a20 2020 2020 2020   correct.       
-00021790: 2020 2020 2020 2020 2023 2020 706f 7369           #  posi
-000217a0: 7469 6f6e 730a 2020 2020 2020 2020 2020  tions.          
-000217b0: 2020 2020 2020 666f 7220 6a2c 2076 7320        for j, vs 
-000217c0: 696e 2065 6e75 6d65 7261 7465 2876 6572  in enumerate(ver
-000217d0: 7465 784c 6973 7429 3a0a 2020 2020 2020  texList):.      
-000217e0: 2020 2020 2020 2020 2020 2020 2020 6177                aw
-000217f0: 5261 6e64 6f6d 5761 6c6b 4265 7477 6565  RandomWalkBetwee
-00021800: 6e6e 6573 735b 7673 5d20 3d20 7277 625b  nness[vs] = rwb[
-00021810: 6a5d 0a0a 2020 2020 2020 2020 6966 2073  j]..        if s
-00021820: 656c 662e 7369 6c65 6e63 655f 6c65 7665  elf.silence_leve
-00021830: 6c20 3c3d 2031 3a0a 2020 2020 2020 2020  l <= 1:.        
-00021840: 2020 2020 7072 696e 7428 222e 2e2e 746f      print("...to
-00021850: 6f6b 222c 2074 696d 652e 7469 6d65 2829  ok", time.time()
-00021860: 2d74 302c 2022 7365 636f 6e64 7322 290a  -t0, "seconds").
-00021870: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00021880: 6177 5261 6e64 6f6d 5761 6c6b 4265 7477  awRandomWalkBetw
-00021890: 6565 6e6e 6573 730a 0a20 2020 2023 2070  eenness..    # p
-000218a0: 6172 616c 6c65 6c69 7a65 6420 6d61 696e  arallelized main
-000218b0: 206c 6f6f 700a 2020 2020 4073 7461 7469   loop.    @stati
-000218c0: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
-000218d0: 5f6d 7069 5f6e 7369 5f61 7265 6e61 735f  _mpi_nsi_arenas_
-000218e0: 6265 7477 6565 6e6e 6573 7328 0a20 2020  betweenness(.   
-000218f0: 2020 2020 2020 2020 204e 2c20 7370 5f50           N, sp_P
-00021900: 2c20 7468 6973 5f41 706c 7573 2c20 772c  , this_Aplus, w,
-00021910: 2074 6869 735f 772c 2073 7461 7274 5f69   this_w, start_i
-00021920: 2c20 656e 645f 692c 0a20 2020 2020 2020  , end_i,.       
-00021930: 2020 2020 2065 7863 6c75 6465 5f6e 6569       exclude_nei
-00021940: 6768 626f 7273 2c20 7374 6f70 7069 6e67  ghbors, stopping
-00021950: 5f6d 6f64 652c 2074 6869 735f 7477 696e  _mode, this_twin
-00021960: 6e65 7373 293a 0a20 2020 2020 2020 2065  ness):.        e
-00021970: 7272 6f72 5f6d 6573 7361 6765 2c20 7265  rror_message, re
-00021980: 7375 6c74 203d 2027 272c 204e 6f6e 650a  sult = '', None.
-00021990: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-000219a0: 2020 2020 2020 2020 2063 6f6d 706f 6e65           compone
-000219b0: 6e74 5f62 6574 7765 656e 6e65 7373 203d  nt_betweenness =
-000219c0: 206e 702e 7a65 726f 7328 4e29 0a20 2020   np.zeros(N).   
-000219d0: 2020 2020 2020 2020 2066 6f72 2069 2069           for i i
-000219e0: 6e20 7261 6e67 6528 7374 6172 745f 692c  n range(start_i,
-000219f0: 2065 6e64 5f69 293a 0a20 2020 2020 2020   end_i):.       
-00021a00: 2020 2020 2020 2020 2023 2046 6f72 2069           # For i
-00021a10: 2061 6e64 2065 6163 6820 6e65 6967 6862   and each neighb
-00021a20: 6f75 7220 6f66 2069 742c 206d 6f64 6966  our of it, modif
-00021a30: 7920 7468 6520 636f 7272 6573 706f 6e64  y the correspond
-00021a40: 696e 6720 726f 770a 2020 2020 2020 2020  ing row.        
-00021a50: 2020 2020 2020 2020 2320 6f66 2050 2074          # of P t
-00021a60: 6f20 6163 636f 756e 7420 666f 7220 7468  o account for th
-00021a70: 6520 6162 736f 7270 7469 6f6e 206f 6620  e absorption of 
-00021a80: 7261 6e64 6f6d 2077 616c 6b65 7273 2061  random walkers a
-00021a90: 7420 7468 6569 720a 2020 2020 2020 2020  t their.        
-00021aa0: 2020 2020 2020 2020 2320 6465 7374 696e          # destin
-00021ab0: 6174 696f 6e0a 2020 2020 2020 2020 2020  ation.          
-00021ac0: 2020 2020 2020 7370 5f50 6920 3d20 7370        sp_Pi = sp
-00021ad0: 5f50 2e63 6f70 7928 290a 2020 2020 2020  _P.copy().      
-00021ae0: 2020 2020 2020 2020 2020 4170 6c75 735f            Aplus_
-00021af0: 6920 3d20 7468 6973 5f41 706c 7573 5b69  i = this_Aplus[i
-00021b00: 2d73 7461 7274 5f69 2c20 3a5d 0a20 2020  -start_i, :].   
-00021b10: 2020 2020 2020 2020 2020 2020 2075 7064               upd
-00021b20: 6174 655f 6b65 7973 203d 205b 6b20 666f  ate_keys = [k fo
-00021b30: 7220 6b20 696e 2073 705f 5069 2e6b 6579  r k in sp_Pi.key
-00021b40: 7328 2920 6966 2041 706c 7573 5f69 5b6b  s() if Aplus_i[k
-00021b50: 5b30 5d5d 203d 3d20 315d 0a20 2020 2020  [0]] == 1].     
-00021b60: 2020 2020 2020 2020 2020 2069 6620 7374             if st
-00021b70: 6f70 7069 6e67 5f6d 6f64 6520 3d3d 2022  opping_mode == "
-00021b80: 7477 696e 6e65 7373 223a 0a20 2020 2020  twinness":.     
-00021b90: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00021ba0: 7769 6e6e 6573 735f 6920 3d20 7468 6973  winness_i = this
-00021bb0: 5f74 7769 6e6e 6573 735b 692d 7374 6172  _twinness[i-star
-00021bc0: 745f 692c 203a 5d0a 2020 2020 2020 2020  t_i, :].        
-00021bd0: 2020 2020 2020 2020 2020 2020 7570 6461              upda
-00021be0: 7465 5f76 616c 7320 3d20 5b73 705f 5069  te_vals = [sp_Pi
-00021bf0: 5b6b 5d20 2a20 2831 2e30 202d 2074 7769  [k] * (1.0 - twi
-00021c00: 6e6e 6573 735f 695b 6b5b 305d 5d29 0a20  nness_i[k[0]]). 
-00021c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021c30: 2020 666f 7220 6b20 696e 2075 7064 6174    for k in updat
-00021c40: 655f 6b65 7973 5d0a 2020 2020 2020 2020  e_keys].        
-00021c50: 2020 2020 2020 2020 656c 7365 3a20 2023          else:  #
-00021c60: 2022 6e65 6967 6862 6f72 7322 0a20 2020   "neighbors".   
-00021c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021c80: 2075 7064 6174 655f 7661 6c73 203d 206e   update_vals = n
-00021c90: 702e 7a65 726f 7328 6c65 6e28 7570 6461  p.zeros(len(upda
-00021ca0: 7465 5f6b 6579 7329 290a 2020 2020 2020  te_keys)).      
-00021cb0: 2020 2020 2020 2020 2020 7570 6461 7465            update
-00021cc0: 5f72 6f77 732c 2075 7064 6174 655f 636f  _rows, update_co
-00021cd0: 6c73 203d 207a 6970 282a 7570 6461 7465  ls = zip(*update
-00021ce0: 5f6b 6579 7329 0a20 2020 2020 2020 2020  _keys).         
-00021cf0: 2020 2020 2020 2073 705f 5069 5b75 7064         sp_Pi[upd
-00021d00: 6174 655f 726f 7773 2c20 7570 6461 7465  ate_rows, update
-00021d10: 5f63 6f6c 735d 203d 2075 7064 6174 655f  _cols] = update_
-00021d20: 7661 6c73 0a20 2020 2020 2020 2020 2020  vals.           
-00021d30: 2020 2020 2073 705f 5069 203d 2073 705f       sp_Pi = sp_
-00021d40: 5069 2e74 6f63 7363 2829 0a20 2020 2020  Pi.tocsc().     
-00021d50: 2020 2020 2020 2020 2020 2073 705f 5069             sp_Pi
-00021d60: 2e65 6c69 6d69 6e61 7465 5f7a 6572 6f73  .eliminate_zeros
-00021d70: 2829 0a0a 2020 2020 2020 2020 2020 2020  ()..            
-00021d80: 2020 2020 2320 736f 6c76 6520 2831 202d      # solve (1 -
-00021d90: 2073 705f 5069 2920 2a20 5620 3d20 7370   sp_Pi) * V = sp
-00021da0: 5f50 690a 2020 2020 2020 2020 2020 2020  _Pi.            
-00021db0: 2020 2020 5620 3d20 7370 6c75 2873 702e      V = splu(sp.
-00021dc0: 6964 656e 7469 7479 284e 2c20 666f 726d  identity(N, form
-00021dd0: 6174 3d27 6373 6327 2920 2d20 7370 5f50  at='csc') - sp_P
-00021de0: 6929 2e73 6f6c 7665 2873 705f 5069 2e41  i).solve(sp_Pi.A
-00021df0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-00021e00: 2020 2069 6620 6578 636c 7564 655f 6e65     if exclude_ne
-00021e10: 6967 6862 6f72 733a 0a20 2020 2020 2020  ighbors:.       
-00021e20: 2020 2020 2020 2020 2020 2020 2023 2066               # f
-00021e30: 6f72 2074 6865 2072 6573 756c 742c 2077  or the result, w
-00021e40: 6520 7573 6520 6f6e 6c79 2074 686f 7365  e use only those
-00021e50: 2074 6172 6765 7473 2069 2077 6869 6368   targets i which
-00021e60: 2061 7265 206e 6f74 0a20 2020 2020 2020   are not.       
-00021e70: 2020 2020 2020 2020 2020 2020 2023 206e               # n
-00021e80: 6569 6768 626f 7572 6564 2074 6f20 6f75  eighboured to ou
-00021e90: 7220 6e6f 6465 206f 6620 696e 7465 7265  r node of intere
-00021ea0: 7374 206a 0a20 2020 2020 2020 2020 2020  st j.           
-00021eb0: 2020 2020 2020 2020 2042 5f73 756d 203d           B_sum =
-00021ec0: 2077 2e64 6f74 2828 562e 5420 2a20 2831   w.dot((V.T * (1
-00021ed0: 202d 2041 706c 7573 5f69 2929 2e54 2920   - Aplus_i)).T) 
-00021ee0: 2a20 2831 202d 2041 706c 7573 5f69 290a  * (1 - Aplus_i).
-00021ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021f00: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00021f10: 2020 2020 2020 2020 2020 425f 7375 6d20            B_sum 
-00021f20: 3d20 772e 646f 7428 5629 0a20 2020 2020  = w.dot(V).     
-00021f30: 2020 2020 2020 2020 2020 2063 6f6d 706f             compo
-00021f40: 6e65 6e74 5f62 6574 7765 656e 6e65 7373  nent_betweenness
-00021f50: 202b 3d20 7468 6973 5f77 5b69 2d73 7461   += this_w[i-sta
-00021f60: 7274 5f69 5d20 2a20 425f 7375 6d0a 0a20  rt_i] * B_sum.. 
-00021f70: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-00021f80: 7420 3d20 636f 6d70 6f6e 656e 745f 6265  t = component_be
-00021f90: 7477 6565 6e6e 6573 732c 2073 7461 7274  tweenness, start
-00021fa0: 5f69 2c20 656e 645f 690a 2020 2020 2020  _i, end_i.      
-00021fb0: 2020 6578 6365 7074 2052 756e 7469 6d65    except Runtime
-00021fc0: 4572 726f 723a 0a20 2020 2020 2020 2020  Error:.         
-00021fd0: 2020 2065 203d 2073 7973 2e65 7863 5f69     e = sys.exc_i
-00021fe0: 6e66 6f28 290a 2020 2020 2020 2020 2020  nfo().          
-00021ff0: 2020 6572 726f 725f 6d65 7373 6167 6520    error_message 
-00022000: 3d20 2873 7472 2865 5b30 5d29 202b 2027  = (str(e[0]) + '
-00022010: 5c6e 2720 2b20 7374 7228 655b 315d 2929  \n' + str(e[1]))
-00022020: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00022030: 2065 7272 6f72 5f6d 6573 7361 6765 2c20   error_message, 
-00022040: 7265 7375 6c74 0a0a 2020 2020 2320 544f  result..    # TO
-00022050: 444f 3a20 7365 7474 6c65 2066 6f72 2073  DO: settle for s
-00022060: 6f6d 6520 7375 6974 6162 6c65 2064 6566  ome suitable def
-00022070: 6175 6c74 730a 2020 2020 6465 6620 6e73  aults.    def ns
-00022080: 695f 6172 656e 6173 5f62 6574 7765 656e  i_arenas_between
-00022090: 6e65 7373 2873 656c 662c 2065 7863 6c75  ness(self, exclu
-000220a0: 6465 5f6e 6569 6768 626f 7273 3d54 7275  de_neighbors=Tru
-000220b0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-000220c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000220d0: 2020 7374 6f70 7069 6e67 5f6d 6f64 653d    stopping_mode=
-000220e0: 226e 6569 6768 626f 7273 2229 3a0a 2020  "neighbors"):.  
-000220f0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00022100: 2020 466f 7220 6561 6368 206e 6f64 652c    For each node,
-00022110: 2072 6574 7572 6e20 6974 7320 6e2e 732e   return its n.s.
-00022120: 692e 2041 7265 6e61 732d 7479 7065 2072  i. Arenas-type r
-00022130: 616e 646f 6d20 7761 6c6b 2062 6574 7765  andom walk betwe
-00022140: 656e 6e65 7373 2e0a 0a20 2020 2020 2020  enness...       
-00022150: 2054 6869 7320 6d65 6173 7572 6573 2068   This measures h
-00022160: 6f77 206f 6674 656e 2061 2072 616e 646f  ow often a rando
-00022170: 6d20 7761 6c6b 2073 6561 7263 6820 666f  m walk search fo
-00022180: 7220 6120 7261 6e64 6f6d 2074 6172 6765  r a random targe
-00022190: 7420 6e6f 6465 0a20 2020 2020 2020 2066  t node.        f
-000221a0: 726f 6d20 6120 7261 6e64 6f6d 2073 6f75  rom a random sou
-000221b0: 7263 6520 6e6f 6465 2069 7320 6578 7065  rce node is expe
-000221c0: 6374 6564 2074 6f20 7061 7373 2074 6869  cted to pass thi
-000221d0: 7320 6e6f 6465 2e20 2873 6565 0a20 2020  s node. (see.   
-000221e0: 2020 2020 205b 4172 656e 6173 3230 3033       [Arenas2003
-000221f0: 5d5f 290a 0a20 2020 2020 2020 202a 2a45  ]_)..        **E
-00022200: 7861 6d70 6c65 733a 2a2a 0a0a 2020 2020  xamples:**..    
-00022210: 2020 2020 3e3e 3e20 6e65 7420 3d20 4e65      >>> net = Ne
-00022220: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-00022230: 6574 776f 726b 2829 0a20 2020 2020 2020  etwork().       
-00022240: 203e 3e3e 2072 286e 6574 2e6e 7369 5f61   >>> r(net.nsi_a
-00022250: 7265 6e61 735f 6265 7477 6565 6e6e 6573  renas_betweennes
-00022260: 7328 2929 0a20 2020 2020 2020 2043 616c  s()).        Cal
-00022270: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
-00022280: 4172 656e 6173 2d74 7970 6520 7261 6e64  Arenas-type rand
-00022290: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
-000222a0: 6573 732e 2e2e 0a20 2020 2020 2020 2020  ess....         
-000222b0: 2020 2867 6961 6e74 2063 6f6d 706f 6e65    (giant compone
-000222c0: 6e74 2073 697a 653a 2036 2028 312e 3029  nt size: 6 (1.0)
-000222d0: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-000222e0: 6174 696e 6720 6e2e 732e 692e 2064 6567  ating n.s.i. deg
-000222f0: 7265 652e 2e2e 0a20 2020 2020 2020 2061  ree....        a
-00022300: 7272 6179 285b 2032 302e 3538 3134 2c20  rray([ 20.5814, 
-00022310: 3239 2e32 3130 332c 2032 372e 3030 3735  29.2103, 27.0075
-00022320: 2c20 3139 2e35 3433 342c 2032 352e 3238  , 19.5434, 25.28
-00022330: 3439 2c20 3234 2e38 3438 335d 290a 2020  49, 24.8483]).  
-00022340: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
-00022350: 7370 6c69 7474 6564 5f63 6f70 7928 292e  splitted_copy().
-00022360: 6e73 695f 6172 656e 6173 5f62 6574 7765  nsi_arenas_betwe
-00022370: 656e 6e65 7373 2829 290a 2020 2020 2020  enness()).      
-00022380: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
-00022390: 732e 692e 2041 7265 6e61 732d 7479 7065  s.i. Arenas-type
-000223a0: 2072 616e 646f 6d20 7761 6c6b 2062 6574   random walk bet
-000223b0: 7765 656e 6e65 7373 2e2e 2e0a 2020 2020  weenness....    
-000223c0: 2020 2020 2020 2028 6769 616e 7420 636f         (giant co
-000223d0: 6d70 6f6e 656e 7420 7369 7a65 3a20 3720  mponent size: 7 
-000223e0: 2831 2e30 2929 0a20 2020 2020 2020 2043  (1.0)).        C
-000223f0: 616c 6375 6c61 7469 6e67 206e 2e73 2e69  alculating n.s.i
-00022400: 2e20 6465 6772 6565 2e2e 2e0a 2020 2020  . degree....    
-00022410: 2020 2020 6172 7261 7928 5b20 3230 2e35      array([ 20.5
-00022420: 3831 342c 2032 392e 3231 3033 2c20 3237  814, 29.2103, 27
-00022430: 2e30 3037 352c 2031 392e 3534 3334 2c20  .0075, 19.5434, 
-00022440: 3235 2e32 3834 392c 2032 342e 3834 3833  25.2849, 24.8483
-00022450: 2c20 3234 2e38 3438 335d 290a 2020 2020  , 24.8483]).    
-00022460: 2020 2020 3e3e 3e20 7228 6e65 742e 6e73      >>> r(net.ns
-00022470: 695f 6172 656e 6173 5f62 6574 7765 656e  i_arenas_between
-00022480: 6e65 7373 2865 7863 6c75 6465 5f6e 6569  ness(exclude_nei
-00022490: 6768 626f 7273 3d46 616c 7365 2929 0a20  ghbors=False)). 
-000224a0: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-000224b0: 6e67 206e 2e73 2e69 2e20 4172 656e 6173  ng n.s.i. Arenas
-000224c0: 2d74 7970 6520 7261 6e64 6f6d 2077 616c  -type random wal
-000224d0: 6b20 6265 7477 6565 6e6e 6573 732e 2e2e  k betweenness...
-000224e0: 0a20 2020 2020 2020 2020 2020 2867 6961  .           (gia
-000224f0: 6e74 2063 6f6d 706f 6e65 6e74 2073 697a  nt component siz
-00022500: 653a 2036 2028 312e 3029 290a 2020 2020  e: 6 (1.0)).    
-00022510: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-00022520: 6e2e 732e 692e 2064 6567 7265 652e 2e2e  n.s.i. degree...
-00022530: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
-00022540: 2034 342e 3533 3531 2c20 3337 2e34 3035   44.5351, 37.405
-00022550: 382c 2032 372e 3030 3735 2c20 3231 2e37  8, 27.0075, 21.7
-00022560: 3733 362c 2033 312e 3332 3536 2c20 3234  736, 31.3256, 24
-00022570: 2e38 3438 335d 290a 2020 2020 2020 2020  .8483]).        
-00022580: 3e3e 3e20 7228 6e65 742e 6e73 695f 6172  >>> r(net.nsi_ar
-00022590: 656e 6173 5f62 6574 7765 656e 6e65 7373  enas_betweenness
-000225a0: 2873 746f 7070 696e 675f 6d6f 6465 3d22  (stopping_mode="
-000225b0: 7477 696e 6e65 7373 2229 290a 2020 2020  twinness")).    
-000225c0: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
-000225d0: 6e2e 732e 692e 2041 7265 6e61 732d 7479  n.s.i. Arenas-ty
-000225e0: 7065 2072 616e 646f 6d20 7761 6c6b 2062  pe random walk b
-000225f0: 6574 7765 656e 6e65 7373 2e2e 2e0a 2020  etweenness....  
-00022600: 2020 2020 2020 2020 2028 6769 616e 7420           (giant 
-00022610: 636f 6d70 6f6e 656e 7420 7369 7a65 3a20  component size: 
-00022620: 3620 2831 2e30 2929 0a20 2020 2020 2020  6 (1.0)).       
-00022630: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
-00022640: 2e69 2e20 6465 6772 6565 2e2e 2e0a 2020  .i. degree....  
-00022650: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-00022660: 6720 6e2e 732e 692e 2064 6567 7265 652e  g n.s.i. degree.
-00022670: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
-00022680: 285b 2032 322e 3631 3533 2c20 3431 2e32  ([ 22.6153, 41.2
-00022690: 3331 342c 2033 382e 3634 3131 2c20 3238  314, 38.6411, 28
-000226a0: 2e36 3139 352c 2033 382e 3538 3234 2c20  .6195, 38.5824, 
-000226b0: 3330 2e32 3939 345d 290a 0a20 2020 2020  30.2994])..     
-000226c0: 2020 2061 7320 636f 6d70 6172 6564 2074     as compared t
-000226d0: 6f20 6974 7320 756e 7765 6967 6874 6564  o its unweighted
-000226e0: 2076 6572 7369 6f6e 3a0a 0a20 2020 2020   version:..     
-000226f0: 2020 203e 3e3e 206e 6574 203d 204e 6574     >>> net = Net
-00022700: 776f 726b 2e53 6d61 6c6c 5465 7374 4e65  work.SmallTestNe
-00022710: 7477 6f72 6b28 290a 2020 2020 2020 2020  twork().        
-00022720: 3e3e 3e20 7228 6e65 742e 6172 656e 6173  >>> r(net.arenas
-00022730: 5f62 6574 7765 656e 6e65 7373 2829 290a  _betweenness()).
-00022740: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-00022750: 696e 6720 4172 656e 6173 2d74 7970 6520  ing Arenas-type 
-00022760: 7261 6e64 6f6d 2077 616c 6b20 6265 7477  random walk betw
-00022770: 6565 6e6e 6573 732e 2e2e 0a20 2020 2020  eenness....     
-00022780: 2020 2020 2020 2867 6961 6e74 2063 6f6d        (giant com
-00022790: 706f 6e65 6e74 2073 697a 653a 2036 2028  ponent size: 6 (
-000227a0: 312e 3029 290a 2020 2020 2020 2020 6172  1.0)).        ar
-000227b0: 7261 7928 5b20 3530 2e31 3831 382c 2035  ray([ 50.1818, 5
-000227c0: 302e 3138 3138 2c20 3333 2e34 3534 352c  0.1818, 33.4545,
-000227d0: 2033 332e 3435 3435 2c20 3530 2e31 3831   33.4545, 50.181
-000227e0: 382c 2031 362e 3732 3733 5d29 0a20 2020  8, 16.7273]).   
-000227f0: 2020 2020 203e 3e3e 2072 286e 6574 2e73       >>> r(net.s
-00022800: 706c 6974 7465 645f 636f 7079 2829 2e61  plitted_copy().a
-00022810: 7265 6e61 735f 6265 7477 6565 6e6e 6573  renas_betweennes
-00022820: 7328 2929 0a20 2020 2020 2020 2043 616c  s()).        Cal
-00022830: 6375 6c61 7469 6e67 2041 7265 6e61 732d  culating Arenas-
-00022840: 7479 7065 2072 616e 646f 6d20 7761 6c6b  type random walk
-00022850: 2062 6574 7765 656e 6e65 7373 2e2e 2e0a   betweenness....
-00022860: 2020 2020 2020 2020 2020 2028 6769 616e             (gian
-00022870: 7420 636f 6d70 6f6e 656e 7420 7369 7a65  t component size
-00022880: 3a20 3720 2831 2e30 2929 0a20 2020 2020  : 7 (1.0)).     
-00022890: 2020 2061 7272 6179 285b 2039 302e 3432     array([ 90.42
-000228a0: 3432 2c20 3637 2e38 3138 322c 2034 352e  42, 67.8182, 45.
-000228b0: 3231 3231 2c20 3435 2e32 3132 312c 2036  2121, 45.2121, 6
-000228c0: 372e 3831 3832 2c20 3435 2e32 3132 312c  7.8182, 45.2121,
-000228d0: 2034 352e 3231 3231 5d29 0a0a 2020 2020   45.2121])..    
-000228e0: 2020 2020 3a61 7267 2062 6f6f 6c20 6578      :arg bool ex
-000228f0: 636c 7564 655f 6e65 6967 6862 6f72 733a  clude_neighbors:
-00022900: 2049 6e64 6963 6174 6573 2077 6865 7468   Indicates wheth
-00022910: 6572 2074 6f20 7573 6520 6f6e 6c79 2073  er to use only s
-00022920: 6f75 7263 6520 616e 640a 2020 2020 2020  ource and.      
-00022930: 2020 2020 2020 7461 7267 6574 206e 6f64        target nod
-00022940: 6573 2074 6861 7420 6172 6520 6e6f 7420  es that are not 
-00022950: 6c69 6e6b 6564 2074 6f20 7468 6520 6e6f  linked to the no
-00022960: 6465 206f 6620 696e 7465 7265 7374 2e0a  de of interest..
-00022970: 2020 2020 2020 2020 2020 2020 2844 6566              (Def
-00022980: 6175 6c74 3a20 5472 7565 290a 2020 2020  ault: True).    
-00022990: 2020 2020 3a61 7267 2073 7472 2073 746f      :arg str sto
-000229a0: 7070 696e 675f 6d6f 6465 3a20 5370 6563  pping_mode: Spec
-000229b0: 6966 6965 7320 7768 656e 2074 6865 2072  ifies when the r
-000229c0: 616e 646f 6d20 7761 6c6b 2069 7320 7374  andom walk is st
-000229d0: 6f70 7065 642e 2049 660a 2020 2020 2020  opped. If.      
-000229e0: 2020 2020 2020 226e 6569 6768 626f 7273        "neighbors
-000229f0: 222c 2074 6865 2077 616c 6b20 7374 6f70  ", the walk stop
-00022a00: 7320 6173 2073 6f6f 6e20 6173 2069 7420  s as soon as it 
-00022a10: 7265 6163 6865 7320 6120 6e65 6967 6862  reaches a neighb
-00022a20: 6f72 206f 6620 7468 650a 2020 2020 2020  or of the.      
-00022a30: 2020 2020 2020 7461 7267 6574 206e 6f64        target nod
-00022a40: 652e 2049 6620 2274 7769 6e6e 6e65 7373  e. If "twinnness
-00022a50: 222c 2074 6865 2073 746f 7070 696e 6720  ", the stopping 
-00022a60: 7072 6f62 6162 696c 6974 7920 6174 2065  probability at e
-00022a70: 6163 6820 7374 6570 0a20 2020 2020 2020  ach step.       
-00022a80: 2020 2020 2069 7320 7468 6520 7477 696e       is the twin
-00022a90: 6e6e 6573 7320 6f66 2074 6865 2063 7572  nness of the cur
-00022aa0: 7265 6e74 2061 6e64 2074 6172 6765 7420  rent and target 
-00022ab0: 6e6f 6465 7320 6173 2067 6976 656e 2062  nodes as given b
-00022ac0: 790a 2020 2020 2020 2020 2020 2020 3a6d  y.            :m
-00022ad0: 6574 683a 606e 7369 5f74 7769 6e6e 6573  eth:`nsi_twinnes
-00022ae0: 7328 2960 2e20 2844 6566 6175 6c74 3a20  s()`. (Default: 
-00022af0: 226e 6569 6768 626f 7273 2229 0a20 2020  "neighbors").   
-00022b00: 2020 2020 203a 7274 7970 653a 2031 6420       :rtype: 1d 
-00022b10: 6e75 6d70 7920 6172 7261 7920 5b6e 6f64  numpy array [nod
-00022b20: 655d 206f 6620 666c 6f61 7473 203e 3d20  e] of floats >= 
-00022b30: 300a 2020 2020 2020 2020 2222 220a 2020  0.        """.  
-00022b40: 2020 2020 2020 6966 2073 656c 662e 7369        if self.si
-00022b50: 6c65 6e63 655f 6c65 7665 6c20 3c3d 2031  lence_level <= 1
-00022b60: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-00022b70: 696e 7428 2243 616c 6375 6c61 7469 6e67  int("Calculating
-00022b80: 206e 2e73 2e69 2e20 4172 656e 6173 2d74   n.s.i. Arenas-t
-00022b90: 7970 6520 7261 6e64 6f6d 2077 616c 6b20  ype random walk 
-00022ba0: 6265 7477 6565 6e6e 6573 732e 2e2e 2229  betweenness...")
-00022bb0: 0a0a 2020 2020 2020 2020 7430 203d 2074  ..        t0 = t
-00022bc0: 696d 652e 7469 6d65 2829 0a0a 2020 2020  ime.time()..    
-00022bd0: 2020 2020 2320 2049 6e69 7469 616c 697a      #  Initializ
-00022be0: 6520 7468 6520 6172 7261 7920 746f 2068  e the array to h
-00022bf0: 6f6c 6420 7261 6e64 6f6d 2077 616c 6b20  old random walk 
-00022c00: 6265 7477 6565 6e6e 6573 730a 2020 2020  betweenness.    
-00022c10: 2020 2020 6e73 695f 6172 656e 6173 5f62      nsi_arenas_b
-00022c20: 6574 7765 656e 6e65 7373 203d 206e 702e  etweenness = np.
-00022c30: 7a65 726f 7328 7365 6c66 2e4e 290a 0a20  zeros(self.N).. 
-00022c40: 2020 2020 2020 2023 2020 5261 6e64 6f6d         #  Random
-00022c50: 2077 616c 6b20 6265 7477 6565 6e6e 6573   walk betweennes
-00022c60: 7320 6861 7320 746f 2062 6520 6361 6c63  s has to be calc
-00022c70: 756c 6174 6564 2066 6f72 2065 6163 6820  ulated for each 
-00022c80: 636f 6d70 6f6e 656e 740a 2020 2020 2020  component.      
-00022c90: 2020 2320 2073 6570 6172 6174 656c 792e    #  separately.
-00022ca0: 2054 6865 7265 666f 7265 2067 6574 2064   Therefore get d
-00022cb0: 6966 6665 7265 6e74 2063 6f6d 706f 6e65  ifferent compone
-00022cc0: 6e74 7320 6f66 2074 6865 2067 7261 7068  nts of the graph
-00022cd0: 2066 6972 7374 0a20 2020 2020 2020 2063   first.        c
-00022ce0: 6f6d 706f 6e65 6e74 7320 3d20 7365 6c66  omponents = self
-00022cf0: 2e67 7261 7068 2e63 6c75 7374 6572 7328  .graph.clusters(
-00022d00: 290a 0a20 2020 2020 2020 2023 2020 5072  )..        #  Pr
-00022d10: 696e 7420 6769 616e 7420 636f 6d70 6f6e  int giant compon
-00022d20: 656e 7420 7369 7a65 0a20 2020 2020 2020  ent size.       
-00022d30: 2069 6620 7365 6c66 2e73 696c 656e 6365   if self.silence
-00022d40: 5f6c 6576 656c 203c 3d20 313a 0a20 2020  _level <= 1:.   
-00022d50: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
-00022d60: 2020 2028 6769 616e 7420 636f 6d70 6f6e     (giant compon
-00022d70: 656e 7420 7369 7a65 3a20 220a 2020 2020  ent size: ".    
-00022d80: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-00022d90: 7374 7228 636f 6d70 6f6e 656e 7473 2e67  str(components.g
-00022da0: 6961 6e74 2829 2e76 636f 756e 7428 2929  iant().vcount())
-00022db0: 202b 2022 2028 220a 2020 2020 2020 2020   + " (".        
-00022dc0: 2020 2020 2020 2020 2020 2b20 7374 7228            + str(
-00022dd0: 636f 6d70 6f6e 656e 7473 2e67 6961 6e74  components.giant
-00022de0: 2829 2e76 636f 756e 7428 290a 2020 2020  ().vcount().    
+000215f0: 425f 7375 6d20 3d20 772e 646f 7428 2856  B_sum = w.dot((V
+00021600: 2e54 202a 2028 3120 2d20 4170 6c75 735f  .T * (1 - Aplus_
+00021610: 6929 292e 5429 202a 2028 3120 2d20 4170  i)).T) * (1 - Ap
+00021620: 6c75 735f 6929 0a20 2020 2020 2020 2020  lus_i).         
+00021630: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00021640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021650: 2042 5f73 756d 203d 2077 2e64 6f74 2856   B_sum = w.dot(V
+00021660: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00021670: 2020 636f 6d70 6f6e 656e 745f 6265 7477    component_betw
+00021680: 6565 6e6e 6573 7320 2b3d 2074 6869 735f  eenness += this_
+00021690: 775b 692d 7374 6172 745f 695d 202a 2042  w[i-start_i] * B
+000216a0: 5f73 756d 0a0a 2020 2020 2020 2020 2020  _sum..          
+000216b0: 2020 7265 7375 6c74 203d 2063 6f6d 706f    result = compo
+000216c0: 6e65 6e74 5f62 6574 7765 656e 6e65 7373  nent_betweenness
+000216d0: 2c20 7374 6172 745f 692c 2065 6e64 5f69  , start_i, end_i
+000216e0: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+000216f0: 5275 6e74 696d 6545 7272 6f72 3a0a 2020  RuntimeError:.  
+00021700: 2020 2020 2020 2020 2020 6520 3d20 7379            e = sy
+00021710: 732e 6578 635f 696e 666f 2829 0a20 2020  s.exc_info().   
+00021720: 2020 2020 2020 2020 2065 7272 6f72 5f6d           error_m
+00021730: 6573 7361 6765 203d 2028 7374 7228 655b  essage = (str(e[
+00021740: 305d 2920 2b20 275c 6e27 202b 2073 7472  0]) + '\n' + str
+00021750: 2865 5b31 5d29 290a 0a20 2020 2020 2020  (e[1]))..       
+00021760: 2072 6574 7572 6e20 6572 726f 725f 6d65   return error_me
+00021770: 7373 6167 652c 2072 6573 756c 740a 0a20  ssage, result.. 
+00021780: 2020 2023 2054 4f44 4f3a 2073 6574 746c     # TODO: settl
+00021790: 6520 666f 7220 736f 6d65 2073 7569 7461  e for some suita
+000217a0: 626c 6520 6465 6661 756c 7473 0a20 2020  ble defaults.   
+000217b0: 2064 6566 206e 7369 5f61 7265 6e61 735f   def nsi_arenas_
+000217c0: 6265 7477 6565 6e6e 6573 7328 7365 6c66  betweenness(self
+000217d0: 2c20 6578 636c 7564 655f 6e65 6967 6862  , exclude_neighb
+000217e0: 6f72 733d 5472 7565 2c0a 2020 2020 2020  ors=True,.      
+000217f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021800: 2020 2020 2020 2020 2073 746f 7070 696e           stoppin
+00021810: 675f 6d6f 6465 3d22 6e65 6967 6862 6f72  g_mode="neighbor
+00021820: 7322 293a 0a20 2020 2020 2020 2022 2222  s"):.        """
+00021830: 0a20 2020 2020 2020 2046 6f72 2065 6163  .        For eac
+00021840: 6820 6e6f 6465 2c20 7265 7475 726e 2069  h node, return i
+00021850: 7473 206e 2e73 2e69 2e20 4172 656e 6173  ts n.s.i. Arenas
+00021860: 2d74 7970 6520 7261 6e64 6f6d 2077 616c  -type random wal
+00021870: 6b20 6265 7477 6565 6e6e 6573 732e 0a0a  k betweenness...
+00021880: 2020 2020 2020 2020 5468 6973 206d 6561          This mea
+00021890: 7375 7265 7320 686f 7720 6f66 7465 6e20  sures how often 
+000218a0: 6120 7261 6e64 6f6d 2077 616c 6b20 7365  a random walk se
+000218b0: 6172 6368 2066 6f72 2061 2072 616e 646f  arch for a rando
+000218c0: 6d20 7461 7267 6574 206e 6f64 650a 2020  m target node.  
+000218d0: 2020 2020 2020 6672 6f6d 2061 2072 616e        from a ran
+000218e0: 646f 6d20 736f 7572 6365 206e 6f64 6520  dom source node 
+000218f0: 6973 2065 7870 6563 7465 6420 746f 2070  is expected to p
+00021900: 6173 7320 7468 6973 206e 6f64 652e 2028  ass this node. (
+00021910: 7365 650a 2020 2020 2020 2020 5b41 7265  see.        [Are
+00021920: 6e61 7332 3030 335d 5f29 0a0a 2020 2020  nas2003]_)..    
+00021930: 2020 2020 2a2a 4578 616d 706c 6573 3a2a      **Examples:*
+00021940: 2a0a 0a20 2020 2020 2020 203e 3e3e 206e  *..        >>> n
+00021950: 6574 203d 204e 6574 776f 726b 2e53 6d61  et = Network.Sma
+00021960: 6c6c 5465 7374 4e65 7477 6f72 6b28 290a  llTestNetwork().
+00021970: 2020 2020 2020 2020 3e3e 3e20 7228 6e65          >>> r(ne
+00021980: 742e 6e73 695f 6172 656e 6173 5f62 6574  t.nsi_arenas_bet
+00021990: 7765 656e 6e65 7373 2829 290a 2020 2020  weenness()).    
+000219a0: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+000219b0: 6e2e 732e 692e 2041 7265 6e61 732d 7479  n.s.i. Arenas-ty
+000219c0: 7065 2072 616e 646f 6d20 7761 6c6b 2062  pe random walk b
+000219d0: 6574 7765 656e 6e65 7373 2e2e 2e0a 2020  etweenness....  
+000219e0: 2020 2020 2020 2020 2028 6769 616e 7420           (giant 
+000219f0: 636f 6d70 6f6e 656e 7420 7369 7a65 3a20  component size: 
+00021a00: 3620 2831 2e30 2929 0a20 2020 2020 2020  6 (1.0)).       
+00021a10: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
+00021a20: 2e69 2e20 6465 6772 6565 2e2e 2e0a 2020  .i. degree....  
+00021a30: 2020 2020 2020 6172 7261 7928 5b20 3230        array([ 20
+00021a40: 2e35 3831 342c 2032 392e 3231 3033 2c20  .5814, 29.2103, 
+00021a50: 3237 2e30 3037 352c 2031 392e 3534 3334  27.0075, 19.5434
+00021a60: 2c20 3235 2e32 3834 392c 2032 342e 3834  , 25.2849, 24.84
+00021a70: 3833 5d29 0a20 2020 2020 2020 203e 3e3e  83]).        >>>
+00021a80: 2072 286e 6574 2e73 706c 6974 7465 645f   r(net.splitted_
+00021a90: 636f 7079 2829 2e6e 7369 5f61 7265 6e61  copy().nsi_arena
+00021aa0: 735f 6265 7477 6565 6e6e 6573 7328 2929  s_betweenness())
+00021ab0: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+00021ac0: 7469 6e67 206e 2e73 2e69 2e20 4172 656e  ting n.s.i. Aren
+00021ad0: 6173 2d74 7970 6520 7261 6e64 6f6d 2077  as-type random w
+00021ae0: 616c 6b20 6265 7477 6565 6e6e 6573 732e  alk betweenness.
+00021af0: 2e2e 0a20 2020 2020 2020 2020 2020 2867  ...           (g
+00021b00: 6961 6e74 2063 6f6d 706f 6e65 6e74 2073  iant component s
+00021b10: 697a 653a 2037 2028 312e 3029 290a 2020  ize: 7 (1.0)).  
+00021b20: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+00021b30: 6720 6e2e 732e 692e 2064 6567 7265 652e  g n.s.i. degree.
+00021b40: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
+00021b50: 285b 2032 302e 3538 3134 2c20 3239 2e32  ([ 20.5814, 29.2
+00021b60: 3130 332c 2032 372e 3030 3735 2c20 3139  103, 27.0075, 19
+00021b70: 2e35 3433 342c 2032 352e 3238 3439 2c20  .5434, 25.2849, 
+00021b80: 3234 2e38 3438 332c 2032 342e 3834 3833  24.8483, 24.8483
+00021b90: 5d29 0a20 2020 2020 2020 203e 3e3e 2072  ]).        >>> r
+00021ba0: 286e 6574 2e6e 7369 5f61 7265 6e61 735f  (net.nsi_arenas_
+00021bb0: 6265 7477 6565 6e6e 6573 7328 6578 636c  betweenness(excl
+00021bc0: 7564 655f 6e65 6967 6862 6f72 733d 4661  ude_neighbors=Fa
+00021bd0: 6c73 6529 290a 2020 2020 2020 2020 4361  lse)).        Ca
+00021be0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+00021bf0: 2041 7265 6e61 732d 7479 7065 2072 616e   Arenas-type ran
+00021c00: 646f 6d20 7761 6c6b 2062 6574 7765 656e  dom walk between
+00021c10: 6e65 7373 2e2e 2e0a 2020 2020 2020 2020  ness....        
+00021c20: 2020 2028 6769 616e 7420 636f 6d70 6f6e     (giant compon
+00021c30: 656e 7420 7369 7a65 3a20 3620 2831 2e30  ent size: 6 (1.0
+00021c40: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+00021c50: 6c61 7469 6e67 206e 2e73 2e69 2e20 6465  lating n.s.i. de
+00021c60: 6772 6565 2e2e 2e0a 2020 2020 2020 2020  gree....        
+00021c70: 6172 7261 7928 5b20 3434 2e35 3335 312c  array([ 44.5351,
+00021c80: 2033 372e 3430 3538 2c20 3237 2e30 3037   37.4058, 27.007
+00021c90: 352c 2032 312e 3737 3336 2c20 3331 2e33  5, 21.7736, 31.3
+00021ca0: 3235 362c 2032 342e 3834 3833 5d29 0a20  256, 24.8483]). 
+00021cb0: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+00021cc0: 2e6e 7369 5f61 7265 6e61 735f 6265 7477  .nsi_arenas_betw
+00021cd0: 6565 6e6e 6573 7328 7374 6f70 7069 6e67  eenness(stopping
+00021ce0: 5f6d 6f64 653d 2274 7769 6e6e 6573 7322  _mode="twinness"
+00021cf0: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+00021d00: 6c61 7469 6e67 206e 2e73 2e69 2e20 4172  lating n.s.i. Ar
+00021d10: 656e 6173 2d74 7970 6520 7261 6e64 6f6d  enas-type random
+00021d20: 2077 616c 6b20 6265 7477 6565 6e6e 6573   walk betweennes
+00021d30: 732e 2e2e 0a20 2020 2020 2020 2020 2020  s....           
+00021d40: 2867 6961 6e74 2063 6f6d 706f 6e65 6e74  (giant component
+00021d50: 2073 697a 653a 2036 2028 312e 3029 290a   size: 6 (1.0)).
+00021d60: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00021d70: 696e 6720 6e2e 732e 692e 2064 6567 7265  ing n.s.i. degre
+00021d80: 652e 2e2e 0a20 2020 2020 2020 2043 616c  e....        Cal
+00021d90: 6375 6c61 7469 6e67 206e 2e73 2e69 2e20  culating n.s.i. 
+00021da0: 6465 6772 6565 2e2e 2e0a 2020 2020 2020  degree....      
+00021db0: 2020 6172 7261 7928 5b20 3232 2e36 3135    array([ 22.615
+00021dc0: 332c 2034 312e 3233 3134 2c20 3338 2e36  3, 41.2314, 38.6
+00021dd0: 3431 312c 2032 382e 3631 3935 2c20 3338  411, 28.6195, 38
+00021de0: 2e35 3832 342c 2033 302e 3239 3934 5d29  .5824, 30.2994])
+00021df0: 0a0a 2020 2020 2020 2020 6173 2063 6f6d  ..        as com
+00021e00: 7061 7265 6420 746f 2069 7473 2075 6e77  pared to its unw
+00021e10: 6569 6768 7465 6420 7665 7273 696f 6e3a  eighted version:
+00021e20: 0a0a 2020 2020 2020 2020 3e3e 3e20 6e65  ..        >>> ne
+00021e30: 7420 3d20 4e65 7477 6f72 6b2e 536d 616c  t = Network.Smal
+00021e40: 6c54 6573 744e 6574 776f 726b 2829 0a20  lTestNetwork(). 
+00021e50: 2020 2020 2020 203e 3e3e 2072 286e 6574         >>> r(net
+00021e60: 2e61 7265 6e61 735f 6265 7477 6565 6e6e  .arenas_betweenn
+00021e70: 6573 7328 2929 0a20 2020 2020 2020 2043  ess()).        C
+00021e80: 616c 6375 6c61 7469 6e67 2041 7265 6e61  alculating Arena
+00021e90: 732d 7479 7065 2072 616e 646f 6d20 7761  s-type random wa
+00021ea0: 6c6b 2062 6574 7765 656e 6e65 7373 2e2e  lk betweenness..
+00021eb0: 2e0a 2020 2020 2020 2020 2020 2028 6769  ..           (gi
+00021ec0: 616e 7420 636f 6d70 6f6e 656e 7420 7369  ant component si
+00021ed0: 7a65 3a20 3620 2831 2e30 2929 0a20 2020  ze: 6 (1.0)).   
+00021ee0: 2020 2020 2061 7272 6179 285b 2035 302e       array([ 50.
+00021ef0: 3138 3138 2c20 3530 2e31 3831 382c 2033  1818, 50.1818, 3
+00021f00: 332e 3435 3435 2c20 3333 2e34 3534 352c  3.4545, 33.4545,
+00021f10: 2035 302e 3138 3138 2c20 3136 2e37 3237   50.1818, 16.727
+00021f20: 335d 290a 2020 2020 2020 2020 3e3e 3e20  3]).        >>> 
+00021f30: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
+00021f40: 6f70 7928 292e 6172 656e 6173 5f62 6574  opy().arenas_bet
+00021f50: 7765 656e 6e65 7373 2829 290a 2020 2020  weenness()).    
+00021f60: 2020 2020 4361 6c63 756c 6174 696e 6720      Calculating 
+00021f70: 4172 656e 6173 2d74 7970 6520 7261 6e64  Arenas-type rand
+00021f80: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
+00021f90: 6573 732e 2e2e 0a20 2020 2020 2020 2020  ess....         
+00021fa0: 2020 2867 6961 6e74 2063 6f6d 706f 6e65    (giant compone
+00021fb0: 6e74 2073 697a 653a 2037 2028 312e 3029  nt size: 7 (1.0)
+00021fc0: 290a 2020 2020 2020 2020 6172 7261 7928  ).        array(
+00021fd0: 5b20 3930 2e34 3234 322c 2036 372e 3831  [ 90.4242, 67.81
+00021fe0: 3832 2c20 3435 2e32 3132 312c 2034 352e  82, 45.2121, 45.
+00021ff0: 3231 3231 2c20 3637 2e38 3138 322c 2034  2121, 67.8182, 4
+00022000: 352e 3231 3231 2c20 3435 2e32 3132 315d  5.2121, 45.2121]
+00022010: 290a 0a20 2020 2020 2020 203a 6172 6720  )..        :arg 
+00022020: 626f 6f6c 2065 7863 6c75 6465 5f6e 6569  bool exclude_nei
+00022030: 6768 626f 7273 3a20 496e 6469 6361 7465  ghbors: Indicate
+00022040: 7320 7768 6574 6865 7220 746f 2075 7365  s whether to use
+00022050: 206f 6e6c 7920 736f 7572 6365 2061 6e64   only source and
+00022060: 0a20 2020 2020 2020 2020 2020 2074 6172  .            tar
+00022070: 6765 7420 6e6f 6465 7320 7468 6174 2061  get nodes that a
+00022080: 7265 206e 6f74 206c 696e 6b65 6420 746f  re not linked to
+00022090: 2074 6865 206e 6f64 6520 6f66 2069 6e74   the node of int
+000220a0: 6572 6573 742e 0a20 2020 2020 2020 2020  erest..         
+000220b0: 2020 2028 4465 6661 756c 743a 2054 7275     (Default: Tru
+000220c0: 6529 0a20 2020 2020 2020 203a 6172 6720  e).        :arg 
+000220d0: 7374 7220 7374 6f70 7069 6e67 5f6d 6f64  str stopping_mod
+000220e0: 653a 2053 7065 6369 6669 6573 2077 6865  e: Specifies whe
+000220f0: 6e20 7468 6520 7261 6e64 6f6d 2077 616c  n the random wal
+00022100: 6b20 6973 2073 746f 7070 6564 2e20 4966  k is stopped. If
+00022110: 0a20 2020 2020 2020 2020 2020 2022 6e65  .            "ne
+00022120: 6967 6862 6f72 7322 2c20 7468 6520 7761  ighbors", the wa
+00022130: 6c6b 2073 746f 7073 2061 7320 736f 6f6e  lk stops as soon
+00022140: 2061 7320 6974 2072 6561 6368 6573 2061   as it reaches a
+00022150: 206e 6569 6768 626f 7220 6f66 2074 6865   neighbor of the
+00022160: 0a20 2020 2020 2020 2020 2020 2074 6172  .            tar
+00022170: 6765 7420 6e6f 6465 2e20 4966 2022 7477  get node. If "tw
+00022180: 696e 6e6e 6573 7322 2c20 7468 6520 7374  innness", the st
+00022190: 6f70 7069 6e67 2070 726f 6261 6269 6c69  opping probabili
+000221a0: 7479 2061 7420 6561 6368 2073 7465 700a  ty at each step.
+000221b0: 2020 2020 2020 2020 2020 2020 6973 2074              is t
+000221c0: 6865 2074 7769 6e6e 6e65 7373 206f 6620  he twinnness of 
+000221d0: 7468 6520 6375 7272 656e 7420 616e 6420  the current and 
+000221e0: 7461 7267 6574 206e 6f64 6573 2061 7320  target nodes as 
+000221f0: 6769 7665 6e20 6279 0a20 2020 2020 2020  given by.       
+00022200: 2020 2020 203a 6d65 7468 3a60 6e73 695f       :meth:`nsi_
+00022210: 7477 696e 6e65 7373 2829 602e 2028 4465  twinness()`. (De
+00022220: 6661 756c 743a 2022 6e65 6967 6862 6f72  fault: "neighbor
+00022230: 7322 290a 2020 2020 2020 2020 3a72 7479  s").        :rty
+00022240: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
+00022250: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
+00022260: 6174 7320 3e3d 2030 0a20 2020 2020 2020  ats >= 0.       
+00022270: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+00022280: 7365 6c66 2e73 696c 656e 6365 5f6c 6576  self.silence_lev
+00022290: 656c 203c 3d20 313a 0a20 2020 2020 2020  el <= 1:.       
+000222a0: 2020 2020 2070 7269 6e74 2822 4361 6c63       print("Calc
+000222b0: 756c 6174 696e 6720 6e2e 732e 692e 2041  ulating n.s.i. A
+000222c0: 7265 6e61 732d 7479 7065 2072 616e 646f  renas-type rando
+000222d0: 6d20 7761 6c6b 2062 6574 7765 656e 6e65  m walk betweenne
+000222e0: 7373 2e2e 2e22 290a 0a20 2020 2020 2020  ss...")..       
+000222f0: 2074 3020 3d20 7469 6d65 2e74 696d 6528   t0 = time.time(
+00022300: 290a 0a20 2020 2020 2020 2023 2020 496e  )..        #  In
+00022310: 6974 6961 6c69 7a65 2074 6865 2061 7272  itialize the arr
+00022320: 6179 2074 6f20 686f 6c64 2072 616e 646f  ay to hold rando
+00022330: 6d20 7761 6c6b 2062 6574 7765 656e 6e65  m walk betweenne
+00022340: 7373 0a20 2020 2020 2020 206e 7369 5f61  ss.        nsi_a
+00022350: 7265 6e61 735f 6265 7477 6565 6e6e 6573  renas_betweennes
+00022360: 7320 3d20 6e70 2e7a 6572 6f73 2873 656c  s = np.zeros(sel
+00022370: 662e 4e29 0a0a 2020 2020 2020 2020 2320  f.N)..        # 
+00022380: 2052 616e 646f 6d20 7761 6c6b 2062 6574   Random walk bet
+00022390: 7765 656e 6e65 7373 2068 6173 2074 6f20  weenness has to 
+000223a0: 6265 2063 616c 6375 6c61 7465 6420 666f  be calculated fo
+000223b0: 7220 6561 6368 2063 6f6d 706f 6e65 6e74  r each component
+000223c0: 0a20 2020 2020 2020 2023 2020 7365 7061  .        #  sepa
+000223d0: 7261 7465 6c79 2e20 5468 6572 6566 6f72  rately. Therefor
+000223e0: 6520 6765 7420 6469 6666 6572 656e 7420  e get different 
+000223f0: 636f 6d70 6f6e 656e 7473 206f 6620 7468  components of th
+00022400: 6520 6772 6170 6820 6669 7273 740a 2020  e graph first.  
+00022410: 2020 2020 2020 636f 6d70 6f6e 656e 7473        components
+00022420: 203d 2073 656c 662e 6772 6170 682e 636f   = self.graph.co
+00022430: 6e6e 6563 7465 645f 636f 6d70 6f6e 656e  nnected_componen
+00022440: 7473 2829 0a0a 2020 2020 2020 2020 2320  ts()..        # 
+00022450: 2050 7269 6e74 2067 6961 6e74 2063 6f6d   Print giant com
+00022460: 706f 6e65 6e74 2073 697a 650a 2020 2020  ponent size.    
+00022470: 2020 2020 6966 2073 656c 662e 7369 6c65      if self.sile
+00022480: 6e63 655f 6c65 7665 6c20 3c3d 2031 3a0a  nce_level <= 1:.
+00022490: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+000224a0: 7428 2220 2020 2867 6961 6e74 2063 6f6d  t("   (giant com
+000224b0: 706f 6e65 6e74 2073 697a 653a 2022 0a20  ponent size: ". 
+000224c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000224d0: 202b 2073 7472 2863 6f6d 706f 6e65 6e74   + str(component
+000224e0: 732e 6769 616e 7428 292e 7663 6f75 6e74  s.giant().vcount
+000224f0: 2829 2920 2b20 2220 2822 0a20 2020 2020  ()) + " (".     
+00022500: 2020 2020 2020 2020 2020 2020 202b 2073               + s
+00022510: 7472 2863 6f6d 706f 6e65 6e74 732e 6769  tr(components.gi
+00022520: 616e 7428 292e 7663 6f75 6e74 2829 0a20  ant().vcount(). 
+00022530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022540: 2020 2020 2020 202f 2066 6c6f 6174 2873         / float(s
+00022550: 656c 662e 6772 6170 682e 7663 6f75 6e74  elf.graph.vcount
+00022560: 2829 2929 202b 2022 2929 2229 0a0a 2020  ())) + "))")..  
+00022570: 2020 2020 2020 666f 7220 632c 2063 6f6d        for c, com
+00022580: 7020 696e 2065 6e75 6d65 7261 7465 2863  p in enumerate(c
+00022590: 6f6d 706f 6e65 6e74 7329 3a0a 2020 2020  omponents):.    
+000225a0: 2020 2020 2020 2020 2320 2049 6620 7468          #  If th
+000225b0: 6520 636f 6d70 6f6e 656e 7420 6861 7320  e component has 
+000225c0: 7369 7a65 2031 2c20 7365 7420 7261 6e64  size 1, set rand
+000225d0: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
+000225e0: 6573 7320 746f 207a 6572 6f0a 2020 2020  ess to zero.    
+000225f0: 2020 2020 2020 2020 6966 206c 656e 2863          if len(c
+00022600: 6f6d 7029 203d 3d20 313a 0a20 2020 2020  omp) == 1:.     
+00022610: 2020 2020 2020 2020 2020 206e 7369 5f61             nsi_a
+00022620: 7265 6e61 735f 6265 7477 6565 6e6e 6573  renas_betweennes
+00022630: 735b 636f 6d70 5b30 5d5d 203d 2030 0a20  s[comp[0]] = 0. 
+00022640: 2020 2020 2020 2020 2020 2023 2020 466f             #  Fo
+00022650: 7220 6c61 7267 6572 2063 6f6d 706f 6e65  r larger compone
+00022660: 6e74 732c 2063 6f6e 7469 6e75 6520 7769  nts, continue wi
+00022670: 7468 2074 6865 2063 616c 6375 6c61 7469  th the calculati
+00022680: 6f6e 0a20 2020 2020 2020 2020 2020 2065  on.            e
+00022690: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000226a0: 2020 2020 2023 2020 4765 7420 7468 6520       #  Get the 
+000226b0: 7375 6267 7261 7068 2063 6f72 7265 7370  subgraph corresp
+000226c0: 6f6e 6469 6e67 2074 6f20 636f 6d70 6f6e  onding to compon
+000226d0: 656e 7420 690a 2020 2020 2020 2020 2020  ent i.          
+000226e0: 2020 2020 2020 7375 6267 7261 7068 203d        subgraph =
+000226f0: 2063 6f6d 706f 6e65 6e74 732e 7375 6267   components.subg
+00022700: 7261 7068 2863 290a 2020 2020 2020 2020  raph(c).        
+00022710: 2020 2020 2020 2020 4120 3d20 6e70 2e61          A = np.a
+00022720: 7272 6179 2873 7562 6772 6170 682e 6765  rray(subgraph.ge
+00022730: 745f 6164 6a61 6365 6e63 7928 7479 7065  t_adjacency(type
+00022740: 3d32 292e 6461 7461 290a 2020 2020 2020  =2).data).      
+00022750: 2020 2020 2020 2020 2020 6465 6c20 7375            del su
+00022760: 6267 7261 7068 0a0a 2020 2020 2020 2020  bgraph..        
+00022770: 2020 2020 2020 2020 2320 2047 6574 2074          #  Get t
+00022780: 6865 206c 6973 7420 6f66 2076 6572 7465  he list of verte
+00022790: 7820 6e75 6d62 6572 7320 696e 2074 6865  x numbers in the
+000227a0: 2073 7562 6772 6170 680a 2020 2020 2020   subgraph.      
+000227b0: 2020 2020 2020 2020 2020 6e6f 6465 7320            nodes 
+000227c0: 3d20 636f 6d70 0a0a 2020 2020 2020 2020  = comp..        
+000227d0: 2020 2020 2020 2020 2320 4578 7472 6163          # Extrac
+000227e0: 7420 636f 7272 6573 706f 6e64 696e 6720  t corresponding 
+000227f0: 6172 6561 2077 6569 6768 7420 7665 6374  area weight vect
+00022800: 6f72 0a20 2020 2020 2020 2020 2020 2020  or.             
+00022810: 2020 2077 203d 206e 702e 7a65 726f 7328     w = np.zeros(
+00022820: 6c65 6e28 6e6f 6465 7329 290a 2020 2020  len(nodes)).    
+00022830: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00022840: 6a2c 206e 6f64 6520 696e 2065 6e75 6d65  j, node in enume
+00022850: 7261 7465 286e 6f64 6573 293a 0a20 2020  rate(nodes):.   
+00022860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022870: 2077 5b6a 5d20 3d20 7365 6c66 2e6e 6f64   w[j] = self.nod
+00022880: 655f 7765 6967 6874 735b 6e6f 6465 5d0a  e_weights[node].
+00022890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000228a0: 2023 2020 4765 6e65 7261 7465 2061 204e   #  Generate a N
+000228b0: 6574 776f 726b 206f 626a 6563 7420 7265  etwork object re
+000228c0: 7072 6573 656e 7469 6e67 2074 6865 2073  presenting the s
+000228d0: 7562 6772 6170 680a 2020 2020 2020 2020  ubgraph.        
+000228e0: 2020 2020 2020 2020 7375 626e 6574 203d          subnet =
+000228f0: 204e 6574 776f 726b 2861 646a 6163 656e   Network(adjacen
+00022900: 6379 3d41 2c20 6469 7265 6374 6564 3d46  cy=A, directed=F
+00022910: 616c 7365 2c20 6e6f 6465 5f77 6569 6768  alse, node_weigh
+00022920: 7473 3d77 290a 2020 2020 2020 2020 2020  ts=w).          
+00022930: 2020 2020 2020 4e20 3d20 7375 626e 6574        N = subnet
+00022940: 2e4e 0a0a 2020 2020 2020 2020 2020 2020  .N..            
+00022950: 2020 2020 2320 2043 616c 6375 6c61 7465      #  Calculate
+00022960: 2074 6865 2073 7562 6e65 7477 6f72 6b73   the subnetworks
+00022970: 2064 6567 7265 6520 7365 7175 656e 6365   degree sequence
+00022980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022990: 2073 7562 6e65 742e 6e73 695f 6465 6772   subnet.nsi_degr
+000229a0: 6565 2829 0a20 2020 2020 2020 2020 2020  ee().           
+000229b0: 2020 2020 2041 706c 7573 203d 2028 4120       Aplus = (A 
+000229c0: 2b20 6e70 2e69 6465 6e74 6974 7928 4e29  + np.identity(N)
+000229d0: 292e 6173 7479 7065 2869 6e74 290a 2020  ).astype(int).  
+000229e0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000229f0: 2073 746f 7070 696e 675f 6d6f 6465 203d   stopping_mode =
+00022a00: 3d20 2274 7769 6e6e 6573 7322 3a0a 2020  = "twinness":.  
+00022a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022a20: 2020 7477 696e 6e65 7373 203d 2073 656c    twinness = sel
+00022a30: 662e 6e73 695f 7477 696e 6e65 7373 2829  f.nsi_twinness()
+00022a40: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00022a50: 2020 2320 2047 6574 2074 6865 2073 7061    #  Get the spa
+00022a60: 7273 6520 5020 6d61 7472 6978 2074 6861  rse P matrix tha
+00022a70: 7420 6765 7473 206d 6f64 6966 6965 6420  t gets modified 
+00022a80: 616e 6420 696e 7665 7274 6564 0a20 2020  and inverted.   
+00022a90: 2020 2020 2020 2020 2020 2020 2073 705f               sp_
+00022aa0: 5020 3d20 2873 7562 6e65 742e 7370 5f6e  P = (subnet.sp_n
+00022ab0: 7369 5f64 6961 675f 6b5f 696e 7628 2920  si_diag_k_inv() 
+00022ac0: 2a20 7375 626e 6574 2e73 705f 4170 6c75  * subnet.sp_Aplu
+00022ad0: 7328 290a 2020 2020 2020 2020 2020 2020  s().            
+00022ae0: 2020 2020 2020 2020 2020 2020 2a20 7375              * su
+00022af0: 626e 6574 2e73 705f 6469 6167 5f77 2829  bnet.sp_diag_w()
+00022b00: 292e 746f 646f 6b28 290a 0a20 2020 2020  ).todok()..     
+00022b10: 2020 2020 2020 2020 2020 2069 6620 6d70             if mp
+00022b20: 692e 6176 6169 6c61 626c 653a 0a20 2020  i.available:.   
+00022b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b40: 2070 6172 7473 203d 206d 6178 2831 2c20   parts = max(1, 
+00022b50: 696e 7428 6e70 2e63 6569 6c28 0a20 2020  int(np.ceil(.   
+00022b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b70: 2020 2020 206d 696e 2828 6d70 692e 7369       min((mpi.si
+00022b80: 7a65 2d31 2920 2a20 3130 2e30 2c20 302e  ze-1) * 10.0, 0.
+00022b90: 3120 2a20 4e29 2929 290a 2020 2020 2020  1 * N)))).      
+00022ba0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00022bb0: 6570 203d 2069 6e74 286e 702e 6365 696c  ep = int(np.ceil
+00022bc0: 2831 2e30 202a 204e 202f 2028 312e 3020  (1.0 * N / (1.0 
+00022bd0: 2a20 7061 7274 7329 2929 0a20 2020 2020  * parts))).     
+00022be0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00022bf0: 6620 7365 6c66 2e73 696c 656e 6365 5f6c  f self.silence_l
+00022c00: 6576 656c 203c 3d20 303a 0a20 2020 2020  evel <= 0:.     
+00022c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022c20: 2020 2070 7269 6e74 2866 2220 2020 7061     print(f"   pa
+00022c30: 7261 6c6c 656c 697a 696e 6720 6f6e 207b  rallelizing on {
+00022c40: 6d70 692e 7369 7a65 2d31 7d22 0a20 2020  mpi.size-1}".   
+00022c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022c60: 2020 2020 2020 2020 2020 2066 2220 736c             f" sl
+00022c70: 6176 6573 2069 6e74 6f20 7b70 6172 7473  aves into {parts
+00022c80: 7d20 7061 7274 7320 7769 7468 2022 0a20  } parts with ". 
+00022c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022ca0: 2020 2020 2020 2020 2020 2020 2066 227b               f"{
+00022cb0: 7374 6570 7d20 6e6f 6465 7320 6561 6368  step} nodes each
+00022cc0: 2e2e 2e22 290a 0a20 2020 2020 2020 2020  ...")..         
+00022cd0: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00022ce0: 6e64 6578 2069 6e20 7261 6e67 6528 7061  ndex in range(pa
+00022cf0: 7274 7329 3a0a 2020 2020 2020 2020 2020  rts):.          
+00022d00: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00022d10: 6172 745f 6920 3d20 696e 6465 7820 2a20  art_i = index * 
+00022d20: 7374 6570 0a20 2020 2020 2020 2020 2020  step.           
+00022d30: 2020 2020 2020 2020 2020 2020 2065 6e64               end
+00022d40: 5f69 203d 206d 696e 2828 696e 6465 7820  _i = min((index 
+00022d50: 2b20 3129 202a 2073 7465 702c 204e 290a  + 1) * step, N).
+00022d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022d70: 2020 2020 2020 2020 6966 2073 7461 7274          if start
+00022d80: 5f69 203e 3d20 656e 645f 693a 0a20 2020  _i >= end_i:.   
+00022d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022da0: 2020 2020 2020 2020 2062 7265 616b 0a20           break. 
+00022db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022dc0: 2020 2020 2020 2074 6869 735f 4170 6c75         this_Aplu
+00022dd0: 7320 3d20 4170 6c75 735b 7374 6172 745f  s = Aplus[start_
+00022de0: 693a 656e 645f 692c 203a 5d0a 2020 2020  i:end_i, :].    
 00022df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022e00: 2020 2020 2f20 666c 6f61 7428 7365 6c66      / float(self
-00022e10: 2e67 7261 7068 2e76 636f 756e 7428 2929  .graph.vcount())
-00022e20: 2920 2b20 2229 2922 290a 0a20 2020 2020  ) + "))")..     
-00022e30: 2020 2066 6f72 2063 2c20 636f 6d70 2069     for c, comp i
-00022e40: 6e20 656e 756d 6572 6174 6528 636f 6d70  n enumerate(comp
-00022e50: 6f6e 656e 7473 293a 0a20 2020 2020 2020  onents):.       
-00022e60: 2020 2020 2023 2020 4966 2074 6865 2063       #  If the c
-00022e70: 6f6d 706f 6e65 6e74 2068 6173 2073 697a  omponent has siz
-00022e80: 6520 312c 2073 6574 2072 616e 646f 6d20  e 1, set random 
-00022e90: 7761 6c6b 2062 6574 7765 656e 6e65 7373  walk betweenness
-00022ea0: 2074 6f20 7a65 726f 0a20 2020 2020 2020   to zero.       
-00022eb0: 2020 2020 2069 6620 6c65 6e28 636f 6d70       if len(comp
-00022ec0: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
-00022ed0: 2020 2020 2020 2020 6e73 695f 6172 656e          nsi_aren
-00022ee0: 6173 5f62 6574 7765 656e 6e65 7373 5b63  as_betweenness[c
-00022ef0: 6f6d 705b 305d 5d20 3d20 300a 2020 2020  omp[0]] = 0.    
-00022f00: 2020 2020 2020 2020 2320 2046 6f72 206c          #  For l
-00022f10: 6172 6765 7220 636f 6d70 6f6e 656e 7473  arger components
-00022f20: 2c20 636f 6e74 696e 7565 2077 6974 6820  , continue with 
-00022f30: 7468 6520 6361 6c63 756c 6174 696f 6e0a  the calculation.
-00022f40: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00022f50: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00022f60: 2020 2320 2047 6574 2074 6865 2073 7562    #  Get the sub
-00022f70: 6772 6170 6820 636f 7272 6573 706f 6e64  graph correspond
-00022f80: 696e 6720 746f 2063 6f6d 706f 6e65 6e74  ing to component
-00022f90: 2069 0a20 2020 2020 2020 2020 2020 2020   i.             
-00022fa0: 2020 2073 7562 6772 6170 6820 3d20 636f     subgraph = co
-00022fb0: 6d70 6f6e 656e 7473 2e73 7562 6772 6170  mponents.subgrap
-00022fc0: 6828 6329 0a20 2020 2020 2020 2020 2020  h(c).           
-00022fd0: 2020 2020 2041 203d 206e 702e 6172 7261       A = np.arra
-00022fe0: 7928 7375 6267 7261 7068 2e67 6574 5f61  y(subgraph.get_a
-00022ff0: 646a 6163 656e 6379 2874 7970 653d 3229  djacency(type=2)
-00023000: 2e64 6174 6129 0a20 2020 2020 2020 2020  .data).         
-00023010: 2020 2020 2020 2064 656c 2073 7562 6772         del subgr
-00023020: 6170 680a 0a20 2020 2020 2020 2020 2020  aph..           
-00023030: 2020 2020 2023 2020 4765 7420 7468 6520       #  Get the 
-00023040: 6c69 7374 206f 6620 7665 7274 6578 206e  list of vertex n
-00023050: 756d 6265 7273 2069 6e20 7468 6520 7375  umbers in the su
-00023060: 6267 7261 7068 0a20 2020 2020 2020 2020  bgraph.         
-00023070: 2020 2020 2020 206e 6f64 6573 203d 2063         nodes = c
-00023080: 6f6d 700a 0a20 2020 2020 2020 2020 2020  omp..           
-00023090: 2020 2020 2023 2045 7874 7261 6374 2063       # Extract c
-000230a0: 6f72 7265 7370 6f6e 6469 6e67 2061 7265  orresponding are
-000230b0: 6120 7765 6967 6874 2076 6563 746f 720a  a weight vector.
-000230c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000230d0: 7720 3d20 6e70 2e7a 6572 6f73 286c 656e  w = np.zeros(len
-000230e0: 286e 6f64 6573 2929 0a20 2020 2020 2020  (nodes)).       
-000230f0: 2020 2020 2020 2020 2066 6f72 206a 2c20           for j, 
-00023100: 6e6f 6465 2069 6e20 656e 756d 6572 6174  node in enumerat
-00023110: 6528 6e6f 6465 7329 3a0a 2020 2020 2020  e(nodes):.      
-00023120: 2020 2020 2020 2020 2020 2020 2020 775b                w[
-00023130: 6a5d 203d 2073 656c 662e 6e6f 6465 5f77  j] = self.node_w
-00023140: 6569 6768 7473 5b6e 6f64 655d 0a0a 2020  eights[node]..  
-00023150: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00023160: 2047 656e 6572 6174 6520 6120 4e65 7477   Generate a Netw
-00023170: 6f72 6b20 6f62 6a65 6374 2072 6570 7265  ork object repre
-00023180: 7365 6e74 696e 6720 7468 6520 7375 6267  senting the subg
-00023190: 7261 7068 0a20 2020 2020 2020 2020 2020  raph.           
-000231a0: 2020 2020 2073 7562 6e65 7420 3d20 4e65       subnet = Ne
-000231b0: 7477 6f72 6b28 6164 6a61 6365 6e63 793d  twork(adjacency=
-000231c0: 412c 2064 6972 6563 7465 643d 4661 6c73  A, directed=Fals
-000231d0: 652c 206e 6f64 655f 7765 6967 6874 733d  e, node_weights=
-000231e0: 7729 0a20 2020 2020 2020 2020 2020 2020  w).             
-000231f0: 2020 204e 203d 2073 7562 6e65 742e 4e0a     N = subnet.N.
-00023200: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023210: 2023 2020 4361 6c63 756c 6174 6520 7468   #  Calculate th
-00023220: 6520 7375 626e 6574 776f 726b 7320 6465  e subnetworks de
-00023230: 6772 6565 2073 6571 7565 6e63 650a 2020  gree sequence.  
-00023240: 2020 2020 2020 2020 2020 2020 2020 7375                su
-00023250: 626e 6574 2e6e 7369 5f64 6567 7265 6528  bnet.nsi_degree(
-00023260: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00023270: 2020 4170 6c75 7320 3d20 2841 202b 206e    Aplus = (A + n
-00023280: 702e 6964 656e 7469 7479 284e 2929 2e61  p.identity(N)).a
-00023290: 7374 7970 6528 696e 7429 0a20 2020 2020  stype(int).     
-000232a0: 2020 2020 2020 2020 2020 2069 6620 7374             if st
-000232b0: 6f70 7069 6e67 5f6d 6f64 6520 3d3d 2022  opping_mode == "
-000232c0: 7477 696e 6e65 7373 223a 0a20 2020 2020  twinness":.     
-000232d0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-000232e0: 7769 6e6e 6573 7320 3d20 7365 6c66 2e6e  winness = self.n
-000232f0: 7369 5f74 7769 6e6e 6573 7328 290a 0a20  si_twinness().. 
-00023300: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00023310: 2020 4765 7420 7468 6520 7370 6172 7365    Get the sparse
-00023320: 2050 206d 6174 7269 7820 7468 6174 2067   P matrix that g
-00023330: 6574 7320 6d6f 6469 6669 6564 2061 6e64  ets modified and
-00023340: 2069 6e76 6572 7465 640a 2020 2020 2020   inverted.      
-00023350: 2020 2020 2020 2020 2020 7370 5f50 203d            sp_P =
-00023360: 2028 7375 626e 6574 2e73 705f 6e73 695f   (subnet.sp_nsi_
-00023370: 6469 6167 5f6b 5f69 6e76 2829 202a 2073  diag_k_inv() * s
-00023380: 7562 6e65 742e 7370 5f41 706c 7573 2829  ubnet.sp_Aplus()
-00023390: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000233a0: 2020 2020 2020 2020 202a 2073 7562 6e65           * subne
-000233b0: 742e 7370 5f64 6961 675f 7728 2929 2e74  t.sp_diag_w()).t
-000233c0: 6f64 6f6b 2829 0a0a 2020 2020 2020 2020  odok()..        
-000233d0: 2020 2020 2020 2020 6966 206d 7069 2e61          if mpi.a
-000233e0: 7661 696c 6162 6c65 3a0a 2020 2020 2020  vailable:.      
-000233f0: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-00023400: 7274 7320 3d20 6d61 7828 312c 2069 6e74  rts = max(1, int
-00023410: 286e 702e 6365 696c 280a 2020 2020 2020  (np.ceil(.      
-00023420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023430: 2020 6d69 6e28 286d 7069 2e73 697a 652d    min((mpi.size-
-00023440: 3129 202a 2031 302e 302c 2030 2e31 202a  1) * 10.0, 0.1 *
-00023450: 204e 2929 2929 0a20 2020 2020 2020 2020   N)))).         
-00023460: 2020 2020 2020 2020 2020 2073 7465 7020             step 
-00023470: 3d20 696e 7428 6e70 2e63 6569 6c28 312e  = int(np.ceil(1.
-00023480: 3020 2a20 4e20 2f20 2831 2e30 202a 2070  0 * N / (1.0 * p
-00023490: 6172 7473 2929 290a 2020 2020 2020 2020  arts))).        
-000234a0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-000234b0: 656c 662e 7369 6c65 6e63 655f 6c65 7665  elf.silence_leve
-000234c0: 6c20 3c3d 2030 3a0a 2020 2020 2020 2020  l <= 0:.        
-000234d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000234e0: 7072 696e 7428 6622 2020 2070 6172 616c  print(f"   paral
-000234f0: 6c65 6c69 7a69 6e67 206f 6e20 7b6d 7069  lelizing on {mpi
-00023500: 2e73 697a 652d 317d 220a 2020 2020 2020  .size-1}".      
+00022e00: 2020 2020 7468 6973 5f77 203d 2077 5b73      this_w = w[s
+00022e10: 7461 7274 5f69 3a65 6e64 5f69 5d0a 2020  tart_i:end_i].  
+00022e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022e30: 2020 2020 2020 6966 2073 746f 7070 696e        if stoppin
+00022e40: 675f 6d6f 6465 203d 3d20 2274 7769 6e6e  g_mode == "twinn
+00022e50: 6573 7322 3a0a 2020 2020 2020 2020 2020  ess":.          
+00022e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022e70: 2020 7468 6973 5f74 7769 6e6e 6573 7320    this_twinness 
+00022e80: 3d20 7477 696e 6e65 7373 5b73 7461 7274  = twinness[start
+00022e90: 5f69 3a65 6e64 5f69 2c20 3a5d 0a20 2020  _i:end_i, :].   
+00022ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022eb0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00022ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022ed0: 2020 2020 2020 2074 6869 735f 7477 696e         this_twin
+00022ee0: 6e65 7373 203d 204e 6f6e 650a 2020 2020  ness = None.    
+00022ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022f00: 2020 2020 6966 2073 656c 662e 7369 6c65      if self.sile
+00022f10: 6e63 655f 6c65 7665 6c20 3c3d 2030 3a0a  nce_level <= 0:.
+00022f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022f30: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00022f40: 7428 2220 2020 7375 626d 6974 7469 6e67  t("   submitting
+00022f50: 222c 2069 6e64 6578 290a 2020 2020 2020  ", index).      
+00022f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022f70: 2020 2020 2020 6d70 692e 7375 626d 6974        mpi.submit
+00022f80: 5f63 616c 6c28 0a20 2020 2020 2020 2020  _call(.         
+00022f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022fa0: 2020 2020 2020 2022 4e65 7477 6f72 6b2e         "Network.
+00022fb0: 5f6d 7069 5f6e 7369 5f61 7265 6e61 735f  _mpi_nsi_arenas_
+00022fc0: 6265 7477 6565 6e6e 6573 7322 2c0a 2020  betweenness",.  
+00022fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022fe0: 2020 2020 2020 2020 2020 2020 2020 284e                (N
+00022ff0: 2c20 7370 5f50 2c20 7468 6973 5f41 706c  , sp_P, this_Apl
+00023000: 7573 2c20 772c 2074 6869 735f 772c 0a20  us, w, this_w,. 
+00023010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023030: 7374 6172 745f 692c 2065 6e64 5f69 2c20  start_i, end_i, 
+00023040: 6578 636c 7564 655f 6e65 6967 6862 6f72  exclude_neighbor
+00023050: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00023060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023070: 2020 2020 7374 6f70 7069 6e67 5f6d 6f64      stopping_mod
+00023080: 652c 2074 6869 735f 7477 696e 6e65 7373  e, this_twinness
+00023090: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+000230a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000230b0: 2020 206d 6f64 756c 653d 2270 7975 6e69     module="pyuni
+000230c0: 636f 726e 222c 2069 643d 696e 6465 7829  corn", id=index)
+000230d0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+000230e0: 2020 2020 2020 2320 5265 7472 6965 7665        # Retrieve
+000230f0: 2072 6573 756c 7473 206f 6620 616c 6c20   results of all 
+00023100: 7375 626d 6974 6564 206a 6f62 730a 2020  submited jobs.  
+00023110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023120: 2020 636f 6d70 6f6e 656e 745f 6265 7477    component_betw
+00023130: 6565 6e6e 6573 7320 3d20 6e70 2e7a 6572  eenness = np.zer
+00023140: 6f73 284e 290a 2020 2020 2020 2020 2020  os(N).          
+00023150: 2020 2020 2020 2020 2020 666f 7220 696e            for in
+00023160: 6465 7820 696e 2072 616e 6765 2870 6172  dex in range(par
+00023170: 7473 293a 0a20 2020 2020 2020 2020 2020  ts):.           
+00023180: 2020 2020 2020 2020 2020 2020 2073 7461               sta
+00023190: 7274 5f69 203d 2069 6e64 6578 202a 2073  rt_i = index * s
+000231a0: 7465 700a 2020 2020 2020 2020 2020 2020  tep.            
+000231b0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+000231c0: 656c 662e 7369 6c65 6e63 655f 6c65 7665  elf.silence_leve
+000231d0: 6c20 3c3d 2030 3a0a 2020 2020 2020 2020  l <= 0:.        
+000231e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000231f0: 2020 2020 7072 696e 7428 2220 2020 7265      print("   re
+00023200: 7472 6965 7669 6e67 2072 6573 756c 7473  trieving results
+00023210: 2066 726f 6d22 2c20 696e 6465 7829 0a20   from", index). 
+00023220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023230: 2020 2020 2020 2065 7272 6f72 5f6d 6573         error_mes
+00023240: 7361 6765 2c20 7265 7375 6c74 203d 206d  sage, result = m
+00023250: 7069 2e67 6574 5f72 6573 756c 7428 696e  pi.get_result(in
+00023260: 6465 7829 0a20 2020 2020 2020 2020 2020  dex).           
+00023270: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00023280: 6572 726f 725f 6d65 7373 6167 6520 213d  error_message !=
+00023290: 2027 273a 0a20 2020 2020 2020 2020 2020   '':.           
+000232a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000232b0: 2070 7269 6e74 2865 7272 6f72 5f6d 6573   print(error_mes
+000232c0: 7361 6765 290a 2020 2020 2020 2020 2020  sage).          
+000232d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000232e0: 2020 7379 732e 6578 6974 2829 0a20 2020    sys.exit().   
+000232f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023300: 2020 2020 2074 6869 735f 6265 7477 6565       this_betwee
+00023310: 6e6e 6573 732c 2073 7461 7274 5f69 2c20  nness, start_i, 
+00023320: 656e 645f 6920 3d20 7265 7375 6c74 0a20  end_i = result. 
+00023330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023340: 2020 2020 2020 2063 6f6d 706f 6e65 6e74         component
+00023350: 5f62 6574 7765 656e 6e65 7373 202b 3d20  _betweenness += 
+00023360: 7468 6973 5f62 6574 7765 656e 6e65 7373  this_betweenness
+00023370: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023380: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00023390: 2020 2020 2020 2020 2020 2063 6f6d 706f             compo
+000233a0: 6e65 6e74 5f62 6574 7765 656e 6e65 7373  nent_betweenness
+000233b0: 203d 206e 702e 7a65 726f 7328 4e29 0a20   = np.zeros(N). 
+000233c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000233d0: 2020 2069 6620 7374 6f70 7069 6e67 5f6d     if stopping_m
+000233e0: 6f64 6520 3d3d 2022 7477 696e 6e65 7373  ode == "twinness
+000233f0: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
+00023400: 2020 2020 2020 2020 2020 2074 6869 735f             this_
+00023410: 7477 696e 6e65 7373 203d 2074 7769 6e6e  twinness = twinn
+00023420: 6573 730a 2020 2020 2020 2020 2020 2020  ess.            
+00023430: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00023440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023450: 2020 2020 2020 7468 6973 5f74 7769 6e6e        this_twinn
+00023460: 6573 7320 3d20 4e6f 6e65 0a20 2020 2020  ess = None.     
+00023470: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00023480: 7272 6f72 5f6d 6573 7361 6765 2c20 7265  rror_message, re
+00023490: 7375 6c74 203d 205c 0a20 2020 2020 2020  sult = \.       
+000234a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000234b0: 204e 6574 776f 726b 2e5f 6d70 695f 6e73   Network._mpi_ns
+000234c0: 695f 6172 656e 6173 5f62 6574 7765 656e  i_arenas_between
+000234d0: 6e65 7373 280a 2020 2020 2020 2020 2020  ness(.          
+000234e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000234f0: 2020 4e2c 2073 705f 502c 2041 706c 7573    N, sp_P, Aplus
+00023500: 2c20 772c 2077 2c20 302c 204e 2c0a 2020  , w, w, 0, N,.  
 00023510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023520: 2020 2020 2020 2020 6622 2073 6c61 7665          f" slave
-00023530: 7320 696e 746f 207b 7061 7274 737d 2070  s into {parts} p
-00023540: 6172 7473 2077 6974 6820 220a 2020 2020  arts with ".    
-00023550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023560: 2020 2020 2020 2020 2020 6622 7b73 7465            f"{ste
-00023570: 707d 206e 6f64 6573 2065 6163 682e 2e2e  p} nodes each...
-00023580: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
-00023590: 2020 2020 2020 2020 666f 7220 696e 6465          for inde
-000235a0: 7820 696e 2072 616e 6765 2870 6172 7473  x in range(parts
-000235b0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-000235c0: 2020 2020 2020 2020 2020 2073 7461 7274             start
-000235d0: 5f69 203d 2069 6e64 6578 202a 2073 7465  _i = index * ste
-000235e0: 700a 2020 2020 2020 2020 2020 2020 2020  p.              
-000235f0: 2020 2020 2020 2020 2020 656e 645f 6920            end_i 
-00023600: 3d20 6d69 6e28 2869 6e64 6578 202b 2031  = min((index + 1
-00023610: 2920 2a20 7374 6570 2c20 4e29 0a20 2020  ) * step, N).   
-00023620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023630: 2020 2020 2069 6620 7374 6172 745f 6920       if start_i 
-00023640: 3e3d 2065 6e64 5f69 3a0a 2020 2020 2020  >= end_i:.      
-00023650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023660: 2020 2020 2020 6272 6561 6b0a 2020 2020        break.    
-00023670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023680: 2020 2020 7468 6973 5f41 706c 7573 203d      this_Aplus =
-00023690: 2041 706c 7573 5b73 7461 7274 5f69 3a65   Aplus[start_i:e
-000236a0: 6e64 5f69 2c20 3a5d 0a20 2020 2020 2020  nd_i, :].       
-000236b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000236c0: 2074 6869 735f 7720 3d20 775b 7374 6172   this_w = w[star
-000236d0: 745f 693a 656e 645f 695d 0a20 2020 2020  t_i:end_i].     
-000236e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000236f0: 2020 2069 6620 7374 6f70 7069 6e67 5f6d     if stopping_m
-00023700: 6f64 6520 3d3d 2022 7477 696e 6e65 7373  ode == "twinness
-00023710: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
-00023720: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00023730: 6869 735f 7477 696e 6e65 7373 203d 2074  his_twinness = t
-00023740: 7769 6e6e 6573 735b 7374 6172 745f 693a  winness[start_i:
-00023750: 656e 645f 692c 203a 5d0a 2020 2020 2020  end_i, :].      
-00023760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023770: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00023780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023790: 2020 2020 7468 6973 5f74 7769 6e6e 6573      this_twinnes
-000237a0: 7320 3d20 4e6f 6e65 0a20 2020 2020 2020  s = None.       
-000237b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000237c0: 2069 6620 7365 6c66 2e73 696c 656e 6365   if self.silence
-000237d0: 5f6c 6576 656c 203c 3d20 303a 0a20 2020  _level <= 0:.   
-000237e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000237f0: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
-00023800: 2020 2073 7562 6d69 7474 696e 6722 2c20     submitting", 
-00023810: 696e 6465 7829 0a20 2020 2020 2020 2020  index).         
-00023820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023830: 2020 206d 7069 2e73 7562 6d69 745f 6361     mpi.submit_ca
-00023840: 6c6c 280a 2020 2020 2020 2020 2020 2020  ll(.            
-00023850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023860: 2020 2020 224e 6574 776f 726b 2e5f 6d70      "Network._mp
-00023870: 695f 6e73 695f 6172 656e 6173 5f62 6574  i_nsi_arenas_bet
-00023880: 7765 656e 6e65 7373 222c 0a20 2020 2020  weenness",.     
-00023890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000238a0: 2020 2020 2020 2020 2020 2028 4e2c 2073             (N, s
-000238b0: 705f 502c 2074 6869 735f 4170 6c75 732c  p_P, this_Aplus,
-000238c0: 2077 2c20 7468 6973 5f77 2c0a 2020 2020   w, this_w,.    
+00023520: 2020 2020 2020 2020 2020 6578 636c 7564            exclud
+00023530: 655f 6e65 6967 6862 6f72 732c 2073 746f  e_neighbors, sto
+00023540: 7070 696e 675f 6d6f 6465 2c20 7468 6973  pping_mode, this
+00023550: 5f74 7769 6e6e 6573 7329 0a20 2020 2020  _twinness).     
+00023560: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00023570: 6620 6572 726f 725f 6d65 7373 6167 6520  f error_message 
+00023580: 213d 2027 273a 0a20 2020 2020 2020 2020  != '':.         
+00023590: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+000235a0: 7269 6e74 2865 7272 6f72 5f6d 6573 7361  rint(error_messa
+000235b0: 6765 290a 2020 2020 2020 2020 2020 2020  ge).            
+000235c0: 2020 2020 2020 2020 2020 2020 7379 732e              sys.
+000235d0: 6578 6974 2829 0a20 2020 2020 2020 2020  exit().         
+000235e0: 2020 2020 2020 2020 2020 2074 6869 735f             this_
+000235f0: 6265 7477 6565 6e6e 6573 732c 2073 7461  betweenness, sta
+00023600: 7274 5f69 2c20 656e 645f 6920 3d20 7265  rt_i, end_i = re
+00023610: 7375 6c74 0a20 2020 2020 2020 2020 2020  sult.           
+00023620: 2020 2020 2020 2020 2063 6f6d 706f 6e65           compone
+00023630: 6e74 5f62 6574 7765 656e 6e65 7373 202b  nt_betweenness +
+00023640: 3d20 7468 6973 5f62 6574 7765 656e 6e65  = this_betweenne
+00023650: 7373 0a0a 2020 2020 2020 2020 2020 2020  ss..            
+00023660: 2020 2020 636f 6d70 6f6e 656e 745f 6265      component_be
+00023670: 7477 6565 6e6e 6573 7320 2f3d 2077 0a0a  tweenness /= w..
+00023680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023690: 2320 6865 7265 2049 2074 7269 6564 2073  # here I tried s
+000236a0: 6576 6572 616c 2077 6179 7320 746f 2063  everal ways to c
+000236b0: 6f72 7265 6374 2066 6f72 2074 6865 2066  orrect for the f
+000236c0: 6163 7420 7468 6174 206b 2069 730a 2020  act that k is.  
+000236d0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+000236e0: 6e6f 7420 6e65 6967 6862 6f75 7265 6420  not neighboured 
+000236f0: 746f 206a 2028 7365 6520 6162 6f76 6529  to j (see above)
+00023700: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00023710: 2020 2320 636f 6d70 6f6e 656e 745f 6265    # component_be
+00023720: 7477 6565 6e6e 6573 7320 2a3d 2031 2d77  tweenness *= 1-w
+00023730: 2f6e 7369 5f6b 0a20 2020 2020 2020 2020  /nsi_k.         
+00023740: 2020 2020 2020 2023 2063 6f6d 706f 6e65         # compone
+00023750: 6e74 5f62 6574 7765 656e 6e65 7373 202b  nt_betweenness +
+00023760: 3d20 7375 626e 6574 2e74 6f74 616c 5f6e  = subnet.total_n
+00023770: 6f64 655f 7765 6967 6874 2a6e 7369 5f6b  ode_weight*nsi_k
+00023780: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023790: 2023 2063 6f6d 706f 6e65 6e74 5f62 6574   # component_bet
+000237a0: 7765 656e 6e65 7373 202d 3d20 7375 626e  weenness -= subn
+000237b0: 6574 2e74 6f74 616c 5f6e 6f64 655f 7765  et.total_node_we
+000237c0: 6967 6874 2a6e 7369 5f6b 0a20 2020 2020  ight*nsi_k.     
+000237d0: 2020 2020 2020 2020 2020 2023 2069 7320             # is 
+000237e0: 7468 6973 2061 6e20 696d 7072 6f76 656d  this an improvem
+000237f0: 656e 743f 3f3f 0a0a 2020 2020 2020 2020  ent???..        
+00023800: 2020 2020 2020 2020 2320 2043 6c65 616e          #  Clean
+00023810: 2075 700a 2020 2020 2020 2020 2020 2020   up.            
+00023820: 2020 2020 6465 6c20 7375 626e 6574 0a0a      del subnet..
+00023830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023840: 2320 2043 6f70 7920 7265 7375 6c74 7320  #  Copy results 
+00023850: 696e 746f 2072 616e 646f 6d57 616c 6b42  into randomWalkB
+00023860: 6574 7765 656e 6e65 7373 4172 7261 7920  etweennessArray 
+00023870: 6174 2074 6865 2063 6f72 7265 6374 0a20  at the correct. 
+00023880: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00023890: 2020 706f 7369 7469 6f6e 730a 2020 2020    positions.    
+000238a0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000238b0: 6a2c 206e 6f64 6520 696e 2065 6e75 6d65  j, node in enume
+000238c0: 7261 7465 286e 6f64 6573 293a 0a20 2020  rate(nodes):.   
 000238d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000238e0: 2020 2020 2020 2020 2020 2020 2073 7461               sta
-000238f0: 7274 5f69 2c20 656e 645f 692c 2065 7863  rt_i, end_i, exc
-00023900: 6c75 6465 5f6e 6569 6768 626f 7273 2c0a  lude_neighbors,.
-00023910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023930: 2073 746f 7070 696e 675f 6d6f 6465 2c20   stopping_mode, 
-00023940: 7468 6973 5f74 7769 6e6e 6573 7329 2c0a  this_twinness),.
-00023950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023970: 6d6f 6475 6c65 3d22 7079 756e 6963 6f72  module="pyunicor
-00023980: 6e22 2c20 6964 3d69 6e64 6578 290a 0a20  n", id=index).. 
-00023990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000239a0: 2020 2023 2052 6574 7269 6576 6520 7265     # Retrieve re
-000239b0: 7375 6c74 7320 6f66 2061 6c6c 2073 7562  sults of all sub
-000239c0: 6d69 7465 6420 6a6f 6273 0a20 2020 2020  mited jobs.     
-000239d0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-000239e0: 6f6d 706f 6e65 6e74 5f62 6574 7765 656e  omponent_between
-000239f0: 6e65 7373 203d 206e 702e 7a65 726f 7328  ness = np.zeros(
-00023a00: 4e29 0a20 2020 2020 2020 2020 2020 2020  N).             
-00023a10: 2020 2020 2020 2066 6f72 2069 6e64 6578         for index
-00023a20: 2069 6e20 7261 6e67 6528 7061 7274 7329   in range(parts)
-00023a30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00023a40: 2020 2020 2020 2020 2020 7374 6172 745f            start_
-00023a50: 6920 3d20 696e 6465 7820 2a20 7374 6570  i = index * step
-00023a60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023a70: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00023a80: 2e73 696c 656e 6365 5f6c 6576 656c 203c  .silence_level <
-00023a90: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
-00023aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023ab0: 2070 7269 6e74 2822 2020 2072 6574 7269   print("   retri
-00023ac0: 6576 696e 6720 7265 7375 6c74 7320 6672  eving results fr
-00023ad0: 6f6d 222c 2069 6e64 6578 290a 2020 2020  om", index).    
-00023ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023af0: 2020 2020 6572 726f 725f 6d65 7373 6167      error_messag
-00023b00: 652c 2072 6573 756c 7420 3d20 6d70 692e  e, result = mpi.
-00023b10: 6765 745f 7265 7375 6c74 2869 6e64 6578  get_result(index
-00023b20: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00023b30: 2020 2020 2020 2020 2020 6966 2065 7272            if err
-00023b40: 6f72 5f6d 6573 7361 6765 2021 3d20 2727  or_message != ''
-00023b50: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00023b60: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00023b70: 696e 7428 6572 726f 725f 6d65 7373 6167  int(error_messag
-00023b80: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-00023b90: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00023ba0: 7973 2e65 7869 7428 290a 2020 2020 2020  ys.exit().      
-00023bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023bc0: 2020 7468 6973 5f62 6574 7765 656e 6e65    this_betweenne
-00023bd0: 7373 2c20 7374 6172 745f 692c 2065 6e64  ss, start_i, end
-00023be0: 5f69 203d 2072 6573 756c 740a 2020 2020  _i = result.    
-00023bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023c00: 2020 2020 636f 6d70 6f6e 656e 745f 6265      component_be
-00023c10: 7477 6565 6e6e 6573 7320 2b3d 2074 6869  tweenness += thi
-00023c20: 735f 6265 7477 6565 6e6e 6573 730a 2020  s_betweenness.  
-00023c30: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00023c40: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00023c50: 2020 2020 2020 2020 636f 6d70 6f6e 656e          componen
-00023c60: 745f 6265 7477 6565 6e6e 6573 7320 3d20  t_betweenness = 
-00023c70: 6e70 2e7a 6572 6f73 284e 290a 2020 2020  np.zeros(N).    
-00023c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023c90: 6966 2073 746f 7070 696e 675f 6d6f 6465  if stopping_mode
-00023ca0: 203d 3d20 2274 7769 6e6e 6573 7322 3a0a   == "twinness":.
-00023cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023cc0: 2020 2020 2020 2020 7468 6973 5f74 7769          this_twi
-00023cd0: 6e6e 6573 7320 3d20 7477 696e 6e65 7373  nness = twinness
-00023ce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023cf0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00023d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d10: 2020 2074 6869 735f 7477 696e 6e65 7373     this_twinness
-00023d20: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
-00023d30: 2020 2020 2020 2020 2020 2020 6572 726f              erro
-00023d40: 725f 6d65 7373 6167 652c 2072 6573 756c  r_message, resul
-00023d50: 7420 3d20 5c0a 2020 2020 2020 2020 2020  t = \.          
-00023d60: 2020 2020 2020 2020 2020 2020 2020 4e65                Ne
-00023d70: 7477 6f72 6b2e 5f6d 7069 5f6e 7369 5f61  twork._mpi_nsi_a
-00023d80: 7265 6e61 735f 6265 7477 6565 6e6e 6573  renas_betweennes
-00023d90: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
-00023da0: 2020 2020 2020 2020 2020 2020 2020 204e                 N
-00023db0: 2c20 7370 5f50 2c20 4170 6c75 732c 2077  , sp_P, Aplus, w
-00023dc0: 2c20 772c 2030 2c20 4e2c 0a20 2020 2020  , w, 0, N,.     
-00023dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023de0: 2020 2020 2020 2065 7863 6c75 6465 5f6e         exclude_n
-00023df0: 6569 6768 626f 7273 2c20 7374 6f70 7069  eighbors, stoppi
-00023e00: 6e67 5f6d 6f64 652c 2074 6869 735f 7477  ng_mode, this_tw
-00023e10: 696e 6e65 7373 290a 2020 2020 2020 2020  inness).        
-00023e20: 2020 2020 2020 2020 2020 2020 6966 2065              if e
-00023e30: 7272 6f72 5f6d 6573 7361 6765 2021 3d20  rror_message != 
-00023e40: 2727 3a0a 2020 2020 2020 2020 2020 2020  '':.            
-00023e50: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00023e60: 7428 6572 726f 725f 6d65 7373 6167 6529  t(error_message)
-00023e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023e80: 2020 2020 2020 2020 2073 7973 2e65 7869           sys.exi
-00023e90: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
-00023ea0: 2020 2020 2020 2020 7468 6973 5f62 6574          this_bet
-00023eb0: 7765 656e 6e65 7373 2c20 7374 6172 745f  weenness, start_
-00023ec0: 692c 2065 6e64 5f69 203d 2072 6573 756c  i, end_i = resul
-00023ed0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00023ee0: 2020 2020 2020 636f 6d70 6f6e 656e 745f        component_
-00023ef0: 6265 7477 6565 6e6e 6573 7320 2b3d 2074  betweenness += t
-00023f00: 6869 735f 6265 7477 6565 6e6e 6573 730a  his_betweenness.
-00023f10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023f20: 2063 6f6d 706f 6e65 6e74 5f62 6574 7765   component_betwe
-00023f30: 656e 6e65 7373 202f 3d20 770a 0a20 2020  enness /= w..   
-00023f40: 2020 2020 2020 2020 2020 2020 2023 2068               # h
-00023f50: 6572 6520 4920 7472 6965 6420 7365 7665  ere I tried seve
-00023f60: 7261 6c20 7761 7973 2074 6f20 636f 7272  ral ways to corr
-00023f70: 6563 7420 666f 7220 7468 6520 6661 6374  ect for the fact
-00023f80: 2074 6861 7420 6b20 6973 0a20 2020 2020   that k is.     
-00023f90: 2020 2020 2020 2020 2020 2023 206e 6f74             # not
-00023fa0: 206e 6569 6768 626f 7572 6564 2074 6f20   neighboured to 
-00023fb0: 6a20 2873 6565 2061 626f 7665 293a 0a20  j (see above):. 
-00023fc0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00023fd0: 2063 6f6d 706f 6e65 6e74 5f62 6574 7765   component_betwe
-00023fe0: 656e 6e65 7373 202a 3d20 312d 772f 6e73  enness *= 1-w/ns
-00023ff0: 695f 6b0a 2020 2020 2020 2020 2020 2020  i_k.            
-00024000: 2020 2020 2320 636f 6d70 6f6e 656e 745f      # component_
-00024010: 6265 7477 6565 6e6e 6573 7320 2b3d 2073  betweenness += s
-00024020: 7562 6e65 742e 746f 7461 6c5f 6e6f 6465  ubnet.total_node
-00024030: 5f77 6569 6768 742a 6e73 695f 6b0a 2020  _weight*nsi_k.  
-00024040: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00024050: 636f 6d70 6f6e 656e 745f 6265 7477 6565  component_betwee
-00024060: 6e6e 6573 7320 2d3d 2073 7562 6e65 742e  nness -= subnet.
-00024070: 746f 7461 6c5f 6e6f 6465 5f77 6569 6768  total_node_weigh
-00024080: 742a 6e73 695f 6b0a 2020 2020 2020 2020  t*nsi_k.        
-00024090: 2020 2020 2020 2020 2320 6973 2074 6869          # is thi
-000240a0: 7320 616e 2069 6d70 726f 7665 6d65 6e74  s an improvement
-000240b0: 3f3f 3f0a 0a20 2020 2020 2020 2020 2020  ???..           
-000240c0: 2020 2020 2023 2020 436c 6561 6e20 7570       #  Clean up
-000240d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000240e0: 2064 656c 2073 7562 6e65 740a 0a20 2020   del subnet..   
-000240f0: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-00024100: 436f 7079 2072 6573 756c 7473 2069 6e74  Copy results int
-00024110: 6f20 7261 6e64 6f6d 5761 6c6b 4265 7477  o randomWalkBetw
-00024120: 6565 6e6e 6573 7341 7272 6179 2061 7420  eennessArray at 
-00024130: 7468 6520 636f 7272 6563 740a 2020 2020  the correct.    
-00024140: 2020 2020 2020 2020 2020 2020 2320 2070              #  p
-00024150: 6f73 6974 696f 6e73 0a20 2020 2020 2020  ositions.       
-00024160: 2020 2020 2020 2020 2066 6f72 206a 2c20           for j, 
-00024170: 6e6f 6465 2069 6e20 656e 756d 6572 6174  node in enumerat
-00024180: 6528 6e6f 6465 7329 3a0a 2020 2020 2020  e(nodes):.      
-00024190: 2020 2020 2020 2020 2020 2020 2020 6e73                ns
-000241a0: 695f 6172 656e 6173 5f62 6574 7765 656e  i_arenas_between
-000241b0: 6e65 7373 5b6e 6f64 655d 203d 2063 6f6d  ness[node] = com
-000241c0: 706f 6e65 6e74 5f62 6574 7765 656e 6e65  ponent_betweenne
-000241d0: 7373 5b6a 5d0a 0a20 2020 2020 2020 2069  ss[j]..        i
-000241e0: 6620 7365 6c66 2e73 696c 656e 6365 5f6c  f self.silence_l
-000241f0: 6576 656c 203c 3d20 303a 0a20 2020 2020  evel <= 0:.     
-00024200: 2020 2020 2020 2070 7269 6e74 2822 2e2e         print("..
-00024210: 2e74 6f6f 6b22 2c20 7469 6d65 2e74 696d  .took", time.tim
-00024220: 6528 292d 7430 2c20 2273 6563 6f6e 6473  e()-t0, "seconds
-00024230: 2229 0a0a 2020 2020 2020 2020 7265 7475  ")..        retu
-00024240: 726e 206e 7369 5f61 7265 6e61 735f 6265  rn nsi_arenas_be
-00024250: 7477 6565 6e6e 6573 730a 0a20 2020 2023  tweenness..    #
-00024260: 2064 6561 6374 6976 6174 6564 2061 6e64   deactivated and
-00024270: 2072 6570 6c61 6365 6420 6279 2063 6f72   replaced by cor
-00024280: 7265 6374 6564 2061 6e64 2066 6173 7465  rected and faste
-00024290: 7220 7665 7273 696f 6e20 2873 6565 2062  r version (see b
-000242a0: 656c 6f77 293a 0a20 2020 2023 2054 4f44  elow):.    # TOD
-000242b0: 4f3a 2072 656d 6f76 6520 6166 7465 7220  O: remove after 
-000242c0: 7265 6772 6573 7369 6f6e 2074 6573 740a  regression test.
-000242d0: 2020 2020 6465 6620 5f6e 6577 6d61 6e5f      def _newman_
-000242e0: 6265 7477 6565 6e6e 6573 735f 6261 646c  betweenness_badl
-000242f0: 7928 7365 6c66 2c20 6c69 6e6b 5f61 7474  y(self, link_att
-00024300: 7269 6275 7465 3d4e 6f6e 6529 3a0a 2020  ribute=None):.  
-00024310: 2020 2020 2020 7072 696e 7428 2257 4152        print("WAR
-00024320: 4e49 4e47 3a20 5f6e 6577 6d61 6e5f 6265  NING: _newman_be
-00024330: 7477 6565 6e6e 6573 735f 6261 646c 7928  tweenness_badly(
-00024340: 2920 6973 2064 6570 7265 6361 7465 6421  ) is deprecated!
-00024350: 2229 0a0a 2020 2020 2020 2020 2320 2049  ")..        #  I
-00024360: 6e69 7469 616c 697a 6520 7468 6520 6172  nitialize the ar
-00024370: 7261 7920 746f 2068 6f6c 6420 7261 6e64  ray to hold rand
-00024380: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
-00024390: 6573 730a 2020 2020 2020 2020 7261 6e64  ess.        rand
-000243a0: 6f6d 5761 6c6b 4265 7477 6565 6e6e 6573  omWalkBetweennes
-000243b0: 7320 3d20 6e70 2e7a 6572 6f73 2873 656c  s = np.zeros(sel
-000243c0: 662e 4e29 0a0a 2020 2020 2020 2020 2320  f.N)..        # 
-000243d0: 2052 616e 646f 6d20 7761 6c6b 2062 6574   Random walk bet
-000243e0: 7765 656e 6e65 7373 2068 6173 2074 6f20  weenness has to 
-000243f0: 6265 2063 616c 6375 6c61 7465 6420 666f  be calculated fo
-00024400: 7220 6561 6368 2063 6f6d 706f 6e65 6e74  r each component
-00024410: 0a20 2020 2020 2020 2023 2020 7365 7061  .        #  sepa
-00024420: 7261 7465 6c79 2e20 5468 6572 6566 6f72  rately. Therefor
-00024430: 6520 6765 7420 6469 6666 6572 656e 7420  e get different 
-00024440: 636f 6d70 6f6e 656e 7473 206f 6620 7468  components of th
-00024450: 6520 6772 6170 6820 6669 7273 740a 2020  e graph first.  
-00024460: 2020 2020 2020 636f 6d70 6f6e 656e 7473        components
-00024470: 203d 2073 656c 662e 6772 6170 682e 636c   = self.graph.cl
-00024480: 7573 7465 7273 2829 0a0a 2020 2020 2020  usters()..      
-00024490: 2020 666f 7220 692c 2063 6f6d 7020 696e    for i, comp in
-000244a0: 2065 6e75 6d65 7261 7465 2863 6f6d 706f   enumerate(compo
-000244b0: 6e65 6e74 7329 3a0a 2020 2020 2020 2020  nents):.        
-000244c0: 2020 2020 2320 2049 6620 7468 6520 636f      #  If the co
-000244d0: 6d70 6f6e 656e 7420 6861 7320 7369 7a65  mponent has size
-000244e0: 2031 2c20 7365 7420 7261 6e64 6f6d 2077   1, set random w
-000244f0: 616c 6b20 6265 7477 6565 6e6e 6573 7320  alk betweenness 
-00024500: 746f 207a 6572 6f0a 2020 2020 2020 2020  to zero.        
-00024510: 2020 2020 6966 206c 656e 2863 6f6d 7029      if len(comp)
-00024520: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
-00024530: 2020 2020 2020 2072 616e 646f 6d57 616c         randomWal
-00024540: 6b42 6574 7765 656e 6e65 7373 5b63 6f6d  kBetweenness[com
-00024550: 705b 305d 5d20 3d20 300a 2020 2020 2020  p[0]] = 0.      
-00024560: 2020 2020 2020 2320 2046 6f72 206c 6172        #  For lar
-00024570: 6765 7220 636f 6d70 6f6e 656e 7473 2c20  ger components, 
-00024580: 636f 6e74 696e 7565 2077 6974 6820 7468  continue with th
-00024590: 6520 6361 6c63 756c 6174 696f 6e0a 2020  e calculation.  
-000245a0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-000245b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000245c0: 2320 2047 6574 2074 6865 2073 7562 6772  #  Get the subgr
-000245d0: 6170 6820 636f 7272 6573 706f 6e64 696e  aph correspondin
-000245e0: 6720 746f 2063 6f6d 706f 6e65 6e74 2069  g to component i
-000245f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00024600: 2073 7562 6772 6170 6820 3d20 636f 6d70   subgraph = comp
-00024610: 6f6e 656e 7473 2e73 7562 6772 6170 6828  onents.subgraph(
-00024620: 6929 0a0a 2020 2020 2020 2020 2020 2020  i)..            
-00024630: 2020 2020 2320 2047 6574 2074 6865 2073      #  Get the s
-00024640: 7562 6772 6170 6820 6164 6a61 6365 6e63  ubgraph adjacenc
-00024650: 7920 6d61 7472 6978 0a20 2020 2020 2020  y matrix.       
-00024660: 2020 2020 2020 2020 2061 646a 6163 656e           adjacen
-00024670: 6379 203d 206e 702e 6172 7261 7928 7375  cy = np.array(su
-00024680: 6267 7261 7068 2e67 6574 5f61 646a 6163  bgraph.get_adjac
-00024690: 656e 6379 2874 7970 653d 3229 2e64 6174  ency(type=2).dat
-000246a0: 6129 0a0a 2020 2020 2020 2020 2020 2020  a)..            
-000246b0: 2020 2020 2320 2047 656e 6572 6174 6520      #  Generate 
-000246c0: 6120 4e65 7477 6f72 6b20 6f62 6a65 6374  a Network object
-000246d0: 2072 6570 7265 7365 6e74 696e 6720 7468   representing th
-000246e0: 6520 7375 6267 7261 7068 0a20 2020 2020  e subgraph.     
-000246f0: 2020 2020 2020 2020 2020 2073 7562 6e65             subne
-00024700: 7477 6f72 6b20 3d20 4e65 7477 6f72 6b28  twork = Network(
-00024710: 6164 6a61 6365 6e63 792c 2064 6972 6563  adjacency, direc
-00024720: 7465 643d 5472 7565 290a 0a20 2020 2020  ted=True)..     
-00024730: 2020 2020 2020 2020 2020 2023 2020 4765             #  Ge
-00024740: 7420 7468 6520 6e75 6d62 6572 206f 6620  t the number of 
-00024750: 6e6f 6465 7320 6f66 2074 6865 2073 7562  nodes of the sub
-00024760: 6772 6170 6820 2874 6865 2063 6f6d 706f  graph (the compo
-00024770: 6e65 6e74 2073 697a 6529 0a20 2020 2020  nent size).     
-00024780: 2020 2020 2020 2020 2020 206e 4e6f 6465             nNode
-00024790: 7320 3d20 7375 626e 6574 776f 726b 2e4e  s = subnetwork.N
-000247a0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000247b0: 2020 2320 2049 6e69 7469 616c 697a 6520    #  Initialize 
-000247c0: 7468 6520 5257 4220 6172 7261 790a 2020  the RWB array.  
-000247d0: 2020 2020 2020 2020 2020 2020 2020 7277                rw
-000247e0: 6220 3d20 6e70 2e7a 6572 6f73 286e 4e6f  b = np.zeros(nNo
-000247f0: 6465 7329 0a0a 2020 2020 2020 2020 2020  des)..          
-00024800: 2020 2020 2020 2320 4865 6974 7a69 6720        # Heitzig 
-00024810: 4649 584d 453a 206c 6170 6c61 6369 616e  FIXME: laplacian
-00024820: 2069 7320 6661 756c 7479 2066 6f72 2075   is faulty for u
-00024830: 6e64 6972 6563 7465 640a 2020 2020 2020  ndirected.      
-00024840: 2020 2020 2020 2020 2020 2320 6e65 7477            # netw
-00024850: 6f72 6b73 2073 696e 6365 2072 6f77 2d73  orks since row-s
-00024860: 756d 2021 3d20 303a 2047 6574 2074 6865  um != 0: Get the
-00024870: 2028 6469 7265 6374 6564 2061 6e64 2077   (directed and w
-00024880: 6569 6768 7465 6429 0a20 2020 2020 2020  eighted).       
-00024890: 2020 2020 2020 2020 2023 2067 7261 7068           # graph
-000248a0: 204c 6170 6c61 6369 616e 0a20 2020 2020   Laplacian.     
-000248b0: 2020 2020 2020 2020 2020 206c 6170 6c61             lapla
-000248c0: 6369 616e 203d 205c 0a20 2020 2020 2020  cian = \.       
-000248d0: 2020 2020 2020 2020 2020 2020 2073 7562               sub
-000248e0: 6e65 7477 6f72 6b2e 6c61 706c 6163 6961  network.laplacia
-000248f0: 6e28 6c69 6e6b 5f61 7474 7269 6275 7465  n(link_attribute
-00024900: 292e 6173 7479 7065 2827 666c 6f61 7436  ).astype('float6
-00024910: 3427 290a 0a20 2020 2020 2020 2020 2020  4')..           
-00024920: 2020 2020 2023 2020 5265 6d6f 7665 2074       #  Remove t
-00024930: 6865 206c 6173 7420 726f 7720 616e 6420  he last row and 
-00024940: 636f 6c75 6d6e 2074 6f20 6d61 6b65 2074  column to make t
-00024950: 6865 206d 6174 7269 7820 696e 7665 7274  he matrix invert
-00024960: 6962 6c65 0a20 2020 2020 2020 2020 2020  ible.           
-00024970: 2020 2020 206c 6170 6c61 6369 616e 203d       laplacian =
-00024980: 206c 6170 6c61 6369 616e 5b3a 2d31 2c20   laplacian[:-1, 
-00024990: 3a2d 315d 0a0a 2020 2020 2020 2020 2020  :-1]..          
-000249a0: 2020 2020 2020 2320 2049 6e76 6572 7420        #  Invert 
-000249b0: 7468 6520 7265 6475 6365 6420 6c61 706c  the reduced lapl
-000249c0: 6163 6961 6e20 6d61 7472 6978 2061 6e64  acian matrix and
-000249d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000249e0: 2054 203d 206e 702e 6c69 6e61 6c67 2e69   T = np.linalg.i
-000249f0: 6e76 286c 6170 6c61 6369 616e 290a 0a20  nv(laplacian).. 
-00024a00: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00024a10: 2020 436c 6561 6e20 7570 0a20 2020 2020    Clean up.     
-00024a20: 2020 2020 2020 2020 2020 2064 656c 2073             del s
-00024a30: 7562 6772 6170 682c 206c 6170 6c61 6369  ubgraph, laplaci
-00024a40: 616e 0a0a 2020 2020 2020 2020 2020 2020  an..            
-00024a50: 2020 2020 2320 2061 6464 2072 6f77 2061      #  add row a
-00024a60: 6e64 2063 6f6c 756d 6e20 6f66 207a 6572  nd column of zer
-00024a70: 6f73 2074 6f20 5420 6174 2074 6865 2070  os to T at the p
-00024a80: 6f73 6974 696f 6e20 7468 6579 2077 6572  osition they wer
-00024a90: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00024aa0: 2020 2320 2072 656d 6f76 6564 2066 726f    #  removed fro
-00024ab0: 6d20 7468 6520 6c61 706c 6163 6961 6e20  m the laplacian 
-00024ac0: 6d61 7472 6978 2028 7468 6520 6c61 7374  matrix (the last
-00024ad0: 2072 6f77 2061 6e64 2063 6f6c 756d 6e29   row and column)
-00024ae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00024af0: 2054 203d 206e 702e 7673 7461 636b 2828   T = np.vstack((
-00024b00: 542c 206e 702e 7a65 726f 7328 6e4e 6f64  T, np.zeros(nNod
-00024b10: 6573 202d 2031 2929 290a 2020 2020 2020  es - 1))).      
-00024b20: 2020 2020 2020 2020 2020 5420 3d20 6e70            T = np
-00024b30: 2e61 7363 6f6e 7469 6775 6f75 7361 7272  .ascontiguousarr
-00024b40: 6179 286e 702e 6873 7461 636b 2828 542c  ay(np.hstack((T,
-00024b50: 206e 702e 7a65 726f 7328 286e 4e6f 6465   np.zeros((nNode
-00024b60: 732c 2031 2929 2929 290a 0a20 2020 2020  s, 1)))))..     
-00024b70: 2020 2020 2020 2020 2020 206e 4e6f 6465             nNode
-00024b80: 7320 3d20 666c 6f61 7428 6e4e 6f64 6573  s = float(nNodes
-00024b90: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-00024ba0: 2020 2023 2020 4361 6c63 756c 6174 6520     #  Calculate 
-00024bb0: 7468 6520 7261 6e64 6f6d 2077 616c 6b20  the random walk 
-00024bc0: 6265 7477 6565 6e6e 6573 7320 696e 2043  betweenness in C
-00024bd0: 2b2b 2075 7369 6e67 2043 7974 686f 6e0a  ++ using Cython.
-00024be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024bf0: 2320 6164 6465 6420 2d77 2073 696e 6365  # added -w since
-00024c00: 206e 756d 6572 6f75 7320 7761 726e 696e   numerous warnin
-00024c10: 6773 206f 6620 7479 7065 2022 5761 726e  gs of type "Warn
-00024c20: 756e 673a 2076 6572 616c 7465 7465 0a20  ung: veraltete. 
-00024c30: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00024c40: 204b 6f6e 7665 7274 6965 7275 6e67 2076   Konvertierung v
-00024c50: 6f6e 205a 6569 6368 656e 6b65 7474 656e  on Zeichenketten
-00024c60: 6b6f 6e73 7461 6e74 6520 696e 20c2 bb63  konstante in ..c
-00024c70: 6861 722a c2ab 220a 2020 2020 2020 2020  har*..".        
-00024c80: 2020 2020 2020 2020 2320 6f63 6375 7272          # occurr
-00024c90: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
-00024ca0: 2020 2020 7277 6220 3d20 5f6e 6577 6d61      rwb = _newma
-00024cb0: 6e5f 6265 7477 6565 6e6e 6573 735f 6261  n_betweenness_ba
-00024cc0: 646c 795f 6379 7468 6f6e 2861 646a 6163  dly_cython(adjac
-00024cd0: 656e 6379 2e61 7374 7970 6528 696e 7429  ency.astype(int)
-00024ce0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00024cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024d10: 2020 2020 2020 2020 2054 2c20 7277 622c           T, rwb,
-00024d20: 2073 656c 662e 4e29 0a0a 2020 2020 2020   self.N)..      
-00024d30: 2020 2020 2020 2020 2020 2320 204e 6f72            #  Nor
-00024d40: 6d61 6c69 7a65 2052 5742 2062 7920 636f  malize RWB by co
-00024d50: 6d70 6f6e 656e 7420 7369 7a65 0a20 2020  mponent size.   
-00024d60: 2020 2020 2020 2020 2020 2020 2072 7762               rwb
-00024d70: 202a 3d20 6e4e 6f64 6573 0a0a 2020 2020   *= nNodes..    
-00024d80: 2020 2020 2020 2020 2020 2020 2320 2047              #  G
-00024d90: 6574 2074 6865 206c 6973 7420 6f66 2076  et the list of v
-00024da0: 6572 7465 7820 6e75 6d62 6572 7320 696e  ertex numbers in
-00024db0: 2074 6865 2073 7562 6772 6170 680a 2020   the subgraph.  
-00024dc0: 2020 2020 2020 2020 2020 2020 2020 7665                ve
-00024dd0: 7274 6578 4c69 7374 203d 2063 6f6d 700a  rtexList = comp.
-00024de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00024df0: 2023 2020 436f 7079 2072 6573 756c 7473   #  Copy results
-00024e00: 2069 6e74 6f20 7261 6e64 6f6d 5761 6c6b   into randomWalk
-00024e10: 4265 7477 6565 6e6e 6573 7341 7272 6179  BetweennessArray
-00024e20: 2061 7420 7468 6520 636f 7272 6563 740a   at the correct.
-00024e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024e40: 2320 2070 6f73 6974 696f 6e73 0a20 2020  #  positions.   
-00024e50: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00024e60: 206a 2c20 7673 2069 6e20 656e 756d 6572   j, vs in enumer
-00024e70: 6174 6528 7665 7274 6578 4c69 7374 293a  ate(vertexList):
-00024e80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00024e90: 2020 2020 2072 616e 646f 6d57 616c 6b42       randomWalkB
-00024ea0: 6574 7765 656e 6e65 7373 5b76 735d 203d  etweenness[vs] =
-00024eb0: 2072 7762 5b6a 5d0a 0a20 2020 2020 2020   rwb[j]..       
-00024ec0: 2072 6574 7572 6e20 7261 6e64 6f6d 5761   return randomWa
-00024ed0: 6c6b 4265 7477 6565 6e6e 6573 730a 0a20  lkBetweenness.. 
-00024ee0: 2020 2023 206d 7563 6820 6661 7374 6572     # much faster
-00024ef0: 2028 616e 6420 636f 7272 6563 7465 6429   (and corrected)
-00024f00: 2076 6572 7369 6f6e 206f 6620 7468 6520   version of the 
-00024f10: 7072 6563 6564 696e 673a 0a20 2020 2040  preceding:.    @
-00024f20: 6361 6368 6564 5f63 6f6e 7374 2827 6261  cached_const('ba
-00024f30: 7365 272c 2027 6e65 776d 616e 2062 7477  se', 'newman btw
-00024f40: 272c 2022 4e65 776d 616e 2773 2072 616e  ', "Newman's ran
-00024f50: 646f 6d20 7761 6c6b 2062 6574 7765 656e  dom walk between
-00024f60: 6e65 7373 2229 0a20 2020 2064 6566 206e  ness").    def n
-00024f70: 6577 6d61 6e5f 6265 7477 6565 6e6e 6573  ewman_betweennes
-00024f80: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
-00024f90: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
-00024fa0: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
-00024fb0: 726e 204e 6577 6d61 6e27 7320 7261 6e64  rn Newman's rand
-00024fc0: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
-00024fd0: 6573 732e 0a0a 2020 2020 2020 2020 5468  ess...        Th
-00024fe0: 6973 206d 6561 7375 7265 7320 686f 7720  is measures how 
-00024ff0: 6f66 7465 6e20 6120 7261 6e64 6f6d 2077  often a random w
-00025000: 616c 6b20 7365 6172 6368 2066 6f72 2061  alk search for a
-00025010: 2072 616e 646f 6d20 7461 7267 6574 206e   random target n
-00025020: 6f64 650a 2020 2020 2020 2020 6672 6f6d  ode.        from
-00025030: 2061 2072 616e 646f 6d20 736f 7572 6365   a random source
-00025040: 206e 6f64 6520 6973 2065 7870 6563 7465   node is expecte
-00025050: 6420 746f 2070 6173 7320 7468 6973 206e  d to pass this n
-00025060: 6f64 652c 206e 6f74 2063 6f75 6e74 696e  ode, not countin
-00025070: 670a 2020 2020 2020 2020 7768 656e 2074  g.        when t
-00025080: 6865 2077 616c 6b20 7265 7475 726e 7320  he walk returns 
-00025090: 616c 6f6e 6720 6120 6c69 6e6b 2069 7420  along a link it 
-000250a0: 746f 6f6b 2062 6566 6f72 6520 746f 206c  took before to l
-000250b0: 6561 7665 2074 6865 206e 6f64 652e 0a20  eave the node.. 
-000250c0: 2020 2020 2020 2028 7365 6520 5b4e 6577         (see [New
-000250d0: 6d61 6e32 3030 355d 5f29 0a0a 2020 2020  man2005]_)..    
-000250e0: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
-000250f0: 0a0a 2020 2020 2020 2020 3e3e 3e20 7228  ..        >>> r(
-00025100: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
-00025110: 744e 6574 776f 726b 2829 2e6e 6577 6d61  tNetwork().newma
-00025120: 6e5f 6265 7477 6565 6e6e 6573 7328 2929  n_betweenness())
-00025130: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
-00025140: 7469 6e67 204e 6577 6d61 6e27 7320 7261  ting Newman's ra
-00025150: 6e64 6f6d 2077 616c 6b20 6265 7477 6565  ndom walk betwee
-00025160: 6e6e 6573 732e 2e2e 0a20 2020 2020 2020  nness....       
-00025170: 2020 2020 2867 6961 6e74 2063 6f6d 706f      (giant compo
-00025180: 6e65 6e74 2073 697a 653a 2036 2028 312e  nent size: 6 (1.
-00025190: 3029 290a 2020 2020 2020 2020 6172 7261  0)).        arra
-000251a0: 7928 5b20 342e 3138 3138 2c20 332e 3431  y([ 4.1818, 3.41
-000251b0: 3832 2c20 322e 3530 3931 2c20 332e 3031  82, 2.5091, 3.01
-000251c0: 3832 2c20 332e 3620 2c20 322e 205d 290a  82, 3.6 , 2. ]).
-000251d0: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-000251e0: 2031 6420 6e75 6d70 7920 6172 7261 7920   1d numpy array 
-000251f0: 5b6e 6f64 655d 206f 6620 666c 6f61 7473  [node] of floats
-00025200: 203e 3d20 300a 2020 2020 2020 2020 2222   >= 0.        ""
-00025210: 220a 2020 2020 2020 2020 7430 203d 2074  ".        t0 = t
-00025220: 696d 652e 7469 6d65 2829 0a0a 2020 2020  ime.time()..    
-00025230: 2020 2020 2320 2049 6e69 7469 616c 697a      #  Initializ
-00025240: 6520 7468 6520 6172 7261 7920 746f 2068  e the array to h
-00025250: 6f6c 6420 7261 6e64 6f6d 2077 616c 6b20  old random walk 
-00025260: 6265 7477 6565 6e6e 6573 730a 2020 2020  betweenness.    
-00025270: 2020 2020 6e65 776d 616e 5f62 6574 7765      newman_betwe
-00025280: 656e 6e65 7373 203d 206e 702e 7a65 726f  enness = np.zero
-00025290: 7328 7365 6c66 2e4e 290a 0a20 2020 2020  s(self.N)..     
-000252a0: 2020 2023 2020 5261 6e64 6f6d 2077 616c     #  Random wal
-000252b0: 6b20 6265 7477 6565 6e6e 6573 7320 6861  k betweenness ha
-000252c0: 7320 746f 2062 6520 6361 6c63 756c 6174  s to be calculat
-000252d0: 6564 2066 6f72 2065 6163 6820 636f 6d70  ed for each comp
-000252e0: 6f6e 656e 740a 2020 2020 2020 2020 2320  onent.        # 
-000252f0: 2073 6570 6172 6174 656c 792e 2054 6865   separately. The
-00025300: 7265 666f 7265 2067 6574 2064 6966 6665  refore get diffe
-00025310: 7265 6e74 2063 6f6d 706f 6e65 6e74 7320  rent components 
-00025320: 6f66 2074 6865 2067 7261 7068 2066 6972  of the graph fir
-00025330: 7374 0a20 2020 2020 2020 2063 6f6d 706f  st.        compo
-00025340: 6e65 6e74 7320 3d20 7365 6c66 2e67 7261  nents = self.gra
-00025350: 7068 2e63 6c75 7374 6572 7328 290a 0a20  ph.clusters().. 
-00025360: 2020 2020 2020 2023 2020 5072 696e 7420         #  Print 
-00025370: 6769 616e 7420 636f 6d70 6f6e 656e 7420  giant component 
-00025380: 7369 7a65 0a20 2020 2020 2020 2069 6620  size.        if 
-00025390: 7365 6c66 2e73 696c 656e 6365 5f6c 6576  self.silence_lev
-000253a0: 656c 203c 3d20 313a 0a20 2020 2020 2020  el <= 1:.       
-000253b0: 2020 2020 2070 7269 6e74 2822 2020 2028       print("   (
-000253c0: 6769 616e 7420 636f 6d70 6f6e 656e 7420  giant component 
-000253d0: 7369 7a65 3a20 220a 2020 2020 2020 2020  size: ".        
-000253e0: 2020 2020 2020 2020 2020 2b20 7374 7228            + str(
-000253f0: 636f 6d70 6f6e 656e 7473 2e67 6961 6e74  components.giant
-00025400: 2829 2e76 636f 756e 7428 2929 202b 2022  ().vcount()) + "
-00025410: 2028 220a 2020 2020 2020 2020 2020 2020   (".            
-00025420: 2020 2020 2020 2b20 7374 7228 636f 6d70        + str(comp
-00025430: 6f6e 656e 7473 2e67 6961 6e74 2829 2e76  onents.giant().v
-00025440: 636f 756e 7428 290a 2020 2020 2020 2020  count().        
-00025450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025460: 2f20 666c 6f61 7428 7365 6c66 2e67 7261  / float(self.gra
-00025470: 7068 2e76 636f 756e 7428 2929 2920 2b20  ph.vcount())) + 
-00025480: 2229 2922 290a 0a20 2020 2020 2020 2066  "))")..        f
-00025490: 6f72 2063 2c20 636f 6d70 2069 6e20 656e  or c, comp in en
-000254a0: 756d 6572 6174 6528 636f 6d70 6f6e 656e  umerate(componen
-000254b0: 7473 293a 0a20 2020 2020 2020 2020 2020  ts):.           
-000254c0: 2023 2020 4966 2074 6865 2063 6f6d 706f   #  If the compo
-000254d0: 6e65 6e74 2068 6173 2073 697a 6520 312c  nent has size 1,
-000254e0: 2073 6574 2072 616e 646f 6d20 7761 6c6b   set random walk
-000254f0: 2062 6574 7765 656e 6e65 7373 2074 6f20   betweenness to 
-00025500: 7a65 726f 0a20 2020 2020 2020 2020 2020  zero.           
-00025510: 2069 6620 6c65 6e28 636f 6d70 2920 3c20   if len(comp) < 
-00025520: 323a 0a20 2020 2020 2020 2020 2020 2020  2:.             
-00025530: 2020 206e 6577 6d61 6e5f 6265 7477 6565     newman_betwee
-00025540: 6e6e 6573 735b 636f 6d70 5b30 5d5d 203d  nness[comp[0]] =
-00025550: 2030 0a20 2020 2020 2020 2020 2020 2023   0.            #
-00025560: 2020 466f 7220 6c61 7267 6572 2063 6f6d    For larger com
-00025570: 706f 6e65 6e74 732c 2063 6f6e 7469 6e75  ponents, continu
-00025580: 6520 7769 7468 2074 6865 2063 616c 6375  e with the calcu
-00025590: 6c61 7469 6f6e 0a20 2020 2020 2020 2020  lation.         
-000255a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000255b0: 2020 2020 2020 2020 2023 2020 4765 7420           #  Get 
-000255c0: 7468 6520 7375 6267 7261 7068 2041 206d  the subgraph A m
-000255d0: 6174 7269 7820 636f 7272 6573 706f 6e64  atrix correspond
-000255e0: 696e 6720 746f 2063 6f6d 706f 6e65 6e74  ing to component
-000255f0: 2063 0a20 2020 2020 2020 2020 2020 2020   c.             
-00025600: 2020 2073 7562 6772 6170 6820 3d20 636f     subgraph = co
-00025610: 6d70 6f6e 656e 7473 2e73 7562 6772 6170  mponents.subgrap
-00025620: 6828 6329 0a20 2020 2020 2020 2020 2020  h(c).           
-00025630: 2020 2020 2041 203d 206e 702e 6172 7261       A = np.arra
-00025640: 7928 7375 6267 7261 7068 2e67 6574 5f61  y(subgraph.get_a
-00025650: 646a 6163 656e 6379 2874 7970 653d 3229  djacency(type=2)
-00025660: 2e64 6174 612c 0a20 2020 2020 2020 2020  .data,.         
-00025670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025680: 2020 2020 6474 7970 653d 6e70 2e69 6e74      dtype=np.int
-00025690: 3829 0a0a 2020 2020 2020 2020 2020 2020  8)..            
-000256a0: 2020 2020 2320 2047 656e 6572 6174 6520      #  Generate 
-000256b0: 6120 4e65 7477 6f72 6b20 6f62 6a65 6374  a Network object
-000256c0: 2072 6570 7265 7365 6e74 696e 6720 7468   representing th
-000256d0: 6520 7375 6267 7261 7068 0a20 2020 2020  e subgraph.     
-000256e0: 2020 2020 2020 2020 2020 2073 7562 6e65             subne
-000256f0: 7477 6f72 6b20 3d20 4e65 7477 6f72 6b28  twork = Network(
-00025700: 6164 6a61 6365 6e63 793d 412c 2064 6972  adjacency=A, dir
-00025710: 6563 7465 643d 4661 6c73 6529 0a20 2020  ected=False).   
-00025720: 2020 2020 2020 2020 2020 2020 204e 2c20               N, 
-00025730: 7370 5f41 203d 2073 7562 6e65 7477 6f72  sp_A = subnetwor
-00025740: 6b2e 4e2c 2073 7562 6e65 7477 6f72 6b2e  k.N, subnetwork.
-00025750: 7370 5f41 0a0a 2020 2020 2020 2020 2020  sp_A..          
-00025760: 2020 2020 2020 2320 4b69 7263 6868 6f66        # Kirchhof
-00025770: 6620 6d61 7472 6978 0a20 2020 2020 2020  f matrix.       
-00025780: 2020 2020 2020 2020 2073 705f 4d20 3d20           sp_M = 
-00025790: 7370 2e64 6961 6773 285b 7375 626e 6574  sp.diags([subnet
-000257a0: 776f 726b 2e69 6e64 6567 7265 6528 295d  work.indegree()]
-000257b0: 2c20 5b30 5d2c 0a20 2020 2020 2020 2020  , [0],.         
-000257c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000257d0: 2020 2020 2020 2073 6861 7065 3d28 4e2c         shape=(N,
-000257e0: 204e 292c 2066 6f72 6d61 743d 2763 7363   N), format='csc
-000257f0: 2729 202d 2073 705f 410a 0a20 2020 2020  ') - sp_A..     
-00025800: 2020 2020 2020 2020 2020 2023 2069 6e76             # inv
-00025810: 6572 7420 6974 2077 6974 686f 7574 206c  ert it without l
-00025820: 6173 7420 726f 772f 636f 6c0a 2020 2020  ast row/col.    
-00025830: 2020 2020 2020 2020 2020 2020 2320 4649              # FI
-00025840: 584d 453a 2069 6e20 7261 7265 2063 6173  XME: in rare cas
-00025850: 6573 2028 7768 656e 2074 6865 7265 2069  es (when there i
-00025860: 7320 616e 2065 7861 6374 2074 7769 6e20  s an exact twin 
-00025870: 746f 2074 6865 206c 6173 740a 2020 2020  to the last.    
-00025880: 2020 2020 2020 2020 2020 2020 2320 6e6f              # no
-00025890: 6465 292c 2074 6869 7320 6d69 6768 7420  de), this might 
-000258a0: 6e6f 7420 6265 2069 6e76 6572 7469 626c  not be invertibl
-000258b0: 6520 616e 6420 6120 6469 6666 6572 656e  e and a differen
-000258c0: 7420 726f 772f 636f 6c0a 2020 2020 2020  t row/col.      
-000258d0: 2020 2020 2020 2020 2020 2320 776f 756c            # woul
-000258e0: 6420 6e65 6564 2074 6f20 6265 2072 656d  d need to be rem
-000258f0: 6f76 6564 210a 2020 2020 2020 2020 2020  oved!.          
-00025900: 2020 2020 2020 5620 3d20 7370 2e6c 696c        V = sp.lil
-00025910: 5f6d 6174 7269 7828 284e 2c20 4e29 290a  _matrix((N, N)).
-00025920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025930: 565b 3a2d 312c 203a 2d31 5d20 3d20 696e  V[:-1, :-1] = in
-00025940: 7628 7370 5f4d 5b3a 2d31 2c20 3a2d 315d  v(sp_M[:-1, :-1]
-00025950: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00025960: 2020 5620 3d20 562e 410a 2020 2020 2020    V = V.A.      
-00025970: 2020 2020 2020 2020 2020 6465 6c20 7375            del su
-00025980: 6267 7261 7068 2c20 7375 626e 6574 776f  bgraph, subnetwo
-00025990: 726b 2c20 7370 5f41 2c20 7370 5f4d 0a0a  rk, sp_A, sp_M..
-000259a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000259b0: 2320 2043 616c 6375 6c61 7465 2074 6865  #  Calculate the
-000259c0: 2072 616e 646f 6d20 7761 6c6b 2062 6574   random walk bet
-000259d0: 7765 656e 6e65 7373 2069 6e20 432b 2b20  weenness in C++ 
-000259e0: 7573 696e 6720 5765 6176 650a 2020 2020  using Weave.    
-000259f0: 2020 2020 2020 2020 2020 2020 636f 6d70              comp
-00025a00: 6f6e 656e 745f 6265 7477 6565 6e6e 6573  onent_betweennes
-00025a10: 7320 3d20 6e70 2e7a 6572 6f73 284e 290a  s = np.zeros(N).
-00025a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025a30: 6966 206d 7069 2e61 7661 696c 6162 6c65  if mpi.available
-00025a40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00025a50: 2020 2020 2020 2320 6465 7465 726d 696e        # determin
-00025a60: 6520 696e 2068 6f77 206d 616e 7920 7061  e in how many pa
-00025a70: 7274 7320 7765 2073 706c 6974 2074 6865  rts we split the
-00025a80: 206f 7574 6572 206c 6f6f 703a 0a20 2020   outer loop:.   
-00025a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025aa0: 2070 6172 7473 203d 206d 6178 2831 2c20   parts = max(1, 
-00025ab0: 696e 7428 6e70 2e63 6569 6c28 6d69 6e28  int(np.ceil(min(
-00025ac0: 286d 7069 2e73 697a 652d 3129 202a 2031  (mpi.size-1) * 1
-00025ad0: 302e 302c 0a20 2020 2020 2020 2020 2020  0.0,.           
-00025ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025b00: 2020 2020 2020 2020 302e 3120 2a20 4e29          0.1 * N)
-00025b10: 2929 290a 2020 2020 2020 2020 2020 2020  ))).            
-00025b20: 2020 2020 2020 2020 2320 636f 7272 6573          # corres
-00025b30: 706f 6e64 696e 6720 7374 6570 2073 697a  ponding step siz
-00025b40: 6520 666f 7220 6320 696e 6465 7820 6f66  e for c index of
-00025b50: 206f 7574 6572 206c 6f6f 703a 0a20 2020   outer loop:.   
-00025b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025b70: 2073 7465 7020 3d20 696e 7428 6e70 2e63   step = int(np.c
-00025b80: 6569 6c28 312e 3020 2a20 4e20 2f20 2831  eil(1.0 * N / (1
-00025b90: 2e30 202a 2070 6172 7473 2929 290a 2020  .0 * parts))).  
-00025ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025bb0: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
-00025bc0: 655f 6c65 7665 6c20 3c3d 2030 3a0a 2020  e_level <= 0:.  
-00025bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025be0: 2020 2020 2020 7072 696e 7428 2220 2020        print("   
-00025bf0: 7061 7261 6c6c 656c 697a 696e 6720 6f6e  parallelizing on
-00025c00: 2022 202b 2073 7472 2828 6d70 692e 7369   " + str((mpi.si
-00025c10: 7a65 2d31 2929 0a20 2020 2020 2020 2020  ze-1)).         
-00025c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025c30: 2020 2020 202b 2022 2073 6c61 7665 7320       + " slaves 
-00025c40: 696e 746f 2022 202b 2073 7472 2870 6172  into " + str(par
-00025c50: 7473 2920 2b20 2220 7061 7274 7320 7769  ts) + " parts wi
-00025c60: 7468 2022 0a20 2020 2020 2020 2020 2020  th ".           
-00025c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025c80: 2020 202b 2073 7472 2873 7465 7029 202b     + str(step) +
-00025c90: 2022 206e 6f64 6573 2065 6163 682e 2e2e   " nodes each...
-00025ca0: 2229 0a0a 2020 2020 2020 2020 2020 2020  ")..            
-00025cb0: 2020 2020 2020 2020 2320 6e6f 7720 7375          # now su
-00025cc0: 626d 6974 2074 6865 206a 6f62 733a 0a20  bmit the jobs:. 
-00025cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025ce0: 2020 2066 6f72 2069 6e64 6578 2069 6e20     for index in 
-00025cf0: 7261 6e67 6528 7061 7274 7329 3a0a 2020  range(parts):.  
-00025d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025d10: 2020 2020 2020 7374 6172 745f 6920 3d20        start_i = 
-00025d20: 696e 6465 7820 2a20 7374 6570 0a20 2020  index * step.   
-00025d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025d40: 2020 2020 2065 6e64 5f69 203d 206d 696e       end_i = min
-00025d50: 2828 696e 6465 7820 2b20 3129 202a 2073  ((index + 1) * s
-00025d60: 7465 702c 204e 290a 2020 2020 2020 2020  tep, N).        
-00025d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025d80: 6966 2073 7461 7274 5f69 203e 3d20 656e  if start_i >= en
-00025d90: 645f 693a 0a20 2020 2020 2020 2020 2020  d_i:.           
-00025da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025db0: 2062 7265 616b 0a20 2020 2020 2020 2020   break.         
-00025dc0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00025dd0: 6869 735f 4120 3d20 415b 7374 6172 745f  his_A = A[start_
-00025de0: 693a 656e 645f 692c 203a 5d0a 2020 2020  i:end_i, :].    
-00025df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025e00: 2020 2020 2320 7375 626d 6974 2074 6865      # submit the
-00025e10: 206a 6f62 2061 6e64 2061 6464 2069 7420   job and add it 
-00025e20: 746f 2074 6865 206c 6973 7420 6f66 206a  to the list of j
-00025e30: 6f62 732c 2073 6f0a 2020 2020 2020 2020  obs, so.        
-00025e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025e50: 2320 7468 6174 206c 6174 6572 2074 6865  # that later the
-00025e60: 2072 6573 756c 7473 2063 616e 2062 6520   results can be 
-00025e70: 7265 7472 6965 7665 643a 0a20 2020 2020  retrieved:.     
-00025e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025e90: 2020 2069 6620 7365 6c66 2e73 696c 656e     if self.silen
-00025ea0: 6365 5f6c 6576 656c 203c 3d20 303a 0a20  ce_level <= 0:. 
-00025eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025ec0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00025ed0: 2822 7375 626d 6974 7469 6e67 2070 6172  ("submitting par
-00025ee0: 7420 6672 6f6d 222c 2073 7461 7274 5f69  t from", start_i
-00025ef0: 2c20 2274 6f22 2c20 656e 645f 6929 0a20  , "to", end_i). 
-00025f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025f10: 2020 2020 2020 206d 7069 2e73 7562 6d69         mpi.submi
-00025f20: 745f 6361 6c6c 2822 5f63 795f 6d70 695f  t_call("_cy_mpi_
-00025f30: 6e65 776d 616e 5f62 6574 7765 656e 6e65  newman_betweenne
-00025f40: 7373 222c 0a20 2020 2020 2020 2020 2020  ss",.           
-00025f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025f60: 2020 2020 2020 2020 2020 2020 2028 7468               (th
-00025f70: 6973 5f41 2e61 7374 7970 6528 696e 7429  is_A.astype(int)
-00025f80: 2c20 562e 6173 7479 7065 2866 6c6f 6174  , V.astype(float
-00025f90: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+000238e0: 206e 7369 5f61 7265 6e61 735f 6265 7477   nsi_arenas_betw
+000238f0: 6565 6e6e 6573 735b 6e6f 6465 5d20 3d20  eenness[node] = 
+00023900: 636f 6d70 6f6e 656e 745f 6265 7477 6565  component_betwee
+00023910: 6e6e 6573 735b 6a5d 0a0a 2020 2020 2020  nness[j]..      
+00023920: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
+00023930: 655f 6c65 7665 6c20 3c3d 2030 3a0a 2020  e_level <= 0:.  
+00023940: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00023950: 222e 2e2e 746f 6f6b 222c 2074 696d 652e  "...took", time.
+00023960: 7469 6d65 2829 2d74 302c 2022 7365 636f  time()-t0, "seco
+00023970: 6e64 7322 290a 0a20 2020 2020 2020 2072  nds")..        r
+00023980: 6574 7572 6e20 6e73 695f 6172 656e 6173  eturn nsi_arenas
+00023990: 5f62 6574 7765 656e 6e65 7373 0a0a 2020  _betweenness..  
+000239a0: 2020 4043 6163 6865 642e 6d65 7468 6f64    @Cached.method
+000239b0: 286e 616d 653d 224e 6577 6d61 6e27 7320  (name="Newman's 
+000239c0: 7261 6e64 6f6d 2077 616c 6b20 6265 7477  random walk betw
+000239d0: 6565 6e6e 6573 7322 290a 2020 2020 6465  eenness").    de
+000239e0: 6620 6e65 776d 616e 5f62 6574 7765 656e  f newman_between
+000239f0: 6e65 7373 2873 656c 6629 3a0a 2020 2020  ness(self):.    
+00023a00: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00023a10: 466f 7220 6561 6368 206e 6f64 652c 2072  For each node, r
+00023a20: 6574 7572 6e20 4e65 776d 616e 2773 2072  eturn Newman's r
+00023a30: 616e 646f 6d20 7761 6c6b 2062 6574 7765  andom walk betwe
+00023a40: 656e 6e65 7373 2e0a 0a20 2020 2020 2020  enness...       
+00023a50: 2054 6869 7320 6d65 6173 7572 6573 2068   This measures h
+00023a60: 6f77 206f 6674 656e 2061 2072 616e 646f  ow often a rando
+00023a70: 6d20 7761 6c6b 2073 6561 7263 6820 666f  m walk search fo
+00023a80: 7220 6120 7261 6e64 6f6d 2074 6172 6765  r a random targe
+00023a90: 7420 6e6f 6465 0a20 2020 2020 2020 2066  t node.        f
+00023aa0: 726f 6d20 6120 7261 6e64 6f6d 2073 6f75  rom a random sou
+00023ab0: 7263 6520 6e6f 6465 2069 7320 6578 7065  rce node is expe
+00023ac0: 6374 6564 2074 6f20 7061 7373 2074 6869  cted to pass thi
+00023ad0: 7320 6e6f 6465 2c20 6e6f 7420 636f 756e  s node, not coun
+00023ae0: 7469 6e67 0a20 2020 2020 2020 2077 6865  ting.        whe
+00023af0: 6e20 7468 6520 7761 6c6b 2072 6574 7572  n the walk retur
+00023b00: 6e73 2061 6c6f 6e67 2061 206c 696e 6b20  ns along a link 
+00023b10: 6974 2074 6f6f 6b20 6265 666f 7265 2074  it took before t
+00023b20: 6f20 6c65 6176 6520 7468 6520 6e6f 6465  o leave the node
+00023b30: 2e0a 2020 2020 2020 2020 2873 6565 205b  ..        (see [
+00023b40: 4e65 776d 616e 3230 3035 5d5f 290a 0a20  Newman2005]_).. 
+00023b50: 2020 2020 2020 202a 2a45 7861 6d70 6c65         **Example
+00023b60: 3a2a 2a0a 0a20 2020 2020 2020 203e 3e3e  :**..        >>>
+00023b70: 2072 284e 6574 776f 726b 2e53 6d61 6c6c   r(Network.Small
+00023b80: 5465 7374 4e65 7477 6f72 6b28 292e 6e65  TestNetwork().ne
+00023b90: 776d 616e 5f62 6574 7765 656e 6e65 7373  wman_betweenness
+00023ba0: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
+00023bb0: 756c 6174 696e 6720 4e65 776d 616e 2773  ulating Newman's
+00023bc0: 2072 616e 646f 6d20 7761 6c6b 2062 6574   random walk bet
+00023bd0: 7765 656e 6e65 7373 2e2e 2e0a 2020 2020  weenness....    
+00023be0: 2020 2020 2020 2028 6769 616e 7420 636f         (giant co
+00023bf0: 6d70 6f6e 656e 7420 7369 7a65 3a20 3620  mponent size: 6 
+00023c00: 2831 2e30 2929 0a20 2020 2020 2020 2061  (1.0)).        a
+00023c10: 7272 6179 285b 2034 2e31 3831 382c 2033  rray([ 4.1818, 3
+00023c20: 2e34 3138 322c 2032 2e35 3039 312c 2033  .4182, 2.5091, 3
+00023c30: 2e30 3138 322c 2033 2e36 202c 2032 2e20  .0182, 3.6 , 2. 
+00023c40: 5d29 0a0a 2020 2020 2020 2020 3a72 7479  ])..        :rty
+00023c50: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
+00023c60: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
+00023c70: 6174 7320 3e3d 2030 0a20 2020 2020 2020  ats >= 0.       
+00023c80: 2022 2222 0a20 2020 2020 2020 2074 3020   """.        t0 
+00023c90: 3d20 7469 6d65 2e74 696d 6528 290a 0a20  = time.time().. 
+00023ca0: 2020 2020 2020 2023 2020 496e 6974 6961         #  Initia
+00023cb0: 6c69 7a65 2074 6865 2061 7272 6179 2074  lize the array t
+00023cc0: 6f20 686f 6c64 2072 616e 646f 6d20 7761  o hold random wa
+00023cd0: 6c6b 2062 6574 7765 656e 6e65 7373 0a20  lk betweenness. 
+00023ce0: 2020 2020 2020 206e 6577 6d61 6e5f 6265         newman_be
+00023cf0: 7477 6565 6e6e 6573 7320 3d20 6e70 2e7a  tweenness = np.z
+00023d00: 6572 6f73 2873 656c 662e 4e29 0a0a 2020  eros(self.N)..  
+00023d10: 2020 2020 2020 2320 2052 616e 646f 6d20        #  Random 
+00023d20: 7761 6c6b 2062 6574 7765 656e 6e65 7373  walk betweenness
+00023d30: 2068 6173 2074 6f20 6265 2063 616c 6375   has to be calcu
+00023d40: 6c61 7465 6420 666f 7220 6561 6368 2063  lated for each c
+00023d50: 6f6d 706f 6e65 6e74 0a20 2020 2020 2020  omponent.       
+00023d60: 2023 2020 7365 7061 7261 7465 6c79 2e20   #  separately. 
+00023d70: 5468 6572 6566 6f72 6520 6765 7420 6469  Therefore get di
+00023d80: 6666 6572 656e 7420 636f 6d70 6f6e 656e  fferent componen
+00023d90: 7473 206f 6620 7468 6520 6772 6170 6820  ts of the graph 
+00023da0: 6669 7273 740a 2020 2020 2020 2020 636f  first.        co
+00023db0: 6d70 6f6e 656e 7473 203d 2073 656c 662e  mponents = self.
+00023dc0: 6772 6170 682e 636f 6e6e 6563 7465 645f  graph.connected_
+00023dd0: 636f 6d70 6f6e 656e 7473 2829 0a0a 2020  components()..  
+00023de0: 2020 2020 2020 2320 2050 7269 6e74 2067        #  Print g
+00023df0: 6961 6e74 2063 6f6d 706f 6e65 6e74 2073  iant component s
+00023e00: 697a 650a 2020 2020 2020 2020 6966 2073  ize.        if s
+00023e10: 656c 662e 7369 6c65 6e63 655f 6c65 7665  elf.silence_leve
+00023e20: 6c20 3c3d 2031 3a0a 2020 2020 2020 2020  l <= 1:.        
+00023e30: 2020 2020 7072 696e 7428 2220 2020 2867      print("   (g
+00023e40: 6961 6e74 2063 6f6d 706f 6e65 6e74 2073  iant component s
+00023e50: 697a 653a 2022 0a20 2020 2020 2020 2020  ize: ".         
+00023e60: 2020 2020 2020 2020 202b 2073 7472 2863           + str(c
+00023e70: 6f6d 706f 6e65 6e74 732e 6769 616e 7428  omponents.giant(
+00023e80: 292e 7663 6f75 6e74 2829 2920 2b20 2220  ).vcount()) + " 
+00023e90: 2822 0a20 2020 2020 2020 2020 2020 2020  (".             
+00023ea0: 2020 2020 202b 2073 7472 2863 6f6d 706f       + str(compo
+00023eb0: 6e65 6e74 732e 6769 616e 7428 292e 7663  nents.giant().vc
+00023ec0: 6f75 6e74 2829 0a20 2020 2020 2020 2020  ount().         
+00023ed0: 2020 2020 2020 2020 2020 2020 2020 202f                 /
+00023ee0: 2066 6c6f 6174 2873 656c 662e 6772 6170   float(self.grap
+00023ef0: 682e 7663 6f75 6e74 2829 2929 202b 2022  h.vcount())) + "
+00023f00: 2929 2229 0a0a 2020 2020 2020 2020 666f  ))")..        fo
+00023f10: 7220 632c 2063 6f6d 7020 696e 2065 6e75  r c, comp in enu
+00023f20: 6d65 7261 7465 2863 6f6d 706f 6e65 6e74  merate(component
+00023f30: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+00023f40: 2320 2049 6620 7468 6520 636f 6d70 6f6e  #  If the compon
+00023f50: 656e 7420 6861 7320 7369 7a65 2031 2c20  ent has size 1, 
+00023f60: 7365 7420 7261 6e64 6f6d 2077 616c 6b20  set random walk 
+00023f70: 6265 7477 6565 6e6e 6573 7320 746f 207a  betweenness to z
+00023f80: 6572 6f0a 2020 2020 2020 2020 2020 2020  ero.            
+00023f90: 6966 206c 656e 2863 6f6d 7029 203c 2032  if len(comp) < 2
+00023fa0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00023fb0: 2020 6e65 776d 616e 5f62 6574 7765 656e    newman_between
+00023fc0: 6e65 7373 5b63 6f6d 705b 305d 5d20 3d20  ness[comp[0]] = 
+00023fd0: 300a 2020 2020 2020 2020 2020 2020 2320  0.            # 
+00023fe0: 2046 6f72 206c 6172 6765 7220 636f 6d70   For larger comp
+00023ff0: 6f6e 656e 7473 2c20 636f 6e74 696e 7565  onents, continue
+00024000: 2077 6974 6820 7468 6520 6361 6c63 756c   with the calcul
+00024010: 6174 696f 6e0a 2020 2020 2020 2020 2020  ation.          
+00024020: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00024030: 2020 2020 2020 2020 2320 2047 6574 2074          #  Get t
+00024040: 6865 2073 7562 6772 6170 6820 4120 6d61  he subgraph A ma
+00024050: 7472 6978 2063 6f72 7265 7370 6f6e 6469  trix correspondi
+00024060: 6e67 2074 6f20 636f 6d70 6f6e 656e 7420  ng to component 
+00024070: 630a 2020 2020 2020 2020 2020 2020 2020  c.              
+00024080: 2020 7375 6267 7261 7068 203d 2063 6f6d    subgraph = com
+00024090: 706f 6e65 6e74 732e 7375 6267 7261 7068  ponents.subgraph
+000240a0: 2863 290a 2020 2020 2020 2020 2020 2020  (c).            
+000240b0: 2020 2020 4120 3d20 6e70 2e61 7272 6179      A = np.array
+000240c0: 2873 7562 6772 6170 682e 6765 745f 6164  (subgraph.get_ad
+000240d0: 6a61 6365 6e63 7928 7479 7065 3d32 292e  jacency(type=2).
+000240e0: 6461 7461 2c20 6474 7970 653d 4144 4a29  data, dtype=ADJ)
+000240f0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00024100: 2020 2320 2047 656e 6572 6174 6520 6120    #  Generate a 
+00024110: 4e65 7477 6f72 6b20 6f62 6a65 6374 2072  Network object r
+00024120: 6570 7265 7365 6e74 696e 6720 7468 6520  epresenting the 
+00024130: 7375 6267 7261 7068 0a20 2020 2020 2020  subgraph.       
+00024140: 2020 2020 2020 2020 2073 7562 6e65 7477           subnetw
+00024150: 6f72 6b20 3d20 4e65 7477 6f72 6b28 6164  ork = Network(ad
+00024160: 6a61 6365 6e63 793d 412c 2064 6972 6563  jacency=A, direc
+00024170: 7465 643d 4661 6c73 6529 0a20 2020 2020  ted=False).     
+00024180: 2020 2020 2020 2020 2020 204e 2c20 7370             N, sp
+00024190: 5f41 203d 2073 7562 6e65 7477 6f72 6b2e  _A = subnetwork.
+000241a0: 4e2c 2073 7562 6e65 7477 6f72 6b2e 7370  N, subnetwork.sp
+000241b0: 5f41 0a0a 2020 2020 2020 2020 2020 2020  _A..            
+000241c0: 2020 2020 2320 4b69 7263 6868 6f66 6620      # Kirchhoff 
+000241d0: 6d61 7472 6978 0a20 2020 2020 2020 2020  matrix.         
+000241e0: 2020 2020 2020 2073 705f 4d20 3d20 7370         sp_M = sp
+000241f0: 2e64 6961 6773 285b 7375 626e 6574 776f  .diags([subnetwo
+00024200: 726b 2e69 6e64 6567 7265 6528 295d 2c20  rk.indegree()], 
+00024210: 5b30 5d2c 0a20 2020 2020 2020 2020 2020  [0],.           
+00024220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024230: 2020 2020 2073 6861 7065 3d28 4e2c 204e       shape=(N, N
+00024240: 292c 2066 6f72 6d61 743d 2763 7363 2729  ), format='csc')
+00024250: 202d 2073 705f 410a 0a20 2020 2020 2020   - sp_A..       
+00024260: 2020 2020 2020 2020 2023 2069 6e76 6572           # inver
+00024270: 7420 6974 2077 6974 686f 7574 206c 6173  t it without las
+00024280: 7420 726f 772f 636f 6c0a 2020 2020 2020  t row/col.      
+00024290: 2020 2020 2020 2020 2020 2320 4649 584d            # FIXM
+000242a0: 453a 2069 6e20 7261 7265 2063 6173 6573  E: in rare cases
+000242b0: 2028 7768 656e 2074 6865 7265 2069 7320   (when there is 
+000242c0: 616e 2065 7861 6374 2074 7769 6e20 746f  an exact twin to
+000242d0: 2074 6865 206c 6173 740a 2020 2020 2020   the last.      
+000242e0: 2020 2020 2020 2020 2020 2320 6e6f 6465            # node
+000242f0: 292c 2074 6869 7320 6d69 6768 7420 6e6f  ), this might no
+00024300: 7420 6265 2069 6e76 6572 7469 626c 6520  t be invertible 
+00024310: 616e 6420 6120 6469 6666 6572 656e 7420  and a different 
+00024320: 726f 772f 636f 6c0a 2020 2020 2020 2020  row/col.        
+00024330: 2020 2020 2020 2020 2320 776f 756c 6420          # would 
+00024340: 6e65 6564 2074 6f20 6265 2072 656d 6f76  need to be remov
+00024350: 6564 210a 2020 2020 2020 2020 2020 2020  ed!.            
+00024360: 2020 2020 5620 3d20 7370 2e6c 696c 5f6d      V = sp.lil_m
+00024370: 6174 7269 7828 284e 2c20 4e29 290a 2020  atrix((N, N)).  
+00024380: 2020 2020 2020 2020 2020 2020 2020 565b                V[
+00024390: 3a2d 312c 203a 2d31 5d20 3d20 696e 7628  :-1, :-1] = inv(
+000243a0: 7370 5f4d 5b3a 2d31 2c20 3a2d 315d 290a  sp_M[:-1, :-1]).
+000243b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000243c0: 5620 3d20 562e 410a 2020 2020 2020 2020  V = V.A.        
+000243d0: 2020 2020 2020 2020 6465 6c20 7375 6267          del subg
+000243e0: 7261 7068 2c20 7375 626e 6574 776f 726b  raph, subnetwork
+000243f0: 2c20 7370 5f41 2c20 7370 5f4d 0a0a 2020  , sp_A, sp_M..  
+00024400: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00024410: 6d70 6f6e 656e 745f 6265 7477 6565 6e6e  mponent_betweenn
+00024420: 6573 7320 3d20 6e70 2e7a 6572 6f73 284e  ess = np.zeros(N
+00024430: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00024440: 2020 6966 206d 7069 2e61 7661 696c 6162    if mpi.availab
+00024450: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
+00024460: 2020 2020 2020 2020 2320 6465 7465 726d          # determ
+00024470: 696e 6520 696e 2068 6f77 206d 616e 7920  ine in how many 
+00024480: 7061 7274 7320 7765 2073 706c 6974 2074  parts we split t
+00024490: 6865 206f 7574 6572 206c 6f6f 703a 0a20  he outer loop:. 
+000244a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000244b0: 2020 2070 6172 7473 203d 206d 6178 2831     parts = max(1
+000244c0: 2c20 696e 7428 6e70 2e63 6569 6c28 0a20  , int(np.ceil(. 
+000244d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000244e0: 2020 2020 2020 206d 696e 2828 6d70 692e         min((mpi.
+000244f0: 7369 7a65 2d31 2920 2a20 3130 2e30 2c20  size-1) * 10.0, 
+00024500: 302e 3120 2a20 4e29 2929 290a 2020 2020  0.1 * N)))).    
+00024510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024520: 2320 636f 7272 6573 706f 6e64 696e 6720  # corresponding 
+00024530: 7374 6570 2073 697a 6520 666f 7220 6320  step size for c 
+00024540: 696e 6465 7820 6f66 206f 7574 6572 206c  index of outer l
+00024550: 6f6f 703a 0a20 2020 2020 2020 2020 2020  oop:.           
+00024560: 2020 2020 2020 2020 2073 7465 7020 3d20           step = 
+00024570: 696e 7428 6e70 2e63 6569 6c28 312e 3020  int(np.ceil(1.0 
+00024580: 2a20 4e20 2f20 2831 2e30 202a 2070 6172  * N / (1.0 * par
+00024590: 7473 2929 290a 2020 2020 2020 2020 2020  ts))).          
+000245a0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+000245b0: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
+000245c0: 3c3d 2030 3a0a 2020 2020 2020 2020 2020  <= 0:.          
+000245d0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000245e0: 696e 7428 2220 2020 7061 7261 6c6c 656c  int("   parallel
+000245f0: 697a 696e 6720 6f6e 2022 202b 2073 7472  izing on " + str
+00024600: 2828 6d70 692e 7369 7a65 2d31 2929 0a20  ((mpi.size-1)). 
+00024610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024620: 2020 2020 2020 2020 2020 2020 202b 2022               + "
+00024630: 2073 6c61 7665 7320 696e 746f 2022 202b   slaves into " +
+00024640: 2073 7472 2870 6172 7473 2920 2b20 2220   str(parts) + " 
+00024650: 7061 7274 7320 7769 7468 2022 0a20 2020  parts with ".   
+00024660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024670: 2020 2020 2020 2020 2020 202b 2073 7472             + str
+00024680: 2873 7465 7029 202b 2022 206e 6f64 6573  (step) + " nodes
+00024690: 2065 6163 682e 2e2e 2229 0a0a 2020 2020   each...")..    
+000246a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000246b0: 2320 6e6f 7720 7375 626d 6974 2074 6865  # now submit the
+000246c0: 206a 6f62 733a 0a20 2020 2020 2020 2020   jobs:.         
+000246d0: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+000246e0: 6e64 6578 2069 6e20 7261 6e67 6528 7061  ndex in range(pa
+000246f0: 7274 7329 3a0a 2020 2020 2020 2020 2020  rts):.          
+00024700: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00024710: 6172 745f 6920 3d20 696e 6465 7820 2a20  art_i = index * 
+00024720: 7374 6570 0a20 2020 2020 2020 2020 2020  step.           
+00024730: 2020 2020 2020 2020 2020 2020 2065 6e64               end
+00024740: 5f69 203d 206d 696e 2828 696e 6465 7820  _i = min((index 
+00024750: 2b20 3129 202a 2073 7465 702c 204e 290a  + 1) * step, N).
+00024760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024770: 2020 2020 2020 2020 6966 2073 7461 7274          if start
+00024780: 5f69 203e 3d20 656e 645f 693a 0a20 2020  _i >= end_i:.   
+00024790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000247a0: 2020 2020 2020 2020 2062 7265 616b 0a20           break. 
+000247b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000247c0: 2020 2020 2020 2074 6869 735f 4120 3d20         this_A = 
+000247d0: 415b 7374 6172 745f 693a 656e 645f 692c  A[start_i:end_i,
+000247e0: 203a 5d0a 2020 2020 2020 2020 2020 2020   :].            
+000247f0: 2020 2020 2020 2020 2020 2020 2320 7375              # su
+00024800: 626d 6974 2074 6865 206a 6f62 2061 6e64  bmit the job and
+00024810: 2061 6464 2069 7420 746f 2074 6865 206c   add it to the l
+00024820: 6973 7420 6f66 206a 6f62 732c 2073 6f0a  ist of jobs, so.
+00024830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024840: 2020 2020 2020 2020 2320 7468 6174 206c          # that l
+00024850: 6174 6572 2074 6865 2072 6573 756c 7473  ater the results
+00024860: 2063 616e 2062 6520 7265 7472 6965 7665   can be retrieve
+00024870: 643a 0a20 2020 2020 2020 2020 2020 2020  d:.             
+00024880: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00024890: 6c66 2e73 696c 656e 6365 5f6c 6576 656c  lf.silence_level
+000248a0: 203c 3d20 303a 0a20 2020 2020 2020 2020   <= 0:.         
+000248b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000248c0: 2020 2070 7269 6e74 2822 7375 626d 6974     print("submit
+000248d0: 7469 6e67 2070 6172 7420 6672 6f6d 222c  ting part from",
+000248e0: 2073 7461 7274 5f69 2c20 2274 6f22 2c20   start_i, "to", 
+000248f0: 656e 645f 6929 0a20 2020 2020 2020 2020  end_i).         
+00024900: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00024910: 7069 2e73 7562 6d69 745f 6361 6c6c 280a  pi.submit_call(.
+00024920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024930: 2020 2020 2020 2020 2020 2020 225f 6d70              "_mp
+00024940: 695f 6e65 776d 616e 5f62 6574 7765 656e  i_newman_between
+00024950: 6e65 7373 222c 0a20 2020 2020 2020 2020  ness",.         
+00024960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024970: 2020 2028 746f 5f63 7928 7468 6973 5f41     (to_cy(this_A
+00024980: 2c20 4144 4a29 2c20 746f 5f63 7928 562c  , ADJ), to_cy(V,
+00024990: 2044 4649 454c 4429 2c0a 2020 2020 2020   DFIELD),.      
+000249a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000249b0: 2020 2020 2020 204e 2c20 7374 6172 745f         N, start_
+000249c0: 692c 2065 6e64 5f69 292c 0a20 2020 2020  i, end_i),.     
+000249d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000249e0: 2020 2020 2020 206d 6f64 756c 653d 2270         module="p
+000249f0: 7975 6e69 636f 726e 222c 2069 643d 696e  yunicorn", id=in
+00024a00: 6465 782c 0a20 2020 2020 2020 2020 2020  dex,.           
+00024a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024a20: 2074 696d 655f 6573 743d 7468 6973 5f41   time_est=this_A
+00024a30: 2e73 756d 2829 290a 0a20 2020 2020 2020  .sum())..       
+00024a40: 2020 2020 2020 2020 2020 2020 2023 2052               # R
+00024a50: 6574 7269 6576 6520 7265 7375 6c74 7320  etrieve results 
+00024a60: 6f66 2061 6c6c 2073 7562 6d69 7474 6564  of all submitted
+00024a70: 206a 6f62 733a 0a20 2020 2020 2020 2020   jobs:.         
+00024a80: 2020 2020 2020 2020 2020 2063 6f6d 706f             compo
+00024a90: 6e65 6e74 5f62 6574 7765 656e 6e65 7373  nent_betweenness
+00024aa0: 203d 206e 702e 7a65 726f 7328 4e29 0a20   = np.zeros(N). 
+00024ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024ac0: 2020 2066 6f72 2069 6e64 6578 2069 6e20     for index in 
+00024ad0: 7261 6e67 6528 7061 7274 7329 3a0a 2020  range(parts):.  
+00024ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024af0: 2020 2020 2020 2320 7468 6520 666f 6c6c        # the foll
+00024b00: 6f77 696e 6720 6361 6c6c 2063 6f6e 6e65  owing call conne
+00024b10: 6374 7320 746f 2074 6865 2073 7562 6d69  cts to the submi
+00024b20: 7474 6564 206a 6f62 2c0a 2020 2020 2020  tted job,.      
+00024b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024b40: 2020 2320 7761 6974 7320 756e 7469 6c20    # waits until 
+00024b50: 6974 2066 696e 6973 6865 732c 2061 6e64  it finishes, and
+00024b60: 2072 6574 7269 6576 6573 2074 6865 2072   retrieves the r
+00024b70: 6573 756c 743a 0a20 2020 2020 2020 2020  esult:.         
+00024b80: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00024b90: 6620 7365 6c66 2e73 696c 656e 6365 5f6c  f self.silence_l
+00024ba0: 6576 656c 203c 3d20 303a 0a20 2020 2020  evel <= 0:.     
+00024bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024bc0: 2020 2020 2020 2070 7269 6e74 2822 7265         print("re
+00024bd0: 7472 6965 7669 6e67 2072 6573 756c 7473  trieving results
+00024be0: 2066 726f 6d20 222c 2069 6e64 6578 290a   from ", index).
+00024bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024c00: 2020 2020 2020 2020 7468 6973 5f62 6574          this_bet
+00024c10: 7765 656e 6e65 7373 2c20 7374 6172 745f  weenness, start_
+00024c20: 692c 2065 6e64 5f69 203d 205c 0a20 2020  i, end_i = \.   
+00024c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024c40: 2020 2020 2020 2020 206d 7069 2e67 6574           mpi.get
+00024c50: 5f72 6573 756c 7428 696e 6465 7829 0a20  _result(index). 
+00024c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024c70: 2020 2020 2020 2063 6f6d 706f 6e65 6e74         component
+00024c80: 5f62 6574 7765 656e 6e65 7373 5b73 7461  _betweenness[sta
+00024c90: 7274 5f69 3a65 6e64 5f69 5d20 3d20 7468  rt_i:end_i] = th
+00024ca0: 6973 5f62 6574 7765 656e 6e65 7373 0a20  is_betweenness. 
+00024cb0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00024cc0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00024cd0: 2020 2020 2020 2020 2063 6f6d 706f 6e65           compone
+00024ce0: 6e74 5f62 6574 7765 656e 6e65 7373 2c20  nt_betweenness, 
+00024cf0: 7374 6172 745f 692c 2065 6e64 5f69 203d  start_i, end_i =
+00024d00: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00024d10: 2020 2020 2020 2020 2020 5f6d 7069 5f6e            _mpi_n
+00024d20: 6577 6d61 6e5f 6265 7477 6565 6e6e 6573  ewman_betweennes
+00024d30: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+00024d40: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00024d50: 6f5f 6379 2841 2c20 4144 4a29 2c20 746f  o_cy(A, ADJ), to
+00024d60: 5f63 7928 562c 2044 4649 454c 4429 2c0a  _cy(V, DFIELD),.
+00024d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024d80: 2020 2020 2020 2020 2020 2020 4e2c 2030              N, 0
+00024d90: 2c20 4e29 0a0a 2020 2020 2020 2020 2020  , N)..          
+00024da0: 2020 2020 2020 636f 6d70 6f6e 656e 745f        component_
+00024db0: 6265 7477 6565 6e6e 6573 7320 2b3d 2032  betweenness += 2
+00024dc0: 202a 2028 4e20 2d20 3129 0a20 2020 2020   * (N - 1).     
+00024dd0: 2020 2020 2020 2020 2020 2063 6f6d 706f             compo
+00024de0: 6e65 6e74 5f62 6574 7765 656e 6e65 7373  nent_betweenness
+00024df0: 202f 3d20 284e 202d 2031 2e30 2920 2023   /= (N - 1.0)  #
+00024e00: 2054 4f44 4f3a 2077 6879 2069 7320 7468   TODO: why is th
+00024e10: 6973 3f0a 0a20 2020 2020 2020 2020 2020  is?..           
+00024e20: 2020 2020 2023 2073 6f72 7420 7265 7375       # sort resu
+00024e30: 6c74 7320 696e 746f 2063 6f72 7265 6374  lts into correct
+00024e40: 2070 6f73 6974 696f 6e73 0a20 2020 2020   positions.     
+00024e50: 2020 2020 2020 2020 2020 206e 6f64 6573             nodes
+00024e60: 203d 2063 6f6d 700a 2020 2020 2020 2020   = comp.        
+00024e70: 2020 2020 2020 2020 666f 7220 6a2c 206e          for j, n
+00024e80: 6f64 6520 696e 2065 6e75 6d65 7261 7465  ode in enumerate
+00024e90: 286e 6f64 6573 293a 0a20 2020 2020 2020  (nodes):.       
+00024ea0: 2020 2020 2020 2020 2020 2020 206e 6577               new
+00024eb0: 6d61 6e5f 6265 7477 6565 6e6e 6573 735b  man_betweenness[
+00024ec0: 6e6f 6465 5d20 3d20 636f 6d70 6f6e 656e  node] = componen
+00024ed0: 745f 6265 7477 6565 6e6e 6573 735b 6a5d  t_betweenness[j]
+00024ee0: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
+00024ef0: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
+00024f00: 3c3d 2030 3a0a 2020 2020 2020 2020 2020  <= 0:.          
+00024f10: 2020 7072 696e 7428 222e 2e2e 746f 6f6b    print("...took
+00024f20: 222c 2074 696d 652e 7469 6d65 2829 2d74  ", time.time()-t
+00024f30: 302c 2022 7365 636f 6e64 7322 290a 0a20  0, "seconds").. 
+00024f40: 2020 2020 2020 2072 6574 7572 6e20 6e65         return ne
+00024f50: 776d 616e 5f62 6574 7765 656e 6e65 7373  wman_betweenness
+00024f60: 0a0a 2020 2020 6465 6620 6e73 695f 6e65  ..    def nsi_ne
+00024f70: 776d 616e 5f62 6574 7765 656e 6e65 7373  wman_betweenness
+00024f80: 2873 656c 662c 2061 6464 5f6c 6f63 616c  (self, add_local
+00024f90: 5f65 6e64 733d 4661 6c73 6529 3a0a 2020  _ends=False):.  
+00024fa0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00024fb0: 2020 466f 7220 6561 6368 206e 6f64 652c    For each node,
+00024fc0: 2072 6574 7572 6e20 6974 7320 6e2e 732e   return its n.s.
+00024fd0: 692e 204e 6577 6d61 6e2d 7479 7065 2072  i. Newman-type r
+00024fe0: 616e 646f 6d20 7761 6c6b 2062 6574 7765  andom walk betwe
+00024ff0: 656e 6e65 7373 2e0a 0a20 2020 2020 2020  enness...       
+00025000: 2054 6869 7320 6d65 6173 7572 6573 2068   This measures h
+00025010: 6f77 206f 6674 656e 2061 2072 616e 646f  ow often a rando
+00025020: 6d20 7761 6c6b 2073 6561 7263 6820 666f  m walk search fo
+00025030: 7220 6120 7261 6e64 6f6d 2074 6172 6765  r a random targe
+00025040: 7420 6e6f 6465 0a20 2020 2020 2020 2066  t node.        f
+00025050: 726f 6d20 6120 7261 6e64 6f6d 2073 6f75  rom a random sou
+00025060: 7263 6520 6e6f 6465 2069 7320 6578 7065  rce node is expe
+00025070: 6374 6564 2074 6f20 7061 7373 2074 6869  cted to pass thi
+00025080: 7320 6e6f 6465 2c20 6e6f 7420 636f 756e  s node, not coun
+00025090: 7469 6e67 0a20 2020 2020 2020 2077 6865  ting.        whe
+000250a0: 6e20 7468 6520 7761 6c6b 2072 6574 7572  n the walk retur
+000250b0: 6e73 2061 6c6f 6e67 2061 206c 696e 6b20  ns along a link 
+000250c0: 6974 2074 6f6f 6b20 6265 666f 7265 2074  it took before t
+000250d0: 6f20 6c65 6176 6520 7468 6520 6e6f 6465  o leave the node
+000250e0: 2e0a 2020 2020 2020 2020 2873 6565 205b  ..        (see [
+000250f0: 4e65 776d 616e 3230 3035 5d5f 290a 0a20  Newman2005]_).. 
+00025100: 2020 2020 2020 2049 6e20 7468 6973 206e         In this n
+00025110: 2e73 2e69 2e20 7665 7273 696f 6e2c 206e  .s.i. version, n
+00025120: 6f64 6520 7765 6967 6874 7320 6172 6520  ode weights are 
+00025130: 7461 6b65 6e20 696e 746f 2061 6363 6f75  taken into accou
+00025140: 6e74 2c20 616e 6420 6f6e 6c79 0a20 2020  nt, and only.   
+00025150: 2020 2020 2072 616e 646f 6d20 7761 6c6b       random walk
+00025160: 7320 6172 6520 7573 6564 2074 6861 7420  s are used that 
+00025170: 646f 206e 6f74 2073 7461 7274 206f 7220  do not start or 
+00025180: 656e 6420 696e 206e 6569 6768 626f 7273  end in neighbors
+00025190: 206f 6620 7468 650a 2020 2020 2020 2020   of the.        
+000251a0: 6e6f 6465 2e0a 0a0a 2020 2020 2020 2020  node....        
+000251b0: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
+000251c0: 2020 2020 2020 3e3e 3e20 6e65 7420 3d20        >>> net = 
+000251d0: 4e65 7477 6f72 6b2e 536d 616c 6c54 6573  Network.SmallTes
+000251e0: 744e 6574 776f 726b 2829 0a20 2020 2020  tNetwork().     
+000251f0: 2020 203e 3e3e 2072 286e 6574 2e6e 7369     >>> r(net.nsi
+00025200: 5f6e 6577 6d61 6e5f 6265 7477 6565 6e6e  _newman_betweenn
+00025210: 6573 7328 2929 0a20 2020 2020 2020 2043  ess()).        C
+00025220: 616c 6375 6c61 7469 6e67 206e 2e73 2e69  alculating n.s.i
+00025230: 2e20 4e65 776d 616e 2d74 7970 6520 7261  . Newman-type ra
+00025240: 6e64 6f6d 2077 616c 6b20 6265 7477 6565  ndom walk betwee
+00025250: 6e6e 6573 732e 2e2e 0a20 2020 2020 2020  nness....       
+00025260: 2020 2020 2867 6961 6e74 2063 6f6d 706f      (giant compo
+00025270: 6e65 6e74 2073 697a 653a 2036 2028 312e  nent size: 6 (1.
+00025280: 3029 290a 2020 2020 2020 2020 4361 6c63  0)).        Calc
+00025290: 756c 6174 696e 6720 6e2e 732e 692e 2064  ulating n.s.i. d
+000252a0: 6567 7265 652e 2e2e 0a20 2020 2020 2020  egree....       
+000252b0: 2061 7272 6179 285b 2030 2e34 3034 382c   array([ 0.4048,
+000252c0: 2030 2e20 2c20 302e 3835 3231 2c20 332e   0. , 0.8521, 3.
+000252d0: 3333 3537 2c20 312e 3336 3632 2c20 302e  3357, 1.3662, 0.
+000252e0: 205d 290a 2020 2020 2020 2020 3e3e 3e20   ]).        >>> 
+000252f0: 7228 6e65 742e 7370 6c69 7474 6564 5f63  r(net.splitted_c
+00025300: 6f70 7928 292e 6e73 695f 6e65 776d 616e  opy().nsi_newman
+00025310: 5f62 6574 7765 656e 6e65 7373 2829 290a  _betweenness()).
+00025320: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00025330: 696e 6720 6e2e 732e 692e 204e 6577 6d61  ing n.s.i. Newma
+00025340: 6e2d 7479 7065 2072 616e 646f 6d20 7761  n-type random wa
+00025350: 6c6b 2062 6574 7765 656e 6e65 7373 2e2e  lk betweenness..
+00025360: 2e0a 2020 2020 2020 2020 2020 2028 6769  ..           (gi
+00025370: 616e 7420 636f 6d70 6f6e 656e 7420 7369  ant component si
+00025380: 7a65 3a20 3720 2831 2e30 2929 0a20 2020  ze: 7 (1.0)).   
+00025390: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+000253a0: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
+000253b0: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
+000253c0: 5b20 302e 3430 3438 2c20 302e 202c 2030  [ 0.4048, 0. , 0
+000253d0: 2e38 3532 312c 2033 2e33 3335 372c 2031  .8521, 3.3357, 1
+000253e0: 2e33 3636 322c 2030 2e20 2c20 302e 205d  .3662, 0. , 0. ]
+000253f0: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
+00025400: 6e65 742e 6e73 695f 6e65 776d 616e 5f62  net.nsi_newman_b
+00025410: 6574 7765 656e 6e65 7373 2861 6464 5f6c  etweenness(add_l
+00025420: 6f63 616c 5f65 6e64 733d 5472 7565 2929  ocal_ends=True))
+00025430: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+00025440: 7469 6e67 206e 2e73 2e69 2e20 4e65 776d  ting n.s.i. Newm
+00025450: 616e 2d74 7970 6520 7261 6e64 6f6d 2077  an-type random w
+00025460: 616c 6b20 6265 7477 6565 6e6e 6573 732e  alk betweenness.
+00025470: 2e2e 0a20 2020 2020 2020 2020 2020 2867  ...           (g
+00025480: 6961 6e74 2063 6f6d 706f 6e65 6e74 2073  iant component s
+00025490: 697a 653a 2036 2028 312e 3029 290a 2020  ize: 6 (1.0)).  
+000254a0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+000254b0: 6720 6e2e 732e 692e 2064 6567 7265 652e  g n.s.i. degree.
+000254c0: 2e2e 0a20 2020 2020 2020 2061 7272 6179  ...        array
+000254d0: 285b 2031 3331 2e34 3434 382c 2031 3238  ([ 131.4448, 128
+000254e0: 2e20 2c20 3130 372e 3634 3231 2c20 3130  . , 107.6421, 10
+000254f0: 322e 3434 3537 2c20 3132 342e 3230 3632  2.4457, 124.2062
+00025500: 2c20 3830 2e20 5d29 0a20 2020 2020 2020  , 80. ]).       
+00025510: 203e 3e3e 2072 286e 6574 2e73 706c 6974   >>> r(net.split
+00025520: 7465 645f 636f 7079 2829 2e6e 7369 5f6e  ted_copy().nsi_n
+00025530: 6577 6d61 6e5f 6265 7477 6565 6e6e 6573  ewman_betweennes
+00025540: 7328 0a20 2020 2020 2020 202e 2e2e 2020  s(.        ...  
+00025550: 2020 2061 6464 5f6c 6f63 616c 5f65 6e64     add_local_end
+00025560: 733d 5472 7565 2929 0a20 2020 2020 2020  s=True)).       
+00025570: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
+00025580: 2e69 2e20 4e65 776d 616e 2d74 7970 6520  .i. Newman-type 
+00025590: 7261 6e64 6f6d 2077 616c 6b20 6265 7477  random walk betw
+000255a0: 6565 6e6e 6573 732e 2e2e 0a20 2020 2020  eenness....     
+000255b0: 2020 2020 2020 2867 6961 6e74 2063 6f6d        (giant com
+000255c0: 706f 6e65 6e74 2073 697a 653a 2037 2028  ponent size: 7 (
+000255d0: 312e 3029 290a 2020 2020 2020 2020 4361  1.0)).        Ca
+000255e0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
+000255f0: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
+00025600: 2020 2061 7272 6179 285b 2031 3331 2e34     array([ 131.4
+00025610: 3434 382c 2031 3238 2e20 2c20 3130 372e  448, 128. , 107.
+00025620: 3634 3231 2c20 3130 322e 3434 3537 2c20  6421, 102.4457, 
+00025630: 3132 342e 3230 3632 2c20 3830 2e20 2c20  124.2062, 80. , 
+00025640: 3830 2e20 5d29 0a0a 2020 2020 2020 2020  80. ])..        
+00025650: 6173 2063 6f6d 7061 7265 6420 746f 2069  as compared to i
+00025660: 7473 2075 6e77 6569 6768 7465 6420 7665  ts unweighted ve
+00025670: 7273 696f 6e3a 0a0a 2020 2020 2020 2020  rsion:..        
+00025680: 3e3e 3e20 6e65 7420 3d20 4e65 7477 6f72  >>> net = Networ
+00025690: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
+000256a0: 726b 2829 0a20 2020 2020 2020 203e 3e3e  rk().        >>>
+000256b0: 2072 286e 6574 2e6e 6577 6d61 6e5f 6265   r(net.newman_be
+000256c0: 7477 6565 6e6e 6573 7328 2929 0a20 2020  tweenness()).   
+000256d0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+000256e0: 204e 6577 6d61 6e27 7320 7261 6e64 6f6d   Newman's random
+000256f0: 2077 616c 6b20 6265 7477 6565 6e6e 6573   walk betweennes
+00025700: 732e 2e2e 0a20 2020 2020 2020 2020 2020  s....           
+00025710: 2867 6961 6e74 2063 6f6d 706f 6e65 6e74  (giant component
+00025720: 2073 697a 653a 2036 2028 312e 3029 290a   size: 6 (1.0)).
+00025730: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
+00025740: 342e 3138 3138 2c20 332e 3431 3832 2c20  4.1818, 3.4182, 
+00025750: 322e 3530 3931 2c20 332e 3031 3832 2c20  2.5091, 3.0182, 
+00025760: 332e 3620 2c20 322e 205d 290a 2020 2020  3.6 , 2. ]).    
+00025770: 2020 2020 3e3e 3e20 7228 6e65 742e 7370      >>> r(net.sp
+00025780: 6c69 7474 6564 5f63 6f70 7928 292e 6e65  litted_copy().ne
+00025790: 776d 616e 5f62 6574 7765 656e 6e65 7373  wman_betweenness
+000257a0: 2829 290a 2020 2020 2020 2020 4361 6c63  ()).        Calc
+000257b0: 756c 6174 696e 6720 4e65 776d 616e 2773  ulating Newman's
+000257c0: 2072 616e 646f 6d20 7761 6c6b 2062 6574   random walk bet
+000257d0: 7765 656e 6e65 7373 2e2e 2e0a 2020 2020  weenness....    
+000257e0: 2020 2020 2020 2028 6769 616e 7420 636f         (giant co
+000257f0: 6d70 6f6e 656e 7420 7369 7a65 3a20 3720  mponent size: 7 
+00025800: 2831 2e30 2929 0a20 2020 2020 2020 2061  (1.0)).        a
+00025810: 7272 6179 285b 2035 2e32 3632 362c 2033  rray([ 5.2626, 3
+00025820: 2e35 3135 322c 2032 2e35 3435 352c 2033  .5152, 2.5455, 3
+00025830: 2e32 3132 312c 2033 2e38 3138 322c 2032  .2121, 3.8182, 2
+00025840: 2e35 3535 362c 2032 2e35 3535 365d 290a  .5556, 2.5556]).
+00025850: 0a20 2020 2020 2020 203a 6172 6720 626f  .        :arg bo
+00025860: 6f6c 2061 6464 5f6c 6f63 616c 5f65 6e64  ol add_local_end
+00025870: 733a 2049 6e64 6963 6174 6573 2077 6865  s: Indicates whe
+00025880: 7468 6572 2074 6f20 6164 6420 6120 636f  ther to add a co
+00025890: 7272 6563 7469 6f6e 2066 6f72 2074 6865  rrection for the
+000258a0: 0a20 2020 2020 2020 2020 2020 2066 6163  .            fac
+000258b0: 7420 7468 6174 2077 616c 6b73 2073 7461  t that walks sta
+000258c0: 7274 696e 6720 6f72 2065 6e64 696e 6720  rting or ending 
+000258d0: 696e 206e 6569 6768 626f 7273 2061 7265  in neighbors are
+000258e0: 206e 6f74 2075 7365 642e 0a20 2020 2020   not used..     
+000258f0: 2020 2020 2020 2028 4465 6661 756c 743a         (Default:
+00025900: 2066 616c 7365 290a 2020 2020 2020 2020   false).        
+00025910: 3a72 7479 7065 3a20 6172 7261 7920 5b66  :rtype: array [f
+00025920: 6c6f 6174 3e3d 305d 0a20 2020 2020 2020  loat>=0].       
+00025930: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+00025940: 7365 6c66 2e73 696c 656e 6365 5f6c 6576  self.silence_lev
+00025950: 656c 203c 3d20 313a 0a20 2020 2020 2020  el <= 1:.       
+00025960: 2020 2020 2070 7269 6e74 2822 4361 6c63       print("Calc
+00025970: 756c 6174 696e 6720 6e2e 732e 692e 204e  ulating n.s.i. N
+00025980: 6577 6d61 6e2d 7479 7065 2072 616e 646f  ewman-type rando
+00025990: 6d20 7761 6c6b 2062 6574 7765 656e 6e65  m walk betweenne
+000259a0: 7373 2e2e 2e22 290a 0a20 2020 2020 2020  ss...")..       
+000259b0: 2074 3020 3d20 7469 6d65 2e74 696d 6528   t0 = time.time(
+000259c0: 290a 0a20 2020 2020 2020 2023 2020 496e  )..        #  In
+000259d0: 6974 6961 6c69 7a65 2074 6865 2061 7272  itialize the arr
+000259e0: 6179 2074 6f20 686f 6c64 2072 616e 646f  ay to hold rando
+000259f0: 6d20 7761 6c6b 2062 6574 7765 656e 6e65  m walk betweenne
+00025a00: 7373 0a20 2020 2020 2020 206e 7369 5f6e  ss.        nsi_n
+00025a10: 6577 6d61 6e5f 6265 7477 6565 6e6e 6573  ewman_betweennes
+00025a20: 7320 3d20 6e70 2e7a 6572 6f73 2873 656c  s = np.zeros(sel
+00025a30: 662e 4e29 0a0a 2020 2020 2020 2020 2320  f.N)..        # 
+00025a40: 2052 616e 646f 6d20 7761 6c6b 2062 6574   Random walk bet
+00025a50: 7765 656e 6e65 7373 2068 6173 2074 6f20  weenness has to 
+00025a60: 6265 2063 616c 6375 6c61 7465 6420 666f  be calculated fo
+00025a70: 7220 6561 6368 2063 6f6d 706f 6e65 6e74  r each component
+00025a80: 0a20 2020 2020 2020 2023 2020 7365 7061  .        #  sepa
+00025a90: 7261 7465 6c79 2e20 5468 6572 6566 6f72  rately. Therefor
+00025aa0: 6520 6765 7420 6469 6666 6572 656e 7420  e get different 
+00025ab0: 636f 6d70 6f6e 656e 7473 206f 6620 7468  components of th
+00025ac0: 6520 6772 6170 6820 6669 7273 740a 2020  e graph first.  
+00025ad0: 2020 2020 2020 636f 6d70 6f6e 656e 7473        components
+00025ae0: 203d 2073 656c 662e 6772 6170 682e 636f   = self.graph.co
+00025af0: 6e6e 6563 7465 645f 636f 6d70 6f6e 656e  nnected_componen
+00025b00: 7473 2829 0a0a 2020 2020 2020 2020 2320  ts()..        # 
+00025b10: 2050 7269 6e74 2067 6961 6e74 2063 6f6d   Print giant com
+00025b20: 706f 6e65 6e74 2073 697a 650a 2020 2020  ponent size.    
+00025b30: 2020 2020 6966 2073 656c 662e 7369 6c65      if self.sile
+00025b40: 6e63 655f 6c65 7665 6c20 3c3d 2031 3a0a  nce_level <= 1:.
+00025b50: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00025b60: 7428 2220 2020 2867 6961 6e74 2063 6f6d  t("   (giant com
+00025b70: 706f 6e65 6e74 2073 697a 653a 2022 0a20  ponent size: ". 
+00025b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025b90: 202b 2073 7472 2863 6f6d 706f 6e65 6e74   + str(component
+00025ba0: 732e 6769 616e 7428 292e 7663 6f75 6e74  s.giant().vcount
+00025bb0: 2829 2920 2b20 2220 2822 0a20 2020 2020  ()) + " (".     
+00025bc0: 2020 2020 2020 2020 2020 2020 202b 2073               + s
+00025bd0: 7472 2863 6f6d 706f 6e65 6e74 732e 6769  tr(components.gi
+00025be0: 616e 7428 292e 7663 6f75 6e74 2829 0a20  ant().vcount(). 
+00025bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025c00: 2020 2020 2020 202f 2066 6c6f 6174 2873         / float(s
+00025c10: 656c 662e 6772 6170 682e 7663 6f75 6e74  elf.graph.vcount
+00025c20: 2829 2929 202b 2022 2929 2229 0a0a 2020  ())) + "))")..  
+00025c30: 2020 2020 2020 666f 7220 632c 2063 6f6d        for c, com
+00025c40: 7020 696e 2065 6e75 6d65 7261 7465 2863  p in enumerate(c
+00025c50: 6f6d 706f 6e65 6e74 7329 3a0a 2020 2020  omponents):.    
+00025c60: 2020 2020 2020 2020 2320 2049 6620 7468          #  If th
+00025c70: 6520 636f 6d70 6f6e 656e 7420 6861 7320  e component has 
+00025c80: 7369 7a65 2031 2c20 7365 7420 7261 6e64  size 1, set rand
+00025c90: 6f6d 2077 616c 6b20 6265 7477 6565 6e6e  om walk betweenn
+00025ca0: 6573 7320 746f 207a 6572 6f0a 2020 2020  ess to zero.    
+00025cb0: 2020 2020 2020 2020 2320 4649 584d 453a          # FIXME:
+00025cc0: 2063 6865 636b 2077 6879 2074 6865 7265   check why there
+00025cd0: 2077 6173 2061 2070 726f 626c 656d 2077   was a problem w
+00025ce0: 6974 6820 3d3d 310a 2020 2020 2020 2020  ith ==1.        
+00025cf0: 2020 2020 6966 206c 656e 2863 6f6d 7029      if len(comp)
+00025d00: 203c 2032 3a0a 2020 2020 2020 2020 2020   < 2:.          
+00025d10: 2020 2020 2020 6e73 695f 6e65 776d 616e        nsi_newman
+00025d20: 5f62 6574 7765 656e 6e65 7373 5b63 6f6d  _betweenness[com
+00025d30: 705b 305d 5d20 3d20 300a 2020 2020 2020  p[0]] = 0.      
+00025d40: 2020 2020 2020 2320 2046 6f72 206c 6172        #  For lar
+00025d50: 6765 7220 636f 6d70 6f6e 656e 7473 2c20  ger components, 
+00025d60: 636f 6e74 696e 7565 2077 6974 6820 7468  continue with th
+00025d70: 6520 6361 6c63 756c 6174 696f 6e0a 2020  e calculation.  
+00025d80: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00025d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025da0: 2320 2047 6574 2074 6865 2073 7562 6772  #  Get the subgr
+00025db0: 6170 6820 636f 7272 6573 706f 6e64 696e  aph correspondin
+00025dc0: 6720 746f 2063 6f6d 706f 6e65 6e74 2069  g to component i
+00025dd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00025de0: 2073 7562 6772 6170 6820 3d20 636f 6d70   subgraph = comp
+00025df0: 6f6e 656e 7473 2e73 7562 6772 6170 6828  onents.subgraph(
+00025e00: 6329 0a0a 2020 2020 2020 2020 2020 2020  c)..            
+00025e10: 2020 2020 2320 2047 6574 2074 6865 2073      #  Get the s
+00025e20: 7562 6772 6170 6820 4120 6d61 7472 6978  ubgraph A matrix
+00025e30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00025e40: 2041 203d 206e 702e 6172 7261 7928 7375   A = np.array(su
+00025e50: 6267 7261 7068 2e67 6574 5f61 646a 6163  bgraph.get_adjac
+00025e60: 656e 6379 2874 7970 653d 3229 2e64 6174  ency(type=2).dat
+00025e70: 612c 2064 7479 7065 3d41 444a 290a 0a20  a, dtype=ADJ).. 
+00025e80: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00025e90: 2020 4765 7420 7468 6520 6c69 7374 206f    Get the list o
+00025ea0: 6620 7665 7274 6578 206e 756d 6265 7273  f vertex numbers
+00025eb0: 2069 6e20 7468 6520 7375 6267 7261 7068   in the subgraph
+00025ec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00025ed0: 206e 6f64 6573 203d 2063 6f6d 700a 0a20   nodes = comp.. 
+00025ee0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00025ef0: 2045 7874 7261 6374 2063 6f72 7265 7370   Extract corresp
+00025f00: 6f6e 6469 6e67 2061 7265 6120 7765 6967  onding area weig
+00025f10: 6874 2076 6563 746f 723a 0a20 2020 2020  ht vector:.     
+00025f20: 2020 2020 2020 2020 2020 2077 203d 2074             w = t
+00025f30: 6f5f 6379 2873 656c 662e 6e6f 6465 5f77  o_cy(self.node_w
+00025f40: 6569 6768 7473 5b6e 6f64 6573 5d2c 2044  eights[nodes], D
+00025f50: 5745 4947 4854 290a 0a20 2020 2020 2020  WEIGHT)..       
+00025f60: 2020 2020 2020 2020 2023 2020 4765 6e65           #  Gene
+00025f70: 7261 7465 2061 204e 6574 776f 726b 206f  rate a Network o
+00025f80: 626a 6563 7420 7265 7072 6573 656e 7469  bject representi
+00025f90: 6e67 2074 6865 2073 7562 6772 6170 680a  ng the subgraph.
 00025fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025fb0: 2020 2020 2020 2020 2020 2020 4e2c 2073              N, s
-00025fc0: 7461 7274 5f69 2c20 656e 645f 6929 2c0a  tart_i, end_i),.
-00025fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025ff0: 2020 2020 2020 2020 6d6f 6475 6c65 3d22          module="
-00026000: 7079 756e 6963 6f72 6e22 2c20 6964 3d69  pyunicorn", id=i
-00026010: 6e64 6578 2c0a 2020 2020 2020 2020 2020  ndex,.          
-00026020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026030: 2020 2020 2020 2020 2020 2020 2020 7469                ti
-00026040: 6d65 5f65 7374 3d74 6869 735f 412e 7375  me_est=this_A.su
-00026050: 6d28 2929 0a0a 2020 2020 2020 2020 2020  m())..          
-00026060: 2020 2020 2020 2020 2020 2320 5265 7472            # Retr
-00026070: 6965 7665 2072 6573 756c 7473 206f 6620  ieve results of 
-00026080: 616c 6c20 7375 626d 6974 7465 6420 6a6f  all submitted jo
-00026090: 6273 3a0a 2020 2020 2020 2020 2020 2020  bs:.            
-000260a0: 2020 2020 2020 2020 636f 6d70 6f6e 656e          componen
-000260b0: 745f 6265 7477 6565 6e6e 6573 7320 3d20  t_betweenness = 
-000260c0: 6e70 2e7a 6572 6f73 284e 290a 2020 2020  np.zeros(N).    
-000260d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000260e0: 666f 7220 696e 6465 7820 696e 2072 616e  for index in ran
-000260f0: 6765 2870 6172 7473 293a 0a20 2020 2020  ge(parts):.     
-00026100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026110: 2020 2023 2074 6865 2066 6f6c 6c6f 7769     # the followi
-00026120: 6e67 2063 616c 6c20 636f 6e6e 6563 7473  ng call connects
-00026130: 2074 6f20 7468 6520 7375 626d 6974 7465   to the submitte
-00026140: 6420 6a6f 622c 0a20 2020 2020 2020 2020  d job,.         
-00026150: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00026160: 2077 6169 7473 2075 6e74 696c 2069 7420   waits until it 
-00026170: 6669 6e69 7368 6573 2c20 616e 6420 7265  finishes, and re
-00026180: 7472 6965 7665 7320 7468 6520 7265 7375  trieves the resu
-00026190: 6c74 3a0a 2020 2020 2020 2020 2020 2020  lt:.            
-000261a0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-000261b0: 656c 662e 7369 6c65 6e63 655f 6c65 7665  elf.silence_leve
-000261c0: 6c20 3c3d 2030 3a0a 2020 2020 2020 2020  l <= 0:.        
-000261d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000261e0: 2020 2020 7072 696e 7428 2272 6574 7269      print("retri
-000261f0: 6576 696e 6720 7265 7375 6c74 7320 6672  eving results fr
-00026200: 6f6d 2022 2c20 696e 6465 7829 0a20 2020  om ", index).   
-00026210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026220: 2020 2020 2074 6869 735f 6265 7477 6565       this_betwee
-00026230: 6e6e 6573 732c 2073 7461 7274 5f69 2c20  nness, start_i, 
-00026240: 656e 645f 6920 3d20 5c0a 2020 2020 2020  end_i = \.      
-00026250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026260: 2020 2020 2020 6d70 692e 6765 745f 7265        mpi.get_re
-00026270: 7375 6c74 2869 6e64 6578 290a 2020 2020  sult(index).    
-00026280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026290: 2020 2020 636f 6d70 6f6e 656e 745f 6265      component_be
-000262a0: 7477 6565 6e6e 6573 735b 7374 6172 745f  tweenness[start_
-000262b0: 693a 656e 645f 695d 203d 2074 6869 735f  i:end_i] = this_
-000262c0: 6265 7477 6565 6e6e 6573 730a 2020 2020  betweenness.    
-000262d0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-000262e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000262f0: 2020 2020 2020 636f 6d70 6f6e 656e 745f        component_
-00026300: 6265 7477 6565 6e6e 6573 732c 2073 7461  betweenness, sta
-00026310: 7274 5f69 2c20 656e 645f 6920 3d5c 0a20  rt_i, end_i =\. 
-00026320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026330: 2020 2020 2020 205f 6379 5f6d 7069 5f6e         _cy_mpi_n
-00026340: 6577 6d61 6e5f 6265 7477 6565 6e6e 6573  ewman_betweennes
-00026350: 7328 412e 6173 7479 7065 2869 6e74 292c  s(A.astype(int),
-00026360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00026370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00026390: 2020 2020 562e 6173 7479 7065 2866 6c6f      V.astype(flo
-000263a0: 6174 292c 204e 2c20 302c 204e 290a 0a20  at), N, 0, N).. 
-000263b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-000263c0: 6f6d 706f 6e65 6e74 5f62 6574 7765 656e  omponent_between
-000263d0: 6e65 7373 202b 3d20 3220 2a20 284e 202d  ness += 2 * (N -
-000263e0: 2031 290a 2020 2020 2020 2020 2020 2020   1).            
-000263f0: 2020 2020 636f 6d70 6f6e 656e 745f 6265      component_be
-00026400: 7477 6565 6e6e 6573 7320 2f3d 2028 4e20  tweenness /= (N 
-00026410: 2d20 312e 3029 2020 2320 544f 444f 3a20  - 1.0)  # TODO: 
-00026420: 7768 7920 6973 2074 6869 733f 0a0a 2020  why is this?..  
-00026430: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00026440: 736f 7274 2072 6573 756c 7473 2069 6e74  sort results int
-00026450: 6f20 636f 7272 6563 7420 706f 7369 7469  o correct positi
-00026460: 6f6e 730a 2020 2020 2020 2020 2020 2020  ons.            
-00026470: 2020 2020 6e6f 6465 7320 3d20 636f 6d70      nodes = comp
-00026480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00026490: 2066 6f72 206a 2c20 6e6f 6465 2069 6e20   for j, node in 
-000264a0: 656e 756d 6572 6174 6528 6e6f 6465 7329  enumerate(nodes)
-000264b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000264c0: 2020 2020 2020 6e65 776d 616e 5f62 6574        newman_bet
-000264d0: 7765 656e 6e65 7373 5b6e 6f64 655d 203d  weenness[node] =
-000264e0: 2063 6f6d 706f 6e65 6e74 5f62 6574 7765   component_betwe
-000264f0: 656e 6e65 7373 5b6a 5d0a 0a20 2020 2020  enness[j]..     
-00026500: 2020 2069 6620 7365 6c66 2e73 696c 656e     if self.silen
-00026510: 6365 5f6c 6576 656c 203c 3d20 303a 0a20  ce_level <= 0:. 
-00026520: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00026530: 2822 2e2e 2e74 6f6f 6b22 2c20 7469 6d65  ("...took", time
-00026540: 2e74 696d 6528 292d 7430 2c20 2273 6563  .time()-t0, "sec
-00026550: 6f6e 6473 2229 0a0a 2020 2020 2020 2020  onds")..        
-00026560: 7265 7475 726e 206e 6577 6d61 6e5f 6265  return newman_be
-00026570: 7477 6565 6e6e 6573 730a 0a20 2020 2064  tweenness..    d
-00026580: 6566 206e 7369 5f6e 6577 6d61 6e5f 6265  ef nsi_newman_be
-00026590: 7477 6565 6e6e 6573 7328 7365 6c66 2c20  tweenness(self, 
-000265a0: 6164 645f 6c6f 6361 6c5f 656e 6473 3d46  add_local_ends=F
-000265b0: 616c 7365 293a 0a20 2020 2020 2020 2022  alse):.        "
-000265c0: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
-000265d0: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
-000265e0: 2069 7473 206e 2e73 2e69 2e20 4e65 776d   its n.s.i. Newm
-000265f0: 616e 2d74 7970 6520 7261 6e64 6f6d 2077  an-type random w
-00026600: 616c 6b20 6265 7477 6565 6e6e 6573 732e  alk betweenness.
-00026610: 0a0a 2020 2020 2020 2020 5468 6973 206d  ..        This m
-00026620: 6561 7375 7265 7320 686f 7720 6f66 7465  easures how ofte
-00026630: 6e20 6120 7261 6e64 6f6d 2077 616c 6b20  n a random walk 
-00026640: 7365 6172 6368 2066 6f72 2061 2072 616e  search for a ran
-00026650: 646f 6d20 7461 7267 6574 206e 6f64 650a  dom target node.
-00026660: 2020 2020 2020 2020 6672 6f6d 2061 2072          from a r
-00026670: 616e 646f 6d20 736f 7572 6365 206e 6f64  andom source nod
-00026680: 6520 6973 2065 7870 6563 7465 6420 746f  e is expected to
-00026690: 2070 6173 7320 7468 6973 206e 6f64 652c   pass this node,
-000266a0: 206e 6f74 2063 6f75 6e74 696e 670a 2020   not counting.  
-000266b0: 2020 2020 2020 7768 656e 2074 6865 2077        when the w
-000266c0: 616c 6b20 7265 7475 726e 7320 616c 6f6e  alk returns alon
-000266d0: 6720 6120 6c69 6e6b 2069 7420 746f 6f6b  g a link it took
-000266e0: 2062 6566 6f72 6520 746f 206c 6561 7665   before to leave
-000266f0: 2074 6865 206e 6f64 652e 0a20 2020 2020   the node..     
-00026700: 2020 2028 7365 6520 5b4e 6577 6d61 6e32     (see [Newman2
-00026710: 3030 355d 5f29 0a0a 2020 2020 2020 2020  005]_)..        
-00026720: 496e 2074 6869 7320 6e2e 732e 692e 2076  In this n.s.i. v
-00026730: 6572 7369 6f6e 2c20 6e6f 6465 2077 6569  ersion, node wei
-00026740: 6768 7473 2061 7265 2074 616b 656e 2069  ghts are taken i
-00026750: 6e74 6f20 6163 636f 756e 742c 2061 6e64  nto account, and
-00026760: 206f 6e6c 790a 2020 2020 2020 2020 7261   only.        ra
-00026770: 6e64 6f6d 2077 616c 6b73 2061 7265 2075  ndom walks are u
-00026780: 7365 6420 7468 6174 2064 6f20 6e6f 7420  sed that do not 
-00026790: 7374 6172 7420 6f72 2065 6e64 2069 6e20  start or end in 
-000267a0: 6e65 6967 6862 6f72 7320 6f66 2074 6865  neighbors of the
-000267b0: 0a20 2020 2020 2020 206e 6f64 652e 0a0a  .        node...
-000267c0: 0a20 2020 2020 2020 202a 2a45 7861 6d70  .        **Examp
-000267d0: 6c65 3a2a 2a0a 0a20 2020 2020 2020 203e  le:**..        >
-000267e0: 3e3e 206e 6574 203d 204e 6574 776f 726b  >> net = Network
-000267f0: 2e53 6d61 6c6c 5465 7374 4e65 7477 6f72  .SmallTestNetwor
-00026800: 6b28 290a 2020 2020 2020 2020 3e3e 3e20  k().        >>> 
-00026810: 7228 6e65 742e 6e73 695f 6e65 776d 616e  r(net.nsi_newman
-00026820: 5f62 6574 7765 656e 6e65 7373 2829 290a  _betweenness()).
-00026830: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-00026840: 696e 6720 6e2e 732e 692e 204e 6577 6d61  ing n.s.i. Newma
-00026850: 6e2d 7479 7065 2072 616e 646f 6d20 7761  n-type random wa
-00026860: 6c6b 2062 6574 7765 656e 6e65 7373 2e2e  lk betweenness..
-00026870: 2e0a 2020 2020 2020 2020 2020 2028 6769  ..           (gi
-00026880: 616e 7420 636f 6d70 6f6e 656e 7420 7369  ant component si
-00026890: 7a65 3a20 3620 2831 2e30 2929 0a20 2020  ze: 6 (1.0)).   
-000268a0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-000268b0: 206e 2e73 2e69 2e20 6465 6772 6565 2e2e   n.s.i. degree..
-000268c0: 2e0a 2020 2020 2020 2020 6172 7261 7928  ..        array(
-000268d0: 5b20 302e 3430 3438 2c20 302e 202c 2030  [ 0.4048, 0. , 0
-000268e0: 2e38 3532 312c 2033 2e33 3335 372c 2031  .8521, 3.3357, 1
-000268f0: 2e33 3636 322c 2030 2e20 5d29 0a20 2020  .3662, 0. ]).   
-00026900: 2020 2020 203e 3e3e 2072 286e 6574 2e73       >>> r(net.s
-00026910: 706c 6974 7465 645f 636f 7079 2829 2e6e  plitted_copy().n
-00026920: 7369 5f6e 6577 6d61 6e5f 6265 7477 6565  si_newman_betwee
-00026930: 6e6e 6573 7328 2929 0a20 2020 2020 2020  nness()).       
-00026940: 2043 616c 6375 6c61 7469 6e67 206e 2e73   Calculating n.s
-00026950: 2e69 2e20 4e65 776d 616e 2d74 7970 6520  .i. Newman-type 
-00026960: 7261 6e64 6f6d 2077 616c 6b20 6265 7477  random walk betw
-00026970: 6565 6e6e 6573 732e 2e2e 0a20 2020 2020  eenness....     
-00026980: 2020 2020 2020 2867 6961 6e74 2063 6f6d        (giant com
-00026990: 706f 6e65 6e74 2073 697a 653a 2037 2028  ponent size: 7 (
-000269a0: 312e 3029 290a 2020 2020 2020 2020 4361  1.0)).        Ca
-000269b0: 6c63 756c 6174 696e 6720 6e2e 732e 692e  lculating n.s.i.
-000269c0: 2064 6567 7265 652e 2e2e 0a20 2020 2020   degree....     
-000269d0: 2020 2061 7272 6179 285b 2030 2e34 3034     array([ 0.404
-000269e0: 382c 2030 2e20 2c20 302e 3835 3231 2c20  8, 0. , 0.8521, 
-000269f0: 332e 3333 3537 2c20 312e 3336 3632 2c20  3.3357, 1.3662, 
-00026a00: 302e 202c 2030 2e20 5d29 0a20 2020 2020  0. , 0. ]).     
-00026a10: 2020 203e 3e3e 2072 286e 6574 2e6e 7369     >>> r(net.nsi
-00026a20: 5f6e 6577 6d61 6e5f 6265 7477 6565 6e6e  _newman_betweenn
-00026a30: 6573 7328 6164 645f 6c6f 6361 6c5f 656e  ess(add_local_en
-00026a40: 6473 3d54 7275 6529 290a 2020 2020 2020  ds=True)).      
-00026a50: 2020 4361 6c63 756c 6174 696e 6720 6e2e    Calculating n.
-00026a60: 732e 692e 204e 6577 6d61 6e2d 7479 7065  s.i. Newman-type
-00026a70: 2072 616e 646f 6d20 7761 6c6b 2062 6574   random walk bet
-00026a80: 7765 656e 6e65 7373 2e2e 2e0a 2020 2020  weenness....    
-00026a90: 2020 2020 2020 2028 6769 616e 7420 636f         (giant co
-00026aa0: 6d70 6f6e 656e 7420 7369 7a65 3a20 3620  mponent size: 6 
-00026ab0: 2831 2e30 2929 0a20 2020 2020 2020 2043  (1.0)).        C
-00026ac0: 616c 6375 6c61 7469 6e67 206e 2e73 2e69  alculating n.s.i
-00026ad0: 2e20 6465 6772 6565 2e2e 2e0a 2020 2020  . degree....    
-00026ae0: 2020 2020 6172 7261 7928 5b20 3133 312e      array([ 131.
-00026af0: 3434 3438 2c20 3132 382e 202c 2031 3037  4448, 128. , 107
-00026b00: 2e36 3432 312c 2031 3032 2e34 3435 372c  .6421, 102.4457,
-00026b10: 2031 3234 2e32 3036 322c 2038 302e 205d   124.2062, 80. ]
-00026b20: 290a 2020 2020 2020 2020 3e3e 3e20 7228  ).        >>> r(
-00026b30: 6e65 742e 7370 6c69 7474 6564 5f63 6f70  net.splitted_cop
-00026b40: 7928 292e 6e73 695f 6e65 776d 616e 5f62  y().nsi_newman_b
-00026b50: 6574 7765 656e 6e65 7373 280a 2020 2020  etweenness(.    
-00026b60: 2020 2020 2e2e 2e20 2020 2020 6164 645f      ...     add_
-00026b70: 6c6f 6361 6c5f 656e 6473 3d54 7275 6529  local_ends=True)
-00026b80: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-00026b90: 6174 696e 6720 6e2e 732e 692e 204e 6577  ating n.s.i. New
-00026ba0: 6d61 6e2d 7479 7065 2072 616e 646f 6d20  man-type random 
-00026bb0: 7761 6c6b 2062 6574 7765 656e 6e65 7373  walk betweenness
-00026bc0: 2e2e 2e0a 2020 2020 2020 2020 2020 2028  ....           (
-00026bd0: 6769 616e 7420 636f 6d70 6f6e 656e 7420  giant component 
-00026be0: 7369 7a65 3a20 3720 2831 2e30 2929 0a20  size: 7 (1.0)). 
-00026bf0: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-00026c00: 6e67 206e 2e73 2e69 2e20 6465 6772 6565  ng n.s.i. degree
-00026c10: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-00026c20: 7928 5b20 3133 312e 3434 3438 2c20 3132  y([ 131.4448, 12
-00026c30: 382e 202c 2031 3037 2e36 3432 312c 2031  8. , 107.6421, 1
-00026c40: 3032 2e34 3435 372c 2031 3234 2e32 3036  02.4457, 124.206
-00026c50: 322c 2038 302e 202c 2038 302e 205d 290a  2, 80. , 80. ]).
-00026c60: 0a20 2020 2020 2020 2061 7320 636f 6d70  .        as comp
-00026c70: 6172 6564 2074 6f20 6974 7320 756e 7765  ared to its unwe
-00026c80: 6967 6874 6564 2076 6572 7369 6f6e 3a0a  ighted version:.
-00026c90: 0a20 2020 2020 2020 203e 3e3e 206e 6574  .        >>> net
-00026ca0: 203d 204e 6574 776f 726b 2e53 6d61 6c6c   = Network.Small
-00026cb0: 5465 7374 4e65 7477 6f72 6b28 290a 2020  TestNetwork().  
-00026cc0: 2020 2020 2020 3e3e 3e20 7228 6e65 742e        >>> r(net.
-00026cd0: 6e65 776d 616e 5f62 6574 7765 656e 6e65  newman_betweenne
-00026ce0: 7373 2829 290a 2020 2020 2020 2020 4361  ss()).        Ca
-00026cf0: 6c63 756c 6174 696e 6720 4e65 776d 616e  lculating Newman
-00026d00: 2773 2072 616e 646f 6d20 7761 6c6b 2062  's random walk b
-00026d10: 6574 7765 656e 6e65 7373 2e2e 2e0a 2020  etweenness....  
-00026d20: 2020 2020 2020 2020 2028 6769 616e 7420           (giant 
-00026d30: 636f 6d70 6f6e 656e 7420 7369 7a65 3a20  component size: 
-00026d40: 3620 2831 2e30 2929 0a20 2020 2020 2020  6 (1.0)).       
-00026d50: 2061 7272 6179 285b 2034 2e31 3831 382c   array([ 4.1818,
-00026d60: 2033 2e34 3138 322c 2032 2e35 3039 312c   3.4182, 2.5091,
-00026d70: 2033 2e30 3138 322c 2033 2e36 202c 2032   3.0182, 3.6 , 2
-00026d80: 2e20 5d29 0a20 2020 2020 2020 203e 3e3e  . ]).        >>>
-00026d90: 2072 286e 6574 2e73 706c 6974 7465 645f   r(net.splitted_
-00026da0: 636f 7079 2829 2e6e 6577 6d61 6e5f 6265  copy().newman_be
-00026db0: 7477 6565 6e6e 6573 7328 2929 0a20 2020  tweenness()).   
-00026dc0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-00026dd0: 204e 6577 6d61 6e27 7320 7261 6e64 6f6d   Newman's random
-00026de0: 2077 616c 6b20 6265 7477 6565 6e6e 6573   walk betweennes
-00026df0: 732e 2e2e 0a20 2020 2020 2020 2020 2020  s....           
-00026e00: 2867 6961 6e74 2063 6f6d 706f 6e65 6e74  (giant component
-00026e10: 2073 697a 653a 2037 2028 312e 3029 290a   size: 7 (1.0)).
-00026e20: 2020 2020 2020 2020 6172 7261 7928 5b20          array([ 
-00026e30: 352e 3236 3236 2c20 332e 3531 3532 2c20  5.2626, 3.5152, 
-00026e40: 322e 3534 3535 2c20 332e 3231 3231 2c20  2.5455, 3.2121, 
-00026e50: 332e 3831 3832 2c20 322e 3535 3536 2c20  3.8182, 2.5556, 
-00026e60: 322e 3535 3536 5d29 0a0a 2020 2020 2020  2.5556])..      
-00026e70: 2020 3a61 7267 2062 6f6f 6c20 6164 645f    :arg bool add_
-00026e80: 6c6f 6361 6c5f 656e 6473 3a20 496e 6469  local_ends: Indi
-00026e90: 6361 7465 7320 7768 6574 6865 7220 746f  cates whether to
-00026ea0: 2061 6464 2061 2063 6f72 7265 6374 696f   add a correctio
-00026eb0: 6e20 666f 7220 7468 650a 2020 2020 2020  n for the.      
-00026ec0: 2020 2020 2020 6661 6374 2074 6861 7420        fact that 
-00026ed0: 7761 6c6b 7320 7374 6172 7469 6e67 206f  walks starting o
-00026ee0: 7220 656e 6469 6e67 2069 6e20 6e65 6967  r ending in neig
-00026ef0: 6862 6f72 7320 6172 6520 6e6f 7420 7573  hbors are not us
-00026f00: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
-00026f10: 2844 6566 6175 6c74 3a20 6661 6c73 6529  (Default: false)
-00026f20: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-00026f30: 2061 7272 6179 205b 666c 6f61 743e 3d30   array [float>=0
-00026f40: 5d0a 2020 2020 2020 2020 2222 220a 2020  ].        """.  
-00026f50: 2020 2020 2020 6966 2073 656c 662e 7369        if self.si
-00026f60: 6c65 6e63 655f 6c65 7665 6c20 3c3d 2031  lence_level <= 1
-00026f70: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-00026f80: 696e 7428 2243 616c 6375 6c61 7469 6e67  int("Calculating
-00026f90: 206e 2e73 2e69 2e20 4e65 776d 616e 2d74   n.s.i. Newman-t
-00026fa0: 7970 6520 7261 6e64 6f6d 2077 616c 6b20  ype random walk 
-00026fb0: 6265 7477 6565 6e6e 6573 732e 2e2e 2229  betweenness...")
-00026fc0: 0a0a 2020 2020 2020 2020 7430 203d 2074  ..        t0 = t
-00026fd0: 696d 652e 7469 6d65 2829 0a0a 2020 2020  ime.time()..    
-00026fe0: 2020 2020 2320 2049 6e69 7469 616c 697a      #  Initializ
-00026ff0: 6520 7468 6520 6172 7261 7920 746f 2068  e the array to h
-00027000: 6f6c 6420 7261 6e64 6f6d 2077 616c 6b20  old random walk 
-00027010: 6265 7477 6565 6e6e 6573 730a 2020 2020  betweenness.    
-00027020: 2020 2020 6e73 695f 6e65 776d 616e 5f62      nsi_newman_b
-00027030: 6574 7765 656e 6e65 7373 203d 206e 702e  etweenness = np.
-00027040: 7a65 726f 7328 7365 6c66 2e4e 290a 0a20  zeros(self.N).. 
-00027050: 2020 2020 2020 2023 2020 5261 6e64 6f6d         #  Random
-00027060: 2077 616c 6b20 6265 7477 6565 6e6e 6573   walk betweennes
-00027070: 7320 6861 7320 746f 2062 6520 6361 6c63  s has to be calc
-00027080: 756c 6174 6564 2066 6f72 2065 6163 6820  ulated for each 
-00027090: 636f 6d70 6f6e 656e 740a 2020 2020 2020  component.      
-000270a0: 2020 2320 2073 6570 6172 6174 656c 792e    #  separately.
-000270b0: 2054 6865 7265 666f 7265 2067 6574 2064   Therefore get d
-000270c0: 6966 6665 7265 6e74 2063 6f6d 706f 6e65  ifferent compone
-000270d0: 6e74 7320 6f66 2074 6865 2067 7261 7068  nts of the graph
-000270e0: 2066 6972 7374 0a20 2020 2020 2020 2063   first.        c
-000270f0: 6f6d 706f 6e65 6e74 7320 3d20 7365 6c66  omponents = self
-00027100: 2e67 7261 7068 2e63 6c75 7374 6572 7328  .graph.clusters(
-00027110: 290a 0a20 2020 2020 2020 2023 2020 5072  )..        #  Pr
-00027120: 696e 7420 6769 616e 7420 636f 6d70 6f6e  int giant compon
-00027130: 656e 7420 7369 7a65 0a20 2020 2020 2020  ent size.       
-00027140: 2069 6620 7365 6c66 2e73 696c 656e 6365   if self.silence
-00027150: 5f6c 6576 656c 203c 3d20 313a 0a20 2020  _level <= 1:.   
-00027160: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
-00027170: 2020 2028 6769 616e 7420 636f 6d70 6f6e     (giant compon
-00027180: 656e 7420 7369 7a65 3a20 220a 2020 2020  ent size: ".    
-00027190: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-000271a0: 7374 7228 636f 6d70 6f6e 656e 7473 2e67  str(components.g
-000271b0: 6961 6e74 2829 2e76 636f 756e 7428 2929  iant().vcount())
-000271c0: 202b 2022 2028 220a 2020 2020 2020 2020   + " (".        
-000271d0: 2020 2020 2020 2020 2020 2b20 7374 7228            + str(
-000271e0: 636f 6d70 6f6e 656e 7473 2e67 6961 6e74  components.giant
-000271f0: 2829 2e76 636f 756e 7428 290a 2020 2020  ().vcount().    
-00027200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027210: 2020 2020 2f20 666c 6f61 7428 7365 6c66      / float(self
-00027220: 2e67 7261 7068 2e76 636f 756e 7428 2929  .graph.vcount())
-00027230: 2920 2b20 2229 2922 290a 0a20 2020 2020  ) + "))")..     
-00027240: 2020 2066 6f72 2063 2c20 636f 6d70 2069     for c, comp i
-00027250: 6e20 656e 756d 6572 6174 6528 636f 6d70  n enumerate(comp
-00027260: 6f6e 656e 7473 293a 0a20 2020 2020 2020  onents):.       
-00027270: 2020 2020 2023 2020 4966 2074 6865 2063       #  If the c
-00027280: 6f6d 706f 6e65 6e74 2068 6173 2073 697a  omponent has siz
-00027290: 6520 312c 2073 6574 2072 616e 646f 6d20  e 1, set random 
-000272a0: 7761 6c6b 2062 6574 7765 656e 6e65 7373  walk betweenness
-000272b0: 2074 6f20 7a65 726f 0a20 2020 2020 2020   to zero.       
-000272c0: 2020 2020 2023 2046 4958 4d45 3a20 6368       # FIXME: ch
-000272d0: 6563 6b20 7768 7920 7468 6572 6520 7761  eck why there wa
-000272e0: 7320 6120 7072 6f62 6c65 6d20 7769 7468  s a problem with
-000272f0: 203d 3d31 0a20 2020 2020 2020 2020 2020   ==1.           
-00027300: 2069 6620 6c65 6e28 636f 6d70 2920 3c20   if len(comp) < 
-00027310: 323a 0a20 2020 2020 2020 2020 2020 2020  2:.             
-00027320: 2020 206e 7369 5f6e 6577 6d61 6e5f 6265     nsi_newman_be
-00027330: 7477 6565 6e6e 6573 735b 636f 6d70 5b30  tweenness[comp[0
-00027340: 5d5d 203d 2030 0a20 2020 2020 2020 2020  ]] = 0.         
-00027350: 2020 2023 2020 466f 7220 6c61 7267 6572     #  For larger
-00027360: 2063 6f6d 706f 6e65 6e74 732c 2063 6f6e   components, con
-00027370: 7469 6e75 6520 7769 7468 2074 6865 2063  tinue with the c
-00027380: 616c 6375 6c61 7469 6f6e 0a20 2020 2020  alculation.     
-00027390: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000273a0: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-000273b0: 4765 7420 7468 6520 7375 6267 7261 7068  Get the subgraph
-000273c0: 2063 6f72 7265 7370 6f6e 6469 6e67 2074   corresponding t
-000273d0: 6f20 636f 6d70 6f6e 656e 7420 690a 2020  o component i.  
-000273e0: 2020 2020 2020 2020 2020 2020 2020 7375                su
-000273f0: 6267 7261 7068 203d 2063 6f6d 706f 6e65  bgraph = compone
-00027400: 6e74 732e 7375 6267 7261 7068 2863 290a  nts.subgraph(c).
-00027410: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00027420: 2023 2020 4765 7420 7468 6520 7375 6267   #  Get the subg
-00027430: 7261 7068 2041 206d 6174 7269 780a 2020  raph A matrix.  
-00027440: 2020 2020 2020 2020 2020 2020 2020 4120                A 
-00027450: 3d20 6e70 2e61 7272 6179 2873 7562 6772  = np.array(subgr
-00027460: 6170 682e 6765 745f 6164 6a61 6365 6e63  aph.get_adjacenc
-00027470: 7928 7479 7065 3d32 292e 6461 7461 2c0a  y(type=2).data,.
-00027480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027490: 2020 2020 2020 2020 2020 2020 2064 7479               dty
-000274a0: 7065 3d6e 702e 696e 7438 290a 0a20 2020  pe=np.int8)..   
-000274b0: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-000274c0: 4765 7420 7468 6520 6c69 7374 206f 6620  Get the list of 
-000274d0: 7665 7274 6578 206e 756d 6265 7273 2069  vertex numbers i
-000274e0: 6e20 7468 6520 7375 6267 7261 7068 0a20  n the subgraph. 
-000274f0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00027500: 6f64 6573 203d 2063 6f6d 700a 0a20 2020  odes = comp..   
-00027510: 2020 2020 2020 2020 2020 2020 2023 2045               # E
-00027520: 7874 7261 6374 2063 6f72 7265 7370 6f6e  xtract correspon
-00027530: 6469 6e67 2061 7265 6120 7765 6967 6874  ding area weight
-00027540: 2076 6563 746f 723a 0a20 2020 2020 2020   vector:.       
-00027550: 2020 2020 2020 2020 2077 203d 206e 702e           w = np.
-00027560: 7a65 726f 7328 6c65 6e28 6e6f 6465 7329  zeros(len(nodes)
-00027570: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00027580: 2020 666f 7220 6a2c 206e 6f64 6520 696e    for j, node in
-00027590: 2065 6e75 6d65 7261 7465 286e 6f64 6573   enumerate(nodes
-000275a0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-000275b0: 2020 2020 2020 2077 5b6a 5d20 3d20 7365         w[j] = se
-000275c0: 6c66 2e6e 6f64 655f 7765 6967 6874 735b  lf.node_weights[
-000275d0: 6e6f 6465 5d0a 0a20 2020 2020 2020 2020  node]..         
-000275e0: 2020 2020 2020 2023 2020 4765 6e65 7261         #  Genera
-000275f0: 7465 2061 204e 6574 776f 726b 206f 626a  te a Network obj
-00027600: 6563 7420 7265 7072 6573 656e 7469 6e67  ect representing
-00027610: 2074 6865 2073 7562 6772 6170 680a 2020   the subgraph.  
-00027620: 2020 2020 2020 2020 2020 2020 2020 7375                su
-00027630: 626e 6574 203d 204e 6574 776f 726b 2861  bnet = Network(a
-00027640: 646a 6163 656e 6379 3d41 2c20 6469 7265  djacency=A, dire
-00027650: 6374 6564 3d46 616c 7365 2c20 6e6f 6465  cted=False, node
-00027660: 5f77 6569 6768 7473 3d77 290a 2020 2020  _weights=w).    
-00027670: 2020 2020 2020 2020 2020 2020 4e20 3d20              N = 
-00027680: 7375 626e 6574 2e4e 0a0a 2020 2020 2020  subnet.N..      
-00027690: 2020 2020 2020 2020 2020 2320 2049 6e69            #  Ini
-000276a0: 7469 616c 697a 6520 7468 6520 5257 4220  tialize the RWB 
-000276b0: 6172 7261 790a 2020 2020 2020 2020 2020  array.          
-000276c0: 2020 2020 2020 636f 6d70 6f6e 656e 745f        component_
-000276d0: 6265 7477 6565 6e6e 6573 7320 3d20 6e70  betweenness = np
-000276e0: 2e7a 6572 6f73 284e 290a 0a20 2020 2020  .zeros(N)..     
-000276f0: 2020 2020 2020 2020 2020 2023 2073 705f             # sp_
-00027700: 4d20 3d20 6172 6561 2d77 6569 6768 7465  M = area-weighte
-00027710: 6420 4b69 7263 6868 6f66 6620 6d61 7472  d Kirchhoff matr
-00027720: 6978 202a 2064 6961 6728 7729 5e28 2d31  ix * diag(w)^(-1
-00027730: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00027740: 2020 4170 203d 2073 7562 6e65 742e 7370    Ap = subnet.sp
-00027750: 5f41 706c 7573 2829 0a20 2020 2020 2020  _Aplus().       
-00027760: 2020 2020 2020 2020 2044 772c 2044 7749           Dw, DwI
-00027770: 203d 2073 7562 6e65 742e 7370 5f64 6961   = subnet.sp_dia
-00027780: 675f 7728 292c 2073 7562 6e65 742e 7370  g_w(), subnet.sp
-00027790: 5f64 6961 675f 775f 696e 7628 290a 2020  _diag_w_inv().  
-000277a0: 2020 2020 2020 2020 2020 2020 2020 446b                Dk
-000277b0: 2c20 446b 4920 3d20 7375 626e 6574 2e73  , DkI = subnet.s
-000277c0: 705f 6e73 695f 6469 6167 5f6b 2829 2c20  p_nsi_diag_k(), 
-000277d0: 7375 626e 6574 2e73 705f 6e73 695f 6469  subnet.sp_nsi_di
-000277e0: 6167 5f6b 5f69 6e76 2829 0a20 2020 2020  ag_k_inv().     
-000277f0: 2020 2020 2020 2020 2020 2073 705f 4d20             sp_M 
-00027800: 3d20 4477 202a 2028 446b 202d 2041 7020  = Dw * (Dk - Ap 
-00027810: 2a20 4477 2920 2a20 4477 490a 0a20 2020  * Dw) * DwI..   
-00027820: 2020 2020 2020 2020 2020 2020 2023 2069               # i
-00027830: 6e76 6572 7420 7370 5f4d 2077 6974 686f  nvert sp_M witho
-00027840: 7574 206c 6173 7420 726f 772f 636f 6c20  ut last row/col 
-00027850: 2873 6565 2061 626f 7665 290a 2020 2020  (see above).    
-00027860: 2020 2020 2020 2020 2020 2020 7370 5f4d              sp_M
-00027870: 5f69 6e76 203d 2073 702e 6c69 6c5f 6d61  _inv = sp.lil_ma
-00027880: 7472 6978 2828 4e2c 204e 2929 0a20 2020  trix((N, N)).   
-00027890: 2020 2020 2020 2020 2020 2020 2073 705f               sp_
-000278a0: 4d5f 696e 765b 3a2d 312c 203a 2d31 5d20  M_inv[:-1, :-1] 
-000278b0: 3d20 696e 7628 7370 5f4d 5b3a 2d31 2c20  = inv(sp_M[:-1, 
-000278c0: 3a2d 315d 290a 0a20 2020 2020 2020 2020  :-1])..         
-000278d0: 2020 2020 2020 2023 204e 6f74 653a 2073         # Note: s
-000278e0: 705f 4d5f 696e 7620 6973 206e 6f74 206e  p_M_inv is not n
-000278f0: 6563 6573 7361 7269 6c79 2073 7061 7273  ecessarily spars
-00027900: 652c 2073 6f20 7468 6520 6f72 6465 7220  e, so the order 
-00027910: 6973 0a20 2020 2020 2020 2020 2020 2020  is.             
-00027920: 2020 2023 2069 6d70 6f72 7461 6e74 2066     # important f
-00027930: 6f72 2070 6572 666f 726d 616e 6365 0a20  or performance. 
-00027940: 2020 2020 2020 2020 2020 2020 2020 2056                 V
-00027950: 203d 2028 2844 6b49 202a 2041 7029 202a   = ((DkI * Ap) *
-00027960: 2073 705f 4d5f 696e 7629 2e54 2e61 7374   sp_M_inv).T.ast
-00027970: 7970 6528 2766 6c6f 6174 3332 2729 2e41  ype('float32').A
-00027980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00027990: 2064 656c 2073 7562 6772 6170 682c 2041   del subgraph, A
-000279a0: 702c 2044 772c 2044 7749 2c20 446b 2c20  p, Dw, DwI, Dk, 
-000279b0: 446b 492c 2073 705f 4d2c 2073 705f 4d5f  DkI, sp_M, sp_M_
-000279c0: 696e 760a 0a20 2020 2020 2020 2020 2020  inv..           
-000279d0: 2020 2020 2023 2054 4f44 4f3a 2076 6572       # TODO: ver
-000279e0: 6966 7920 7468 6174 2074 6869 7320 7761  ify that this wa
-000279f0: 7320 696e 6465 6564 2077 726f 6e67 0a20  s indeed wrong. 
-00027a00: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00027a10: 2077 203d 2073 656c 662e 6e6f 6465 5f77   w = self.node_w
-00027a20: 6569 6768 7473 0a0a 2020 2020 2020 2020  eights..        
-00027a30: 2020 2020 2020 2020 2320 696e 6469 6361          # indica
-00027a40: 746f 7220 6d61 7472 6978 2074 6861 7420  tor matrix that 
-00027a50: 692c 6a20 6172 6520 6e6f 7420 6e65 6967  i,j are not neig
-00027a60: 6862 6f75 7265 6420 6f72 2065 7175 616c  hboured or equal
-00027a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00027a80: 206e 6f74 5f61 646a 6163 656e 745f 6f72   not_adjacent_or
-00027a90: 5f65 7175 616c 203d 2028 3120 2d20 4120  _equal = (1 - A 
-00027aa0: 2d20 6e70 2e69 6465 6e74 6974 7928 4e29  - np.identity(N)
-00027ab0: 292e 6173 7479 7065 2827 696e 7438 2729  ).astype('int8')
-00027ac0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00027ad0: 2020 6966 206d 7069 2e61 7661 696c 6162    if mpi.availab
-00027ae0: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
-00027af0: 2020 2020 2020 2020 7061 7274 7320 3d20          parts = 
-00027b00: 6d61 7828 312c 2069 6e74 286e 702e 6365  max(1, int(np.ce
-00027b10: 696c 286d 696e 2828 6d70 692e 7369 7a65  il(min((mpi.size
-00027b20: 2d31 2920 2a20 3130 2e30 2c0a 2020 2020  -1) * 10.0,.    
-00027b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027b50: 2020 2020 2020 2020 2020 2020 2020 2030                 0
-00027b60: 2e31 202a 204e 2929 2929 0a20 2020 2020  .1 * N)))).     
-00027b70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00027b80: 7465 7020 3d20 696e 7428 6e70 2e63 6569  tep = int(np.cei
-00027b90: 6c28 312e 302a 4e2f 2831 2e30 2a70 6172  l(1.0*N/(1.0*par
-00027ba0: 7473 2929 290a 2020 2020 2020 2020 2020  ts))).          
-00027bb0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-00027bc0: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
-00027bd0: 3c3d 2030 3a0a 2020 2020 2020 2020 2020  <= 0:.          
-00027be0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00027bf0: 696e 7428 2220 2020 7061 7261 6c6c 656c  int("   parallel
-00027c00: 697a 696e 6720 6f6e 2022 202b 2073 7472  izing on " + str
-00027c10: 2828 6d70 692e 7369 7a65 2d31 2929 0a20  ((mpi.size-1)). 
-00027c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027c30: 2020 2020 2020 2020 2020 2020 202b 2022               + "
-00027c40: 2073 6c61 7665 7320 696e 746f 2022 202b   slaves into " +
-00027c50: 2073 7472 2870 6172 7473 2920 2b20 2220   str(parts) + " 
-00027c60: 7061 7274 7320 7769 7468 2022 0a20 2020  parts with ".   
-00027c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027c80: 2020 2020 2020 2020 2020 202b 2073 7472             + str
-00027c90: 2873 7465 7029 202b 2022 206e 6f64 6573  (step) + " nodes
-00027ca0: 2065 6163 682e 2e2e 2229 0a0a 2020 2020   each...")..    
-00027cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027cc0: 666f 7220 6964 7820 696e 2072 616e 6765  for idx in range
-00027cd0: 2870 6172 7473 293a 0a20 2020 2020 2020  (parts):.       
-00027ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027cf0: 2073 7461 7274 5f69 203d 2069 6478 202a   start_i = idx *
-00027d00: 2073 7465 700a 2020 2020 2020 2020 2020   step.          
-00027d10: 2020 2020 2020 2020 2020 2020 2020 656e                en
-00027d20: 645f 6920 3d20 6d69 6e28 2869 6478 2b31  d_i = min((idx+1
-00027d30: 292a 7374 6570 2c20 4e29 0a20 2020 2020  )*step, N).     
-00027d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027d50: 2020 2069 6620 7374 6172 745f 6920 3e3d     if start_i >=
-00027d60: 2065 6e64 5f69 3a0a 2020 2020 2020 2020   end_i:.        
-00027d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027d80: 2020 2020 6272 6561 6b0a 2020 2020 2020      break.      
-00027d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027da0: 2020 7468 6973 5f41 203d 2041 5b73 7461    this_A = A[sta
-00027db0: 7274 5f69 3a65 6e64 5f69 2c20 3a5d 0a20  rt_i:end_i, :]. 
-00027dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027dd0: 2020 2020 2020 2074 6869 735f 6e6f 745f         this_not_
-00027de0: 6164 6a61 6365 6e74 5f6f 725f 6571 7561  adjacent_or_equa
-00027df0: 6c20 3d20 5c0a 2020 2020 2020 2020 2020  l = \.          
-00027e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027e10: 2020 6e6f 745f 6164 6a61 6365 6e74 5f6f    not_adjacent_o
-00027e20: 725f 6571 7561 6c5b 7374 6172 745f 693a  r_equal[start_i:
-00027e30: 656e 645f 692c 203a 5d0a 0a20 2020 2020  end_i, :]..     
-00027e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027e50: 2020 206d 7069 2e73 7562 6d69 745f 6361     mpi.submit_ca
-00027e60: 6c6c 280a 2020 2020 2020 2020 2020 2020  ll(.            
-00027e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027e80: 225f 6379 5f6d 7069 5f6e 7369 5f6e 6577  "_cy_mpi_nsi_new
-00027e90: 6d61 6e5f 6265 7477 6565 6e6e 6573 7322  man_betweenness"
-00027ea0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00027eb0: 2020 2020 2020 2020 2020 2020 2020 2874                (t
-00027ec0: 6869 735f 412e 6173 7479 7065 2869 6e74  his_A.astype(int
-00027ed0: 292c 2056 2e61 7374 7970 6528 666c 6f61  ), V.astype(floa
-00027ee0: 7429 2c20 4e2c 0a20 2020 2020 2020 2020  t), N,.         
-00027ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f00: 2020 2020 772e 6173 7479 7065 2866 6c6f      w.astype(flo
-00027f10: 6174 292c 0a20 2020 2020 2020 2020 2020  at),.           
-00027f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f30: 2020 7468 6973 5f6e 6f74 5f61 646a 6163    this_not_adjac
-00027f40: 656e 745f 6f72 5f65 7175 616c 2e61 7374  ent_or_equal.ast
-00027f50: 7970 6528 696e 7429 2c20 7374 6172 745f  ype(int), start_
-00027f60: 692c 0a20 2020 2020 2020 2020 2020 2020  i,.             
-00027f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027f80: 656e 645f 6929 2c0a 2020 2020 2020 2020  end_i),.        
-00027f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00027fa0: 2020 2020 6d6f 6475 6c65 3d22 7079 756e      module="pyun
-00027fb0: 6963 6f72 6e22 2c20 6964 3d69 6478 290a  icorn", id=idx).
-00027fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00027fd0: 2020 2020 2023 2052 6574 7269 6576 6520       # Retrieve 
-00027fe0: 7265 7375 6c74 7320 6f66 2061 6c6c 2073  results of all s
-00027ff0: 7562 6d69 7465 6420 6a6f 6273 0a20 2020  ubmited jobs.   
-00028000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00028010: 2063 6f6d 706f 6e65 6e74 5f62 6574 7765   component_betwe
-00028020: 656e 6e65 7373 203d 206e 702e 7a65 726f  enness = np.zero
-00028030: 7328 4e29 0a20 2020 2020 2020 2020 2020  s(N).           
-00028040: 2020 2020 2020 2020 2066 6f72 2069 6478           for idx
-00028050: 2069 6e20 7261 6e67 6528 7061 7274 7329   in range(parts)
-00028060: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00028070: 2020 2020 2020 2020 2020 7468 6973 5f62            this_b
-00028080: 6574 7765 656e 6e65 7373 2c20 7374 6172  etweenness, star
-00028090: 745f 692c 2065 6e64 5f69 203d 206d 7069  t_i, end_i = mpi
-000280a0: 2e67 6574 5f72 6573 756c 7428 6964 7829  .get_result(idx)
-000280b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000280c0: 2020 2020 2020 2020 2063 6f6d 706f 6e65           compone
-000280d0: 6e74 5f62 6574 7765 656e 6e65 7373 5b73  nt_betweenness[s
-000280e0: 7461 7274 5f69 3a65 6e64 5f69 5d20 3d20  tart_i:end_i] = 
-000280f0: 7468 6973 5f62 6574 7765 656e 6e65 7373  this_betweenness
-00028100: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00028110: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00028120: 2020 2020 2020 2020 2020 2020 636f 6d70              comp
-00028130: 6f6e 656e 745f 6265 7477 6565 6e6e 6573  onent_betweennes
-00028140: 732c 2073 7461 7274 5f69 2c20 656e 645f  s, start_i, end_
-00028150: 6920 3d20 5c0a 2020 2020 2020 2020 2020  i = \.          
-00028160: 2020 2020 2020 2020 2020 2020 2020 5f63                _c
-00028170: 795f 6d70 695f 6e73 695f 6e65 776d 616e  y_mpi_nsi_newman
-00028180: 5f62 6574 7765 656e 6e65 7373 280a 2020  _betweenness(.  
-00028190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000281a0: 2020 2020 2020 2020 2020 412e 6173 7479            A.asty
-000281b0: 7065 2869 6e74 292c 2056 2e61 7374 7970  pe(int), V.astyp
-000281c0: 6528 666c 6f61 7429 2c20 4e2c 2077 2e61  e(float), N, w.a
-000281d0: 7374 7970 6528 666c 6f61 7429 2c0a 2020  stype(float),.  
-000281e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000281f0: 2020 2020 2020 2020 2020 6e6f 745f 6164            not_ad
-00028200: 6a61 6365 6e74 5f6f 725f 6571 7561 6c2e  jacent_or_equal.
-00028210: 6173 7479 7065 2869 6e74 292c 2030 2c20  astype(int), 0, 
-00028220: 4e29 0a0a 2020 2020 2020 2020 2020 2020  N)..            
-00028230: 2020 2020 2320 2043 6f72 7265 6374 696f      #  Correctio
-00028240: 6e20 666f 7220 7468 6520 6661 6374 2074  n for the fact t
-00028250: 6861 7420 7765 2075 7365 6420 6f6e 6c79  hat we used only
-00028260: 2073 2c74 206e 6f74 0a20 2020 2020 2020   s,t not.       
-00028270: 2020 2020 2020 2020 2023 2020 6e65 6967           #  neig
-00028280: 6862 6f75 7265 6420 746f 2069 0a20 2020  hboured to i.   
-00028290: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-000282a0: 6164 645f 6c6f 6361 6c5f 656e 6473 3a0a  add_local_ends:.
-000282b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000282c0: 2020 2020 6e73 695f 6b20 3d20 7375 626e      nsi_k = subn
-000282d0: 6574 2e6e 7369 5f64 6567 7265 6528 290a  et.nsi_degree().
-000282e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000282f0: 2020 2020 636f 6d70 6f6e 656e 745f 6265      component_be
-00028300: 7477 6565 6e6e 6573 7320 2b3d 2028 322e  tweenness += (2.
-00028310: 3020 2a20 772e 7375 6d28 2920 2d20 6e73  0 * w.sum() - ns
-00028320: 695f 6b29 202a 206e 7369 5f6b 0a0a 2020  i_k) * nsi_k..  
-00028330: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00028340: 2043 6f70 7920 7265 7375 6c74 7320 696e   Copy results in
-00028350: 746f 2072 616e 646f 6d57 616c 6b42 6574  to randomWalkBet
-00028360: 7765 656e 6e65 7373 4172 7261 7920 6174  weennessArray at
-00028370: 2074 6865 2063 6f72 7265 6374 0a20 2020   the correct.   
-00028380: 2020 2020 2020 2020 2020 2020 2023 2020               #  
-00028390: 706f 7369 7469 6f6e 730a 2020 2020 2020  positions.      
-000283a0: 2020 2020 2020 2020 2020 666f 7220 6a2c            for j,
-000283b0: 206e 6f64 6520 696e 2065 6e75 6d65 7261   node in enumera
-000283c0: 7465 286e 6f64 6573 293a 0a20 2020 2020  te(nodes):.     
-000283d0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-000283e0: 7369 5f6e 6577 6d61 6e5f 6265 7477 6565  si_newman_betwee
-000283f0: 6e6e 6573 735b 6e6f 6465 5d20 3d20 636f  nness[node] = co
-00028400: 6d70 6f6e 656e 745f 6265 7477 6565 6e6e  mponent_betweenn
-00028410: 6573 735b 6a5d 0a0a 2020 2020 2020 2020  ess[j]..        
-00028420: 6966 2073 656c 662e 7369 6c65 6e63 655f  if self.silence_
-00028430: 6c65 7665 6c20 3c3d 2030 3a0a 2020 2020  level <= 0:.    
-00028440: 2020 2020 2020 2020 7072 696e 7428 222e          print(".
-00028450: 2e2e 746f 6f6b 222c 2074 696d 652e 7469  ..took", time.ti
-00028460: 6d65 2829 2d74 302c 2022 7365 636f 6e64  me()-t0, "second
-00028470: 7322 290a 0a20 2020 2020 2020 2072 6574  s")..        ret
-00028480: 7572 6e20 6e73 695f 6e65 776d 616e 5f62  urn nsi_newman_b
-00028490: 6574 7765 656e 6e65 7373 0a0a 2020 2020  etweenness..    
-000284a0: 230a 2020 2020 2320 2045 6666 6963 6965  #.    #  Efficie
-000284b0: 6e63 7920 6d65 6173 7572 6573 0a20 2020  ncy measures.   
-000284c0: 2023 0a0a 2020 2020 6465 6620 676c 6f62   #..    def glob
-000284d0: 616c 5f65 6666 6963 6965 6e63 7928 7365  al_efficiency(se
-000284e0: 6c66 2c20 6c69 6e6b 5f61 7474 7269 6275  lf, link_attribu
-000284f0: 7465 3d4e 6f6e 6529 3a0a 2020 2020 2020  te=None):.      
-00028500: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
-00028510: 7475 726e 2074 6865 2067 6c6f 6261 6c20  turn the global 
-00028520: 2877 6569 6768 7465 6429 2065 6666 6963  (weighted) effic
-00028530: 6965 6e63 792e 2028 7365 6520 5b43 6f73  iency. (see [Cos
-00028540: 7461 3230 3037 5d5f 290a 0a20 2020 2020  ta2007]_)..     
-00028550: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
-00028560: 0a20 2020 2020 2020 203e 3e3e 2072 284e  .        >>> r(N
-00028570: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
-00028580: 4e65 7477 6f72 6b28 292e 676c 6f62 616c  Network().global
-00028590: 5f65 6666 6963 6965 6e63 7928 2929 0a20  _efficiency()). 
-000285a0: 2020 2020 2020 2043 616c 6375 6c61 7469         Calculati
-000285b0: 6e67 2061 6c6c 2073 686f 7274 6573 7420  ng all shortest 
-000285c0: 7061 7468 206c 656e 6774 6873 2e2e 2e0a  path lengths....
-000285d0: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-000285e0: 696e 6720 676c 6f62 616c 2028 7765 6967  ing global (weig
-000285f0: 6874 6564 2920 6566 6669 6369 656e 6379  hted) efficiency
-00028600: 2e2e 2e0a 2020 2020 2020 2020 302e 3731  ....        0.71
-00028610: 3131 0a0a 2020 2020 2020 2020 3a61 7267  11..        :arg
-00028620: 2073 7472 206c 696e 6b5f 6174 7472 6962   str link_attrib
-00028630: 7574 653a 204f 7074 696f 6e61 6c20 6e61  ute: Optional na
-00028640: 6d65 206f 6620 7468 6520 6c69 6e6b 2061  me of the link a
-00028650: 7474 7269 6275 7465 2074 6f20 6265 2075  ttribute to be u
-00028660: 7365 640a 2020 2020 2020 2020 2020 2020  sed.            
-00028670: 6173 2074 6865 206c 696e 6b73 2720 6c65  as the links' le
-00028680: 6e67 7468 2e20 4966 204e 6f6e 652c 206c  ngth. If None, l
-00028690: 696e 6b73 2068 6176 6520 6c65 6e67 7468  inks have length
-000286a0: 2031 2e20 2844 6566 6175 6c74 3a20 4e6f   1. (Default: No
-000286b0: 6e65 290a 2020 2020 2020 2020 3a72 7479  ne).        :rty
-000286c0: 7065 3a20 666c 6f61 740a 2020 2020 2020  pe: float.      
-000286d0: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
-000286e0: 206c 696e 6b5f 6174 7472 6962 7574 6520   link_attribute 
-000286f0: 3d3d 2022 746f 706f 6c6f 6769 6361 6c22  == "topological"
-00028700: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-00028710: 696e 7428 2257 4152 4e49 4e47 3a20 6c69  int("WARNING: li
-00028720: 6e6b 5f61 7474 7269 6275 7465 3d27 746f  nk_attribute='to
-00028730: 706f 6c6f 6769 6361 6c27 2069 7320 6465  pological' is de
-00028740: 7072 6563 6174 6564 2e5c 6e22 0a20 2020  precated.\n".   
-00028750: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00028760: 2022 5573 6520 6c69 6e6b 5f61 7474 7269   "Use link_attri
-00028770: 6275 7465 3d4e 6f6e 6520 696e 7374 6561  bute=None instea
-00028780: 642e 2229 0a20 2020 2020 2020 2020 2020  d.").           
-00028790: 206c 696e 6b5f 6174 7472 6962 7574 6520   link_attribute 
-000287a0: 3d20 4e6f 6e65 0a0a 2020 2020 2020 2020  = None..        
-000287b0: 7061 7468 5f6c 656e 6774 6873 203d 2073  path_lengths = s
-000287c0: 656c 662e 7061 7468 5f6c 656e 6774 6873  elf.path_lengths
-000287d0: 286c 696e 6b5f 6174 7472 6962 7574 6529  (link_attribute)
-000287e0: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-000287f0: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
-00028800: 3c3d 2031 3a0a 2020 2020 2020 2020 2020  <= 1:.          
-00028810: 2020 7072 696e 7428 2243 616c 6375 6c61    print("Calcula
-00028820: 7469 6e67 2067 6c6f 6261 6c20 2877 6569  ting global (wei
-00028830: 6768 7465 6429 2065 6666 6963 6965 6e63  ghted) efficienc
-00028840: 792e 2e2e 2229 0a0a 2020 2020 2020 2020  y...")..        
-00028850: 2320 2053 6574 2070 6174 6820 6c65 6e67  #  Set path leng
-00028860: 7468 7320 6f6e 2064 6961 676f 6e61 6c20  ths on diagonal 
-00028870: 746f 2069 6e66 696e 6974 7920 746f 2061  to infinity to a
-00028880: 766f 6964 2073 756d 6d69 6e67 206f 7665  void summing ove
-00028890: 7220 7468 6f73 650a 2020 2020 2020 2020  r those.        
-000288a0: 2320 2065 6e74 7269 6573 2077 6865 6e20  #  entries when 
-000288b0: 6361 6c63 756c 6174 696e 6720 6566 6669  calculating effi
-000288c0: 6369 656e 6379 0a20 2020 2020 2020 206e  ciency.        n
-000288d0: 702e 6669 6c6c 5f64 6961 676f 6e61 6c28  p.fill_diagonal(
-000288e0: 7061 7468 5f6c 656e 6774 6873 2c20 6e70  path_lengths, np
-000288f0: 2e69 6e66 290a 0a20 2020 2020 2020 2023  .inf)..        #
-00028900: 2020 4361 6c63 756c 6174 6520 676c 6f62    Calculate glob
-00028910: 616c 2065 6666 6963 6965 6e63 790a 2020  al efficiency.  
-00028920: 2020 2020 2020 6566 6669 6369 656e 6379        efficiency
-00028930: 203d 2028 312f 666c 6f61 7428 7365 6c66   = (1/float(self
-00028940: 2e4e 202a 2028 7365 6c66 2e4e 2d31 2929  .N * (self.N-1))
-00028950: 202a 2028 312f 7061 7468 5f6c 656e 6774   * (1/path_lengt
-00028960: 6873 292e 7375 6d28 2929 0a0a 2020 2020  hs).sum())..    
-00028970: 2020 2020 2320 2052 6573 746f 7265 2070      #  Restore p
-00028980: 6174 6820 6c65 6e67 7468 7320 6f6e 2064  ath lengths on d
-00028990: 6961 676f 6e61 6c20 746f 207a 6572 6f0a  iagonal to zero.
-000289a0: 2020 2020 2020 2020 6e70 2e66 696c 6c5f          np.fill_
-000289b0: 6469 6167 6f6e 616c 2870 6174 685f 6c65  diagonal(path_le
-000289c0: 6e67 7468 732c 2030 290a 0a20 2020 2020  ngths, 0)..     
-000289d0: 2020 2072 6574 7572 6e20 6566 6669 6369     return effici
-000289e0: 656e 6379 0a0a 2020 2020 4063 6163 6865  ency..    @cache
-000289f0: 645f 636f 6e73 7428 276e 7369 272c 2027  d_const('nsi', '
-00028a00: 676c 6f62 616c 2065 6666 272c 2027 6e2e  global eff', 'n.
-00028a10: 732e 692e 2067 6c6f 6261 6c20 6566 6669  s.i. global effi
-00028a20: 6369 656e 6379 2729 0a20 2020 2064 6566  ciency').    def
-00028a30: 206e 7369 5f67 6c6f 6261 6c5f 6566 6669   nsi_global_effi
-00028a40: 6369 656e 6379 2873 656c 6629 3a0a 2020  ciency(self):.  
-00028a50: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00028a60: 2020 5265 7475 726e 2074 6865 206e 2e73    Return the n.s
-00028a70: 2e69 2e20 676c 6f62 616c 2065 6666 6963  .i. global effic
-00028a80: 6965 6e63 792e 0a0a 2020 2020 2020 2020  iency...        
-00028a90: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
-00028aa0: 2020 2020 2020 3e3e 3e20 7228 4e65 7477        >>> r(Netw
-00028ab0: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
-00028ac0: 776f 726b 2829 2e6e 7369 5f67 6c6f 6261  work().nsi_globa
-00028ad0: 6c5f 6566 6669 6369 656e 6379 2829 290a  l_efficiency()).
-00028ae0: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-00028af0: 696e 6720 6e2e 732e 692e 2067 6c6f 6261  ing n.s.i. globa
-00028b00: 6c20 6566 6669 6369 656e 6379 2e2e 2e0a  l efficiency....
-00028b10: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
-00028b20: 696e 6720 616c 6c20 7368 6f72 7465 7374  ing all shortest
-00028b30: 2070 6174 6820 6c65 6e67 7468 732e 2e2e   path lengths...
-00028b40: 0a20 2020 2020 2020 2030 2e37 3431 350a  .        0.7415.
-00028b50: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
-00028b60: 2066 6c6f 6174 0a20 2020 2020 2020 2022   float.        "
-00028b70: 2222 0a20 2020 2020 2020 2023 2054 4f44  "".        # TOD
-00028b80: 4f3a 2063 6865 636b 2072 6573 756c 7473  O: check results
-00028b90: 206f 6620 6578 616d 706c 6573 210a 2020   of examples!.  
-00028ba0: 2020 2020 2020 7720 3d20 7365 6c66 2e6e        w = self.n
-00028bb0: 6f64 655f 7765 6967 6874 730a 2020 2020  ode_weights.    
-00028bc0: 2020 2020 2320 2053 6574 2070 6174 6820      #  Set path 
-00028bd0: 6c65 6e67 7468 7320 6f6e 2064 6961 676f  lengths on diago
-00028be0: 6e61 6c20 746f 2031 0a20 2020 2020 2020  nal to 1.       
-00028bf0: 206e 7369 5f64 6973 7420 3d20 7365 6c66   nsi_dist = self
-00028c00: 2e70 6174 685f 6c65 6e67 7468 7328 2920  .path_lengths() 
-00028c10: 2b20 6e70 2e69 6465 6e74 6974 7928 7365  + np.identity(se
-00028c20: 6c66 2e4e 290a 2020 2020 2020 2020 7265  lf.N).        re
-00028c30: 7475 726e 2077 2e64 6f74 2828 312f 6e73  turn w.dot((1/ns
-00028c40: 695f 6469 7374 292e 646f 7428 7729 2920  i_dist).dot(w)) 
-00028c50: 2f20 7365 6c66 2e74 6f74 616c 5f6e 6f64  / self.total_nod
-00028c60: 655f 7765 6967 6874 2a2a 320a 0a20 2020  e_weight**2..   
-00028c70: 2064 6566 2064 6973 7461 6e63 655f 6261   def distance_ba
-00028c80: 7365 645f 6d65 6173 7572 6573 2873 656c  sed_measures(sel
-00028c90: 662c 2072 6570 6c61 6365 5f69 6e66 5f62  f, replace_inf_b
-00028ca0: 793d 4e6f 6e65 293a 0a20 2020 2020 2020  y=None):.       
-00028cb0: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
-00028cc0: 7572 6e20 6120 6469 6374 696f 6e61 7279  urn a dictionary
-00028cd0: 206f 6620 6c6f 6361 6c20 616e 6420 676c   of local and gl
-00028ce0: 6f62 616c 206d 6561 7375 7265 7320 7468  obal measures th
-00028cf0: 6174 2061 7265 2062 6173 6564 206f 6e0a  at are based on.
-00028d00: 2020 2020 2020 2020 7368 6f72 7465 7374          shortest
-00028d10: 2070 6174 6820 6c65 6e67 7468 732e 0a0a   path lengths...
-00028d20: 2020 2020 2020 2020 5468 6973 2069 7320          This is 
-00028d30: 7573 6566 756c 2066 6f72 206c 6172 6765  useful for large
-00028d40: 2067 7261 7068 7320 666f 7220 7768 6963   graphs for whic
-00028d50: 6820 7468 6520 6d61 7472 6978 206f 6620  h the matrix of 
-00028d60: 616c 6c20 7368 6f72 7465 7374 0a20 2020  all shortest.   
-00028d70: 2020 2020 2070 6174 6820 6c65 6e67 7468       path length
-00028d80: 7320 6361 6e6e 6f74 2062 6520 7374 6f72  s cannot be stor
-00028d90: 6564 2e0a 0a20 2020 2020 2020 2045 5850  ed...        EXP
-00028da0: 4552 494d 454e 5441 4c21 0a0a 2020 2020  ERIMENTAL!..    
-00028db0: 2020 2020 3a74 7970 6520 7265 706c 6163      :type replac
-00028dc0: 655f 696e 665f 6279 3a20 666c 6f61 742f  e_inf_by: float/
-00028dd0: 696e 662f 4e6f 6e65 0a20 2020 2020 2020  inf/None.       
-00028de0: 203a 6172 6720 7265 706c 6163 655f 696e   :arg replace_in
-00028df0: 665f 6279 3a20 4966 204e 6f6e 652c 2074  f_by: If None, t
-00028e00: 6865 206e 756d 6265 7220 6f66 206e 6f64  he number of nod
-00028e10: 6573 2069 7320 7573 6564 2e0a 2020 2020  es is used..    
-00028e20: 2020 2020 2020 2020 2844 6566 6175 6c74          (Default
-00028e30: 3a20 4e6f 6e65 290a 2020 2020 2020 2020  : None).        
-00028e40: 3a72 7479 7065 3a20 6469 6374 696f 6e61  :rtype: dictiona
-00028e50: 7279 2077 6974 6820 6b65 7973 2022 636c  ry with keys "cl
-00028e60: 6f73 656e 6573 7322 2c20 2268 6172 6d6f  oseness", "harmo
-00028e70: 6e69 635f 636c 6f73 656e 6573 7322 2c0a  nic_closeness",.
-00028e80: 2020 2020 2020 2020 2020 2020 2265 7870              "exp
-00028e90: 6f6e 656e 7469 616c 5f63 6c6f 7365 6e65  onential_closene
-00028ea0: 7373 222c 2022 6176 6572 6167 655f 7061  ss", "average_pa
-00028eb0: 7468 5f6c 656e 6774 6822 2c0a 2020 2020  th_length",.    
-00028ec0: 2020 2020 2020 2020 2267 6c6f 6261 6c5f          "global_
-00028ed0: 6566 6669 6369 656e 6379 222c 2022 6e73  efficiency", "ns
-00028ee0: 695f 636c 6f73 656e 6573 7322 2c20 226e  i_closeness", "n
-00028ef0: 7369 5f68 6172 6d6f 6e69 635f 636c 6f73  si_harmonic_clos
-00028f00: 656e 6573 7322 2c0a 2020 2020 2020 2020  eness",.        
-00028f10: 2020 2020 226e 7369 5f65 7870 6f6e 656e      "nsi_exponen
-00028f20: 7469 616c 5f63 6c6f 7365 6e65 7373 222c  tial_closeness",
-00028f30: 2022 6e73 695f 6176 6572 6167 655f 7061   "nsi_average_pa
-00028f40: 7468 5f6c 656e 6774 6822 2c0a 2020 2020  th_length",.    
-00028f50: 2020 2020 2020 2020 226e 7369 5f67 6c6f          "nsi_glo
-00028f60: 6261 6c5f 6566 6669 6369 656e 6379 220a  bal_efficiency".
-00028f70: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00028f80: 2020 2020 4e2c 2077 2c20 5720 3d20 7365      N, w, W = se
-00028f90: 6c66 2e4e 2c20 7365 6c66 2e6e 6f64 655f  lf.N, self.node_
-00028fa0: 7765 6967 6874 732c 2073 656c 662e 746f  weights, self.to
-00028fb0: 7461 6c5f 6e6f 6465 5f77 6569 6768 740a  tal_node_weight.
-00028fc0: 0a20 2020 2020 2020 2069 6620 7265 706c  .        if repl
-00028fd0: 6163 655f 696e 665f 6279 2069 7320 4e6f  ace_inf_by is No
-00028fe0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00028ff0: 7265 706c 6163 655f 696e 665f 6279 203d  replace_inf_by =
-00029000: 204e 0a0a 2020 2020 2020 2020 636c 6f73   N..        clos
-00029010: 656e 6573 7320 3d20 6e70 2e7a 6572 6f73  eness = np.zeros
-00029020: 284e 290a 2020 2020 2020 2020 6861 726d  (N).        harm
-00029030: 6f6e 6963 5f63 6c6f 7365 6e65 7373 203d  onic_closeness =
-00029040: 206e 702e 7a65 726f 7328 4e29 0a20 2020   np.zeros(N).   
-00029050: 2020 2020 2065 7870 6f6e 656e 7469 616c       exponential
-00029060: 5f63 6c6f 7365 6e65 7373 203d 206e 702e  _closeness = np.
-00029070: 7a65 726f 7328 4e29 0a20 2020 2020 2020  zeros(N).       
-00029080: 2061 7665 7261 6765 5f70 6174 685f 6c65   average_path_le
-00029090: 6e67 7468 203d 2030 0a20 2020 2020 2020  ngth = 0.       
-000290a0: 206e 7369 5f63 6c6f 7365 6e65 7373 203d   nsi_closeness =
-000290b0: 206e 702e 7a65 726f 7328 4e29 0a20 2020   np.zeros(N).   
-000290c0: 2020 2020 206e 7369 5f68 6172 6d6f 6e69       nsi_harmoni
-000290d0: 635f 636c 6f73 656e 6573 7320 3d20 6e70  c_closeness = np
-000290e0: 2e7a 6572 6f73 284e 290a 2020 2020 2020  .zeros(N).      
-000290f0: 2020 6e73 695f 6578 706f 6e65 6e74 6961    nsi_exponentia
-00029100: 6c5f 636c 6f73 656e 6573 7320 3d20 6e70  l_closeness = np
-00029110: 2e7a 6572 6f73 284e 290a 2020 2020 2020  .zeros(N).      
-00029120: 2020 6e73 695f 6176 6572 6167 655f 7061    nsi_average_pa
-00029130: 7468 5f6c 656e 6774 6820 3d20 300a 0a20  th_length = 0.. 
-00029140: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
-00029150: 7261 6e67 6528 4e29 3a0a 2020 2020 2020  range(N):.      
-00029160: 2020 2020 2020 6966 2073 656c 662e 7369        if self.si
-00029170: 6c65 6e63 655f 6c65 7665 6c20 3d3d 2030  lence_level == 0
-00029180: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00029190: 2020 7072 696e 7428 6929 0a20 2020 2020    print(i).     
-000291a0: 2020 2020 2020 2064 6920 3d20 6e70 2e61         di = np.a
-000291b0: 7272 6179 2873 656c 662e 6772 6170 682e  rray(self.graph.
-000291c0: 7368 6f72 7465 7374 5f70 6174 6873 2869  shortest_paths(i
-000291d0: 292c 2064 7479 7065 3d66 6c6f 6174 292e  ), dtype=float).
-000291e0: 666c 6174 7465 6e28 290a 2020 2020 2020  flatten().      
-000291f0: 2020 2020 2020 6469 5b6e 702e 7768 6572        di[np.wher
-00029200: 6528 6469 203d 3d20 6e70 2e69 6e66 295d  e(di == np.inf)]
-00029210: 203d 2072 6570 6c61 6365 5f69 6e66 5f62   = replace_inf_b
-00029220: 790a 0a20 2020 2020 2020 2020 2020 2063  y..            c
-00029230: 6c6f 7365 6e65 7373 5b69 5d20 3d20 312e  loseness[i] = 1.
-00029240: 3020 2f20 6469 2e73 756d 2829 0a20 2020  0 / di.sum().   
-00029250: 2020 2020 2020 2020 2061 7665 7261 6765           average
-00029260: 5f70 6174 685f 6c65 6e67 7468 202b 3d20  _path_length += 
-00029270: 6469 2e73 756d 2829 0a0a 2020 2020 2020  di.sum()..      
-00029280: 2020 2020 2020 6469 5b69 5d20 3d20 6e70        di[i] = np
-00029290: 2e69 6e66 0a20 2020 2020 2020 2020 2020  .inf.           
-000292a0: 2068 6172 6d6f 6e69 635f 636c 6f73 656e   harmonic_closen
-000292b0: 6573 735b 695d 203d 2028 312e 302f 6469  ess[i] = (1.0/di
-000292c0: 292e 7375 6d28 290a 2020 2020 2020 2020  ).sum().        
-000292d0: 2020 2020 6578 706f 6e65 6e74 6961 6c5f      exponential_
-000292e0: 636c 6f73 656e 6573 735b 695d 203d 2028  closeness[i] = (
-000292f0: 302e 352a 2a64 6929 2e73 756d 2829 0a0a  0.5**di).sum()..
-00029300: 2020 2020 2020 2020 2020 2020 6469 5b69              di[i
-00029310: 5d20 3d20 310a 2020 2020 2020 2020 2020  ] = 1.          
-00029320: 2020 6e73 695f 636c 6f73 656e 6573 735b    nsi_closeness[
-00029330: 695d 203d 2031 2e30 202f 2028 772a 6469  i] = 1.0 / (w*di
-00029340: 292e 7375 6d28 290a 2020 2020 2020 2020  ).sum().        
-00029350: 2020 2020 6e73 695f 6176 6572 6167 655f      nsi_average_
-00029360: 7061 7468 5f6c 656e 6774 6820 2b3d 2077  path_length += w
-00029370: 5b69 5d20 2a20 2877 2a64 6929 2e73 756d  [i] * (w*di).sum
-00029380: 2829 0a20 2020 2020 2020 2020 2020 206e  ().            n
-00029390: 7369 5f68 6172 6d6f 6e69 635f 636c 6f73  si_harmonic_clos
-000293a0: 656e 6573 735b 695d 203d 2028 772f 6469  eness[i] = (w/di
-000293b0: 292e 7375 6d28 290a 2020 2020 2020 2020  ).sum().        
-000293c0: 2020 2020 6e73 695f 6578 706f 6e65 6e74      nsi_exponent
-000293d0: 6961 6c5f 636c 6f73 656e 6573 735b 695d  ial_closeness[i]
-000293e0: 203d 2028 7720 2a20 302e 352a 2a64 6929   = (w * 0.5**di)
-000293f0: 2e73 756d 2829 0a0a 2020 2020 2020 2020  .sum()..        
-00029400: 7265 7475 726e 207b 0a20 2020 2020 2020  return {.       
-00029410: 2020 2020 2022 636c 6f73 656e 6573 7322       "closeness"
-00029420: 3a20 636c 6f73 656e 6573 7320 2a20 284e  : closeness * (N
-00029430: 2d31 292c 0a20 2020 2020 2020 2020 2020  -1),.           
-00029440: 2022 6861 726d 6f6e 6963 5f63 6c6f 7365   "harmonic_close
-00029450: 6e65 7373 223a 2068 6172 6d6f 6e69 635f  ness": harmonic_
-00029460: 636c 6f73 656e 6573 7320 2f20 284e 2d31  closeness / (N-1
-00029470: 292c 0a20 2020 2020 2020 2020 2020 2022  ),.            "
-00029480: 6578 706f 6e65 6e74 6961 6c5f 636c 6f73  exponential_clos
-00029490: 656e 6573 7322 3a20 6578 706f 6e65 6e74  eness": exponent
-000294a0: 6961 6c5f 636c 6f73 656e 6573 7320 2f20  ial_closeness / 
-000294b0: 284e 2d31 292c 0a20 2020 2020 2020 2020  (N-1),.         
-000294c0: 2020 2022 6176 6572 6167 655f 7061 7468     "average_path
-000294d0: 5f6c 656e 6774 6822 3a20 6176 6572 6167  _length": averag
-000294e0: 655f 7061 7468 5f6c 656e 6774 6820 2f20  e_path_length / 
-000294f0: 4e2a 284e 2d31 292c 0a20 2020 2020 2020  N*(N-1),.       
-00029500: 2020 2020 2022 676c 6f62 616c 5f65 6666       "global_eff
-00029510: 6963 6965 6e63 7922 3a20 6861 726d 6f6e  iciency": harmon
-00029520: 6963 5f63 6c6f 7365 6e65 7373 2e6d 6561  ic_closeness.mea
-00029530: 6e28 2920 2f20 284e 2d31 292c 0a20 2020  n() / (N-1),.   
-00029540: 2020 2020 2020 2020 2022 6e73 695f 636c           "nsi_cl
-00029550: 6f73 656e 6573 7322 3a20 6e73 695f 636c  oseness": nsi_cl
-00029560: 6f73 656e 6573 7320 2a20 572c 0a20 2020  oseness * W,.   
-00029570: 2020 2020 2020 2020 2022 6e73 695f 6861           "nsi_ha
-00029580: 726d 6f6e 6963 5f63 6c6f 7365 6e65 7373  rmonic_closeness
-00029590: 223a 206e 7369 5f68 6172 6d6f 6e69 635f  ": nsi_harmonic_
-000295a0: 636c 6f73 656e 6573 7320 2f20 572c 0a20  closeness / W,. 
-000295b0: 2020 2020 2020 2020 2020 2022 6e73 695f             "nsi_
-000295c0: 6578 706f 6e65 6e74 6961 6c5f 636c 6f73  exponential_clos
-000295d0: 656e 6573 7322 3a20 6e73 695f 6578 706f  eness": nsi_expo
-000295e0: 6e65 6e74 6961 6c5f 636c 6f73 656e 6573  nential_closenes
-000295f0: 7320 2f20 572c 0a20 2020 2020 2020 2020  s / W,.         
-00029600: 2020 2022 6e73 695f 6176 6572 6167 655f     "nsi_average_
-00029610: 7061 7468 5f6c 656e 6774 6822 3a20 6e73  path_length": ns
-00029620: 695f 6176 6572 6167 655f 7061 7468 5f6c  i_average_path_l
-00029630: 656e 6774 6820 2f20 572a 2a32 2c0a 2020  ength / W**2,.  
-00029640: 2020 2020 2020 2020 2020 226e 7369 5f67            "nsi_g
-00029650: 6c6f 6261 6c5f 6566 6669 6369 656e 6379  lobal_efficiency
-00029660: 223a 2077 2e64 6f74 286e 7369 5f68 6172  ": w.dot(nsi_har
-00029670: 6d6f 6e69 635f 636c 6f73 656e 6573 7329  monic_closeness)
-00029680: 202f 2057 2a2a 320a 2020 2020 2020 2020   / W**2.        
-00029690: 7d0a 0a20 2020 2023 0a20 2020 2023 2020  }..    #.    #  
-000296a0: 5675 6c6e 6572 6162 696c 6974 7920 6d65  Vulnerability me
-000296b0: 6173 7572 6573 0a20 2020 2023 0a0a 2020  asures.    #..  
-000296c0: 2020 6465 6620 6c6f 6361 6c5f 7675 6c6e    def local_vuln
-000296d0: 6572 6162 696c 6974 7928 7365 6c66 2c20  erability(self, 
-000296e0: 6c69 6e6b 5f61 7474 7269 6275 7465 3d4e  link_attribute=N
-000296f0: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
-00029700: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
-00029710: 6368 206e 6f64 652c 2072 6574 7572 6e20  ch node, return 
-00029720: 6974 7320 7675 6c6e 6572 6162 696c 6974  its vulnerabilit
-00029730: 792e 2028 7365 6520 5b43 6f73 7461 3230  y. (see [Costa20
-00029740: 3037 5d5f 290a 0a20 2020 2020 2020 202a  07]_)..        *
-00029750: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
-00029760: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
-00029770: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
-00029780: 6f72 6b28 292e 6c6f 6361 6c5f 7675 6c6e  ork().local_vuln
-00029790: 6572 6162 696c 6974 7928 2929 0a20 2020  erability()).   
-000297a0: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
-000297b0: 2061 6c6c 2073 686f 7274 6573 7420 7061   all shortest pa
-000297c0: 7468 206c 656e 6774 6873 2e2e 2e0a 2020  th lengths....  
-000297d0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
-000297e0: 6720 676c 6f62 616c 2028 7765 6967 6874  g global (weight
-000297f0: 6564 2920 6566 6669 6369 656e 6379 2e2e  ed) efficiency..
-00029800: 2e0a 2020 2020 2020 2020 4361 6c63 756c  ..        Calcul
-00029810: 6174 696e 6720 2877 6569 6768 7465 6429  ating (weighted)
-00029820: 206e 6f64 6520 7675 6c6e 6572 6162 696c   node vulnerabil
-00029830: 6974 6965 732e 2e2e 0a20 2020 2020 2020  ities....       
-00029840: 2061 7272 6179 285b 2030 2e32 3936 392c   array([ 0.2969,
-00029850: 2030 2e30 3632 352c 202d 302e 3033 3133   0.0625, -0.0313
-00029860: 2c20 2d30 2e30 3037 382c 2030 2e30 3937  , -0.0078, 0.097
-00029870: 372c 202d 302e 3132 3520 5d29 0a0a 2020  7, -0.125 ])..  
-00029880: 2020 2020 2020 3a61 7267 2073 7472 206c        :arg str l
-00029890: 696e 6b5f 6174 7472 6962 7574 653a 204f  ink_attribute: O
-000298a0: 7074 696f 6e61 6c20 6e61 6d65 206f 6620  ptional name of 
-000298b0: 7468 6520 6c69 6e6b 2061 7474 7269 6275  the link attribu
-000298c0: 7465 2074 6f20 6265 2075 7365 640a 2020  te to be used.  
-000298d0: 2020 2020 2020 2020 2020 6173 2074 6865            as the
-000298e0: 206c 696e 6b73 2720 6c65 6e67 7468 2e20   links' length. 
-000298f0: 4966 204e 6f6e 652c 206c 696e 6b73 2068  If None, links h
-00029900: 6176 6520 6c65 6e67 7468 2031 2e20 2844  ave length 1. (D
-00029910: 6566 6175 6c74 3a20 4e6f 6e65 290a 2020  efault: None).  
-00029920: 2020 2020 2020 3a72 7479 7065 3a20 3164        :rtype: 1d
-00029930: 206e 756d 7079 2061 7272 6179 205b 6e6f   numpy array [no
-00029940: 6465 5d20 6f66 2066 6c6f 6174 730a 2020  de] of floats.  
-00029950: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00029960: 2020 6966 206c 696e 6b5f 6174 7472 6962    if link_attrib
-00029970: 7574 6520 3d3d 2022 746f 706f 6c6f 6769  ute == "topologi
-00029980: 6361 6c22 3a0a 2020 2020 2020 2020 2020  cal":.          
-00029990: 2020 7072 696e 7428 2257 4152 4e49 4e47    print("WARNING
-000299a0: 3a20 6c69 6e6b 5f61 7474 7269 6275 7465  : link_attribute
-000299b0: 3d27 746f 706f 6c6f 6769 6361 6c27 2069  ='topological' i
-000299c0: 7320 6465 7072 6563 6174 6564 2e5c 6e22  s deprecated.\n"
-000299d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000299e0: 2020 202b 2022 5573 6520 6c69 6e6b 5f61     + "Use link_a
-000299f0: 7474 7269 6275 7465 3d4e 6f6e 6520 696e  ttribute=None in
-00029a00: 7374 6561 642e 2229 0a20 2020 2020 2020  stead.").       
-00029a10: 2020 2020 206c 696e 6b5f 6174 7472 6962       link_attrib
-00029a20: 7574 6520 3d20 4e6f 6e65 0a0a 2020 2020  ute = None..    
-00029a30: 2020 2020 7675 6c6e 6572 6162 696c 6974      vulnerabilit
-00029a40: 7920 3d20 6e70 2e7a 6572 6f73 2873 656c  y = np.zeros(sel
-00029a50: 662e 4e29 0a0a 2020 2020 2020 2020 2320  f.N)..        # 
-00029a60: 2043 616c 6375 6c61 7465 2067 6c6f 6261   Calculate globa
-00029a70: 6c20 6566 6669 6369 656e 6379 206f 6620  l efficiency of 
-00029a80: 636f 6d70 6c65 7465 206e 6574 776f 726b  complete network
-00029a90: 2045 0a20 2020 2020 2020 2067 6c6f 6261   E.        globa
-00029aa0: 6c5f 6566 6669 6369 656e 6379 203d 2073  l_efficiency = s
-00029ab0: 656c 662e 676c 6f62 616c 5f65 6666 6963  elf.global_effic
-00029ac0: 6965 6e63 7928 6c69 6e6b 5f61 7474 7269  iency(link_attri
-00029ad0: 6275 7465 290a 0a20 2020 2020 2020 2069  bute)..        i
-00029ae0: 6620 7365 6c66 2e73 696c 656e 6365 5f6c  f self.silence_l
-00029af0: 6576 656c 203c 3d20 313a 0a20 2020 2020  evel <= 1:.     
-00029b00: 2020 2020 2020 2070 7269 6e74 2822 4361         print("Ca
-00029b10: 6c63 756c 6174 696e 6720 2877 6569 6768  lculating (weigh
-00029b20: 7465 6429 206e 6f64 6520 7675 6c6e 6572  ted) node vulner
-00029b30: 6162 696c 6974 6965 732e 2e2e 2229 0a0a  abilities...")..
-00029b40: 2020 2020 2020 2020 2320 2049 6e69 7469          #  Initi
-00029b50: 616c 697a 6520 7072 6f67 7265 7373 2062  alize progress b
-00029b60: 6172 0a20 2020 2020 2020 2069 6620 7365  ar.        if se
-00029b70: 6c66 2e73 696c 656e 6365 5f6c 6576 656c  lf.silence_level
-00029b80: 203c 3d20 313a 0a20 2020 2020 2020 2020   <= 1:.         
-00029b90: 2020 2070 726f 6772 6573 7320 3d20 7072     progress = pr
-00029ba0: 6f67 7265 7373 6261 722e 5072 6f67 7265  ogressbar.Progre
-00029bb0: 7373 4261 7228 6d61 7876 616c 3d73 656c  ssBar(maxval=sel
-00029bc0: 662e 4e29 2e73 7461 7274 2829 0a0a 2020  f.N).start()..  
-00029bd0: 2020 2020 2020 666f 7220 6920 696e 2072        for i in r
-00029be0: 616e 6765 2873 656c 662e 4e29 3a0a 2020  ange(self.N):.  
-00029bf0: 2020 2020 2020 2020 2020 2320 5570 6461            # Upda
-00029c00: 7465 2070 726f 6772 6573 7320 6261 7220  te progress bar 
-00029c10: 6576 6572 7920 3130 2073 7465 7073 0a20  every 10 steps. 
-00029c20: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00029c30: 6c66 2e73 696c 656e 6365 5f6c 6576 656c  lf.silence_level
-00029c40: 203c 3d20 313a 0a20 2020 2020 2020 2020   <= 1:.         
-00029c50: 2020 2020 2020 2069 6620 2869 2025 2031         if (i % 1
-00029c60: 3029 203d 3d20 303a 0a20 2020 2020 2020  0) == 0:.       
-00029c70: 2020 2020 2020 2020 2020 2020 2070 726f               pro
-00029c80: 6772 6573 732e 7570 6461 7465 2869 290a  gress.update(i).
-00029c90: 0a20 2020 2020 2020 2020 2020 2023 2020  .            #  
-00029ca0: 5265 6d6f 7665 2076 6572 7465 7820 6920  Remove vertex i 
-00029cb0: 6672 6f6d 2067 7261 7068 0a20 2020 2020  from graph.     
-00029cc0: 2020 2020 2020 2067 7261 7068 203d 2073         graph = s
-00029cd0: 656c 662e 6772 6170 6820 2d20 690a 0a20  elf.graph - i.. 
-00029ce0: 2020 2020 2020 2020 2020 2023 2020 4765             #  Ge
-00029cf0: 6e65 7261 7465 204e 6574 776f 726b 206f  nerate Network o
-00029d00: 626a 6563 7420 6672 6f6d 2074 6869 7320  bject from this 
-00029d10: 7265 6475 6365 6420 6772 6170 680a 2020  reduced graph.  
-00029d20: 2020 2020 2020 2020 2020 6e65 7477 6f72            networ
-00029d30: 6b20 3d20 4e65 7477 6f72 6b2e 4672 6f6d  k = Network.From
-00029d40: 4947 7261 7068 2867 7261 7068 2c20 3229  IGraph(graph, 2)
-00029d50: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00029d60: 2043 616c 6375 6c61 7465 2067 6c6f 6261   Calculate globa
-00029d70: 6c20 746f 706f 6c6f 6769 6361 6c20 6566  l topological ef
-00029d80: 6669 6369 656e 6379 2045 5f69 2061 6674  ficiency E_i aft
-00029d90: 6572 2072 656d 6f76 616c 206f 660a 2020  er removal of.  
-00029da0: 2020 2020 2020 2020 2020 2320 2076 6572            #  ver
-00029db0: 7465 7820 690a 2020 2020 2020 2020 2020  tex i.          
-00029dc0: 2020 6e6f 6465 5f65 6666 6963 6965 6e63    node_efficienc
-00029dd0: 7920 3d20 6e65 7477 6f72 6b2e 676c 6f62  y = network.glob
-00029de0: 616c 5f65 6666 6963 6965 6e63 7928 6c69  al_efficiency(li
-00029df0: 6e6b 5f61 7474 7269 6275 7465 290a 0a20  nk_attribute).. 
-00029e00: 2020 2020 2020 2020 2020 2023 2020 4361             #  Ca
-00029e10: 6c63 756c 6174 6520 6c6f 6361 6c20 746f  lculate local to
-00029e20: 706f 6c6f 6769 6361 6c20 7675 6c6e 6572  pological vulner
-00029e30: 6162 696c 6974 7920 6f66 2076 6572 7465  ability of verte
-00029e40: 7820 690a 2020 2020 2020 2020 2020 2020  x i.            
-00029e50: 7675 6c6e 6572 6162 696c 6974 795b 695d  vulnerability[i]
-00029e60: 203d 2028 2867 6c6f 6261 6c5f 6566 6669   = ((global_effi
-00029e70: 6369 656e 6379 202d 206e 6f64 655f 6566  ciency - node_ef
-00029e80: 6669 6369 656e 6379 290a 2020 2020 2020  ficiency).      
-00029e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00029ea0: 2020 2020 2020 2020 2020 2f20 676c 6f62            / glob
-00029eb0: 616c 5f65 6666 6963 6965 6e63 7929 0a0a  al_efficiency)..
-00029ec0: 2020 2020 2020 2020 2020 2020 2320 2043              #  C
-00029ed0: 6c65 616e 2075 700a 2020 2020 2020 2020  lean up.        
-00029ee0: 2020 2020 6465 6c20 6772 6170 682c 206e      del graph, n
-00029ef0: 6574 776f 726b 0a0a 2020 2020 2020 2020  etwork..        
-00029f00: 2320 2054 6572 6d69 6e61 7465 2070 726f  #  Terminate pro
-00029f10: 6772 6573 7320 6261 720a 2020 2020 2020  gress bar.      
-00029f20: 2020 6966 2073 656c 662e 7369 6c65 6e63    if self.silenc
-00029f30: 655f 6c65 7665 6c20 3c3d 2031 3a0a 2020  e_level <= 1:.  
-00029f40: 2020 2020 2020 2020 2020 7072 6f67 7265            progre
-00029f50: 7373 2e66 696e 6973 6828 290a 0a20 2020  ss.finish()..   
-00029f60: 2020 2020 2072 6574 7572 6e20 7675 6c6e       return vuln
-00029f70: 6572 6162 696c 6974 790a 0a20 2020 2023  erability..    #
-00029f80: 0a20 2020 2023 2020 436f 6d6d 756e 6974  .    #  Communit
-00029f90: 7920 6d65 6173 7572 6573 0a20 2020 2023  y measures.    #
-00029fa0: 0a0a 2020 2020 4063 6163 6865 645f 636f  ..    @cached_co
-00029fb0: 6e73 7428 2762 6173 6527 2c20 2763 6f72  nst('base', 'cor
-00029fc0: 656e 6573 7327 2c20 2763 6f72 656e 6573  eness', 'corenes
-00029fd0: 7327 290a 2020 2020 6465 6620 636f 7265  s').    def core
-00029fe0: 6e65 7373 2873 656c 6629 3a0a 2020 2020  ness(self):.    
-00029ff0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0002a000: 466f 7220 6561 6368 206e 6f64 652c 2072  For each node, r
-0002a010: 6574 7572 6e20 6974 7320 636f 7265 6e65  eturn its corene
-0002a020: 7373 2e0a 0a20 2020 2020 2020 2054 6865  ss...        The
-0002a030: 206b 2d63 6f72 6520 6f66 2061 206e 6574   k-core of a net
-0002a040: 776f 726b 2069 7320 6120 6d61 7869 6d61  work is a maxima
-0002a050: 6c20 7375 626e 6574 776f 726b 2069 6e20  l subnetwork in 
-0002a060: 7768 6963 6820 6561 6368 206e 6f64 6520  which each node 
-0002a070: 6861 730a 2020 2020 2020 2020 6174 206c  has.        at l
-0002a080: 6561 7374 2064 6567 7265 6520 6b2e 2028  east degree k. (
-0002a090: 4465 6772 6565 2068 6572 6520 6d65 616e  Degree here mean
-0002a0a0: 7320 7468 6520 6465 6772 6565 2069 6e20  s the degree in 
-0002a0b0: 7468 6520 7375 626e 6574 776f 726b 206f  the subnetwork o
-0002a0c0: 660a 2020 2020 2020 2020 636f 7572 7365  f.        course
-0002a0d0: 292e 2054 6865 2063 6f72 656e 6573 7320  ). The coreness 
-0002a0e0: 6f66 2061 206e 6f64 6520 6973 206b 2069  of a node is k i
-0002a0f0: 6620 6974 2069 7320 6120 6d65 6d62 6572  f it is a member
-0002a100: 206f 6620 7468 6520 6b2d 636f 7265 0a20   of the k-core. 
-0002a110: 2020 2020 2020 2062 7574 206e 6f74 2061         but not a
-0002a120: 206d 656d 6265 7220 6f66 2074 6865 2028   member of the (
-0002a130: 6b2b 3129 2d63 6f72 652e 0a0a 2020 2020  k+1)-core...    
-0002a140: 2020 2020 2a2a 4578 616d 706c 653a 2a2a      **Example:**
-0002a150: 0a0a 2020 2020 2020 2020 3e3e 3e20 4e65  ..        >>> Ne
-0002a160: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-0002a170: 6574 776f 726b 2829 2e63 6f72 656e 6573  etwork().corenes
-0002a180: 7328 290a 2020 2020 2020 2020 4361 6c63  s().        Calc
-0002a190: 756c 6174 696e 6720 636f 7265 6e65 7373  ulating coreness
-0002a1a0: 2e2e 2e0a 2020 2020 2020 2020 6172 7261  ....        arra
-0002a1b0: 7928 5b32 2c20 322c 2032 2c20 322c 2032  y([2, 2, 2, 2, 2
-0002a1c0: 2c20 315d 290a 0a20 2020 2020 2020 203a  , 1])..        :
-0002a1d0: 7274 7970 653a 2031 6420 6e75 6d70 7920  rtype: 1d numpy 
-0002a1e0: 6172 7261 7920 5b6e 6f64 655d 206f 6620  array [node] of 
-0002a1f0: 666c 6f61 7473 0a20 2020 2020 2020 2022  floats.        "
-0002a200: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-0002a210: 6e20 6e70 2e61 7272 6179 2873 656c 662e  n np.array(self.
-0002a220: 6772 6170 682e 636f 7265 6e65 7373 2829  graph.coreness()
-0002a230: 290a 0a20 2020 2023 0a20 2020 2023 2020  )..    #.    #  
-0002a240: 5379 6e63 6872 6f6e 697a 6162 696c 6974  Synchronizabilit
-0002a250: 7920 6d65 6173 7572 6573 0a20 2020 2023  y measures.    #
-0002a260: 0a0a 2020 2020 4063 6163 6865 645f 636f  ..    @cached_co
-0002a270: 6e73 7428 2762 6173 6527 2c20 276d 7366  nst('base', 'msf
-0002a280: 2073 796e 6327 2c0a 2020 2020 2020 2020   sync',.        
-0002a290: 2020 2020 2020 2020 2020 276d 6173 7465            'maste
-0002a2a0: 7220 7374 6162 696c 6974 7920 6675 6e63  r stability func
-0002a2b0: 7469 6f6e 2073 796e 6368 726f 6e69 7a61  tion synchroniza
-0002a2c0: 6269 6c69 7479 2729 0a20 2020 2064 6566  bility').    def
-0002a2d0: 206d 7366 5f73 796e 6368 726f 6e69 7a61   msf_synchroniza
-0002a2e0: 6269 6c69 7479 2873 656c 6629 3a0a 2020  bility(self):.  
-0002a2f0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0002a300: 2020 5265 7475 726e 2074 6865 2073 796e    Return the syn
-0002a310: 6368 726f 6e69 7a61 6269 6c69 7479 2069  chronizability i
-0002a320: 6e20 7468 6520 6d61 7374 6572 2073 7461  n the master sta
-0002a330: 6269 6c69 7479 2066 756e 6374 696f 6e0a  bility function.
-0002a340: 2020 2020 2020 2020 6672 616d 6577 6f72          framewor
-0002a350: 6b2e 0a0a 2020 2020 2020 2020 5468 6973  k...        This
-0002a360: 2069 7320 6571 7561 6c20 746f 2074 6865   is equal to the
-0002a370: 206c 6172 6765 7374 2065 6967 656e 7661   largest eigenva
-0002a380: 6c75 6520 6f66 2074 6865 2067 7261 7068  lue of the graph
-0002a390: 204c 6170 6c61 6369 616e 2064 6976 6964   Laplacian divid
-0002a3a0: 6564 0a20 2020 2020 2020 2062 7920 7468  ed.        by th
-0002a3b0: 6520 736d 616c 6c65 7374 206e 6f6e 2d7a  e smallest non-z
-0002a3c0: 6572 6f20 6569 6765 6e76 616c 7565 2e20  ero eigenvalue. 
-0002a3d0: 4120 736d 616c 6c65 7220 7661 6c75 6520  A smaller value 
-0002a3e0: 696e 6469 6361 7465 7320 6869 6768 6572  indicates higher
-0002a3f0: 0a20 2020 2020 2020 2073 796e 6368 726f  .        synchro
-0002a400: 6e69 7a61 6269 6c69 7479 2061 6e64 2076  nizability and v
-0002a410: 6963 6520 7665 7273 612e 2054 6869 7320  ice versa. This 
-0002a420: 6675 6e63 7469 6f6e 206d 616b 6573 2073  function makes s
-0002a430: 656e 7365 2066 6f72 0a20 2020 2020 2020  ense for.       
-0002a440: 2075 6e64 6972 6563 7465 6420 636c 696d   undirected clim
-0002a450: 6174 6520 6e65 7477 6f72 6b73 2028 7769  ate networks (wi
-0002a460: 7468 2073 796d 6d65 7472 6963 206c 6170  th symmetric lap
-0002a470: 6c61 6369 616e 206d 6174 7269 7829 2e0a  lacian matrix)..
-0002a480: 2020 2020 2020 2020 466f 7220 6469 7265          For dire
-0002a490: 6374 6564 206e 6574 776f 726b 732c 2074  cted networks, t
-0002a4a0: 6865 2075 6e64 6972 6563 7465 6420 6c61  he undirected la
-0002a4b0: 706c 6163 6961 6e20 6d61 7472 6978 2069  placian matrix i
-0002a4c0: 7320 7573 6564 2e0a 0a20 2020 2020 2020  s used...       
-0002a4d0: 2028 7365 6520 5b50 6563 6f72 6131 3939   (see [Pecora199
-0002a4e0: 385d 5f29 0a0a 2020 2020 2020 2020 2e2e  8]_)..        ..
-0002a4f0: 206e 6f74 653a 3a0a 2020 2020 2020 2020   note::.        
-0002a500: 2020 204f 6e6c 7920 6465 6669 6e65 6420     Only defined 
-0002a510: 666f 7220 756e 6469 7265 6374 6564 206e  for undirected n
-0002a520: 6574 776f 726b 732e 0a0a 2020 2020 2020  etworks...      
-0002a530: 2020 2a2a 4578 616d 706c 653a 2a2a 0a0a    **Example:**..
-0002a540: 2020 2020 2020 2020 3e3e 3e20 7228 4e65          >>> r(Ne
-0002a550: 7477 6f72 6b2e 536d 616c 6c54 6573 744e  twork.SmallTestN
-0002a560: 6574 776f 726b 2829 2e6d 7366 5f73 796e  etwork().msf_syn
-0002a570: 6368 726f 6e69 7a61 6269 6c69 7479 2829  chronizability()
-0002a580: 290a 2020 2020 2020 2020 4361 6c63 756c  ).        Calcul
-0002a590: 6174 696e 6720 6d61 7374 6572 2073 7461  ating master sta
-0002a5a0: 6269 6c69 7479 2066 756e 6374 696f 6e20  bility function 
-0002a5b0: 7379 6e63 6872 6f6e 697a 6162 696c 6974  synchronizabilit
-0002a5c0: 792e 2e2e 0a20 2020 2020 2020 2036 2e37  y....        6.7
-0002a5d0: 3738 340a 0a20 2020 2020 2020 203a 7274  784..        :rt
-0002a5e0: 7970 653a 2066 6c6f 6174 0a20 2020 2020  ype: float.     
-0002a5f0: 2020 2022 2222 0a20 2020 2020 2020 2023     """.        #
-0002a600: 2054 4f44 4f3a 2075 7365 2073 7061 7273   TODO: use spars
-0002a610: 6520 7665 7273 696f 6e20 746f 2073 7065  e version to spe
-0002a620: 6564 2075 7021 0a20 2020 2020 2020 2023  ed up!.        #
-0002a630: 2020 4765 7420 756e 6469 7265 6374 6564    Get undirected
-0002a640: 2067 7261 7068 206c 6170 6c61 6369 616e   graph laplacian
-0002a650: 0a20 2020 2020 2020 206c 6170 6c61 6369  .        laplaci
-0002a660: 616e 203d 2073 656c 662e 6c61 706c 6163  an = self.laplac
-0002a670: 6961 6e28 290a 0a20 2020 2020 2020 2023  ian()..        #
-0002a680: 2020 4765 7420 6569 6765 6e76 616c 7565    Get eigenvalue
-0002a690: 7320 6f66 206c 6170 6c61 6369 616e 0a20  s of laplacian. 
-0002a6a0: 2020 2020 2020 2065 6967 656e 7661 6c75         eigenvalu
-0002a6b0: 6573 203d 206e 702e 7265 616c 286c 696e  es = np.real(lin
-0002a6c0: 616c 672e 6569 6776 616c 7328 6c61 706c  alg.eigvals(lapl
-0002a6d0: 6163 6961 6e29 290a 0a20 2020 2020 2020  acian))..       
-0002a6e0: 2023 2020 536f 7274 2065 6967 656e 7661   #  Sort eigenva
-0002a6f0: 6c75 6573 2069 6e20 6173 6365 6e64 696e  lues in ascendin
-0002a700: 6720 6f72 6465 720a 2020 2020 2020 2020  g order.        
-0002a710: 6569 6765 6e76 616c 7565 732e 736f 7274  eigenvalues.sort
-0002a720: 2829 0a0a 2020 2020 2020 2020 2320 2047  ()..        #  G
-0002a730: 6574 2073 6d61 6c6c 6573 7420 6e6f 6e2d  et smallest non-
-0002a740: 7a65 726f 2065 6967 656e 7661 6c75 6520  zero eigenvalue 
-0002a750: 2846 6965 646c 6572 2076 616c 7565 290a  (Fiedler value).
-0002a760: 2020 2020 2020 2020 6920 3d20 300a 2020          i = 0.  
-0002a770: 2020 2020 2020 6669 6564 6c65 725f 7661        fiedler_va
-0002a780: 6c75 6520 3d20 300a 0a20 2020 2020 2020  lue = 0..       
-0002a790: 2023 2020 5468 6520 6c69 6d69 7465 6420   #  The limited 
-0002a7a0: 6163 6375 7261 6379 206f 6620 6569 6765  accuracy of eige
-0002a7b0: 6e76 616c 7565 2063 616c 6375 6c61 7469  nvalue calculati
-0002a7c0: 6f6e 2066 6f72 6365 7320 7468 6520 7573  on forces the us
-0002a7d0: 6520 6f66 0a20 2020 2020 2020 2023 2020  e of.        #  
-0002a7e0: 736f 6d65 2074 6872 6573 686f 6c64 2c20  some threshold, 
-0002a7f0: 6265 6c6f 7720 7768 6963 6820 6569 6765  below which eige
-0002a800: 6e76 616c 7565 7320 6172 6520 636f 6e73  nvalues are cons
-0002a810: 6964 6572 6564 2074 6f20 6265 207a 6572  idered to be zer
-0002a820: 6f0a 2020 2020 2020 2020 6163 6375 7261  o.        accura
-0002a830: 6379 203d 2031 302a 2a28 2d31 3029 0a0a  cy = 10**(-10)..
-0002a840: 2020 2020 2020 2020 7768 696c 6520 2865          while (e
-0002a850: 6967 656e 7661 6c75 6573 5b69 5d20 3c3d  igenvalues[i] <=
-0002a860: 2061 6363 7572 6163 7929 2061 6e64 2028   accuracy) and (
-0002a870: 6920 3c20 7365 6c66 2e4e 202d 2031 293a  i < self.N - 1):
-0002a880: 0a20 2020 2020 2020 2020 2020 2066 6965  .            fie
-0002a890: 646c 6572 5f76 616c 7565 203d 2065 6967  dler_value = eig
-0002a8a0: 656e 7661 6c75 6573 5b69 2b31 5d0a 2020  envalues[i+1].  
-0002a8b0: 2020 2020 2020 2020 2020 6920 2b3d 2031            i += 1
-0002a8c0: 0a0a 2020 2020 2020 2020 2320 2043 616c  ..        #  Cal
-0002a8d0: 6375 6c61 7465 2073 796e 6368 726f 6e69  culate synchroni
-0002a8e0: 7a61 6269 6c69 7479 2052 0a20 2020 2020  zability R.     
-0002a8f0: 2020 2052 203d 2065 6967 656e 7661 6c75     R = eigenvalu
-0002a900: 6573 5b2d 315d 202f 2066 6965 646c 6572  es[-1] / fiedler
-0002a910: 5f76 616c 7565 0a0a 2020 2020 2020 2020  _value..        
-0002a920: 7265 7475 726e 2052 0a0a 2020 2020 230a  return R..    #.
-0002a930: 2020 2020 2320 2044 6973 7461 6e63 6520      #  Distance 
-0002a940: 6d65 6173 7572 6573 2062 6574 7765 656e  measures between
-0002a950: 2074 776f 2067 7261 7068 730a 2020 2020   two graphs.    
-0002a960: 230a 0a20 2020 2064 6566 2068 616d 6d69  #..    def hammi
-0002a970: 6e67 5f64 6973 7461 6e63 655f 6672 6f6d  ng_distance_from
-0002a980: 2873 656c 662c 206f 7468 6572 5f6e 6574  (self, other_net
-0002a990: 776f 726b 293a 0a20 2020 2020 2020 2022  work):.        "
-0002a9a0: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
-0002a9b0: 6e20 7468 6520 6e6f 726d 616c 697a 6564  n the normalized
-0002a9c0: 2068 616d 6d69 6e67 2064 6973 7461 6e63   hamming distanc
-0002a9d0: 6520 6265 7477 6565 6e20 7468 6973 2061  e between this a
-0002a9e0: 6e64 2061 6e6f 7468 6572 0a20 2020 2020  nd another.     
-0002a9f0: 2020 206e 6574 776f 726b 2e0a 0a20 2020     network...   
-0002aa00: 2020 2020 2054 6869 7320 6973 2074 6865       This is the
-0002aa10: 2070 6572 6365 6e74 6167 6520 6f66 206c   percentage of l
-0002aa20: 696e 6b73 2074 6861 7420 6861 7665 2074  inks that have t
-0002aa30: 6f20 6265 2063 6861 6e67 6564 2074 6f20  o be changed to 
-0002aa40: 7472 616e 7366 6f72 6d0a 2020 2020 2020  transform.      
-0002aa50: 2020 7468 6973 206e 6574 776f 726b 2069    this network i
-0002aa60: 6e74 6f20 7468 6520 6f74 6865 722e 2048  nto the other. H
-0002aa70: 616d 6d69 6e67 2064 6973 7461 6e63 6520  amming distance 
-0002aa80: 6973 206f 6e6c 7920 6465 6669 6e65 6420  is only defined 
-0002aa90: 666f 720a 2020 2020 2020 2020 6e65 7477  for.        netw
-0002aaa0: 6f72 6b73 2077 6974 6820 616e 2065 7175  orks with an equ
-0002aab0: 616c 206e 756d 6265 7220 6f66 206e 6f64  al number of nod
-0002aac0: 6573 2e0a 0a20 2020 2020 2020 203a 7274  es...        :rt
-0002aad0: 7970 653a 2066 6c6f 6174 2062 6574 7765  ype: float betwe
-0002aae0: 656e 2030 2061 6e64 2031 0a20 2020 2020  en 0 and 1.     
-0002aaf0: 2020 2022 2222 0a20 2020 2020 2020 2023     """.        #
-0002ab00: 2020 4765 7420 6f77 6e20 6164 6a61 6365    Get own adjace
-0002ab10: 6e63 7920 6d61 7472 6978 0a20 2020 2020  ncy matrix.     
-0002ab20: 2020 2041 203d 2073 656c 662e 6164 6a61     A = self.adja
-0002ab30: 6365 6e63 790a 2020 2020 2020 2020 2320  cency.        # 
-0002ab40: 2047 6574 2074 6865 206f 7468 6572 2067   Get the other g
-0002ab50: 7261 7068 2773 2061 646a 6163 656e 6379  raph's adjacency
-0002ab60: 206d 6174 7269 780a 2020 2020 2020 2020   matrix.        
-0002ab70: 4220 3d20 6f74 6865 725f 6e65 7477 6f72  B = other_networ
-0002ab80: 6b2e 6164 6a61 6365 6e63 790a 0a20 2020  k.adjacency..   
-0002ab90: 2020 2020 2023 2020 4368 6563 6b20 6966       #  Check if
-0002aba0: 2074 6865 2067 7261 7068 7320 6861 7665   the graphs have
-0002abb0: 2074 6865 2073 616d 6520 6e75 6d62 6572   the same number
-0002abc0: 206f 6620 7665 7274 6963 6573 0a20 2020   of vertices.   
-0002abd0: 2020 2020 2069 6620 7365 6c66 2e4e 203d       if self.N =
-0002abe0: 3d20 6f74 6865 725f 6e65 7477 6f72 6b2e  = other_network.
-0002abf0: 4e3a 0a20 2020 2020 2020 2020 2020 2023  N:.            #
-0002ac00: 2020 4361 6c63 756c 6174 6520 7468 6520    Calculate the 
-0002ac10: 6861 6d6d 696e 6720 6469 7374 616e 6365  hamming distance
-0002ac20: 0a20 2020 2020 2020 2020 2020 2068 616d  .            ham
-0002ac30: 6d69 6e67 203d 2028 4120 213d 2042 292e  ming = (A != B).
-0002ac40: 7375 6d28 290a 0a20 2020 2020 2020 2020  sum()..         
-0002ac50: 2020 2023 2020 5265 7475 726e 2074 6865     #  Return the
-0002ac60: 206e 6f72 6d61 6c69 7a65 6420 6861 6d6d   normalized hamm
-0002ac70: 696e 6720 6469 7374 616e 6365 0a20 2020  ing distance.   
-0002ac80: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0002ac90: 6861 6d6d 696e 6720 2f20 666c 6f61 7428  hamming / float(
-0002aca0: 7365 6c66 2e4e 202a 2028 7365 6c66 2e4e  self.N * (self.N
-0002acb0: 202d 2031 2929 0a20 2020 2020 2020 2065   - 1)).        e
-0002acc0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0002acd0: 2072 6169 7365 204e 6574 776f 726b 4572   raise NetworkEr
-0002ace0: 726f 7228 224f 6e6c 7920 6465 6669 6e65  ror("Only define
-0002acf0: 6420 666f 7220 6e65 7477 6f72 6b73 2077  d for networks w
-0002ad00: 6974 6820 7361 6d65 206e 756d 6265 7220  ith same number 
-0002ad10: 6f66 205c 0a20 2020 2020 2020 2020 2020  of \.           
-0002ad20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ad30: 2020 2020 6e6f 6465 732e 2229 0a0a 2020      nodes.")..  
-0002ad40: 2020 6465 6620 7370 7265 6164 696e 6728    def spreading(
-0002ad50: 7365 6c66 2c20 616c 7068 613d 4e6f 6e65  self, alpha=None
-0002ad60: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0002ad70: 2020 2020 2020 2046 6f72 2065 6163 6820         For each 
-0002ad80: 6e6f 6465 2c20 7265 7475 726e 2069 7473  node, return its
-0002ad90: 2022 7370 7265 6164 696e 6722 2076 616c   "spreading" val
-0002ada0: 7565 2e0a 0a20 2020 2020 2020 202e 2e20  ue...        .. 
-0002adb0: 6e6f 7465 3a3a 0a20 2020 2020 2020 2020  note::.         
-0002adc0: 2020 5468 6973 2069 7320 7374 696c 6c20    This is still 
-0002add0: 4558 5045 5249 4d45 4e54 414c 210a 0a20  EXPERIMENTAL!.. 
-0002ade0: 2020 2020 2020 203a 7274 7970 653a 2031         :rtype: 1
-0002adf0: 6420 6e75 6d70 7920 6172 7261 7920 5b6e  d numpy array [n
-0002ae00: 6f64 655d 206f 6620 666c 6f61 7473 0a20  ode] of floats. 
-0002ae10: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0002ae20: 2020 2069 6620 616c 7068 6120 6973 204e     if alpha is N
-0002ae30: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0002ae40: 2061 6c70 6861 203d 2031 2e30 202f 2073   alpha = 1.0 / s
-0002ae50: 656c 662e 6465 6772 6565 2829 2e6d 6561  elf.degree().mea
-0002ae60: 6e28 290a 2020 2020 2020 2020 7265 7475  n().        retu
-0002ae70: 726e 206d 6174 6675 6e63 732e 6578 706d  rn matfuncs.expm
-0002ae80: 280a 2020 2020 2020 2020 2020 2020 6e70  (.            np
-0002ae90: 2e6c 6f67 2832 2e30 2920 2a20 2861 6c70  .log(2.0) * (alp
-0002aea0: 6861 202a 2073 656c 662e 6164 6a61 6365  ha * self.adjace
-0002aeb0: 6e63 790a 2020 2020 2020 2020 2020 2020  ncy.            
-0002aec0: 2020 2020 2020 2020 2020 2020 2020 202d                 -
-0002aed0: 206e 702e 6964 656e 7469 7479 2873 656c   np.identity(sel
-0002aee0: 662e 4e29 2929 2e73 756d 2861 7869 733d  f.N))).sum(axis=
-0002aef0: 3029 2e66 6c61 7474 656e 2829 0a0a 2020  0).flatten()..  
-0002af00: 2020 6465 6620 6e73 695f 7370 7265 6164    def nsi_spread
-0002af10: 696e 6728 7365 6c66 2c20 616c 7068 613d  ing(self, alpha=
-0002af20: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
-0002af30: 2222 0a20 2020 2020 2020 2046 6f72 2065  "".        For e
-0002af40: 6163 6820 6e6f 6465 2c20 7265 7475 726e  ach node, return
-0002af50: 2069 7473 206e 2e73 2e69 2e20 2273 7072   its n.s.i. "spr
-0002af60: 6561 6469 6e67 2220 7661 6c75 652e 0a0a  eading" value...
-0002af70: 2020 2020 2020 2020 2e2e 206e 6f74 653a          .. note:
-0002af80: 3a0a 2020 2020 2020 2020 2020 2054 6869  :.           Thi
-0002af90: 7320 6973 2073 7469 6c6c 2045 5850 4552  s is still EXPER
-0002afa0: 494d 454e 5441 4c21 0a0a 2020 2020 2020  IMENTAL!..      
-0002afb0: 2020 3a72 7479 7065 3a20 3164 206e 756d    :rtype: 1d num
-0002afc0: 7079 2061 7272 6179 205b 6e6f 6465 5d20  py array [node] 
-0002afd0: 6f66 2066 6c6f 6174 730a 2020 2020 2020  of floats.      
-0002afe0: 2020 2222 220a 2020 2020 2020 2020 4e2c    """.        N,
-0002aff0: 2041 706c 7573 203d 2073 656c 662e 4e2c   Aplus = self.N,
-0002b000: 2073 656c 662e 7370 5f41 706c 7573 2829   self.sp_Aplus()
-0002b010: 2e41 0a20 2020 2020 2020 2077 2c20 6b20  .A.        w, k 
-0002b020: 3d20 7365 6c66 2e6e 6f64 655f 7765 6967  = self.node_weig
-0002b030: 6874 732c 2073 656c 662e 6e73 695f 6465  hts, self.nsi_de
-0002b040: 6772 6565 2829 0a20 2020 2020 2020 2069  gree().        i
-0002b050: 6620 616c 7068 6120 6973 204e 6f6e 653a  f alpha is None:
-0002b060: 0a20 2020 2020 2020 2020 2020 2061 6c70  .            alp
-0002b070: 6861 203d 2073 656c 662e 746f 7461 6c5f  ha = self.total_
-0002b080: 6e6f 6465 5f77 6569 6768 7420 2f20 6b2e  node_weight / k.
-0002b090: 646f 7428 7729 0a20 2020 2020 2020 2023  dot(w).        #
-0002b0a0: 2070 7269 6e74 2861 6c70 6861 290a 2020   print(alpha).  
-0002b0b0: 2020 2020 2020 7265 7475 726e 2028 0a20        return (. 
-0002b0c0: 2020 2020 2020 2020 2020 206d 6174 6675             matfu
-0002b0d0: 6e63 732e 6578 706d 280a 2020 2020 2020  ncs.expm(.      
-0002b0e0: 2020 2020 2020 2020 2020 6e70 2e6c 6f67            np.log
-0002b0f0: 2832 2e30 292a 2841 706c 7573 202a 2061  (2.0)*(Aplus * a
-0002b100: 6c70 6861 202a 2077 202d 2073 702e 6964  lpha * w - sp.id
-0002b110: 656e 7469 7479 284e 2929 292e 646f 7428  entity(N))).dot(
-0002b120: 4170 6c75 7329 0a20 2020 2020 2020 2020  Aplus).         
-0002b130: 2020 202a 2077 2e72 6573 6861 7065 2828     * w.reshape((
-0002b140: 4e2c 2031 2929 292e 7375 6d28 6178 6973  N, 1))).sum(axis
-0002b150: 3d30 290a 0a20 2020 2064 6566 2064 6f5f  =0)..    def do_
-0002b160: 6e73 695f 7063 615f 636c 7573 7465 7269  nsi_pca_clusteri
-0002b170: 6e67 2873 656c 662c 206d 6178 5f6e 5f63  ng(self, max_n_c
-0002b180: 6c75 7374 6572 733d 4e6f 6e65 293a 0a20  lusters=None):. 
-0002b190: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0002b1a0: 2020 2050 6572 666f 726d 2061 2063 6c75     Perform a clu
-0002b1b0: 7374 6572 696e 6720 6f66 2074 6865 206e  stering of the n
-0002b1c0: 6f64 6573 2075 7369 6e67 2070 7269 6e63  odes using princ
-0002b1d0: 6970 616c 2063 6f6d 706f 6e65 6e74 7320  ipal components 
-0002b1e0: 616e 616c 7973 6973 2e0a 0a20 2020 2020  analysis...     
-0002b1f0: 2020 2050 6572 666f 726d 2061 2050 4341     Perform a PCA
-0002b200: 2066 6f72 2074 6865 2063 6f6c 756d 6e73   for the columns
-0002b210: 206f 6620 7468 6520 6164 6a61 6365 6e63   of the adjacenc
-0002b220: 7920 6d61 7472 6978 2c20 6578 7472 6163  y matrix, extrac
-0002b230: 7420 7468 650a 2020 2020 2020 2020 6c61  t the.        la
-0002b240: 7267 6573 7420 6569 6765 6e76 616c 7565  rgest eigenvalue
-0002b250: 732c 2061 6e64 2061 7373 6967 6e20 6561  s, and assign ea
-0002b260: 6368 206e 6f64 6520 746f 2074 6861 7420  ch node to that 
-0002b270: 6569 6765 6e76 616c 7565 2077 686f 7365  eigenvalue whose
-0002b280: 0a20 2020 2020 2020 2065 6967 656e 7665  .        eigenve
-0002b290: 6374 6f72 2065 7870 6c61 696e 7320 7468  ctor explains th
-0002b2a0: 6520 6c61 7267 6573 7420 616d 6f75 6e74  e largest amount
-0002b2b0: 206f 6620 7468 6520 6e6f 6465 2773 2063   of the node's c
-0002b2c0: 6f6c 756d 6e27 730a 2020 2020 2020 2020  olumn's.        
-0002b2d0: 7661 7269 616e 6365 2c20 692e 652e 2074  variance, i.e. t
-0002b2e0: 6865 206f 6e65 2074 6861 7420 6d61 7869  he one that maxi
-0002b2f0: 6d69 7a65 7320 7468 6520 7661 6c75 6520  mizes the value 
-0002b300: 6f66 2065 6967 656e 7661 6c75 6520 2a0a  of eigenvalue *.
-0002b310: 2020 2020 2020 2020 636f 7272 6573 706f          correspo
-0002b320: 6e64 696e 6720 6661 6374 6f72 206c 6f61  nding factor loa
-0002b330: 6420 6f6e 2074 6861 7420 6e6f 6465 2773  d on that node's
-0002b340: 2063 6f6c 756d 6e2e 0a0a 2020 2020 2020   column...      
-0002b350: 2020 2e2e 206e 6f74 653a 3a0a 2020 2020    .. note::.    
-0002b360: 2020 2020 2020 2054 6869 7320 6973 2073         This is s
-0002b370: 7469 6c6c 2045 5850 4552 494d 454e 5441  till EXPERIMENTA
-0002b380: 4c21 0a0a 2020 2020 2020 2020 3a74 7970  L!..        :typ
-0002b390: 6520 6d61 785f 6e5f 636c 7573 7465 7273  e max_n_clusters
-0002b3a0: 3a20 696e 7420 3e3d 2031 0a20 2020 2020  : int >= 1.     
-0002b3b0: 2020 203a 6172 6720 206d 6178 5f6e 5f63     :arg  max_n_c
-0002b3c0: 6c75 7374 6572 733a 204e 756d 6265 7220  lusters: Number 
-0002b3d0: 6f66 2063 6c75 7374 6572 7320 746f 2066  of clusters to f
-0002b3e0: 696e 6420 6174 206d 6f73 742e 0a20 2020  ind at most..   
-0002b3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b400: 2020 2020 2020 2020 2020 2028 4465 6661             (Defa
-0002b410: 756c 743a 2063 6569 6c28 7371 7274 284e  ult: ceil(sqrt(N
-0002b420: 2929 290a 0a20 2020 2020 2020 203a 7274  )))..        :rt
-0002b430: 7970 653a 2074 7570 6c65 2028 6c69 7374  ype: tuple (list
-0002b440: 5b6e 6f64 655d 2c20 6c69 7374 5b6e 6f64  [node], list[nod
-0002b450: 655d 2c20 6c69 7374 5b63 6c75 7374 6572  e], list[cluster
-0002b460: 5d2c 2032 6420 6e75 6d70 7920 6172 7261  ], 2d numpy arra
-0002b470: 7929 0a20 2020 2020 2020 203a 7265 7475  y).        :retu
-0002b480: 726e 3a20 4120 6c69 7374 206f 6620 636c  rn: A list of cl
-0002b490: 7573 7465 7220 696e 6469 6365 7320 666f  uster indices fo
-0002b4a0: 7220 6561 6368 206e 6f64 652c 0a20 2020  r each node,.   
-0002b4b0: 2020 2020 2020 2020 2020 2020 2020 6120                a 
-0002b4c0: 6c69 7374 2077 6974 6820 7468 6520 6672  list with the fr
-0002b4d0: 6163 7469 6f6e 206f 6620 7468 6520 6e6f  action of the no
-0002b4e0: 6465 2773 2063 6f6c 756d 6e27 7320 7661  de's column's va
-0002b4f0: 7269 616e 6365 0a20 2020 2020 2020 2020  riance.         
-0002b500: 2020 2020 2020 2020 6578 706c 6169 6e65          explaine
-0002b510: 6420 6279 2063 686f 7365 6e20 6569 6765  d by chosen eige
-0002b520: 6e76 6563 746f 722c 2066 6f72 2065 6163  nvector, for eac
-0002b530: 6820 6e6f 6465 2c0a 2020 2020 2020 2020  h node,.        
-0002b540: 2020 2020 2020 2020 2061 206c 6973 7420           a list 
-0002b550: 6f66 2065 6967 656e 7661 6c75 6573 2063  of eigenvalues c
-0002b560: 6f72 7265 7370 6f6e 6469 6e67 2074 6f20  orresponding to 
-0002b570: 6561 6368 2063 6c75 7374 6572 2c0a 2020  each cluster,.  
-0002b580: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0002b590: 6e64 2061 6e20 6172 7261 7920 7768 6f73  nd an array whos
-0002b5a0: 6520 636f 6c75 6d6e 7320 6172 6520 7468  e columns are th
-0002b5b0: 6520 636f 7272 6573 706f 6e64 696e 6720  e corresponding 
-0002b5c0: 6569 6765 6e76 6563 746f 7273 0a20 2020  eigenvectors.   
-0002b5d0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0002b5e0: 2023 2054 4f44 4f3a 2077 6f72 6b73 206f   # TODO: works o
-0002b5f0: 6e6c 7920 666f 7220 756e 6469 7265 6374  nly for undirect
-0002b600: 6564 2067 7261 7068 7320 736f 2066 6172  ed graphs so far
-0002b610: 2e20 466f 7220 6469 7265 6374 6564 2c20  . For directed, 
-0002b620: 410a 2020 2020 2020 2020 2320 7374 6163  A.        # stac
-0002b630: 6b65 6420 7769 7468 2069 7473 2074 7261  ked with its tra
-0002b640: 6e73 706f 7365 2077 6f75 6c64 2068 6176  nspose would hav
-0002b650: 6520 746f 2062 6520 7573 6564 210a 0a20  e to be used!.. 
-0002b660: 2020 2020 2020 2023 2043 5353 2028 636f         # CSS (co
-0002b670: 7272 6563 7465 6420 7375 6d20 6f66 2073  rrected sum of s
-0002b680: 7175 6172 6573 293b 2070 726f 706f 7274  quares); proport
-0002b690: 696f 6e61 6c20 746f 2063 6f76 6172 6961  ional to covaria
-0002b6a0: 6e63 6520 6d61 7472 6978 0a20 2020 2020  nce matrix.     
-0002b6b0: 2020 2044 7752 203d 2073 656c 662e 7370     DwR = self.sp
-0002b6c0: 5f64 6961 675f 7371 7274 5f77 2829 0a20  _diag_sqrt_w(). 
-0002b6d0: 2020 2020 2020 2044 4144 203d 2044 7752         DAD = DwR
-0002b6e0: 202a 2073 656c 662e 7370 5f41 706c 7573   * self.sp_Aplus
-0002b6f0: 2829 202a 2044 7752 0a20 2020 2020 2020  () * DwR.       
-0002b700: 2063 6f72 7220 3d20 7365 6c66 2e6e 7369   corr = self.nsi
-0002b710: 5f64 6567 7265 6528 2920 2a20 6e70 2e73  _degree() * np.s
-0002b720: 7172 7428 7365 6c66 2e6e 6f64 655f 7765  qrt(self.node_we
-0002b730: 6967 6874 7329 0a20 2020 2020 2020 2043  ights).        C
-0002b740: 5353 203d 2044 4144 202a 2044 4144 202d  SS = DAD * DAD -
-0002b750: 206e 702e 6f75 7465 7228 636f 7272 2c20   np.outer(corr, 
-0002b760: 636f 7272 2920 2f20 7365 6c66 2e74 6f74  corr) / self.tot
-0002b770: 616c 5f6e 6f64 655f 7765 6967 6874 0a0a  al_node_weight..
-0002b780: 2020 2020 2020 2020 2320 6578 7472 6163          # extrac
-0002b790: 7420 6d61 785f 6e5f 636c 7573 7465 7273  t max_n_clusters
-0002b7a0: 206c 6172 6765 7374 2065 6967 656e 7661   largest eigenva
-0002b7b0: 6c75 6573 2061 6e64 2065 6967 656e 7665  lues and eigenve
-0002b7c0: 6374 6f72 7320 6672 6f6d 2043 5353 0a20  ctors from CSS. 
-0002b7d0: 2020 2020 2020 204e 203d 2073 656c 662e         N = self.
-0002b7e0: 4e0a 2020 2020 2020 2020 6966 206d 6178  N.        if max
-0002b7f0: 5f6e 5f63 6c75 7374 6572 7320 6973 204e  _n_clusters is N
-0002b800: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0002b810: 206d 6178 5f6e 5f63 6c75 7374 6572 7320   max_n_clusters 
-0002b820: 3d20 696e 7428 6e70 2e63 6569 6c28 6e70  = int(np.ceil(np
-0002b830: 2e73 7172 7428 4e29 2929 0a20 2020 2020  .sqrt(N))).     
-0002b840: 2020 2023 2074 6f74 616c 2076 6172 6961     # total varia
-0002b850: 6e63 6520 6973 2070 726f 706f 7274 696f  nce is proportio
-0002b860: 6e61 6c20 746f 2074 7261 6365 206f 6620  nal to trace of 
-0002b870: 4353 530a 2020 2020 2020 2020 7661 7220  CSS.        var 
-0002b880: 3d20 4353 532e 6469 6167 6f6e 616c 2829  = CSS.diagonal()
-0002b890: 2e41 5b30 5d0a 0a20 2020 2020 2020 2023  .A[0]..        #
-0002b8a0: 2074 6172 6765 7420 6569 6765 6e76 616c   target eigenval
-0002b8b0: 7565 2028 6b6e 6f77 6e20 7570 7065 7220  ue (known upper 
-0002b8c0: 626f 756e 6429 202d 3e20 6c61 7267 6573  bound) -> larges
-0002b8d0: 7420 6569 6765 6e76 616c 7565 730a 2020  t eigenvalues.  
-0002b8e0: 2020 2020 2020 7461 7520 3d20 7375 6d28        tau = sum(
-0002b8f0: 7661 7229 0a20 2020 2020 2020 2065 7661  var).        eva
-0002b900: 6c73 2c20 6576 6563 7320 3d20 6569 6773  ls, evecs = eigs
-0002b910: 6828 4353 532c 206b 3d6d 6178 5f6e 5f63  h(CSS, k=max_n_c
-0002b920: 6c75 7374 6572 732c 2073 6967 6d61 3d74  lusters, sigma=t
-0002b930: 6175 2c0a 2020 2020 2020 2020 2020 2020  au,.            
-0002b940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002b950: 206d 6178 6974 6572 3d31 3030 2a6d 6178   maxiter=100*max
-0002b960: 5f6e 5f63 6c75 7374 6572 732c 2074 6f6c  _n_clusters, tol
-0002b970: 3d31 652d 3829 0a0a 2020 2020 2020 2020  =1e-8)..        
-0002b980: 2320 6672 6163 7469 6f6e 206f 6620 6e6f  # fraction of no
-0002b990: 6465 2773 2076 6172 6961 6e63 6520 6578  de's variance ex
-0002b9a0: 706c 6169 6e65 6420 6279 2065 6163 6820  plained by each 
-0002b9b0: 6569 6765 6e76 6563 746f 720a 2020 2020  eigenvector.    
-0002b9c0: 2020 2020 6578 706c 6169 6e65 645f 7661      explained_va
-0002b9d0: 7220 3d20 6e70 2e70 6f77 6572 2865 7665  r = np.power(eve
-0002b9e0: 6373 2c20 322e 3029 202a 2065 7661 6c73  cs, 2.0) * evals
-0002b9f0: 2e72 6573 6861 7065 2828 312c 2065 7661  .reshape((1, eva
-0002ba00: 6c73 2e73 697a 6529 290a 0a20 2020 2020  ls.size))..     
-0002ba10: 2020 2023 2061 7373 6967 6e20 6561 6368     # assign each
-0002ba20: 206e 6f64 6520 746f 2063 6c75 7374 6572   node to cluster
-0002ba30: 2032 2a69 206f 7220 322a 692b 310a 2020   2*i or 2*i+1.  
-0002ba40: 2020 2020 2020 2320 666f 7220 7468 6174        # for that
-0002ba50: 2065 6967 656e 7665 6374 6f72 2069 2077   eigenvector i w
-0002ba60: 6869 6368 2065 7870 6c61 696e 7320 7468  hich explains th
-0002ba70: 6520 6c61 7267 6573 7420 7061 7274 206f  e largest part o
-0002ba80: 6620 7468 6520 6e6f 6465 2773 0a20 2020  f the node's.   
-0002ba90: 2020 2020 2023 2076 6172 6961 6e63 652e       # variance.
-0002baa0: 2020 6173 7369 676e 206e 6f64 6520 746f    assign node to
-0002bab0: 2063 6c75 7374 6572 2032 2a69 2069 6620   cluster 2*i if 
-0002bac0: 6569 6765 6e76 6563 746f 7220 706f 7369  eigenvector posi
-0002bad0: 7469 7665 2061 7420 7468 650a 2020 2020  tive at the.    
-0002bae0: 2020 2020 2320 6e6f 6465 2c20 6f74 6865      # node, othe
-0002baf0: 7277 6973 6520 746f 2063 6c75 7374 6572  rwise to cluster
-0002bb00: 2032 2a69 2b31 3a0a 2020 2020 2020 2020   2*i+1:.        
-0002bb10: 636c 7573 7465 725f 696e 6465 7820 3d20  cluster_index = 
-0002bb20: 3220 2a20 6e70 2e61 7267 6d61 7828 6578  2 * np.argmax(ex
-0002bb30: 706c 6169 6e65 645f 7661 722c 2061 7869  plained_var, axi
-0002bb40: 733d 3129 0a20 2020 2020 2020 2066 6f72  s=1).        for
-0002bb50: 2069 2069 6e20 7261 6e67 6528 302c 204e   i in range(0, N
-0002bb60: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-0002bb70: 6620 6576 6563 735b 692c 2063 6c75 7374  f evecs[i, clust
-0002bb80: 6572 5f69 6e64 6578 5b69 5d2f 325d 203c  er_index[i]/2] <
-0002bb90: 2030 2e30 3a0a 2020 2020 2020 2020 2020   0.0:.          
-0002bba0: 2020 2020 2020 636c 7573 7465 725f 696e        cluster_in
-0002bbb0: 6465 785b 695d 202b 3d20 310a 0a20 2020  dex[i] += 1..   
-0002bbc0: 2020 2020 2063 6c75 7374 6572 5f65 7870       cluster_exp
-0002bbd0: 6c61 696e 6564 5f76 6172 203d 206e 702e  lained_var = np.
-0002bbe0: 6d61 7828 6578 706c 6169 6e65 645f 7661  max(explained_va
-0002bbf0: 722c 2061 7869 733d 3129 0a20 2020 2020  r, axis=1).     
-0002bc00: 2020 2063 6c75 7374 6572 5f69 6e64 6578     cluster_index
-0002bc10: 5f73 6574 203d 2073 6574 2863 6c75 7374  _set = set(clust
-0002bc20: 6572 5f69 6e64 6578 290a 2020 2020 2020  er_index).      
-0002bc30: 2020 636c 7573 7465 725f 7369 7a65 7320    cluster_sizes 
-0002bc40: 3d20 6e70 2e7a 6572 6f73 286d 6178 2863  = np.zeros(max(c
-0002bc50: 6c75 7374 6572 5f69 6e64 6578 5f73 6574  luster_index_set
-0002bc60: 292b 3129 0a20 2020 2020 2020 2066 6f72  )+1).        for
-0002bc70: 2069 2069 6e20 7261 6e67 6528 302c 204e   i in range(0, N
-0002bc80: 293a 0a20 2020 2020 2020 2020 2020 2063  ):.            c
-0002bc90: 6c75 7374 6572 5f73 697a 6573 5b63 6c75  luster_sizes[clu
-0002bca0: 7374 6572 5f69 6e64 6578 5b69 5d5d 202b  ster_index[i]] +
-0002bcb0: 3d20 7365 6c66 2e6e 6f64 655f 7765 6967  = self.node_weig
-0002bcc0: 6874 735b 695d 0a20 2020 2020 2020 2063  hts[i].        c
-0002bcd0: 6c75 7374 6572 5f73 697a 6573 203d 2063  luster_sizes = c
-0002bce0: 6c75 7374 6572 5f73 697a 6573 5b6c 6973  luster_sizes[lis
-0002bcf0: 7428 636c 7573 7465 725f 696e 6465 785f  t(cluster_index_
-0002bd00: 7365 7429 5d0a 2020 2020 2020 2020 636c  set)].        cl
-0002bd10: 7573 7465 725f 6669 7420 3d20 636c 7573  uster_fit = clus
-0002bd20: 7465 725f 6578 706c 6169 6e65 645f 7661  ter_explained_va
-0002bd30: 7220 2f20 7661 720a 2020 2020 2020 2020  r / var.        
-0002bd40: 6966 2073 656c 662e 7369 6c65 6e63 655f  if self.silence_
-0002bd50: 6c65 7665 6c20 3c3d 2031 3a0a 2020 2020  level <= 1:.    
-0002bd60: 2020 2020 2020 2020 7072 696e 7428 226d          print("m
-0002bd70: 6178 5f6e 5f63 6c75 7374 6572 7320 7761  ax_n_clusters wa
-0002bd80: 7322 2c20 6d61 785f 6e5f 636c 7573 7465  s", max_n_cluste
-0002bd90: 7273 290a 2020 2020 2020 2020 2020 2020  rs).            
-0002bda0: 7072 696e 7428 6622 666f 756e 6420 7b6c  print(f"found {l
-0002bdb0: 656e 2865 7661 6c73 297d 2065 6967 656e  en(evals)} eigen
-0002bdc0: 7661 6c75 6573 2061 6e64 2022 0a20 2020  values and ".   
-0002bdd0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0002bde0: 227b 6c65 6e28 636c 7573 7465 725f 696e  "{len(cluster_in
-0002bdf0: 6465 785f 7365 7429 7d20 636c 7573 7465  dex_set)} cluste
-0002be00: 7273 2229 0a20 2020 2020 2020 2020 2020  rs").           
-0002be10: 2070 7269 6e74 2866 2263 6c75 7374 6572   print(f"cluster
-0002be20: 2073 697a 6573 2072 616e 6765 2066 726f   sizes range fro
-0002be30: 6d20 7b63 6c75 7374 6572 5f73 697a 6573  m {cluster_sizes
-0002be40: 2e6d 696e 2829 7d20 746f 2022 0a20 2020  .min()} to ".   
-0002be50: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0002be60: 227b 636c 7573 7465 725f 7369 7a65 732e  "{cluster_sizes.
-0002be70: 6d61 7828 297d 2077 6974 6820 6d65 6469  max()} with medi
-0002be80: 616e 2022 0a20 2020 2020 2020 2020 2020  an ".           
-0002be90: 2020 2020 2020 2066 227b 6e70 2e6d 6564         f"{np.med
-0002bea0: 6961 6e28 636c 7573 7465 725f 7369 7a65  ian(cluster_size
-0002beb0: 7329 7d3a 207b 636c 7573 7465 725f 7369  s)}: {cluster_si
-0002bec0: 7a65 737d 2229 0a20 2020 2020 2020 2020  zes}").         
-0002bed0: 2020 2070 7269 6e74 2866 226d 6178 2061     print(f"max a
-0002bee0: 6e64 206d 696e 2066 6f75 6e64 2065 6967  nd min found eig
-0002bef0: 656e 7661 6c75 6573 2061 7265 207b 6d61  envalues are {ma
-0002bf00: 7828 6576 616c 7329 7d20 616e 6420 220a  x(evals)} and ".
-0002bf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002bf20: 2020 6622 7b6d 696e 2865 7661 6c73 297d    f"{min(evals)}
-0002bf30: 2028 6176 6572 6167 6520 6f66 2061 6c6c   (average of all
-0002bf40: 2077 6173 207b 7461 752f 4e7d 2922 290a   was {tau/N})").
-0002bf50: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0002bf60: 7428 6622 7063 6120 616e 6420 636c 7573  t(f"pca and clus
-0002bf70: 7465 7273 2065 7870 6c61 696e 207b 7375  ters explain {su
-0002bf80: 6d28 6576 616c 7329 2f74 6175 7d20 616e  m(evals)/tau} an
-0002bf90: 6420 220a 2020 2020 2020 2020 2020 2020  d ".            
-0002bfa0: 2020 2020 2020 6622 7b73 756d 2863 6c75        f"{sum(clu
-0002bfb0: 7374 6572 5f65 7870 6c61 696e 6564 5f76  ster_explained_v
-0002bfc0: 6172 292f 7461 757d 206f 6620 746f 7461  ar)/tau} of tota
-0002bfd0: 6c20 7661 7269 616e 6365 2e22 290a 0a20  l variance.").. 
-0002bfe0: 2020 2020 2020 2072 6574 7572 6e20 2863         return (c
-0002bff0: 6c75 7374 6572 5f69 6e64 6578 2c20 2023  luster_index,  #
-0002c000: 2063 6c75 7374 6572 5f69 6e64 6578 2066   cluster_index f
-0002c010: 6f72 2065 6163 6820 6e6f 6465 0a20 2020  or each node.   
-0002c020: 2020 2020 2020 2020 2020 2020 2063 6c75               clu
-0002c030: 7374 6572 5f66 6974 2c20 2020 2023 2066  ster_fit,    # f
-0002c040: 7261 6374 696f 6e20 6f66 206e 6f64 6527  raction of node'
-0002c050: 7320 7661 7269 616e 6365 2065 7870 6c61  s variance expla
-0002c060: 696e 6564 2062 790a 2020 2020 2020 2020  ined by.        
-0002c070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c080: 2020 2020 2020 2020 2320 6368 6f73 656e          # chosen
-0002c090: 2065 6967 656e 7665 6374 6f72 2c20 666f   eigenvector, fo
-0002c0a0: 7220 6561 6368 206e 6f64 650a 2020 2020  r each node.    
-0002c0b0: 2020 2020 2020 2020 2020 2020 6576 616c              eval
-0002c0c0: 732c 2020 2020 2020 2020 2020 2320 6569  s,          # ei
-0002c0d0: 6765 6e76 616c 7565 730a 2020 2020 2020  genvalues.      
-0002c0e0: 2020 2020 2020 2020 2020 6576 6563 7329            evecs)
-0002c0f0: 2020 2020 2020 2020 2020 2320 6d61 7472            # matr
-0002c100: 6978 2077 6974 6820 636f 6c75 6d6e 733d  ix with columns=
-0002c110: 6569 6765 6e76 6563 746f 7273 0a0a 2020  eigenvectors..  
-0002c120: 2020 6465 6620 646f 5f6e 7369 5f63 6c75    def do_nsi_clu
-0002c130: 7374 6572 696e 6728 7365 6c66 2c20 6430  stering(self, d0
-0002c140: 3d4e 6f6e 652c 2074 7265 655f 646f 7466  =None, tree_dotf
-0002c150: 696c 653d 4e6f 6e65 2c0a 2020 2020 2020  ile=None,.      
-0002c160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002c170: 2020 2020 6469 7374 616e 6365 733d 4e6f      distances=No
-0002c180: 6e65 2c20 6361 6e64 6964 6174 6573 3d4e  ne, candidates=N
-0002c190: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
-0002c1a0: 220a 2020 2020 2020 2020 5065 7266 6f72  ".        Perfor
-0002c1b0: 6d20 6167 676c 6f6d 6572 6174 6976 6520  m agglomerative 
-0002c1c0: 636c 7573 7465 7269 6e67 2062 6173 6564  clustering based
-0002c1d0: 206f 6e20 7265 7072 6573 656e 7461 7469   on representati
-0002c1e0: 6f6e 2061 6363 7572 6163 792e 0a0a 2020  on accuracy...  
-0002c1f0: 2020 2020 2020 5468 6973 206d 696e 696d        This minim
-0002c200: 697a 6573 2069 6e20 6561 6368 2073 7465  izes in each ste
-0002c210: 7020 7468 6520 6d65 616e 2073 7175 6172  p the mean squar
-0002c220: 6564 2065 7272 6f72 206f 6620 7265 7072  ed error of repr
-0002c230: 6573 656e 7469 6e67 2074 6865 0a20 2020  esenting the.   
-0002c240: 2020 2020 2070 6169 7277 6973 6520 6e6f       pairwise no
-0002c250: 6465 2064 6973 7461 6e63 6573 2062 7920  de distances by 
-0002c260: 7468 6569 7220 636c 7573 7465 7220 6176  their cluster av
-0002c270: 6572 6167 6573 2e0a 0a20 2020 2020 2020  erages...       
-0002c280: 202e 2e20 6e6f 7465 3a3a 0a20 2020 2020   .. note::.     
-0002c290: 2020 2020 2020 5468 6973 2069 7320 7374        This is st
-0002c2a0: 696c 6c20 4558 5045 5249 4d45 4e54 414c  ill EXPERIMENTAL
-0002c2b0: 210a 0a20 2020 2020 2020 2053 6565 2074  !..        See t
-0002c2c0: 6865 2063 6f64 6520 666f 7220 6172 6775  he code for argu
-0002c2d0: 6d65 6e74 7320 616e 6420 7265 7475 726e  ments and return
-0002c2e0: 2076 616c 7565 2e0a 0a20 2020 2020 2020   value...       
-0002c2f0: 2043 6c75 7374 6572 7320 302e 2e2e 6e2d   Clusters 0...n-
-0002c300: 3120 6172 6520 7468 6520 7369 6e67 6c65  1 are the single
-0002c310: 746f 6e73 2028 636c 7573 7465 7220 6920  tons (cluster i 
-0002c320: 636f 6e74 6169 6e69 6e67 206a 7573 7420  containing just 
-0002c330: 6e6f 6465 2069 292e 0a20 2020 2020 2020  node i)..       
-0002c340: 2043 6c75 7374 6572 7320 6e2e 2e2e 326e   Clusters n...2n
-0002c350: 2d32 2061 7265 206e 756d 6265 7265 6420  -2 are numbered 
-0002c360: 696e 2074 6865 206f 7264 6572 2069 6e20  in the order in 
-0002c370: 7768 6963 6820 636c 7573 7465 7273 2061  which clusters a
-0002c380: 7265 0a20 2020 2020 2020 206a 6f69 6e65  re.        joine
-0002c390: 6420 2861 2063 6c75 7374 6572 2077 6974  d (a cluster wit
-0002c3a0: 6820 6964 2063 2069 7320 6120 756e 696f  h id c is a unio
-0002c3b0: 6e20 6f66 2074 776f 2065 6172 6c69 6572  n of two earlier
-0002c3c0: 2063 6c75 7374 6572 7320 7769 7468 0a20   clusters with. 
-0002c3d0: 2020 2020 2020 2069 6473 2063 312c 6332         ids c1,c2
-0002c3e0: 203c 2063 292e 2049 6e20 7061 7274 6963   < c). In partic
-0002c3f0: 756c 6172 2c20 636c 7573 7465 7220 326e  ular, cluster 2n
-0002c400: 2d32 2069 7320 7468 6520 6675 6c6c 2073  -2 is the full s
-0002c410: 6574 206f 6620 6e6f 6465 732e 0a0a 2020  et of nodes...  
-0002c420: 2020 2020 2020 3a72 7479 7065 3a20 2064        :rtype:  d
-0002c430: 6963 7469 6f6e 6172 790a 2020 2020 2020  ictionary.      
-0002c440: 2020 3a72 6574 7572 6e3a 2041 2064 6963    :return: A dic
-0002c450: 7469 6f6e 6172 7920 636f 6e74 6169 6e69  tionary containi
-0002c460: 6e67 2074 6865 2066 6f6c 6c6f 7769 6e67  ng the following
-0002c470: 206b 6579 733a 0a0a 2020 2020 2020 2020   keys:..        
-0002c480: 2020 202d 2022 6d69 6e5f 636c 7573 7465     - "min_cluste
-0002c490: 7273 223a 2069 6e74 203e 2030 2e20 536d  rs": int > 0. Sm
-0002c4a0: 616c 6c65 7374 206e 756d 6265 7220 6f66  allest number of
-0002c4b0: 2063 6c75 7374 6572 7320 6765 6e65 7261   clusters genera
-0002c4c0: 7465 642e 0a20 2020 2020 2020 2020 2020  ted..           
-0002c4d0: 2d20 2265 7272 6f72 223a 2061 7272 6179  - "error": array
-0002c4e0: 286e 2b31 292e 2045 6e74 7279 205b 6b5d  (n+1). Entry [k]
-0002c4f0: 2069 7320 7468 6520 7265 7072 6573 656e   is the represen
-0002c500: 7461 7469 6f6e 2065 7272 6f72 2066 6f72  tation error for
-0002c510: 2074 6865 0a20 2020 2020 2020 2020 2020   the.           
-0002c520: 2020 736f 6c75 7469 6f6e 2077 6974 6820    solution with 
-0002c530: 6b20 636c 7573 7465 7273 2e0a 2020 2020  k clusters..    
-0002c540: 2020 2020 2020 202d 2022 6e6f 6465 3263         - "node2c
-0002c550: 6c75 7374 6572 223a 2061 7272 6179 286e  luster": array(n
-0002c560: 2c6e 2b31 292e 2045 6e74 7279 205b 692c  ,n+1). Entry [i,
-0002c570: 6b5d 2069 7320 7468 6520 6964 206f 6620  k] is the id of 
-0002c580: 7468 6520 636c 7573 7465 720a 2020 2020  the cluster.    
-0002c590: 2020 2020 2020 2020 2074 6861 7420 636f           that co
-0002c5a0: 6e74 6169 6e73 206e 6f64 6520 6920 696e  ntains node i in
-0002c5b0: 2074 6865 2073 6f6c 7574 696f 6e20 7769   the solution wi
-0002c5c0: 7468 206b 2063 6c75 7374 6572 732e 0a20  th k clusters.. 
-0002c5d0: 2020 2020 2020 2020 2020 2d20 2263 6c75            - "clu
-0002c5e0: 7374 6572 5f77 6569 6768 7422 3a20 6172  ster_weight": ar
-0002c5f0: 7261 7928 326e 2d31 292e 2045 6e74 7279  ray(2n-1). Entry
-0002c600: 205b 635d 2069 7320 7468 6520 746f 7461   [c] is the tota
-0002c610: 6c20 7765 6967 6874 206f 660a 2020 2020  l weight of.    
-0002c620: 2020 2020 2020 2020 2063 6c75 7374 6572           cluster
-0002c630: 2063 2e0a 2020 2020 2020 2020 2020 202d   c..           -
-0002c640: 2022 636c 7573 7465 7232 7261 6e6b 223a   "cluster2rank":
-0002c650: 2061 7272 6179 2832 6e2d 312c 6e2b 3129   array(2n-1,n+1)
-0002c660: 2e20 456e 7472 7920 5b63 2c6b 5d20 6973  . Entry [c,k] is
-0002c670: 2074 6865 2064 6573 6365 6e64 696e 670a   the descending.
-0002c680: 2020 2020 2020 2020 2020 2020 206f 7264               ord
-0002c690: 6572 2072 616e 6b20 6f66 2063 6c75 7374  er rank of clust
-0002c6a0: 6572 2063 2069 6e20 7468 6520 6b2d 636c  er c in the k-cl
-0002c6b0: 7573 7465 7220 736f 6c75 7469 6f6e 2c20  uster solution, 
-0002c6c0: 692e 652e 2c20 7468 650a 2020 2020 2020  i.e., the.      
-0002c6d0: 2020 2020 2020 206e 756d 6265 7220 6f66         number of
-0002c6e0: 206c 6172 6765 7220 636c 7573 7465 7273   larger clusters
-0002c6f0: 2069 6e20 7468 6174 2073 6f6c 7574 696f   in that solutio
-0002c700: 6e2e 2055 7365 2074 6869 7320 746f 2063  n. Use this to c
-0002c710: 6f6e 7665 7274 0a20 2020 2020 2020 2020  onvert.         
-0002c720: 2020 2020 636c 7573 7465 7220 6964 7320      cluster ids 
-0002c730: 696e 2030 2e2e 2e32 6e2d 3120 746f 2063  in 0...2n-1 to c
-0002c740: 6c75 7374 6572 2069 6473 2069 6e20 302e  luster ids in 0.
-0002c750: 2e2e 6b2d 312e 0a20 2020 2020 2020 2020  ..k-1..         
-0002c760: 2020 2d20 226e 6f64 655f 696e 5f63 6c75    - "node_in_clu
-0002c770: 7374 6572 223a 2061 7272 6179 286e 2c32  ster": array(n,2
-0002c780: 6e2d 3129 2e20 456e 7472 7920 5b69 2c63  n-1). Entry [i,c
-0002c790: 5d20 696e 6469 6361 7465 7320 7768 6574  ] indicates whet
-0002c7a0: 6865 720a 2020 2020 2020 2020 2020 2020  her.            
-0002c7b0: 206e 6f64 6520 6920 6973 2069 6e20 7468   node i is in th
-0002c7c0: 6520 636c 7573 7465 7220 7769 7468 2069  e cluster with i
-0002c7d0: 6420 632e 0a20 2020 2020 2020 2020 2020  d c..           
-0002c7e0: 2d20 2263 6869 6c64 7265 6e22 3a20 6172  - "children": ar
-0002c7f0: 7261 7928 326e 2d31 2c32 292e 2045 6e74  ray(2n-1,2). Ent
-0002c800: 7269 6573 205b 632c 305d 2061 6e64 205b  ries [c,0] and [
-0002c810: 632c 315d 2061 7265 2074 6865 2069 6473  c,1] are the ids
-0002c820: 206f 660a 2020 2020 2020 2020 2020 2020   of.            
-0002c830: 2074 6865 2074 776f 2063 6c75 7374 6572   the two cluster
-0002c840: 7320 7468 6174 2077 6572 6520 6a6f 696e  s that were join
-0002c850: 6564 2074 6f20 6769 7665 2063 6c75 7374  ed to give clust
-0002c860: 6572 2063 2e0a 2020 2020 2020 2020 2020  er c..          
-0002c870: 202d 2022 7369 626c 696e 6722 3a20 6172   - "sibling": ar
-0002c880: 7261 7928 326e 2d32 292e 2045 6e74 7279  ray(2n-2). Entry
-0002c890: 205b 635d 2069 7320 7468 6520 6964 206f   [c] is the id o
-0002c8a0: 6620 7468 6520 636c 7573 7465 7220 7769  f the cluster wi
-0002c8b0: 7468 0a20 2020 2020 2020 2020 2020 2020  th.             
-0002c8c0: 7768 6963 6820 636c 7573 7465 7220 6320  which cluster c 
-0002c8d0: 6973 206a 6f69 6e65 642e 0a20 2020 2020  is joined..     
-0002c8e0: 2020 2020 2020 2d20 2270 6172 656e 7422        - "parent"
-0002c8f0: 3a20 6172 7261 7928 326e 2d32 292e 2045  : array(2n-2). E
-0002c900: 6e74 7279 205b 635d 2069 7320 7468 6520  ntry [c] is the 
-0002c910: 6964 206f 6620 7468 6520 636c 7573 7465  id of the cluste
-0002c920: 7220 7468 6174 0a20 2020 2020 2020 2020  r that.         
-0002c930: 2020 2020 7265 7375 6c74 7320 6672 6f6d      results from
-0002c940: 206a 6f69 6e69 6e67 2063 6c75 7374 6572   joining cluster
-0002c950: 2063 2077 6974 6820 6974 7320 7369 626c   c with its sibl
-0002c960: 696e 672e 0a20 2020 2020 2020 2022 2222  ing..        """
-0002c970: 0a20 2020 2020 2020 204e 203d 2073 656c  .        N = sel
-0002c980: 662e 4e0a 2020 2020 2020 2020 4e32 203d  f.N.        N2 =
-0002c990: 2032 2a4e 202d 2031 0a20 2020 2020 2020   2*N - 1.       
-0002c9a0: 2072 4e20 3d20 7261 6e67 6528 4e29 0a20   rN = range(N). 
-0002c9b0: 2020 2020 2020 2077 203d 2073 656c 662e         w = self.
-0002c9c0: 6e6f 6465 5f77 6569 6768 7473 2e63 6f70  node_weights.cop
-0002c9d0: 7928 290a 2020 2020 2020 2020 6b20 3d20  y().        k = 
-0002c9e0: 7365 6c66 2e6e 7369 5f64 6567 7265 6528  self.nsi_degree(
-0002c9f0: 2920 2023 2054 4f44 4f3a 206c 696e 6b20  )  # TODO: link 
-0002ca00: 7765 6967 6874 0a0a 2020 2020 2020 2020  weight..        
-0002ca10: 2320 696e 6974 2072 6573 756c 7420 7374  # init result st
-0002ca20: 7275 6374 7572 6573 3a0a 2020 2020 2020  ructures:.      
-0002ca30: 2020 6572 726f 7220 3d20 6e70 2e7a 6572    error = np.zer
-0002ca40: 6f73 284e 2b31 2920 2b20 6e70 2e69 6e66  os(N+1) + np.inf
-0002ca50: 0a20 2020 2020 2020 2065 7272 6f72 5b2d  .        error[-
-0002ca60: 315d 203d 2030 2e30 0a20 2020 2020 2020  1] = 0.0.       
-0002ca70: 206e 6f64 6532 636c 7573 7465 7220 3d20   node2cluster = 
-0002ca80: 6e70 2e7a 6572 6f73 2828 4e2c 204e 2b31  np.zeros((N, N+1
-0002ca90: 292c 2064 7479 7065 3d6e 702e 696e 7431  ), dtype=np.int1
-0002caa0: 3629 0a20 2020 2020 2020 206e 6f64 6532  6).        node2
-0002cab0: 636c 7573 7465 725b 3a2c 2030 5d20 3d20  cluster[:, 0] = 
-0002cac0: 2d31 0a20 2020 2020 2020 206e 6f64 6532  -1.        node2
-0002cad0: 636c 7573 7465 725b 3a2c 204e 5d20 3d20  cluster[:, N] = 
-0002cae0: 724e 0a20 2020 2020 2020 2063 6c75 7374  rN.        clust
-0002caf0: 6572 5f77 6569 6768 7420 3d20 6e70 2e7a  er_weight = np.z
-0002cb00: 6572 6f73 284e 3229 0a20 2020 2020 2020  eros(N2).       
-0002cb10: 2063 6c75 7374 6572 5f77 6569 6768 745b   cluster_weight[
-0002cb20: 303a 4e5d 203d 2077 0a20 2020 2020 2020  0:N] = w.       
-0002cb30: 2063 6c75 7374 6572 3272 616e 6b20 3d20   cluster2rank = 
-0002cb40: 6e70 2e7a 6572 6f73 2828 4e32 2c20 4e2b  np.zeros((N2, N+
-0002cb50: 3129 2c20 6474 7970 653d 6e70 2e69 6e74  1), dtype=np.int
-0002cb60: 3136 2920 2d20 310a 2020 2020 2020 2020  16) - 1.        
-0002cb70: 636c 7573 7465 7232 7261 6e6b 5b30 2c20  cluster2rank[0, 
-0002cb80: 315d 203d 2030 0a20 2020 2020 2020 206e  1] = 0.        n
-0002cb90: 6f64 655f 696e 5f63 6c75 7374 6572 203d  ode_in_cluster =
-0002cba0: 206e 702e 7a65 726f 7328 284e 2c20 4e32   np.zeros((N, N2
-0002cbb0: 292c 2064 7479 7065 3d6e 702e 696e 7438  ), dtype=np.int8
-0002cbc0: 2920 2023 206f 7220 626f 6f6c 3f0a 2020  )  # or bool?.  
-0002cbd0: 2020 2020 2020 6368 696c 6472 656e 203d        children =
-0002cbe0: 206e 702e 7a65 726f 7328 284e 322c 2032   np.zeros((N2, 2
-0002cbf0: 292c 2064 7479 7065 3d6e 702e 696e 7431  ), dtype=np.int1
-0002cc00: 3629 0a20 2020 2020 2020 2063 6869 6c64  6).        child
-0002cc10: 7265 6e5b 3a4e 5d20 3d20 2d31 0a20 2020  ren[:N] = -1.   
-0002cc20: 2020 2020 2073 6962 6c69 6e67 203d 206e       sibling = n
-0002cc30: 702e 7a65 726f 7328 4e32 2d31 2c20 6474  p.zeros(N2-1, dt
-0002cc40: 7970 653d 6e70 2e69 6e74 3136 2920 2d20  ype=np.int16) - 
-0002cc50: 310a 2020 2020 2020 2020 7061 7265 6e74  1.        parent
-0002cc60: 203d 206e 702e 7a65 726f 7328 4e32 2d31   = np.zeros(N2-1
-0002cc70: 2c20 6474 7970 653d 6e70 2e69 6e74 3136  , dtype=np.int16
-0002cc80: 2920 2d20 310a 2020 2020 2020 2020 636c  ) - 1.        cl
-0002cc90: 6964 203d 206e 702e 6172 616e 6765 284e  id = np.arange(N
-0002cca0: 290a 0a20 2020 2020 2020 2023 2061 2064  )..        # a d
-0002ccb0: 796e 616d 6963 2064 6f75 626c 7920 6c69  ynamic doubly li
-0002ccc0: 6e6b 6564 206c 6973 7420 6f66 2064 6973  nked list of dis
-0002ccd0: 7461 6e63 6520 6d61 7472 6978 2065 6e74  tance matrix ent
-0002cce0: 7269 6573 3a0a 2020 2020 2020 2020 2320  ries:.        # 
-0002ccf0: 2044 5f66 6972 7374 706f 735b 636c 5d20   D_firstpos[cl] 
-0002cd00: 3d20 706f 732e 206f 6620 6669 7273 7420  = pos. of first 
-0002cd10: 6e62 2e20 6f66 2063 6c2e 0a20 2020 2020  nb. of cl..     
-0002cd20: 2020 2023 2020 445f 6c61 7374 706f 735b     #  D_lastpos[
-0002cd30: 636c 5d20 3d20 706f 732e 206f 6620 6c61  cl] = pos. of la
-0002cd40: 7374 206e 622e 206f 6620 636c 2e0a 2020  st nb. of cl..  
-0002cd50: 2020 2020 2020 2320 2044 5f6e 6578 7470        #  D_nextp
-0002cd60: 6f73 5b70 6f73 5d20 3d20 706f 732e 206f  os[pos] = pos. o
-0002cd70: 6620 6e65 7874 206e 622e 206f 6620 7468  f next nb. of th
-0002cd80: 6520 7361 6d65 2063 6c2e 0a20 2020 2020  e same cl..     
-0002cd90: 2020 2023 2020 445f 7072 6576 706f 735b     #  D_prevpos[
-0002cda0: 706f 735d 203d 2070 6f73 2e20 6f66 2070  pos] = pos. of p
-0002cdb0: 7265 7669 6f75 7320 6e62 2e20 6f66 2074  revious nb. of t
-0002cdc0: 6865 2073 616d 6c65 2063 6c2e 0a20 2020  he samle cl..   
-0002cdd0: 2020 2020 2023 2020 445f 636c 7573 7465       #  D_cluste
-0002cde0: 725b 706f 735d 203d 2063 6c75 7374 6572  r[pos] = cluster
-0002cdf0: 2069 6e64 6578 206f 6620 7468 6520 6e65   index of the ne
-0002ce00: 6967 6862 6f75 7220 6174 2074 6869 7320  ighbour at this 
-0002ce10: 706f 732e 0a20 2020 2020 2020 2023 2020  pos..        #  
-0002ce20: 445f 696e 7670 6f73 5b70 6f73 5d20 3d20  D_invpos[pos] = 
-0002ce30: 706f 732e 206f 6620 636c 2e20 696e 206e  pos. of cl. in n
-0002ce40: 6273 2e20 6c69 7374 206f 6620 6e62 732e  bs. list of nbs.
-0002ce50: 0a20 2020 2020 2020 2023 2061 6c6c 206e  .        # all n
-0002ce60: 6565 6465 6420 6c69 6e6b 2061 7474 7269  eeded link attri
-0002ce70: 6275 7465 7320 6172 6520 7374 6f72 6564  butes are stored
-0002ce80: 2077 6974 6820 7468 6520 7361 6d65 2070   with the same p
-0002ce90: 6f73 2e0a 2020 2020 2020 2020 2320 7768  os..        # wh
-0002cea0: 656e 2063 6c73 2061 7265 206a 6f69 6e65  en cls are joine
-0002ceb0: 642c 2074 6865 2072 6573 702e 206c 6973  d, the resp. lis
-0002cec0: 7473 2061 7265 2063 6f6e 6361 7465 6e61  ts are concatena
-0002ced0: 7465 6420 616e 6420 6475 706c 6963 6174  ted and duplicat
-0002cee0: 6573 0a20 2020 2020 2020 2023 2061 7265  es.        # are
-0002cef0: 2075 6e6c 696e 6b65 6420 2862 7574 2074   unlinked (but t
-0002cf00: 6865 6972 2070 6f73 2e20 6e6f 7420 7265  heir pos. not re
-0002cf10: 7573 6564 292c 2073 6f20 7765 206e 6565  used), so we nee
-0002cf20: 6420 324d 206d 616e 790a 2020 2020 2020  d 2M many.      
-0002cf30: 2020 2320 706f 732e 2c20 312e 2e2e 324d    # pos., 1...2M
-0002cf40: 2c20 7768 6572 6520 706f 7320 3020 7265  , where pos 0 re
-0002cf50: 6d61 696e 7320 656d 7074 793a 0a20 2020  mains empty:.   
-0002cf60: 2020 2020 2069 6620 6469 7374 616e 6365       if distance
-0002cf70: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-0002cf80: 2020 2020 2020 2023 2063 6f6e 7461 696e         # contain
-0002cf90: 7320 6561 6368 206c 696e 6b20 7477 6963  s each link twic
-0002cfa0: 6521 0a20 2020 2020 2020 2020 2020 2064  e!.            d
-0002cfb0: 6973 7461 6e63 655f 6b65 7973 203d 206e  istance_keys = n
-0002cfc0: 7a5f 636f 6f72 6473 2873 656c 662e 7370  z_coords(self.sp
-0002cfd0: 5f41 290a 2020 2020 2020 2020 656c 7365  _A).        else
-0002cfe0: 3a0a 2020 2020 2020 2020 2020 2020 7472  :.            tr
-0002cff0: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
-0002d000: 2020 2064 6973 7461 6e63 655f 6b65 7973     distance_keys
-0002d010: 203d 2064 6973 7461 6e63 6573 2e6b 6579   = distances.key
-0002d020: 7328 290a 2020 2020 2020 2020 2020 2020  s().            
-0002d030: 6578 6365 7074 2041 7474 7269 6275 7465  except Attribute
-0002d040: 4572 726f 723a 0a20 2020 2020 2020 2020  Error:.         
-0002d050: 2020 2020 2020 2064 6973 7461 6e63 655f         distance_
-0002d060: 6b65 7973 203d 205b 2869 2c20 6a29 2066  keys = [(i, j) f
-0002d070: 6f72 2069 2069 6e20 7261 6e67 6528 4e29  or i in range(N)
-0002d080: 2066 6f72 206a 2069 6e20 7261 6e67 6528   for j in range(
-0002d090: 4e29 5d0a 2020 2020 2020 2020 4d20 3d20  N)].        M = 
-0002d0a0: 6c65 6e28 6469 7374 616e 6365 5f6b 6579  len(distance_key
-0002d0b0: 7329 0a20 2020 2020 2020 2072 4d20 3d20  s).        rM = 
-0002d0c0: 7261 6e67 6528 4d29 0a20 2020 2020 2020  range(M).       
-0002d0d0: 2072 706f 7320 3d20 7261 6e67 6528 312c   rpos = range(1,
-0002d0e0: 204d 2b31 290a 2020 2020 2020 2020 2320   M+1).        # 
-0002d0f0: 6966 204d 203c 2036 3535 3335 3a0a 2020  if M < 65535:.  
-0002d100: 2020 2020 2020 2320 2020 2020 706f 7374        #     post
-0002d110: 7970 6520 3d20 2269 6e74 3136 220a 2020  ype = "int16".  
-0002d120: 2020 2020 2020 706f 7374 7970 6520 3d20        postype = 
-0002d130: 2269 6e74 3332 220a 2020 2020 2020 2020  "int32".        
-0002d140: 445f 6669 7273 7470 6f73 203d 206e 702e  D_firstpos = np.
-0002d150: 7a65 726f 7328 4e2c 2070 6f73 7479 7065  zeros(N, postype
-0002d160: 2920 2023 2070 6f73 2e20 6f66 2066 6972  )  # pos. of fir
-0002d170: 7374 206e 622e 206f 6620 636c 2e0a 2020  st nb. of cl..  
-0002d180: 2020 2020 2020 445f 6c61 7374 706f 7320        D_lastpos 
-0002d190: 3d20 6e70 2e7a 6572 6f73 284e 2c20 706f  = np.zeros(N, po
-0002d1a0: 7374 7970 6529 2020 2320 706f 732e 206f  stype)  # pos. o
-0002d1b0: 6620 6c61 7374 206e 622e 206f 6620 636c  f last nb. of cl
-0002d1c0: 2e0a 2020 2020 2020 2020 2320 706f 732e  ..        # pos.
-0002d1d0: 206f 6620 6e65 7874 206e 622e 206f 6620   of next nb. of 
-0002d1e0: 7468 6520 7361 6d65 2063 6c2e 0a20 2020  the same cl..   
-0002d1f0: 2020 2020 2044 5f6e 6578 7470 6f73 203d       D_nextpos =
-0002d200: 206e 702e 7a65 726f 7328 322a 4d2b 312c   np.zeros(2*M+1,
-0002d210: 2070 6f73 7479 7065 290a 2020 2020 2020   postype).      
-0002d220: 2020 2320 706f 732e 206f 6620 7072 6576    # pos. of prev
-0002d230: 696f 7573 206e 622e 206f 6620 7468 6520  ious nb. of the 
-0002d240: 7361 6d6c 6520 636c 2e0a 2020 2020 2020  samle cl..      
-0002d250: 2020 445f 7072 6576 706f 7320 3d20 6e70    D_prevpos = np
-0002d260: 2e7a 6572 6f73 2832 2a4d 2b31 2c20 706f  .zeros(2*M+1, po
-0002d270: 7374 7970 6529 0a20 2020 2020 2020 2023  stype).        #
-0002d280: 2070 6f73 2e20 6f66 2063 6c2e 2069 6e20   pos. of cl. in 
-0002d290: 6e62 732e 206c 6973 7420 6f66 206e 6273  nbs. list of nbs
-0002d2a0: 2e0a 2020 2020 2020 2020 445f 696e 7670  ..        D_invp
-0002d2b0: 6f73 203d 206e 702e 7a65 726f 7328 322a  os = np.zeros(2*
-0002d2c0: 4d2b 312c 2070 6f73 7479 7065 290a 2020  M+1, postype).  
-0002d2d0: 2020 2020 2020 2320 636c 7573 7465 7220        # cluster 
-0002d2e0: 696e 6465 7820 6f66 2074 6865 206e 6569  index of the nei
-0002d2f0: 6768 626f 7572 2061 7420 7468 6973 2070  ghbour at this p
-0002d300: 6f73 2e0a 2020 2020 2020 2020 445f 636c  os..        D_cl
-0002d310: 7573 7465 7220 3d20 6e70 2e7a 6572 6f73  uster = np.zeros
-0002d320: 2832 2a4d 2b31 2c20 2269 6e74 3136 2229  (2*M+1, "int16")
-0002d330: 0a0a 2020 2020 2020 2020 2320 636f 6d70  ..        # comp
-0002d340: 7574 6520 6176 6572 6167 6520 6469 7374  ute average dist
-0002d350: 616e 6365 206f 6620 756e 636f 6e6e 6563  ance of unconnec
-0002d360: 7465 6420 7061 6972 732c 0a20 2020 2020  ted pairs,.     
-0002d370: 2020 2023 2077 6869 6368 2077 696c 6c20     # which will 
-0002d380: 6265 2075 7365 6420 6173 2061 6e20 6573  be used as an es
-0002d390: 7469 6d61 7465 2066 6f72 2074 6865 6d3a  timate for them:
-0002d3a0: 0a20 2020 2020 2020 206e 5f70 6169 7273  .        n_pairs
-0002d3b0: 203d 204e 202a 2028 4e2d 3129 202f 2032   = N * (N-1) / 2
-0002d3c0: 0a20 2020 2020 2020 2069 6620 6430 2069  .        if d0 i
-0002d3d0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0002d3e0: 2020 2020 7430 203d 2074 696d 652e 7469      t0 = time.ti
-0002d3f0: 6d65 2829 0a20 2020 2020 2020 2020 2020  me().           
-0002d400: 2069 6620 6e5f 7061 6972 7320 3e20 4d3a   if n_pairs > M:
-0002d410: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0002d420: 2064 3020 3d20 2873 656c 662e 6176 6572   d0 = (self.aver
-0002d430: 6167 655f 7061 7468 5f6c 656e 6774 6828  age_path_length(
-0002d440: 292a 312e 3020 2a20 6e5f 7061 6972 7320  )*1.0 * n_pairs 
-0002d450: 2d20 4d29 202f 5c0a 2020 2020 2020 2020  - M) /\.        
-0002d460: 2020 2020 2020 2020 2020 2020 2028 6e5f               (n_
-0002d470: 7061 6972 7320 2d20 4d29 2020 2320 544f  pairs - M)  # TO
-0002d480: 444f 3a20 6c69 6e6b 2077 6569 6768 740a  DO: link weight.
-0002d490: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0002d4a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0002d4b0: 2020 6430 203d 2031 2e30 202a 204e 0a20    d0 = 1.0 * N. 
-0002d4c0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-0002d4d0: 2866 2263 616c 6375 6c61 7465 6420 7b64  (f"calculated {d
-0002d4e0: 307d 2061 7320 6176 6572 6167 6520 6e6f  0} as average no
-0002d4f0: 6e2d 6c69 6e6b 6564 2064 6973 7461 6e63  n-linked distanc
-0002d500: 652c 2022 0a20 2020 2020 2020 2020 2020  e, ".           
-0002d510: 2020 2020 2020 2066 226e 6565 6465 6420         f"needed 
-0002d520: 7b74 696d 652e 7469 6d65 2829 2d74 307d  {time.time()-t0}
-0002d530: 2073 6563 2e22 290a 0a20 2020 2020 2020   sec.")..       
-0002d540: 2066 7479 7065 203d 2022 666c 6f61 7433   ftype = "float3
-0002d550: 3222 0a20 2020 2020 2020 2064 6963 745f  2".        dict_
-0002d560: 4420 3d20 7b7d 2020 2320 7765 6967 6874  D = {}  # weight
-0002d570: 6564 2073 756d 206f 6620 6469 7374 616e  ed sum of distan
-0002d580: 6365 7320 6265 7477 6565 6e20 636c 7573  ces between clus
-0002d590: 7465 7273 0a20 2020 2020 2020 2064 6963  ters.        dic
-0002d5a0: 745f 4465 6c74 6120 3d20 7b7d 2020 2320  t_Delta = {}  # 
-0002d5b0: 6572 726f 7220 696e 6372 6561 7365 2075  error increase u
-0002d5c0: 706f 6e20 6a6f 696e 2c20 6f6e 6c79 2069  pon join, only i
-0002d5d0: 3c6a 0a0a 2020 2020 2020 2020 2320 696e  <j..        # in
-0002d5e0: 6974 2074 6865 206c 6973 743a 0a20 2020  it the list:.   
-0002d5f0: 2020 2020 2074 3020 3d20 7469 6d65 2e74       t0 = time.t
-0002d600: 696d 6528 290a 2020 2020 2020 2020 706f  ime().        po
-0002d610: 736a 203d 2030 0a20 2020 2020 2020 2070  sj = 0.        p
-0002d620: 6f73 6920 3d20 4d0a 2020 2020 2020 2020  osi = M.        
-0002d630: 666f 7220 6930 2c20 6a30 2069 6e20 6469  for i0, j0 in di
-0002d640: 7374 616e 6365 5f6b 6579 733a 0a20 2020  stance_keys:.   
-0002d650: 2020 2020 2020 2020 2069 6620 6930 203d           if i0 =
-0002d660: 3d20 6a30 3a0a 2020 2020 2020 2020 2020  = j0:.          
-0002d670: 2020 2020 2020 6469 6374 5f44 5b28 4e2b        dict_D[(N+
-0002d680: 3129 2a69 305d 203d 2077 5b69 305d 202a  1)*i0] = w[i0] *
-0002d690: 2064 6973 7461 6e63 6573 5b69 302c 2069   distances[i0, i
-0002d6a0: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
-0002d6b0: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-0002d6c0: 2020 2020 2020 2020 6966 2069 3020 3c20          if i0 < 
-0002d6d0: 6a30 3a0a 2020 2020 2020 2020 2020 2020  j0:.            
-0002d6e0: 2020 2020 692c 206a 203d 2069 302c 206a      i, j = i0, j
-0002d6f0: 300a 2020 2020 2020 2020 2020 2020 656c  0.            el
-0002d700: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0002d710: 2020 2020 692c 206a 203d 206a 302c 2069      i, j = j0, i
-0002d720: 300a 2020 2020 2020 2020 2020 2020 696a  0.            ij
-0002d730: 203d 2069 2a4e 2b6a 0a20 2020 2020 2020   = i*N+j.       
-0002d740: 2020 2020 2069 6620 696a 2069 6e20 6469       if ij in di
-0002d750: 6374 5f44 3a0a 2020 2020 2020 2020 2020  ct_D:.          
-0002d760: 2020 2020 2020 636f 6e74 696e 7565 0a20        continue. 
-0002d770: 2020 2020 2020 2020 2020 2070 6f73 6a20             posj 
-0002d780: 3d20 706f 736a 202b 2031 0a20 2020 2020  = posj + 1.     
-0002d790: 2020 2020 2020 2069 6620 445f 6669 7273         if D_firs
-0002d7a0: 7470 6f73 5b69 5d20 3d3d 2030 3a0a 2020  tpos[i] == 0:.  
-0002d7b0: 2020 2020 2020 2020 2020 2020 2020 445f                D_
-0002d7c0: 6669 7273 7470 6f73 5b69 5d20 3d20 445f  firstpos[i] = D_
-0002d7d0: 6c61 7374 706f 735b 695d 203d 2070 6f73  lastpos[i] = pos
-0002d7e0: 6a0a 2020 2020 2020 2020 2020 2020 656c  j.            el
-0002d7f0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0002d800: 2020 2020 445f 7072 6576 706f 735b 706f      D_prevpos[po
-0002d810: 736a 5d20 3d20 6c70 6f73 203d 2044 5f6c  sj] = lpos = D_l
-0002d820: 6173 7470 6f73 5b69 5d0a 2020 2020 2020  astpos[i].      
-0002d830: 2020 2020 2020 2020 2020 445f 6e65 7874            D_next
-0002d840: 706f 735b 6c70 6f73 5d20 3d20 445f 6c61  pos[lpos] = D_la
-0002d850: 7374 706f 735b 695d 203d 2070 6f73 6a0a  stpos[i] = posj.
-0002d860: 2020 2020 2020 2020 2020 2020 445f 636c              D_cl
-0002d870: 7573 7465 725b 706f 736a 5d20 3d20 6a0a  uster[posj] = j.
-0002d880: 2020 2020 2020 2020 2020 2020 6966 2064              if d
-0002d890: 6973 7461 6e63 6573 2069 7320 4e6f 6e65  istances is None
-0002d8a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0002d8b0: 2020 2320 692e 652e 2c20 7573 6520 6469    # i.e., use di
-0002d8c0: 7374 2031 2069 6620 6c69 6e6b 6564 2c20  st 1 if linked, 
-0002d8d0: 6430 206f 7468 6572 7769 7365 0a20 2020  d0 otherwise.   
-0002d8e0: 2020 2020 2020 2020 2020 2020 2044 696a               Dij
-0002d8f0: 203d 2064 6963 745f 445b 696a 5d20 3d20   = dict_D[ij] = 
-0002d900: 6469 6374 5f44 5b6a 2a4e 2b69 5d20 3d20  dict_D[j*N+i] = 
-0002d910: 775b 695d 202a 2077 5b6a 5d0a 2020 2020  w[i] * w[j].    
-0002d920: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0002d930: 2020 2020 2020 2020 2020 2020 2020 4469                Di
-0002d940: 6a20 3d20 6469 6374 5f44 5b69 6a5d 203d  j = dict_D[ij] =
-0002d950: 2064 6963 745f 445b 6a2a 4e2b 695d 203d   dict_D[j*N+i] =
-0002d960: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-0002d970: 2020 2020 2020 2077 5b69 5d20 2a20 775b         w[i] * w[
-0002d980: 6a5d 202a 2064 6973 7461 6e63 6573 5b69  j] * distances[i
-0002d990: 302c 206a 305d 0a20 2020 2020 2020 2020  0, j0].         
-0002d9a0: 2020 2044 5f69 6e76 706f 735b 706f 736a     D_invpos[posj
-0002d9b0: 5d20 3d20 706f 7369 203d 2070 6f73 6920  ] = posi = posi 
-0002d9c0: 2b20 310a 2020 2020 2020 2020 2020 2020  + 1.            
-0002d9d0: 6966 2044 5f66 6972 7374 706f 735b 6a5d  if D_firstpos[j]
-0002d9e0: 203d 3d20 303a 0a20 2020 2020 2020 2020   == 0:.         
-0002d9f0: 2020 2020 2020 2044 5f66 6972 7374 706f         D_firstpo
-0002da00: 735b 6a5d 203d 2044 5f6c 6173 7470 6f73  s[j] = D_lastpos
-0002da10: 5b6a 5d20 3d20 706f 7369 0a20 2020 2020  [j] = posi.     
-0002da20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0002da30: 2020 2020 2020 2020 2020 2020 2044 5f70               D_p
-0002da40: 7265 7670 6f73 5b70 6f73 695d 203d 206c  revpos[posi] = l
-0002da50: 706f 7320 3d20 445f 6c61 7374 706f 735b  pos = D_lastpos[
-0002da60: 6a5d 0a20 2020 2020 2020 2020 2020 2020  j].             
-0002da70: 2020 2044 5f6e 6578 7470 6f73 5b6c 706f     D_nextpos[lpo
-0002da80: 735d 203d 2044 5f6c 6173 7470 6f73 5b6a  s] = D_lastpos[j
-0002da90: 5d20 3d20 706f 7369 0a20 2020 2020 2020  ] = posi.       
-0002daa0: 2020 2020 2044 5f63 6c75 7374 6572 5b70       D_cluster[p
-0002dab0: 6f73 695d 203d 2069 0a20 2020 2020 2020  osi] = i.       
-0002dac0: 2020 2020 2044 5f69 6e76 706f 735b 706f       D_invpos[po
-0002dad0: 7369 5d20 3d20 706f 736a 0a20 2020 2020  si] = posj.     
-0002dae0: 2020 2064 656c 2064 6973 7461 6e63 655f     del distance_
-0002daf0: 6b65 7973 0a20 2020 2020 2020 2070 7269  keys.        pri
-0002db00: 6e74 2822 696e 6974 6961 6c69 7a61 7469  nt("initializati
-0002db10: 6f6e 206f 6620 6469 7374 616e 6365 7320  on of distances 
-0002db20: 6e65 6564 6564 222c 2074 696d 652e 7469  needed", time.ti
-0002db30: 6d65 2829 2d74 302c 2022 7365 632e 2229  me()-t0, "sec.")
-0002db40: 0a0a 2020 2020 2020 2020 2320 696e 6974  ..        # init
-0002db50: 2063 616e 6469 6461 7465 733a 0a20 2020   candidates:.   
-0002db60: 2020 2020 2074 3020 3d20 7469 6d65 2e74       t0 = time.t
-0002db70: 696d 6528 290a 2020 2020 2020 2020 6966  ime().        if
-0002db80: 2063 616e 6469 6461 7465 7320 6973 204e   candidates is N
-0002db90: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0002dba0: 2063 616e 6469 6461 7465 7320 3d20 6e7a   candidates = nz
-0002dbb0: 5f63 6f6f 7264 7328 7365 6c66 2e73 705f  _coords(self.sp_
-0002dbc0: 4129 0a20 2020 2020 2020 2066 6f72 2069  A).        for i
-0002dbd0: 302c 206a 3020 696e 2063 616e 6469 6461  0, j0 in candida
-0002dbe0: 7465 733a 0a20 2020 2020 2020 2020 2020  tes:.           
-0002dbf0: 2069 6620 6930 203c 206a 303a 0a20 2020   if i0 < j0:.   
-0002dc00: 2020 2020 2020 2020 2020 2020 2069 2c20               i, 
-0002dc10: 6a20 3d20 6930 2c20 6a30 0a20 2020 2020  j = i0, j0.     
-0002dc20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0002dc30: 2020 2020 2020 2020 2020 2020 2069 2c20               i, 
-0002dc40: 6a20 3d20 6a30 2c20 6930 0a20 2020 2020  j = j0, i0.     
-0002dc50: 2020 2020 2020 2069 6a20 3d20 692a 4e2b         ij = i*N+
-0002dc60: 6a0a 2020 2020 2020 2020 2020 2020 6966  j.            if
-0002dc70: 2069 6a20 696e 2064 6963 745f 4465 6c74   ij in dict_Delt
-0002dc80: 613a 0a20 2020 2020 2020 2020 2020 2020  a:.             
-0002dc90: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-0002dca0: 2020 2020 2020 2020 7769 203d 2077 5b69          wi = w[i
-0002dcb0: 5d0a 2020 2020 2020 2020 2020 2020 776a  ].            wj
-0002dcc0: 203d 2077 5b6a 5d0a 2020 2020 2020 2020   = w[j].        
-0002dcd0: 2020 2020 7763 203d 2077 6920 2b20 776a      wc = wi + wj
-0002dce0: 0a20 2020 2020 2020 2020 2020 2077 6977  .            wiw
-0002dcf0: 6a20 3d20 7769 202a 2077 6a0a 2020 2020  j = wi * wj.    
-0002dd00: 2020 2020 2020 2020 6966 2069 6a20 696e          if ij in
-0002dd10: 2064 6963 745f 443a 0a20 2020 2020 2020   dict_D:.       
-0002dd20: 2020 2020 2020 2020 2044 6363 5f77 6332           Dcc_wc2
-0002dd30: 203d 2032 202a 2064 6963 745f 442e 6765   = 2 * dict_D.ge
-0002dd40: 7428 696a 2c20 7769 776a 2a64 3029 202f  t(ij, wiwj*d0) /
-0002dd50: 2077 632a 2a32 0a20 2020 2020 2020 2020   wc**2.         
-0002dd60: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0002dd70: 2020 2020 2020 2020 2064 6963 745f 445b           dict_D[
-0002dd80: 696a 5d20 3d20 6469 6374 5f44 5b6a 2a4e  ij] = dict_D[j*N
-0002dd90: 2b69 5d20 3d20 7769 776a 6430 203d 2077  +i] = wiwjd0 = w
-0002dda0: 6977 6a2a 6430 0a20 2020 2020 2020 2020  iwj*d0.         
-0002ddb0: 2020 2020 2020 2044 6363 5f77 6332 203d         Dcc_wc2 =
-0002ddc0: 2032 202a 2077 6977 6a64 3020 2f20 7763   2 * wiwjd0 / wc
-0002ddd0: 2a2a 320a 2020 2020 2020 2020 2020 2020  **2.            
-0002dde0: 6469 6374 5f44 656c 7461 5b69 6a5d 203d  dict_Delta[ij] =
-0002ddf0: 2028 7769 2a2a 3220 2b20 776a 2a2a 3229   (wi**2 + wj**2)
-0002de00: 202a 2028 4463 635f 7763 3229 2a2a 3220   * (Dcc_wc2)**2 
-0002de10: 2b20 5c0a 2020 2020 2020 2020 2020 2020  + \.            
-0002de20: 2020 2020 3220 2a20 7769 776a 202a 2028      2 * wiwj * (
-0002de30: 4463 635f 7763 322d 3129 2a2a 320a 2020  Dcc_wc2-1)**2.  
-0002de40: 2020 2020 2020 7072 696e 7428 2269 6e69        print("ini
-0002de50: 7469 616c 697a 6174 696f 6e20 6f66 2063  tialization of c
-0002de60: 616e 6469 6461 7465 7320 6e65 6564 6564  andidates needed
-0002de70: 222c 2074 696d 652e 7469 6d65 2829 2d74  ", time.time()-t
-0002de80: 302c 2022 7365 632e 2229 0a0a 2020 2020  0, "sec.")..    
-0002de90: 2020 2020 7430 203d 2074 696d 652e 7469      t0 = time.ti
-0002dea0: 6d65 2829 0a20 2020 2020 2020 2063 616e  me().        can
-0002deb0: 6473 203d 2064 6963 745f 4465 6c74 612e  ds = dict_Delta.
-0002dec0: 6b65 7973 2829 0a20 2020 2020 2020 206e  keys().        n
-0002ded0: 5f63 616e 6473 203d 206c 656e 2863 616e  _cands = len(can
-0002dee0: 6473 290a 0a20 2020 2020 2020 2064 6963  ds)..        dic
-0002def0: 745f 4465 6c74 6120 3d20 5f64 6f5f 6e73  t_Delta = _do_ns
-0002df00: 695f 636c 7573 7465 7269 6e67 5f49 286e  i_clustering_I(n
-0002df10: 5f63 616e 6473 2c20 6361 6e64 732c 2044  _cands, cands, D
-0002df20: 5f63 6c75 7374 6572 2c20 772c 2064 302c  _cluster, w, d0,
-0002df30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0002df40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002df50: 2020 2020 2020 2020 2020 2044 5f66 6972             D_fir
-0002df60: 7374 706f 732c 2044 5f6e 6578 7470 6f73  stpos, D_nextpos
-0002df70: 2c20 4e2c 2064 6963 745f 442c 0a20 2020  , N, dict_D,.   
-0002df80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002df90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002dfa0: 2020 2020 2020 2064 6963 745f 4465 6c74         dict_Delt
-0002dfb0: 6129 0a0a 2020 2020 2020 2020 7072 696e  a)..        prin
-0002dfc0: 7428 6622 696e 6974 6961 6c69 7a61 7469  t(f"initializati
-0002dfd0: 6f6e 206f 6620 6572 726f 7220 696e 6372  on of error incr
-0002dfe0: 656d 656e 7473 206e 6565 6465 6422 0a20  ements needed". 
-0002dff0: 2020 2020 2020 2020 2020 2020 2066 227b               f"{
-0002e000: 7469 6d65 2e74 696d 6528 292d 7430 7d20  time.time()-t0} 
-0002e010: 7365 632e 2229 0a0a 2020 2020 2020 2020  sec.")..        
-0002e020: 2320 7375 6363 6573 7369 7665 6c79 206a  # successively j
-0002e030: 6f69 6e20 7468 6520 6265 7374 2070 6169  oin the best pai
-0002e040: 723a 0a20 2020 2020 2020 2073 756d 7431  r:.        sumt1
-0002e050: 203d 2073 756d 7432 203d 2073 756d 7433   = sumt2 = sumt3
-0002e060: 203d 2030 2e30 0a20 2020 2020 2020 2061   = 0.0.        a
-0002e070: 6374 6976 6573 203d 2072 616e 6765 284e  ctives = range(N
-0002e080: 290a 2020 2020 2020 2020 6d69 6e5f 636c  ).        min_cl
-0002e090: 7573 7465 7273 203d 2031 0a20 2020 2020  usters = 1.     
-0002e0a0: 2020 2066 6f72 206e 5f63 6c75 7374 6572     for n_cluster
-0002e0b0: 7320 696e 2072 616e 6765 284e 2d31 2c20  s in range(N-1, 
-0002e0c0: 302c 202d 3129 3a0a 0a20 2020 2020 2020  0, -1):..       
-0002e0d0: 2020 2020 2023 2066 696e 6420 6265 7374       # find best
-0002e0e0: 2070 6169 7220 613c 623a 0a20 2020 2020   pair a<b:.     
-0002e0f0: 2020 2020 2020 2074 3020 3d20 7469 6d65         t0 = time
-0002e100: 2e74 696d 6528 290a 2020 2020 2020 2020  .time().        
-0002e110: 2020 2020 7661 6c73 203d 2064 6963 745f      vals = dict_
-0002e120: 4465 6c74 612e 7661 6c75 6573 2829 0a20  Delta.values(). 
-0002e130: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-0002e140: 7420 7661 6c73 3a0a 2020 2020 2020 2020  t vals:.        
-0002e150: 2020 2020 2020 2020 6d69 6e5f 636c 7573          min_clus
-0002e160: 7465 7273 203d 206e 5f63 6c75 7374 6572  ters = n_cluster
-0002e170: 7320 2b20 310a 2020 2020 2020 2020 2020  s + 1.          
-0002e180: 2020 2020 2020 6272 6561 6b0a 2020 2020        break.    
-0002e190: 2020 2020 2020 2020 6d69 6e70 6f73 203d          minpos =
-0002e1a0: 206e 702e 6172 676d 696e 2876 616c 7329   np.argmin(vals)
-0002e1b0: 0a20 2020 2020 2020 2020 2020 2061 6220  .            ab 
-0002e1c0: 3d20 6469 6374 5f44 656c 7461 2e6b 6579  = dict_Delta.key
-0002e1d0: 7328 295b 6d69 6e70 6f73 5d0a 2020 2020  s()[minpos].    
-0002e1e0: 2020 2020 2020 2020 6465 6c20 6469 6374          del dict
-0002e1f0: 5f44 656c 7461 5b61 625d 0a20 2020 2020  _Delta[ab].     
-0002e200: 2020 2020 2020 2061 203d 2061 6220 2f20         a = ab / 
-0002e210: 4e0a 2020 2020 2020 2020 2020 2020 6220  N.            b 
-0002e220: 3d20 6162 2025 204e 0a20 2020 2020 2020  = ab % N.       
-0002e230: 2020 2020 2074 6869 735f 6572 726f 7220       this_error 
-0002e240: 3d20 7661 6c73 5b6d 696e 706f 735d 0a20  = vals[minpos]. 
-0002e250: 2020 2020 2020 2020 2020 2073 756d 7431             sumt1
-0002e260: 202b 3d20 7469 6d65 2e74 696d 6528 292d   += time.time()-
-0002e270: 7430 0a0a 2020 2020 2020 2020 2020 2020  t0..            
-0002e280: 2320 7265 6d6f 7665 2064 7570 6c69 6361  # remove duplica
-0002e290: 7465 7320 696e 2044 2061 6e64 2072 6577  tes in D and rew
-0002e2a0: 6972 6520 6e62 7320 6331 206f 6620 6220  ire nbs c1 of b 
-0002e2b0: 746f 2070 6f69 6e74 2074 6f20 613a 0a20  to point to a:. 
-0002e2c0: 2020 2020 2020 2020 2020 2064 656c 6b65             delke
-0002e2d0: 7973 203d 205b 2862 2c20 6229 5d0a 2020  ys = [(b, b)].  
-0002e2e0: 2020 2020 2020 2020 2020 7430 203d 2074            t0 = t
-0002e2f0: 696d 652e 7469 6d65 2829 0a20 2020 2020  ime.time().     
-0002e300: 2020 2020 2020 206c 706f 7320 3d20 445f         lpos = D_
-0002e310: 6c61 7374 706f 735b 615d 0a20 2020 2020  lastpos[a].     
-0002e320: 2020 2020 2020 2044 5f6e 6578 7470 6f73         D_nextpos
-0002e330: 5b6c 706f 735d 203d 2070 6f73 6331 203d  [lpos] = posc1 =
-0002e340: 2044 5f66 6972 7374 706f 735b 625d 0a20   D_firstpos[b]. 
-0002e350: 2020 2020 2020 2020 2020 2044 5f70 7265             D_pre
-0002e360: 7670 6f73 5b70 6f73 6331 5d20 3d20 6c70  vpos[posc1] = lp
-0002e370: 6f73 0a20 2020 2020 2020 2020 2020 2044  os.            D
-0002e380: 5f6c 6173 7470 6f73 5b61 5d20 3d20 445f  _lastpos[a] = D_
-0002e390: 6c61 7374 706f 735b 625d 0a20 2020 2020  lastpos[b].     
-0002e3a0: 2020 2020 2020 2077 6869 6c65 2070 6f73         while pos
-0002e3b0: 6331 2021 3d20 303a 0a20 2020 2020 2020  c1 != 0:.       
-0002e3c0: 2020 2020 2020 2020 2063 3120 3d20 445f           c1 = D_
-0002e3d0: 636c 7573 7465 725b 706f 7363 315d 0a20  cluster[posc1]. 
-0002e3e0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0002e3f0: 656c 6b65 7973 202b 3d20 5b28 6331 2c20  elkeys += [(c1, 
-0002e400: 6229 5d0a 2020 2020 2020 2020 2020 2020  b)].            
-0002e410: 2020 2020 6966 2063 3120 3c20 613a 0a20      if c1 < a:. 
-0002e420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e430: 2020 2063 3161 6b65 7920 3d20 6331 2a4e     c1akey = c1*N
-0002e440: 2b61 0a20 2020 2020 2020 2020 2020 2020  +a.             
-0002e450: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0002e460: 2020 2020 2020 2020 2020 2020 2063 3161               c1a
-0002e470: 6b65 7920 3d20 612a 4e2b 6331 0a20 2020  key = a*N+c1.   
-0002e480: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0002e490: 6331 203c 2062 3a0a 2020 2020 2020 2020  c1 < b:.        
-0002e4a0: 2020 2020 2020 2020 2020 2020 6331 626b              c1bk
-0002e4b0: 6579 203d 2063 312a 4e2b 620a 2020 2020  ey = c1*N+b.    
-0002e4c0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0002e4d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0002e4e0: 2020 2020 2020 6331 626b 6579 203d 2062        c1bkey = b
-0002e4f0: 2a4e 2b63 310a 2020 2020 2020 2020 2020  *N+c1.          
-0002e500: 2020 2020 2020 6966 2063 3162 6b65 7920        if c1bkey 
-0002e510: 696e 2064 6963 745f 4465 6c74 613a 2020  in dict_Delta:  
-0002e520: 2320 7265 7769 7265 2063 616e 642e 2063  # rewire cand. c
-0002e530: 312d 6220 746f 2063 312d 613a 0a20 2020  1-b to c1-a:.   
-0002e540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e550: 2064 656c 2064 6963 745f 4465 6c74 615b   del dict_Delta[
-0002e560: 6331 626b 6579 5d0a 2020 2020 2020 2020  c1bkey].        
-0002e570: 2020 2020 2020 2020 2020 2020 6469 6374              dict
-0002e580: 5f44 656c 7461 5b63 3161 6b65 795d 203d  _Delta[c1akey] =
-0002e590: 2030 2e30 2020 2320 7769 6c6c 206c 6174   0.0  # will lat
-0002e5a0: 6572 2062 6520 7265 636f 6d70 7574 6564  er be recomputed
-0002e5b0: 210a 2020 2020 2020 2020 2020 2020 2020  !.              
-0002e5c0: 2020 6966 2063 3120 3d3d 2061 206f 7220    if c1 == a or 
-0002e5d0: 6331 616b 6579 2069 6e20 6469 6374 5f44  c1akey in dict_D
-0002e5e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0002e5f0: 2020 2020 2020 6970 6f73 6331 203d 2044        iposc1 = D
-0002e600: 5f69 6e76 706f 735b 706f 7363 315d 0a20  _invpos[posc1]. 
-0002e610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e620: 2020 2069 7070 6f73 203d 2044 5f70 7265     ippos = D_pre
-0002e630: 7670 6f73 5b69 706f 7363 315d 0a20 2020  vpos[iposc1].   
-0002e640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e650: 2069 6e70 6f73 203d 2044 5f6e 6578 7470   inpos = D_nextp
-0002e660: 6f73 5b69 706f 7363 315d 0a20 2020 2020  os[iposc1].     
-0002e670: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0002e680: 6620 6970 706f 7320 3e20 303a 0a20 2020  f ippos > 0:.   
-0002e690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e6a0: 2020 2020 2044 5f6e 6578 7470 6f73 5b69       D_nextpos[i
-0002e6b0: 7070 6f73 5d20 3d20 696e 706f 730a 2020  ppos] = inpos.  
-0002e6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e6d0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0002e6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e6f0: 445f 6669 7273 7470 6f73 5b63 315d 203d  D_firstpos[c1] =
-0002e700: 2069 6e70 6f73 0a20 2020 2020 2020 2020   inpos.         
-0002e710: 2020 2020 2020 2020 2020 2069 6620 696e             if in
-0002e720: 706f 7320 3e20 303a 0a20 2020 2020 2020  pos > 0:.       
-0002e730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e740: 2044 5f70 7265 7670 6f73 5b69 6e70 6f73   D_prevpos[inpos
-0002e750: 5d20 3d20 6970 706f 730a 2020 2020 2020  ] = ippos.      
-0002e760: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0002e770: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0002e780: 2020 2020 2020 2020 2020 2020 445f 6c61              D_la
-0002e790: 7374 706f 735b 6331 5d20 3d20 6970 706f  stpos[c1] = ippo
-0002e7a0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
-0002e7b0: 2020 2020 2020 7070 6f73 203d 2044 5f70        ppos = D_p
-0002e7c0: 7265 7670 6f73 5b70 6f73 6331 5d0a 2020  revpos[posc1].  
-0002e7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e7e0: 2020 706f 7363 3120 3d20 445f 6e65 7874    posc1 = D_next
-0002e7f0: 706f 735b 706f 7363 315d 0a20 2020 2020  pos[posc1].     
-0002e800: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0002e810: 6620 7070 6f73 203e 2030 3a0a 2020 2020  f ppos > 0:.    
-0002e820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e830: 2020 2020 445f 6e65 7874 706f 735b 7070      D_nextpos[pp
-0002e840: 6f73 5d20 3d20 706f 7363 310a 2020 2020  os] = posc1.    
-0002e850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e860: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0002e870: 2020 2020 2020 2020 2020 2020 2020 445f                D_
-0002e880: 6669 7273 7470 6f73 5b61 5d20 3d20 706f  firstpos[a] = po
-0002e890: 7363 310a 2020 2020 2020 2020 2020 2020  sc1.            
-0002e8a0: 2020 2020 2020 2020 6966 2070 6f73 6331          if posc1
-0002e8b0: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
-0002e8c0: 2020 2020 2020 2020 2020 2020 2020 445f                D_
-0002e8d0: 7072 6576 706f 735b 706f 7363 315d 203d  prevpos[posc1] =
-0002e8e0: 2070 706f 730a 2020 2020 2020 2020 2020   ppos.          
-0002e8f0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0002e900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002e910: 2020 2020 2020 2020 445f 6c61 7374 706f          D_lastpo
-0002e920: 735b 615d 203d 2070 706f 730a 2020 2020  s[a] = ppos.    
-0002e930: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0002e940: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0002e950: 2020 2020 2020 445f 636c 7573 7465 725b        D_cluster[
-0002e960: 445f 696e 7670 6f73 5b70 6f73 6331 5d5d  D_invpos[posc1]]
-0002e970: 203d 2061 0a20 2020 2020 2020 2020 2020   = a.           
-0002e980: 2020 2020 2020 2020 2070 6f73 6331 203d           posc1 =
-0002e990: 2044 5f6e 6578 7470 6f73 5b70 6f73 6331   D_nextpos[posc1
-0002e9a0: 5d0a 2020 2020 2020 2020 2020 2020 445f  ].            D_
-0002e9b0: 6669 7273 7470 6f73 5b62 5d20 3d20 445f  firstpos[b] = D_
-0002e9c0: 6c61 7374 706f 735b 625d 203d 2030 0a20  lastpos[b] = 0. 
-0002e9d0: 2020 2020 2020 2020 2020 2073 756d 7432             sumt2
-0002e9e0: 202b 3d20 7469 6d65 2e74 696d 6528 292d   += time.time()-
-0002e9f0: 7430 0a0a 2020 2020 2020 2020 2020 2020  t0..            
-0002ea00: 2320 544f 444f 3a20 7468 6973 2069 7320  # TODO: this is 
-0002ea10: 7468 6520 626f 7474 6c65 6e65 636b 2c20  the bottleneck, 
-0002ea20: 736f 2073 7065 6564 2069 7420 7570 3a0a  so speed it up:.
-0002ea30: 2020 2020 2020 2020 2020 2020 2320 6669              # fi
-0002ea40: 7273 7420 7570 6461 7465 2044 656c 7461  rst update Delta
-0002ea50: 5b61 312c 6231 5d20 666f 7220 6561 6368  [a1,b1] for each
-0002ea60: 2070 6169 7220 6131 2c62 3120 7769 7468   pair a1,b1 with
-0002ea70: 2061 3120 6c69 6e6b 6564 2074 6f20 630a   a1 linked to c.
-0002ea80: 2020 2020 2020 2020 2020 2020 2320 616e              # an
-0002ea90: 6420 6231 2021 3d20 632c 2061 6e64 2063  d b1 != c, and c
-0002eaa0: 6f6d 7075 7465 2044 656c 7461 5b61 312c  ompute Delta[a1,
-0002eab0: 635d 2066 6f72 2065 6163 6820 6131 206c  c] for each a1 l
-0002eac0: 696e 6b65 6420 746f 2063 3a0a 2020 2020  inked to c:.    
-0002ead0: 2020 2020 2020 2020 7761 203d 2077 5b61          wa = w[a
-0002eae0: 5d0a 2020 2020 2020 2020 2020 2020 7762  ].            wb
-0002eaf0: 203d 2077 5b62 5d0a 2020 2020 2020 2020   = w[b].        
-0002eb00: 2020 2020 7763 203d 2077 6120 2b20 7762      wc = wa + wb
-0002eb10: 0a20 2020 2020 2020 2020 2020 2077 6164  .            wad
-0002eb20: 3020 3d20 7761 202a 2064 300a 2020 2020  0 = wa * d0.    
-0002eb30: 2020 2020 2020 2020 7762 6430 203d 2077          wbd0 = w
-0002eb40: 6220 2a20 6430 0a0a 2020 2020 2020 2020  b * d0..        
-0002eb50: 2020 2020 7430 203d 2074 696d 652e 7469      t0 = time.ti
-0002eb60: 6d65 2829 0a0a 2020 2020 2020 2020 2020  me()..          
-0002eb70: 2020 6469 6374 5f44 656c 7461 203d 205f    dict_Delta = _
-0002eb80: 646f 5f6e 7369 5f63 6c75 7374 6572 696e  do_nsi_clusterin
-0002eb90: 675f 4949 2861 2c20 622c 2044 5f63 6c75  g_II(a, b, D_clu
-0002eba0: 7374 6572 2c20 772c 2064 302c 0a20 2020  ster, w, d0,.   
-0002ebb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ebc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ebd0: 2020 2020 2020 2020 2020 2020 445f 6669              D_fi
-0002ebe0: 7273 7470 6f73 2c20 445f 6e65 7874 706f  rstpos, D_nextpo
-0002ebf0: 732c 204e 2c0a 2020 2020 2020 2020 2020  s, N,.          
-0002ec00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ec10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002ec20: 2020 2020 2064 6963 745f 442c 2064 6963       dict_D, dic
-0002ec30: 745f 4465 6c74 6129 0a0a 2020 2020 2020  t_Delta)..      
-0002ec40: 2020 2020 2020 7375 6d74 3320 3d20 7469        sumt3 = ti
-0002ec50: 6d65 2e74 696d 6528 292d 7430 0a0a 2020  me.time()-t0..  
-0002ec60: 2020 2020 2020 2020 2020 2320 6669 6e61            # fina
-0002ec70: 6c6c 7920 7570 6461 7465 2044 3a0a 2020  lly update D:.  
-0002ec80: 2020 2020 2020 2020 2020 4461 6120 3d20            Daa = 
-0002ec90: 6469 6374 5f44 2e67 6574 2861 2a28 4e2b  dict_D.get(a*(N+
-0002eca0: 3129 2c20 302e 3029 0a20 2020 2020 2020  1), 0.0).       
-0002ecb0: 2020 2020 2044 6262 203d 2064 6963 745f       Dbb = dict_
-0002ecc0: 442e 6765 7428 622a 284e 2b31 292c 2030  D.get(b*(N+1), 0
-0002ecd0: 2e30 290a 2020 2020 2020 2020 2020 2020  .0).            
-0002ece0: 6469 6374 5f44 5b61 2a28 4e2b 3129 5d20  dict_D[a*(N+1)] 
-0002ecf0: 3d20 4461 6120 2b20 4462 6220 2b20 322a  = Daa + Dbb + 2*
-0002ed00: 6469 6374 5f44 5b61 2a4e 2b62 5d0a 2020  dict_D[a*N+b].  
-0002ed10: 2020 2020 2020 2020 2020 706f 7363 3120            posc1 
-0002ed20: 3d20 445f 6669 7273 7470 6f73 5b61 5d0a  = D_firstpos[a].
-0002ed30: 2020 2020 2020 2020 2020 2020 7768 696c              whil
-0002ed40: 6520 706f 7363 3120 3e20 303a 0a20 2020  e posc1 > 0:.   
-0002ed50: 2020 2020 2020 2020 2020 2020 2063 3120               c1 
-0002ed60: 3d20 445f 636c 7573 7465 725b 706f 7363  = D_cluster[posc
-0002ed70: 315d 0a20 2020 2020 2020 2020 2020 2020  1].             
-0002ed80: 2020 2044 6163 3120 3d20 6469 6374 5f44     Dac1 = dict_D
-0002ed90: 2e67 6574 2861 2a4e 2b63 312c 2077 5b63  .get(a*N+c1, w[c
-0002eda0: 315d 2a77 6164 3029 0a20 2020 2020 2020  1]*wad0).       
-0002edb0: 2020 2020 2020 2020 2044 6263 3120 3d20           Dbc1 = 
-0002edc0: 6469 6374 5f44 2e67 6574 2862 2a4e 2b63  dict_D.get(b*N+c
-0002edd0: 312c 2077 5b63 315d 2a77 6264 3029 0a20  1, w[c1]*wbd0). 
-0002ede0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0002edf0: 6963 745f 445b 6331 2a4e 2b61 5d20 3d20  ict_D[c1*N+a] = 
-0002ee00: 6469 6374 5f44 5b61 2a4e 2b63 315d 203d  dict_D[a*N+c1] =
-0002ee10: 2044 6163 3120 2b20 4462 6331 0a20 2020   Dac1 + Dbc1.   
-0002ee20: 2020 2020 2020 2020 2020 2020 2070 6f73               pos
-0002ee30: 6331 203d 2044 5f6e 6578 7470 6f73 5b70  c1 = D_nextpos[p
-0002ee40: 6f73 6331 5d0a 0a20 2020 2020 2020 2020  osc1]..         
-0002ee50: 2020 2023 2075 7064 6174 6520 7265 7375     # update resu
-0002ee60: 6c74 2073 7472 7563 7475 7265 733a 0a20  lt structures:. 
-0002ee70: 2020 2020 2020 2020 2020 2063 203d 204e             c = N
-0002ee80: 3220 2d20 6e5f 636c 7573 7465 7273 0a20  2 - n_clusters. 
-0002ee90: 2020 2020 2020 2020 2020 2065 7272 6f72             error
-0002eea0: 5b6e 5f63 6c75 7374 6572 735d 203d 2065  [n_clusters] = e
-0002eeb0: 7272 6f72 5b6e 5f63 6c75 7374 6572 732b  rror[n_clusters+
-0002eec0: 315d 202b 2074 6869 735f 6572 726f 720a  1] + this_error.
-0002eed0: 2020 2020 2020 2020 2020 2020 2320 544f              # TO
-0002eee0: 444f 3a20 6e6f 6465 3263 6c75 7374 6572  DO: node2cluster
-0002eef0: 0a20 2020 2020 2020 2020 2020 2063 6c75  .            clu
-0002ef00: 7374 6572 5f77 6569 6768 745b 635d 203d  ster_weight[c] =
-0002ef10: 2077 630a 2020 2020 2020 2020 2020 2020   wc.            
-0002ef20: 2320 544f 444f 3a20 636c 7573 7465 7232  # TODO: cluster2
-0002ef30: 7261 6e6b 0a20 2020 2020 2020 2020 2020  rank.           
-0002ef40: 2023 2054 4f44 4f3a 206e 6f64 655f 696e   # TODO: node_in
-0002ef50: 5f63 6c75 7374 6572 0a20 2020 2020 2020  _cluster.       
-0002ef60: 2020 2020 2063 6869 6c64 7265 6e5b 632c       children[c,
-0002ef70: 2030 5d20 3d20 6361 203d 2063 6c69 645b   0] = ca = clid[
-0002ef80: 615d 0a20 2020 2020 2020 2020 2020 2063  a].            c
-0002ef90: 6869 6c64 7265 6e5b 632c 2031 5d20 3d20  hildren[c, 1] = 
-0002efa0: 7369 626c 696e 675b 6361 5d20 3d20 6362  sibling[ca] = cb
-0002efb0: 203d 2063 6c69 645b 625d 0a20 2020 2020   = clid[b].     
-0002efc0: 2020 2020 2020 2073 6962 6c69 6e67 5b63         sibling[c
-0002efd0: 625d 203d 2063 610a 2020 2020 2020 2020  b] = ca.        
-0002efe0: 2020 2020 7061 7265 6e74 5b63 615d 203d      parent[ca] =
-0002eff0: 2070 6172 656e 745b 6362 5d20 3d20 630a   parent[cb] = c.
-0002f000: 2020 2020 2020 2020 2020 2020 7061 7265              pare
-0002f010: 6e74 5b63 5d20 3d20 4e32 202d 2031 2020  nt[c] = N2 - 1  
-0002f020: 2320 696e 6974 6961 6c6c 792c 2075 6e74  # initially, unt
-0002f030: 696c 206a 6f69 6e65 642e 0a0a 2020 2020  il joined...    
-0002f040: 2020 2020 2020 2020 2320 7265 6d6f 7665          # remove
-0002f050: 2062 2061 6e64 2072 6570 6c61 6365 2061   b and replace a
-0002f060: 2062 7920 633a 0a20 2020 2020 2020 2020   by c:.         
-0002f070: 2020 2066 6f72 206b 312c 206b 3220 696e     for k1, k2 in
-0002f080: 2064 656c 6b65 7973 3a0a 2020 2020 2020   delkeys:.      
-0002f090: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
-0002f0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f0b0: 2020 2064 656c 2064 6963 745f 445b 6b31     del dict_D[k1
-0002f0c0: 2a4e 2b6b 325d 2c20 6469 6374 5f44 5b6b  *N+k2], dict_D[k
-0002f0d0: 322a 4e2b 6b31 5d0a 2020 2020 2020 2020  2*N+k1].        
-0002f0e0: 2020 2020 2020 2020 6578 6365 7074 204b          except K
-0002f0f0: 6579 4572 726f 723a 0a20 2020 2020 2020  eyError:.       
-0002f100: 2020 2020 2020 2020 2020 2020 2070 6173               pas
-0002f110: 730a 2020 2020 2020 2020 2020 2020 6163  s.            ac
-0002f120: 7469 7665 732e 7265 6d6f 7665 2862 290a  tives.remove(b).
-0002f130: 2020 2020 2020 2020 2020 2020 636c 6964              clid
-0002f140: 5b61 5d20 3d20 630a 2020 2020 2020 2020  [a] = c.        
-0002f150: 2020 2020 775b 615d 203d 2077 630a 0a20      w[a] = wc.. 
-0002f160: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-0002f170: 286e 5f63 6c75 7374 6572 732c 2022 3a20  (n_clusters, ": 
-0002f180: 6a6f 696e 696e 6722 2c20 6361 2c20 6362  joining", ca, cb
-0002f190: 2c20 2274 6f22 2c20 632c 2022 6174 222c  , "to", c, "at",
-0002f1a0: 2074 6869 735f 6572 726f 7229 0a20 2020   this_error).   
-0002f1b0: 2020 2020 2020 2020 2069 6620 6e5f 636c           if n_cl
-0002f1c0: 7573 7465 7273 203c 2031 303a 0a20 2020  usters < 10:.   
-0002f1d0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-0002f1e0: 6e74 2822 4422 2c20 6469 6374 5f44 290a  nt("D", dict_D).
-0002f1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f200: 7072 696e 7428 2244 656c 7461 222c 2064  print("Delta", d
-0002f210: 6963 745f 4465 6c74 6129 0a0a 2020 2020  ict_Delta)..    
-0002f220: 2020 2020 7072 696e 7428 2270 6172 7420      print("part 
-0002f230: 3120 6e65 6564 6564 222c 2073 756d 7431  1 needed", sumt1
-0002f240: 2c20 2273 6563 2e22 290a 2020 2020 2020  , "sec.").      
-0002f250: 2020 7072 696e 7428 2270 6172 7420 3220    print("part 2 
-0002f260: 6e65 6564 6564 222c 2073 756d 7432 2c20  needed", sumt2, 
-0002f270: 2273 6563 2e22 290a 2020 2020 2020 2020  "sec.").        
-0002f280: 7072 696e 7428 2270 6172 7420 3320 6e65  print("part 3 ne
-0002f290: 6564 6564 222c 2073 756d 7433 2c20 2273  eded", sumt3, "s
-0002f2a0: 6563 2e22 290a 0a20 2020 2020 2020 2069  ec.")..        i
-0002f2b0: 6620 7472 6565 5f64 6f74 6669 6c65 2069  f tree_dotfile i
-0002f2c0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-0002f2d0: 2020 2020 2020 2020 2320 7573 6520 7065          # use pe
-0002f2e0: 6e77 6964 7468 2061 6e64 206c 656e 210a  nwidth and len!.
-0002f2f0: 2020 2020 2020 2020 2020 2020 6564 6765              edge
-0002f300: 7320 3d20 5b28 696e 7428 6e29 2c20 696e  s = [(int(n), in
-0002f310: 7428 7061 7265 6e74 5b6e 5d29 2920 666f  t(parent[n])) fo
-0002f320: 7220 6e20 696e 2072 616e 6765 284e 322d  r n in range(N2-
-0002f330: 3129 5d0a 2020 2020 2020 2020 2020 2020  1)].            
-0002f340: 6d69 6e6c 656e 203d 205b 696e 7428 7061  minlen = [int(pa
-0002f350: 7265 6e74 5b6e 5d2d 6d61 7828 6e2c 204e  rent[n]-max(n, N
-0002f360: 2d31 2929 2066 6f72 206e 2069 6e20 7261  -1)) for n in ra
-0002f370: 6e67 6528 4e32 2d31 295d 0a20 2020 2020  nge(N2-1)].     
-0002f380: 2020 2020 2020 2023 2054 4f44 4f3a 2065         # TODO: e
-0002f390: 7073 202b 2065 7272 6f72 2064 6966 6665  ps + error diffe
-0002f3a0: 7265 6e63 650a 2020 2020 2020 2020 2020  rence.          
-0002f3b0: 2020 6564 6765 6c65 6e20 3d20 6e70 2e61    edgelen = np.a
-0002f3c0: 7272 6179 280a 2020 2020 2020 2020 2020  rray(.          
-0002f3d0: 2020 2020 2020 5b6d 6178 2830 2e30 2c20        [max(0.0, 
-0002f3e0: 6572 726f 725b 4e32 2d70 6172 656e 745b  error[N2-parent[
-0002f3f0: 6e5d 5d29 2066 6f72 206e 2069 6e20 7261  n]]) for n in ra
-0002f400: 6e67 6528 4e29 5d0a 2020 2020 2020 2020  nge(N)].        
-0002f410: 2020 2020 2020 2020 2b20 5b6d 6178 2830          + [max(0
-0002f420: 2e30 2c20 6572 726f 725b 4e32 2d70 6172  .0, error[N2-par
-0002f430: 656e 745b 6e5d 5d2d 6572 726f 725b 4e32  ent[n]]-error[N2
-0002f440: 2d6e 5d29 0a20 2020 2020 2020 2020 2020  -n]).           
-0002f450: 2020 2020 2020 2020 666f 7220 6e20 696e          for n in
-0002f460: 2072 616e 6765 284e 2c20 4e32 2d31 295d   range(N, N2-1)]
-0002f470: 2920 2023 206d 696e 6c65 6e0a 2020 2020  )  # minlen.    
-0002f480: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
-0002f490: 312f 2865 7073 202b 2065 7272 6f72 2064  1/(eps + error d
-0002f4a0: 6966 6665 7265 6e63 6529 0a20 2020 2020  ifference).     
-0002f4b0: 2020 2020 2020 2023 205b 312e 3020 666f         # [1.0 fo
-0002f4c0: 7220 6920 696e 2072 616e 6765 284e 322d  r i in range(N2-
-0002f4d0: 3129 5d0a 2020 2020 2020 2020 2020 2020  1)].            
-0002f4e0: 7065 6e77 6964 7468 203d 2033 302e 3020  penwidth = 30.0 
-0002f4f0: 2f20 2831 2e30 202b 2032 392e 302a 6564  / (1.0 + 29.0*ed
-0002f500: 6765 6c65 6e2f 6564 6765 6c65 6e2e 6d61  gelen/edgelen.ma
-0002f510: 7828 2929 0a20 2020 2020 2020 2020 2020  x()).           
-0002f520: 2074 7265 6520 3d20 6967 7261 7068 2e47   tree = igraph.G
-0002f530: 7261 7068 2865 6467 6573 2c20 6469 7265  raph(edges, dire
-0002f540: 6374 6564 3d54 7275 6529 0a20 2020 2020  cted=True).     
-0002f550: 2020 2020 2020 2074 7265 652e 6573 2e73         tree.es.s
-0002f560: 6574 5f61 7474 7269 6275 7465 5f76 616c  et_attribute_val
-0002f570: 7565 7328 226d 696e 6c65 6e22 2c20 6d69  ues("minlen", mi
-0002f580: 6e6c 656e 290a 2020 2020 2020 2020 2020  nlen).          
-0002f590: 2020 7472 6565 2e65 732e 7365 745f 6174    tree.es.set_at
-0002f5a0: 7472 6962 7574 655f 7661 6c75 6573 2822  tribute_values("
-0002f5b0: 6c65 6e22 2c20 6564 6765 6c65 6e29 0a20  len", edgelen). 
-0002f5c0: 2020 2020 2020 2020 2020 2074 7265 652e             tree.
-0002f5d0: 6573 2e73 6574 5f61 7474 7269 6275 7465  es.set_attribute
-0002f5e0: 5f76 616c 7565 7328 2270 656e 7769 6474  _values("penwidt
-0002f5f0: 6822 2c20 7065 6e77 6964 7468 290a 2020  h", penwidth).  
-0002f600: 2020 2020 2020 2020 2020 7472 6565 5b22            tree["
-0002f610: 7261 6e6b 6469 7222 5d20 3d20 2242 5422  rankdir"] = "BT"
-0002f620: 0a20 2020 2020 2020 2020 2020 2074 7265  .            tre
-0002f630: 652e 7772 6974 655f 646f 7428 7472 6565  e.write_dot(tree
-0002f640: 5f64 6f74 6669 6c65 290a 2020 2020 2020  _dotfile).      
-0002f650: 2020 2020 2020 6465 6c20 7472 6565 0a0a        del tree..
-0002f660: 2020 2020 2020 2020 7265 7475 726e 207b          return {
-0002f670: 0a20 2020 2020 2020 2020 2020 2022 6d69  .            "mi
-0002f680: 6e5f 636c 7573 7465 7273 223a 206d 696e  n_clusters": min
-0002f690: 5f63 6c75 7374 6572 732c 2022 6e6f 6465  _clusters, "node
-0002f6a0: 3263 6c75 7374 6572 223a 206e 6f64 6532  2cluster": node2
-0002f6b0: 636c 7573 7465 722c 0a20 2020 2020 2020  cluster,.       
-0002f6c0: 2020 2020 2022 636c 7573 7465 7232 7261       "cluster2ra
-0002f6d0: 6e6b 223a 2063 6c75 7374 6572 3272 616e  nk": cluster2ran
-0002f6e0: 6b2c 2022 636c 7573 7465 725f 7765 6967  k, "cluster_weig
-0002f6f0: 6874 223a 2063 6c75 7374 6572 5f77 6569  ht": cluster_wei
-0002f700: 6768 742c 0a20 2020 2020 2020 2020 2020  ght,.           
-0002f710: 2022 6e6f 6465 5f69 6e5f 636c 7573 7465   "node_in_cluste
-0002f720: 7222 3a20 6e6f 6465 5f69 6e5f 636c 7573  r": node_in_clus
-0002f730: 7465 722c 2022 6572 726f 7222 3a20 6572  ter, "error": er
-0002f740: 726f 722c 0a20 2020 2020 2020 2020 2020  ror,.           
-0002f750: 2022 6368 696c 6472 656e 223a 2063 6869   "children": chi
-0002f760: 6c64 7265 6e2c 2022 7369 626c 696e 6722  ldren, "sibling"
-0002f770: 3a20 7369 626c 696e 672c 2022 7061 7265  : sibling, "pare
-0002f780: 6e74 223a 2070 6172 656e 740a 2020 2020  nt": parent.    
-0002f790: 2020 2020 7d0a 0a20 2020 2064 6566 2064      }..    def d
-0002f7a0: 6f5f 6e73 695f 6861 6d6d 696e 675f 636c  o_nsi_hamming_cl
-0002f7b0: 7573 7465 7269 6e67 2873 656c 662c 2061  ustering(self, a
-0002f7c0: 646d 6973 7369 626c 655f 6a6f 696e 733d  dmissible_joins=
-0002f7d0: 4e6f 6e65 2c20 616c 7068 613d 302e 3031  None, alpha=0.01
-0002f7e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0002f7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0002f800: 2020 2020 7472 6565 5f64 6f74 6669 6c65      tree_dotfile
-0002f810: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
-0002f820: 2222 220a 2020 2020 2020 2020 5065 7266  """.        Perf
-0002f830: 6f72 6d20 6167 676c 6f6d 6572 6174 6976  orm agglomerativ
-0002f840: 6520 636c 7573 7465 7269 6e67 2062 6173  e clustering bas
-0002f850: 6564 206f 6e20 4861 6d6d 696e 6720 6469  ed on Hamming di
-0002f860: 7374 616e 6365 732e 0a0a 2020 2020 2020  stances...      
-0002f870: 2020 5468 6973 206d 696e 696d 697a 6573    This minimizes
-0002f880: 2069 6e20 6561 6368 2073 7465 7020 7468   in each step th
-0002f890: 6520 4861 6d6d 696e 6720 6469 7374 616e  e Hamming distan
-0002f8a0: 6365 2062 6574 7765 656e 2074 6865 206f  ce between the o
-0002f8b0: 7269 6769 6e61 6c0a 2020 2020 2020 2020  riginal.        
-0002f8c0: 616e 6420 7468 6520 2263 6c75 7374 6572  and the "cluster
-0002f8d0: 6564 2220 6e65 7477 6f72 6b2e 0a0a 2020  ed" network...  
-0002f8e0: 2020 2020 2020 2e2e 206e 6f74 653a 3a0a        .. note::.
-0002f8f0: 2020 2020 2020 2020 2020 2054 6869 7320             This 
-0002f900: 6973 2073 7469 6c6c 2045 5850 4552 494d  is still EXPERIM
-0002f910: 454e 5441 4c21 0a0a 2020 2020 2020 2020  ENTAL!..        
-0002f920: 5365 6520 7468 6520 636f 6465 2066 6f72  See the code for
-0002f930: 2061 7267 756d 656e 7473 2061 6e64 2072   arguments and r
-0002f940: 6574 7572 6e20 7661 6c75 652e 0a0a 2020  eturn value...  
-0002f950: 2020 2020 2020 436c 7573 7465 7273 2030        Clusters 0
-0002f960: 2e2e 2e6e 2d31 2061 7265 2074 6865 2073  ...n-1 are the s
-0002f970: 696e 676c 6574 6f6e 7320 2863 6c75 7374  ingletons (clust
-0002f980: 6572 2069 2063 6f6e 7461 696e 696e 6720  er i containing 
-0002f990: 6a75 7374 206e 6f64 6520 6929 2e0a 2020  just node i)..  
-0002f9a0: 2020 2020 2020 436c 7573 7465 7273 206e        Clusters n
-0002f9b0: 2e2e 2e32 6e2d 3220 6172 6520 6e75 6d62  ...2n-2 are numb
-0002f9c0: 6572 6564 2069 6e20 7468 6520 6f72 6465  ered in the orde
-0002f9d0: 7220 696e 2077 6869 6368 2063 6c75 7374  r in which clust
-0002f9e0: 6572 7320 6172 650a 2020 2020 2020 2020  ers are.        
-0002f9f0: 6a6f 696e 6564 2028 6120 636c 7573 7465  joined (a cluste
-0002fa00: 7220 7769 7468 2069 6420 6320 6973 2061  r with id c is a
-0002fa10: 2075 6e69 6f6e 206f 6620 7477 6f20 6561   union of two ea
-0002fa20: 726c 6965 7220 636c 7573 7465 7273 2077  rlier clusters w
-0002fa30: 6974 680a 2020 2020 2020 2020 6964 7320  ith.        ids 
-0002fa40: 6331 2c63 3220 3c20 6329 2e20 496e 2070  c1,c2 < c). In p
-0002fa50: 6172 7469 6375 6c61 722c 2063 6c75 7374  articular, clust
-0002fa60: 6572 2032 6e2d 3220 6973 2074 6865 2066  er 2n-2 is the f
-0002fa70: 756c 6c20 7365 7420 6f66 206e 6f64 6573  ull set of nodes
-0002fa80: 2e0a 0a20 2020 2020 2020 203a 7274 7970  ...        :rtyp
-0002fa90: 653a 2020 6469 6374 696f 6e61 7279 0a20  e:  dictionary. 
-0002faa0: 2020 2020 2020 203a 7265 7475 726e 3a20         :return: 
-0002fab0: 4120 6469 6374 696f 6e61 7279 2063 6f6e  A dictionary con
-0002fac0: 7461 696e 696e 6720 7468 6520 666f 6c6c  taining the foll
-0002fad0: 6f77 696e 6720 6b65 7973 3a0a 0a20 2020  owing keys:..   
-0002fae0: 2020 2020 2020 2020 2d20 2265 7272 6f72          - "error
-0002faf0: 223a 2061 7272 6179 286e 2b31 292e 2045  ": array(n+1). E
-0002fb00: 6e74 7279 205b 6b5d 2069 7320 7468 6520  ntry [k] is the 
-0002fb10: 7265 7072 6573 656e 7461 7469 6f6e 2065  representation e
-0002fb20: 7272 6f72 2066 6f72 2074 6865 0a20 2020  rror for the.   
-0002fb30: 2020 2020 2020 2020 2020 736f 6c75 7469            soluti
-0002fb40: 6f6e 2077 6974 6820 6b20 636c 7573 7465  on with k cluste
-0002fb50: 7273 2e0a 2020 2020 2020 2020 2020 202d  rs..           -
-0002fb60: 2022 6e6f 6465 3263 6c75 7374 6572 223a   "node2cluster":
-0002fb70: 2061 7272 6179 286e 2c6e 2b31 292e 2045   array(n,n+1). E
-0002fb80: 6e74 7279 205b 692c 6b5d 2069 7320 7468  ntry [i,k] is th
-0002fb90: 6520 6964 206f 6620 7468 6520 636c 7573  e id of the clus
-0002fba0: 7465 720a 2020 2020 2020 2020 2020 2020  ter.            
-0002fbb0: 2074 6861 7420 636f 6e74 6169 6e73 206e   that contains n
-0002fbc0: 6f64 6520 6920 696e 2074 6865 2073 6f6c  ode i in the sol
-0002fbd0: 7574 696f 6e20 7769 7468 206b 2063 6c75  ution with k clu
-0002fbe0: 7374 6572 732e 0a20 2020 2020 2020 2020  sters..         
-0002fbf0: 2020 2d20 2263 6c75 7374 6572 5f77 6569    - "cluster_wei
-0002fc00: 6768 7422 3a20 6172 7261 7928 326e 2d31  ght": array(2n-1
-0002fc10: 292e 2045 6e74 7279 205b 635d 2069 7320  ). Entry [c] is 
-0002fc20: 7468 6520 746f 7461 6c20 7765 6967 6874  the total weight
-0002fc30: 206f 660a 2020 2020 2020 2020 2020 2020   of.            
-0002fc40: 2063 6c75 7374 6572 2063 2e0a 2020 2020   cluster c..    
-0002fc50: 2020 2020 2020 202d 2022 636c 7573 7465         - "cluste
-0002fc60: 7232 7261 6e6b 223a 2061 7272 6179 2832  r2rank": array(2
-0002fc70: 6e2d 312c 6e2b 3129 2e20 456e 7472 7920  n-1,n+1). Entry 
-0002fc80: 5b63 2c6b 5d20 6973 2074 6865 2064 6573  [c,k] is the des
-0002fc90: 6365 6e64 696e 670a 2020 2020 2020 2020  cending.        
-0002fca0: 2020 2020 206f 7264 6572 2072 616e 6b20       order rank 
-0002fcb0: 6f66 2063 6c75 7374 6572 2063 2069 6e20  of cluster c in 
-0002fcc0: 7468 6520 6b2d 636c 7573 7465 7220 736f  the k-cluster so
-0002fcd0: 6c75 7469 6f6e 2c20 692e 652e 2c20 7468  lution, i.e., th
-0002fce0: 650a 2020 2020 2020 2020 2020 2020 206e  e.             n
-0002fcf0: 756d 6265 7220 6f66 206c 6172 6765 7220  umber of larger 
-0002fd00: 636c 7573 7465 7273 2069 6e20 7468 6174  clusters in that
-0002fd10: 2073 6f6c 7574 696f 6e2e 2055 7365 2074   solution. Use t
-0002fd20: 6869 7320 746f 2063 6f6e 7665 7274 0a20  his to convert. 
-0002fd30: 2020 2020 2020 2020 2020 2020 636c 7573              clus
-0002fd40: 7465 7220 6964 7320 696e 2030 2e2e 2e32  ter ids in 0...2
-0002fd50: 6e2d 3120 746f 2063 6c75 7374 6572 2069  n-1 to cluster i
-0002fd60: 6473 2069 6e20 302e 2e2e 6b2d 312e 0a20  ds in 0...k-1.. 
-0002fd70: 2020 2020 2020 2020 2020 2d20 226e 6f64            - "nod
-0002fd80: 655f 696e 5f63 6c75 7374 6572 223a 2061  e_in_cluster": a
-0002fd90: 7272 6179 286e 2c32 6e2d 3129 2e20 456e  rray(n,2n-1). En
-0002fda0: 7472 7920 5b69 2c63 5d20 696e 6469 6361  try [i,c] indica
-0002fdb0: 7465 7320 7768 6574 6865 720a 2020 2020  tes whether.    
-0002fdc0: 2020 2020 2020 2020 206e 6f64 6520 6920           node i 
-0002fdd0: 6973 2069 6e20 7468 6520 636c 7573 7465  is in the cluste
-0002fde0: 7220 7769 7468 2069 6420 632e 0a20 2020  r with id c..   
-0002fdf0: 2020 2020 2020 2020 2d20 2263 6869 6c64          - "child
-0002fe00: 7265 6e22 3a20 6172 7261 7928 326e 2d31  ren": array(2n-1
-0002fe10: 2c32 292e 2045 6e74 7269 6573 205b 632c  ,2). Entries [c,
-0002fe20: 305d 2061 6e64 205b 632c 315d 2061 7265  0] and [c,1] are
-0002fe30: 2074 6865 2069 6473 206f 660a 2020 2020   the ids of.    
-0002fe40: 2020 2020 2020 2020 2074 6865 2074 776f           the two
-0002fe50: 2063 6c75 7374 6572 7320 7468 6174 2077   clusters that w
-0002fe60: 6572 6520 6a6f 696e 6564 2074 6f20 6769  ere joined to gi
-0002fe70: 7665 2063 6c75 7374 6572 2063 2e0a 2020  ve cluster c..  
-0002fe80: 2020 2020 2020 2020 202d 2022 7369 626c           - "sibl
-0002fe90: 696e 6722 3a20 6172 7261 7928 326e 2d32  ing": array(2n-2
-0002fea0: 292e 2045 6e74 7279 205b 635d 2069 7320  ). Entry [c] is 
-0002feb0: 7468 6520 6964 206f 6620 7468 6520 636c  the id of the cl
-0002fec0: 7573 7465 7220 7769 7468 0a20 2020 2020  uster with.     
-0002fed0: 2020 2020 2020 2020 7768 6963 6820 636c          which cl
-0002fee0: 7573 7465 7220 6320 6973 206a 6f69 6e65  uster c is joine
-0002fef0: 642e 0a20 2020 2020 2020 2020 2020 2d20  d..           - 
-0002ff00: 2270 6172 656e 7422 3a20 6172 7261 7928  "parent": array(
-0002ff10: 326e 2d32 292e 2045 6e74 7279 205b 635d  2n-2). Entry [c]
-0002ff20: 2069 7320 7468 6520 6964 206f 6620 7468   is the id of th
-0002ff30: 6520 636c 7573 7465 7220 7468 6174 0a20  e cluster that. 
-0002ff40: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-0002ff50: 6c74 7320 6672 6f6d 206a 6f69 6e69 6e67  lts from joining
-0002ff60: 2063 6c75 7374 6572 2063 2077 6974 6820   cluster c with 
-0002ff70: 6974 7320 7369 626c 696e 672e 0a20 2020  its sibling..   
-0002ff80: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0002ff90: 2023 2074 6f6f 6b20 6162 6f75 7420 3135   # took about 15
-0002ffa0: 6820 6f6e 205a 7573 6520 666f 7220 4861  h on Zuse for Ha
-0002ffb0: 6443 4d33 2067 6c6f 6265 0a20 2020 2020  dCM3 globe.     
-0002ffc0: 2020 2023 203f 7461 6b65 7320 6162 6f75     # ?takes abou
-0002ffd0: 7420 3930 2a28 4e2f 3830 3029 5e34 2073  t 90*(N/800)^4 s
-0002ffe0: 6563 6f6e 6473 206f 6e20 6120 312e 3637  econds on a 1.67
-0002fff0: 2047 487a 2069 3638 362c 0a20 2020 2020   GHz i686,.     
-00030000: 2020 2023 2077 6869 6368 206d 616b 6573     # which makes
-00030010: 2061 626f 7574 2031 3020 6461 7973 2066   about 10 days f
-00030020: 6f72 204e 3d38 3030 3020 2865 2e67 2e20  or N=8000 (e.g. 
-00030030: 6120 4861 6443 4d33 2067 6c6f 6265 290a  a HadCM3 globe).
-00030040: 0a20 2020 2020 2020 2074 3020 3d20 7469  .        t0 = ti
-00030050: 6d65 2e74 696d 6528 290a 0a20 2020 2020  me.time()..     
-00030060: 2020 2023 2069 6e69 7469 616c 697a 6520     # initialize 
-00030070: 6461 7461 2073 7472 7563 7475 7265 733a  data structures:
-00030080: 0a0a 2020 2020 2020 2020 6e20 3d20 7365  ..        n = se
-00030090: 6c66 2e4e 0a20 2020 2020 2020 206e 3220  lf.N.        n2 
-000300a0: 3d20 322a 6e2d 310a 2020 2020 2020 2020  = 2*n-1.        
-000300b0: 7720 3d20 7365 6c66 2e6e 6f64 655f 7765  w = self.node_we
-000300c0: 6967 6874 730a 2020 2020 2020 2020 5757  ights.        WW
-000300d0: 203d 2073 656c 662e 746f 7461 6c5f 6e6f   = self.total_no
-000300e0: 6465 5f77 6569 6768 742a 2a32 0a0a 2020  de_weight**2..  
-000300f0: 2020 2020 2020 2320 6a6f 696e 2061 646d        # join adm
-00030100: 6973 7369 6269 6c69 7479 206d 6174 7269  issibility matri
-00030110: 783a 0a20 2020 2020 2020 2069 6620 6164  x:.        if ad
-00030120: 6d69 7373 6962 6c65 5f6a 6f69 6e73 2069  missible_joins i
-00030130: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-00030140: 2020 2020 7072 696e 7428 2261 6c6c 206a      print("all j
-00030150: 6f69 6e73 2061 646d 6973 7369 626c 6522  oins admissible"
-00030160: 290a 2020 2020 2020 2020 2020 2020 6d61  ).            ma
-00030170: 794a 6f69 6e20 3d20 6e70 2e7a 6572 6f73  yJoin = np.zeros
-00030180: 2828 6e32 2c20 6e32 292c 2064 7479 7065  ((n2, n2), dtype
-00030190: 3d69 6e74 2920 2b20 310a 2020 2020 2020  =int) + 1.      
-000301a0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-000301b0: 2020 2020 7072 696e 7428 226f 6e6c 7920      print("only 
-000301c0: 736f 6d65 206a 6f69 6e73 2061 646d 6973  some joins admis
-000301d0: 7369 626c 6522 290a 2020 2020 2020 2020  sible").        
-000301e0: 2020 2020 6d61 794a 6f69 6e20 3d20 6e70      mayJoin = np
-000301f0: 2e7a 6572 6f73 2828 6e32 2c20 6e32 292c  .zeros((n2, n2),
-00030200: 2064 7479 7065 3d69 6e74 290a 2020 2020   dtype=int).    
-00030210: 2020 2020 2020 2020 6d61 794a 6f69 6e5b          mayJoin[
-00030220: 303a 6e2c 2030 3a6e 5d20 3d20 6164 6d69  0:n, 0:n] = admi
-00030230: 7373 6962 6c65 5f6a 6f69 6e73 0a20 2020  ssible_joins.   
-00030240: 2020 2020 2023 2063 6c75 7374 6572 206d       # cluster m
-00030250: 656d 6265 7273 6869 7020 696e 6469 6361  embership indica
-00030260: 746f 7273 3a0a 2020 2020 2020 2020 636c  tors:.        cl
-00030270: 7573 7465 724d 656d 6265 7273 203d 206e  usterMembers = n
-00030280: 702e 7a65 726f 7328 286e 322c 206e 292c  p.zeros((n2, n),
-00030290: 2064 7479 7065 3d69 6e74 290a 2020 2020   dtype=int).    
-000302a0: 2020 2020 636c 7573 7465 724d 656d 6265      clusterMembe
-000302b0: 7273 5b30 3a6e 2c20 303a 6e5d 203d 206e  rs[0:n, 0:n] = n
-000302c0: 702e 6964 656e 7469 7479 286e 290a 2020  p.identity(n).  
-000302d0: 2020 2020 2020 2320 636c 7573 7465 7220        # cluster 
-000302e0: 7765 6967 6874 733a 0a20 2020 2020 2020  weights:.       
-000302f0: 2063 6c75 7374 6572 5765 6967 6874 7320   clusterWeights 
-00030300: 3d20 6e70 2e7a 6572 6f73 286e 3229 0a20  = np.zeros(n2). 
-00030310: 2020 2020 2020 2063 6c75 7374 6572 5765         clusterWe
-00030320: 6967 6874 735b 303a 6e5d 203d 2077 0a20  ights[0:n] = w. 
-00030330: 2020 2020 2020 2023 2077 6569 6768 7420         # weight 
-00030340: 7072 6f64 7563 7473 3a0a 2020 2020 2020  products:.      
-00030350: 2020 7765 6967 6874 5072 6f64 7563 7473    weightProducts
-00030360: 203d 206e 702e 7a65 726f 7328 286e 322c   = np.zeros((n2,
-00030370: 206e 3229 290a 2020 2020 2020 2020 7765   n2)).        we
-00030380: 6967 6874 5072 6f64 7563 7473 5b30 3a6e  ightProducts[0:n
-00030390: 2c20 303a 6e5d 203d 206e 702e 646f 7428  , 0:n] = np.dot(
-000303a0: 772e 7265 7368 6170 6528 286e 2c20 3129  w.reshape((n, 1)
-000303b0: 292c 2077 2e72 6573 6861 7065 2828 312c  ), w.reshape((1,
-000303c0: 206e 2929 290a 2020 2020 2020 2020 2320   n))).        # 
-000303d0: 6c69 6e6b 6564 2077 6569 6768 7473 3a0a  linked weights:.
-000303e0: 2020 2020 2020 2020 412c 2041 706c 7573          A, Aplus
-000303f0: 203d 2073 656c 662e 6164 6a61 6365 6e63   = self.adjacenc
-00030400: 792c 2073 656c 662e 7370 5f41 706c 7573  y, self.sp_Aplus
-00030410: 2829 2e41 0a20 2020 2020 2020 206c 696e  ().A.        lin
-00030420: 6b65 6457 6569 6768 7473 203d 206e 702e  kedWeights = np.
-00030430: 7a65 726f 7328 286e 322c 206e 3229 290a  zeros((n2, n2)).
-00030440: 2020 2020 2020 2020 6c69 6e6b 6564 5765          linkedWe
-00030450: 6967 6874 735b 303a 6e2c 2030 3a6e 5d20  ights[0:n, 0:n] 
-00030460: 3d20 5c0a 2020 2020 2020 2020 2020 2020  = \.            
-00030470: 7365 6c66 2e6e 6f64 655f 7765 6967 6874  self.node_weight
-00030480: 732e 7265 7368 6170 6528 286e 2c20 3129  s.reshape((n, 1)
-00030490: 2920 2a20 4170 6c75 7320 2a20 5c0a 2020  ) * Aplus * \.  
-000304a0: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
-000304b0: 6f64 655f 7765 6967 6874 732e 7265 7368  ode_weights.resh
-000304c0: 6170 6528 2831 2c20 6e29 290a 2020 2020  ape((1, n)).    
-000304d0: 2020 2020 2320 6572 726f 7220 636f 6e74      # error cont
-000304e0: 7269 6275 7469 6f6e 7320 6f66 2063 6c75  ributions of clu
-000304f0: 7374 6572 2070 6169 7273 0a20 2020 2020  ster pairs.     
-00030500: 2020 2023 2028 7375 6d20 7570 2074 6f20     # (sum up to 
-00030510: 746f 7461 6c20 6572 726f 7220 3d20 322a  total error = 2*
-00030520: 4861 6d6d 696e 6720 6469 7374 616e 6365  Hamming distance
-00030530: 293a 0a20 2020 2020 2020 2065 7272 6f72  ):.        error
-00030540: 7320 3d20 6e70 2e7a 6572 6f73 2828 6e32  s = np.zeros((n2
-00030550: 2c20 6e32 2929 0a20 2020 2020 2020 2023  , n2)).        #
-00030560: 2064 6973 7461 6e63 6520 3d20 696e 6372   distance = incr
-00030570: 6561 7365 206f 6620 4861 6d6d 696e 6720  ease of Hamming 
-00030580: 6469 7374 616e 6365 3a0a 2020 2020 2020  distance:.      
-00030590: 2020 2320 616e 6420 6669 6e64 2066 6972    # and find fir
-000305a0: 7374 2070 6169 7220 746f 206a 6f69 6e3a  st pair to join:
-000305b0: 0a20 2020 2020 2020 2064 6973 7461 6e63  .        distanc
-000305c0: 6573 203d 206e 702e 7a65 726f 7328 286e  es = np.zeros((n
-000305d0: 322c 206e 3229 290a 0a20 2020 2020 2020  2, n2))..       
-000305e0: 2023 206c 6973 7420 6f66 2061 6374 6976   # list of activ
-000305f0: 6520 636c 7573 7465 7220 696e 6469 6365  e cluster indice
-00030600: 733a 0a20 2020 2020 2020 2061 6374 6976  s:.        activ
-00030610: 6549 6e64 6963 6573 203d 2072 616e 6765  eIndices = range
-00030620: 2830 2c20 6e29 0a0a 2020 2020 2020 2020  (0, n)..        
-00030630: 2320 6669 6e61 6c20 4861 6d6d 696e 6720  # final Hamming 
-00030640: 6469 7374 616e 6365 733a 0a20 2020 2020  distances:.     
-00030650: 2020 2068 616d 6d69 6e67 203d 206e 702e     hamming = np.
-00030660: 7a65 726f 7328 6e32 290a 0a20 2020 2020  zeros(n2)..     
-00030670: 2020 2023 206c 6973 7420 6f66 2070 6172     # list of par
-00030680: 656e 7473 2061 6e64 2073 6962 6c69 6e67  ents and sibling
-00030690: 733a 0a20 2020 2020 2020 2073 6962 6c69  s:.        sibli
-000306a0: 6e67 203d 206e 702e 7a65 726f 7328 6e32  ng = np.zeros(n2
-000306b0: 2d31 2c20 6474 7970 653d 696e 7429 0a20  -1, dtype=int). 
-000306c0: 2020 2020 2020 2070 6172 656e 7420 3d20         parent = 
-000306d0: 6e70 2e7a 6572 6f73 286e 322d 312c 2064  np.zeros(n2-1, d
-000306e0: 7479 7065 3d69 6e74 290a 0a20 2020 2020  type=int)..     
-000306f0: 2020 2023 206c 6973 7420 6f66 2070 6172     # list of par
-00030700: 7473 3a0a 2020 2020 2020 2020 7061 7274  ts:.        part
-00030710: 7320 3d20 6e70 2e7a 6572 6f73 2828 6e32  s = np.zeros((n2
-00030720: 2c20 3229 2c20 6474 7970 653d 696e 7429  , 2), dtype=int)
-00030730: 0a20 2020 2020 2020 2070 6172 7473 5b3a  .        parts[:
-00030740: 6e5d 203d 202d 310a 0a20 2020 2020 2020  n] = -1..       
-00030750: 206e 6f64 6532 636c 7573 7465 7220 3d20   node2cluster = 
-00030760: 6e70 2e7a 6572 6f73 2828 6e2c 206e 2b31  np.zeros((n, n+1
-00030770: 292c 2064 7479 7065 3d69 6e74 290a 2020  ), dtype=int).  
-00030780: 2020 2020 2020 6e6f 6465 3263 6c75 7374        node2clust
-00030790: 6572 5b3a 2c20 305d 203d 202d 310a 2020  er[:, 0] = -1.  
-000307a0: 2020 2020 2020 6e6f 6465 3263 6c75 7374        node2clust
-000307b0: 6572 5b3a 2c20 6e5d 203d 2072 616e 6765  er[:, n] = range
-000307c0: 286e 290a 2020 2020 2020 2020 636c 7573  (n).        clus
-000307d0: 7465 7232 7261 6e6b 203d 206e 702e 7a65  ter2rank = np.ze
-000307e0: 726f 7328 286e 322c 206e 2b31 292c 2064  ros((n2, n+1), d
-000307f0: 7479 7065 3d69 6e74 2920 2d20 310a 2020  type=int) - 1.  
-00030800: 2020 2020 2020 636c 7573 7465 7232 7261        cluster2ra
-00030810: 6e6b 5b30 2c20 315d 203d 2030 0a0a 2020  nk[0, 1] = 0..  
-00030820: 2020 2020 2020 6c61 7374 756e 6974 6564        lastunited
-00030830: 203d 2070 6172 7431 203d 2070 6172 7432   = part1 = part2
-00030840: 203d 202d 310a 0a20 2020 2020 2020 2023   = -1..        #
-00030850: 2069 7465 7261 7469 7665 6c79 206a 6f69   iteratively joi
-00030860: 6e20 7468 6f73 6520 7477 6f20 636c 7573  n those two clus
-00030870: 7465 7273 2077 6869 6368 2069 6e63 7265  ters which incre
-00030880: 6173 6520 4861 6d6d 696e 6720 6469 7374  ase Hamming dist
-00030890: 616e 6365 0a20 2020 2020 2020 2023 2074  ance.        # t
-000308a0: 6865 206c 6561 7374 3a0a 2020 2020 2020  he least:.      
-000308b0: 2020 666f 7220 756e 6974 6564 2069 6e20    for united in 
-000308c0: 7261 6e67 6528 6e2c 206e 3229 3a0a 0a20  range(n, n2):.. 
-000308d0: 2020 2020 2020 2020 2020 2023 2066 696e             # fin
-000308e0: 6420 6e65 7874 206f 7074 696d 616c 2070  d next optimal p
-000308f0: 6169 723a 0a0a 2020 2020 2020 2020 2020  air:..          
-00030900: 2020 6e41 6374 6976 6549 6e64 6963 6573    nActiveIndices
-00030910: 203d 206c 656e 2861 6374 6976 6549 6e64   = len(activeInd
-00030920: 6963 6573 290a 2020 2020 2020 2020 2020  ices).          
-00030930: 2020 7468 6541 6374 6976 6549 6e64 6963    theActiveIndic
-00030940: 6573 203d 206e 702e 736f 7274 2861 6374  es = np.sort(act
-00030950: 6976 6549 6e64 6963 6573 290a 2020 2020  iveIndices).    
-00030960: 2020 2020 2020 2020 6d69 6e64 3020 3d20          mind0 = 
-00030970: 666c 6f61 7428 6e70 2e70 6f77 6572 2831  float(np.power(1
-00030980: 2e30 2a73 656c 662e 746f 7461 6c5f 6e6f  .0*self.total_no
-00030990: 6465 5f77 6569 6768 742c 2033 2e30 2929  de_weight, 3.0))
-000309a0: 0a20 2020 2020 2020 2020 2020 206d 696e  .            min
-000309b0: 7770 3020 3d20 666c 6f61 7428 322e 302a  wp0 = float(2.0*
-000309c0: 7765 6967 6874 5072 6f64 7563 7473 2e6d  weightProducts.m
-000309d0: 6178 2829 290a 2020 2020 2020 2020 2020  ax()).          
-000309e0: 2020 7265 7375 6c74 203d 206e 702e 7a65    result = np.ze
-000309f0: 726f 7328 3329 0a0a 2020 2020 2020 2020  ros(3)..        
-00030a00: 2020 2020 7265 7375 6c74 7320 3d20 5f64      results = _d
-00030a10: 6f5f 6e73 695f 6861 6d6d 696e 675f 636c  o_nsi_hamming_cl
-00030a20: 7573 7465 7269 6e67 280a 2020 2020 2020  ustering(.      
-00030a30: 2020 2020 2020 2020 2020 6e32 2c20 6e41            n2, nA
-00030a40: 6374 6976 6549 6e64 6963 6573 2c20 6d69  ctiveIndices, mi
-00030a50: 6e64 302c 206d 696e 7770 302c 206c 6173  nd0, minwp0, las
-00030a60: 7475 6e69 7465 642c 2070 6172 7431 2c0a  tunited, part1,.
-00030a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030a80: 7061 7274 322c 2064 6973 7461 6e63 6573  part2, distances
-00030a90: 2e63 6f70 7928 6d6f 6465 3d27 6327 292c  .copy(mode='c'),
-00030aa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00030ab0: 2074 6865 4163 7469 7665 496e 6469 6365   theActiveIndice
-00030ac0: 732e 636f 7079 286d 6f64 653d 2763 2729  s.copy(mode='c')
-00030ad0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00030ae0: 2020 6c69 6e6b 6564 5765 6967 6874 732e    linkedWeights.
-00030af0: 636f 7079 286d 6f64 653d 2763 2729 2c0a  copy(mode='c'),.
-00030b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030b10: 7765 6967 6874 5072 6f64 7563 7473 2e63  weightProducts.c
-00030b20: 6f70 7928 6d6f 6465 3d27 6327 292c 0a20  opy(mode='c'),. 
-00030b30: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00030b40: 7272 6f72 732e 636f 7079 286d 6f64 653d  rrors.copy(mode=
-00030b50: 2763 2729 2c20 7265 7375 6c74 2e63 6f70  'c'), result.cop
-00030b60: 7928 6d6f 6465 3d27 6327 292c 0a20 2020  y(mode='c'),.   
-00030b70: 2020 2020 2020 2020 2020 2020 206d 6179               may
-00030b80: 4a6f 696e 2e63 6f70 7928 6d6f 6465 3d27  Join.copy(mode='
-00030b90: 6327 2929 0a0a 2020 2020 2020 2020 2020  c'))..          
-00030ba0: 2020 6d69 6e64 203d 2072 6573 756c 745b    mind = result[
-00030bb0: 305d 0a20 2020 2020 2020 2020 2020 2070  0].            p
-00030bc0: 6172 7431 203d 2069 6e74 2872 6573 756c  art1 = int(resul
-00030bd0: 745b 315d 290a 2020 2020 2020 2020 2020  t[1]).          
-00030be0: 2020 7061 7274 3220 3d20 696e 7428 7265    part2 = int(re
-00030bf0: 7375 6c74 5b32 5d29 0a20 2020 2020 2020  sult[2]).       
-00030c00: 2020 2020 2069 6620 6d69 6e64 203c 2030       if mind < 0
-00030c10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00030c20: 2020 7072 696e 7428 756e 6974 6564 2c20    print(united, 
-00030c30: 6d69 6e64 2c20 7061 7274 312c 2070 6172  mind, part1, par
-00030c40: 7432 290a 2020 2020 2020 2020 2020 2020  t2).            
-00030c50: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
-00030c60: 696f 6e0a 0a20 2020 2020 2020 2020 2020  ion..           
-00030c70: 2063 6c75 7374 6572 3272 616e 6b5b 6e70   cluster2rank[np
-00030c80: 2e61 7272 6179 2861 6374 6976 6549 6e64  .array(activeInd
-00030c90: 6963 6573 295b 0a20 2020 2020 2020 2020  ices)[.         
-00030ca0: 2020 2020 2020 2028 2d63 6c75 7374 6572         (-cluster
-00030cb0: 5765 6967 6874 735b 6163 7469 7665 496e  Weights[activeIn
-00030cc0: 6469 6365 735d 292e 6172 6773 6f72 7428  dices]).argsort(
-00030cd0: 295d 2c20 6e32 2b31 2d75 6e69 7465 645d  )], n2+1-united]
-00030ce0: 203d 205c 0a20 2020 2020 2020 2020 2020   = \.           
-00030cf0: 2020 2020 2072 616e 6765 286e 322b 312d       range(n2+1-
-00030d00: 756e 6974 6564 290a 0a20 2020 2020 2020  united)..       
-00030d10: 2020 2020 2068 616d 6d69 6e67 5b75 6e69       hamming[uni
-00030d20: 7465 645d 203d 2068 616d 6d69 6e67 5b75  ted] = hamming[u
-00030d30: 6e69 7465 642d 315d 202b 2032 2e30 202a  nited-1] + 2.0 *
-00030d40: 206d 696e 640a 0a20 2020 2020 2020 2020   mind..         
-00030d50: 2020 2069 6620 756e 6974 6564 203c 206e     if united < n
-00030d60: 202b 2031 3030 206f 7220 756e 6974 6564   + 100 or united
-00030d70: 2025 2028 3120 2b20 6e32 2f31 3030 2920   % (1 + n2/100) 
-00030d80: 3d3d 2030 206f 7220 5c0a 2020 2020 2020  == 0 or \.      
-00030d90: 2020 2020 2020 2020 2020 2020 2020 756e                un
-00030da0: 6974 6564 203e 3d20 6e32 202d 2031 3030  ited >= n2 - 100
-00030db0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00030dc0: 2020 7072 696e 7428 6622 666f 7220 7b6e    print(f"for {n
-00030dd0: 322d 756e 6974 6564 7d20 636c 7573 7465  2-united} cluste
-00030de0: 7273 2077 6974 6820 6572 726f 7220 220a  rs with error ".
-00030df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030e00: 2020 2020 2020 6622 7b68 616d 6d69 6e67        f"{hamming
-00030e10: 5b75 6e69 7465 645d 2f57 577d 2077 6520  [united]/WW} we 
-00030e20: 6a6f 696e 2063 6c75 7374 6572 7320 220a  join clusters ".
-00030e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00030e40: 2020 2020 2020 6622 7b70 6172 7431 7d20        f"{part1} 
-00030e50: 616e 6420 7b70 6172 7432 7d20 746f 2067  and {part2} to g
-00030e60: 6574 2063 6c75 7374 6572 207b 756e 6974  et cluster {unit
-00030e70: 6564 7d22 290a 2020 2020 2020 2020 2020  ed}").          
-00030e80: 2020 2020 2020 7379 732e 7374 646f 7574        sys.stdout
-00030e90: 2e66 6c75 7368 2829 0a0a 2020 2020 2020  .flush()..      
-00030ea0: 2020 2020 2020 2320 756e 6974 6520 7061        # unite pa
-00030eb0: 7274 733a 0a0a 2020 2020 2020 2020 2020  rts:..          
-00030ec0: 2020 7061 7265 6e74 5b70 6172 7431 5d20    parent[part1] 
-00030ed0: 3d20 7061 7265 6e74 5b70 6172 7432 5d20  = parent[part2] 
-00030ee0: 3d20 756e 6974 6564 0a20 2020 2020 2020  = united.       
-00030ef0: 2020 2020 2070 6172 7473 5b75 6e69 7465       parts[unite
-00030f00: 642c 2030 5d20 3d20 7369 626c 696e 675b  d, 0] = sibling[
-00030f10: 7061 7274 325d 203d 2070 6172 7431 0a20  part2] = part1. 
-00030f20: 2020 2020 2020 2020 2020 2070 6172 7473             parts
-00030f30: 5b75 6e69 7465 642c 2031 5d20 3d20 7369  [united, 1] = si
-00030f40: 626c 696e 675b 7061 7274 315d 203d 2070  bling[part1] = p
-00030f50: 6172 7432 0a20 2020 2020 2020 2020 2020  art2.           
-00030f60: 2063 6c75 7374 6572 4d65 6d62 6572 735b   clusterMembers[
-00030f70: 756e 6974 6564 2c20 3a5d 203d 205c 0a20  united, :] = \. 
-00030f80: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00030f90: 6c75 7374 6572 4d65 6d62 6572 735b 7061  lusterMembers[pa
-00030fa0: 7274 312c 203a 5d20 2b20 636c 7573 7465  rt1, :] + cluste
-00030fb0: 724d 656d 6265 7273 5b70 6172 7432 2c20  rMembers[part2, 
-00030fc0: 3a5d 0a20 2020 2020 2020 2020 2020 206e  :].            n
-00030fd0: 6f64 6532 636c 7573 7465 725b 3a2c 206e  ode2cluster[:, n
-00030fe0: 322d 756e 6974 6564 5d20 3d20 5c0a 2020  2-united] = \.  
-00030ff0: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
-00031000: 6465 3263 6c75 7374 6572 5b3a 2c20 312b  de2cluster[:, 1+
-00031010: 6e32 2d75 6e69 7465 645d 202a 2028 312d  n2-united] * (1-
-00031020: 636c 7573 7465 724d 656d 6265 7273 5b75  clusterMembers[u
-00031030: 6e69 7465 642c 203a 5d29 202b 5c0a 2020  nited, :]) +\.  
-00031040: 2020 2020 2020 2020 2020 2020 2020 756e                un
-00031050: 6974 6564 2a63 6c75 7374 6572 4d65 6d62  ited*clusterMemb
-00031060: 6572 735b 756e 6974 6564 2c20 3a5d 0a20  ers[united, :]. 
-00031070: 2020 2020 2020 2020 2020 2061 6374 6976             activ
-00031080: 6549 6e64 6963 6573 2e72 656d 6f76 6528  eIndices.remove(
-00031090: 7061 7274 3129 0a20 2020 2020 2020 2020  part1).         
-000310a0: 2020 2061 6374 6976 6549 6e64 6963 6573     activeIndices
-000310b0: 2e72 656d 6f76 6528 7061 7274 3229 0a20  .remove(part2). 
-000310c0: 2020 2020 2020 2020 2020 2061 6374 6976             activ
-000310d0: 6549 6e64 6963 6573 2e61 7070 656e 6428  eIndices.append(
-000310e0: 756e 6974 6564 290a 0a20 2020 2020 2020  united)..       
-000310f0: 2020 2020 2023 2063 6f6d 7075 7465 206e       # compute n
-00031100: 6577 2065 6e74 7269 6573 2069 6e20 636c  ew entries in cl
-00031110: 7573 7465 7257 6569 6768 7473 2c20 7765  usterWeights, we
-00031120: 6967 6874 5072 6f64 7563 7473 2c0a 2020  ightProducts,.  
-00031130: 2020 2020 2020 2020 2020 2320 6c69 6e6b            # link
-00031140: 6564 5765 6967 6874 732c 2065 7272 6f72  edWeights, error
-00031150: 732c 206d 6179 4a6f 696e 3a0a 2020 2020  s, mayJoin:.    
-00031160: 2020 2020 2020 2020 636c 7573 7465 7257          clusterW
-00031170: 6569 6768 7473 5b75 6e69 7465 645d 203d  eights[united] =
-00031180: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-00031190: 2020 2063 6c75 7374 6572 5765 6967 6874     clusterWeight
-000311a0: 735b 7061 7274 315d 202b 2063 6c75 7374  s[part1] + clust
-000311b0: 6572 5765 6967 6874 735b 7061 7274 325d  erWeights[part2]
-000311c0: 0a20 2020 2020 2020 2020 2020 2077 6569  .            wei
-000311d0: 6768 7450 726f 6475 6374 735b 756e 6974  ghtProducts[unit
-000311e0: 6564 2c20 303a 756e 6974 6564 5d20 3d20  ed, 0:united] = 
-000311f0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-00031200: 2020 7765 6967 6874 5072 6f64 7563 7473    weightProducts
-00031210: 5b70 6172 7431 2c20 303a 756e 6974 6564  [part1, 0:united
-00031220: 5d20 2b20 5c0a 2020 2020 2020 2020 2020  ] + \.          
-00031230: 2020 2020 2020 7765 6967 6874 5072 6f64        weightProd
-00031240: 7563 7473 5b70 6172 7432 2c20 303a 756e  ucts[part2, 0:un
-00031250: 6974 6564 5d0a 2020 2020 2020 2020 2020  ited].          
-00031260: 2020 7765 6967 6874 5072 6f64 7563 7473    weightProducts
-00031270: 5b30 3a75 6e69 7465 642c 2075 6e69 7465  [0:united, unite
-00031280: 645d 203d 205c 0a20 2020 2020 2020 2020  d] = \.         
-00031290: 2020 2020 2020 2077 6569 6768 7450 726f         weightPro
-000312a0: 6475 6374 735b 756e 6974 6564 2c20 303a  ducts[united, 0:
-000312b0: 756e 6974 6564 5d2e 666c 6174 7465 6e28  united].flatten(
-000312c0: 290a 2020 2020 2020 2020 2020 2020 7765  ).            we
-000312d0: 6967 6874 5072 6f64 7563 7473 5b75 6e69  ightProducts[uni
-000312e0: 7465 642c 2075 6e69 7465 645d 203d 205c  ted, united] = \
-000312f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00031300: 206e 702e 706f 7765 7228 636c 7573 7465   np.power(cluste
-00031310: 7257 6569 6768 7473 5b75 6e69 7465 645d  rWeights[united]
-00031320: 2c20 322e 3029 0a20 2020 2020 2020 2020  , 2.0).         
-00031330: 2020 206c 696e 6b65 6457 6569 6768 7473     linkedWeights
-00031340: 5b75 6e69 7465 642c 2030 3a75 6e69 7465  [united, 0:unite
-00031350: 645d 203d 205c 0a20 2020 2020 2020 2020  d] = \.         
-00031360: 2020 2020 2020 206c 696e 6b65 6457 6569         linkedWei
-00031370: 6768 7473 5b70 6172 7431 2c20 303a 756e  ghts[part1, 0:un
-00031380: 6974 6564 5d20 2b20 6c69 6e6b 6564 5765  ited] + linkedWe
-00031390: 6967 6874 735b 7061 7274 322c 2030 3a75  ights[part2, 0:u
-000313a0: 6e69 7465 645d 0a20 2020 2020 2020 2020  nited].         
-000313b0: 2020 206c 696e 6b65 6457 6569 6768 7473     linkedWeights
-000313c0: 5b30 3a75 6e69 7465 642c 2075 6e69 7465  [0:united, unite
-000313d0: 645d 203d 205c 0a20 2020 2020 2020 2020  d] = \.         
-000313e0: 2020 2020 2020 206c 696e 6b65 6457 6569         linkedWei
-000313f0: 6768 7473 5b75 6e69 7465 642c 2030 3a75  ghts[united, 0:u
-00031400: 6e69 7465 645d 2e66 6c61 7474 656e 2829  nited].flatten()
-00031410: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
-00031420: 6b65 6457 6569 6768 7473 5b75 6e69 7465  kedWeights[unite
-00031430: 642c 2075 6e69 7465 645d 203d 205c 0a20  d, united] = \. 
-00031440: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00031450: 696e 6b65 6457 6569 6768 7473 5b70 6172  inkedWeights[par
-00031460: 7431 2c20 7061 7274 315d 202b 206c 696e  t1, part1] + lin
-00031470: 6b65 6457 6569 6768 7473 5b70 6172 7432  kedWeights[part2
-00031480: 2c20 7061 7274 325d 202b 205c 0a20 2020  , part2] + \.   
-00031490: 2020 2020 2020 2020 2020 2020 2032 2e30               2.0
-000314a0: 202a 206c 696e 6b65 6457 6569 6768 7473   * linkedWeights
-000314b0: 5b70 6172 7431 2c20 7061 7274 325d 0a20  [part1, part2]. 
-000314c0: 2020 2020 2020 2020 2020 206d 6179 4a6f             mayJo
-000314d0: 696e 5b75 6e69 7465 642c 2030 3a75 6e69  in[united, 0:uni
-000314e0: 7465 645d 203d 205c 0a20 2020 2020 2020  ted] = \.       
-000314f0: 2020 2020 2020 2020 206d 6179 4a6f 696e           mayJoin
-00031500: 5b70 6172 7431 2c20 303a 756e 6974 6564  [part1, 0:united
-00031510: 5d20 2b20 6d61 794a 6f69 6e5b 7061 7274  ] + mayJoin[part
-00031520: 322c 2030 3a75 6e69 7465 645d 0a20 2020  2, 0:united].   
-00031530: 2020 2020 2020 2020 206d 6179 4a6f 696e           mayJoin
-00031540: 5b30 3a75 6e69 7465 642c 2075 6e69 7465  [0:united, unite
-00031550: 645d 203d 206d 6179 4a6f 696e 5b75 6e69  d] = mayJoin[uni
-00031560: 7465 642c 2030 3a75 6e69 7465 645d 2e66  ted, 0:united].f
-00031570: 6c61 7474 656e 2829 0a20 2020 2020 2020  latten().       
-00031580: 2020 2020 2066 6f72 2063 2069 6e20 7261       for c in ra
-00031590: 6e67 6528 302c 2075 6e69 7465 6429 3a0a  nge(0, united):.
-000315a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000315b0: 6c77 203d 206c 696e 6b65 6457 6569 6768  lw = linkedWeigh
-000315c0: 7473 5b75 6e69 7465 642c 2063 5d0a 2020  ts[united, c].  
-000315d0: 2020 2020 2020 2020 2020 2020 2020 6572                er
-000315e0: 726f 7273 5b75 6e69 7465 642c 2063 5d20  rors[united, c] 
-000315f0: 3d20 6572 726f 7273 5b63 2c20 756e 6974  = errors[c, unit
-00031600: 6564 5d20 3d20 5c0a 2020 2020 2020 2020  ed] = \.        
-00031610: 2020 2020 2020 2020 2020 2020 6d69 6e28              min(
-00031620: 6c77 2c20 7765 6967 6874 5072 6f64 7563  lw, weightProduc
-00031630: 7473 5b75 6e69 7465 642c 2063 5d20 2d20  ts[united, c] - 
-00031640: 6c77 290a 2020 2020 2020 2020 2020 2020  lw).            
-00031650: 6572 726f 7273 5b75 6e69 7465 642c 2075  errors[united, u
-00031660: 6e69 7465 645d 203d 205c 0a20 2020 2020  nited] = \.     
-00031670: 2020 2020 2020 2020 2020 2077 6569 6768             weigh
-00031680: 7450 726f 6475 6374 735b 756e 6974 6564  tProducts[united
-00031690: 2c20 756e 6974 6564 5d20 2d20 6c69 6e6b  , united] - link
-000316a0: 6564 5765 6967 6874 735b 756e 6974 6564  edWeights[united
-000316b0: 2c20 756e 6974 6564 5d0a 2020 2020 2020  , united].      
-000316c0: 2020 2020 2020 6966 2065 7272 6f72 732e        if errors.
-000316d0: 6d69 6e28 2920 3c20 2d31 652d 3130 3a0a  min() < -1e-10:.
-000316e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000316f0: 7072 696e 7428 6572 726f 7273 290a 2020  print(errors).  
-00031700: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00031710: 6973 6520 4578 6365 7074 696f 6e0a 2020  ise Exception.  
-00031720: 2020 2020 2020 2020 2020 6c61 7374 756e            lastun
-00031730: 6974 6564 203d 2075 6e69 7465 640a 0a20  ited = united.. 
-00031740: 2020 2020 2020 2070 7269 6e74 2874 696d         print(tim
-00031750: 652e 7469 6d65 2829 2d74 302c 2022 7365  e.time()-t0, "se
-00031760: 636f 6e64 7322 290a 0a20 2020 2020 2020  conds")..       
-00031770: 2023 206e 6f64 6532 636c 7573 7465 7220   # node2cluster 
-00031780: 3d20 6e70 2e61 7272 6179 2872 616e 6765  = np.array(range
-00031790: 2830 2c20 6e32 2929 2e72 6573 6861 7065  (0, n2)).reshape
-000317a0: 2828 6e32 2c20 3129 292a 636c 7573 7465  ((n2, 1))*cluste
-000317b0: 724d 656d 6265 7273 0a0a 2020 2020 2020  rMembers..      
-000317c0: 2020 6e6f 6465 5f69 6e5f 636c 7573 7465    node_in_cluste
-000317d0: 7220 3d20 636c 7573 7465 724d 656d 6265  r = clusterMembe
-000317e0: 7273 2e54 2e61 7374 7970 6528 696e 7429  rs.T.astype(int)
-000317f0: 0a20 2020 2020 2020 2065 7272 6f72 203d  .        error =
-00031800: 206e 702e 7a65 726f 7328 6e2b 3129 0a20   np.zeros(n+1). 
-00031810: 2020 2020 2020 2065 7272 6f72 5b30 5d20         error[0] 
-00031820: 3d20 6e70 2e69 6e66 0a20 2020 2020 2020  = np.inf.       
-00031830: 2065 7272 6f72 5b2d 312d 6e70 2e61 7261   error[-1-np.ara
-00031840: 6e67 6528 6e29 5d20 3d20 6861 6d6d 696e  nge(n)] = hammin
-00031850: 675b 2d6e 3a5d 202f 2057 570a 0a20 2020  g[-n:] / WW..   
-00031860: 2020 2020 2069 6620 7472 6565 5f64 6f74       if tree_dot
-00031870: 6669 6c65 2069 7320 6e6f 7420 4e6f 6e65  file is not None
-00031880: 3a0a 2020 2020 2020 2020 2020 2020 6564  :.            ed
-00031890: 6765 7320 3d20 5b28 696e 7428 6929 2c20  ges = [(int(i), 
-000318a0: 696e 7428 7061 7265 6e74 5b69 5d29 2920  int(parent[i])) 
-000318b0: 666f 7220 6920 696e 2072 616e 6765 286e  for i in range(n
-000318c0: 322d 3129 5d0a 2020 2020 2020 2020 2020  2-1)].          
-000318d0: 2020 6d69 6e6c 656e 203d 205b 696e 7428    minlen = [int(
-000318e0: 7061 7265 6e74 5b69 5d2d 6d61 7828 692c  parent[i]-max(i,
-000318f0: 206e 2d31 2929 2066 6f72 2069 2069 6e20   n-1)) for i in 
-00031900: 7261 6e67 6528 6e32 2d31 295d 0a20 2020  range(n2-1)].   
-00031910: 2020 2020 2020 2020 2074 7265 6520 3d20           tree = 
-00031920: 6967 7261 7068 2e47 7261 7068 2865 6467  igraph.Graph(edg
-00031930: 6573 2c20 6469 7265 6374 6564 3d54 7275  es, directed=Tru
-00031940: 6529 0a20 2020 2020 2020 2020 2020 2074  e).            t
-00031950: 7265 652e 6573 2e73 6574 5f61 7474 7269  ree.es.set_attri
-00031960: 6275 7465 5f76 616c 7565 7328 226d 696e  bute_values("min
-00031970: 6c65 6e22 2c20 6d69 6e6c 656e 290a 2020  len", minlen).  
-00031980: 2020 2020 2020 2020 2020 7472 6565 5b22            tree["
-00031990: 7261 6e6b 6469 7222 5d20 3d20 224c 5222  rankdir"] = "LR"
-000319a0: 0a20 2020 2020 2020 2020 2020 2074 7265  .            tre
-000319b0: 652e 7772 6974 655f 646f 7428 7472 6565  e.write_dot(tree
-000319c0: 5f64 6f74 6669 6c65 290a 2020 2020 2020  _dotfile).      
-000319d0: 2020 2020 2020 6465 6c20 7472 6565 0a0a        del tree..
-000319e0: 2020 2020 2020 2020 7265 7475 726e 207b          return {
-000319f0: 0a20 2020 2020 2020 2020 2020 2022 6e6f  .            "no
-00031a00: 6465 3263 6c75 7374 6572 223a 206e 6f64  de2cluster": nod
-00031a10: 6532 636c 7573 7465 722c 2022 636c 7573  e2cluster, "clus
-00031a20: 7465 7232 7261 6e6b 223a 2063 6c75 7374  ter2rank": clust
-00031a30: 6572 3272 616e 6b2c 0a20 2020 2020 2020  er2rank,.       
-00031a40: 2020 2020 2022 636c 7573 7465 725f 7765       "cluster_we
-00031a50: 6967 6874 223a 2063 6c75 7374 6572 5765  ight": clusterWe
-00031a60: 6967 6874 732c 0a20 2020 2020 2020 2020  ights,.         
-00031a70: 2020 2022 6e6f 6465 5f69 6e5f 636c 7573     "node_in_clus
-00031a80: 7465 7222 3a20 6e6f 6465 5f69 6e5f 636c  ter": node_in_cl
-00031a90: 7573 7465 722c 2022 6572 726f 7222 3a20  uster, "error": 
-00031aa0: 6572 726f 722c 0a20 2020 2020 2020 2020  error,.         
-00031ab0: 2020 2022 6368 696c 6472 656e 223a 2070     "children": p
-00031ac0: 6172 7473 2c20 2273 6962 6c69 6e67 223a  arts, "sibling":
-00031ad0: 2073 6962 6c69 6e67 2c20 2270 6172 656e   sibling, "paren
-00031ae0: 7422 3a20 7061 7265 6e74 0a20 2020 2020  t": parent.     
-00031af0: 2020 207d 0a                                }.
+00025fb0: 7375 626e 6574 203d 204e 6574 776f 726b  subnet = Network
+00025fc0: 2861 646a 6163 656e 6379 3d41 2c20 6469  (adjacency=A, di
+00025fd0: 7265 6374 6564 3d46 616c 7365 2c20 6e6f  rected=False, no
+00025fe0: 6465 5f77 6569 6768 7473 3d77 290a 2020  de_weights=w).  
+00025ff0: 2020 2020 2020 2020 2020 2020 2020 4e20                N 
+00026000: 3d20 7375 626e 6574 2e4e 0a0a 2020 2020  = subnet.N..    
+00026010: 2020 2020 2020 2020 2020 2020 2320 2049              #  I
+00026020: 6e69 7469 616c 697a 6520 7468 6520 5257  nitialize the RW
+00026030: 4220 6172 7261 790a 2020 2020 2020 2020  B array.        
+00026040: 2020 2020 2020 2020 636f 6d70 6f6e 656e          componen
+00026050: 745f 6265 7477 6565 6e6e 6573 7320 3d20  t_betweenness = 
+00026060: 6e70 2e7a 6572 6f73 284e 290a 0a20 2020  np.zeros(N)..   
+00026070: 2020 2020 2020 2020 2020 2020 2023 2073               # s
+00026080: 705f 4d20 3d20 6172 6561 2d77 6569 6768  p_M = area-weigh
+00026090: 7465 6420 4b69 7263 6868 6f66 6620 6d61  ted Kirchhoff ma
+000260a0: 7472 6978 202a 2064 6961 6728 7729 5e28  trix * diag(w)^(
+000260b0: 2d31 290a 2020 2020 2020 2020 2020 2020  -1).            
+000260c0: 2020 2020 4170 203d 2073 7562 6e65 742e      Ap = subnet.
+000260d0: 7370 5f41 706c 7573 2829 0a20 2020 2020  sp_Aplus().     
+000260e0: 2020 2020 2020 2020 2020 2044 772c 2044             Dw, D
+000260f0: 7749 203d 2073 7562 6e65 742e 7370 5f64  wI = subnet.sp_d
+00026100: 6961 675f 7728 292c 2073 7562 6e65 742e  iag_w(), subnet.
+00026110: 7370 5f64 6961 675f 775f 696e 7628 290a  sp_diag_w_inv().
+00026120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026130: 446b 2c20 446b 4920 3d20 7375 626e 6574  Dk, DkI = subnet
+00026140: 2e73 705f 6e73 695f 6469 6167 5f6b 2829  .sp_nsi_diag_k()
+00026150: 2c20 7375 626e 6574 2e73 705f 6e73 695f  , subnet.sp_nsi_
+00026160: 6469 6167 5f6b 5f69 6e76 2829 0a20 2020  diag_k_inv().   
+00026170: 2020 2020 2020 2020 2020 2020 2073 705f               sp_
+00026180: 4d20 3d20 4477 202a 2028 446b 202d 2041  M = Dw * (Dk - A
+00026190: 7020 2a20 4477 2920 2a20 4477 490a 0a20  p * Dw) * DwI.. 
+000261a0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000261b0: 2069 6e76 6572 7420 7370 5f4d 2077 6974   invert sp_M wit
+000261c0: 686f 7574 206c 6173 7420 726f 772f 636f  hout last row/co
+000261d0: 6c20 2873 6565 2061 626f 7665 290a 2020  l (see above).  
+000261e0: 2020 2020 2020 2020 2020 2020 2020 7370                sp
+000261f0: 5f4d 5f69 6e76 203d 2073 702e 6c69 6c5f  _M_inv = sp.lil_
+00026200: 6d61 7472 6978 2828 4e2c 204e 2929 0a20  matrix((N, N)). 
+00026210: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00026220: 705f 4d5f 696e 765b 3a2d 312c 203a 2d31  p_M_inv[:-1, :-1
+00026230: 5d20 3d20 696e 7628 7370 5f4d 5b3a 2d31  ] = inv(sp_M[:-1
+00026240: 2c20 3a2d 315d 290a 0a20 2020 2020 2020  , :-1])..       
+00026250: 2020 2020 2020 2020 2023 204e 6f74 653a           # Note:
+00026260: 2073 705f 4d5f 696e 7620 6973 206e 6f74   sp_M_inv is not
+00026270: 206e 6563 6573 7361 7269 6c79 2073 7061   necessarily spa
+00026280: 7273 652c 2073 6f20 7468 6520 6f72 6465  rse, so the orde
+00026290: 7220 6973 0a20 2020 2020 2020 2020 2020  r is.           
+000262a0: 2020 2020 2023 2069 6d70 6f72 7461 6e74       # important
+000262b0: 2066 6f72 2070 6572 666f 726d 616e 6365   for performance
+000262c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000262d0: 2056 203d 2028 2844 6b49 202a 2041 7029   V = ((DkI * Ap)
+000262e0: 202a 2073 705f 4d5f 696e 7629 2e54 2e61   * sp_M_inv).T.a
+000262f0: 7374 7970 6528 4446 4945 4c44 292e 410a  stype(DFIELD).A.
+00026300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026310: 6465 6c20 7375 6267 7261 7068 2c20 4170  del subgraph, Ap
+00026320: 2c20 4477 2c20 4477 492c 2044 6b2c 2044  , Dw, DwI, Dk, D
+00026330: 6b49 2c20 7370 5f4d 2c20 7370 5f4d 5f69  kI, sp_M, sp_M_i
+00026340: 6e76 0a0a 2020 2020 2020 2020 2020 2020  nv..            
+00026350: 2020 2020 2320 544f 444f 3a20 7665 7269      # TODO: veri
+00026360: 6679 2074 6861 7420 7468 6973 2077 6173  fy that this was
+00026370: 2069 6e64 6565 6420 7772 6f6e 670a 2020   indeed wrong.  
+00026380: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00026390: 7720 3d20 7365 6c66 2e6e 6f64 655f 7765  w = self.node_we
+000263a0: 6967 6874 730a 0a20 2020 2020 2020 2020  ights..         
+000263b0: 2020 2020 2020 2023 2069 6e64 6963 6174         # indicat
+000263c0: 6f72 206d 6174 7269 7820 7468 6174 2069  or matrix that i
+000263d0: 2c6a 2061 7265 206e 6f74 206e 6569 6768  ,j are not neigh
+000263e0: 626f 7572 6564 206f 7220 6571 7561 6c0a  boured or equal.
+000263f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026400: 6e6f 745f 6164 6a61 6365 6e74 5f6f 725f  not_adjacent_or_
+00026410: 6571 7561 6c20 3d20 2831 202d 2041 202d  equal = (1 - A -
+00026420: 206e 702e 6964 656e 7469 7479 284e 2929   np.identity(N))
+00026430: 2e61 7374 7970 6528 4d41 534b 290a 0a20  .astype(MASK).. 
+00026440: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00026450: 6620 6d70 692e 6176 6169 6c61 626c 653a  f mpi.available:
+00026460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00026470: 2020 2020 2070 6172 7473 203d 206d 6178       parts = max
+00026480: 2831 2c20 696e 7428 6e70 2e63 6569 6c28  (1, int(np.ceil(
+00026490: 6d69 6e28 286d 7069 2e73 697a 652d 3129  min((mpi.size-1)
+000264a0: 202a 2031 302e 302c 0a20 2020 2020 2020   * 10.0,.       
+000264b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000264c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000264d0: 2020 2020 2020 2020 2020 2020 302e 3120              0.1 
+000264e0: 2a20 4e29 2929 290a 2020 2020 2020 2020  * N)))).        
+000264f0: 2020 2020 2020 2020 2020 2020 7374 6570              step
+00026500: 203d 2069 6e74 286e 702e 6365 696c 2831   = int(np.ceil(1
+00026510: 2e30 2a4e 2f28 312e 302a 7061 7274 7329  .0*N/(1.0*parts)
+00026520: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00026530: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+00026540: 696c 656e 6365 5f6c 6576 656c 203c 3d20  ilence_level <= 
+00026550: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+00026560: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00026570: 2822 2020 2070 6172 616c 6c65 6c69 7a69  ("   parallelizi
+00026580: 6e67 206f 6e20 2220 2b20 7374 7228 286d  ng on " + str((m
+00026590: 7069 2e73 697a 652d 3129 290a 2020 2020  pi.size-1)).    
+000265a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000265b0: 2020 2020 2020 2020 2020 2b20 2220 736c            + " sl
+000265c0: 6176 6573 2069 6e74 6f20 2220 2b20 7374  aves into " + st
+000265d0: 7228 7061 7274 7329 202b 2022 2070 6172  r(parts) + " par
+000265e0: 7473 2077 6974 6820 220a 2020 2020 2020  ts with ".      
+000265f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026600: 2020 2020 2020 2020 2b20 7374 7228 7374          + str(st
+00026610: 6570 2920 2b20 2220 6e6f 6465 7320 6561  ep) + " nodes ea
+00026620: 6368 2e2e 2e22 290a 0a20 2020 2020 2020  ch...")..       
+00026630: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00026640: 2069 6478 2069 6e20 7261 6e67 6528 7061   idx in range(pa
+00026650: 7274 7329 3a0a 2020 2020 2020 2020 2020  rts):.          
+00026660: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00026670: 6172 745f 6920 3d20 6964 7820 2a20 7374  art_i = idx * st
+00026680: 6570 0a20 2020 2020 2020 2020 2020 2020  ep.             
+00026690: 2020 2020 2020 2020 2020 2065 6e64 5f69             end_i
+000266a0: 203d 206d 696e 2828 6964 782b 3129 2a73   = min((idx+1)*s
+000266b0: 7465 702c 204e 290a 2020 2020 2020 2020  tep, N).        
+000266c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000266d0: 6966 2073 7461 7274 5f69 203e 3d20 656e  if start_i >= en
+000266e0: 645f 693a 0a20 2020 2020 2020 2020 2020  d_i:.           
+000266f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026700: 2062 7265 616b 0a20 2020 2020 2020 2020   break.         
+00026710: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00026720: 6869 735f 4120 3d20 415b 7374 6172 745f  his_A = A[start_
+00026730: 693a 656e 645f 692c 203a 5d0a 2020 2020  i:end_i, :].    
+00026740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026750: 2020 2020 7468 6973 5f6e 6f74 5f61 646a      this_not_adj
+00026760: 6163 656e 745f 6f72 5f65 7175 616c 203d  acent_or_equal =
+00026770: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+00026780: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00026790: 6f74 5f61 646a 6163 656e 745f 6f72 5f65  ot_adjacent_or_e
+000267a0: 7175 616c 5b73 7461 7274 5f69 3a65 6e64  qual[start_i:end
+000267b0: 5f69 2c20 3a5d 0a0a 2020 2020 2020 2020  _i, :]..        
+000267c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000267d0: 6d70 692e 7375 626d 6974 5f63 616c 6c28  mpi.submit_call(
+000267e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000267f0: 2020 2020 2020 2020 2020 2020 2022 5f6d               "_m
+00026800: 7069 5f6e 7369 5f6e 6577 6d61 6e5f 6265  pi_nsi_newman_be
+00026810: 7477 6565 6e6e 6573 7322 2c0a 2020 2020  tweenness",.    
+00026820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026830: 2020 2020 2020 2020 2874 6f5f 6379 2874          (to_cy(t
+00026840: 6869 735f 412c 2041 444a 292c 2074 6f5f  his_A, ADJ), to_
+00026850: 6379 2856 2c20 4446 4945 4c44 292c 204e  cy(V, DFIELD), N
+00026860: 2c20 772c 0a20 2020 2020 2020 2020 2020  , w,.           
+00026870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026880: 2020 7468 6973 5f6e 6f74 5f61 646a 6163    this_not_adjac
+00026890: 656e 745f 6f72 5f65 7175 616c 2c20 7374  ent_or_equal, st
+000268a0: 6172 745f 692c 2065 6e64 5f69 292c 0a20  art_i, end_i),. 
+000268b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000268c0: 2020 2020 2020 2020 2020 206d 6f64 756c             modul
+000268d0: 653d 2270 7975 6e69 636f 726e 222c 2069  e="pyunicorn", i
+000268e0: 643d 6964 7829 0a0a 2020 2020 2020 2020  d=idx)..        
+000268f0: 2020 2020 2020 2020 2020 2020 2320 5265              # Re
+00026900: 7472 6965 7665 2072 6573 756c 7473 206f  trieve results o
+00026910: 6620 616c 6c20 7375 626d 6974 6564 206a  f all submited j
+00026920: 6f62 730a 2020 2020 2020 2020 2020 2020  obs.            
+00026930: 2020 2020 2020 2020 636f 6d70 6f6e 656e          componen
+00026940: 745f 6265 7477 6565 6e6e 6573 7320 3d20  t_betweenness = 
+00026950: 6e70 2e7a 6572 6f73 284e 290a 2020 2020  np.zeros(N).    
+00026960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026970: 666f 7220 6964 7820 696e 2072 616e 6765  for idx in range
+00026980: 2870 6172 7473 293a 0a20 2020 2020 2020  (parts):.       
+00026990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000269a0: 2074 6869 735f 6265 7477 6565 6e6e 6573   this_betweennes
+000269b0: 732c 2073 7461 7274 5f69 2c20 656e 645f  s, start_i, end_
+000269c0: 6920 3d20 6d70 692e 6765 745f 7265 7375  i = mpi.get_resu
+000269d0: 6c74 2869 6478 290a 2020 2020 2020 2020  lt(idx).        
+000269e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000269f0: 636f 6d70 6f6e 656e 745f 6265 7477 6565  component_betwee
+00026a00: 6e6e 6573 735b 7374 6172 745f 693a 656e  nness[start_i:en
+00026a10: 645f 695d 203d 2074 6869 735f 6265 7477  d_i] = this_betw
+00026a20: 6565 6e6e 6573 730a 0a20 2020 2020 2020  eenness..       
+00026a30: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00026a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026a50: 2020 2063 6f6d 706f 6e65 6e74 5f62 6574     component_bet
+00026a60: 7765 656e 6e65 7373 2c20 7374 6172 745f  weenness, start_
+00026a70: 692c 2065 6e64 5f69 203d 205c 0a20 2020  i, end_i = \.   
+00026a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026a90: 2020 2020 205f 6d70 695f 6e73 695f 6e65       _mpi_nsi_ne
+00026aa0: 776d 616e 5f62 6574 7765 656e 6e65 7373  wman_betweenness
+00026ab0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00026ac0: 2020 2020 2020 2020 2020 2020 2020 746f                to
+00026ad0: 5f63 7928 412c 2041 444a 292c 2074 6f5f  _cy(A, ADJ), to_
+00026ae0: 6379 2856 2c20 4446 4945 4c44 292c 204e  cy(V, DFIELD), N
+00026af0: 2c20 772c 0a20 2020 2020 2020 2020 2020  , w,.           
+00026b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026b10: 206e 6f74 5f61 646a 6163 656e 745f 6f72   not_adjacent_or
+00026b20: 5f65 7175 616c 2c20 302c 204e 290a 0a20  _equal, 0, N).. 
+00026b30: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00026b40: 2020 436f 7272 6563 7469 6f6e 2066 6f72    Correction for
+00026b50: 2074 6865 2066 6163 7420 7468 6174 2077   the fact that w
+00026b60: 6520 7573 6564 206f 6e6c 7920 732c 7420  e used only s,t 
+00026b70: 6e6f 740a 2020 2020 2020 2020 2020 2020  not.            
+00026b80: 2020 2020 2320 206e 6569 6768 626f 7572      #  neighbour
+00026b90: 6564 2074 6f20 690a 2020 2020 2020 2020  ed to i.        
+00026ba0: 2020 2020 2020 2020 6966 2061 6464 5f6c          if add_l
+00026bb0: 6f63 616c 5f65 6e64 733a 0a20 2020 2020  ocal_ends:.     
+00026bc0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00026bd0: 7369 5f6b 203d 2073 7562 6e65 742e 6e73  si_k = subnet.ns
+00026be0: 695f 6465 6772 6565 2829 0a20 2020 2020  i_degree().     
+00026bf0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00026c00: 6f6d 706f 6e65 6e74 5f62 6574 7765 656e  omponent_between
+00026c10: 6e65 7373 202b 3d20 2832 2e30 202a 2077  ness += (2.0 * w
+00026c20: 2e73 756d 2829 202d 206e 7369 5f6b 2920  .sum() - nsi_k) 
+00026c30: 2a20 6e73 695f 6b0a 0a20 2020 2020 2020  * nsi_k..       
+00026c40: 2020 2020 2020 2020 2023 2020 436f 7079           #  Copy
+00026c50: 2072 6573 756c 7473 2069 6e74 6f20 7261   results into ra
+00026c60: 6e64 6f6d 5761 6c6b 4265 7477 6565 6e6e  ndomWalkBetweenn
+00026c70: 6573 7341 7272 6179 2061 7420 7468 6520  essArray at the 
+00026c80: 636f 7272 6563 740a 2020 2020 2020 2020  correct.        
+00026c90: 2020 2020 2020 2020 2320 2070 6f73 6974          #  posit
+00026ca0: 696f 6e73 0a20 2020 2020 2020 2020 2020  ions.           
+00026cb0: 2020 2020 2066 6f72 206a 2c20 6e6f 6465       for j, node
+00026cc0: 2069 6e20 656e 756d 6572 6174 6528 6e6f   in enumerate(no
+00026cd0: 6465 7329 3a0a 2020 2020 2020 2020 2020  des):.          
+00026ce0: 2020 2020 2020 2020 2020 6e73 695f 6e65            nsi_ne
+00026cf0: 776d 616e 5f62 6574 7765 656e 6e65 7373  wman_betweenness
+00026d00: 5b6e 6f64 655d 203d 2063 6f6d 706f 6e65  [node] = compone
+00026d10: 6e74 5f62 6574 7765 656e 6e65 7373 5b6a  nt_betweenness[j
+00026d20: 5d0a 0a20 2020 2020 2020 2069 6620 7365  ]..        if se
+00026d30: 6c66 2e73 696c 656e 6365 5f6c 6576 656c  lf.silence_level
+00026d40: 203c 3d20 303a 0a20 2020 2020 2020 2020   <= 0:.         
+00026d50: 2020 2070 7269 6e74 2822 2e2e 2e74 6f6f     print("...too
+00026d60: 6b22 2c20 7469 6d65 2e74 696d 6528 292d  k", time.time()-
+00026d70: 7430 2c20 2273 6563 6f6e 6473 2229 0a0a  t0, "seconds")..
+00026d80: 2020 2020 2020 2020 7265 7475 726e 206e          return n
+00026d90: 7369 5f6e 6577 6d61 6e5f 6265 7477 6565  si_newman_betwee
+00026da0: 6e6e 6573 730a 0a20 2020 2023 0a20 2020  nness..    #.   
+00026db0: 2023 2020 4566 6669 6369 656e 6379 206d   #  Efficiency m
+00026dc0: 6561 7375 7265 730a 2020 2020 230a 0a20  easures.    #.. 
+00026dd0: 2020 2064 6566 2067 6c6f 6261 6c5f 6566     def global_ef
+00026de0: 6669 6369 656e 6379 2873 656c 662c 206c  ficiency(self, l
+00026df0: 696e 6b5f 6174 7472 6962 7574 653d 4e6f  ink_attribute=No
+00026e00: 6e65 293a 0a20 2020 2020 2020 2022 2222  ne):.        """
+00026e10: 0a20 2020 2020 2020 2052 6574 7572 6e20  .        Return 
+00026e20: 7468 6520 676c 6f62 616c 2028 7765 6967  the global (weig
+00026e30: 6874 6564 2920 6566 6669 6369 656e 6379  hted) efficiency
+00026e40: 2e20 2873 6565 205b 436f 7374 6132 3030  . (see [Costa200
+00026e50: 375d 5f29 0a0a 2020 2020 2020 2020 2a2a  7]_)..        **
+00026e60: 4578 616d 706c 653a 2a2a 0a0a 2020 2020  Example:**..    
+00026e70: 2020 2020 3e3e 3e20 7228 4e65 7477 6f72      >>> r(Networ
+00026e80: 6b2e 536d 616c 6c54 6573 744e 6574 776f  k.SmallTestNetwo
+00026e90: 726b 2829 2e67 6c6f 6261 6c5f 6566 6669  rk().global_effi
+00026ea0: 6369 656e 6379 2829 290a 2020 2020 2020  ciency()).      
+00026eb0: 2020 4361 6c63 756c 6174 696e 6720 616c    Calculating al
+00026ec0: 6c20 7368 6f72 7465 7374 2070 6174 6820  l shortest path 
+00026ed0: 6c65 6e67 7468 732e 2e2e 0a20 2020 2020  lengths....     
+00026ee0: 2020 2043 616c 6375 6c61 7469 6e67 2067     Calculating g
+00026ef0: 6c6f 6261 6c20 2877 6569 6768 7465 6429  lobal (weighted)
+00026f00: 2065 6666 6963 6965 6e63 792e 2e2e 0a20   efficiency.... 
+00026f10: 2020 2020 2020 2030 2e37 3131 310a 0a20         0.7111.. 
+00026f20: 2020 2020 2020 203a 6172 6720 7374 7220         :arg str 
+00026f30: 6c69 6e6b 5f61 7474 7269 6275 7465 3a20  link_attribute: 
+00026f40: 4f70 7469 6f6e 616c 206e 616d 6520 6f66  Optional name of
+00026f50: 2074 6865 206c 696e 6b20 6174 7472 6962   the link attrib
+00026f60: 7574 6520 746f 2062 6520 7573 6564 0a20  ute to be used. 
+00026f70: 2020 2020 2020 2020 2020 2061 7320 7468             as th
+00026f80: 6520 6c69 6e6b 7327 206c 656e 6774 682e  e links' length.
+00026f90: 2049 6620 4e6f 6e65 2c20 6c69 6e6b 7320   If None, links 
+00026fa0: 6861 7665 206c 656e 6774 6820 312e 2028  have length 1. (
+00026fb0: 4465 6661 756c 743a 204e 6f6e 6529 0a20  Default: None). 
+00026fc0: 2020 2020 2020 203a 7274 7970 653a 2066         :rtype: f
+00026fd0: 6c6f 6174 0a20 2020 2020 2020 2022 2222  loat.        """
+00026fe0: 0a20 2020 2020 2020 2069 6620 6c69 6e6b  .        if link
+00026ff0: 5f61 7474 7269 6275 7465 203d 3d20 2274  _attribute == "t
+00027000: 6f70 6f6c 6f67 6963 616c 223a 0a20 2020  opological":.   
+00027010: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+00027020: 5741 524e 494e 473a 206c 696e 6b5f 6174  WARNING: link_at
+00027030: 7472 6962 7574 653d 2774 6f70 6f6c 6f67  tribute='topolog
+00027040: 6963 616c 2720 6973 2064 6570 7265 6361  ical' is depreca
+00027050: 7465 642e 5c6e 220a 2020 2020 2020 2020  ted.\n".        
+00027060: 2020 2020 2020 2020 2020 2b20 2255 7365            + "Use
+00027070: 206c 696e 6b5f 6174 7472 6962 7574 653d   link_attribute=
+00027080: 4e6f 6e65 2069 6e73 7465 6164 2e22 290a  None instead.").
+00027090: 2020 2020 2020 2020 2020 2020 6c69 6e6b              link
+000270a0: 5f61 7474 7269 6275 7465 203d 204e 6f6e  _attribute = Non
+000270b0: 650a 0a20 2020 2020 2020 2070 6174 685f  e..        path_
+000270c0: 6c65 6e67 7468 7320 3d20 7365 6c66 2e70  lengths = self.p
+000270d0: 6174 685f 6c65 6e67 7468 7328 6c69 6e6b  ath_lengths(link
+000270e0: 5f61 7474 7269 6275 7465 290a 0a20 2020  _attribute)..   
+000270f0: 2020 2020 2069 6620 7365 6c66 2e73 696c       if self.sil
+00027100: 656e 6365 5f6c 6576 656c 203c 3d20 313a  ence_level <= 1:
+00027110: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+00027120: 6e74 2822 4361 6c63 756c 6174 696e 6720  nt("Calculating 
+00027130: 676c 6f62 616c 2028 7765 6967 6874 6564  global (weighted
+00027140: 2920 6566 6669 6369 656e 6379 2e2e 2e22  ) efficiency..."
+00027150: 290a 0a20 2020 2020 2020 2023 2020 5365  )..        #  Se
+00027160: 7420 7061 7468 206c 656e 6774 6873 206f  t path lengths o
+00027170: 6e20 6469 6167 6f6e 616c 2074 6f20 696e  n diagonal to in
+00027180: 6669 6e69 7479 2074 6f20 6176 6f69 6420  finity to avoid 
+00027190: 7375 6d6d 696e 6720 6f76 6572 2074 686f  summing over tho
+000271a0: 7365 0a20 2020 2020 2020 2023 2020 656e  se.        #  en
+000271b0: 7472 6965 7320 7768 656e 2063 616c 6375  tries when calcu
+000271c0: 6c61 7469 6e67 2065 6666 6963 6965 6e63  lating efficienc
+000271d0: 790a 2020 2020 2020 2020 6e70 2e66 696c  y.        np.fil
+000271e0: 6c5f 6469 6167 6f6e 616c 2870 6174 685f  l_diagonal(path_
+000271f0: 6c65 6e67 7468 732c 206e 702e 696e 6629  lengths, np.inf)
+00027200: 0a0a 2020 2020 2020 2020 2320 2043 616c  ..        #  Cal
+00027210: 6375 6c61 7465 2067 6c6f 6261 6c20 6566  culate global ef
+00027220: 6669 6369 656e 6379 0a20 2020 2020 2020  ficiency.       
+00027230: 2065 6666 6963 6965 6e63 7920 3d20 2831   efficiency = (1
+00027240: 2f66 6c6f 6174 2873 656c 662e 4e20 2a20  /float(self.N * 
+00027250: 2873 656c 662e 4e2d 3129 2920 2a20 2831  (self.N-1)) * (1
+00027260: 2f70 6174 685f 6c65 6e67 7468 7329 2e73  /path_lengths).s
+00027270: 756d 2829 290a 0a20 2020 2020 2020 2023  um())..        #
+00027280: 2020 5265 7374 6f72 6520 7061 7468 206c    Restore path l
+00027290: 656e 6774 6873 206f 6e20 6469 6167 6f6e  engths on diagon
+000272a0: 616c 2074 6f20 7a65 726f 0a20 2020 2020  al to zero.     
+000272b0: 2020 206e 702e 6669 6c6c 5f64 6961 676f     np.fill_diago
+000272c0: 6e61 6c28 7061 7468 5f6c 656e 6774 6873  nal(path_lengths
+000272d0: 2c20 3029 0a0a 2020 2020 2020 2020 7265  , 0)..        re
+000272e0: 7475 726e 2065 6666 6963 6965 6e63 790a  turn efficiency.
+000272f0: 0a20 2020 2040 4361 6368 6564 2e6d 6574  .    @Cached.met
+00027300: 686f 6428 6e61 6d65 3d22 6e2e 732e 692e  hod(name="n.s.i.
+00027310: 2067 6c6f 6261 6c20 6566 6669 6369 656e   global efficien
+00027320: 6379 222c 2061 7474 7273 3d28 225f 6d75  cy", attrs=("_mu
+00027330: 745f 6e77 222c 2929 0a20 2020 2064 6566  t_nw",)).    def
+00027340: 206e 7369 5f67 6c6f 6261 6c5f 6566 6669   nsi_global_effi
+00027350: 6369 656e 6379 2873 656c 6629 3a0a 2020  ciency(self):.  
+00027360: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00027370: 2020 5265 7475 726e 2074 6865 206e 2e73    Return the n.s
+00027380: 2e69 2e20 676c 6f62 616c 2065 6666 6963  .i. global effic
+00027390: 6965 6e63 792e 0a0a 2020 2020 2020 2020  iency...        
+000273a0: 2a2a 4578 616d 706c 653a 2a2a 0a0a 2020  **Example:**..  
+000273b0: 2020 2020 2020 3e3e 3e20 7228 4e65 7477        >>> r(Netw
+000273c0: 6f72 6b2e 536d 616c 6c54 6573 744e 6574  ork.SmallTestNet
+000273d0: 776f 726b 2829 2e6e 7369 5f67 6c6f 6261  work().nsi_globa
+000273e0: 6c5f 6566 6669 6369 656e 6379 2829 290a  l_efficiency()).
+000273f0: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00027400: 696e 6720 6e2e 732e 692e 2067 6c6f 6261  ing n.s.i. globa
+00027410: 6c20 6566 6669 6369 656e 6379 2e2e 2e0a  l efficiency....
+00027420: 2020 2020 2020 2020 4361 6c63 756c 6174          Calculat
+00027430: 696e 6720 616c 6c20 7368 6f72 7465 7374  ing all shortest
+00027440: 2070 6174 6820 6c65 6e67 7468 732e 2e2e   path lengths...
+00027450: 0a20 2020 2020 2020 2030 2e37 3431 350a  .        0.7415.
+00027460: 0a20 2020 2020 2020 203a 7274 7970 653a  .        :rtype:
+00027470: 2066 6c6f 6174 0a20 2020 2020 2020 2022   float.        "
+00027480: 2222 0a20 2020 2020 2020 2077 203d 2073  "".        w = s
+00027490: 656c 662e 6e6f 6465 5f77 6569 6768 7473  elf.node_weights
+000274a0: 0a20 2020 2020 2020 2023 2020 5365 7420  .        #  Set 
+000274b0: 7061 7468 206c 656e 6774 6873 206f 6e20  path lengths on 
+000274c0: 6469 6167 6f6e 616c 2074 6f20 310a 2020  diagonal to 1.  
+000274d0: 2020 2020 2020 6e73 695f 6469 7374 203d        nsi_dist =
+000274e0: 2073 656c 662e 7061 7468 5f6c 656e 6774   self.path_lengt
+000274f0: 6873 2829 202b 206e 702e 6964 656e 7469  hs() + np.identi
+00027500: 7479 2873 656c 662e 4e29 0a20 2020 2020  ty(self.N).     
+00027510: 2020 2072 6574 7572 6e20 772e 646f 7428     return w.dot(
+00027520: 2831 2f6e 7369 5f64 6973 7429 2e64 6f74  (1/nsi_dist).dot
+00027530: 2877 2929 202f 2073 656c 662e 746f 7461  (w)) / self.tota
+00027540: 6c5f 6e6f 6465 5f77 6569 6768 742a 2a32  l_node_weight**2
+00027550: 0a0a 2020 2020 6465 6620 6469 7374 616e  ..    def distan
+00027560: 6365 5f62 6173 6564 5f6d 6561 7375 7265  ce_based_measure
+00027570: 7328 7365 6c66 2c20 7265 706c 6163 655f  s(self, replace_
+00027580: 696e 665f 6279 3d4e 6f6e 6529 3a0a 2020  inf_by=None):.  
+00027590: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000275a0: 2020 5265 7475 726e 2061 2064 6963 7469    Return a dicti
+000275b0: 6f6e 6172 7920 6f66 206c 6f63 616c 2061  onary of local a
+000275c0: 6e64 2067 6c6f 6261 6c20 6d65 6173 7572  nd global measur
+000275d0: 6573 2074 6861 7420 6172 6520 6261 7365  es that are base
+000275e0: 6420 6f6e 0a20 2020 2020 2020 2073 686f  d on.        sho
+000275f0: 7274 6573 7420 7061 7468 206c 656e 6774  rtest path lengt
+00027600: 6873 2e0a 0a20 2020 2020 2020 2054 6869  hs...        Thi
+00027610: 7320 6973 2075 7365 6675 6c20 666f 7220  s is useful for 
+00027620: 6c61 7267 6520 6772 6170 6873 2066 6f72  large graphs for
+00027630: 2077 6869 6368 2074 6865 206d 6174 7269   which the matri
+00027640: 7820 6f66 2061 6c6c 2073 686f 7274 6573  x of all shortes
+00027650: 740a 2020 2020 2020 2020 7061 7468 206c  t.        path l
+00027660: 656e 6774 6873 2063 616e 6e6f 7420 6265  engths cannot be
+00027670: 2073 746f 7265 642e 0a0a 2020 2020 2020   stored...      
+00027680: 2020 4558 5045 5249 4d45 4e54 414c 210a    EXPERIMENTAL!.
+00027690: 0a20 2020 2020 2020 203a 7479 7065 2072  .        :type r
+000276a0: 6570 6c61 6365 5f69 6e66 5f62 793a 2066  eplace_inf_by: f
+000276b0: 6c6f 6174 2f69 6e66 2f4e 6f6e 650a 2020  loat/inf/None.  
+000276c0: 2020 2020 2020 3a61 7267 2072 6570 6c61        :arg repla
+000276d0: 6365 5f69 6e66 5f62 793a 2049 6620 4e6f  ce_inf_by: If No
+000276e0: 6e65 2c20 7468 6520 6e75 6d62 6572 206f  ne, the number o
+000276f0: 6620 6e6f 6465 7320 6973 2075 7365 642e  f nodes is used.
+00027700: 0a20 2020 2020 2020 2020 2020 2028 4465  .            (De
+00027710: 6661 756c 743a 204e 6f6e 6529 0a20 2020  fault: None).   
+00027720: 2020 2020 203a 7274 7970 653a 2064 6963       :rtype: dic
+00027730: 7469 6f6e 6172 7920 7769 7468 206b 6579  tionary with key
+00027740: 7320 2263 6c6f 7365 6e65 7373 222c 2022  s "closeness", "
+00027750: 6861 726d 6f6e 6963 5f63 6c6f 7365 6e65  harmonic_closene
+00027760: 7373 222c 0a20 2020 2020 2020 2020 2020  ss",.           
+00027770: 2022 6578 706f 6e65 6e74 6961 6c5f 636c   "exponential_cl
+00027780: 6f73 656e 6573 7322 2c20 2261 7665 7261  oseness", "avera
+00027790: 6765 5f70 6174 685f 6c65 6e67 7468 222c  ge_path_length",
+000277a0: 0a20 2020 2020 2020 2020 2020 2022 676c  .            "gl
+000277b0: 6f62 616c 5f65 6666 6963 6965 6e63 7922  obal_efficiency"
+000277c0: 2c20 226e 7369 5f63 6c6f 7365 6e65 7373  , "nsi_closeness
+000277d0: 222c 2022 6e73 695f 6861 726d 6f6e 6963  ", "nsi_harmonic
+000277e0: 5f63 6c6f 7365 6e65 7373 222c 0a20 2020  _closeness",.   
+000277f0: 2020 2020 2020 2020 2022 6e73 695f 6578           "nsi_ex
+00027800: 706f 6e65 6e74 6961 6c5f 636c 6f73 656e  ponential_closen
+00027810: 6573 7322 2c20 226e 7369 5f61 7665 7261  ess", "nsi_avera
+00027820: 6765 5f70 6174 685f 6c65 6e67 7468 222c  ge_path_length",
+00027830: 0a20 2020 2020 2020 2020 2020 2022 6e73  .            "ns
+00027840: 695f 676c 6f62 616c 5f65 6666 6963 6965  i_global_efficie
+00027850: 6e63 7922 0a20 2020 2020 2020 2022 2222  ncy".        """
+00027860: 0a20 2020 2020 2020 204e 2c20 772c 2057  .        N, w, W
+00027870: 203d 2073 656c 662e 4e2c 2073 656c 662e   = self.N, self.
+00027880: 6e6f 6465 5f77 6569 6768 7473 2c20 7365  node_weights, se
+00027890: 6c66 2e74 6f74 616c 5f6e 6f64 655f 7765  lf.total_node_we
+000278a0: 6967 6874 0a0a 2020 2020 2020 2020 6966  ight..        if
+000278b0: 2072 6570 6c61 6365 5f69 6e66 5f62 7920   replace_inf_by 
+000278c0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+000278d0: 2020 2020 2072 6570 6c61 6365 5f69 6e66       replace_inf
+000278e0: 5f62 7920 3d20 4e0a 0a20 2020 2020 2020  _by = N..       
+000278f0: 2063 6c6f 7365 6e65 7373 203d 206e 702e   closeness = np.
+00027900: 7a65 726f 7328 4e29 0a20 2020 2020 2020  zeros(N).       
+00027910: 2068 6172 6d6f 6e69 635f 636c 6f73 656e   harmonic_closen
+00027920: 6573 7320 3d20 6e70 2e7a 6572 6f73 284e  ess = np.zeros(N
+00027930: 290a 2020 2020 2020 2020 6578 706f 6e65  ).        expone
+00027940: 6e74 6961 6c5f 636c 6f73 656e 6573 7320  ntial_closeness 
+00027950: 3d20 6e70 2e7a 6572 6f73 284e 290a 2020  = np.zeros(N).  
+00027960: 2020 2020 2020 6176 6572 6167 655f 7061        average_pa
+00027970: 7468 5f6c 656e 6774 6820 3d20 300a 2020  th_length = 0.  
+00027980: 2020 2020 2020 6e73 695f 636c 6f73 656e        nsi_closen
+00027990: 6573 7320 3d20 6e70 2e7a 6572 6f73 284e  ess = np.zeros(N
+000279a0: 290a 2020 2020 2020 2020 6e73 695f 6861  ).        nsi_ha
+000279b0: 726d 6f6e 6963 5f63 6c6f 7365 6e65 7373  rmonic_closeness
+000279c0: 203d 206e 702e 7a65 726f 7328 4e29 0a20   = np.zeros(N). 
+000279d0: 2020 2020 2020 206e 7369 5f65 7870 6f6e         nsi_expon
+000279e0: 656e 7469 616c 5f63 6c6f 7365 6e65 7373  ential_closeness
+000279f0: 203d 206e 702e 7a65 726f 7328 4e29 0a20   = np.zeros(N). 
+00027a00: 2020 2020 2020 206e 7369 5f61 7665 7261         nsi_avera
+00027a10: 6765 5f70 6174 685f 6c65 6e67 7468 203d  ge_path_length =
+00027a20: 2030 0a0a 2020 2020 2020 2020 666f 7220   0..        for 
+00027a30: 6920 696e 2072 616e 6765 284e 293a 0a20  i in range(N):. 
+00027a40: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00027a50: 6c66 2e73 696c 656e 6365 5f6c 6576 656c  lf.silence_level
+00027a60: 203d 3d20 303a 0a20 2020 2020 2020 2020   == 0:.         
+00027a70: 2020 2020 2020 2070 7269 6e74 2869 290a         print(i).
+00027a80: 2020 2020 2020 2020 2020 2020 6469 203d              di =
+00027a90: 206e 702e 6172 7261 7928 7365 6c66 2e67   np.array(self.g
+00027aa0: 7261 7068 2e64 6973 7461 6e63 6573 2869  raph.distances(i
+00027ab0: 292c 2064 7479 7065 3d66 6c6f 6174 292e  ), dtype=float).
+00027ac0: 666c 6174 7465 6e28 290a 2020 2020 2020  flatten().      
+00027ad0: 2020 2020 2020 6469 5b6e 702e 7768 6572        di[np.wher
+00027ae0: 6528 6469 203d 3d20 6e70 2e69 6e66 295d  e(di == np.inf)]
+00027af0: 203d 2072 6570 6c61 6365 5f69 6e66 5f62   = replace_inf_b
+00027b00: 790a 0a20 2020 2020 2020 2020 2020 2063  y..            c
+00027b10: 6c6f 7365 6e65 7373 5b69 5d20 3d20 312e  loseness[i] = 1.
+00027b20: 3020 2f20 6469 2e73 756d 2829 0a20 2020  0 / di.sum().   
+00027b30: 2020 2020 2020 2020 2061 7665 7261 6765           average
+00027b40: 5f70 6174 685f 6c65 6e67 7468 202b 3d20  _path_length += 
+00027b50: 6469 2e73 756d 2829 0a0a 2020 2020 2020  di.sum()..      
+00027b60: 2020 2020 2020 6469 5b69 5d20 3d20 6e70        di[i] = np
+00027b70: 2e69 6e66 0a20 2020 2020 2020 2020 2020  .inf.           
+00027b80: 2068 6172 6d6f 6e69 635f 636c 6f73 656e   harmonic_closen
+00027b90: 6573 735b 695d 203d 2028 312e 302f 6469  ess[i] = (1.0/di
+00027ba0: 292e 7375 6d28 290a 2020 2020 2020 2020  ).sum().        
+00027bb0: 2020 2020 6578 706f 6e65 6e74 6961 6c5f      exponential_
+00027bc0: 636c 6f73 656e 6573 735b 695d 203d 2028  closeness[i] = (
+00027bd0: 302e 352a 2a64 6929 2e73 756d 2829 0a0a  0.5**di).sum()..
+00027be0: 2020 2020 2020 2020 2020 2020 6469 5b69              di[i
+00027bf0: 5d20 3d20 310a 2020 2020 2020 2020 2020  ] = 1.          
+00027c00: 2020 6e73 695f 636c 6f73 656e 6573 735b    nsi_closeness[
+00027c10: 695d 203d 2031 2e30 202f 2028 772a 6469  i] = 1.0 / (w*di
+00027c20: 292e 7375 6d28 290a 2020 2020 2020 2020  ).sum().        
+00027c30: 2020 2020 6e73 695f 6176 6572 6167 655f      nsi_average_
+00027c40: 7061 7468 5f6c 656e 6774 6820 2b3d 2077  path_length += w
+00027c50: 5b69 5d20 2a20 2877 2a64 6929 2e73 756d  [i] * (w*di).sum
+00027c60: 2829 0a20 2020 2020 2020 2020 2020 206e  ().            n
+00027c70: 7369 5f68 6172 6d6f 6e69 635f 636c 6f73  si_harmonic_clos
+00027c80: 656e 6573 735b 695d 203d 2028 772f 6469  eness[i] = (w/di
+00027c90: 292e 7375 6d28 290a 2020 2020 2020 2020  ).sum().        
+00027ca0: 2020 2020 6e73 695f 6578 706f 6e65 6e74      nsi_exponent
+00027cb0: 6961 6c5f 636c 6f73 656e 6573 735b 695d  ial_closeness[i]
+00027cc0: 203d 2028 7720 2a20 302e 352a 2a64 6929   = (w * 0.5**di)
+00027cd0: 2e73 756d 2829 0a0a 2020 2020 2020 2020  .sum()..        
+00027ce0: 7265 7475 726e 207b 0a20 2020 2020 2020  return {.       
+00027cf0: 2020 2020 2022 636c 6f73 656e 6573 7322       "closeness"
+00027d00: 3a20 636c 6f73 656e 6573 7320 2a20 284e  : closeness * (N
+00027d10: 2d31 292c 0a20 2020 2020 2020 2020 2020  -1),.           
+00027d20: 2022 6861 726d 6f6e 6963 5f63 6c6f 7365   "harmonic_close
+00027d30: 6e65 7373 223a 2068 6172 6d6f 6e69 635f  ness": harmonic_
+00027d40: 636c 6f73 656e 6573 7320 2f20 284e 2d31  closeness / (N-1
+00027d50: 292c 0a20 2020 2020 2020 2020 2020 2022  ),.            "
+00027d60: 6578 706f 6e65 6e74 6961 6c5f 636c 6f73  exponential_clos
+00027d70: 656e 6573 7322 3a20 6578 706f 6e65 6e74  eness": exponent
+00027d80: 6961 6c5f 636c 6f73 656e 6573 7320 2f20  ial_closeness / 
+00027d90: 284e 2d31 292c 0a20 2020 2020 2020 2020  (N-1),.         
+00027da0: 2020 2022 6176 6572 6167 655f 7061 7468     "average_path
+00027db0: 5f6c 656e 6774 6822 3a20 6176 6572 6167  _length": averag
+00027dc0: 655f 7061 7468 5f6c 656e 6774 6820 2f20  e_path_length / 
+00027dd0: 4e2a 284e 2d31 292c 0a20 2020 2020 2020  N*(N-1),.       
+00027de0: 2020 2020 2022 676c 6f62 616c 5f65 6666       "global_eff
+00027df0: 6963 6965 6e63 7922 3a20 6861 726d 6f6e  iciency": harmon
+00027e00: 6963 5f63 6c6f 7365 6e65 7373 2e6d 6561  ic_closeness.mea
+00027e10: 6e28 2920 2f20 284e 2d31 292c 0a20 2020  n() / (N-1),.   
+00027e20: 2020 2020 2020 2020 2022 6e73 695f 636c           "nsi_cl
+00027e30: 6f73 656e 6573 7322 3a20 6e73 695f 636c  oseness": nsi_cl
+00027e40: 6f73 656e 6573 7320 2a20 572c 0a20 2020  oseness * W,.   
+00027e50: 2020 2020 2020 2020 2022 6e73 695f 6861           "nsi_ha
+00027e60: 726d 6f6e 6963 5f63 6c6f 7365 6e65 7373  rmonic_closeness
+00027e70: 223a 206e 7369 5f68 6172 6d6f 6e69 635f  ": nsi_harmonic_
+00027e80: 636c 6f73 656e 6573 7320 2f20 572c 0a20  closeness / W,. 
+00027e90: 2020 2020 2020 2020 2020 2022 6e73 695f             "nsi_
+00027ea0: 6578 706f 6e65 6e74 6961 6c5f 636c 6f73  exponential_clos
+00027eb0: 656e 6573 7322 3a20 6e73 695f 6578 706f  eness": nsi_expo
+00027ec0: 6e65 6e74 6961 6c5f 636c 6f73 656e 6573  nential_closenes
+00027ed0: 7320 2f20 572c 0a20 2020 2020 2020 2020  s / W,.         
+00027ee0: 2020 2022 6e73 695f 6176 6572 6167 655f     "nsi_average_
+00027ef0: 7061 7468 5f6c 656e 6774 6822 3a20 6e73  path_length": ns
+00027f00: 695f 6176 6572 6167 655f 7061 7468 5f6c  i_average_path_l
+00027f10: 656e 6774 6820 2f20 572a 2a32 2c0a 2020  ength / W**2,.  
+00027f20: 2020 2020 2020 2020 2020 226e 7369 5f67            "nsi_g
+00027f30: 6c6f 6261 6c5f 6566 6669 6369 656e 6379  lobal_efficiency
+00027f40: 223a 2077 2e64 6f74 286e 7369 5f68 6172  ": w.dot(nsi_har
+00027f50: 6d6f 6e69 635f 636c 6f73 656e 6573 7329  monic_closeness)
+00027f60: 202f 2057 2a2a 320a 2020 2020 2020 2020   / W**2.        
+00027f70: 7d0a 0a20 2020 2023 0a20 2020 2023 2020  }..    #.    #  
+00027f80: 5675 6c6e 6572 6162 696c 6974 7920 6d65  Vulnerability me
+00027f90: 6173 7572 6573 0a20 2020 2023 0a0a 2020  asures.    #..  
+00027fa0: 2020 6465 6620 6c6f 6361 6c5f 7675 6c6e    def local_vuln
+00027fb0: 6572 6162 696c 6974 7928 7365 6c66 2c20  erability(self, 
+00027fc0: 6c69 6e6b 5f61 7474 7269 6275 7465 3d4e  link_attribute=N
+00027fd0: 6f6e 6529 3a0a 2020 2020 2020 2020 2222  one):.        ""
+00027fe0: 220a 2020 2020 2020 2020 466f 7220 6561  ".        For ea
+00027ff0: 6368 206e 6f64 652c 2072 6574 7572 6e20  ch node, return 
+00028000: 6974 7320 7675 6c6e 6572 6162 696c 6974  its vulnerabilit
+00028010: 792e 2028 7365 6520 5b43 6f73 7461 3230  y. (see [Costa20
+00028020: 3037 5d5f 290a 0a20 2020 2020 2020 202a  07]_)..        *
+00028030: 2a45 7861 6d70 6c65 3a2a 2a0a 0a20 2020  *Example:**..   
+00028040: 2020 2020 203e 3e3e 2072 284e 6574 776f       >>> r(Netwo
+00028050: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
+00028060: 6f72 6b28 292e 6c6f 6361 6c5f 7675 6c6e  ork().local_vuln
+00028070: 6572 6162 696c 6974 7928 2929 0a20 2020  erability()).   
+00028080: 2020 2020 2043 616c 6375 6c61 7469 6e67       Calculating
+00028090: 2061 6c6c 2073 686f 7274 6573 7420 7061   all shortest pa
+000280a0: 7468 206c 656e 6774 6873 2e2e 2e0a 2020  th lengths....  
+000280b0: 2020 2020 2020 4361 6c63 756c 6174 696e        Calculatin
+000280c0: 6720 676c 6f62 616c 2028 7765 6967 6874  g global (weight
+000280d0: 6564 2920 6566 6669 6369 656e 6379 2e2e  ed) efficiency..
+000280e0: 2e0a 2020 2020 2020 2020 4361 6c63 756c  ..        Calcul
+000280f0: 6174 696e 6720 2877 6569 6768 7465 6429  ating (weighted)
+00028100: 206e 6f64 6520 7675 6c6e 6572 6162 696c   node vulnerabil
+00028110: 6974 6965 732e 2e2e 0a20 2020 2020 2020  ities....       
+00028120: 2061 7272 6179 285b 2030 2e32 3936 392c   array([ 0.2969,
+00028130: 2030 2e30 3632 352c 202d 302e 3033 3133   0.0625, -0.0313
+00028140: 2c20 2d30 2e30 3037 382c 2030 2e30 3937  , -0.0078, 0.097
+00028150: 372c 202d 302e 3132 3520 5d29 0a0a 2020  7, -0.125 ])..  
+00028160: 2020 2020 2020 3a61 7267 2073 7472 206c        :arg str l
+00028170: 696e 6b5f 6174 7472 6962 7574 653a 204f  ink_attribute: O
+00028180: 7074 696f 6e61 6c20 6e61 6d65 206f 6620  ptional name of 
+00028190: 7468 6520 6c69 6e6b 2061 7474 7269 6275  the link attribu
+000281a0: 7465 2074 6f20 6265 2075 7365 640a 2020  te to be used.  
+000281b0: 2020 2020 2020 2020 2020 6173 2074 6865            as the
+000281c0: 206c 696e 6b73 2720 6c65 6e67 7468 2e20   links' length. 
+000281d0: 4966 204e 6f6e 652c 206c 696e 6b73 2068  If None, links h
+000281e0: 6176 6520 6c65 6e67 7468 2031 2e20 2844  ave length 1. (D
+000281f0: 6566 6175 6c74 3a20 4e6f 6e65 290a 2020  efault: None).  
+00028200: 2020 2020 2020 3a72 7479 7065 3a20 3164        :rtype: 1d
+00028210: 206e 756d 7079 2061 7272 6179 205b 6e6f   numpy array [no
+00028220: 6465 5d20 6f66 2066 6c6f 6174 730a 2020  de] of floats.  
+00028230: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00028240: 2020 6966 206c 696e 6b5f 6174 7472 6962    if link_attrib
+00028250: 7574 6520 3d3d 2022 746f 706f 6c6f 6769  ute == "topologi
+00028260: 6361 6c22 3a0a 2020 2020 2020 2020 2020  cal":.          
+00028270: 2020 7072 696e 7428 2257 4152 4e49 4e47    print("WARNING
+00028280: 3a20 6c69 6e6b 5f61 7474 7269 6275 7465  : link_attribute
+00028290: 3d27 746f 706f 6c6f 6769 6361 6c27 2069  ='topological' i
+000282a0: 7320 6465 7072 6563 6174 6564 2e5c 6e22  s deprecated.\n"
+000282b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000282c0: 2020 202b 2022 5573 6520 6c69 6e6b 5f61     + "Use link_a
+000282d0: 7474 7269 6275 7465 3d4e 6f6e 6520 696e  ttribute=None in
+000282e0: 7374 6561 642e 2229 0a20 2020 2020 2020  stead.").       
+000282f0: 2020 2020 206c 696e 6b5f 6174 7472 6962       link_attrib
+00028300: 7574 6520 3d20 4e6f 6e65 0a0a 2020 2020  ute = None..    
+00028310: 2020 2020 7675 6c6e 6572 6162 696c 6974      vulnerabilit
+00028320: 7920 3d20 6e70 2e7a 6572 6f73 2873 656c  y = np.zeros(sel
+00028330: 662e 4e29 0a0a 2020 2020 2020 2020 2320  f.N)..        # 
+00028340: 2043 616c 6375 6c61 7465 2067 6c6f 6261   Calculate globa
+00028350: 6c20 6566 6669 6369 656e 6379 206f 6620  l efficiency of 
+00028360: 636f 6d70 6c65 7465 206e 6574 776f 726b  complete network
+00028370: 2045 0a20 2020 2020 2020 2067 6c6f 6261   E.        globa
+00028380: 6c5f 6566 6669 6369 656e 6379 203d 2073  l_efficiency = s
+00028390: 656c 662e 676c 6f62 616c 5f65 6666 6963  elf.global_effic
+000283a0: 6965 6e63 7928 6c69 6e6b 5f61 7474 7269  iency(link_attri
+000283b0: 6275 7465 290a 0a20 2020 2020 2020 2069  bute)..        i
+000283c0: 6620 7365 6c66 2e73 696c 656e 6365 5f6c  f self.silence_l
+000283d0: 6576 656c 203c 3d20 313a 0a20 2020 2020  evel <= 1:.     
+000283e0: 2020 2020 2020 2070 7269 6e74 2822 4361         print("Ca
+000283f0: 6c63 756c 6174 696e 6720 2877 6569 6768  lculating (weigh
+00028400: 7465 6429 206e 6f64 6520 7675 6c6e 6572  ted) node vulner
+00028410: 6162 696c 6974 6965 732e 2e2e 2229 0a0a  abilities...")..
+00028420: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
+00028430: 2074 7261 6e67 6528 7365 6c66 2e4e 2c20   trange(self.N, 
+00028440: 6469 7361 626c 653d 7365 6c66 2e73 696c  disable=self.sil
+00028450: 656e 6365 5f6c 6576 656c 203e 2031 293a  ence_level > 1):
+00028460: 0a20 2020 2020 2020 2020 2020 2023 2020  .            #  
+00028470: 5265 6d6f 7665 2076 6572 7465 7820 6920  Remove vertex i 
+00028480: 6672 6f6d 2067 7261 7068 0a20 2020 2020  from graph.     
+00028490: 2020 2020 2020 2067 7261 7068 203d 2073         graph = s
+000284a0: 656c 662e 6772 6170 6820 2d20 690a 0a20  elf.graph - i.. 
+000284b0: 2020 2020 2020 2020 2020 2023 2020 4765             #  Ge
+000284c0: 6e65 7261 7465 204e 6574 776f 726b 206f  nerate Network o
+000284d0: 626a 6563 7420 6672 6f6d 2074 6869 7320  bject from this 
+000284e0: 7265 6475 6365 6420 6772 6170 680a 2020  reduced graph.  
+000284f0: 2020 2020 2020 2020 2020 6e65 7477 6f72            networ
+00028500: 6b20 3d20 4e65 7477 6f72 6b2e 4672 6f6d  k = Network.From
+00028510: 4947 7261 7068 2867 7261 7068 2c20 3229  IGraph(graph, 2)
+00028520: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00028530: 2043 616c 6375 6c61 7465 2067 6c6f 6261   Calculate globa
+00028540: 6c20 746f 706f 6c6f 6769 6361 6c20 6566  l topological ef
+00028550: 6669 6369 656e 6379 2045 5f69 2061 6674  ficiency E_i aft
+00028560: 6572 2072 656d 6f76 616c 206f 660a 2020  er removal of.  
+00028570: 2020 2020 2020 2020 2020 2320 2076 6572            #  ver
+00028580: 7465 7820 690a 2020 2020 2020 2020 2020  tex i.          
+00028590: 2020 6e6f 6465 5f65 6666 6963 6965 6e63    node_efficienc
+000285a0: 7920 3d20 6e65 7477 6f72 6b2e 676c 6f62  y = network.glob
+000285b0: 616c 5f65 6666 6963 6965 6e63 7928 6c69  al_efficiency(li
+000285c0: 6e6b 5f61 7474 7269 6275 7465 290a 0a20  nk_attribute).. 
+000285d0: 2020 2020 2020 2020 2020 2023 2020 4361             #  Ca
+000285e0: 6c63 756c 6174 6520 6c6f 6361 6c20 746f  lculate local to
+000285f0: 706f 6c6f 6769 6361 6c20 7675 6c6e 6572  pological vulner
+00028600: 6162 696c 6974 7920 6f66 2076 6572 7465  ability of verte
+00028610: 7820 690a 2020 2020 2020 2020 2020 2020  x i.            
+00028620: 7675 6c6e 6572 6162 696c 6974 795b 695d  vulnerability[i]
+00028630: 203d 2028 2867 6c6f 6261 6c5f 6566 6669   = ((global_effi
+00028640: 6369 656e 6379 202d 206e 6f64 655f 6566  ciency - node_ef
+00028650: 6669 6369 656e 6379 290a 2020 2020 2020  ficiency).      
+00028660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028670: 2020 2020 2020 2020 2020 2f20 676c 6f62            / glob
+00028680: 616c 5f65 6666 6963 6965 6e63 7929 0a0a  al_efficiency)..
+00028690: 2020 2020 2020 2020 2020 2020 2320 2043              #  C
+000286a0: 6c65 616e 2075 700a 2020 2020 2020 2020  lean up.        
+000286b0: 2020 2020 6465 6c20 6772 6170 682c 206e      del graph, n
+000286c0: 6574 776f 726b 0a0a 2020 2020 2020 2020  etwork..        
+000286d0: 7265 7475 726e 2076 756c 6e65 7261 6269  return vulnerabi
+000286e0: 6c69 7479 0a0a 2020 2020 230a 2020 2020  lity..    #.    
+000286f0: 2320 2043 6f6d 6d75 6e69 7479 206d 6561  #  Community mea
+00028700: 7375 7265 730a 2020 2020 230a 0a20 2020  sures.    #..   
+00028710: 2040 4361 6368 6564 2e6d 6574 686f 6428   @Cached.method(
+00028720: 6e61 6d65 3d22 636f 7265 6e65 7373 2229  name="coreness")
+00028730: 0a20 2020 2064 6566 2063 6f72 656e 6573  .    def corenes
+00028740: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
+00028750: 2022 2222 0a20 2020 2020 2020 2046 6f72   """.        For
+00028760: 2065 6163 6820 6e6f 6465 2c20 7265 7475   each node, retu
+00028770: 726e 2069 7473 2063 6f72 656e 6573 732e  rn its coreness.
+00028780: 0a0a 2020 2020 2020 2020 5468 6520 6b2d  ..        The k-
+00028790: 636f 7265 206f 6620 6120 6e65 7477 6f72  core of a networ
+000287a0: 6b20 6973 2061 206d 6178 696d 616c 2073  k is a maximal s
+000287b0: 7562 6e65 7477 6f72 6b20 696e 2077 6869  ubnetwork in whi
+000287c0: 6368 2065 6163 6820 6e6f 6465 2068 6173  ch each node has
+000287d0: 0a20 2020 2020 2020 2061 7420 6c65 6173  .        at leas
+000287e0: 7420 6465 6772 6565 206b 2e20 2844 6567  t degree k. (Deg
+000287f0: 7265 6520 6865 7265 206d 6561 6e73 2074  ree here means t
+00028800: 6865 2064 6567 7265 6520 696e 2074 6865  he degree in the
+00028810: 2073 7562 6e65 7477 6f72 6b20 6f66 0a20   subnetwork of. 
+00028820: 2020 2020 2020 2063 6f75 7273 6529 2e20         course). 
+00028830: 5468 6520 636f 7265 6e65 7373 206f 6620  The coreness of 
+00028840: 6120 6e6f 6465 2069 7320 6b20 6966 2069  a node is k if i
+00028850: 7420 6973 2061 206d 656d 6265 7220 6f66  t is a member of
+00028860: 2074 6865 206b 2d63 6f72 650a 2020 2020   the k-core.    
+00028870: 2020 2020 6275 7420 6e6f 7420 6120 6d65      but not a me
+00028880: 6d62 6572 206f 6620 7468 6520 286b 2b31  mber of the (k+1
+00028890: 292d 636f 7265 2e0a 0a20 2020 2020 2020  )-core...       
+000288a0: 202a 2a45 7861 6d70 6c65 3a2a 2a0a 0a20   **Example:**.. 
+000288b0: 2020 2020 2020 203e 3e3e 204e 6574 776f         >>> Netwo
+000288c0: 726b 2e53 6d61 6c6c 5465 7374 4e65 7477  rk.SmallTestNetw
+000288d0: 6f72 6b28 292e 636f 7265 6e65 7373 2829  ork().coreness()
+000288e0: 0a20 2020 2020 2020 2043 616c 6375 6c61  .        Calcula
+000288f0: 7469 6e67 2063 6f72 656e 6573 732e 2e2e  ting coreness...
+00028900: 0a20 2020 2020 2020 2061 7272 6179 285b  .        array([
+00028910: 322c 2032 2c20 322c 2032 2c20 322c 2031  2, 2, 2, 2, 2, 1
+00028920: 5d29 0a0a 2020 2020 2020 2020 3a72 7479  ])..        :rty
+00028930: 7065 3a20 3164 206e 756d 7079 2061 7272  pe: 1d numpy arr
+00028940: 6179 205b 6e6f 6465 5d20 6f66 2066 6c6f  ay [node] of flo
+00028950: 6174 730a 2020 2020 2020 2020 2222 220a  ats.        """.
+00028960: 2020 2020 2020 2020 7265 7475 726e 206e          return n
+00028970: 702e 6172 7261 7928 7365 6c66 2e67 7261  p.array(self.gra
+00028980: 7068 2e63 6f72 656e 6573 7328 2929 0a0a  ph.coreness())..
+00028990: 2020 2020 230a 2020 2020 2320 2053 796e      #.    #  Syn
+000289a0: 6368 726f 6e69 7a61 6269 6c69 7479 206d  chronizability m
+000289b0: 6561 7375 7265 730a 2020 2020 230a 0a20  easures.    #.. 
+000289c0: 2020 2040 4361 6368 6564 2e6d 6574 686f     @Cached.metho
+000289d0: 6428 6e61 6d65 3d22 7468 6520 6d61 7374  d(name="the mast
+000289e0: 6572 2073 7461 6269 6c69 7479 2066 756e  er stability fun
+000289f0: 6374 696f 6e20 7379 6e63 6872 6f6e 697a  ction synchroniz
+00028a00: 6162 696c 6974 7922 290a 2020 2020 6465  ability").    de
+00028a10: 6620 6d73 665f 7379 6e63 6872 6f6e 697a  f msf_synchroniz
+00028a20: 6162 696c 6974 7928 7365 6c66 293a 0a20  ability(self):. 
+00028a30: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00028a40: 2020 2052 6574 7572 6e20 7468 6520 7379     Return the sy
+00028a50: 6e63 6872 6f6e 697a 6162 696c 6974 7920  nchronizability 
+00028a60: 696e 2074 6865 206d 6173 7465 7220 7374  in the master st
+00028a70: 6162 696c 6974 7920 6675 6e63 7469 6f6e  ability function
+00028a80: 0a20 2020 2020 2020 2066 7261 6d65 776f  .        framewo
+00028a90: 726b 2e0a 0a20 2020 2020 2020 2054 6869  rk...        Thi
+00028aa0: 7320 6973 2065 7175 616c 2074 6f20 7468  s is equal to th
+00028ab0: 6520 6c61 7267 6573 7420 6569 6765 6e76  e largest eigenv
+00028ac0: 616c 7565 206f 6620 7468 6520 6772 6170  alue of the grap
+00028ad0: 6820 4c61 706c 6163 6961 6e20 6469 7669  h Laplacian divi
+00028ae0: 6465 640a 2020 2020 2020 2020 6279 2074  ded.        by t
+00028af0: 6865 2073 6d61 6c6c 6573 7420 6e6f 6e2d  he smallest non-
+00028b00: 7a65 726f 2065 6967 656e 7661 6c75 652e  zero eigenvalue.
+00028b10: 2041 2073 6d61 6c6c 6572 2076 616c 7565   A smaller value
+00028b20: 2069 6e64 6963 6174 6573 2068 6967 6865   indicates highe
+00028b30: 720a 2020 2020 2020 2020 7379 6e63 6872  r.        synchr
+00028b40: 6f6e 697a 6162 696c 6974 7920 616e 6420  onizability and 
+00028b50: 7669 6365 2076 6572 7361 2e20 5468 6973  vice versa. This
+00028b60: 2066 756e 6374 696f 6e20 6d61 6b65 7320   function makes 
+00028b70: 7365 6e73 6520 666f 720a 2020 2020 2020  sense for.      
+00028b80: 2020 756e 6469 7265 6374 6564 2063 6c69    undirected cli
+00028b90: 6d61 7465 206e 6574 776f 726b 7320 2877  mate networks (w
+00028ba0: 6974 6820 7379 6d6d 6574 7269 6320 4c61  ith symmetric La
+00028bb0: 706c 6163 6961 6e20 6d61 7472 6978 292e  placian matrix).
+00028bc0: 0a20 2020 2020 2020 2046 6f72 2064 6972  .        For dir
+00028bd0: 6563 7465 6420 6e65 7477 6f72 6b73 2c20  ected networks, 
+00028be0: 7468 6520 756e 6469 7265 6374 6564 204c  the undirected L
+00028bf0: 6170 6c61 6369 616e 206d 6174 7269 7820  aplacian matrix 
+00028c00: 6973 2075 7365 642e 0a0a 2020 2020 2020  is used...      
+00028c10: 2020 2873 6565 205b 5065 636f 7261 3139    (see [Pecora19
+00028c20: 3938 5d5f 290a 0a20 2020 2020 2020 202e  98]_)..        .
+00028c30: 2e20 6e6f 7465 3a3a 0a20 2020 2020 2020  . note::.       
+00028c40: 2020 2020 4f6e 6c79 2064 6566 696e 6564      Only defined
+00028c50: 2066 6f72 2075 6e64 6972 6563 7465 6420   for undirected 
+00028c60: 6e65 7477 6f72 6b73 2e0a 0a20 2020 2020  networks...     
+00028c70: 2020 202a 2a45 7861 6d70 6c65 3a2a 2a0a     **Example:**.
+00028c80: 0a20 2020 2020 2020 203e 3e3e 2072 284e  .        >>> r(N
+00028c90: 6574 776f 726b 2e53 6d61 6c6c 5465 7374  etwork.SmallTest
+00028ca0: 4e65 7477 6f72 6b28 292e 6d73 665f 7379  Network().msf_sy
+00028cb0: 6e63 6872 6f6e 697a 6162 696c 6974 7928  nchronizability(
+00028cc0: 2929 0a20 2020 2020 2020 2043 616c 6375  )).        Calcu
+00028cd0: 6c61 7469 6e67 206d 6173 7465 7220 7374  lating master st
+00028ce0: 6162 696c 6974 7920 6675 6e63 7469 6f6e  ability function
+00028cf0: 2073 796e 6368 726f 6e69 7a61 6269 6c69   synchronizabili
+00028d00: 7479 2e2e 2e0a 2020 2020 2020 2020 362e  ty....        6.
+00028d10: 3737 3834 0a0a 2020 2020 2020 2020 3a72  7784..        :r
+00028d20: 7479 7065 3a20 666c 6f61 740a 2020 2020  type: float.    
+00028d30: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00028d40: 2320 544f 444f 3a20 7573 6520 7370 6172  # TODO: use spar
+00028d50: 7365 2076 6572 7369 6f6e 2074 6f20 7370  se version to sp
+00028d60: 6565 6420 7570 210a 2020 2020 2020 2020  eed up!.        
+00028d70: 2320 2047 6574 2075 6e64 6972 6563 7465  #  Get undirecte
+00028d80: 6420 6772 6170 6820 6c61 706c 6163 6961  d graph laplacia
+00028d90: 6e0a 2020 2020 2020 2020 6c61 706c 6163  n.        laplac
+00028da0: 6961 6e20 3d20 7365 6c66 2e6c 6170 6c61  ian = self.lapla
+00028db0: 6369 616e 2829 0a0a 2020 2020 2020 2020  cian()..        
+00028dc0: 2320 2047 6574 2065 6967 656e 7661 6c75  #  Get eigenvalu
+00028dd0: 6573 206f 6620 6c61 706c 6163 6961 6e0a  es of laplacian.
+00028de0: 2020 2020 2020 2020 6569 6765 6e76 616c          eigenval
+00028df0: 7565 7320 3d20 6e70 2e72 6561 6c28 6c69  ues = np.real(li
+00028e00: 6e61 6c67 2e65 6967 7661 6c73 286c 6170  nalg.eigvals(lap
+00028e10: 6c61 6369 616e 2929 0a0a 2020 2020 2020  lacian))..      
+00028e20: 2020 2320 2053 6f72 7420 6569 6765 6e76    #  Sort eigenv
+00028e30: 616c 7565 7320 696e 2061 7363 656e 6469  alues in ascendi
+00028e40: 6e67 206f 7264 6572 0a20 2020 2020 2020  ng order.       
+00028e50: 2065 6967 656e 7661 6c75 6573 2e73 6f72   eigenvalues.sor
+00028e60: 7428 290a 0a20 2020 2020 2020 2023 2020  t()..        #  
+00028e70: 4765 7420 736d 616c 6c65 7374 206e 6f6e  Get smallest non
+00028e80: 2d7a 6572 6f20 6569 6765 6e76 616c 7565  -zero eigenvalue
+00028e90: 2028 4669 6564 6c65 7220 7661 6c75 6529   (Fiedler value)
+00028ea0: 0a20 2020 2020 2020 2069 203d 2030 0a20  .        i = 0. 
+00028eb0: 2020 2020 2020 2066 6965 646c 6572 5f76         fiedler_v
+00028ec0: 616c 7565 203d 2030 0a0a 2020 2020 2020  alue = 0..      
+00028ed0: 2020 2320 2054 6865 206c 696d 6974 6564    #  The limited
+00028ee0: 2061 6363 7572 6163 7920 6f66 2065 6967   accuracy of eig
+00028ef0: 656e 7661 6c75 6520 6361 6c63 756c 6174  envalue calculat
+00028f00: 696f 6e20 666f 7263 6573 2074 6865 2075  ion forces the u
+00028f10: 7365 206f 660a 2020 2020 2020 2020 2320  se of.        # 
+00028f20: 2073 6f6d 6520 7468 7265 7368 6f6c 642c   some threshold,
+00028f30: 2062 656c 6f77 2077 6869 6368 2065 6967   below which eig
+00028f40: 656e 7661 6c75 6573 2061 7265 2063 6f6e  envalues are con
+00028f50: 7369 6465 7265 6420 746f 2062 6520 7a65  sidered to be ze
+00028f60: 726f 0a20 2020 2020 2020 2061 6363 7572  ro.        accur
+00028f70: 6163 7920 3d20 3130 2a2a 282d 3130 290a  acy = 10**(-10).
+00028f80: 0a20 2020 2020 2020 2077 6869 6c65 2028  .        while (
+00028f90: 6569 6765 6e76 616c 7565 735b 695d 203c  eigenvalues[i] <
+00028fa0: 3d20 6163 6375 7261 6379 2920 616e 6420  = accuracy) and 
+00028fb0: 2869 203c 2073 656c 662e 4e20 2d20 3129  (i < self.N - 1)
+00028fc0: 3a0a 2020 2020 2020 2020 2020 2020 6669  :.            fi
+00028fd0: 6564 6c65 725f 7661 6c75 6520 3d20 6569  edler_value = ei
+00028fe0: 6765 6e76 616c 7565 735b 692b 315d 0a20  genvalues[i+1]. 
+00028ff0: 2020 2020 2020 2020 2020 2069 202b 3d20             i += 
+00029000: 310a 0a20 2020 2020 2020 2023 2020 4361  1..        #  Ca
+00029010: 6c63 756c 6174 6520 7379 6e63 6872 6f6e  lculate synchron
+00029020: 697a 6162 696c 6974 7920 520a 2020 2020  izability R.    
+00029030: 2020 2020 5220 3d20 6569 6765 6e76 616c      R = eigenval
+00029040: 7565 735b 2d31 5d20 2f20 6669 6564 6c65  ues[-1] / fiedle
+00029050: 725f 7661 6c75 650a 0a20 2020 2020 2020  r_value..       
+00029060: 2072 6574 7572 6e20 520a 0a20 2020 2023   return R..    #
+00029070: 0a20 2020 2023 2020 4469 7374 616e 6365  .    #  Distance
+00029080: 206d 6561 7375 7265 7320 6265 7477 6565   measures betwee
+00029090: 6e20 7477 6f20 6772 6170 6873 0a20 2020  n two graphs.   
+000290a0: 2023 0a0a 2020 2020 6465 6620 6861 6d6d   #..    def hamm
+000290b0: 696e 675f 6469 7374 616e 6365 5f66 726f  ing_distance_fro
+000290c0: 6d28 7365 6c66 2c20 6f74 6865 725f 6e65  m(self, other_ne
+000290d0: 7477 6f72 6b29 3a0a 2020 2020 2020 2020  twork):.        
+000290e0: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
+000290f0: 726e 2074 6865 206e 6f72 6d61 6c69 7a65  rn the normalize
+00029100: 6420 6861 6d6d 696e 6720 6469 7374 616e  d hamming distan
+00029110: 6365 2062 6574 7765 656e 2074 6869 7320  ce between this 
+00029120: 616e 6420 616e 6f74 6865 720a 2020 2020  and another.    
+00029130: 2020 2020 6e65 7477 6f72 6b2e 0a0a 2020      network...  
+00029140: 2020 2020 2020 5468 6973 2069 7320 7468        This is th
+00029150: 6520 7065 7263 656e 7461 6765 206f 6620  e percentage of 
+00029160: 6c69 6e6b 7320 7468 6174 2068 6176 6520  links that have 
+00029170: 746f 2062 6520 6368 616e 6765 6420 746f  to be changed to
+00029180: 2074 7261 6e73 666f 726d 0a20 2020 2020   transform.     
+00029190: 2020 2074 6869 7320 6e65 7477 6f72 6b20     this network 
+000291a0: 696e 746f 2074 6865 206f 7468 6572 2e20  into the other. 
+000291b0: 4861 6d6d 696e 6720 6469 7374 616e 6365  Hamming distance
+000291c0: 2069 7320 6f6e 6c79 2064 6566 696e 6564   is only defined
+000291d0: 2066 6f72 0a20 2020 2020 2020 206e 6574   for.        net
+000291e0: 776f 726b 7320 7769 7468 2061 6e20 6571  works with an eq
+000291f0: 7561 6c20 6e75 6d62 6572 206f 6620 6e6f  ual number of no
+00029200: 6465 732e 0a0a 2020 2020 2020 2020 3a72  des...        :r
+00029210: 7479 7065 3a20 666c 6f61 7420 6265 7477  type: float betw
+00029220: 6565 6e20 3020 616e 6420 310a 2020 2020  een 0 and 1.    
+00029230: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00029240: 2320 2047 6574 206f 776e 2061 646a 6163  #  Get own adjac
+00029250: 656e 6379 206d 6174 7269 780a 2020 2020  ency matrix.    
+00029260: 2020 2020 4120 3d20 7365 6c66 2e61 646a      A = self.adj
+00029270: 6163 656e 6379 0a20 2020 2020 2020 2023  acency.        #
+00029280: 2020 4765 7420 7468 6520 6f74 6865 7220    Get the other 
+00029290: 6772 6170 6827 7320 6164 6a61 6365 6e63  graph's adjacenc
+000292a0: 7920 6d61 7472 6978 0a20 2020 2020 2020  y matrix.       
+000292b0: 2042 203d 206f 7468 6572 5f6e 6574 776f   B = other_netwo
+000292c0: 726b 2e61 646a 6163 656e 6379 0a0a 2020  rk.adjacency..  
+000292d0: 2020 2020 2020 2320 2043 6865 636b 2069        #  Check i
+000292e0: 6620 7468 6520 6772 6170 6873 2068 6176  f the graphs hav
+000292f0: 6520 7468 6520 7361 6d65 206e 756d 6265  e the same numbe
+00029300: 7220 6f66 2076 6572 7469 6365 730a 2020  r of vertices.  
+00029310: 2020 2020 2020 6966 2073 656c 662e 4e20        if self.N 
+00029320: 3d3d 206f 7468 6572 5f6e 6574 776f 726b  == other_network
+00029330: 2e4e 3a0a 2020 2020 2020 2020 2020 2020  .N:.            
+00029340: 2320 2043 616c 6375 6c61 7465 2074 6865  #  Calculate the
+00029350: 2068 616d 6d69 6e67 2064 6973 7461 6e63   hamming distanc
+00029360: 650a 2020 2020 2020 2020 2020 2020 6861  e.            ha
+00029370: 6d6d 696e 6720 3d20 2841 2021 3d20 4229  mming = (A != B)
+00029380: 2e73 756d 2829 0a0a 2020 2020 2020 2020  .sum()..        
+00029390: 2020 2020 2320 2052 6574 7572 6e20 7468      #  Return th
+000293a0: 6520 6e6f 726d 616c 697a 6564 2068 616d  e normalized ham
+000293b0: 6d69 6e67 2064 6973 7461 6e63 650a 2020  ming distance.  
+000293c0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000293d0: 2068 616d 6d69 6e67 202f 2066 6c6f 6174   hamming / float
+000293e0: 2873 656c 662e 4e20 2a20 2873 656c 662e  (self.N * (self.
+000293f0: 4e20 2d20 3129 290a 2020 2020 2020 2020  N - 1)).        
+00029400: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00029410: 2020 7261 6973 6520 4e65 7477 6f72 6b45    raise NetworkE
+00029420: 7272 6f72 2822 4f6e 6c79 2064 6566 696e  rror("Only defin
+00029430: 6564 2066 6f72 206e 6574 776f 726b 7320  ed for networks 
+00029440: 7769 7468 2073 616d 6520 6e75 6d62 6572  with same number
+00029450: 206f 6620 5c0a 2020 2020 2020 2020 2020   of \.          
+00029460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00029470: 2020 2020 206e 6f64 6573 2e22 290a 0a20       nodes.").. 
+00029480: 2020 2064 6566 2073 7072 6561 6469 6e67     def spreading
+00029490: 2873 656c 662c 2061 6c70 6861 3d4e 6f6e  (self, alpha=Non
+000294a0: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
+000294b0: 2020 2020 2020 2020 466f 7220 6561 6368          For each
+000294c0: 206e 6f64 652c 2072 6574 7572 6e20 6974   node, return it
+000294d0: 7320 2273 7072 6561 6469 6e67 2220 7661  s "spreading" va
+000294e0: 6c75 652e 0a0a 2020 2020 2020 2020 2e2e  lue...        ..
+000294f0: 206e 6f74 653a 3a0a 2020 2020 2020 2020   note::.        
+00029500: 2020 2054 6869 7320 6973 2073 7469 6c6c     This is still
+00029510: 2045 5850 4552 494d 454e 5441 4c21 0a0a   EXPERIMENTAL!..
+00029520: 2020 2020 2020 2020 3a72 7479 7065 3a20          :rtype: 
+00029530: 3164 206e 756d 7079 2061 7272 6179 205b  1d numpy array [
+00029540: 6e6f 6465 5d20 6f66 2066 6c6f 6174 730a  node] of floats.
+00029550: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00029560: 2020 2020 6966 2061 6c70 6861 2069 7320      if alpha is 
+00029570: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00029580: 2020 616c 7068 6120 3d20 312e 3020 2f20    alpha = 1.0 / 
+00029590: 7365 6c66 2e64 6567 7265 6528 292e 6d65  self.degree().me
+000295a0: 616e 2829 0a20 2020 2020 2020 2072 6574  an().        ret
+000295b0: 7572 6e20 6578 706d 286e 702e 6c6f 6728  urn expm(np.log(
+000295c0: 322e 3029 202a 2028 0a20 2020 2020 2020  2.0) * (.       
+000295d0: 2020 2020 2061 6c70 6861 202a 2073 656c       alpha * sel
+000295e0: 662e 6164 6a61 6365 6e63 790a 2020 2020  f.adjacency.    
+000295f0: 2020 2020 2020 2020 2d20 6e70 2e69 6465          - np.ide
+00029600: 6e74 6974 7928 7365 6c66 2e4e 2929 292e  ntity(self.N))).
+00029610: 7375 6d28 6178 6973 3d30 292e 666c 6174  sum(axis=0).flat
+00029620: 7465 6e28 290a 0a20 2020 2064 6566 206e  ten()..    def n
+00029630: 7369 5f73 7072 6561 6469 6e67 2873 656c  si_spreading(sel
+00029640: 662c 2061 6c70 6861 3d4e 6f6e 6529 3a0a  f, alpha=None):.
+00029650: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00029660: 2020 2020 466f 7220 6561 6368 206e 6f64      For each nod
+00029670: 652c 2072 6574 7572 6e20 6974 7320 6e2e  e, return its n.
+00029680: 732e 692e 2022 7370 7265 6164 696e 6722  s.i. "spreading"
+00029690: 2076 616c 7565 2e0a 0a20 2020 2020 2020   value...       
+000296a0: 202e 2e20 6e6f 7465 3a3a 0a20 2020 2020   .. note::.     
+000296b0: 2020 2020 2020 5468 6973 2069 7320 7374        This is st
+000296c0: 696c 6c20 4558 5045 5249 4d45 4e54 414c  ill EXPERIMENTAL
+000296d0: 210a 0a20 2020 2020 2020 203a 7274 7970  !..        :rtyp
+000296e0: 653a 2031 6420 6e75 6d70 7920 6172 7261  e: 1d numpy arra
+000296f0: 7920 5b6e 6f64 655d 206f 6620 666c 6f61  y [node] of floa
+00029700: 7473 0a20 2020 2020 2020 2022 2222 0a20  ts.        """. 
+00029710: 2020 2020 2020 204e 2c20 4170 6c75 7320         N, Aplus 
+00029720: 3d20 7365 6c66 2e4e 2c20 7365 6c66 2e73  = self.N, self.s
+00029730: 705f 4170 6c75 7328 292e 410a 2020 2020  p_Aplus().A.    
+00029740: 2020 2020 772c 206b 203d 2073 656c 662e      w, k = self.
+00029750: 6e6f 6465 5f77 6569 6768 7473 2c20 7365  node_weights, se
+00029760: 6c66 2e6e 7369 5f64 6567 7265 6528 290a  lf.nsi_degree().
+00029770: 2020 2020 2020 2020 6966 2061 6c70 6861          if alpha
+00029780: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00029790: 2020 2020 2020 616c 7068 6120 3d20 7365        alpha = se
+000297a0: 6c66 2e74 6f74 616c 5f6e 6f64 655f 7765  lf.total_node_we
+000297b0: 6967 6874 202f 206b 2e64 6f74 2877 290a  ight / k.dot(w).
+000297c0: 2020 2020 2020 2020 7265 7475 726e 2028          return (
+000297d0: 0a20 2020 2020 2020 2020 2020 2065 7870  .            exp
+000297e0: 6d28 6e70 2e6c 6f67 2832 2e30 2920 2a20  m(np.log(2.0) * 
+000297f0: 2841 706c 7573 202a 2061 6c70 6861 202a  (Aplus * alpha *
+00029800: 2077 202d 2073 702e 6964 656e 7469 7479   w - sp.identity
+00029810: 284e 2929 292e 646f 7428 4170 6c75 7329  (N))).dot(Aplus)
+00029820: 0a20 2020 2020 2020 2020 2020 202a 2077  .            * w
+00029830: 2e72 6573 6861 7065 2828 4e2c 2031 2929  .reshape((N, 1))
+00029840: 292e 7375 6d28 6178 6973 3d30 290a 0a20  ).sum(axis=0).. 
+00029850: 2020 2064 6566 2064 6f5f 6e73 695f 7063     def do_nsi_pc
+00029860: 615f 636c 7573 7465 7269 6e67 2873 656c  a_clustering(sel
+00029870: 662c 206d 6178 5f6e 5f63 6c75 7374 6572  f, max_n_cluster
+00029880: 733d 4e6f 6e65 293a 0a20 2020 2020 2020  s=None):.       
+00029890: 2022 2222 0a20 2020 2020 2020 2050 6572   """.        Per
+000298a0: 666f 726d 2061 2063 6c75 7374 6572 696e  form a clusterin
+000298b0: 6720 6f66 2074 6865 206e 6f64 6573 2075  g of the nodes u
+000298c0: 7369 6e67 2070 7269 6e63 6970 616c 2063  sing principal c
+000298d0: 6f6d 706f 6e65 6e74 7320 616e 616c 7973  omponents analys
+000298e0: 6973 2e0a 0a20 2020 2020 2020 2050 6572  is...        Per
+000298f0: 666f 726d 2061 2050 4341 2066 6f72 2074  form a PCA for t
+00029900: 6865 2063 6f6c 756d 6e73 206f 6620 7468  he columns of th
+00029910: 6520 6164 6a61 6365 6e63 7920 6d61 7472  e adjacency matr
+00029920: 6978 2c20 6578 7472 6163 7420 7468 650a  ix, extract the.
+00029930: 2020 2020 2020 2020 6c61 7267 6573 7420          largest 
+00029940: 6569 6765 6e76 616c 7565 732c 2061 6e64  eigenvalues, and
+00029950: 2061 7373 6967 6e20 6561 6368 206e 6f64   assign each nod
+00029960: 6520 746f 2074 6861 7420 6569 6765 6e76  e to that eigenv
+00029970: 616c 7565 2077 686f 7365 0a20 2020 2020  alue whose.     
+00029980: 2020 2065 6967 656e 7665 6374 6f72 2065     eigenvector e
+00029990: 7870 6c61 696e 7320 7468 6520 6c61 7267  xplains the larg
+000299a0: 6573 7420 616d 6f75 6e74 206f 6620 7468  est amount of th
+000299b0: 6520 6e6f 6465 2773 2063 6f6c 756d 6e27  e node's column'
+000299c0: 730a 2020 2020 2020 2020 7661 7269 616e  s.        varian
+000299d0: 6365 2c20 692e 652e 2074 6865 206f 6e65  ce, i.e. the one
+000299e0: 2074 6861 7420 6d61 7869 6d69 7a65 7320   that maximizes 
+000299f0: 7468 6520 7661 6c75 6520 6f66 2065 6967  the value of eig
+00029a00: 656e 7661 6c75 6520 2a0a 2020 2020 2020  envalue *.      
+00029a10: 2020 636f 7272 6573 706f 6e64 696e 6720    corresponding 
+00029a20: 6661 6374 6f72 206c 6f61 6420 6f6e 2074  factor load on t
+00029a30: 6861 7420 6e6f 6465 2773 2063 6f6c 756d  hat node's colum
+00029a40: 6e2e 0a0a 2020 2020 2020 2020 2e2e 206e  n...        .. n
+00029a50: 6f74 653a 3a0a 2020 2020 2020 2020 2020  ote::.          
+00029a60: 2054 6869 7320 6973 2073 7469 6c6c 2045   This is still E
+00029a70: 5850 4552 494d 454e 5441 4c21 0a0a 2020  XPERIMENTAL!..  
+00029a80: 2020 2020 2020 3a74 7970 6520 6d61 785f        :type max_
+00029a90: 6e5f 636c 7573 7465 7273 3a20 696e 7420  n_clusters: int 
+00029aa0: 3e3d 2031 0a20 2020 2020 2020 203a 6172  >= 1.        :ar
+00029ab0: 6720 206d 6178 5f6e 5f63 6c75 7374 6572  g  max_n_cluster
+00029ac0: 733a 204e 756d 6265 7220 6f66 2063 6c75  s: Number of clu
+00029ad0: 7374 6572 7320 746f 2066 696e 6420 6174  sters to find at
+00029ae0: 206d 6f73 742e 0a20 2020 2020 2020 2020   most..         
+00029af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00029b00: 2020 2020 2028 4465 6661 756c 743a 2063       (Default: c
+00029b10: 6569 6c28 7371 7274 284e 2929 290a 0a20  eil(sqrt(N))).. 
+00029b20: 2020 2020 2020 203a 7274 7970 653a 2074         :rtype: t
+00029b30: 7570 6c65 2028 6c69 7374 5b6e 6f64 655d  uple (list[node]
+00029b40: 2c20 6c69 7374 5b6e 6f64 655d 2c20 6c69  , list[node], li
+00029b50: 7374 5b63 6c75 7374 6572 5d2c 2032 6420  st[cluster], 2d 
+00029b60: 6e75 6d70 7920 6172 7261 7929 0a20 2020  numpy array).   
+00029b70: 2020 2020 203a 7265 7475 726e 3a20 4120       :return: A 
+00029b80: 6c69 7374 206f 6620 636c 7573 7465 7220  list of cluster 
+00029b90: 696e 6469 6365 7320 666f 7220 6561 6368  indices for each
+00029ba0: 206e 6f64 652c 0a20 2020 2020 2020 2020   node,.         
+00029bb0: 2020 2020 2020 2020 6120 6c69 7374 2077          a list w
+00029bc0: 6974 6820 7468 6520 6672 6163 7469 6f6e  ith the fraction
+00029bd0: 206f 6620 7468 6520 6e6f 6465 2773 2063   of the node's c
+00029be0: 6f6c 756d 6e27 7320 7661 7269 616e 6365  olumn's variance
+00029bf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00029c00: 2020 6578 706c 6169 6e65 6420 6279 2063    explained by c
+00029c10: 686f 7365 6e20 6569 6765 6e76 6563 746f  hosen eigenvecto
+00029c20: 722c 2066 6f72 2065 6163 6820 6e6f 6465  r, for each node
+00029c30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00029c40: 2020 2061 206c 6973 7420 6f66 2065 6967     a list of eig
+00029c50: 656e 7661 6c75 6573 2063 6f72 7265 7370  envalues corresp
+00029c60: 6f6e 6469 6e67 2074 6f20 6561 6368 2063  onding to each c
+00029c70: 6c75 7374 6572 2c0a 2020 2020 2020 2020  luster,.        
+00029c80: 2020 2020 2020 2020 2061 6e64 2061 6e20           and an 
+00029c90: 6172 7261 7920 7768 6f73 6520 636f 6c75  array whose colu
+00029ca0: 6d6e 7320 6172 6520 7468 6520 636f 7272  mns are the corr
+00029cb0: 6573 706f 6e64 696e 6720 6569 6765 6e76  esponding eigenv
+00029cc0: 6563 746f 7273 0a20 2020 2020 2020 2022  ectors.        "
+00029cd0: 2222 0a20 2020 2020 2020 2023 2054 4f44  "".        # TOD
+00029ce0: 4f3a 2077 6f72 6b73 206f 6e6c 7920 666f  O: works only fo
+00029cf0: 7220 756e 6469 7265 6374 6564 2067 7261  r undirected gra
+00029d00: 7068 7320 736f 2066 6172 2e20 466f 7220  phs so far. For 
+00029d10: 6469 7265 6374 6564 2c20 410a 2020 2020  directed, A.    
+00029d20: 2020 2020 2320 7374 6163 6b65 6420 7769      # stacked wi
+00029d30: 7468 2069 7473 2074 7261 6e73 706f 7365  th its transpose
+00029d40: 2077 6f75 6c64 2068 6176 6520 746f 2062   would have to b
+00029d50: 6520 7573 6564 210a 0a20 2020 2020 2020  e used!..       
+00029d60: 2023 2043 5353 2028 636f 7272 6563 7465   # CSS (correcte
+00029d70: 6420 7375 6d20 6f66 2073 7175 6172 6573  d sum of squares
+00029d80: 293b 2070 726f 706f 7274 696f 6e61 6c20  ); proportional 
+00029d90: 746f 2063 6f76 6172 6961 6e63 6520 6d61  to covariance ma
+00029da0: 7472 6978 0a20 2020 2020 2020 2044 7752  trix.        DwR
+00029db0: 203d 2073 656c 662e 7370 5f64 6961 675f   = self.sp_diag_
+00029dc0: 7371 7274 5f77 2829 0a20 2020 2020 2020  sqrt_w().       
+00029dd0: 2044 4144 203d 2044 7752 202a 2073 656c   DAD = DwR * sel
+00029de0: 662e 7370 5f41 706c 7573 2829 202a 2044  f.sp_Aplus() * D
+00029df0: 7752 0a20 2020 2020 2020 2063 6f72 7220  wR.        corr 
+00029e00: 3d20 7365 6c66 2e6e 7369 5f64 6567 7265  = self.nsi_degre
+00029e10: 6528 2920 2a20 6e70 2e73 7172 7428 7365  e() * np.sqrt(se
+00029e20: 6c66 2e6e 6f64 655f 7765 6967 6874 7329  lf.node_weights)
+00029e30: 0a20 2020 2020 2020 2043 5353 203d 2044  .        CSS = D
+00029e40: 4144 202a 2044 4144 202d 206e 702e 6f75  AD * DAD - np.ou
+00029e50: 7465 7228 636f 7272 2c20 636f 7272 2920  ter(corr, corr) 
+00029e60: 2f20 7365 6c66 2e74 6f74 616c 5f6e 6f64  / self.total_nod
+00029e70: 655f 7765 6967 6874 0a0a 2020 2020 2020  e_weight..      
+00029e80: 2020 2320 6578 7472 6163 7420 6d61 785f    # extract max_
+00029e90: 6e5f 636c 7573 7465 7273 206c 6172 6765  n_clusters large
+00029ea0: 7374 2065 6967 656e 7661 6c75 6573 2061  st eigenvalues a
+00029eb0: 6e64 2065 6967 656e 7665 6374 6f72 7320  nd eigenvectors 
+00029ec0: 6672 6f6d 2043 5353 0a20 2020 2020 2020  from CSS.       
+00029ed0: 204e 203d 2073 656c 662e 4e0a 2020 2020   N = self.N.    
+00029ee0: 2020 2020 6966 206d 6178 5f6e 5f63 6c75      if max_n_clu
+00029ef0: 7374 6572 7320 6973 204e 6f6e 653a 0a20  sters is None:. 
+00029f00: 2020 2020 2020 2020 2020 206d 6178 5f6e             max_n
+00029f10: 5f63 6c75 7374 6572 7320 3d20 696e 7428  _clusters = int(
+00029f20: 6e70 2e63 6569 6c28 6e70 2e73 7172 7428  np.ceil(np.sqrt(
+00029f30: 4e29 2929 0a20 2020 2020 2020 2023 2074  N))).        # t
+00029f40: 6f74 616c 2076 6172 6961 6e63 6520 6973  otal variance is
+00029f50: 2070 726f 706f 7274 696f 6e61 6c20 746f   proportional to
+00029f60: 2074 7261 6365 206f 6620 4353 530a 2020   trace of CSS.  
+00029f70: 2020 2020 2020 7661 7220 3d20 4353 532e        var = CSS.
+00029f80: 6469 6167 6f6e 616c 2829 2e41 5b30 5d0a  diagonal().A[0].
+00029f90: 0a20 2020 2020 2020 2023 2074 6172 6765  .        # targe
+00029fa0: 7420 6569 6765 6e76 616c 7565 2028 6b6e  t eigenvalue (kn
+00029fb0: 6f77 6e20 7570 7065 7220 626f 756e 6429  own upper bound)
+00029fc0: 202d 3e20 6c61 7267 6573 7420 6569 6765   -> largest eige
+00029fd0: 6e76 616c 7565 730a 2020 2020 2020 2020  nvalues.        
+00029fe0: 7461 7520 3d20 7375 6d28 7661 7229 0a20  tau = sum(var). 
+00029ff0: 2020 2020 2020 2065 7661 6c73 2c20 6576         evals, ev
+0002a000: 6563 7320 3d20 6569 6773 6828 4353 532c  ecs = eigsh(CSS,
+0002a010: 206b 3d6d 6178 5f6e 5f63 6c75 7374 6572   k=max_n_cluster
+0002a020: 732c 2073 6967 6d61 3d74 6175 2c0a 2020  s, sigma=tau,.  
+0002a030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a040: 2020 2020 2020 2020 2020 206d 6178 6974             maxit
+0002a050: 6572 3d31 3030 2a6d 6178 5f6e 5f63 6c75  er=100*max_n_clu
+0002a060: 7374 6572 732c 2074 6f6c 3d31 652d 3829  sters, tol=1e-8)
+0002a070: 0a0a 2020 2020 2020 2020 2320 6672 6163  ..        # frac
+0002a080: 7469 6f6e 206f 6620 6e6f 6465 2773 2076  tion of node's v
+0002a090: 6172 6961 6e63 6520 6578 706c 6169 6e65  ariance explaine
+0002a0a0: 6420 6279 2065 6163 6820 6569 6765 6e76  d by each eigenv
+0002a0b0: 6563 746f 720a 2020 2020 2020 2020 6578  ector.        ex
+0002a0c0: 706c 6169 6e65 645f 7661 7220 3d20 6e70  plained_var = np
+0002a0d0: 2e70 6f77 6572 2865 7665 6373 2c20 322e  .power(evecs, 2.
+0002a0e0: 3029 202a 2065 7661 6c73 2e72 6573 6861  0) * evals.resha
+0002a0f0: 7065 2828 312c 2065 7661 6c73 2e73 697a  pe((1, evals.siz
+0002a100: 6529 290a 0a20 2020 2020 2020 2023 2061  e))..        # a
+0002a110: 7373 6967 6e20 6561 6368 206e 6f64 6520  ssign each node 
+0002a120: 746f 2063 6c75 7374 6572 2032 2a69 206f  to cluster 2*i o
+0002a130: 7220 322a 692b 310a 2020 2020 2020 2020  r 2*i+1.        
+0002a140: 2320 666f 7220 7468 6174 2065 6967 656e  # for that eigen
+0002a150: 7665 6374 6f72 2069 2077 6869 6368 2065  vector i which e
+0002a160: 7870 6c61 696e 7320 7468 6520 6c61 7267  xplains the larg
+0002a170: 6573 7420 7061 7274 206f 6620 7468 6520  est part of the 
+0002a180: 6e6f 6465 2773 0a20 2020 2020 2020 2023  node's.        #
+0002a190: 2076 6172 6961 6e63 652e 2020 6173 7369   variance.  assi
+0002a1a0: 676e 206e 6f64 6520 746f 2063 6c75 7374  gn node to clust
+0002a1b0: 6572 2032 2a69 2069 6620 6569 6765 6e76  er 2*i if eigenv
+0002a1c0: 6563 746f 7220 706f 7369 7469 7665 2061  ector positive a
+0002a1d0: 7420 7468 650a 2020 2020 2020 2020 2320  t the.        # 
+0002a1e0: 6e6f 6465 2c20 6f74 6865 7277 6973 6520  node, otherwise 
+0002a1f0: 746f 2063 6c75 7374 6572 2032 2a69 2b31  to cluster 2*i+1
+0002a200: 3a0a 2020 2020 2020 2020 636c 7573 7465  :.        cluste
+0002a210: 725f 696e 6465 7820 3d20 3220 2a20 6e70  r_index = 2 * np
+0002a220: 2e61 7267 6d61 7828 6578 706c 6169 6e65  .argmax(explaine
+0002a230: 645f 7661 722c 2061 7869 733d 3129 0a20  d_var, axis=1). 
+0002a240: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+0002a250: 7261 6e67 6528 302c 204e 293a 0a20 2020  range(0, N):.   
+0002a260: 2020 2020 2020 2020 2069 6620 6576 6563           if evec
+0002a270: 735b 692c 2063 6c75 7374 6572 5f69 6e64  s[i, cluster_ind
+0002a280: 6578 5b69 5d2f 325d 203c 2030 2e30 3a0a  ex[i]/2] < 0.0:.
+0002a290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a2a0: 636c 7573 7465 725f 696e 6465 785b 695d  cluster_index[i]
+0002a2b0: 202b 3d20 310a 0a20 2020 2020 2020 2063   += 1..        c
+0002a2c0: 6c75 7374 6572 5f65 7870 6c61 696e 6564  luster_explained
+0002a2d0: 5f76 6172 203d 206e 702e 6d61 7828 6578  _var = np.max(ex
+0002a2e0: 706c 6169 6e65 645f 7661 722c 2061 7869  plained_var, axi
+0002a2f0: 733d 3129 0a20 2020 2020 2020 2063 6c75  s=1).        clu
+0002a300: 7374 6572 5f69 6e64 6578 5f73 6574 203d  ster_index_set =
+0002a310: 2073 6574 2863 6c75 7374 6572 5f69 6e64   set(cluster_ind
+0002a320: 6578 290a 2020 2020 2020 2020 636c 7573  ex).        clus
+0002a330: 7465 725f 7369 7a65 7320 3d20 6e70 2e7a  ter_sizes = np.z
+0002a340: 6572 6f73 286d 6178 2863 6c75 7374 6572  eros(max(cluster
+0002a350: 5f69 6e64 6578 5f73 6574 292b 3129 0a20  _index_set)+1). 
+0002a360: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+0002a370: 7261 6e67 6528 302c 204e 293a 0a20 2020  range(0, N):.   
+0002a380: 2020 2020 2020 2020 2063 6c75 7374 6572           cluster
+0002a390: 5f73 697a 6573 5b63 6c75 7374 6572 5f69  _sizes[cluster_i
+0002a3a0: 6e64 6578 5b69 5d5d 202b 3d20 7365 6c66  ndex[i]] += self
+0002a3b0: 2e6e 6f64 655f 7765 6967 6874 735b 695d  .node_weights[i]
+0002a3c0: 0a20 2020 2020 2020 2063 6c75 7374 6572  .        cluster
+0002a3d0: 5f73 697a 6573 203d 2063 6c75 7374 6572  _sizes = cluster
+0002a3e0: 5f73 697a 6573 5b6c 6973 7428 636c 7573  _sizes[list(clus
+0002a3f0: 7465 725f 696e 6465 785f 7365 7429 5d0a  ter_index_set)].
+0002a400: 2020 2020 2020 2020 636c 7573 7465 725f          cluster_
+0002a410: 6669 7420 3d20 636c 7573 7465 725f 6578  fit = cluster_ex
+0002a420: 706c 6169 6e65 645f 7661 7220 2f20 7661  plained_var / va
+0002a430: 720a 2020 2020 2020 2020 6966 2073 656c  r.        if sel
+0002a440: 662e 7369 6c65 6e63 655f 6c65 7665 6c20  f.silence_level 
+0002a450: 3c3d 2031 3a0a 2020 2020 2020 2020 2020  <= 1:.          
+0002a460: 2020 7072 696e 7428 226d 6178 5f6e 5f63    print("max_n_c
+0002a470: 6c75 7374 6572 7320 7761 7322 2c20 6d61  lusters was", ma
+0002a480: 785f 6e5f 636c 7573 7465 7273 290a 2020  x_n_clusters).  
+0002a490: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0002a4a0: 6622 666f 756e 6420 7b6c 656e 2865 7661  f"found {len(eva
+0002a4b0: 6c73 297d 2065 6967 656e 7661 6c75 6573  ls)} eigenvalues
+0002a4c0: 2061 6e64 2022 0a20 2020 2020 2020 2020   and ".         
+0002a4d0: 2020 2020 2020 2020 2066 227b 6c65 6e28           f"{len(
+0002a4e0: 636c 7573 7465 725f 696e 6465 785f 7365  cluster_index_se
+0002a4f0: 7429 7d20 636c 7573 7465 7273 2229 0a20  t)} clusters"). 
+0002a500: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0002a510: 2866 2263 6c75 7374 6572 2073 697a 6573  (f"cluster sizes
+0002a520: 2072 616e 6765 2066 726f 6d20 7b63 6c75   range from {clu
+0002a530: 7374 6572 5f73 697a 6573 2e6d 696e 2829  ster_sizes.min()
+0002a540: 7d20 746f 2022 0a20 2020 2020 2020 2020  } to ".         
+0002a550: 2020 2020 2020 2020 2066 227b 636c 7573           f"{clus
+0002a560: 7465 725f 7369 7a65 732e 6d61 7828 297d  ter_sizes.max()}
+0002a570: 2077 6974 6820 6d65 6469 616e 2022 0a20   with median ". 
+0002a580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a590: 2066 227b 6e70 2e6d 6564 6961 6e28 636c   f"{np.median(cl
+0002a5a0: 7573 7465 725f 7369 7a65 7329 7d3a 207b  uster_sizes)}: {
+0002a5b0: 636c 7573 7465 725f 7369 7a65 737d 2229  cluster_sizes}")
+0002a5c0: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+0002a5d0: 6e74 2866 226d 6178 2061 6e64 206d 696e  nt(f"max and min
+0002a5e0: 2066 6f75 6e64 2065 6967 656e 7661 6c75   found eigenvalu
+0002a5f0: 6573 2061 7265 207b 6d61 7828 6576 616c  es are {max(eval
+0002a600: 7329 7d20 616e 6420 220a 2020 2020 2020  s)} and ".      
+0002a610: 2020 2020 2020 2020 2020 2020 6622 7b6d              f"{m
+0002a620: 696e 2865 7661 6c73 297d 2028 6176 6572  in(evals)} (aver
+0002a630: 6167 6520 6f66 2061 6c6c 2077 6173 207b  age of all was {
+0002a640: 7461 752f 4e7d 2922 290a 2020 2020 2020  tau/N})").      
+0002a650: 2020 2020 2020 7072 696e 7428 6622 7063        print(f"pc
+0002a660: 6120 616e 6420 636c 7573 7465 7273 2065  a and clusters e
+0002a670: 7870 6c61 696e 207b 7375 6d28 6576 616c  xplain {sum(eval
+0002a680: 7329 2f74 6175 7d20 616e 6420 220a 2020  s)/tau} and ".  
+0002a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a6a0: 6622 7b73 756d 2863 6c75 7374 6572 5f65  f"{sum(cluster_e
+0002a6b0: 7870 6c61 696e 6564 5f76 6172 292f 7461  xplained_var)/ta
+0002a6c0: 757d 206f 6620 746f 7461 6c20 7661 7269  u} of total vari
+0002a6d0: 616e 6365 2e22 290a 0a20 2020 2020 2020  ance.")..       
+0002a6e0: 2072 6574 7572 6e20 2863 6c75 7374 6572   return (cluster
+0002a6f0: 5f69 6e64 6578 2c20 2023 2063 6c75 7374  _index,  # clust
+0002a700: 6572 5f69 6e64 6578 2066 6f72 2065 6163  er_index for eac
+0002a710: 6820 6e6f 6465 0a20 2020 2020 2020 2020  h node.         
+0002a720: 2020 2020 2020 2063 6c75 7374 6572 5f66         cluster_f
+0002a730: 6974 2c20 2020 2023 2066 7261 6374 696f  it,    # fractio
+0002a740: 6e20 6f66 206e 6f64 6527 7320 7661 7269  n of node's vari
+0002a750: 616e 6365 2065 7870 6c61 696e 6564 2062  ance explained b
+0002a760: 790a 2020 2020 2020 2020 2020 2020 2020  y.              
+0002a770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a780: 2020 2320 6368 6f73 656e 2065 6967 656e    # chosen eigen
+0002a790: 7665 6374 6f72 2c20 666f 7220 6561 6368  vector, for each
+0002a7a0: 206e 6f64 650a 2020 2020 2020 2020 2020   node.          
+0002a7b0: 2020 2020 2020 6576 616c 732c 2020 2020        evals,    
+0002a7c0: 2020 2020 2020 2320 6569 6765 6e76 616c        # eigenval
+0002a7d0: 7565 730a 2020 2020 2020 2020 2020 2020  ues.            
+0002a7e0: 2020 2020 6576 6563 7329 2020 2020 2020      evecs)      
+0002a7f0: 2020 2020 2320 6d61 7472 6978 2077 6974      # matrix wit
+0002a800: 6820 636f 6c75 6d6e 733d 6569 6765 6e76  h columns=eigenv
+0002a810: 6563 746f 7273 0a0a 2020 2020 6465 6620  ectors..    def 
+0002a820: 646f 5f6e 7369 5f63 6c75 7374 6572 696e  do_nsi_clusterin
+0002a830: 6728 7365 6c66 2c20 6430 3d4e 6f6e 652c  g(self, d0=None,
+0002a840: 2074 7265 655f 646f 7466 696c 653d 4e6f   tree_dotfile=No
+0002a850: 6e65 2c0a 2020 2020 2020 2020 2020 2020  ne,.            
+0002a860: 2020 2020 2020 2020 2020 2020 2020 6469                di
+0002a870: 7374 616e 6365 733d 4e6f 6e65 2c20 6361  stances=None, ca
+0002a880: 6e64 6964 6174 6573 3d4e 6f6e 6529 3a0a  ndidates=None):.
+0002a890: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0002a8a0: 2020 2020 5065 7266 6f72 6d20 6167 676c      Perform aggl
+0002a8b0: 6f6d 6572 6174 6976 6520 636c 7573 7465  omerative cluste
+0002a8c0: 7269 6e67 2062 6173 6564 206f 6e20 7265  ring based on re
+0002a8d0: 7072 6573 656e 7461 7469 6f6e 2061 6363  presentation acc
+0002a8e0: 7572 6163 792e 0a0a 2020 2020 2020 2020  uracy...        
+0002a8f0: 5468 6973 206d 696e 696d 697a 6573 2069  This minimizes i
+0002a900: 6e20 6561 6368 2073 7465 7020 7468 6520  n each step the 
+0002a910: 6d65 616e 2073 7175 6172 6564 2065 7272  mean squared err
+0002a920: 6f72 206f 6620 7265 7072 6573 656e 7469  or of representi
+0002a930: 6e67 2074 6865 0a20 2020 2020 2020 2070  ng the.        p
+0002a940: 6169 7277 6973 6520 6e6f 6465 2064 6973  airwise node dis
+0002a950: 7461 6e63 6573 2062 7920 7468 6569 7220  tances by their 
+0002a960: 636c 7573 7465 7220 6176 6572 6167 6573  cluster averages
+0002a970: 2e0a 0a20 2020 2020 2020 202e 2e20 6e6f  ...        .. no
+0002a980: 7465 3a3a 0a20 2020 2020 2020 2020 2020  te::.           
+0002a990: 5468 6973 2069 7320 7374 696c 6c20 4558  This is still EX
+0002a9a0: 5045 5249 4d45 4e54 414c 210a 0a20 2020  PERIMENTAL!..   
+0002a9b0: 2020 2020 2053 6565 2074 6865 2063 6f64       See the cod
+0002a9c0: 6520 666f 7220 6172 6775 6d65 6e74 7320  e for arguments 
+0002a9d0: 616e 6420 7265 7475 726e 2076 616c 7565  and return value
+0002a9e0: 2e0a 0a20 2020 2020 2020 2043 6c75 7374  ...        Clust
+0002a9f0: 6572 7320 302e 2e2e 6e2d 3120 6172 6520  ers 0...n-1 are 
+0002aa00: 7468 6520 7369 6e67 6c65 746f 6e73 2028  the singletons (
+0002aa10: 636c 7573 7465 7220 6920 636f 6e74 6169  cluster i contai
+0002aa20: 6e69 6e67 206a 7573 7420 6e6f 6465 2069  ning just node i
+0002aa30: 292e 0a20 2020 2020 2020 2043 6c75 7374  )..        Clust
+0002aa40: 6572 7320 6e2e 2e2e 326e 2d32 2061 7265  ers n...2n-2 are
+0002aa50: 206e 756d 6265 7265 6420 696e 2074 6865   numbered in the
+0002aa60: 206f 7264 6572 2069 6e20 7768 6963 6820   order in which 
+0002aa70: 636c 7573 7465 7273 2061 7265 0a20 2020  clusters are.   
+0002aa80: 2020 2020 206a 6f69 6e65 6420 2861 2063       joined (a c
+0002aa90: 6c75 7374 6572 2077 6974 6820 6964 2063  luster with id c
+0002aaa0: 2069 7320 6120 756e 696f 6e20 6f66 2074   is a union of t
+0002aab0: 776f 2065 6172 6c69 6572 2063 6c75 7374  wo earlier clust
+0002aac0: 6572 7320 7769 7468 0a20 2020 2020 2020  ers with.       
+0002aad0: 2069 6473 2063 312c 6332 203c 2063 292e   ids c1,c2 < c).
+0002aae0: 2049 6e20 7061 7274 6963 756c 6172 2c20   In particular, 
+0002aaf0: 636c 7573 7465 7220 326e 2d32 2069 7320  cluster 2n-2 is 
+0002ab00: 7468 6520 6675 6c6c 2073 6574 206f 6620  the full set of 
+0002ab10: 6e6f 6465 732e 0a0a 2020 2020 2020 2020  nodes...        
+0002ab20: 3a72 7479 7065 3a20 2064 6963 7469 6f6e  :rtype:  diction
+0002ab30: 6172 790a 2020 2020 2020 2020 3a72 6574  ary.        :ret
+0002ab40: 7572 6e3a 2041 2064 6963 7469 6f6e 6172  urn: A dictionar
+0002ab50: 7920 636f 6e74 6169 6e69 6e67 2074 6865  y containing the
+0002ab60: 2066 6f6c 6c6f 7769 6e67 206b 6579 733a   following keys:
+0002ab70: 0a0a 2020 2020 2020 2020 2020 202d 2022  ..           - "
+0002ab80: 6d69 6e5f 636c 7573 7465 7273 223a 2069  min_clusters": i
+0002ab90: 6e74 203e 2030 2e20 536d 616c 6c65 7374  nt > 0. Smallest
+0002aba0: 206e 756d 6265 7220 6f66 2063 6c75 7374   number of clust
+0002abb0: 6572 7320 6765 6e65 7261 7465 642e 0a20  ers generated.. 
+0002abc0: 2020 2020 2020 2020 2020 2d20 2265 7272            - "err
+0002abd0: 6f72 223a 2061 7272 6179 286e 2b31 292e  or": array(n+1).
+0002abe0: 2045 6e74 7279 205b 6b5d 2069 7320 7468   Entry [k] is th
+0002abf0: 6520 7265 7072 6573 656e 7461 7469 6f6e  e representation
+0002ac00: 2065 7272 6f72 2066 6f72 2074 6865 0a20   error for the. 
+0002ac10: 2020 2020 2020 2020 2020 2020 736f 6c75              solu
+0002ac20: 7469 6f6e 2077 6974 6820 6b20 636c 7573  tion with k clus
+0002ac30: 7465 7273 2e0a 2020 2020 2020 2020 2020  ters..          
+0002ac40: 202d 2022 6e6f 6465 3263 6c75 7374 6572   - "node2cluster
+0002ac50: 223a 2061 7272 6179 286e 2c6e 2b31 292e  ": array(n,n+1).
+0002ac60: 2045 6e74 7279 205b 692c 6b5d 2069 7320   Entry [i,k] is 
+0002ac70: 7468 6520 6964 206f 6620 7468 6520 636c  the id of the cl
+0002ac80: 7573 7465 720a 2020 2020 2020 2020 2020  uster.          
+0002ac90: 2020 2074 6861 7420 636f 6e74 6169 6e73     that contains
+0002aca0: 206e 6f64 6520 6920 696e 2074 6865 2073   node i in the s
+0002acb0: 6f6c 7574 696f 6e20 7769 7468 206b 2063  olution with k c
+0002acc0: 6c75 7374 6572 732e 0a20 2020 2020 2020  lusters..       
+0002acd0: 2020 2020 2d20 2263 6c75 7374 6572 5f77      - "cluster_w
+0002ace0: 6569 6768 7422 3a20 6172 7261 7928 326e  eight": array(2n
+0002acf0: 2d31 292e 2045 6e74 7279 205b 635d 2069  -1). Entry [c] i
+0002ad00: 7320 7468 6520 746f 7461 6c20 7765 6967  s the total weig
+0002ad10: 6874 206f 660a 2020 2020 2020 2020 2020  ht of.          
+0002ad20: 2020 2063 6c75 7374 6572 2063 2e0a 2020     cluster c..  
+0002ad30: 2020 2020 2020 2020 202d 2022 636c 7573           - "clus
+0002ad40: 7465 7232 7261 6e6b 223a 2061 7272 6179  ter2rank": array
+0002ad50: 2832 6e2d 312c 6e2b 3129 2e20 456e 7472  (2n-1,n+1). Entr
+0002ad60: 7920 5b63 2c6b 5d20 6973 2074 6865 2064  y [c,k] is the d
+0002ad70: 6573 6365 6e64 696e 670a 2020 2020 2020  escending.      
+0002ad80: 2020 2020 2020 206f 7264 6572 2072 616e         order ran
+0002ad90: 6b20 6f66 2063 6c75 7374 6572 2063 2069  k of cluster c i
+0002ada0: 6e20 7468 6520 6b2d 636c 7573 7465 7220  n the k-cluster 
+0002adb0: 736f 6c75 7469 6f6e 2c20 692e 652e 2c20  solution, i.e., 
+0002adc0: 7468 650a 2020 2020 2020 2020 2020 2020  the.            
+0002add0: 206e 756d 6265 7220 6f66 206c 6172 6765   number of large
+0002ade0: 7220 636c 7573 7465 7273 2069 6e20 7468  r clusters in th
+0002adf0: 6174 2073 6f6c 7574 696f 6e2e 2055 7365  at solution. Use
+0002ae00: 2074 6869 7320 746f 2063 6f6e 7665 7274   this to convert
+0002ae10: 0a20 2020 2020 2020 2020 2020 2020 636c  .             cl
+0002ae20: 7573 7465 7220 6964 7320 696e 2030 2e2e  uster ids in 0..
+0002ae30: 2e32 6e2d 3120 746f 2063 6c75 7374 6572  .2n-1 to cluster
+0002ae40: 2069 6473 2069 6e20 302e 2e2e 6b2d 312e   ids in 0...k-1.
+0002ae50: 0a20 2020 2020 2020 2020 2020 2d20 226e  .           - "n
+0002ae60: 6f64 655f 696e 5f63 6c75 7374 6572 223a  ode_in_cluster":
+0002ae70: 2061 7272 6179 286e 2c32 6e2d 3129 2e20   array(n,2n-1). 
+0002ae80: 456e 7472 7920 5b69 2c63 5d20 696e 6469  Entry [i,c] indi
+0002ae90: 6361 7465 7320 7768 6574 6865 720a 2020  cates whether.  
+0002aea0: 2020 2020 2020 2020 2020 206e 6f64 6520             node 
+0002aeb0: 6920 6973 2069 6e20 7468 6520 636c 7573  i is in the clus
+0002aec0: 7465 7220 7769 7468 2069 6420 632e 0a20  ter with id c.. 
+0002aed0: 2020 2020 2020 2020 2020 2d20 2263 6869            - "chi
+0002aee0: 6c64 7265 6e22 3a20 6172 7261 7928 326e  ldren": array(2n
+0002aef0: 2d31 2c32 292e 2045 6e74 7269 6573 205b  -1,2). Entries [
+0002af00: 632c 305d 2061 6e64 205b 632c 315d 2061  c,0] and [c,1] a
+0002af10: 7265 2074 6865 2069 6473 206f 660a 2020  re the ids of.  
+0002af20: 2020 2020 2020 2020 2020 2074 6865 2074             the t
+0002af30: 776f 2063 6c75 7374 6572 7320 7468 6174  wo clusters that
+0002af40: 2077 6572 6520 6a6f 696e 6564 2074 6f20   were joined to 
+0002af50: 6769 7665 2063 6c75 7374 6572 2063 2e0a  give cluster c..
+0002af60: 2020 2020 2020 2020 2020 202d 2022 7369             - "si
+0002af70: 626c 696e 6722 3a20 6172 7261 7928 326e  bling": array(2n
+0002af80: 2d32 292e 2045 6e74 7279 205b 635d 2069  -2). Entry [c] i
+0002af90: 7320 7468 6520 6964 206f 6620 7468 6520  s the id of the 
+0002afa0: 636c 7573 7465 7220 7769 7468 0a20 2020  cluster with.   
+0002afb0: 2020 2020 2020 2020 2020 7768 6963 6820            which 
+0002afc0: 636c 7573 7465 7220 6320 6973 206a 6f69  cluster c is joi
+0002afd0: 6e65 642e 0a20 2020 2020 2020 2020 2020  ned..           
+0002afe0: 2d20 2270 6172 656e 7422 3a20 6172 7261  - "parent": arra
+0002aff0: 7928 326e 2d32 292e 2045 6e74 7279 205b  y(2n-2). Entry [
+0002b000: 635d 2069 7320 7468 6520 6964 206f 6620  c] is the id of 
+0002b010: 7468 6520 636c 7573 7465 7220 7468 6174  the cluster that
+0002b020: 0a20 2020 2020 2020 2020 2020 2020 7265  .             re
+0002b030: 7375 6c74 7320 6672 6f6d 206a 6f69 6e69  sults from joini
+0002b040: 6e67 2063 6c75 7374 6572 2063 2077 6974  ng cluster c wit
+0002b050: 6820 6974 7320 7369 626c 696e 672e 0a20  h its sibling.. 
+0002b060: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0002b070: 2020 204e 203d 2073 656c 662e 4e0a 2020     N = self.N.  
+0002b080: 2020 2020 2020 4e32 203d 2032 2a4e 202d        N2 = 2*N -
+0002b090: 2031 0a20 2020 2020 2020 2072 4e20 3d20   1.        rN = 
+0002b0a0: 7261 6e67 6528 4e29 0a20 2020 2020 2020  range(N).       
+0002b0b0: 2077 203d 2074 6f5f 6379 2873 656c 662e   w = to_cy(self.
+0002b0c0: 6e6f 6465 5f77 6569 6768 7473 2c20 4649  node_weights, FI
+0002b0d0: 454c 4429 0a20 2020 2020 2020 206b 203d  ELD).        k =
+0002b0e0: 2073 656c 662e 6e73 695f 6465 6772 6565   self.nsi_degree
+0002b0f0: 2829 2020 2320 544f 444f 3a20 6c69 6e6b  ()  # TODO: link
+0002b100: 2077 6569 6768 740a 0a20 2020 2020 2020   weight..       
+0002b110: 2023 2069 6e69 7420 7265 7375 6c74 2073   # init result s
+0002b120: 7472 7563 7475 7265 733a 0a20 2020 2020  tructures:.     
+0002b130: 2020 2065 7272 6f72 203d 206e 702e 7a65     error = np.ze
+0002b140: 726f 7328 4e2b 3129 202b 206e 702e 696e  ros(N+1) + np.in
+0002b150: 660a 2020 2020 2020 2020 6572 726f 725b  f.        error[
+0002b160: 2d31 5d20 3d20 302e 300a 2020 2020 2020  -1] = 0.0.      
+0002b170: 2020 6e6f 6465 3263 6c75 7374 6572 203d    node2cluster =
+0002b180: 206e 702e 7a65 726f 7328 284e 2c20 4e2b   np.zeros((N, N+
+0002b190: 3129 2c20 6474 7970 653d 6e70 2e69 6e74  1), dtype=np.int
+0002b1a0: 3136 290a 2020 2020 2020 2020 6e6f 6465  16).        node
+0002b1b0: 3263 6c75 7374 6572 5b3a 2c20 305d 203d  2cluster[:, 0] =
+0002b1c0: 202d 310a 2020 2020 2020 2020 6e6f 6465   -1.        node
+0002b1d0: 3263 6c75 7374 6572 5b3a 2c20 4e5d 203d  2cluster[:, N] =
+0002b1e0: 2072 4e0a 2020 2020 2020 2020 636c 7573   rN.        clus
+0002b1f0: 7465 725f 7765 6967 6874 203d 206e 702e  ter_weight = np.
+0002b200: 7a65 726f 7328 4e32 290a 2020 2020 2020  zeros(N2).      
+0002b210: 2020 636c 7573 7465 725f 7765 6967 6874    cluster_weight
+0002b220: 5b30 3a4e 5d20 3d20 770a 2020 2020 2020  [0:N] = w.      
+0002b230: 2020 636c 7573 7465 7232 7261 6e6b 203d    cluster2rank =
+0002b240: 206e 702e 7a65 726f 7328 284e 322c 204e   np.zeros((N2, N
+0002b250: 2b31 292c 2064 7479 7065 3d6e 702e 696e  +1), dtype=np.in
+0002b260: 7431 3629 202d 2031 0a20 2020 2020 2020  t16) - 1.       
+0002b270: 2063 6c75 7374 6572 3272 616e 6b5b 302c   cluster2rank[0,
+0002b280: 2031 5d20 3d20 300a 2020 2020 2020 2020   1] = 0.        
+0002b290: 6e6f 6465 5f69 6e5f 636c 7573 7465 7220  node_in_cluster 
+0002b2a0: 3d20 6e70 2e7a 6572 6f73 2828 4e2c 204e  = np.zeros((N, N
+0002b2b0: 3229 2c20 6474 7970 653d 6e70 2e69 6e74  2), dtype=np.int
+0002b2c0: 3829 2020 2320 6f72 2062 6f6f 6c3f 0a20  8)  # or bool?. 
+0002b2d0: 2020 2020 2020 2063 6869 6c64 7265 6e20         children 
+0002b2e0: 3d20 6e70 2e7a 6572 6f73 2828 4e32 2c20  = np.zeros((N2, 
+0002b2f0: 3229 2c20 6474 7970 653d 6e70 2e69 6e74  2), dtype=np.int
+0002b300: 3136 290a 2020 2020 2020 2020 6368 696c  16).        chil
+0002b310: 6472 656e 5b3a 4e5d 203d 202d 310a 2020  dren[:N] = -1.  
+0002b320: 2020 2020 2020 7369 626c 696e 6720 3d20        sibling = 
+0002b330: 6e70 2e7a 6572 6f73 284e 322d 312c 2064  np.zeros(N2-1, d
+0002b340: 7479 7065 3d6e 702e 696e 7431 3629 202d  type=np.int16) -
+0002b350: 2031 0a20 2020 2020 2020 2070 6172 656e   1.        paren
+0002b360: 7420 3d20 6e70 2e7a 6572 6f73 284e 322d  t = np.zeros(N2-
+0002b370: 312c 2064 7479 7065 3d6e 702e 696e 7431  1, dtype=np.int1
+0002b380: 3629 202d 2031 0a20 2020 2020 2020 2063  6) - 1.        c
+0002b390: 6c69 6420 3d20 6e70 2e61 7261 6e67 6528  lid = np.arange(
+0002b3a0: 4e29 0a0a 2020 2020 2020 2020 2320 6120  N)..        # a 
+0002b3b0: 6479 6e61 6d69 6320 646f 7562 6c79 206c  dynamic doubly l
+0002b3c0: 696e 6b65 6420 6c69 7374 206f 6620 6469  inked list of di
+0002b3d0: 7374 616e 6365 206d 6174 7269 7820 656e  stance matrix en
+0002b3e0: 7472 6965 733a 0a20 2020 2020 2020 2023  tries:.        #
+0002b3f0: 2020 445f 6669 7273 7470 6f73 5b63 6c5d    D_firstpos[cl]
+0002b400: 203d 2070 6f73 2e20 6f66 2066 6972 7374   = pos. of first
+0002b410: 206e 622e 206f 6620 636c 2e0a 2020 2020   nb. of cl..    
+0002b420: 2020 2020 2320 2044 5f6c 6173 7470 6f73      #  D_lastpos
+0002b430: 5b63 6c5d 203d 2070 6f73 2e20 6f66 206c  [cl] = pos. of l
+0002b440: 6173 7420 6e62 2e20 6f66 2063 6c2e 0a20  ast nb. of cl.. 
+0002b450: 2020 2020 2020 2023 2020 445f 6e65 7874         #  D_next
+0002b460: 706f 735b 706f 735d 203d 2070 6f73 2e20  pos[pos] = pos. 
+0002b470: 6f66 206e 6578 7420 6e62 2e20 6f66 2074  of next nb. of t
+0002b480: 6865 2073 616d 6520 636c 2e0a 2020 2020  he same cl..    
+0002b490: 2020 2020 2320 2044 5f70 7265 7670 6f73      #  D_prevpos
+0002b4a0: 5b70 6f73 5d20 3d20 706f 732e 206f 6620  [pos] = pos. of 
+0002b4b0: 7072 6576 696f 7573 206e 622e 206f 6620  previous nb. of 
+0002b4c0: 7468 6520 7361 6d6c 6520 636c 2e0a 2020  the samle cl..  
+0002b4d0: 2020 2020 2020 2320 2044 5f63 6c75 7374        #  D_clust
+0002b4e0: 6572 5b70 6f73 5d20 3d20 636c 7573 7465  er[pos] = cluste
+0002b4f0: 7220 696e 6465 7820 6f66 2074 6865 206e  r index of the n
+0002b500: 6569 6768 626f 7572 2061 7420 7468 6973  eighbour at this
+0002b510: 2070 6f73 2e0a 2020 2020 2020 2020 2320   pos..        # 
+0002b520: 2044 5f69 6e76 706f 735b 706f 735d 203d   D_invpos[pos] =
+0002b530: 2070 6f73 2e20 6f66 2063 6c2e 2069 6e20   pos. of cl. in 
+0002b540: 6e62 732e 206c 6973 7420 6f66 206e 6273  nbs. list of nbs
+0002b550: 2e0a 2020 2020 2020 2020 2320 616c 6c20  ..        # all 
+0002b560: 6e65 6564 6564 206c 696e 6b20 6174 7472  needed link attr
+0002b570: 6962 7574 6573 2061 7265 2073 746f 7265  ibutes are store
+0002b580: 6420 7769 7468 2074 6865 2073 616d 6520  d with the same 
+0002b590: 706f 732e 0a20 2020 2020 2020 2023 2077  pos..        # w
+0002b5a0: 6865 6e20 636c 7320 6172 6520 6a6f 696e  hen cls are join
+0002b5b0: 6564 2c20 7468 6520 7265 7370 2e20 6c69  ed, the resp. li
+0002b5c0: 7374 7320 6172 6520 636f 6e63 6174 656e  sts are concaten
+0002b5d0: 6174 6564 2061 6e64 2064 7570 6c69 6361  ated and duplica
+0002b5e0: 7465 730a 2020 2020 2020 2020 2320 6172  tes.        # ar
+0002b5f0: 6520 756e 6c69 6e6b 6564 2028 6275 7420  e unlinked (but 
+0002b600: 7468 6569 7220 706f 732e 206e 6f74 2072  their pos. not r
+0002b610: 6575 7365 6429 2c20 736f 2077 6520 6e65  eused), so we ne
+0002b620: 6564 2032 4d20 6d61 6e79 0a20 2020 2020  ed 2M many.     
+0002b630: 2020 2023 2070 6f73 2e2c 2031 2e2e 2e32     # pos., 1...2
+0002b640: 4d2c 2077 6865 7265 2070 6f73 2030 2072  M, where pos 0 r
+0002b650: 656d 6169 6e73 2065 6d70 7479 3a0a 2020  emains empty:.  
+0002b660: 2020 2020 2020 6966 2064 6973 7461 6e63        if distanc
+0002b670: 6573 2069 7320 4e6f 6e65 3a0a 2020 2020  es is None:.    
+0002b680: 2020 2020 2020 2020 2320 636f 6e74 6169          # contai
+0002b690: 6e73 2065 6163 6820 6c69 6e6b 2074 7769  ns each link twi
+0002b6a0: 6365 210a 2020 2020 2020 2020 2020 2020  ce!.            
+0002b6b0: 6469 7374 616e 6365 5f6b 6579 7320 3d20  distance_keys = 
+0002b6c0: 6e7a 5f63 6f6f 7264 7328 7365 6c66 2e73  nz_coords(self.s
+0002b6d0: 705f 4129 0a20 2020 2020 2020 2065 6c73  p_A).        els
+0002b6e0: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
+0002b6f0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+0002b700: 2020 2020 6469 7374 616e 6365 5f6b 6579      distance_key
+0002b710: 7320 3d20 6469 7374 616e 6365 732e 6b65  s = distances.ke
+0002b720: 7973 2829 0a20 2020 2020 2020 2020 2020  ys().           
+0002b730: 2065 7863 6570 7420 4174 7472 6962 7574   except Attribut
+0002b740: 6545 7272 6f72 3a0a 2020 2020 2020 2020  eError:.        
+0002b750: 2020 2020 2020 2020 6469 7374 616e 6365          distance
+0002b760: 5f6b 6579 7320 3d20 5b28 692c 206a 2920  _keys = [(i, j) 
+0002b770: 666f 7220 6920 696e 2072 616e 6765 284e  for i in range(N
+0002b780: 2920 666f 7220 6a20 696e 2072 616e 6765  ) for j in range
+0002b790: 284e 295d 0a20 2020 2020 2020 204d 203d  (N)].        M =
+0002b7a0: 206c 656e 2864 6973 7461 6e63 655f 6b65   len(distance_ke
+0002b7b0: 7973 290a 2020 2020 2020 2020 724d 203d  ys).        rM =
+0002b7c0: 2072 616e 6765 284d 290a 2020 2020 2020   range(M).      
+0002b7d0: 2020 7270 6f73 203d 2072 616e 6765 2831    rpos = range(1
+0002b7e0: 2c20 4d2b 3129 0a0a 2020 2020 2020 2020  , M+1)..        
+0002b7f0: 445f 6669 7273 7470 6f73 203d 206e 702e  D_firstpos = np.
+0002b800: 7a65 726f 7328 4e2c 204e 4f44 4529 2020  zeros(N, NODE)  
+0002b810: 2320 706f 732e 206f 6620 6669 7273 7420  # pos. of first 
+0002b820: 6e62 2e20 6f66 2063 6c2e 0a20 2020 2020  nb. of cl..     
+0002b830: 2020 2044 5f6c 6173 7470 6f73 203d 206e     D_lastpos = n
+0002b840: 702e 7a65 726f 7328 4e2c 204e 4f44 4529  p.zeros(N, NODE)
+0002b850: 2020 2320 706f 732e 206f 6620 6c61 7374    # pos. of last
+0002b860: 206e 622e 206f 6620 636c 2e0a 2020 2020   nb. of cl..    
+0002b870: 2020 2020 2320 706f 732e 206f 6620 6e65      # pos. of ne
+0002b880: 7874 206e 622e 206f 6620 7468 6520 7361  xt nb. of the sa
+0002b890: 6d65 2063 6c2e 0a20 2020 2020 2020 2044  me cl..        D
+0002b8a0: 5f6e 6578 7470 6f73 203d 206e 702e 7a65  _nextpos = np.ze
+0002b8b0: 726f 7328 322a 4d2b 312c 204e 4f44 4529  ros(2*M+1, NODE)
+0002b8c0: 0a20 2020 2020 2020 2023 2070 6f73 2e20  .        # pos. 
+0002b8d0: 6f66 2070 7265 7669 6f75 7320 6e62 2e20  of previous nb. 
+0002b8e0: 6f66 2074 6865 2073 616d 6c65 2063 6c2e  of the samle cl.
+0002b8f0: 0a20 2020 2020 2020 2044 5f70 7265 7670  .        D_prevp
+0002b900: 6f73 203d 206e 702e 7a65 726f 7328 322a  os = np.zeros(2*
+0002b910: 4d2b 312c 204e 4f44 4529 0a20 2020 2020  M+1, NODE).     
+0002b920: 2020 2023 2070 6f73 2e20 6f66 2063 6c2e     # pos. of cl.
+0002b930: 2069 6e20 6e62 732e 206c 6973 7420 6f66   in nbs. list of
+0002b940: 206e 6273 2e0a 2020 2020 2020 2020 445f   nbs..        D_
+0002b950: 696e 7670 6f73 203d 206e 702e 7a65 726f  invpos = np.zero
+0002b960: 7328 322a 4d2b 312c 204e 4f44 4529 0a20  s(2*M+1, NODE). 
+0002b970: 2020 2020 2020 2023 2063 6c75 7374 6572         # cluster
+0002b980: 2069 6e64 6578 206f 6620 7468 6520 6e65   index of the ne
+0002b990: 6967 6862 6f75 7220 6174 2074 6869 7320  ighbour at this 
+0002b9a0: 706f 732e 0a20 2020 2020 2020 2044 5f63  pos..        D_c
+0002b9b0: 6c75 7374 6572 203d 206e 702e 7a65 726f  luster = np.zero
+0002b9c0: 7328 322a 4d2b 312c 2044 4547 5245 4529  s(2*M+1, DEGREE)
+0002b9d0: 0a0a 2020 2020 2020 2020 2320 636f 6d70  ..        # comp
+0002b9e0: 7574 6520 6176 6572 6167 6520 6469 7374  ute average dist
+0002b9f0: 616e 6365 206f 6620 756e 636f 6e6e 6563  ance of unconnec
+0002ba00: 7465 6420 7061 6972 732c 0a20 2020 2020  ted pairs,.     
+0002ba10: 2020 2023 2077 6869 6368 2077 696c 6c20     # which will 
+0002ba20: 6265 2075 7365 6420 6173 2061 6e20 6573  be used as an es
+0002ba30: 7469 6d61 7465 2066 6f72 2074 6865 6d3a  timate for them:
+0002ba40: 0a20 2020 2020 2020 206e 5f70 6169 7273  .        n_pairs
+0002ba50: 203d 204e 202a 2028 4e2d 3129 202f 2032   = N * (N-1) / 2
+0002ba60: 0a20 2020 2020 2020 2069 6620 6430 2069  .        if d0 i
+0002ba70: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0002ba80: 2020 2020 7430 203d 2074 696d 652e 7469      t0 = time.ti
+0002ba90: 6d65 2829 0a20 2020 2020 2020 2020 2020  me().           
+0002baa0: 2069 6620 6e5f 7061 6972 7320 3e20 4d3a   if n_pairs > M:
+0002bab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002bac0: 2064 3020 3d20 2873 656c 662e 6176 6572   d0 = (self.aver
+0002bad0: 6167 655f 7061 7468 5f6c 656e 6774 6828  age_path_length(
+0002bae0: 292a 312e 3020 2a20 6e5f 7061 6972 7320  )*1.0 * n_pairs 
+0002baf0: 2d20 4d29 202f 5c0a 2020 2020 2020 2020  - M) /\.        
+0002bb00: 2020 2020 2020 2020 2020 2020 2028 6e5f               (n_
+0002bb10: 7061 6972 7320 2d20 4d29 2020 2320 544f  pairs - M)  # TO
+0002bb20: 444f 3a20 6c69 6e6b 2077 6569 6768 740a  DO: link weight.
+0002bb30: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0002bb40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0002bb50: 2020 6430 203d 2031 2e30 202a 204e 0a20    d0 = 1.0 * N. 
+0002bb60: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0002bb70: 2866 2263 616c 6375 6c61 7465 6420 7b64  (f"calculated {d
+0002bb80: 307d 2061 7320 6176 6572 6167 6520 6e6f  0} as average no
+0002bb90: 6e2d 6c69 6e6b 6564 2064 6973 7461 6e63  n-linked distanc
+0002bba0: 652c 2022 0a20 2020 2020 2020 2020 2020  e, ".           
+0002bbb0: 2020 2020 2020 2066 226e 6565 6465 6420         f"needed 
+0002bbc0: 7b74 696d 652e 7469 6d65 2829 2d74 307d  {time.time()-t0}
+0002bbd0: 2073 6563 2e22 290a 0a20 2020 2020 2020   sec.")..       
+0002bbe0: 2064 6963 745f 4420 3d20 7b7d 2020 2320   dict_D = {}  # 
+0002bbf0: 7765 6967 6874 6564 2073 756d 206f 6620  weighted sum of 
+0002bc00: 6469 7374 616e 6365 7320 6265 7477 6565  distances betwee
+0002bc10: 6e20 636c 7573 7465 7273 0a20 2020 2020  n clusters.     
+0002bc20: 2020 2064 6963 745f 4465 6c74 6120 3d20     dict_Delta = 
+0002bc30: 7b7d 2020 2320 6572 726f 7220 696e 6372  {}  # error incr
+0002bc40: 6561 7365 2075 706f 6e20 6a6f 696e 2c20  ease upon join, 
+0002bc50: 6f6e 6c79 2069 3c6a 0a0a 2020 2020 2020  only i<j..      
+0002bc60: 2020 2320 696e 6974 2074 6865 206c 6973    # init the lis
+0002bc70: 743a 0a20 2020 2020 2020 2074 3020 3d20  t:.        t0 = 
+0002bc80: 7469 6d65 2e74 696d 6528 290a 2020 2020  time.time().    
+0002bc90: 2020 2020 706f 736a 203d 2030 0a20 2020      posj = 0.   
+0002bca0: 2020 2020 2070 6f73 6920 3d20 4d0a 2020       posi = M.  
+0002bcb0: 2020 2020 2020 666f 7220 6930 2c20 6a30        for i0, j0
+0002bcc0: 2069 6e20 6469 7374 616e 6365 5f6b 6579   in distance_key
+0002bcd0: 733a 0a20 2020 2020 2020 2020 2020 2069  s:.            i
+0002bce0: 6620 6930 203d 3d20 6a30 3a0a 2020 2020  f i0 == j0:.    
+0002bcf0: 2020 2020 2020 2020 2020 2020 6469 6374              dict
+0002bd00: 5f44 5b28 4e2b 3129 2a69 305d 203d 2077  _D[(N+1)*i0] = w
+0002bd10: 5b69 305d 202a 2064 6973 7461 6e63 6573  [i0] * distances
+0002bd20: 5b69 302c 2069 305d 0a20 2020 2020 2020  [i0, i0].       
+0002bd30: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+0002bd40: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
+0002bd50: 2069 3020 3c20 6a30 3a0a 2020 2020 2020   i0 < j0:.      
+0002bd60: 2020 2020 2020 2020 2020 692c 206a 203d            i, j =
+0002bd70: 2069 302c 206a 300a 2020 2020 2020 2020   i0, j0.        
+0002bd80: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0002bd90: 2020 2020 2020 2020 2020 692c 206a 203d            i, j =
+0002bda0: 206a 302c 2069 300a 2020 2020 2020 2020   j0, i0.        
+0002bdb0: 2020 2020 696a 203d 2069 2a4e 2b6a 0a20      ij = i*N+j. 
+0002bdc0: 2020 2020 2020 2020 2020 2069 6620 696a             if ij
+0002bdd0: 2069 6e20 6469 6374 5f44 3a0a 2020 2020   in dict_D:.    
+0002bde0: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+0002bdf0: 696e 7565 0a20 2020 2020 2020 2020 2020  inue.           
+0002be00: 2070 6f73 6a20 3d20 706f 736a 202b 2031   posj = posj + 1
+0002be10: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0002be20: 445f 6669 7273 7470 6f73 5b69 5d20 3d3d  D_firstpos[i] ==
+0002be30: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+0002be40: 2020 2020 445f 6669 7273 7470 6f73 5b69      D_firstpos[i
+0002be50: 5d20 3d20 445f 6c61 7374 706f 735b 695d  ] = D_lastpos[i]
+0002be60: 203d 2070 6f73 6a0a 2020 2020 2020 2020   = posj.        
+0002be70: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0002be80: 2020 2020 2020 2020 2020 445f 7072 6576            D_prev
+0002be90: 706f 735b 706f 736a 5d20 3d20 6c70 6f73  pos[posj] = lpos
+0002bea0: 203d 2044 5f6c 6173 7470 6f73 5b69 5d0a   = D_lastpos[i].
+0002beb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002bec0: 445f 6e65 7874 706f 735b 6c70 6f73 5d20  D_nextpos[lpos] 
+0002bed0: 3d20 445f 6c61 7374 706f 735b 695d 203d  = D_lastpos[i] =
+0002bee0: 2070 6f73 6a0a 2020 2020 2020 2020 2020   posj.          
+0002bef0: 2020 445f 636c 7573 7465 725b 706f 736a    D_cluster[posj
+0002bf00: 5d20 3d20 6a0a 2020 2020 2020 2020 2020  ] = j.          
+0002bf10: 2020 6966 2064 6973 7461 6e63 6573 2069    if distances i
+0002bf20: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0002bf30: 2020 2020 2020 2020 2320 692e 652e 2c20          # i.e., 
+0002bf40: 7573 6520 6469 7374 2031 2069 6620 6c69  use dist 1 if li
+0002bf50: 6e6b 6564 2c20 6430 206f 7468 6572 7769  nked, d0 otherwi
+0002bf60: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
+0002bf70: 2020 2044 696a 203d 2064 6963 745f 445b     Dij = dict_D[
+0002bf80: 696a 5d20 3d20 6469 6374 5f44 5b6a 2a4e  ij] = dict_D[j*N
+0002bf90: 2b69 5d20 3d20 775b 695d 202a 2077 5b6a  +i] = w[i] * w[j
+0002bfa0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
+0002bfb0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0002bfc0: 2020 2020 4469 6a20 3d20 6469 6374 5f44      Dij = dict_D
+0002bfd0: 5b69 6a5d 203d 2064 6963 745f 445b 6a2a  [ij] = dict_D[j*
+0002bfe0: 4e2b 695d 203d 205c 0a20 2020 2020 2020  N+i] = \.       
+0002bff0: 2020 2020 2020 2020 2020 2020 2077 5b69               w[i
+0002c000: 5d20 2a20 775b 6a5d 202a 2064 6973 7461  ] * w[j] * dista
+0002c010: 6e63 6573 5b69 302c 206a 305d 0a20 2020  nces[i0, j0].   
+0002c020: 2020 2020 2020 2020 2044 5f69 6e76 706f           D_invpo
+0002c030: 735b 706f 736a 5d20 3d20 706f 7369 203d  s[posj] = posi =
+0002c040: 2070 6f73 6920 2b20 310a 2020 2020 2020   posi + 1.      
+0002c050: 2020 2020 2020 6966 2044 5f66 6972 7374        if D_first
+0002c060: 706f 735b 6a5d 203d 3d20 303a 0a20 2020  pos[j] == 0:.   
+0002c070: 2020 2020 2020 2020 2020 2020 2044 5f66               D_f
+0002c080: 6972 7374 706f 735b 6a5d 203d 2044 5f6c  irstpos[j] = D_l
+0002c090: 6173 7470 6f73 5b6a 5d20 3d20 706f 7369  astpos[j] = posi
+0002c0a0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+0002c0b0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0002c0c0: 2020 2044 5f70 7265 7670 6f73 5b70 6f73     D_prevpos[pos
+0002c0d0: 695d 203d 206c 706f 7320 3d20 445f 6c61  i] = lpos = D_la
+0002c0e0: 7374 706f 735b 6a5d 0a20 2020 2020 2020  stpos[j].       
+0002c0f0: 2020 2020 2020 2020 2044 5f6e 6578 7470           D_nextp
+0002c100: 6f73 5b6c 706f 735d 203d 2044 5f6c 6173  os[lpos] = D_las
+0002c110: 7470 6f73 5b6a 5d20 3d20 706f 7369 0a20  tpos[j] = posi. 
+0002c120: 2020 2020 2020 2020 2020 2044 5f63 6c75             D_clu
+0002c130: 7374 6572 5b70 6f73 695d 203d 2069 0a20  ster[posi] = i. 
+0002c140: 2020 2020 2020 2020 2020 2044 5f69 6e76             D_inv
+0002c150: 706f 735b 706f 7369 5d20 3d20 706f 736a  pos[posi] = posj
+0002c160: 0a20 2020 2020 2020 2064 656c 2064 6973  .        del dis
+0002c170: 7461 6e63 655f 6b65 7973 0a20 2020 2020  tance_keys.     
+0002c180: 2020 2070 7269 6e74 2822 696e 6974 6961     print("initia
+0002c190: 6c69 7a61 7469 6f6e 206f 6620 6469 7374  lization of dist
+0002c1a0: 616e 6365 7320 6e65 6564 6564 222c 2074  ances needed", t
+0002c1b0: 696d 652e 7469 6d65 2829 2d74 302c 2022  ime.time()-t0, "
+0002c1c0: 7365 632e 2229 0a0a 2020 2020 2020 2020  sec.")..        
+0002c1d0: 2320 696e 6974 2063 616e 6469 6461 7465  # init candidate
+0002c1e0: 733a 0a20 2020 2020 2020 2074 3020 3d20  s:.        t0 = 
+0002c1f0: 7469 6d65 2e74 696d 6528 290a 2020 2020  time.time().    
+0002c200: 2020 2020 6966 2063 616e 6469 6461 7465      if candidate
+0002c210: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
+0002c220: 2020 2020 2020 2063 616e 6469 6461 7465         candidate
+0002c230: 7320 3d20 6e7a 5f63 6f6f 7264 7328 7365  s = nz_coords(se
+0002c240: 6c66 2e73 705f 4129 0a20 2020 2020 2020  lf.sp_A).       
+0002c250: 2066 6f72 2069 302c 206a 3020 696e 2063   for i0, j0 in c
+0002c260: 616e 6469 6461 7465 733a 0a20 2020 2020  andidates:.     
+0002c270: 2020 2020 2020 2069 6620 6930 203c 206a         if i0 < j
+0002c280: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+0002c290: 2020 2069 2c20 6a20 3d20 6930 2c20 6a30     i, j = i0, j0
+0002c2a0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+0002c2b0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0002c2c0: 2020 2069 2c20 6a20 3d20 6a30 2c20 6930     i, j = j0, i0
+0002c2d0: 0a20 2020 2020 2020 2020 2020 2069 6a20  .            ij 
+0002c2e0: 3d20 692a 4e2b 6a0a 2020 2020 2020 2020  = i*N+j.        
+0002c2f0: 2020 2020 6966 2069 6a20 696e 2064 6963      if ij in dic
+0002c300: 745f 4465 6c74 613a 0a20 2020 2020 2020  t_Delta:.       
+0002c310: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+0002c320: 650a 2020 2020 2020 2020 2020 2020 7769  e.            wi
+0002c330: 203d 2077 5b69 5d0a 2020 2020 2020 2020   = w[i].        
+0002c340: 2020 2020 776a 203d 2077 5b6a 5d0a 2020      wj = w[j].  
+0002c350: 2020 2020 2020 2020 2020 7763 203d 2077            wc = w
+0002c360: 6920 2b20 776a 0a20 2020 2020 2020 2020  i + wj.         
+0002c370: 2020 2077 6977 6a20 3d20 7769 202a 2077     wiwj = wi * w
+0002c380: 6a0a 2020 2020 2020 2020 2020 2020 6966  j.            if
+0002c390: 2069 6a20 696e 2064 6963 745f 443a 0a20   ij in dict_D:. 
+0002c3a0: 2020 2020 2020 2020 2020 2020 2020 2044                 D
+0002c3b0: 6363 5f77 6332 203d 2032 202a 2064 6963  cc_wc2 = 2 * dic
+0002c3c0: 745f 442e 6765 7428 696a 2c20 7769 776a  t_D.get(ij, wiwj
+0002c3d0: 2a64 3029 202f 2077 632a 2a32 0a20 2020  *d0) / wc**2.   
+0002c3e0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0002c3f0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0002c400: 6963 745f 445b 696a 5d20 3d20 6469 6374  ict_D[ij] = dict
+0002c410: 5f44 5b6a 2a4e 2b69 5d20 3d20 7769 776a  _D[j*N+i] = wiwj
+0002c420: 6430 203d 2077 6977 6a2a 6430 0a20 2020  d0 = wiwj*d0.   
+0002c430: 2020 2020 2020 2020 2020 2020 2044 6363               Dcc
+0002c440: 5f77 6332 203d 2032 202a 2077 6977 6a64  _wc2 = 2 * wiwjd
+0002c450: 3020 2f20 7763 2a2a 320a 2020 2020 2020  0 / wc**2.      
+0002c460: 2020 2020 2020 6469 6374 5f44 656c 7461        dict_Delta
+0002c470: 5b69 6a5d 203d 2028 7769 2a2a 3220 2b20  [ij] = (wi**2 + 
+0002c480: 776a 2a2a 3229 202a 2028 4463 635f 7763  wj**2) * (Dcc_wc
+0002c490: 3229 2a2a 3220 2b20 5c0a 2020 2020 2020  2)**2 + \.      
+0002c4a0: 2020 2020 2020 2020 2020 3220 2a20 7769            2 * wi
+0002c4b0: 776a 202a 2028 4463 635f 7763 322d 3129  wj * (Dcc_wc2-1)
+0002c4c0: 2a2a 320a 2020 2020 2020 2020 7072 696e  **2.        prin
+0002c4d0: 7428 2269 6e69 7469 616c 697a 6174 696f  t("initializatio
+0002c4e0: 6e20 6f66 2063 616e 6469 6461 7465 7320  n of candidates 
+0002c4f0: 6e65 6564 6564 222c 2074 696d 652e 7469  needed", time.ti
+0002c500: 6d65 2829 2d74 302c 2022 7365 632e 2229  me()-t0, "sec.")
+0002c510: 0a0a 2020 2020 2020 2020 7430 203d 2074  ..        t0 = t
+0002c520: 696d 652e 7469 6d65 2829 0a20 2020 2020  ime.time().     
+0002c530: 2020 2063 616e 6473 203d 2074 6f5f 6379     cands = to_cy
+0002c540: 2864 6963 745f 4465 6c74 612e 6b65 7973  (dict_Delta.keys
+0002c550: 2829 2c20 4e4f 4445 290a 2020 2020 2020  (), NODE).      
+0002c560: 2020 6e5f 6361 6e64 7320 3d20 6c65 6e28    n_cands = len(
+0002c570: 6361 6e64 7329 0a0a 2020 2020 2020 2020  cands)..        
+0002c580: 6469 6374 5f44 656c 7461 203d 205f 646f  dict_Delta = _do
+0002c590: 5f6e 7369 5f63 6c75 7374 6572 696e 675f  _nsi_clustering_
+0002c5a0: 4928 6e5f 6361 6e64 732c 2063 616e 6473  I(n_cands, cands
+0002c5b0: 2c20 445f 636c 7573 7465 722c 2077 2c20  , D_cluster, w, 
+0002c5c0: 6430 2c0a 2020 2020 2020 2020 2020 2020  d0,.            
+0002c5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c5e0: 2020 2020 2020 2020 2020 2020 2020 445f                D_
+0002c5f0: 6669 7273 7470 6f73 2c20 445f 6e65 7874  firstpos, D_next
+0002c600: 706f 732c 204e 2c20 6469 6374 5f44 2c0a  pos, N, dict_D,.
+0002c610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c630: 2020 2020 2020 2020 2020 6469 6374 5f44            dict_D
+0002c640: 656c 7461 290a 2020 2020 2020 2020 7072  elta).        pr
+0002c650: 696e 7428 6622 696e 6974 6961 6c69 7a61  int(f"initializa
+0002c660: 7469 6f6e 206f 6620 6572 726f 7220 696e  tion of error in
+0002c670: 6372 656d 656e 7473 206e 6565 6465 6422  crements needed"
+0002c680: 0a20 2020 2020 2020 2020 2020 2020 2066  .              f
+0002c690: 227b 7469 6d65 2e74 696d 6528 292d 7430  "{time.time()-t0
+0002c6a0: 7d20 7365 632e 2229 0a0a 2020 2020 2020  } sec.")..      
+0002c6b0: 2020 2320 7375 6363 6573 7369 7665 6c79    # successively
+0002c6c0: 206a 6f69 6e20 7468 6520 6265 7374 2070   join the best p
+0002c6d0: 6169 723a 0a20 2020 2020 2020 2073 756d  air:.        sum
+0002c6e0: 7431 203d 2073 756d 7432 203d 2073 756d  t1 = sumt2 = sum
+0002c6f0: 7433 203d 2030 2e30 0a20 2020 2020 2020  t3 = 0.0.       
+0002c700: 2061 6374 6976 6573 203d 2072 616e 6765   actives = range
+0002c710: 284e 290a 2020 2020 2020 2020 6d69 6e5f  (N).        min_
+0002c720: 636c 7573 7465 7273 203d 2031 0a20 2020  clusters = 1.   
+0002c730: 2020 2020 2066 6f72 206e 5f63 6c75 7374       for n_clust
+0002c740: 6572 7320 696e 2072 616e 6765 284e 2d31  ers in range(N-1
+0002c750: 2c20 302c 202d 3129 3a0a 0a20 2020 2020  , 0, -1):..     
+0002c760: 2020 2020 2020 2023 2066 696e 6420 6265         # find be
+0002c770: 7374 2070 6169 7220 613c 623a 0a20 2020  st pair a<b:.   
+0002c780: 2020 2020 2020 2020 2074 3020 3d20 7469           t0 = ti
+0002c790: 6d65 2e74 696d 6528 290a 2020 2020 2020  me.time().      
+0002c7a0: 2020 2020 2020 7661 6c73 203d 2064 6963        vals = dic
+0002c7b0: 745f 4465 6c74 612e 7661 6c75 6573 2829  t_Delta.values()
+0002c7c0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0002c7d0: 6e6f 7420 7661 6c73 3a0a 2020 2020 2020  not vals:.      
+0002c7e0: 2020 2020 2020 2020 2020 6d69 6e5f 636c            min_cl
+0002c7f0: 7573 7465 7273 203d 206e 5f63 6c75 7374  usters = n_clust
+0002c800: 6572 7320 2b20 310a 2020 2020 2020 2020  ers + 1.        
+0002c810: 2020 2020 2020 2020 6272 6561 6b0a 2020          break.  
+0002c820: 2020 2020 2020 2020 2020 6d69 6e70 6f73            minpos
+0002c830: 203d 206e 702e 6172 676d 696e 2876 616c   = np.argmin(val
+0002c840: 7329 0a20 2020 2020 2020 2020 2020 2061  s).            a
+0002c850: 6220 3d20 6469 6374 5f44 656c 7461 2e6b  b = dict_Delta.k
+0002c860: 6579 7328 295b 6d69 6e70 6f73 5d0a 2020  eys()[minpos].  
+0002c870: 2020 2020 2020 2020 2020 6465 6c20 6469            del di
+0002c880: 6374 5f44 656c 7461 5b61 625d 0a20 2020  ct_Delta[ab].   
+0002c890: 2020 2020 2020 2020 2061 203d 2061 6220           a = ab 
+0002c8a0: 2f20 4e0a 2020 2020 2020 2020 2020 2020  / N.            
+0002c8b0: 6220 3d20 6162 2025 204e 0a20 2020 2020  b = ab % N.     
+0002c8c0: 2020 2020 2020 2074 6869 735f 6572 726f         this_erro
+0002c8d0: 7220 3d20 7661 6c73 5b6d 696e 706f 735d  r = vals[minpos]
+0002c8e0: 0a20 2020 2020 2020 2020 2020 2073 756d  .            sum
+0002c8f0: 7431 202b 3d20 7469 6d65 2e74 696d 6528  t1 += time.time(
+0002c900: 292d 7430 0a0a 2020 2020 2020 2020 2020  )-t0..          
+0002c910: 2020 2320 7265 6d6f 7665 2064 7570 6c69    # remove dupli
+0002c920: 6361 7465 7320 696e 2044 2061 6e64 2072  cates in D and r
+0002c930: 6577 6972 6520 6e62 7320 6331 206f 6620  ewire nbs c1 of 
+0002c940: 6220 746f 2070 6f69 6e74 2074 6f20 613a  b to point to a:
+0002c950: 0a20 2020 2020 2020 2020 2020 2064 656c  .            del
+0002c960: 6b65 7973 203d 205b 2862 2c20 6229 5d0a  keys = [(b, b)].
+0002c970: 2020 2020 2020 2020 2020 2020 7430 203d              t0 =
+0002c980: 2074 696d 652e 7469 6d65 2829 0a20 2020   time.time().   
+0002c990: 2020 2020 2020 2020 206c 706f 7320 3d20           lpos = 
+0002c9a0: 445f 6c61 7374 706f 735b 615d 0a20 2020  D_lastpos[a].   
+0002c9b0: 2020 2020 2020 2020 2044 5f6e 6578 7470           D_nextp
+0002c9c0: 6f73 5b6c 706f 735d 203d 2070 6f73 6331  os[lpos] = posc1
+0002c9d0: 203d 2044 5f66 6972 7374 706f 735b 625d   = D_firstpos[b]
+0002c9e0: 0a20 2020 2020 2020 2020 2020 2044 5f70  .            D_p
+0002c9f0: 7265 7670 6f73 5b70 6f73 6331 5d20 3d20  revpos[posc1] = 
+0002ca00: 6c70 6f73 0a20 2020 2020 2020 2020 2020  lpos.           
+0002ca10: 2044 5f6c 6173 7470 6f73 5b61 5d20 3d20   D_lastpos[a] = 
+0002ca20: 445f 6c61 7374 706f 735b 625d 0a20 2020  D_lastpos[b].   
+0002ca30: 2020 2020 2020 2020 2077 6869 6c65 2070           while p
+0002ca40: 6f73 6331 2021 3d20 303a 0a20 2020 2020  osc1 != 0:.     
+0002ca50: 2020 2020 2020 2020 2020 2063 3120 3d20             c1 = 
+0002ca60: 445f 636c 7573 7465 725b 706f 7363 315d  D_cluster[posc1]
+0002ca70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002ca80: 2064 656c 6b65 7973 202b 3d20 5b28 6331   delkeys += [(c1
+0002ca90: 2c20 6229 5d0a 2020 2020 2020 2020 2020  , b)].          
+0002caa0: 2020 2020 2020 6966 2063 3120 3c20 613a        if c1 < a:
+0002cab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002cac0: 2020 2020 2063 3161 6b65 7920 3d20 6331       c1akey = c1
+0002cad0: 2a4e 2b61 0a20 2020 2020 2020 2020 2020  *N+a.           
+0002cae0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0002caf0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0002cb00: 3161 6b65 7920 3d20 612a 4e2b 6331 0a20  1akey = a*N+c1. 
+0002cb10: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0002cb20: 6620 6331 203c 2062 3a0a 2020 2020 2020  f c1 < b:.      
+0002cb30: 2020 2020 2020 2020 2020 2020 2020 6331                c1
+0002cb40: 626b 6579 203d 2063 312a 4e2b 620a 2020  bkey = c1*N+b.  
+0002cb50: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0002cb60: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0002cb70: 2020 2020 2020 2020 6331 626b 6579 203d          c1bkey =
+0002cb80: 2062 2a4e 2b63 310a 2020 2020 2020 2020   b*N+c1.        
+0002cb90: 2020 2020 2020 2020 6966 2063 3162 6b65          if c1bke
+0002cba0: 7920 696e 2064 6963 745f 4465 6c74 613a  y in dict_Delta:
+0002cbb0: 2020 2320 7265 7769 7265 2063 616e 642e    # rewire cand.
+0002cbc0: 2063 312d 6220 746f 2063 312d 613a 0a20   c1-b to c1-a:. 
+0002cbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cbe0: 2020 2064 656c 2064 6963 745f 4465 6c74     del dict_Delt
+0002cbf0: 615b 6331 626b 6579 5d0a 2020 2020 2020  a[c1bkey].      
+0002cc00: 2020 2020 2020 2020 2020 2020 2020 6469                di
+0002cc10: 6374 5f44 656c 7461 5b63 3161 6b65 795d  ct_Delta[c1akey]
+0002cc20: 203d 2030 2e30 2020 2320 7769 6c6c 206c   = 0.0  # will l
+0002cc30: 6174 6572 2062 6520 7265 636f 6d70 7574  ater be recomput
+0002cc40: 6564 210a 2020 2020 2020 2020 2020 2020  ed!.            
+0002cc50: 2020 2020 6966 2063 3120 3d3d 2061 206f      if c1 == a o
+0002cc60: 7220 6331 616b 6579 2069 6e20 6469 6374  r c1akey in dict
+0002cc70: 5f44 3a0a 2020 2020 2020 2020 2020 2020  _D:.            
+0002cc80: 2020 2020 2020 2020 6970 6f73 6331 203d          iposc1 =
+0002cc90: 2044 5f69 6e76 706f 735b 706f 7363 315d   D_invpos[posc1]
+0002cca0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002ccb0: 2020 2020 2069 7070 6f73 203d 2044 5f70       ippos = D_p
+0002ccc0: 7265 7670 6f73 5b69 706f 7363 315d 0a20  revpos[iposc1]. 
+0002ccd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cce0: 2020 2069 6e70 6f73 203d 2044 5f6e 6578     inpos = D_nex
+0002ccf0: 7470 6f73 5b69 706f 7363 315d 0a20 2020  tpos[iposc1].   
+0002cd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cd10: 2069 6620 6970 706f 7320 3e20 303a 0a20   if ippos > 0:. 
+0002cd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cd30: 2020 2020 2020 2044 5f6e 6578 7470 6f73         D_nextpos
+0002cd40: 5b69 7070 6f73 5d20 3d20 696e 706f 730a  [ippos] = inpos.
+0002cd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cd60: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0002cd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cd80: 2020 445f 6669 7273 7470 6f73 5b63 315d    D_firstpos[c1]
+0002cd90: 203d 2069 6e70 6f73 0a20 2020 2020 2020   = inpos.       
+0002cda0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0002cdb0: 696e 706f 7320 3e20 303a 0a20 2020 2020  inpos > 0:.     
+0002cdc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cdd0: 2020 2044 5f70 7265 7670 6f73 5b69 6e70     D_prevpos[inp
+0002cde0: 6f73 5d20 3d20 6970 706f 730a 2020 2020  os] = ippos.    
+0002cdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002ce00: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0002ce10: 2020 2020 2020 2020 2020 2020 2020 445f                D_
+0002ce20: 6c61 7374 706f 735b 6331 5d20 3d20 6970  lastpos[c1] = ip
+0002ce30: 706f 730a 2020 2020 2020 2020 2020 2020  pos.            
+0002ce40: 2020 2020 2020 2020 7070 6f73 203d 2044          ppos = D
+0002ce50: 5f70 7265 7670 6f73 5b70 6f73 6331 5d0a  _prevpos[posc1].
+0002ce60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002ce70: 2020 2020 706f 7363 3120 3d20 445f 6e65      posc1 = D_ne
+0002ce80: 7874 706f 735b 706f 7363 315d 0a20 2020  xtpos[posc1].   
+0002ce90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cea0: 2069 6620 7070 6f73 203e 2030 3a0a 2020   if ppos > 0:.  
+0002ceb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cec0: 2020 2020 2020 445f 6e65 7874 706f 735b        D_nextpos[
+0002ced0: 7070 6f73 5d20 3d20 706f 7363 310a 2020  ppos] = posc1.  
+0002cee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cef0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0002cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cf10: 445f 6669 7273 7470 6f73 5b61 5d20 3d20  D_firstpos[a] = 
+0002cf20: 706f 7363 310a 2020 2020 2020 2020 2020  posc1.          
+0002cf30: 2020 2020 2020 2020 2020 6966 2070 6f73            if pos
+0002cf40: 6331 203e 2030 3a0a 2020 2020 2020 2020  c1 > 0:.        
+0002cf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002cf60: 445f 7072 6576 706f 735b 706f 7363 315d  D_prevpos[posc1]
+0002cf70: 203d 2070 706f 730a 2020 2020 2020 2020   = ppos.        
+0002cf80: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0002cf90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0002cfa0: 2020 2020 2020 2020 2020 445f 6c61 7374            D_last
+0002cfb0: 706f 735b 615d 203d 2070 706f 730a 2020  pos[a] = ppos.  
+0002cfc0: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0002cfd0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0002cfe0: 2020 2020 2020 2020 445f 636c 7573 7465          D_cluste
+0002cff0: 725b 445f 696e 7670 6f73 5b70 6f73 6331  r[D_invpos[posc1
+0002d000: 5d5d 203d 2061 0a20 2020 2020 2020 2020  ]] = a.         
+0002d010: 2020 2020 2020 2020 2020 2070 6f73 6331             posc1
+0002d020: 203d 2044 5f6e 6578 7470 6f73 5b70 6f73   = D_nextpos[pos
+0002d030: 6331 5d0a 2020 2020 2020 2020 2020 2020  c1].            
+0002d040: 445f 6669 7273 7470 6f73 5b62 5d20 3d20  D_firstpos[b] = 
+0002d050: 445f 6c61 7374 706f 735b 625d 203d 2030  D_lastpos[b] = 0
+0002d060: 0a20 2020 2020 2020 2020 2020 2073 756d  .            sum
+0002d070: 7432 202b 3d20 7469 6d65 2e74 696d 6528  t2 += time.time(
+0002d080: 292d 7430 0a0a 2020 2020 2020 2020 2020  )-t0..          
+0002d090: 2020 2320 544f 444f 3a20 7468 6973 2069    # TODO: this i
+0002d0a0: 7320 7468 6520 626f 7474 6c65 6e65 636b  s the bottleneck
+0002d0b0: 2c20 736f 2073 7065 6564 2069 7420 7570  , so speed it up
+0002d0c0: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+0002d0d0: 6669 7273 7420 7570 6461 7465 2044 656c  first update Del
+0002d0e0: 7461 5b61 312c 6231 5d20 666f 7220 6561  ta[a1,b1] for ea
+0002d0f0: 6368 2070 6169 7220 6131 2c62 3120 7769  ch pair a1,b1 wi
+0002d100: 7468 2061 3120 6c69 6e6b 6564 2074 6f20  th a1 linked to 
+0002d110: 630a 2020 2020 2020 2020 2020 2020 2320  c.            # 
+0002d120: 616e 6420 6231 2021 3d20 632c 2061 6e64  and b1 != c, and
+0002d130: 2063 6f6d 7075 7465 2044 656c 7461 5b61   compute Delta[a
+0002d140: 312c 635d 2066 6f72 2065 6163 6820 6131  1,c] for each a1
+0002d150: 206c 696e 6b65 6420 746f 2063 3a0a 2020   linked to c:.  
+0002d160: 2020 2020 2020 2020 2020 7761 203d 2077            wa = w
+0002d170: 5b61 5d0a 2020 2020 2020 2020 2020 2020  [a].            
+0002d180: 7762 203d 2077 5b62 5d0a 2020 2020 2020  wb = w[b].      
+0002d190: 2020 2020 2020 7763 203d 2077 6120 2b20        wc = wa + 
+0002d1a0: 7762 0a20 2020 2020 2020 2020 2020 2077  wb.            w
+0002d1b0: 6164 3020 3d20 7761 202a 2064 300a 2020  ad0 = wa * d0.  
+0002d1c0: 2020 2020 2020 2020 2020 7762 6430 203d            wbd0 =
+0002d1d0: 2077 6220 2a20 6430 0a0a 2020 2020 2020   wb * d0..      
+0002d1e0: 2020 2020 2020 7430 203d 2074 696d 652e        t0 = time.
+0002d1f0: 7469 6d65 2829 0a0a 2020 2020 2020 2020  time()..        
+0002d200: 2020 2020 6469 6374 5f44 656c 7461 203d      dict_Delta =
+0002d210: 205f 646f 5f6e 7369 5f63 6c75 7374 6572   _do_nsi_cluster
+0002d220: 696e 675f 4949 2861 2c20 622c 2044 5f63  ing_II(a, b, D_c
+0002d230: 6c75 7374 6572 2c20 772c 2064 302c 0a20  luster, w, d0,. 
+0002d240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002d250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002d260: 2020 2020 2020 2020 2020 2020 2020 445f                D_
+0002d270: 6669 7273 7470 6f73 2c20 445f 6e65 7874  firstpos, D_next
+0002d280: 706f 732c 204e 2c0a 2020 2020 2020 2020  pos, N,.        
+0002d290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002d2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002d2b0: 2020 2020 2020 2064 6963 745f 442c 2064         dict_D, d
+0002d2c0: 6963 745f 4465 6c74 6129 0a20 2020 2020  ict_Delta).     
+0002d2d0: 2020 2020 2020 2073 756d 7433 203d 2074         sumt3 = t
+0002d2e0: 696d 652e 7469 6d65 2829 2d74 300a 0a20  ime.time()-t0.. 
+0002d2f0: 2020 2020 2020 2020 2020 2023 2066 696e             # fin
+0002d300: 616c 6c79 2075 7064 6174 6520 443a 0a20  ally update D:. 
+0002d310: 2020 2020 2020 2020 2020 2044 6161 203d             Daa =
+0002d320: 2064 6963 745f 442e 6765 7428 612a 284e   dict_D.get(a*(N
+0002d330: 2b31 292c 2030 2e30 290a 2020 2020 2020  +1), 0.0).      
+0002d340: 2020 2020 2020 4462 6220 3d20 6469 6374        Dbb = dict
+0002d350: 5f44 2e67 6574 2862 2a28 4e2b 3129 2c20  _D.get(b*(N+1), 
+0002d360: 302e 3029 0a20 2020 2020 2020 2020 2020  0.0).           
+0002d370: 2064 6963 745f 445b 612a 284e 2b31 295d   dict_D[a*(N+1)]
+0002d380: 203d 2044 6161 202b 2044 6262 202b 2032   = Daa + Dbb + 2
+0002d390: 2a64 6963 745f 445b 612a 4e2b 625d 0a20  *dict_D[a*N+b]. 
+0002d3a0: 2020 2020 2020 2020 2020 2070 6f73 6331             posc1
+0002d3b0: 203d 2044 5f66 6972 7374 706f 735b 615d   = D_firstpos[a]
+0002d3c0: 0a20 2020 2020 2020 2020 2020 2077 6869  .            whi
+0002d3d0: 6c65 2070 6f73 6331 203e 2030 3a0a 2020  le posc1 > 0:.  
+0002d3e0: 2020 2020 2020 2020 2020 2020 2020 6331                c1
+0002d3f0: 203d 2044 5f63 6c75 7374 6572 5b70 6f73   = D_cluster[pos
+0002d400: 6331 5d0a 2020 2020 2020 2020 2020 2020  c1].            
+0002d410: 2020 2020 4461 6331 203d 2064 6963 745f      Dac1 = dict_
+0002d420: 442e 6765 7428 612a 4e2b 6331 2c20 775b  D.get(a*N+c1, w[
+0002d430: 6331 5d2a 7761 6430 290a 2020 2020 2020  c1]*wad0).      
+0002d440: 2020 2020 2020 2020 2020 4462 6331 203d            Dbc1 =
+0002d450: 2064 6963 745f 442e 6765 7428 622a 4e2b   dict_D.get(b*N+
+0002d460: 6331 2c20 775b 6331 5d2a 7762 6430 290a  c1, w[c1]*wbd0).
+0002d470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002d480: 6469 6374 5f44 5b63 312a 4e2b 615d 203d  dict_D[c1*N+a] =
+0002d490: 2064 6963 745f 445b 612a 4e2b 6331 5d20   dict_D[a*N+c1] 
+0002d4a0: 3d20 4461 6331 202b 2044 6263 310a 2020  = Dac1 + Dbc1.  
+0002d4b0: 2020 2020 2020 2020 2020 2020 2020 706f                po
+0002d4c0: 7363 3120 3d20 445f 6e65 7874 706f 735b  sc1 = D_nextpos[
+0002d4d0: 706f 7363 315d 0a0a 2020 2020 2020 2020  posc1]..        
+0002d4e0: 2020 2020 2320 7570 6461 7465 2072 6573      # update res
+0002d4f0: 756c 7420 7374 7275 6374 7572 6573 3a0a  ult structures:.
+0002d500: 2020 2020 2020 2020 2020 2020 6320 3d20              c = 
+0002d510: 4e32 202d 206e 5f63 6c75 7374 6572 730a  N2 - n_clusters.
+0002d520: 2020 2020 2020 2020 2020 2020 6572 726f              erro
+0002d530: 725b 6e5f 636c 7573 7465 7273 5d20 3d20  r[n_clusters] = 
+0002d540: 6572 726f 725b 6e5f 636c 7573 7465 7273  error[n_clusters
+0002d550: 2b31 5d20 2b20 7468 6973 5f65 7272 6f72  +1] + this_error
+0002d560: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
+0002d570: 4f44 4f3a 206e 6f64 6532 636c 7573 7465  ODO: node2cluste
+0002d580: 720a 2020 2020 2020 2020 2020 2020 636c  r.            cl
+0002d590: 7573 7465 725f 7765 6967 6874 5b63 5d20  uster_weight[c] 
+0002d5a0: 3d20 7763 0a20 2020 2020 2020 2020 2020  = wc.           
+0002d5b0: 2023 2054 4f44 4f3a 2063 6c75 7374 6572   # TODO: cluster
+0002d5c0: 3272 616e 6b0a 2020 2020 2020 2020 2020  2rank.          
+0002d5d0: 2020 2320 544f 444f 3a20 6e6f 6465 5f69    # TODO: node_i
+0002d5e0: 6e5f 636c 7573 7465 720a 2020 2020 2020  n_cluster.      
+0002d5f0: 2020 2020 2020 6368 696c 6472 656e 5b63        children[c
+0002d600: 2c20 305d 203d 2063 6120 3d20 636c 6964  , 0] = ca = clid
+0002d610: 5b61 5d0a 2020 2020 2020 2020 2020 2020  [a].            
+0002d620: 6368 696c 6472 656e 5b63 2c20 315d 203d  children[c, 1] =
+0002d630: 2073 6962 6c69 6e67 5b63 615d 203d 2063   sibling[ca] = c
+0002d640: 6220 3d20 636c 6964 5b62 5d0a 2020 2020  b = clid[b].    
+0002d650: 2020 2020 2020 2020 7369 626c 696e 675b          sibling[
+0002d660: 6362 5d20 3d20 6361 0a20 2020 2020 2020  cb] = ca.       
+0002d670: 2020 2020 2070 6172 656e 745b 6361 5d20       parent[ca] 
+0002d680: 3d20 7061 7265 6e74 5b63 625d 203d 2063  = parent[cb] = c
+0002d690: 0a20 2020 2020 2020 2020 2020 2070 6172  .            par
+0002d6a0: 656e 745b 635d 203d 204e 3220 2d20 3120  ent[c] = N2 - 1 
+0002d6b0: 2023 2069 6e69 7469 616c 6c79 2c20 756e   # initially, un
+0002d6c0: 7469 6c20 6a6f 696e 6564 2e0a 0a20 2020  til joined...   
+0002d6d0: 2020 2020 2020 2020 2023 2072 656d 6f76           # remov
+0002d6e0: 6520 6220 616e 6420 7265 706c 6163 6520  e b and replace 
+0002d6f0: 6120 6279 2063 3a0a 2020 2020 2020 2020  a by c:.        
+0002d700: 2020 2020 666f 7220 6b31 2c20 6b32 2069      for k1, k2 i
+0002d710: 6e20 6465 6c6b 6579 733a 0a20 2020 2020  n delkeys:.     
+0002d720: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
+0002d730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002d740: 2020 2020 6465 6c20 6469 6374 5f44 5b6b      del dict_D[k
+0002d750: 312a 4e2b 6b32 5d2c 2064 6963 745f 445b  1*N+k2], dict_D[
+0002d760: 6b32 2a4e 2b6b 315d 0a20 2020 2020 2020  k2*N+k1].       
+0002d770: 2020 2020 2020 2020 2065 7863 6570 7420           except 
+0002d780: 4b65 7945 7272 6f72 3a0a 2020 2020 2020  KeyError:.      
+0002d790: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+0002d7a0: 7373 0a20 2020 2020 2020 2020 2020 2061  ss.            a
+0002d7b0: 6374 6976 6573 2e72 656d 6f76 6528 6229  ctives.remove(b)
+0002d7c0: 0a20 2020 2020 2020 2020 2020 2063 6c69  .            cli
+0002d7d0: 645b 615d 203d 2063 0a20 2020 2020 2020  d[a] = c.       
+0002d7e0: 2020 2020 2077 5b61 5d20 3d20 7763 0a0a       w[a] = wc..
+0002d7f0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0002d800: 7428 6e5f 636c 7573 7465 7273 2c20 223a  t(n_clusters, ":
+0002d810: 206a 6f69 6e69 6e67 222c 2063 612c 2063   joining", ca, c
+0002d820: 622c 2022 746f 222c 2063 2c20 2261 7422  b, "to", c, "at"
+0002d830: 2c20 7468 6973 5f65 7272 6f72 290a 2020  , this_error).  
+0002d840: 2020 2020 2020 2020 2020 6966 206e 5f63            if n_c
+0002d850: 6c75 7374 6572 7320 3c20 3130 3a0a 2020  lusters < 10:.  
+0002d860: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+0002d870: 696e 7428 2244 222c 2064 6963 745f 4429  int("D", dict_D)
+0002d880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002d890: 2070 7269 6e74 2822 4465 6c74 6122 2c20   print("Delta", 
+0002d8a0: 6469 6374 5f44 656c 7461 290a 0a20 2020  dict_Delta)..   
+0002d8b0: 2020 2020 2070 7269 6e74 2822 7061 7274       print("part
+0002d8c0: 2031 206e 6565 6465 6422 2c20 7375 6d74   1 needed", sumt
+0002d8d0: 312c 2022 7365 632e 2229 0a20 2020 2020  1, "sec.").     
+0002d8e0: 2020 2070 7269 6e74 2822 7061 7274 2032     print("part 2
+0002d8f0: 206e 6565 6465 6422 2c20 7375 6d74 322c   needed", sumt2,
+0002d900: 2022 7365 632e 2229 0a20 2020 2020 2020   "sec.").       
+0002d910: 2070 7269 6e74 2822 7061 7274 2033 206e   print("part 3 n
+0002d920: 6565 6465 6422 2c20 7375 6d74 332c 2022  eeded", sumt3, "
+0002d930: 7365 632e 2229 0a0a 2020 2020 2020 2020  sec.")..        
+0002d940: 6966 2074 7265 655f 646f 7466 696c 6520  if tree_dotfile 
+0002d950: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0002d960: 2020 2020 2020 2020 2023 2075 7365 2070           # use p
+0002d970: 656e 7769 6474 6820 616e 6420 6c65 6e21  enwidth and len!
+0002d980: 0a20 2020 2020 2020 2020 2020 2065 6467  .            edg
+0002d990: 6573 203d 205b 2869 6e74 286e 292c 2069  es = [(int(n), i
+0002d9a0: 6e74 2870 6172 656e 745b 6e5d 2929 2066  nt(parent[n])) f
+0002d9b0: 6f72 206e 2069 6e20 7261 6e67 6528 4e32  or n in range(N2
+0002d9c0: 2d31 295d 0a20 2020 2020 2020 2020 2020  -1)].           
+0002d9d0: 206d 696e 6c65 6e20 3d20 5b69 6e74 2870   minlen = [int(p
+0002d9e0: 6172 656e 745b 6e5d 2d6d 6178 286e 2c20  arent[n]-max(n, 
+0002d9f0: 4e2d 3129 2920 666f 7220 6e20 696e 2072  N-1)) for n in r
+0002da00: 616e 6765 284e 322d 3129 5d0a 2020 2020  ange(N2-1)].    
+0002da10: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
+0002da20: 6570 7320 2b20 6572 726f 7220 6469 6666  eps + error diff
+0002da30: 6572 656e 6365 0a20 2020 2020 2020 2020  erence.         
+0002da40: 2020 2065 6467 656c 656e 203d 206e 702e     edgelen = np.
+0002da50: 6172 7261 7928 0a20 2020 2020 2020 2020  array(.         
+0002da60: 2020 2020 2020 205b 6d61 7828 302e 302c         [max(0.0,
+0002da70: 2065 7272 6f72 5b4e 322d 7061 7265 6e74   error[N2-parent
+0002da80: 5b6e 5d5d 2920 666f 7220 6e20 696e 2072  [n]]) for n in r
+0002da90: 616e 6765 284e 295d 0a20 2020 2020 2020  ange(N)].       
+0002daa0: 2020 2020 2020 2020 202b 205b 6d61 7828           + [max(
+0002dab0: 302e 302c 2065 7272 6f72 5b4e 322d 7061  0.0, error[N2-pa
+0002dac0: 7265 6e74 5b6e 5d5d 2d65 7272 6f72 5b4e  rent[n]]-error[N
+0002dad0: 322d 6e5d 290a 2020 2020 2020 2020 2020  2-n]).          
+0002dae0: 2020 2020 2020 2020 2066 6f72 206e 2069           for n i
+0002daf0: 6e20 7261 6e67 6528 4e2c 204e 322d 3129  n range(N, N2-1)
+0002db00: 5d29 2020 2320 6d69 6e6c 656e 0a20 2020  ])  # minlen.   
+0002db10: 2020 2020 2020 2020 2023 2054 4f44 4f3a           # TODO:
+0002db20: 2031 2f28 6570 7320 2b20 6572 726f 7220   1/(eps + error 
+0002db30: 6469 6666 6572 656e 6365 290a 2020 2020  difference).    
+0002db40: 2020 2020 2020 2020 2320 5b31 2e30 2066          # [1.0 f
+0002db50: 6f72 2069 2069 6e20 7261 6e67 6528 4e32  or i in range(N2
+0002db60: 2d31 295d 0a20 2020 2020 2020 2020 2020  -1)].           
+0002db70: 2070 656e 7769 6474 6820 3d20 3330 2e30   penwidth = 30.0
+0002db80: 202f 2028 312e 3020 2b20 3239 2e30 2a65   / (1.0 + 29.0*e
+0002db90: 6467 656c 656e 2f65 6467 656c 656e 2e6d  dgelen/edgelen.m
+0002dba0: 6178 2829 290a 2020 2020 2020 2020 2020  ax()).          
+0002dbb0: 2020 7472 6565 203d 2069 6772 6170 682e    tree = igraph.
+0002dbc0: 4772 6170 6828 6564 6765 732c 2064 6972  Graph(edges, dir
+0002dbd0: 6563 7465 643d 5472 7565 290a 2020 2020  ected=True).    
+0002dbe0: 2020 2020 2020 2020 7472 6565 2e65 732e          tree.es.
+0002dbf0: 7365 745f 6174 7472 6962 7574 655f 7661  set_attribute_va
+0002dc00: 6c75 6573 2822 6d69 6e6c 656e 222c 206d  lues("minlen", m
+0002dc10: 696e 6c65 6e29 0a20 2020 2020 2020 2020  inlen).         
+0002dc20: 2020 2074 7265 652e 6573 2e73 6574 5f61     tree.es.set_a
+0002dc30: 7474 7269 6275 7465 5f76 616c 7565 7328  ttribute_values(
+0002dc40: 226c 656e 222c 2065 6467 656c 656e 290a  "len", edgelen).
+0002dc50: 2020 2020 2020 2020 2020 2020 7472 6565              tree
+0002dc60: 2e65 732e 7365 745f 6174 7472 6962 7574  .es.set_attribut
+0002dc70: 655f 7661 6c75 6573 2822 7065 6e77 6964  e_values("penwid
+0002dc80: 7468 222c 2070 656e 7769 6474 6829 0a20  th", penwidth). 
+0002dc90: 2020 2020 2020 2020 2020 2074 7265 655b             tree[
+0002dca0: 2272 616e 6b64 6972 225d 203d 2022 4254  "rankdir"] = "BT
+0002dcb0: 220a 2020 2020 2020 2020 2020 2020 7472  ".            tr
+0002dcc0: 6565 2e77 7269 7465 5f64 6f74 2874 7265  ee.write_dot(tre
+0002dcd0: 655f 646f 7466 696c 6529 0a20 2020 2020  e_dotfile).     
+0002dce0: 2020 2020 2020 2064 656c 2074 7265 650a         del tree.
+0002dcf0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0002dd00: 7b0a 2020 2020 2020 2020 2020 2020 226d  {.            "m
+0002dd10: 696e 5f63 6c75 7374 6572 7322 3a20 6d69  in_clusters": mi
+0002dd20: 6e5f 636c 7573 7465 7273 2c20 226e 6f64  n_clusters, "nod
+0002dd30: 6532 636c 7573 7465 7222 3a20 6e6f 6465  e2cluster": node
+0002dd40: 3263 6c75 7374 6572 2c0a 2020 2020 2020  2cluster,.      
+0002dd50: 2020 2020 2020 2263 6c75 7374 6572 3272        "cluster2r
+0002dd60: 616e 6b22 3a20 636c 7573 7465 7232 7261  ank": cluster2ra
+0002dd70: 6e6b 2c20 2263 6c75 7374 6572 5f77 6569  nk, "cluster_wei
+0002dd80: 6768 7422 3a20 636c 7573 7465 725f 7765  ght": cluster_we
+0002dd90: 6967 6874 2c0a 2020 2020 2020 2020 2020  ight,.          
+0002dda0: 2020 226e 6f64 655f 696e 5f63 6c75 7374    "node_in_clust
+0002ddb0: 6572 223a 206e 6f64 655f 696e 5f63 6c75  er": node_in_clu
+0002ddc0: 7374 6572 2c20 2265 7272 6f72 223a 2065  ster, "error": e
+0002ddd0: 7272 6f72 2c0a 2020 2020 2020 2020 2020  rror,.          
+0002dde0: 2020 2263 6869 6c64 7265 6e22 3a20 6368    "children": ch
+0002ddf0: 696c 6472 656e 2c20 2273 6962 6c69 6e67  ildren, "sibling
+0002de00: 223a 2073 6962 6c69 6e67 2c20 2270 6172  ": sibling, "par
+0002de10: 656e 7422 3a20 7061 7265 6e74 0a20 2020  ent": parent.   
+0002de20: 2020 2020 207d 0a0a 2020 2020 6465 6620       }..    def 
+0002de30: 646f 5f6e 7369 5f68 616d 6d69 6e67 5f63  do_nsi_hamming_c
+0002de40: 6c75 7374 6572 696e 6728 7365 6c66 2c20  lustering(self, 
+0002de50: 6164 6d69 7373 6962 6c65 5f6a 6f69 6e73  admissible_joins
+0002de60: 3d4e 6f6e 652c 2061 6c70 6861 3d30 2e30  =None, alpha=0.0
+0002de70: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
+0002de80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002de90: 2020 2020 2074 7265 655f 646f 7466 696c       tree_dotfil
+0002dea0: 653d 4e6f 6e65 293a 0a20 2020 2020 2020  e=None):.       
+0002deb0: 2022 2222 0a20 2020 2020 2020 2050 6572   """.        Per
+0002dec0: 666f 726d 2061 6767 6c6f 6d65 7261 7469  form agglomerati
+0002ded0: 7665 2063 6c75 7374 6572 696e 6720 6261  ve clustering ba
+0002dee0: 7365 6420 6f6e 2048 616d 6d69 6e67 2064  sed on Hamming d
+0002def0: 6973 7461 6e63 6573 2e0a 0a20 2020 2020  istances...     
+0002df00: 2020 2054 6869 7320 6d69 6e69 6d69 7a65     This minimize
+0002df10: 7320 696e 2065 6163 6820 7374 6570 2074  s in each step t
+0002df20: 6865 2048 616d 6d69 6e67 2064 6973 7461  he Hamming dista
+0002df30: 6e63 6520 6265 7477 6565 6e20 7468 6520  nce between the 
+0002df40: 6f72 6967 696e 616c 0a20 2020 2020 2020  original.       
+0002df50: 2061 6e64 2074 6865 2022 636c 7573 7465   and the "cluste
+0002df60: 7265 6422 206e 6574 776f 726b 2e0a 0a20  red" network... 
+0002df70: 2020 2020 2020 202e 2e20 6e6f 7465 3a3a         .. note::
+0002df80: 0a20 2020 2020 2020 2020 2020 5468 6973  .           This
+0002df90: 2069 7320 7374 696c 6c20 4558 5045 5249   is still EXPERI
+0002dfa0: 4d45 4e54 414c 210a 0a20 2020 2020 2020  MENTAL!..       
+0002dfb0: 2053 6565 2074 6865 2063 6f64 6520 666f   See the code fo
+0002dfc0: 7220 6172 6775 6d65 6e74 7320 616e 6420  r arguments and 
+0002dfd0: 7265 7475 726e 2076 616c 7565 2e0a 0a20  return value... 
+0002dfe0: 2020 2020 2020 2043 6c75 7374 6572 7320         Clusters 
+0002dff0: 302e 2e2e 6e2d 3120 6172 6520 7468 6520  0...n-1 are the 
+0002e000: 7369 6e67 6c65 746f 6e73 2028 636c 7573  singletons (clus
+0002e010: 7465 7220 6920 636f 6e74 6169 6e69 6e67  ter i containing
+0002e020: 206a 7573 7420 6e6f 6465 2069 292e 0a20   just node i).. 
+0002e030: 2020 2020 2020 2043 6c75 7374 6572 7320         Clusters 
+0002e040: 6e2e 2e2e 326e 2d32 2061 7265 206e 756d  n...2n-2 are num
+0002e050: 6265 7265 6420 696e 2074 6865 206f 7264  bered in the ord
+0002e060: 6572 2069 6e20 7768 6963 6820 636c 7573  er in which clus
+0002e070: 7465 7273 2061 7265 0a20 2020 2020 2020  ters are.       
+0002e080: 206a 6f69 6e65 6420 2861 2063 6c75 7374   joined (a clust
+0002e090: 6572 2077 6974 6820 6964 2063 2069 7320  er with id c is 
+0002e0a0: 6120 756e 696f 6e20 6f66 2074 776f 2065  a union of two e
+0002e0b0: 6172 6c69 6572 2063 6c75 7374 6572 7320  arlier clusters 
+0002e0c0: 7769 7468 0a20 2020 2020 2020 2069 6473  with.        ids
+0002e0d0: 2063 312c 6332 203c 2063 292e 2049 6e20   c1,c2 < c). In 
+0002e0e0: 7061 7274 6963 756c 6172 2c20 636c 7573  particular, clus
+0002e0f0: 7465 7220 326e 2d32 2069 7320 7468 6520  ter 2n-2 is the 
+0002e100: 6675 6c6c 2073 6574 206f 6620 6e6f 6465  full set of node
+0002e110: 732e 0a0a 2020 2020 2020 2020 3a72 7479  s...        :rty
+0002e120: 7065 3a20 2064 6963 7469 6f6e 6172 790a  pe:  dictionary.
+0002e130: 2020 2020 2020 2020 3a72 6574 7572 6e3a          :return:
+0002e140: 2041 2064 6963 7469 6f6e 6172 7920 636f   A dictionary co
+0002e150: 6e74 6169 6e69 6e67 2074 6865 2066 6f6c  ntaining the fol
+0002e160: 6c6f 7769 6e67 206b 6579 733a 0a0a 2020  lowing keys:..  
+0002e170: 2020 2020 2020 2020 202d 2022 6572 726f           - "erro
+0002e180: 7222 3a20 6172 7261 7928 6e2b 3129 2e20  r": array(n+1). 
+0002e190: 456e 7472 7920 5b6b 5d20 6973 2074 6865  Entry [k] is the
+0002e1a0: 2072 6570 7265 7365 6e74 6174 696f 6e20   representation 
+0002e1b0: 6572 726f 7220 666f 7220 7468 650a 2020  error for the.  
+0002e1c0: 2020 2020 2020 2020 2020 2073 6f6c 7574             solut
+0002e1d0: 696f 6e20 7769 7468 206b 2063 6c75 7374  ion with k clust
+0002e1e0: 6572 732e 0a20 2020 2020 2020 2020 2020  ers..           
+0002e1f0: 2d20 226e 6f64 6532 636c 7573 7465 7222  - "node2cluster"
+0002e200: 3a20 6172 7261 7928 6e2c 6e2b 3129 2e20  : array(n,n+1). 
+0002e210: 456e 7472 7920 5b69 2c6b 5d20 6973 2074  Entry [i,k] is t
+0002e220: 6865 2069 6420 6f66 2074 6865 2063 6c75  he id of the clu
+0002e230: 7374 6572 0a20 2020 2020 2020 2020 2020  ster.           
+0002e240: 2020 7468 6174 2063 6f6e 7461 696e 7320    that contains 
+0002e250: 6e6f 6465 2069 2069 6e20 7468 6520 736f  node i in the so
+0002e260: 6c75 7469 6f6e 2077 6974 6820 6b20 636c  lution with k cl
+0002e270: 7573 7465 7273 2e0a 2020 2020 2020 2020  usters..        
+0002e280: 2020 202d 2022 636c 7573 7465 725f 7765     - "cluster_we
+0002e290: 6967 6874 223a 2061 7272 6179 2832 6e2d  ight": array(2n-
+0002e2a0: 3129 2e20 456e 7472 7920 5b63 5d20 6973  1). Entry [c] is
+0002e2b0: 2074 6865 2074 6f74 616c 2077 6569 6768   the total weigh
+0002e2c0: 7420 6f66 0a20 2020 2020 2020 2020 2020  t of.           
+0002e2d0: 2020 636c 7573 7465 7220 632e 0a20 2020    cluster c..   
+0002e2e0: 2020 2020 2020 2020 2d20 2263 6c75 7374          - "clust
+0002e2f0: 6572 3272 616e 6b22 3a20 6172 7261 7928  er2rank": array(
+0002e300: 326e 2d31 2c6e 2b31 292e 2045 6e74 7279  2n-1,n+1). Entry
+0002e310: 205b 632c 6b5d 2069 7320 7468 6520 6465   [c,k] is the de
+0002e320: 7363 656e 6469 6e67 0a20 2020 2020 2020  scending.       
+0002e330: 2020 2020 2020 6f72 6465 7220 7261 6e6b        order rank
+0002e340: 206f 6620 636c 7573 7465 7220 6320 696e   of cluster c in
+0002e350: 2074 6865 206b 2d63 6c75 7374 6572 2073   the k-cluster s
+0002e360: 6f6c 7574 696f 6e2c 2069 2e65 2e2c 2074  olution, i.e., t
+0002e370: 6865 0a20 2020 2020 2020 2020 2020 2020  he.             
+0002e380: 6e75 6d62 6572 206f 6620 6c61 7267 6572  number of larger
+0002e390: 2063 6c75 7374 6572 7320 696e 2074 6861   clusters in tha
+0002e3a0: 7420 736f 6c75 7469 6f6e 2e20 5573 6520  t solution. Use 
+0002e3b0: 7468 6973 2074 6f20 636f 6e76 6572 740a  this to convert.
+0002e3c0: 2020 2020 2020 2020 2020 2020 2063 6c75               clu
+0002e3d0: 7374 6572 2069 6473 2069 6e20 302e 2e2e  ster ids in 0...
+0002e3e0: 326e 2d31 2074 6f20 636c 7573 7465 7220  2n-1 to cluster 
+0002e3f0: 6964 7320 696e 2030 2e2e 2e6b 2d31 2e0a  ids in 0...k-1..
+0002e400: 2020 2020 2020 2020 2020 202d 2022 6e6f             - "no
+0002e410: 6465 5f69 6e5f 636c 7573 7465 7222 3a20  de_in_cluster": 
+0002e420: 6172 7261 7928 6e2c 326e 2d31 292e 2045  array(n,2n-1). E
+0002e430: 6e74 7279 205b 692c 635d 2069 6e64 6963  ntry [i,c] indic
+0002e440: 6174 6573 2077 6865 7468 6572 0a20 2020  ates whether.   
+0002e450: 2020 2020 2020 2020 2020 6e6f 6465 2069            node i
+0002e460: 2069 7320 696e 2074 6865 2063 6c75 7374   is in the clust
+0002e470: 6572 2077 6974 6820 6964 2063 2e0a 2020  er with id c..  
+0002e480: 2020 2020 2020 2020 202d 2022 6368 696c           - "chil
+0002e490: 6472 656e 223a 2061 7272 6179 2832 6e2d  dren": array(2n-
+0002e4a0: 312c 3229 2e20 456e 7472 6965 7320 5b63  1,2). Entries [c
+0002e4b0: 2c30 5d20 616e 6420 5b63 2c31 5d20 6172  ,0] and [c,1] ar
+0002e4c0: 6520 7468 6520 6964 7320 6f66 0a20 2020  e the ids of.   
+0002e4d0: 2020 2020 2020 2020 2020 7468 6520 7477            the tw
+0002e4e0: 6f20 636c 7573 7465 7273 2074 6861 7420  o clusters that 
+0002e4f0: 7765 7265 206a 6f69 6e65 6420 746f 2067  were joined to g
+0002e500: 6976 6520 636c 7573 7465 7220 632e 0a20  ive cluster c.. 
+0002e510: 2020 2020 2020 2020 2020 2d20 2273 6962            - "sib
+0002e520: 6c69 6e67 223a 2061 7272 6179 2832 6e2d  ling": array(2n-
+0002e530: 3229 2e20 456e 7472 7920 5b63 5d20 6973  2). Entry [c] is
+0002e540: 2074 6865 2069 6420 6f66 2074 6865 2063   the id of the c
+0002e550: 6c75 7374 6572 2077 6974 680a 2020 2020  luster with.    
+0002e560: 2020 2020 2020 2020 2077 6869 6368 2063           which c
+0002e570: 6c75 7374 6572 2063 2069 7320 6a6f 696e  luster c is join
+0002e580: 6564 2e0a 2020 2020 2020 2020 2020 202d  ed..           -
+0002e590: 2022 7061 7265 6e74 223a 2061 7272 6179   "parent": array
+0002e5a0: 2832 6e2d 3229 2e20 456e 7472 7920 5b63  (2n-2). Entry [c
+0002e5b0: 5d20 6973 2074 6865 2069 6420 6f66 2074  ] is the id of t
+0002e5c0: 6865 2063 6c75 7374 6572 2074 6861 740a  he cluster that.
+0002e5d0: 2020 2020 2020 2020 2020 2020 2072 6573               res
+0002e5e0: 756c 7473 2066 726f 6d20 6a6f 696e 696e  ults from joinin
+0002e5f0: 6720 636c 7573 7465 7220 6320 7769 7468  g cluster c with
+0002e600: 2069 7473 2073 6962 6c69 6e67 2e0a 2020   its sibling..  
+0002e610: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0002e620: 2020 2320 746f 6f6b 2061 626f 7574 2031    # took about 1
+0002e630: 3568 206f 6e20 5a75 7365 2066 6f72 2048  5h on Zuse for H
+0002e640: 6164 434d 3320 676c 6f62 650a 2020 2020  adCM3 globe.    
+0002e650: 2020 2020 2320 3f74 616b 6573 2061 626f      # ?takes abo
+0002e660: 7574 2039 302a 284e 2f38 3030 295e 3420  ut 90*(N/800)^4 
+0002e670: 7365 636f 6e64 7320 6f6e 2061 2031 2e36  seconds on a 1.6
+0002e680: 3720 4748 7a20 6936 3836 2c0a 2020 2020  7 GHz i686,.    
+0002e690: 2020 2020 2320 7768 6963 6820 6d61 6b65      # which make
+0002e6a0: 7320 6162 6f75 7420 3130 2064 6179 7320  s about 10 days 
+0002e6b0: 666f 7220 4e3d 3830 3030 2028 652e 672e  for N=8000 (e.g.
+0002e6c0: 2061 2048 6164 434d 3320 676c 6f62 6529   a HadCM3 globe)
+0002e6d0: 0a0a 2020 2020 2020 2020 7430 203d 2074  ..        t0 = t
+0002e6e0: 696d 652e 7469 6d65 2829 0a0a 2020 2020  ime.time()..    
+0002e6f0: 2020 2020 2320 696e 6974 6961 6c69 7a65      # initialize
+0002e700: 2064 6174 6120 7374 7275 6374 7572 6573   data structures
+0002e710: 3a0a 0a20 2020 2020 2020 206e 203d 2073  :..        n = s
+0002e720: 656c 662e 4e0a 2020 2020 2020 2020 6e32  elf.N.        n2
+0002e730: 203d 2032 2a6e 2d31 0a20 2020 2020 2020   = 2*n-1.       
+0002e740: 2077 203d 2073 656c 662e 6e6f 6465 5f77   w = self.node_w
+0002e750: 6569 6768 7473 0a20 2020 2020 2020 2057  eights.        W
+0002e760: 5720 3d20 7365 6c66 2e74 6f74 616c 5f6e  W = self.total_n
+0002e770: 6f64 655f 7765 6967 6874 2a2a 320a 0a20  ode_weight**2.. 
+0002e780: 2020 2020 2020 2023 206a 6f69 6e20 6164         # join ad
+0002e790: 6d69 7373 6962 696c 6974 7920 6d61 7472  missibility matr
+0002e7a0: 6978 3a0a 2020 2020 2020 2020 6966 2061  ix:.        if a
+0002e7b0: 646d 6973 7369 626c 655f 6a6f 696e 7320  dmissible_joins 
+0002e7c0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0002e7d0: 2020 2020 2070 7269 6e74 2822 616c 6c20       print("all 
+0002e7e0: 6a6f 696e 7320 6164 6d69 7373 6962 6c65  joins admissible
+0002e7f0: 2229 0a20 2020 2020 2020 2020 2020 206d  ").            m
+0002e800: 6179 4a6f 696e 203d 206e 702e 7a65 726f  ayJoin = np.zero
+0002e810: 7328 286e 322c 206e 3229 2c20 6474 7970  s((n2, n2), dtyp
+0002e820: 653d 4d41 534b 2920 2b20 310a 2020 2020  e=MASK) + 1.    
+0002e830: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0002e840: 2020 2020 2020 7072 696e 7428 226f 6e6c        print("onl
+0002e850: 7920 736f 6d65 206a 6f69 6e73 2061 646d  y some joins adm
+0002e860: 6973 7369 626c 6522 290a 2020 2020 2020  issible").      
+0002e870: 2020 2020 2020 6d61 794a 6f69 6e20 3d20        mayJoin = 
+0002e880: 6e70 2e7a 6572 6f73 2828 6e32 2c20 6e32  np.zeros((n2, n2
+0002e890: 292c 2064 7479 7065 3d4d 4153 4b29 0a20  ), dtype=MASK). 
+0002e8a0: 2020 2020 2020 2020 2020 206d 6179 4a6f             mayJo
+0002e8b0: 696e 5b30 3a6e 2c20 303a 6e5d 203d 2061  in[0:n, 0:n] = a
+0002e8c0: 646d 6973 7369 626c 655f 6a6f 696e 730a  dmissible_joins.
+0002e8d0: 2020 2020 2020 2020 2320 636c 7573 7465          # cluste
+0002e8e0: 7220 6d65 6d62 6572 7368 6970 2069 6e64  r membership ind
+0002e8f0: 6963 6174 6f72 733a 0a20 2020 2020 2020  icators:.       
+0002e900: 2063 6c75 7374 6572 4d65 6d62 6572 7320   clusterMembers 
+0002e910: 3d20 6e70 2e7a 6572 6f73 2828 6e32 2c20  = np.zeros((n2, 
+0002e920: 6e29 2c20 6474 7970 653d 696e 7429 0a20  n), dtype=int). 
+0002e930: 2020 2020 2020 2063 6c75 7374 6572 4d65         clusterMe
+0002e940: 6d62 6572 735b 303a 6e2c 2030 3a6e 5d20  mbers[0:n, 0:n] 
+0002e950: 3d20 6e70 2e69 6465 6e74 6974 7928 6e29  = np.identity(n)
+0002e960: 0a20 2020 2020 2020 2023 2063 6c75 7374  .        # clust
+0002e970: 6572 2077 6569 6768 7473 3a0a 2020 2020  er weights:.    
+0002e980: 2020 2020 636c 7573 7465 7257 6569 6768      clusterWeigh
+0002e990: 7473 203d 206e 702e 7a65 726f 7328 6e32  ts = np.zeros(n2
+0002e9a0: 290a 2020 2020 2020 2020 636c 7573 7465  ).        cluste
+0002e9b0: 7257 6569 6768 7473 5b30 3a6e 5d20 3d20  rWeights[0:n] = 
+0002e9c0: 770a 2020 2020 2020 2020 2320 7765 6967  w.        # weig
+0002e9d0: 6874 2070 726f 6475 6374 733a 0a20 2020  ht products:.   
+0002e9e0: 2020 2020 2077 6569 6768 7450 726f 6475       weightProdu
+0002e9f0: 6374 7320 3d20 6e70 2e7a 6572 6f73 2828  cts = np.zeros((
+0002ea00: 6e32 2c20 6e32 292c 2064 7479 7065 3d44  n2, n2), dtype=D
+0002ea10: 4649 454c 4429 0a20 2020 2020 2020 2077  FIELD).        w
+0002ea20: 6569 6768 7450 726f 6475 6374 735b 303a  eightProducts[0:
+0002ea30: 6e2c 2030 3a6e 5d20 3d20 6e70 2e64 6f74  n, 0:n] = np.dot
+0002ea40: 2877 2e72 6573 6861 7065 2828 6e2c 2031  (w.reshape((n, 1
+0002ea50: 2929 2c20 772e 7265 7368 6170 6528 2831  )), w.reshape((1
+0002ea60: 2c20 6e29 2929 0a20 2020 2020 2020 2023  , n))).        #
+0002ea70: 206c 696e 6b65 6420 7765 6967 6874 733a   linked weights:
+0002ea80: 0a20 2020 2020 2020 2041 2c20 4170 6c75  .        A, Aplu
+0002ea90: 7320 3d20 7365 6c66 2e61 646a 6163 656e  s = self.adjacen
+0002eaa0: 6379 2c20 7365 6c66 2e73 705f 4170 6c75  cy, self.sp_Aplu
+0002eab0: 7328 292e 410a 2020 2020 2020 2020 6c69  s().A.        li
+0002eac0: 6e6b 6564 5765 6967 6874 7320 3d20 6e70  nkedWeights = np
+0002ead0: 2e7a 6572 6f73 2828 6e32 2c20 6e32 292c  .zeros((n2, n2),
+0002eae0: 2064 7479 7065 3d44 4649 454c 4429 0a20   dtype=DFIELD). 
+0002eaf0: 2020 2020 2020 206c 696e 6b65 6457 6569         linkedWei
+0002eb00: 6768 7473 5b30 3a6e 2c20 303a 6e5d 203d  ghts[0:n, 0:n] =
+0002eb10: 205c 0a20 2020 2020 2020 2020 2020 2073   \.            s
+0002eb20: 656c 662e 6e6f 6465 5f77 6569 6768 7473  elf.node_weights
+0002eb30: 2e72 6573 6861 7065 2828 6e2c 2031 2929  .reshape((n, 1))
+0002eb40: 202a 2041 706c 7573 202a 205c 0a20 2020   * Aplus * \.   
+0002eb50: 2020 2020 2020 2020 2073 656c 662e 6e6f           self.no
+0002eb60: 6465 5f77 6569 6768 7473 2e72 6573 6861  de_weights.resha
+0002eb70: 7065 2828 312c 206e 2929 0a20 2020 2020  pe((1, n)).     
+0002eb80: 2020 2023 2065 7272 6f72 2063 6f6e 7472     # error contr
+0002eb90: 6962 7574 696f 6e73 206f 6620 636c 7573  ibutions of clus
+0002eba0: 7465 7220 7061 6972 730a 2020 2020 2020  ter pairs.      
+0002ebb0: 2020 2320 2873 756d 2075 7020 746f 2074    # (sum up to t
+0002ebc0: 6f74 616c 2065 7272 6f72 203d 2032 2a48  otal error = 2*H
+0002ebd0: 616d 6d69 6e67 2064 6973 7461 6e63 6529  amming distance)
+0002ebe0: 3a0a 2020 2020 2020 2020 6572 726f 7273  :.        errors
+0002ebf0: 203d 206e 702e 7a65 726f 7328 286e 322c   = np.zeros((n2,
+0002ec00: 206e 3229 2c20 6474 7970 653d 4446 4945   n2), dtype=DFIE
+0002ec10: 4c44 290a 2020 2020 2020 2020 2320 6469  LD).        # di
+0002ec20: 7374 616e 6365 203d 2069 6e63 7265 6173  stance = increas
+0002ec30: 6520 6f66 2048 616d 6d69 6e67 2064 6973  e of Hamming dis
+0002ec40: 7461 6e63 653a 0a20 2020 2020 2020 2023  tance:.        #
+0002ec50: 2061 6e64 2066 696e 6420 6669 7273 7420   and find first 
+0002ec60: 7061 6972 2074 6f20 6a6f 696e 3a0a 2020  pair to join:.  
+0002ec70: 2020 2020 2020 6469 7374 616e 6365 7320        distances 
+0002ec80: 3d20 6e70 2e7a 6572 6f73 2828 6e32 2c20  = np.zeros((n2, 
+0002ec90: 6e32 292c 2064 7479 7065 3d44 4649 454c  n2), dtype=DFIEL
+0002eca0: 4429 0a0a 2020 2020 2020 2020 2320 6c69  D)..        # li
+0002ecb0: 7374 206f 6620 6163 7469 7665 2063 6c75  st of active clu
+0002ecc0: 7374 6572 2069 6e64 6963 6573 3a0a 2020  ster indices:.  
+0002ecd0: 2020 2020 2020 6163 7469 7665 496e 6469        activeIndi
+0002ece0: 6365 7320 3d20 7261 6e67 6528 302c 206e  ces = range(0, n
+0002ecf0: 290a 0a20 2020 2020 2020 2023 2066 696e  )..        # fin
+0002ed00: 616c 2048 616d 6d69 6e67 2064 6973 7461  al Hamming dista
+0002ed10: 6e63 6573 3a0a 2020 2020 2020 2020 6861  nces:.        ha
+0002ed20: 6d6d 696e 6720 3d20 6e70 2e7a 6572 6f73  mming = np.zeros
+0002ed30: 286e 3229 0a0a 2020 2020 2020 2020 2320  (n2)..        # 
+0002ed40: 6c69 7374 206f 6620 7061 7265 6e74 7320  list of parents 
+0002ed50: 616e 6420 7369 626c 696e 6773 3a0a 2020  and siblings:.  
+0002ed60: 2020 2020 2020 7369 626c 696e 6720 3d20        sibling = 
+0002ed70: 6e70 2e7a 6572 6f73 286e 322d 312c 2064  np.zeros(n2-1, d
+0002ed80: 7479 7065 3d69 6e74 290a 2020 2020 2020  type=int).      
+0002ed90: 2020 7061 7265 6e74 203d 206e 702e 7a65    parent = np.ze
+0002eda0: 726f 7328 6e32 2d31 2c20 6474 7970 653d  ros(n2-1, dtype=
+0002edb0: 696e 7429 0a0a 2020 2020 2020 2020 2320  int)..        # 
+0002edc0: 6c69 7374 206f 6620 7061 7274 733a 0a20  list of parts:. 
+0002edd0: 2020 2020 2020 2070 6172 7473 203d 206e         parts = n
+0002ede0: 702e 7a65 726f 7328 286e 322c 2032 292c  p.zeros((n2, 2),
+0002edf0: 2064 7479 7065 3d69 6e74 290a 2020 2020   dtype=int).    
+0002ee00: 2020 2020 7061 7274 735b 3a6e 5d20 3d20      parts[:n] = 
+0002ee10: 2d31 0a0a 2020 2020 2020 2020 6e6f 6465  -1..        node
+0002ee20: 3263 6c75 7374 6572 203d 206e 702e 7a65  2cluster = np.ze
+0002ee30: 726f 7328 286e 2c20 6e2b 3129 2c20 6474  ros((n, n+1), dt
+0002ee40: 7970 653d 696e 7429 0a20 2020 2020 2020  ype=int).       
+0002ee50: 206e 6f64 6532 636c 7573 7465 725b 3a2c   node2cluster[:,
+0002ee60: 2030 5d20 3d20 2d31 0a20 2020 2020 2020   0] = -1.       
+0002ee70: 206e 6f64 6532 636c 7573 7465 725b 3a2c   node2cluster[:,
+0002ee80: 206e 5d20 3d20 7261 6e67 6528 6e29 0a20   n] = range(n). 
+0002ee90: 2020 2020 2020 2063 6c75 7374 6572 3272         cluster2r
+0002eea0: 616e 6b20 3d20 6e70 2e7a 6572 6f73 2828  ank = np.zeros((
+0002eeb0: 6e32 2c20 6e2b 3129 2c20 6474 7970 653d  n2, n+1), dtype=
+0002eec0: 696e 7429 202d 2031 0a20 2020 2020 2020  int) - 1.       
+0002eed0: 2063 6c75 7374 6572 3272 616e 6b5b 302c   cluster2rank[0,
+0002eee0: 2031 5d20 3d20 300a 0a20 2020 2020 2020   1] = 0..       
+0002eef0: 206c 6173 7475 6e69 7465 6420 3d20 7061   lastunited = pa
+0002ef00: 7274 3120 3d20 7061 7274 3220 3d20 2d31  rt1 = part2 = -1
+0002ef10: 0a0a 2020 2020 2020 2020 2320 6974 6572  ..        # iter
+0002ef20: 6174 6976 656c 7920 6a6f 696e 2074 686f  atively join tho
+0002ef30: 7365 2074 776f 2063 6c75 7374 6572 7320  se two clusters 
+0002ef40: 7768 6963 6820 696e 6372 6561 7365 2048  which increase H
+0002ef50: 616d 6d69 6e67 2064 6973 7461 6e63 650a  amming distance.
+0002ef60: 2020 2020 2020 2020 2320 7468 6520 6c65          # the le
+0002ef70: 6173 743a 0a20 2020 2020 2020 2066 6f72  ast:.        for
+0002ef80: 2075 6e69 7465 6420 696e 2072 616e 6765   united in range
+0002ef90: 286e 2c20 6e32 293a 0a0a 2020 2020 2020  (n, n2):..      
+0002efa0: 2020 2020 2020 2320 6669 6e64 206e 6578        # find nex
+0002efb0: 7420 6f70 7469 6d61 6c20 7061 6972 3a0a  t optimal pair:.
+0002efc0: 0a20 2020 2020 2020 2020 2020 206e 4163  .            nAc
+0002efd0: 7469 7665 496e 6469 6365 7320 3d20 6c65  tiveIndices = le
+0002efe0: 6e28 6163 7469 7665 496e 6469 6365 7329  n(activeIndices)
+0002eff0: 0a20 2020 2020 2020 2020 2020 2074 6865  .            the
+0002f000: 4163 7469 7665 496e 6469 6365 7320 3d20  ActiveIndices = 
+0002f010: 6e70 2e73 6f72 7428 6163 7469 7665 496e  np.sort(activeIn
+0002f020: 6469 6365 7329 0a20 2020 2020 2020 2020  dices).         
+0002f030: 2020 206d 696e 6430 203d 2066 6c6f 6174     mind0 = float
+0002f040: 286e 702e 706f 7765 7228 312e 302a 7365  (np.power(1.0*se
+0002f050: 6c66 2e74 6f74 616c 5f6e 6f64 655f 7765  lf.total_node_we
+0002f060: 6967 6874 2c20 332e 3029 290a 2020 2020  ight, 3.0)).    
+0002f070: 2020 2020 2020 2020 6d69 6e77 7030 203d          minwp0 =
+0002f080: 2066 6c6f 6174 2832 2e30 2a77 6569 6768   float(2.0*weigh
+0002f090: 7450 726f 6475 6374 732e 6d61 7828 2929  tProducts.max())
+0002f0a0: 0a0a 2020 2020 2020 2020 2020 2020 7265  ..            re
+0002f0b0: 7375 6c74 203d 206e 702e 7a65 726f 7328  sult = np.zeros(
+0002f0c0: 332c 2064 7479 7065 3d44 4649 454c 4429  3, dtype=DFIELD)
+0002f0d0: 0a20 2020 2020 2020 2020 2020 205f 646f  .            _do
+0002f0e0: 5f6e 7369 5f68 616d 6d69 6e67 5f63 6c75  _nsi_hamming_clu
+0002f0f0: 7374 6572 696e 6728 0a20 2020 2020 2020  stering(.       
+0002f100: 2020 2020 2020 2020 206e 322c 206e 4163           n2, nAc
+0002f110: 7469 7665 496e 6469 6365 732c 206d 696e  tiveIndices, min
+0002f120: 6430 2c20 6d69 6e77 7030 2c20 6c61 7374  d0, minwp0, last
+0002f130: 756e 6974 6564 2c20 7061 7274 312c 2070  united, part1, p
+0002f140: 6172 7432 2c0a 2020 2020 2020 2020 2020  art2,.          
+0002f150: 2020 2020 2020 746f 5f63 7928 6469 7374        to_cy(dist
+0002f160: 616e 6365 732c 2044 4649 454c 4429 2c0a  ances, DFIELD),.
+0002f170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f180: 746f 5f63 7928 7468 6541 6374 6976 6549  to_cy(theActiveI
+0002f190: 6e64 6963 6573 2c20 4e4f 4445 292c 0a20  ndices, NODE),. 
+0002f1a0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0002f1b0: 6f5f 6379 286c 696e 6b65 6457 6569 6768  o_cy(linkedWeigh
+0002f1c0: 7473 2c20 4446 4945 4c44 292c 0a20 2020  ts, DFIELD),.   
+0002f1d0: 2020 2020 2020 2020 2020 2020 2074 6f5f               to_
+0002f1e0: 6379 2877 6569 6768 7450 726f 6475 6374  cy(weightProduct
+0002f1f0: 732c 2044 4649 454c 4429 2c0a 2020 2020  s, DFIELD),.    
+0002f200: 2020 2020 2020 2020 2020 2020 746f 5f63              to_c
+0002f210: 7928 6572 726f 7273 2c20 4446 4945 4c44  y(errors, DFIELD
+0002f220: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0002f230: 2020 2072 6573 756c 742c 0a20 2020 2020     result,.     
+0002f240: 2020 2020 2020 2020 2020 2074 6f5f 6379             to_cy
+0002f250: 286d 6179 4a6f 696e 2c20 4e4f 4445 2929  (mayJoin, NODE))
+0002f260: 0a0a 2020 2020 2020 2020 2020 2020 6d69  ..            mi
+0002f270: 6e64 203d 2072 6573 756c 745b 305d 0a20  nd = result[0]. 
+0002f280: 2020 2020 2020 2020 2020 2070 6172 7431             part1
+0002f290: 203d 2069 6e74 2872 6573 756c 745b 315d   = int(result[1]
+0002f2a0: 290a 2020 2020 2020 2020 2020 2020 7061  ).            pa
+0002f2b0: 7274 3220 3d20 696e 7428 7265 7375 6c74  rt2 = int(result
+0002f2c0: 5b32 5d29 0a20 2020 2020 2020 2020 2020  [2]).           
+0002f2d0: 2061 7373 6572 7420 6d69 6e64 203e 3d20   assert mind >= 
+0002f2e0: 300a 0a20 2020 2020 2020 2020 2020 2063  0..            c
+0002f2f0: 6c75 7374 6572 3272 616e 6b5b 6e70 2e61  luster2rank[np.a
+0002f300: 7272 6179 2861 6374 6976 6549 6e64 6963  rray(activeIndic
+0002f310: 6573 295b 0a20 2020 2020 2020 2020 2020  es)[.           
+0002f320: 2020 2020 2028 2d63 6c75 7374 6572 5765       (-clusterWe
+0002f330: 6967 6874 735b 6163 7469 7665 496e 6469  ights[activeIndi
+0002f340: 6365 735d 292e 6172 6773 6f72 7428 295d  ces]).argsort()]
+0002f350: 2c20 6e32 2b31 2d75 6e69 7465 645d 203d  , n2+1-united] =
+0002f360: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+0002f370: 2020 2072 616e 6765 286e 322b 312d 756e     range(n2+1-un
+0002f380: 6974 6564 290a 0a20 2020 2020 2020 2020  ited)..         
+0002f390: 2020 2068 616d 6d69 6e67 5b75 6e69 7465     hamming[unite
+0002f3a0: 645d 203d 2068 616d 6d69 6e67 5b75 6e69  d] = hamming[uni
+0002f3b0: 7465 642d 315d 202b 2032 2e30 202a 206d  ted-1] + 2.0 * m
+0002f3c0: 696e 640a 0a20 2020 2020 2020 2020 2020  ind..           
+0002f3d0: 2069 6620 756e 6974 6564 203c 206e 202b   if united < n +
+0002f3e0: 2031 3030 206f 7220 756e 6974 6564 2025   100 or united %
+0002f3f0: 2028 3120 2b20 6e32 2f31 3030 2920 3d3d   (1 + n2/100) ==
+0002f400: 2030 206f 7220 5c0a 2020 2020 2020 2020   0 or \.        
+0002f410: 2020 2020 2020 2020 2020 2020 756e 6974              unit
+0002f420: 6564 203e 3d20 6e32 202d 2031 3030 3a0a  ed >= n2 - 100:.
+0002f430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f440: 7072 696e 7428 6622 666f 7220 7b6e 322d  print(f"for {n2-
+0002f450: 756e 6974 6564 7d20 636c 7573 7465 7273  united} clusters
+0002f460: 2077 6974 6820 6572 726f 7220 220a 2020   with error ".  
+0002f470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f480: 2020 2020 6622 7b68 616d 6d69 6e67 5b75      f"{hamming[u
+0002f490: 6e69 7465 645d 2f57 577d 2077 6520 6a6f  nited]/WW} we jo
+0002f4a0: 696e 2063 6c75 7374 6572 7320 220a 2020  in clusters ".  
+0002f4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f4c0: 2020 2020 6622 7b70 6172 7431 7d20 616e      f"{part1} an
+0002f4d0: 6420 7b70 6172 7432 7d20 746f 2067 6574  d {part2} to get
+0002f4e0: 2063 6c75 7374 6572 207b 756e 6974 6564   cluster {united
+0002f4f0: 7d22 290a 2020 2020 2020 2020 2020 2020  }").            
+0002f500: 2020 2020 7379 732e 7374 646f 7574 2e66      sys.stdout.f
+0002f510: 6c75 7368 2829 0a0a 2020 2020 2020 2020  lush()..        
+0002f520: 2020 2020 2320 756e 6974 6520 7061 7274      # unite part
+0002f530: 733a 0a0a 2020 2020 2020 2020 2020 2020  s:..            
+0002f540: 7061 7265 6e74 5b70 6172 7431 5d20 3d20  parent[part1] = 
+0002f550: 7061 7265 6e74 5b70 6172 7432 5d20 3d20  parent[part2] = 
+0002f560: 756e 6974 6564 0a20 2020 2020 2020 2020  united.         
+0002f570: 2020 2070 6172 7473 5b75 6e69 7465 642c     parts[united,
+0002f580: 2030 5d20 3d20 7369 626c 696e 675b 7061   0] = sibling[pa
+0002f590: 7274 325d 203d 2070 6172 7431 0a20 2020  rt2] = part1.   
+0002f5a0: 2020 2020 2020 2020 2070 6172 7473 5b75           parts[u
+0002f5b0: 6e69 7465 642c 2031 5d20 3d20 7369 626c  nited, 1] = sibl
+0002f5c0: 696e 675b 7061 7274 315d 203d 2070 6172  ing[part1] = par
+0002f5d0: 7432 0a20 2020 2020 2020 2020 2020 2063  t2.            c
+0002f5e0: 6c75 7374 6572 4d65 6d62 6572 735b 756e  lusterMembers[un
+0002f5f0: 6974 6564 2c20 3a5d 203d 205c 0a20 2020  ited, :] = \.   
+0002f600: 2020 2020 2020 2020 2020 2020 2063 6c75               clu
+0002f610: 7374 6572 4d65 6d62 6572 735b 7061 7274  sterMembers[part
+0002f620: 312c 203a 5d20 2b20 636c 7573 7465 724d  1, :] + clusterM
+0002f630: 656d 6265 7273 5b70 6172 7432 2c20 3a5d  embers[part2, :]
+0002f640: 0a20 2020 2020 2020 2020 2020 206e 6f64  .            nod
+0002f650: 6532 636c 7573 7465 725b 3a2c 206e 322d  e2cluster[:, n2-
+0002f660: 756e 6974 6564 5d20 3d20 5c0a 2020 2020  united] = \.    
+0002f670: 2020 2020 2020 2020 2020 2020 6e6f 6465              node
+0002f680: 3263 6c75 7374 6572 5b3a 2c20 312b 6e32  2cluster[:, 1+n2
+0002f690: 2d75 6e69 7465 645d 202a 2028 312d 636c  -united] * (1-cl
+0002f6a0: 7573 7465 724d 656d 6265 7273 5b75 6e69  usterMembers[uni
+0002f6b0: 7465 642c 203a 5d29 202b 5c0a 2020 2020  ted, :]) +\.    
+0002f6c0: 2020 2020 2020 2020 2020 2020 756e 6974              unit
+0002f6d0: 6564 2a63 6c75 7374 6572 4d65 6d62 6572  ed*clusterMember
+0002f6e0: 735b 756e 6974 6564 2c20 3a5d 0a20 2020  s[united, :].   
+0002f6f0: 2020 2020 2020 2020 2061 6374 6976 6549           activeI
+0002f700: 6e64 6963 6573 2e72 656d 6f76 6528 7061  ndices.remove(pa
+0002f710: 7274 3129 0a20 2020 2020 2020 2020 2020  rt1).           
+0002f720: 2061 6374 6976 6549 6e64 6963 6573 2e72   activeIndices.r
+0002f730: 656d 6f76 6528 7061 7274 3229 0a20 2020  emove(part2).   
+0002f740: 2020 2020 2020 2020 2061 6374 6976 6549           activeI
+0002f750: 6e64 6963 6573 2e61 7070 656e 6428 756e  ndices.append(un
+0002f760: 6974 6564 290a 0a20 2020 2020 2020 2020  ited)..         
+0002f770: 2020 2023 2063 6f6d 7075 7465 206e 6577     # compute new
+0002f780: 2065 6e74 7269 6573 2069 6e20 636c 7573   entries in clus
+0002f790: 7465 7257 6569 6768 7473 2c20 7765 6967  terWeights, weig
+0002f7a0: 6874 5072 6f64 7563 7473 2c0a 2020 2020  htProducts,.    
+0002f7b0: 2020 2020 2020 2020 2320 6c69 6e6b 6564          # linked
+0002f7c0: 5765 6967 6874 732c 2065 7272 6f72 732c  Weights, errors,
+0002f7d0: 206d 6179 4a6f 696e 3a0a 2020 2020 2020   mayJoin:.      
+0002f7e0: 2020 2020 2020 636c 7573 7465 7257 6569        clusterWei
+0002f7f0: 6768 7473 5b75 6e69 7465 645d 203d 205c  ghts[united] = \
+0002f800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002f810: 2063 6c75 7374 6572 5765 6967 6874 735b   clusterWeights[
+0002f820: 7061 7274 315d 202b 2063 6c75 7374 6572  part1] + cluster
+0002f830: 5765 6967 6874 735b 7061 7274 325d 0a20  Weights[part2]. 
+0002f840: 2020 2020 2020 2020 2020 2077 6569 6768             weigh
+0002f850: 7450 726f 6475 6374 735b 756e 6974 6564  tProducts[united
+0002f860: 2c20 303a 756e 6974 6564 5d20 3d20 5c0a  , 0:united] = \.
+0002f870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002f880: 7765 6967 6874 5072 6f64 7563 7473 5b70  weightProducts[p
+0002f890: 6172 7431 2c20 303a 756e 6974 6564 5d20  art1, 0:united] 
+0002f8a0: 2b20 5c0a 2020 2020 2020 2020 2020 2020  + \.            
+0002f8b0: 2020 2020 7765 6967 6874 5072 6f64 7563      weightProduc
+0002f8c0: 7473 5b70 6172 7432 2c20 303a 756e 6974  ts[part2, 0:unit
+0002f8d0: 6564 5d0a 2020 2020 2020 2020 2020 2020  ed].            
+0002f8e0: 7765 6967 6874 5072 6f64 7563 7473 5b30  weightProducts[0
+0002f8f0: 3a75 6e69 7465 642c 2075 6e69 7465 645d  :united, united]
+0002f900: 203d 205c 0a20 2020 2020 2020 2020 2020   = \.           
+0002f910: 2020 2020 2077 6569 6768 7450 726f 6475       weightProdu
+0002f920: 6374 735b 756e 6974 6564 2c20 303a 756e  cts[united, 0:un
+0002f930: 6974 6564 5d2e 666c 6174 7465 6e28 290a  ited].flatten().
+0002f940: 2020 2020 2020 2020 2020 2020 7765 6967              weig
+0002f950: 6874 5072 6f64 7563 7473 5b75 6e69 7465  htProducts[unite
+0002f960: 642c 2075 6e69 7465 645d 203d 205c 0a20  d, united] = \. 
+0002f970: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+0002f980: 702e 706f 7765 7228 636c 7573 7465 7257  p.power(clusterW
+0002f990: 6569 6768 7473 5b75 6e69 7465 645d 2c20  eights[united], 
+0002f9a0: 322e 3029 0a20 2020 2020 2020 2020 2020  2.0).           
+0002f9b0: 206c 696e 6b65 6457 6569 6768 7473 5b75   linkedWeights[u
+0002f9c0: 6e69 7465 642c 2030 3a75 6e69 7465 645d  nited, 0:united]
+0002f9d0: 203d 205c 0a20 2020 2020 2020 2020 2020   = \.           
+0002f9e0: 2020 2020 206c 696e 6b65 6457 6569 6768       linkedWeigh
+0002f9f0: 7473 5b70 6172 7431 2c20 303a 756e 6974  ts[part1, 0:unit
+0002fa00: 6564 5d20 2b20 6c69 6e6b 6564 5765 6967  ed] + linkedWeig
+0002fa10: 6874 735b 7061 7274 322c 2030 3a75 6e69  hts[part2, 0:uni
+0002fa20: 7465 645d 0a20 2020 2020 2020 2020 2020  ted].           
+0002fa30: 206c 696e 6b65 6457 6569 6768 7473 5b30   linkedWeights[0
+0002fa40: 3a75 6e69 7465 642c 2075 6e69 7465 645d  :united, united]
+0002fa50: 203d 205c 0a20 2020 2020 2020 2020 2020   = \.           
+0002fa60: 2020 2020 206c 696e 6b65 6457 6569 6768       linkedWeigh
+0002fa70: 7473 5b75 6e69 7465 642c 2030 3a75 6e69  ts[united, 0:uni
+0002fa80: 7465 645d 2e66 6c61 7474 656e 2829 0a20  ted].flatten(). 
+0002fa90: 2020 2020 2020 2020 2020 206c 696e 6b65             linke
+0002faa0: 6457 6569 6768 7473 5b75 6e69 7465 642c  dWeights[united,
+0002fab0: 2075 6e69 7465 645d 203d 205c 0a20 2020   united] = \.   
+0002fac0: 2020 2020 2020 2020 2020 2020 206c 696e               lin
+0002fad0: 6b65 6457 6569 6768 7473 5b70 6172 7431  kedWeights[part1
+0002fae0: 2c20 7061 7274 315d 202b 206c 696e 6b65  , part1] + linke
+0002faf0: 6457 6569 6768 7473 5b70 6172 7432 2c20  dWeights[part2, 
+0002fb00: 7061 7274 325d 202b 205c 0a20 2020 2020  part2] + \.     
+0002fb10: 2020 2020 2020 2020 2020 2032 2e30 202a             2.0 *
+0002fb20: 206c 696e 6b65 6457 6569 6768 7473 5b70   linkedWeights[p
+0002fb30: 6172 7431 2c20 7061 7274 325d 0a20 2020  art1, part2].   
+0002fb40: 2020 2020 2020 2020 206d 6179 4a6f 696e           mayJoin
+0002fb50: 5b75 6e69 7465 642c 2030 3a75 6e69 7465  [united, 0:unite
+0002fb60: 645d 203d 205c 0a20 2020 2020 2020 2020  d] = \.         
+0002fb70: 2020 2020 2020 206d 6179 4a6f 696e 5b70         mayJoin[p
+0002fb80: 6172 7431 2c20 303a 756e 6974 6564 5d20  art1, 0:united] 
+0002fb90: 2b20 6d61 794a 6f69 6e5b 7061 7274 322c  + mayJoin[part2,
+0002fba0: 2030 3a75 6e69 7465 645d 0a20 2020 2020   0:united].     
+0002fbb0: 2020 2020 2020 206d 6179 4a6f 696e 5b30         mayJoin[0
+0002fbc0: 3a75 6e69 7465 642c 2075 6e69 7465 645d  :united, united]
+0002fbd0: 203d 206d 6179 4a6f 696e 5b75 6e69 7465   = mayJoin[unite
+0002fbe0: 642c 2030 3a75 6e69 7465 645d 2e66 6c61  d, 0:united].fla
+0002fbf0: 7474 656e 2829 0a20 2020 2020 2020 2020  tten().         
+0002fc00: 2020 2066 6f72 2063 2069 6e20 7261 6e67     for c in rang
+0002fc10: 6528 302c 2075 6e69 7465 6429 3a0a 2020  e(0, united):.  
+0002fc20: 2020 2020 2020 2020 2020 2020 2020 6c77                lw
+0002fc30: 203d 206c 696e 6b65 6457 6569 6768 7473   = linkedWeights
+0002fc40: 5b75 6e69 7465 642c 2063 5d0a 2020 2020  [united, c].    
+0002fc50: 2020 2020 2020 2020 2020 2020 6572 726f              erro
+0002fc60: 7273 5b75 6e69 7465 642c 2063 5d20 3d20  rs[united, c] = 
+0002fc70: 6572 726f 7273 5b63 2c20 756e 6974 6564  errors[c, united
+0002fc80: 5d20 3d20 5c0a 2020 2020 2020 2020 2020  ] = \.          
+0002fc90: 2020 2020 2020 2020 2020 6d69 6e28 6c77            min(lw
+0002fca0: 2c20 7765 6967 6874 5072 6f64 7563 7473  , weightProducts
+0002fcb0: 5b75 6e69 7465 642c 2063 5d20 2d20 6c77  [united, c] - lw
+0002fcc0: 290a 2020 2020 2020 2020 2020 2020 6572  ).            er
+0002fcd0: 726f 7273 5b75 6e69 7465 642c 2075 6e69  rors[united, uni
+0002fce0: 7465 645d 203d 205c 0a20 2020 2020 2020  ted] = \.       
+0002fcf0: 2020 2020 2020 2020 2077 6569 6768 7450           weightP
+0002fd00: 726f 6475 6374 735b 756e 6974 6564 2c20  roducts[united, 
+0002fd10: 756e 6974 6564 5d20 2d20 6c69 6e6b 6564  united] - linked
+0002fd20: 5765 6967 6874 735b 756e 6974 6564 2c20  Weights[united, 
+0002fd30: 756e 6974 6564 5d0a 2020 2020 2020 2020  united].        
+0002fd40: 2020 2020 6173 7365 7274 2065 7272 6f72      assert error
+0002fd50: 732e 6d69 6e28 2920 3e3d 202d 3165 2d31  s.min() >= -1e-1
+0002fd60: 300a 2020 2020 2020 2020 2020 2020 6c61  0.            la
+0002fd70: 7374 756e 6974 6564 203d 2075 6e69 7465  stunited = unite
+0002fd80: 640a 0a20 2020 2020 2020 2070 7269 6e74  d..        print
+0002fd90: 2874 696d 652e 7469 6d65 2829 2d74 302c  (time.time()-t0,
+0002fda0: 2022 7365 636f 6e64 7322 290a 0a20 2020   "seconds")..   
+0002fdb0: 2020 2020 2023 206e 6f64 6532 636c 7573       # node2clus
+0002fdc0: 7465 7220 3d20 6e70 2e61 7272 6179 2872  ter = np.array(r
+0002fdd0: 616e 6765 2830 2c20 6e32 2929 2e72 6573  ange(0, n2)).res
+0002fde0: 6861 7065 2828 6e32 2c20 3129 292a 636c  hape((n2, 1))*cl
+0002fdf0: 7573 7465 724d 656d 6265 7273 0a0a 2020  usterMembers..  
+0002fe00: 2020 2020 2020 6e6f 6465 5f69 6e5f 636c        node_in_cl
+0002fe10: 7573 7465 7220 3d20 636c 7573 7465 724d  uster = clusterM
+0002fe20: 656d 6265 7273 2e54 2e61 7374 7970 6528  embers.T.astype(
+0002fe30: 696e 7429 0a20 2020 2020 2020 2065 7272  int).        err
+0002fe40: 6f72 203d 206e 702e 7a65 726f 7328 6e2b  or = np.zeros(n+
+0002fe50: 3129 0a20 2020 2020 2020 2065 7272 6f72  1).        error
+0002fe60: 5b30 5d20 3d20 6e70 2e69 6e66 0a20 2020  [0] = np.inf.   
+0002fe70: 2020 2020 2065 7272 6f72 5b2d 312d 6e70       error[-1-np
+0002fe80: 2e61 7261 6e67 6528 6e29 5d20 3d20 6861  .arange(n)] = ha
+0002fe90: 6d6d 696e 675b 2d6e 3a5d 202f 2057 570a  mming[-n:] / WW.
+0002fea0: 0a20 2020 2020 2020 2069 6620 7472 6565  .        if tree
+0002feb0: 5f64 6f74 6669 6c65 2069 7320 6e6f 7420  _dotfile is not 
+0002fec0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0002fed0: 2020 6564 6765 7320 3d20 5b28 696e 7428    edges = [(int(
+0002fee0: 6929 2c20 696e 7428 7061 7265 6e74 5b69  i), int(parent[i
+0002fef0: 5d29 2920 666f 7220 6920 696e 2072 616e  ])) for i in ran
+0002ff00: 6765 286e 322d 3129 5d0a 2020 2020 2020  ge(n2-1)].      
+0002ff10: 2020 2020 2020 6d69 6e6c 656e 203d 205b        minlen = [
+0002ff20: 696e 7428 7061 7265 6e74 5b69 5d2d 6d61  int(parent[i]-ma
+0002ff30: 7828 692c 206e 2d31 2929 2066 6f72 2069  x(i, n-1)) for i
+0002ff40: 2069 6e20 7261 6e67 6528 6e32 2d31 295d   in range(n2-1)]
+0002ff50: 0a20 2020 2020 2020 2020 2020 2074 7265  .            tre
+0002ff60: 6520 3d20 6967 7261 7068 2e47 7261 7068  e = igraph.Graph
+0002ff70: 2865 6467 6573 2c20 6469 7265 6374 6564  (edges, directed
+0002ff80: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
+0002ff90: 2020 2074 7265 652e 6573 2e73 6574 5f61     tree.es.set_a
+0002ffa0: 7474 7269 6275 7465 5f76 616c 7565 7328  ttribute_values(
+0002ffb0: 226d 696e 6c65 6e22 2c20 6d69 6e6c 656e  "minlen", minlen
+0002ffc0: 290a 2020 2020 2020 2020 2020 2020 7472  ).            tr
+0002ffd0: 6565 5b22 7261 6e6b 6469 7222 5d20 3d20  ee["rankdir"] = 
+0002ffe0: 224c 5222 0a20 2020 2020 2020 2020 2020  "LR".           
+0002fff0: 2074 7265 652e 7772 6974 655f 646f 7428   tree.write_dot(
+00030000: 7472 6565 5f64 6f74 6669 6c65 290a 2020  tree_dotfile).  
+00030010: 2020 2020 2020 2020 2020 6465 6c20 7472            del tr
+00030020: 6565 0a0a 2020 2020 2020 2020 7265 7475  ee..        retu
+00030030: 726e 207b 0a20 2020 2020 2020 2020 2020  rn {.           
+00030040: 2022 6e6f 6465 3263 6c75 7374 6572 223a   "node2cluster":
+00030050: 206e 6f64 6532 636c 7573 7465 722c 2022   node2cluster, "
+00030060: 636c 7573 7465 7232 7261 6e6b 223a 2063  cluster2rank": c
+00030070: 6c75 7374 6572 3272 616e 6b2c 0a20 2020  luster2rank,.   
+00030080: 2020 2020 2020 2020 2022 636c 7573 7465           "cluste
+00030090: 725f 7765 6967 6874 223a 2063 6c75 7374  r_weight": clust
+000300a0: 6572 5765 6967 6874 732c 0a20 2020 2020  erWeights,.     
+000300b0: 2020 2020 2020 2022 6e6f 6465 5f69 6e5f         "node_in_
+000300c0: 636c 7573 7465 7222 3a20 6e6f 6465 5f69  cluster": node_i
+000300d0: 6e5f 636c 7573 7465 722c 2022 6572 726f  n_cluster, "erro
+000300e0: 7222 3a20 6572 726f 722c 0a20 2020 2020  r": error,.     
+000300f0: 2020 2020 2020 2022 6368 696c 6472 656e         "children
+00030100: 223a 2070 6172 7473 2c20 2273 6962 6c69  ": parts, "sibli
+00030110: 6e67 223a 2073 6962 6c69 6e67 2c20 2270  ng": sibling, "p
+00030120: 6172 656e 7422 3a20 7061 7265 6e74 0a20  arent": parent. 
+00030130: 2020 2020 2020 207d 0a                          }.
```

### Comparing `pyunicorn-0.6.1/pyunicorn/core/data.py` & `pyunicorn-0.7.0/src/pyunicorn/core/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -16,35 +13,28 @@
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for analyzing spatially embedded complex networks, handling
 multivariate data and generating time series surrogates.
 """
 
-#
-#  Imports
-#
+from typing import Optional
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
-
-#  Import netCDF4 for a NetCDF4 reader
 try:
-    import netCDF4
+    from h5netcdf.legacyapi import Dataset
 except ImportError:
-    print("pyunicorn: Package netCDF4 could not be loaded. Some "
-          "functionality in class Data might not be available!")
+    try:
+        from netCDF4 import Dataset
+    except ImportError:
+        print("pyunicorn: Packages netCDF4 or h5netcdf could not be loaded. "
+              "Some functionality in class Data might not be available!")
 
+from .geo_grid import GeoGrid
 
-from .grid import Grid
-
-
-#
-#  Define class Data
-#
 
 class Data:
 
     """
     Encapsulates general spatio-temporal data.
 
     Also contains methods to load data from various file formats
@@ -53,42 +43,45 @@
     Mainly an abstract class.
     """
 
     #
     #  Define internal methods
     #
 
-    def __init__(self, observable, grid, observable_name=None,
-                 observable_long_name=None, window=None, silence_level=0):
+    def __init__(self, observable: np.ndarray, grid: GeoGrid,
+                 observable_name: str = None, observable_long_name: str = None,
+                 window: Optional[dict] = None, silence_level: int = 0):
         """
         Initialize an instance of Data.
 
         The spatio-temporal window is described by the following dictionary::
 
             window = {"time_min": 0., "time_max": 0., "lat_min": 0.,
                       "lat_max": 0., "lon_min": 0., "lon_max": 0.}
 
         :type observable: 2D array [time, index]
         :arg observable: The array of time series to be represented by the
             :class:`Data` instance.
-        :type grid: :class:`.Grid` instance
-        :arg grid: The Grid representing the spatial coordinates associated to
-            the time series and their temporal sampling.
+        :type grid: :class:`.GeoGrid` instance
+        :arg grid: The GeoGrid representing the spatial coordinates associated
+            to the time series and their temporal sampling.
         :arg str observable_name: A short name for the observable.
         :arg str observable_long_name: A long name for the observable.
         :arg dict window: Spatio-temporal window to select a view on the data.
         :arg int silence_level: The inverse level of verbosity of the object.
         """
 
         self.silence_level = silence_level
         """(int) - The inverse level of verbosity of the object."""
         self._full_observable = observable
+
+        assert isinstance(grid, GeoGrid)
         self._full_grid = grid
         self.grid = None
-        """The :class:`.Grid` object associated with the data."""
+        """The :class:`.GeoGrid` object associated with the data."""
 
         self.observable_name = observable_name
         """(str) - The short name of the observable within
                       data file (particularly relevant for NetCDF)."""
 
         self.observable_long_name = observable_long_name
         """(str) - The long name of the observable within data file."""
@@ -110,42 +103,31 @@
             Data.set_window(self, window)
 
     def __str__(self):
         """Return a string representation of the object."""
         if self.file_name:
             self.print_data_info()
 
-        return ('Data: %i grid points, %i measurements.\n'
-                'Geographical boundaries:\n%s') % (
-                    self.grid.N, self.grid.n_grid_points,
-                    self.grid.print_boundaries())
+        return (f"Data: {self.grid.N} grid points, "
+                f"{self.grid.n_grid_points} measurements.\n"
+                f"Geographical boundaries:\n{self.grid.print_boundaries()}")
 
     def set_silence_level(self, silence_level):
         """
         Set the silence level.
 
         Includes dependent objects such as :attr:`grid`.
 
         :type silence_level: number (int)
         :arg silence_level: The inverse level of verbosity of the object.
         """
         self.silence_level = silence_level
         self.grid.silence_level = silence_level
         self._full_grid.silence_level = silence_level
 
-    def clear_cache(self):
-        """
-        Clean up cache.
-
-        Is reversible, since all cached information can be recalculated from
-        basic data.
-        """
-        self.grid.clear_cache()
-        self._full_grid.clear_cache()
-
     #
     #  Methods for creating Data objects and alternative constructors
     #
 
     @classmethod
     def Load(cls, file_name, observable_name, file_type, dimension_names=None,
              window=None, vertical_level=None, silence_level=0):
@@ -238,15 +220,16 @@
         """
         #  Create time series
         ts = np.zeros((10, 6))
 
         for i in range(6):
             ts[:, i] = np.sin(np.arange(10) * np.pi / 10. + i * np.pi / 2.)
 
-        return Data(observable=ts, grid=Grid.SmallTestGrid(), silence_level=2)
+        return Data(observable=ts, grid=GeoGrid.SmallTestGrid(),
+                    silence_level=2)
 
     #
     #  Defines methods to load data from files and display related information
     #
 
     @classmethod
     def _get_netcdf_data(cls, file_name, file_type, observable_name,
@@ -273,33 +256,33 @@
         """
         if silence_level <= 1:
             print("Reading NetCDF File and converting data to NumPy array...")
 
         # Initialize dictionary of results
         res = {}
 
-        # Open netCDF3 or netCDF4 file
-        f = netCDF4.Dataset(file_name, "r")
+        # Open netCDF4 file
+        f = Dataset(file_name, "r")
 
         # Create reference to observable
         observable = f.variables[observable_name][:].astype("float32")
 
         # Get time axis from NetCDF file
         time = f.variables[dimension_names["time"]][:].astype("float32")
 
         # Get number of dimensions of data
         n_dim = observable.ndim
 
         # Distinguish between regular and irregular grids
         if file_type == "NetCDF":
-            # Create Grid instance
+            # Create GeoGrid instance
             lat_grid = f.variables[dimension_names["lat"]][:].astype("float32")
             lon_grid = f.variables[dimension_names["lon"]][:].astype("float32")
-            res["grid"] = Grid.RegularGrid(time, lat_grid, lon_grid,
-                                           silence_level)
+            res["grid"] = GeoGrid.RegularGrid(time, (lat_grid, lon_grid),
+                                              silence_level)
 
             # If 3D data set (time, lat, lon), select whole data set
             if n_dim == 3:
                 res["observable"] = observable.copy()
             # If 4D data set (time, level, lat, lon), select certain vertical
             # level.
             elif n_dim == 4:
@@ -312,18 +295,18 @@
                 res["observable"] = observable[:, level, :, :].copy()
             else:
                 print("Regular NetCDF data sets with dimensions other than "
                       "3 (time, lat, lon) or 4 (time, level, lat, lon) are "
                       "not supported by Data class!")
 
         elif file_type == "iNetCDF":
-            # Create Grid instance
+            # Create GeoGrid instance
             lat_seq = f.variables["grid_center_lat"][:].astype("float32")
             lon_seq = f.variables["grid_center_lon"][:].astype("float32")
-            res["grid"] = Grid(time, lat_seq, lon_seq, silence_level)
+            res["grid"] = GeoGrid(time, lat_seq, lon_seq, silence_level)
 
             # If 2D data set (time, index), select whole data set
             if n_dim == 2:
                 res["observable"] = observable.copy()
             # If 3D data set (time, level, index), select certain vertical
             # level.
             elif n_dim == 3:
@@ -353,15 +336,15 @@
         f.close()
         return res
 
     @classmethod
     def _load_data(cls, file_name, file_type, observable_name,
                    dimension_names, vertical_level=None, silence_level=0):
         """
-        Load data into a Numpy array and create a corresponding Grid object.
+        Load data into a Numpy array and create a corresponding GeoGrid object.
 
         Supported file types ``file_type`` are:
           - "NetCDF" for regular (rectangular) grids
           - "iNetCDF" for irregular (e.g. geodesic) grids or station data
 
         :arg str file_name: The name of the data file.
         :arg str file_type: The format of the data file.
@@ -383,23 +366,22 @@
             if silence_level <= 1:
                 print("This file type can currently not be read "
                       "by pyunicorn.")
             return None
 
     def print_data_info(self):
         """Print information on the data encapsulated by the Data object."""
-        # Open netCDF3 or netCDF4 file
-        f = netCDF4.Dataset(self.file_name, "r")
-        print("File format:", f.file_format)
+        # Open netCDF4 file
+        f = Dataset(self.file_name, "r")
         print("Global attributes:")
         for name in f.ncattrs():
             print(name + ":", getattr(f, name))
         print("Variables (size):")
         for name, obj in f.variables.items():
-            print("%s (%i)" % (name, len(obj)))
+            print(f"{name} ({len(obj)})")
         f.close()
 
     def observable(self):
         """
         Return the current spatio-temporal view on the data.
 
         **Example:**
@@ -434,15 +416,15 @@
         """
         return self.grid.boundaries()
 
     def set_window(self, window):
         """
         Select a rectangular spatio-temporal region from the data set.
 
-        Create a data array as well as a corresponding Grid object to access
+        Create a data array as well as a corresponding GeoGrid object to access
         this window.
 
         The time axis of the underlying raw data is assumed to be ordered and
         increasing. The latitude and longitude sequences can be arbitrarily
         chosen, i.e., no ordering and no regular grid is required.
 
         The spatio-temporal window is described by the following dictionary::
@@ -506,22 +488,22 @@
         # Set windowed observable and grid object
         time = full_time[time_indices]
         lat_seq = full_lat_seq[space_indices]
         lon_seq = full_lon_seq[space_indices]
 
         self._observable = \
             self._full_observable[time_indices, :][:, space_indices]
-        self.grid = Grid(time, lat_seq, lon_seq, self.silence_level)
+        self.grid = GeoGrid(time, lat_seq, lon_seq, self.silence_level)
 
     def set_global_window(self):
         """
         Set the view on the whole data set.
 
         Select the full data set and creates a data array as well as
-        a corresponding Grid object to access this window from outside.
+        a corresponding GeoGrid object to access this window from outside.
 
         **Example** (Set smaller window and subsequently restore global
         window):
 
         >>> data = Data.SmallTestData()
         >>> data.set_window(window={"time_min": 0., "time_max": 4.,
         ...                 "lat_min": 10., "lat_max": 20., "lon_min": 5.,
@@ -586,16 +568,15 @@
         elif var_type == 'uint8':
             scale_factor = (ar_max - ar_min) / (2. ** 8 - 1.)
             add_offset = ar_min
             array -= add_offset
             array /= scale_factor
             scaled_array = array.astype('uint8')
         else:
-            print("Data type %s variable %s for rescaling array "
-                  "not supported!" % var_type)
+            print(f"Data type {var_type} not supported!")
             scale_factor = 1.
             add_offset = 0.
 
         return (scaled_array, scale_factor, add_offset, actual_range)
 
     #
     #  Define methods to prepare data for similarity measure calculation
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/joint_recurrence_network.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/joint_recurrence_network.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -153,16 +150,17 @@
             raise ValueError("Delay value (lag) must not exceed length of \
                              time series!")
 
     def __str__(self):
         """
         Returns a string representation.
         """
-        return 'JointRecurrenceNetwork:\n%s\n%s' % (
-            JointRecurrencePlot.__str__(self), Network.__str__(self))
+        return ("JointRecurrenceNetwork:\n"
+                f"{JointRecurrencePlot.__str__(self)}\n"
+                f"{Network.__str__(self)}")
 
     def clear_cache(self):
         """
         Clean up memory by deleting information that can be recalculated from
         basic data.
 
         Extends the clean up methods of the parent classes.
@@ -215,25 +213,25 @@
 
         #  Create a Network object interpreting the recurrence matrix as the
         #  graph adjacency matrix. Joint recurrence networks are undirected by
         #  definition.
         Network.__init__(self, A, directed=False,
                          silence_level=self.silence_level)
 
-    def set_fixed_recurrence_rate(self, density):
+    def set_fixed_recurrence_rate(self, recurrence_rate):
         """
         Create a joint recurrence network at fixed link densities (recurrence
         rates).
 
-        :type density: tuple of number
-        :arg density: The link density / recurrence rate. Give for each time
-            series separately.
+        :type recurrence_rate: tuple of number
+        :arg recurrence_rate: The link density / recurrence rate.
+            Give for each time series separately.
         """
         #  Set fixed recurrence rate on recurrence plot level
-        JointRecurrencePlot.set_fixed_recurrence_rate(self, density)
+        JointRecurrencePlot.set_fixed_recurrence_rate(self, recurrence_rate)
 
         #  Set diagonal of JR to zero to avoid self-loops in the joint
         #  recurrence network
         A = self.JR.copy()
         A.flat[::self.N+1] = 0
 
         #  Create a Network object interpreting the recurrence matrix as the
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/recurrence_network.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/recurrence_network.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -147,16 +144,17 @@
                              node_weights=node_weights,
                              silence_level=silence_level)
 
     def __str__(self):
         """
         Returns a string representation.
         """
-        return 'RecurrenceNetwork:\n%s\n%s' % (
-            RecurrencePlot.__str__(self), Network.__str__(self))
+        return (f"RecurrenceNetwork:\n"
+                f"{RecurrencePlot.__str__(self)}\n"
+                f"{Network.__str__(self)}")
 
     def clear_cache(self):
         """
         Clean up memory by deleting information that can be recalculated from
         basic data.
 
         Extends the clean up methods of the parent classes.
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/cross_recurrence_plot.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/cross_recurrence_plot.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -17,29 +14,27 @@
 
 """
 Provides classes for the analysis of dynamical systems and time series based
 on recurrence plots, including measures of recurrence quantification
 analysis (RQA) and recurrence network analysis.
 """
 
-# array object and fast numerics
+from typing import Tuple
+from collections.abc import Hashable
+
 import numpy as np
 
+from ..core.cache import Cached
+from .recurrence_plot import RecurrencePlot
+from ..core._ext.types import to_cy, DFIELD
 from ._ext.numerics import _manhattan_distance_matrix_crp, \
     _euclidean_distance_matrix_crp, _supremum_distance_matrix_crp
 
-from .recurrence_plot import RecurrencePlot
-
-#
-#  Class definitions
-#
-
 
 class CrossRecurrencePlot(RecurrencePlot):
-
     """
     Class CrossRecurrencePlot for generating and quantitatively analyzing
     :index:`cross recurrence plots <single: cross recurrence plot>`.
 
     The CrossRecurrencePlot class supports the construction of cross recurrence
     plots from two multi-dimensional time series, optionally using embedding.
     Currently, manhattan, euclidean and supremum norms are provided for
@@ -106,16 +101,16 @@
         :arg number tau: The embedding delay.
         """
         threshold = kwds.get("threshold")
         recurrence_rate = kwds.get("recurrence_rate")
 
         RecurrencePlot.__init__(
             self, np.empty((2, 0)), metric=metric, normalize=normalize,
-            sparse_rqa=sparse_rqa, threshold=threshold,
-            recurrence_rate=recurrence_rate, silence_level=silence_level)
+            sparse_rqa=sparse_rqa, silence_level=silence_level,
+            skip_recurrence=True)
 
         self.CR = None
         """The cross recurrence matrix."""
         self.N = 0
         """The length of the embedded time series x."""
         self.M = 0
         """The length of the embedded time series y."""
@@ -135,20 +130,19 @@
             self.normalize_time_series(self.x)
             self.normalize_time_series(self.y)
 
         #  Get embedding dimension and delay from **kwds
         dim = kwds.get("dim")
         tau = kwds.get("tau")
 
-        if dim is not None and tau is not None:
+        self._mut_embedding: int = 0
+        if (dim is not None) and (tau is not None):
             #  Embed the time series
             self.x_embedded = self.embed_time_series(self.x, dim, tau)
-            """The embedded time series x."""
             self.y_embedded = self.embed_time_series(self.y, dim, tau)
-            """The embedded time series y."""
         else:
             self.x_embedded = self.x
             self.y_embedded = self.y
 
         #  construct recurrence plot accordingly to threshold / recurrence rate
         if threshold is not None:
             #  Calculate the recurrence matrix R using the radius of
@@ -158,158 +152,142 @@
             #  Calculate the recurrence matrix R using a fixed recurrence rate
             CrossRecurrencePlot.\
                 set_fixed_recurrence_rate(self, recurrence_rate)
         else:
             raise NameError("Please give either threshold or recurrence_rate \
                             to construct the cross recurrence plot!")
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return (self._mut_embedding,)
+
     def __str__(self):
         """
         Returns a string representation.
         """
-        return ('CrossRecurrencePlot: time series shapes %s, %s.\n'
-                'Embedding dimension %i\nThreshold %s, %s metric') % (
-                    self.x.shape, self.y.shape, self.dim if self.dim else 0,
-                    self.threshold, self.metric)
+        return ("CrossRecurrencePlot: "
+                f"time series shapes {self.x.shape}, {self.y.shape}.\n"
+                f"Embedding dimension {self.dim if self.dim else 0}\n"
+                f"Threshold {self.threshold}, {self.metric} metric")
+
+    @property
+    def x_embedded(self) -> np.ndarray:
+        """
+        The embedded time series x.
+        """
+        return self._x_embedded
+
+    @x_embedded.setter
+    def x_embedded(self, embedding: np.ndarray):
+        self._x_embedded = to_cy(embedding, DFIELD)
+        self._mut_embedding += 1
+
+    @property
+    def y_embedded(self) -> np.ndarray:
+        """
+        The embedded time series y.
+        """
+        return self._y_embedded
+
+    @y_embedded.setter
+    def y_embedded(self, embedding: np.ndarray):
+        self._y_embedded = to_cy(embedding, DFIELD)
+        self._mut_embedding += 1
 
     #
     #  Service methods
     #
 
     def recurrence_matrix(self):
         """
         Return the current cross recurrence matrix :math:`CR`.
 
         :rtype: 2D square Numpy array
         :return: the current cross recurrence matrix :math:`CR`.
         """
         return self.CR
 
-    def distance_matrix(self, x_embedded, y_embedded, metric):
+    def distance_matrix(self, metric):
         """
         Return phase space cross distance matrix :math:`D` according to the
         chosen metric.
 
-        :type x_embedded: 2D array (time, embedding dimension)
-        :arg x_embedded: The phase space trajectory x.
-        :type y_embedded: 2D array (time, embedding dimension)
-        :arg y_embedded: The phase space trajectory y.
         :arg str metric: The metric for measuring distances in phase space
             ("manhattan", "euclidean", "supremum").
         :rtype: 2D square array
         :return: the phase space cross distance matrix :math:`D`
         """
-        #  Return distance matrix according to chosen metric:
-        if metric == "manhattan":
-            return self.manhattan_distance_matrix(x_embedded, y_embedded)
-        elif metric == "euclidean":
-            return self.euclidean_distance_matrix(x_embedded, y_embedded)
-        elif metric == "supremum":
-            return self.supremum_distance_matrix(x_embedded, y_embedded)
-        else:
-            return None
+        assert metric in self._known_metrics, f"unknown metric: {metric}"
+        return getattr(self, f"{metric}_distance_matrix")()
 
     #
     #  Calculate recurrence plot
     #
 
-    def manhattan_distance_matrix(self, x_embedded, y_embedded):
+    @Cached.method(name="the manhattan distance matrix")
+    def manhattan_distance_matrix(self):
         """
         Return the manhattan distance matrix from two (embedded) time series.
 
         :type x_embedded: 2D Numpy array (time, embedding dimension)
         :arg x_embedded: The phase space trajectory x.
         :type y_embedded: 2D Numpy array (time, embedding dimension)
         :arg y_embedded: The phase space trajectory y.
-        :rtype: 2D rectangular Numpy array ("float32")
+        :rtype: 2D rectangular Numpy array
         :return: the manhattan distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating the manhattan distance matrix...")
-
-        ntime_x = x_embedded.shape[0]
-        ntime_y = y_embedded.shape[0]
-        dim = x_embedded.shape[1]
-        x_embedded = x_embedded.astype('double').copy(order='c')
-        y_embedded = y_embedded.astype('double').copy(order='c')
+        ntime_x = self.x_embedded.shape[0]
+        ntime_y = self.y_embedded.shape[0]
+        dim = self.x_embedded.shape[1]
         return _manhattan_distance_matrix_crp(ntime_x, ntime_y, dim,
-                                              x_embedded, y_embedded)
+                                              self.x_embedded, self.y_embedded)
 
-    def euclidean_distance_matrix(self, x_embedded, y_embedded):
+    @Cached.method(name="the euclidean distance matrix")
+    def euclidean_distance_matrix(self):
         """
         Return the euclidean distance matrix from two (embedded) time series.
 
-        :type x_embedded: 2D Numpy array (time, embedding dimension)
-        :arg x_embedded: The phase space trajectory x.
-        :type y_embedded: 2D Numpy array (time, embedding dimension)
-        :arg y_embedded: The phase space trajectory y.
-        :rtype: 2D rectangular Numpy array ("float32")
+        :rtype: 2D rectangular Numpy array
         :return: the euclidean distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating the euclidean distance matrix...")
-
-        ntime_x = x_embedded.shape[0]
-        ntime_y = y_embedded.shape[0]
-        dim = x_embedded.shape[1]
-        x_embedded = x_embedded.astype('double').copy(order='c')
-        y_embedded = y_embedded.astype('double').copy(order='c')
+        ntime_x = self.x_embedded.shape[0]
+        ntime_y = self.y_embedded.shape[0]
+        dim = self.x_embedded.shape[1]
         return _euclidean_distance_matrix_crp(ntime_x, ntime_y, dim,
-                                              x_embedded, y_embedded)
+                                              self.x_embedded, self.y_embedded)
 
-    def supremum_distance_matrix(self, x_embedded, y_embedded):
+    @Cached.method(name="the supremum distance matrix")
+    def supremum_distance_matrix(self):
         """
         Return the supremum distance matrix from two (embedded) time series.
 
-        :type x_embedded: 2D Numpy array (time, embedding dimension)
-        :arg x_embedded: The phase space trajectory x.
-        :type y_embedded: 2D Numpy array (time, embedding dimension)
-        :arg y_embedded: The phase space trajectory y.
-        :rtype: 2D rectangular Numpy array ("float32")
+        :rtype: 2D rectangular Numpy array
         :return: the supremum distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating the supremum distance matrix...")
-
-        ntime_x = x_embedded.shape[0]
-        ntime_y = y_embedded.shape[0]
-        dim = x_embedded.shape[1]
-        x_embedded = x_embedded.astype('float32').copy(order='c')
-        y_embedded = y_embedded.astype('float32').copy(order='c')
-        return _supremum_distance_matrix_crp(ntime_x, ntime_y, dim, x_embedded,
-                                             y_embedded)
+        ntime_x = self.x_embedded.shape[0]
+        ntime_y = self.y_embedded.shape[0]
+        dim = self.x_embedded.shape[1]
+        return _supremum_distance_matrix_crp(ntime_x, ntime_y, dim,
+                                             self.x_embedded, self.y_embedded)
 
     def set_fixed_threshold(self, threshold):
         """
         Set the cross recurrence plot to a fixed threshold.
 
         Modifies / sets the class variables :attr:`CR`, :attr:`N` and :attr:`M`
         accordingly.
 
         :arg number threshold: The recurrence threshold.
         """
         if self.silence_level <= 1:
             print("Calculating cross recurrence plot at fixed threshold...")
 
-        #  Get distance matrix, according to self.metric
-        distance = self.distance_matrix(self.x_embedded, self.y_embedded,
-                                        self.metric)
-        print(distance)
-        #  Get length of time series x and y
+        distance = self.distance_matrix(self.metric)
         (N, M) = distance.shape
-
-        #  Initialize recurrence matrix
         recurrence = np.zeros((N, M), dtype="int8")
-
-        #  Thresholding the distance matrix
         recurrence[distance < threshold] = 1
-
-        #  Clean up
-        del distance
-
         self.CR = recurrence
         self.N = N
         self.M = M
 
     def set_fixed_recurrence_rate(self, recurrence_rate):
         """
         Set the cross recurrence plot to a fixed recurrence rate.
@@ -319,34 +297,20 @@
 
         :arg number recurrence_rate: The recurrence rate.
         """
         if self.silence_level <= 1:
             print("Calculating cross recurrence plot at "
                   "fixed recurrence rate...")
 
-        #  Get distance matrix, according to self.metric
-        distance = self.distance_matrix(self.x_embedded, self.y_embedded,
-                                        self.metric)
-
-        #  Get length of time series x and y
+        distance = self.distance_matrix(self.metric)
         (N, M) = distance.shape
-
-        #  Get threshold to obtain fixed recurrence rate
         threshold = self.threshold_from_recurrence_rate(distance,
                                                         recurrence_rate)
-
-        #  Initialize recurrence matrix
         recurrence = np.zeros((N, M), dtype="int8")
-
-        #  Thresholding the distance matrix
         recurrence[distance < threshold] = 1
-
-        #  Clean up
-        del distance
-
         self.CR = recurrence
         self.N = N
         self.M = M
 
     #
     #  Extended RQA measures
     #
@@ -390,7 +354,25 @@
         #  Get sum of lower triangle of cross recurrence matrix, excluding the
         #  main diagonal
         lower_triangle_sum = np.tril(CR, k=-1).sum()
 
         #  Return balance
         return (upper_triangle_sum - lower_triangle_sum) / \
             float(upper_triangle_sum + lower_triangle_sum)
+
+    def diagline_dist(self):
+        """Not implemented yet"""
+        raise NotImplementedError(
+            "Line distributions are not yet "
+            "available for cross-recurrence plots")
+
+    def vertline_dist(self):
+        """Not implemented yet"""
+        raise NotImplementedError(
+            "Line distributions are not yet "
+            "available for cross-recurrence plots")
+
+    def white_vertline_dist(self):
+        """Not implemented yet"""
+        raise NotImplementedError(
+            "Line distributions are not yet "
+            "available for cross-recurrence plots")
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/joint_recurrence_plot.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/joint_recurrence_plot.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -17,28 +14,19 @@
 
 """
 Provides classes for the analysis of dynamical systems and time series based
 on recurrence plots, including measures of recurrence quantification
 analysis (RQA) and recurrence network analysis.
 """
 
-#
-#  Import essential packages
-#
-
-# array object and fast numerics
 import numpy as np
 
 from .recurrence_plot import RecurrencePlot
 
 
-#
-#  Class definitions
-#
-
 class JointRecurrencePlot(RecurrencePlot):
 
     """
     Class JointRecurrencePlot for generating and quantitatively analyzing
     :index:`joint recurrence plots <single: joint recurrence plot>`.
 
     The JointRecurrencePlot class supports the construction of joint recurrence
@@ -126,20 +114,26 @@
         :type tau: tuple of number
         :keyword tau: Embedding delay. Give separately for each time series.
         """
         threshold = kwds.get("threshold")
         threshold_std = kwds.get("threshold_std")
         recurrence_rate = kwds.get("recurrence_rate")
 
+        assert len(metric) == 2
+        assert all(m in ("manhattan", "euclidean", "supremum") for m in metric)
+
+        # initialise base class using dummy values (bad OO design)
         RecurrencePlot.__init__(
             self, np.empty((2, 0)), metric=metric[0], normalize=normalize,
             threshold=threshold[0] if threshold else 0,
             recurrence_rate=recurrence_rate, silence_level=silence_level)
 
-        self._distance_matrix_cached = False
+        #  Store type of metric
+        self.metric = metric
+
         self.JR = None
         """The joint recurrence matrix."""
         self.N = 0
         """The length of both embedded time series x and y."""
 
         #  Check for consistency: x and y need to have the same length
         if x.shape[0] == y.shape[0]:
@@ -217,18 +211,18 @@
             raise ValueError("Both time series x and y need to have the same \
                              length!")
 
     def __str__(self):
         """
         Returns a string representation.
         """
-        return ('JointRecurrencePlot: time series shapes %s.\n'
-                'Embedding dimension %i\nThreshold %s, %s metric') % (
-                    self.x.shape, self.dim if self.dim else 0,
-                    self.threshold, self.metric)
+        return ("JointRecurrencePlot: "
+                f"time series shapes {self.x.shape}.\n"
+                f"Embedding dimension {self.dim if self.dim else 0}\n"
+                f"Threshold {self.threshold}, {self.metric} metric")
 
     #
     #  Service methods
     #
 
     def recurrence_matrix(self):
         """
@@ -253,55 +247,37 @@
         :type threshold: tuple of number
         :arg threshold: The recurrence threshold. Give for both time series
             separately.
         """
         if self.silence_level <= 1:
             print("Calculating joint recurrence plot at fixed threshold...")
 
-        #  Disable caching of distances in RecurrencePlot class
-        self._distance_matrix_cached = False
-        #  Get distance matrix for the first time series
-        distance = self.distance_matrix(self.x_embedded, self.metric[0])
-
-        #  Get length of time series
+        self.embedding = self.x_embedded
+        distance = self.distance_matrix(self.metric[0])
         N = distance.shape[0]
-
-        #  Initialize first recurrence matrix
         recurrence_x = np.zeros((N, N), dtype="int8")
-
-        #  Thresholding the first distance matrix
         recurrence_x[distance < threshold[0]] = 1
-
-        #  Clean up
         del distance
 
-        #  Disable caching of distances in RecurrencePlot class
-        self._distance_matrix_cached = False
-        #  Get distance matrix for the second time series
-        distance = self.distance_matrix(self.y_embedded, self.metric[1])
-
-        #  Initialize second recurrence matrix
+        self.embedding = self.y_embedded
+        distance = self.distance_matrix(self.metric[1])
         recurrence_y = np.zeros((N, N), dtype="int8")
-
-        #  Thresholding the second distance matrix
         recurrence_y[distance < threshold[1]] = 1
+        del distance
 
         if self.lag >= 0:
             self.JR = recurrence_x[:N-self.lag, :N-self.lag] * \
                 recurrence_y[self.lag:N, self.lag:N]
         else:
             # self.JR = recurrence_x[-self.lag:N, -self.lag:N] * \
             #     recurrence_y[:N+self.lag, :N+self.lag]
             self.JR = recurrence_y[:N+self.lag, :N+self.lag] * \
                 recurrence_x[-self.lag:N, -self.lag:N]
         self.N = N
 
-        #  Clean up
-        del distance, recurrence_x, recurrence_y
-
     def set_fixed_threshold_std(self, threshold_std):
         """
         Set the joint recurrence plot to fixed thresholds in units of the
         standard deviation of the time series.
 
         Calculates the absolute thresholds and calls
         :meth:`set_fixed_threshold`.
@@ -310,19 +286,16 @@
         :arg threshold_std: The recurrence threshold in units of the standard
             deviation of the time series. Give for both time series separately.
         """
         if self.silence_level <= 1:
             print("Calculating recurrence plot at fixed threshold "
                   "in units of time series STD...")
 
-        #  Get absolute threshold
         threshold_x = threshold_std[0] * self.x.std()
         threshold_y = threshold_std[1] * self.y.std()
-
-        #  Call set fixed threshold method
         JointRecurrencePlot.\
             set_fixed_threshold(self, (threshold_x, threshold_y))
 
     def set_fixed_recurrence_rate(self, recurrence_rate):
         """
         Set the joint recurrence plot to fixed recurrence rates.
 
@@ -333,55 +306,33 @@
         :arg recurrence_rate: The recurrence rate. Give for both time series
             separately.
         """
         if self.silence_level <= 1:
             print("Calculating joint recurrence plot at "
                   "fixed recurrence rate...")
 
-        #  Disable caching of distances in RecurrencePlot class
-        self._distance_matrix_cached = False
-        #  Get distance matrix for the first time series
-        distance = self.distance_matrix(self.x_embedded, self.metric[0])
-
-        #  Get length of time series
+        self.embedding = self.x_embedded
+        distance = self.distance_matrix(self.metric[0])
         N = distance.shape[0]
-
-        #  Get first threshold to obtain fixed recurrence rate
         threshold_x = self.\
             threshold_from_recurrence_rate(distance, recurrence_rate[0])
-
-        #  Initialize recurrence matrix
         recurrence_x = np.zeros((N, N), dtype="int8")
-
-        #  Thresholding the distance matrix
         recurrence_x[distance < threshold_x] = 1
-
-        #  Clean up
         del distance
 
-        #  Disable caching of distances in RecurrencePlot class
-        self._distance_matrix_cached = False
-        #  Get distance matrix for the second time series
-        distance = self.distance_matrix(self.y_embedded, self.metric[1])
-
-        #  Get first threshold to obtain fixed recurrence rate
+        self.embedding = self.y_embedded
+        distance = self.distance_matrix(self.metric[1])
         threshold_y = self.\
             threshold_from_recurrence_rate(distance, recurrence_rate[1])
-
-        #  Initialize recurrence matrix
         recurrence_y = np.zeros((N, N), dtype="int8")
-
-        #  Thresholding the distance matrix
         recurrence_y[distance < threshold_y] = 1
+        del distance
 
         if self.lag >= 0:
             self.JR = recurrence_x[:N-self.lag, :N-self.lag] * \
                 recurrence_y[self.lag:N, self.lag:N]
         else:
             # self.JR = recurrence_x[-self.lag:N, -self.lag:N] * \
             #     recurrence_y[:N+self.lag, :N+self.lag]
             self.JR = recurrence_y[:N+self.lag, :N+self.lag] * \
                 recurrence_x[-self.lag:N, -self.lag:N]
         self.N = N
-
-        #  Clean up
-        del distance, recurrence_x, recurrence_y
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/_ext/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/_ext/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/_ext/src_numerics.c` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/_ext/src_numerics.c`

 * *Files 14% similar despite different names*

```diff
@@ -1,105 +1,47 @@
 /*
 * !/usr/bin/python
 * -*- coding: utf-8 -*-
 *
 * This file is part of pyunicorn.
-* Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
+* Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
 * URL: <http://www.pik-potsdam.de/members/donges/software>
 * License: BSD (3-clause)
 */
 
-// cross_recurrence_plot ======================================================
-
-void _manhattan_distance_matrix_fast(int ntime_x, int ntime_y, int dim, 
-    double *x_embedded, double *y_embedded, double *distance)  {
-
-    //  Calculate the manhattan distance matrix
-    for (int j = 0; j < ntime_x; j++) {
-        for (int k = 0; k < ntime_y; k++) {
-            double sum = 0;
-            for (int l = 0; l < dim; l++) {
-                //  Use manhattan norm
-                sum += fabs(x_embedded[j*ntime_x+l] - y_embedded[k*ntime_y+l]);
-            }
-            distance[j*ntime_x+k] = sum;
-        }
-    }
-}
-
-
-void _euclidean_distance_matrix_fast(int ntime_x, int ntime_y, int dim, 
-    double *x_embedded, double *y_embedded, double *distance)  {
-
-    //  Calculate the euclidean distance matrix
-    for (int j = 0; j < ntime_x; j++) {
-        for (int k = 0; k < ntime_y; k++) {
-            double sum = 0;
-            for (int l = 0; l < dim; l++) {
-                //  Use euclidean norm
-                double diff = fabs(x_embedded[j*ntime_x+l] - 
-                    y_embedded[k*ntime_y+l]);
-                sum += diff * diff;
-            }
-            distance[j*ntime_x+k] = sqrt(sum);
-        }
-    }
-}
-
-
-void _supremum_distance_matrix_fast(int ntime_x, int ntime_y, int dim, 
-    float *x_embedded, float *y_embedded, float *distance)  {
-
-    float temp_diff, diff;
-
-    //  Calculate the supremum distance matrix
-
-    for (int j = 0; j < ntime_x; j++) {
-        for (int k = 0; k < ntime_y; k++) {
-            temp_diff = diff = 0;
-            for (int l = 0; l < dim; l++) {
-                //  Use supremum norm
-                temp_diff = fabs(x_embedded[j*ntime_x+l] - 
-                    y_embedded[k*ntime_y+l]);
-                if (temp_diff > diff)
-                    diff = temp_diff;
-            }
-            distance[j*ntime_x+k] = diff;
-        }
-    }
-}
-
+#include <math.h>
 
 // surrogates =================================================================
 
 void _test_pearson_correlation_fast(double *original_data, double *surrogates, 
     float *correlation, int n_time, int N, double norm)  {
 
     float *p_correlation;
-    double *p_original, *p_surrogates;
+    double *p_original, *p_surrogates, corr;
 
     for (int i = 0; i < N; i++) {
         //  Set pointer to correlation(i,0)
         p_correlation = correlation + i*N;
 
         for (int j = 0; j < N; j++) {
             if (i != j) {
                 //  Set pointer to original_data(i,0)
                 p_original = original_data + i*n_time;
                 //  Set pointer to surrogates(j,0)
                 p_surrogates = surrogates + j*n_time;
 
+                corr = 0;
                 for (int k = 0; k < n_time; k++) {
-                    *p_correlation += (*p_original) * (*p_surrogates);
+                    corr += (*p_original) * (*p_surrogates);
                     //  Set pointer to original_data(i,k+1)
                     p_original++;
                     //  Set pointer to surrogates(j,k+1)
                     p_surrogates++;
                 }
-                *p_correlation *= norm;
+                *p_correlation = (float) (corr * norm);
             }
             p_correlation++;
         }
     }
 }
 
 
@@ -137,15 +79,15 @@
 
             //  Rescale sample into interval [0,1]
             rescaled = scaling * (*p_original - range_min);
 
             //  Calculate symbolic trajectories for each time series,
             //  where the symbols are bin numbers.
             if (rescaled < 1.0)
-                *p_symbolic_original = rescaled * n_bins;
+                *p_symbolic_original = (int) (rescaled * n_bins);
             else
                 *p_symbolic_original = n_bins - 1;
 
             //  Calculate 1d-histograms for single time series
             //  Set pointer to hist_original(i, *p_symbolic_original)
             p_hist_original = hist_original + in_bins
                               + *p_symbolic_original;
@@ -153,15 +95,15 @@
 
             //  Rescale sample into interval [0,1]
             rescaled = scaling * (*p_surrogates - range_min);
 
             //  Calculate symbolic trajectories for each time series,
             //  where the symbols are bin numbers.
             if (rescaled < 1.0)
-                *p_symbolic_surrogates = rescaled * n_bins;
+                *p_symbolic_surrogates = (int) (rescaled * n_bins);
             else
                 *p_symbolic_surrogates = n_bins - 1;
 
             //  Calculate 1d-histograms for single time series
             //  Set pointer to hist_surrogates(i, *p_symbolic_surrogates)
             p_hist_surrogates = hist_surrogates + in_bins
                                 + *p_symbolic_surrogates;
@@ -238,15 +180,15 @@
                         for (m = 0; m < n_bins; m++) {
 
                             hpm = (*p_hist_surrogates) * norm;
 
                             if (hpm > 0.0) {
                                 plm = (*p_hist2d) * norm;
                                 if (plm > 0.0)
-                                    *p_mi += plm * log(plm/hpm/hpl);
+                                    *p_mi += (float) (plm * log(plm/hpm/hpl));
                             }
 
                             //  Set pointer to hist_surrogates(j,m+1)
                             p_hist_surrogates++;
                             //  Set pointer to hist2d(l,m+1)
                             p_hist2d++;
                         }
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/_ext/numerics.pyx` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/_ext/numerics.pyx`

 * *Files 22% similar despite different names*

```diff
@@ -1,201 +1,179 @@
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
-cimport cython
-from cpython cimport bool
 from libc.math cimport sqrt, floor
-from libc.stdlib cimport rand, RAND_MAX
 
+from datetime import datetime
+import random
 
 import numpy as np
-cimport numpy as np
 import numpy.random as rd
-import random
-from datetime import datetime
-
-randint = rd.randint
-
-
-
-BOOLTYPE = np.uint8
-INTTYPE = np.int
-INT8TYPE = np.int8
-INT16TYPE = np.int16
-INT32TYPE = np.int32
-FLOATTYPE = np.float
-FLOAT32TYPE = np.float32
-FLOAT64TYPE = np.float64
-ctypedef np.uint8_t BOOLTYPE_t
-ctypedef np.int_t INTTYPE_t
-ctypedef np.int8_t INT8TYPE_t
-ctypedef np.int16_t INT16TYPE_t
-ctypedef np.int32_t INT32TYPE_t
-ctypedef np.float_t FLOATTYPE_t
-ctypedef np.float32_t FLOAT32TYPE_t
-ctypedef np.float64_t FLOAT64TYPE_t
-
-cdef extern from "stdlib.h":
-    double drand48()
-    double srand48()
-
-cdef extern from "time.h":
-    double time()
+cimport numpy as cnp
+from numpy cimport ndarray
 
+from ...core._ext.types import MASK, NODE, LAG, FIELD, DFIELD
+from ...core._ext.types cimport \
+    ADJ_t, MASK_t, NODE_t, DEGREE_t, LAG_t, FIELD_t, DFIELD_t
 
 cdef extern from "src_numerics.c":
-    void _manhattan_distance_matrix_fast(int ntime_x, int ntime_y, int dim,
-        double *x_embedded, double *y_embedded, double *distance)
-    void _euclidean_distance_matrix_fast(int ntime_x, int ntime_y, int dim,
-        double *x_embedded, double *y_embedded, double *distance)
-    void _supremum_distance_matrix_fast(int ntime_x, int ntime_y, int dim,
-        float *x_embedded, float *y_embedded, float *distance)
     void _test_pearson_correlation_fast(double *original_data,
         double *surrogates, float *correlation, int n_time, int N, double norm)
     void _test_mutual_information_fast(int N, int n_time, int n_bins,
         double scaling, double range_min, double *original_data,
         double *surrogates, int *symbolic_original, int *symbolic_surrogates,
         int *hist_original, int *hist_surrogates, int * hist2d, float *mi)
 
 
 # cross_recurrence_plot =======================================================
 
+
 def _manhattan_distance_matrix_crp(
     int ntime_x, int ntime_y, int dim,
-    np.ndarray[double, ndim=2, mode='c'] x_embedded not None,
-    np.ndarray[double, ndim=2, mode='c'] y_embedded not None):
-
-    cdef np.ndarray[double, ndim=2, mode='c'] distance = \
-        np.zeros((ntime_x, ntime_y), dtype="double")
+    ndarray[DFIELD_t, ndim=2, mode='c'] x_embedded not None,
+    ndarray[DFIELD_t, ndim=2, mode='c'] y_embedded not None):
 
-    _manhattan_distance_matrix_fast(
-        ntime_x, ntime_y, dim,
-        <double*> np.PyArray_DATA(x_embedded),
-        <double*> np.PyArray_DATA(y_embedded),
-        <double*> np.PyArray_DATA(distance))
+    cdef:
+        int j, k, l
+        DFIELD_t sum
+        ndarray[DFIELD_t, ndim=2, mode='c'] distance = \
+            np.zeros((ntime_x, ntime_y), dtype=DFIELD)
 
+    for j in range(ntime_x):
+        for k in range(ntime_y):
+            sum = 0
+            for l in range(dim):
+                diff = abs(x_embedded[j,l] - y_embedded[k,l])
+                sum += diff
+            distance[j, k] = sum
     return distance
 
 
 def _euclidean_distance_matrix_crp(
     int ntime_x, int ntime_y, int dim,
-    np.ndarray[double, ndim=2, mode='c'] x_embedded not None,
-    np.ndarray[double, ndim=2, mode='c'] y_embedded not None):
-
-    cdef np.ndarray[double, ndim=2, mode='c'] distance = \
-        np.zeros((ntime_x, ntime_y), dtype="double")
+    ndarray[DFIELD_t, ndim=2, mode='c'] x_embedded not None,
+    ndarray[DFIELD_t, ndim=2, mode='c'] y_embedded not None):
 
-    _euclidean_distance_matrix_fast(
-        ntime_x, ntime_y, dim,
-        <double*> np.PyArray_DATA(x_embedded),
-        <double*> np.PyArray_DATA(y_embedded),
-        <double*> np.PyArray_DATA(distance))
+    cdef:
+        int j, k, l
+        DFIELD_t sum, diff
+        ndarray[DFIELD_t, ndim=2, mode='c'] distance = \
+            np.zeros((ntime_x, ntime_y), dtype=DFIELD)
 
+    for j in range(ntime_x):
+        for k in range(ntime_y):
+            sum = 0
+            for l in range(dim):
+                diff = abs(x_embedded[j,l] - y_embedded[k,l])
+                sum += diff * diff
+            distance[j, k] = sqrt(sum)
     return distance
 
 
 def _supremum_distance_matrix_crp(
     int ntime_x, int ntime_y, int dim,
-    np.ndarray[float, ndim=2, mode='c'] x_embedded not None,
-    np.ndarray[float, ndim=2, mode='c'] y_embedded not None):
-
-    cdef np.ndarray[float, ndim=2, mode='c'] distance = \
-        np.zeros((ntime_x, ntime_y), dtype="float32")
-
-    _supremum_distance_matrix_fast(
-        ntime_x, ntime_y, dim,
-        <float*> np.PyArray_DATA(x_embedded),
-        <float*> np.PyArray_DATA(y_embedded),
-        <float*> np.PyArray_DATA(distance))
+    ndarray[DFIELD_t, ndim=2, mode='c'] x_embedded not None,
+    ndarray[DFIELD_t, ndim=2, mode='c'] y_embedded not None):
 
+    cdef:
+        int j, k, l
+        DFIELD_t temp_diff, diff
+        ndarray[DFIELD_t, ndim=2, mode='c'] distance = \
+            np.zeros((ntime_x, ntime_y), dtype=DFIELD)
+
+    for j in range(ntime_x):
+        for k in range(ntime_y):
+            diff = 0
+            for l in range(dim):
+                temp_diff = abs(x_embedded[j,l] - y_embedded[k,l])
+                if temp_diff > diff:
+                    diff = temp_diff
+            distance[j, k] = diff
     return distance
 
 
 # surrogates ==================================================================
 
+
 def _embed_time_series_array(
-    int N, int n_time, int dimension, int delay,
-    np.ndarray[FLOATTYPE_t, ndim=2] time_series_array,
-    np.ndarray[FLOAT64TYPE_t, ndim=3] embedding):
-    """
-    >>> 42 == 42
-    True
-    """
+    int n, int n_time, int dimension, int delay,
+    ndarray[DFIELD_t, ndim=2] time_series_array,
+    ndarray[DFIELD_t, ndim=3] embedding):
 
-    cdef int i, j, k, max_delay, len_embedded, index
+    cdef:
+        int i, j, k, max_delay, len_embedded, index
+        int N = n, D = dimension
 
     # Calculate the maximum delay
     max_delay = (dimension - 1) * delay
     # Calculate the length of the embedded time series
     len_embedded = n_time - max_delay
 
     for i in range(N):
-        for j in range(dimension):
+        for j in range(D):
             index = j*delay
             for k in range(len_embedded):
                 embedding[i, k, j] = time_series_array[i, index]
                 index += 1
 
 
 def _recurrence_plot(
     int n_time, int dimension, float threshold,
-    np.ndarray[FLOATTYPE_t, ndim=2] embedding,
-    np.ndarray[INT8TYPE_t, ndim=2] R):
+    ndarray[DFIELD_t, ndim=2] embedding,
+    ndarray[ADJ_t, ndim=2] R):
 
     cdef:
-        int j, k, l
-        double diff
+        int j, k, l, T = n_time, D = dimension
+        DFIELD_t diff
 
-    for j in range(n_time):
+    for j in range(T):
         # Ignore the main diagonal, since every sample is neighbor of itself
         for k in range(j):
-            for l in range(dimension):
+            for l in range(D):
                 # Use supremum norm
                 diff = embedding[j, l] - embedding[k, l]
 
                 if abs(diff) > threshold:
                     # j and k are not neighbors
                     R[j, k] = R[k, j] = 0
 
                     # Leave the loop
                     break
 
 
 def _twins_s(
     int N, int n_time, int dimension, float threshold, int min_dist,
-    np.ndarray[FLOATTYPE_t, ndim=3] embedding_array,
-    np.ndarray[FLOATTYPE_t, ndim=2] R, np.ndarray[FLOATTYPE_t, ndim=1] nR,
+    ndarray[DFIELD_t, ndim=3] embedding_array,
+    ndarray[ADJ_t, ndim=2] R, ndarray[DEGREE_t, ndim=1] nR,
     twins):
+
     cdef:
         int i, j, k, l
-        double diff
+        DFIELD_t diff
+        object twins_i, twins_ij, twins_ik
 
     for i in range(N):
         # Initialize the recurrence matrix R and nR
-
         for j in range(n_time):
             for k in range(j+1):
                 R[j, k] = R[k, j] = 1
-            nR[j] = n_time
+            nR[j] = <DEGREE_t> n_time
 
         # Calculate the recurrence matrix for time series i
-
         for j in range(n_time):
             # Ignore main diagonal, since every sample is neighbor of itself
             for k in range(j):
                 for l in range(dimension):
                     # Use maximum norm
                     diff = embedding_array[i, j, l] - embedding_array[i, k, l]
 
@@ -210,24 +188,23 @@
                         # Leave the for loop
                         break
 
         # Add list for twins in time series i
         twins.append([])
 
         # Find all twins in the recurrence matrix
-
         for j in range(n_time):
             twins_i = twins[i]
             twins_i.append([])
             twins_ij = twins_i[j]
 
             # Respect a minimal temporal spacing between twins to avoid false
             # twins due to the higher
             # sample density in phase space along the trajectory
-            for k in range(j-min_dist):
+            for k in range(j - min_dist):
                 # Continue only if both samples have the same number of
                 # neighbors and more than just one neighbor (themselves)
                 if nR[j] == nR[k] and nR[j] != 1:
                     l = 0
 
                     while R[j, l] == R[k, l]:
                         l += 1
@@ -241,107 +218,222 @@
                             twins_ij.append(k)
                             twins_ik.append(j)
 
                             # Leave the while loop
                             break
 
 
-# recurrence plot==============================================================
+def _twin_surrogates_s(int n_surrogates, int N, twins,
+                       ndarray[DFIELD_t, ndim=2] original_data):
+    cdef:
+        int i, j, k, new_k, n_twins, rand
+        object twins_i, twins_ik
+        ndarray[DFIELD_t, ndim=2] surrogates = np.empty(
+            (n_surrogates, N), dtype=DFIELD)
+
+    for i in range(n_surrogates):
+        # Get the twin list for time series i
+        twins_i = twins[i]
+        # Randomly choose a starting point in the original trajectory
+        k = int(floor(random.random() * N))
+
+        j = 0
+        while j < N:
+            # Assign state vector of surrogate trajectory
+            surrogates[i,j] = original_data[i,k]
+            # Get the list of twins of state vector k in the original time
+            # series
+            twins_ik = twins_i[k]
+
+            # Get the number of twins of k
+            n_twins = int(len(twins_ik))
+            # If k has no twins, go to the next sample k+1, If k has twins at
+            # m, choose among m+1 and k+1 with equal probability
+            if n_twins == 0:
+                k += 1
+            else:
+                # Generate a random integer between 0 and n_twins
+                rand = int(floor(random.random() * (n_twins + 1)))
+
+                # If rand = n_twings go to smple k+1, otherwise jump to the
+                # future of one of the twins
+                if rand == n_twins:
+                    k += 1
+                else:
+                    k = twins_ik[rand]
+                    k += 1
+
+            # If the new k >= n_time, choose a new random starting point in the
+            # original time series
+            if k >= N:
+                while True:
+                    new_k = int(floor(random.random() * N))
+                    if new_k != k:
+                        break
+                k = new_k
+
+            j += 1
+
+    return surrogates
+
+
+def _test_pearson_correlation(
+    ndarray[DFIELD_t, ndim=2, mode='c'] original_data not None,
+    ndarray[DFIELD_t, ndim=2, mode='c'] surrogates not None,
+    int N, int n_time):
+
+    cdef:
+        DFIELD_t norm = 1.0 / float(n_time)
+        #  Initialize Pearson correlation matrix
+        ndarray[FIELD_t, ndim=2, mode='c'] correlation = np.zeros(
+            (N, N), dtype=FIELD)
+
+    _test_pearson_correlation_fast(
+        <DFIELD_t*> cnp.PyArray_DATA(original_data),
+        <DFIELD_t*> cnp.PyArray_DATA(surrogates),
+        <FIELD_t*> cnp.PyArray_DATA(correlation),
+        n_time, N, norm)
+
+    return correlation
+
+
+def _test_mutual_information(
+    ndarray[DFIELD_t, ndim=2, mode='c'] original_data not None,
+    ndarray[DFIELD_t, ndim=2, mode='c'] surrogates not None,
+    int N, int n_time, int n_bins):
+
+    cdef:
+        #  Get common range for all histograms
+        DFIELD_t range_min = np.min((original_data.min(), surrogates.min()))
+        DFIELD_t range_max = np.max((original_data.max(), surrogates.max()))
+        #  Rescale all time series to the interval [0,1], using the maximum
+        #  range of the whole dataset
+        DFIELD_t scaling = 1. / (range_max - range_min)
+        #  Create arrays to hold symbolic trajectories
+        ndarray[NODE_t, ndim=2, mode='c'] symbolic_original = \
+            np.empty((N, n_time), dtype=NODE)
+        ndarray[NODE_t, ndim=2, mode='c'] symbolic_surrogates = \
+            np.empty((N, n_time), dtype=NODE)
+        #  Initialize array to hold 1d-histograms of individual time series
+        ndarray[NODE_t, ndim=2, mode='c'] hist_original = \
+            np.zeros((N, n_bins), dtype=NODE)
+        ndarray[NODE_t, ndim=2, mode='c'] hist_surrogates = \
+            np.zeros((N, n_bins), dtype=NODE)
+        #  Initialize array to hold 2d-histogram for one pair of time series
+        ndarray[NODE_t, ndim=2, mode='c'] hist2d = \
+            np.zeros((n_bins, n_bins), dtype=NODE)
+        #  Initialize mutual information array
+        ndarray[FIELD_t, ndim=2, mode='c'] mi = np.zeros((N, N), dtype=FIELD)
+
+    _test_mutual_information_fast(
+            N, n_time, n_bins, scaling, range_min,
+            <DFIELD_t*> cnp.PyArray_DATA(original_data),
+            <DFIELD_t*> cnp.PyArray_DATA(surrogates),
+            <int*> cnp.PyArray_DATA(symbolic_original),
+            <int*> cnp.PyArray_DATA(symbolic_surrogates),
+            <int*> cnp.PyArray_DATA(hist_original),
+            <int*> cnp.PyArray_DATA(hist_surrogates),
+            <int*> cnp.PyArray_DATA(hist2d),
+            <FIELD_t*> cnp.PyArray_DATA(mi))
+
+    return mi
+
+
+# recurrence plot =============================================================
+
 
 def _embed_time_series(
     int n_time, int dim, int tau,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] time_series,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] embedding):
-    """
-    >>> 42 == 42
-    True
-    """
+    ndarray[FIELD_t, ndim=1] time_series,
+    ndarray[FIELD_t, ndim=2] embedding):
 
     cdef:
-        int i,j, max_delay, len_embedded, index
+        int j, max_delay, index, D = dim
+        int k, len_embedded
 
     # Calculate the maximum delay
     max_delay = (dim - 1) * tau
     # Calculate the length of the embedded time series
     len_embedded = n_time - max_delay
 
-    for j in range(dim):
+    for j in range(D):
         index = j * tau
         for k in range(len_embedded):
             embedding[k, j] = time_series[index]
             index += 1
 
+
 def _manhattan_distance_matrix_rp(
-    int n_time, int dim, np.ndarray[FLOAT32TYPE_t, ndim=2] embedding,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] distance):
+    int n_time, int dim, ndarray[DFIELD_t, ndim=2] embedding):
 
     cdef:
-        int j, k, l
-        float sum
+        int j, k, l, T = n_time, D = dim
+        DFIELD_t sum
+        ndarray[DFIELD_t, ndim=2, mode='c'] distance = \
+            np.zeros((n_time, n_time), dtype=DFIELD)
 
-    # Calculate the manhattan distance matrix
-    for j in range(n_time):
+    for j in range(T):
         # Ignore the main diagonal, since every samle is neighbor of itself
         for k in range(j):
             sum = 0
-            for l in range(dim):
+            for l in range(D):
                 # use manhattan norm
                 sum += abs(embedding[j, l] - embedding[k, l])
-
             distance[j, k] = distance[k, j] = sum
+    return distance
 
 
 def _euclidean_distance_matrix_rp(
-    int n_time, int dim, np.ndarray[FLOAT32TYPE_t, ndim=2] embedding,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] distance):
+    int n_time, int dim, ndarray[DFIELD_t, ndim=2] embedding):
 
     cdef:
-        int j, k, l
-        float sum, diff
+        int j, k, l, T = n_time, D = dim
+        DFIELD_t sum, diff
+        ndarray[DFIELD_t, ndim=2, mode='c'] distance = \
+            np.zeros((n_time, n_time), dtype=DFIELD)
 
-    # Calculate the eucliadean distance matrix
-    for j in range(n_time):
+    for j in range(T):
         # Ignore the main diagonal, since every sample is neighbor of itself
         for k in range(j):
             sum = 0
-            for l in range(dim):
+            for l in range(D):
                 # Use euclidean norm
                 diff = abs(embedding[j, l] - embedding[k, l])
                 sum += diff * diff
-            distance[j, k] = distance[k, j] = sum
+            distance[j, k] = distance[k, j] = sqrt(sum)
+    return distance
 
 
 def _supremum_distance_matrix_rp(
-    int n_time, int dim, np.ndarray[FLOAT32TYPE_t, ndim=2] embedding,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] distance):
+    int n_time, int dim, ndarray[DFIELD_t, ndim=2] embedding):
 
     cdef:
-        int j, k, l
-        float temp_diff, diff
-
+        int j, k, l, T = n_time, D = dim
+        DFIELD_t temp_diff, diff
+        ndarray[DFIELD_t, ndim=2, mode='c'] distance = \
+            np.zeros((n_time, n_time), dtype=DFIELD)
 
-    # Calculate the eucliadean distance matrix
-    for j in range(n_time):
+    for j in range(T):
         # Ignore the main diagonal, since every sample is neighbor of itself
         for k in range(j):
-            temp_diff = diff = 0
-            for l in range(dim):
+            diff = 0
+            for l in range(D):
                 # Use supremum norm
                 temp_diff = abs(embedding[j, l] - embedding[k, l])
                 if temp_diff > diff:
                     diff = temp_diff
-
             distance[j, k] = distance[k, j] = diff
+    return distance
 
 
 def _set_adaptive_neighborhood_size(
     int n_time, int adaptive_neighborhood_size,
-    np.ndarray[INT32TYPE_t, ndim=2] sorted_neighbors,
-    np.ndarray[INTTYPE_t, ndim=1] order,
-    np.ndarray[INT8TYPE_t, ndim=2] recurrence):
+    ndarray[NODE_t, ndim=2] sorted_neighbors,
+    ndarray[NODE_t, ndim=1] order,
+    ndarray[LAG_t, ndim=2] recurrence):
 
     cdef:
         int i, j, k, l
 
     for i in range(adaptive_neighborhood_size):
         for j in range(n_time):
             # Get the node index to be processed
@@ -353,370 +445,97 @@
             while recurrence[l, sorted_neighbors[l, k]] == 1 and k < n_time:
                 k += 1
             # add a "new" nearest neighbor of l to the recurrence plot
             recurrence[l, sorted_neighbors[l, k]] = \
                 recurrence[sorted_neighbors[l, k], l] = 1
 
 
-def _bootstrap_distance_matrix_manhatten(
-    int n_time, int dim, np.ndarray[FLOAT32TYPE_t, ndim=2] embedding,
-    np.ndarray[FLOAT32TYPE_t, ndim=1] distances, int M):
+def _bootstrap_distance_matrix_manhattan(
+    int n_time, int dim, ndarray[DFIELD_t, ndim=2] embedding,
+    ndarray[DFIELD_t, ndim=1] distances, int M):
 
     cdef:
         int i, l
-        np.ndarray[INTTYPE_t, ndim=2] jk = rd.randint(n_time, size=(2,M))
-        float sum, diff
+        ndarray[NODE_t, ndim=2] jk = rd.randint(n_time, size=(2,M))
+        double sum
 
     for i in range(M):
         #Compute their distance
         sum = 0
         for l in range(dim):
-            # Use manhatten norm
+            # Use Manhattan norm
             sum += abs(embedding[jk[0, i], l] - embedding[jk[1, i], l])
 
         distances[i] = sum
 
 
 def _bootstrap_distance_matrix_euclidean(
-    int n_time, int dim, np.ndarray[FLOAT32TYPE_t, ndim=2] embedding,
-    np.ndarray[FLOAT32TYPE_t, ndim=1] distances, int M):
+    int n_time, int dim, ndarray[DFIELD_t, ndim=2] embedding,
+    ndarray[DFIELD_t, ndim=1] distances, int M):
 
     cdef:
         int i, l
-        np.ndarray[INTTYPE_t, ndim=2] jk = rd.randint(n_time, size=(2,M))
-        float sum, diff
+        ndarray[NODE_t, ndim=2] jk = rd.randint(n_time, size=(2,M))
+        double sum, diff
 
     for i in range(M):
         #Compute their distance
         sum = 0
         for l in range(dim):
-            # Use manhatten norm
+            # Use Manhattan norm
             diff = abs(embedding[jk[0, i], l] - embedding[jk[1, i], l])
             sum += diff * diff
 
         distances[i] = sqrt(sum)
 
 
 def _bootstrap_distance_matrix_supremum(
-    int n_time, int dim, np.ndarray[FLOAT32TYPE_t, ndim=2] embedding,
-    np.ndarray[FLOAT32TYPE_t, ndim=1] distances, int M):
+    int n_time, int dim, ndarray[DFIELD_t, ndim=2] embedding,
+    ndarray[DFIELD_t, ndim=1] distances, int M):
 
     cdef:
         int i, l
-        np.ndarray[INTTYPE_t, ndim=2] jk = rd.randint(n_time, size=(2,M))
-        float temp_diff, diff
+        ndarray[NODE_t, ndim=2] jk = rd.randint(n_time, size=(2,M))
+        double temp_diff, diff
 
     for i in range(M):
         #Compute their distance
-        temp_diff = diff = 0
+        diff = 0
         for l in range(dim):
             # Use supremum norm
             temp_diff = abs(embedding[jk[0, i], l] - embedding[jk[1, i], l])
 
             if temp_diff > diff:
                 diff = temp_diff
 
             distances[i] = diff
 
 
-def _diagline_dist_norqa_missingvalues(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] diagline,
-    np.ndarray[INT8TYPE_t, ndim=2] recmat,
-    np.ndarray[BOOLTYPE_t, ndim=1, cast=True] mv_indices):
-
-    cdef:
-        int i, j, k = 0
-        BOOLTYPE_t missing_flag = False
-
-    for i in range(n_time):
-        if k != 0 and not missing_flag:
-            diagline[k] += 1
-            k = 0
-
-        missing_flag = False
-
-        for j in range(i+1):
-            # Check if curren tpoint in RP belongs to a mising value
-            if mv_indices[n_time-1-i+j] or mv_indices[j]:
-                missing_flag = True
-                k = 0
-            elif recmat[n_time-1-i+j, j] == 0 and missing_flag:
-                missing_flag = False
-
-            if not missing_flag:
-                # Only incease k if some previous point in diagonal was not a
-                # missing value!
-                if recmat[n_time-1-i+j, j] == 1:
-                    k += 1
-                # Only count diagonal lines that are not followed by a missing
-                # point in the recurrence plot
-                elif k != 0:
-                    diagline[k] += 1
-                    k = 0
-
-
-def _diagline_dist_norqa(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] diagline,
-    np.ndarray[INT8TYPE_t, ndim=2] recmat):
-
-    cdef:
-        int i, j, k = 0
-
-    for i in range(n_time):
-        if k != 0:
-            diagline[k] += 1
-            k = 0
-        for j in range(i+1):
-            if recmat[n_time-1-i+j, j] == 1:
-                k += 1
-            elif k != 0:
-                diagline[k] += 1
-                k = 0
-
-
-def _diagline_dist_rqa_missingvalues(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] diagline,
-    np.ndarray[BOOLTYPE_t, ndim=1, cast=True] mv_indices,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] embedding, float eps, int dim):
-
-    cdef:
-        int i, j, k = 0, l
-        float temp_diff, diff
-        BOOLTYPE_t missing_flag = False
-
-    for i in range(n_time):
-        if k != 0 and not missing_flag:
-            diagline[k] += 1
-            k = 0
-
-        missing_flag = False
-
-        for j in range(i+1):
-            # Compute supreumum distance between state vectors
-            temp_diff = diff = 0
-            for l in range(dim):
-                # Use supremum norm
-                temp_diff = abs(embedding[j, l] - embedding[n_time-1-i+j, l])
-                if temp_diff > diff:
-                    diff = temp_diff
-
-            # Check if curren tpoint in RP belongs to a missing value
-            if mv_indices[n_time-1-i+j] or mv_indices[j]:
-                missing_flag = True
-                k = 0
-            elif diff > eps and missing_flag:
-                missing_flag = False
-
-            if not missing_flag:
-                # Only increase k if some previous point in diagonal was not a
-                # missig value!
-                if diff < eps:
-                    k += 1
-
-                # Only count diagonal lines that are not followed by a missing
-                # value point in the recurrenc plot
-                elif k != 0:
-                    diagline[k] += 1
-                    k = 0
-
-
-def _diagline_dist_rqa(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] diagline,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] embedding, float eps, int dim):
-
-    cdef:
-        int i, j, k = 0, l
-        float temp_diff, diff
-
-    for i in range(n_time):
-        if k != 0:
-            diagline[k] += 1
-            k = 0
-
-        for j in range(i+1):
-            # Compute supremum distance between state vectors
-            temp_diff = diff = 0
-            for l in range(dim):
-                # Use supremum norm
-                temp_diff = abs(embedding[j, l] - embedding[n_time-1-i+j, l])
-                if temp_diff > diff:
-                    diff = temp_diff
-
-            # check if R(j, n_time-q-i+j) == 1 -> recurrence
-            if diff < eps:
-                k += 1
-            elif k != 0:
-                diagline[k] += 1
-                k = 0
-
-
 def _rejection_sampling(
-    np.ndarray[FLOATTYPE_t, ndim=1] dist,
-    np.ndarray[FLOATTYPE_t, ndim=1] resampled_dist, int N, int M):
+    ndarray[DFIELD_t, ndim=1] dist,
+    ndarray[NODE_t, ndim=1] resampled_dist, int N, int M):
 
     cdef:
         int i = 0, x
 
     while i < M:
-        x = int(floor(drand48() * N))
+        x = int(floor(random.random() * N))
 
-        if (drand48() < dist[x]):
+        if (random.random() < dist[x]):
             resampled_dist[x] += 1
             i += 1
 
 
-def _vertline_dist_norqa_missingvalues(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] vertline,
-    np.ndarray[INT8TYPE_t, ndim=2] recmat,
-    np.ndarray[BOOLTYPE_t, ndim=1, cast=True] mv_indices):
-
-    cdef:
-        int i, j, k = 0
-        BOOLTYPE_t missing_flag = False
-
-    for i in range(n_time):
-        if (k != 0 and not missing_flag):
-            vertline[k] += 1
-            k = 0
-
-        missing_flag = False
-
-        for j in range(n_time):
-            # check if current point in RP belongs to a missing value
-            if mv_indices[i] or mv_indices[j]:
-                missing_flag = True
-                k = 0
-            elif recmat[i, j] == 0 and missing_flag:
-                missing_flag = False
-
-            if not missing_flag:
-                if recmat[i, j] != 0:
-                    k += 1
-                elif k != 0:
-                    vertline[k] += 1
-                    k = 0
-
-
-def _vertline_dist_norqa(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] vertline,
-    np.ndarray[INT8TYPE_t, ndim=2] recmat):
-
-    cdef int i, j, k = 0
-
-    for i in range(n_time):
-        if k != 0:
-            vertline[k] += 1
-            k = 0
-
-        for j in range(n_time):
-            if recmat[i, j] != 0:
-                k += 1
-            elif k != 0:
-                vertline[k] += 1
-                k = 0
-
-
-def _vertline_dist_rqa_missingvalues(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] vertline,
-    np.ndarray[BOOLTYPE_t, ndim=1, cast=True] mv_indices,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] embedding, float eps, int dim):
-
-    cdef:
-        int i, j, k = 0, l
-        float temp_diff, diff
-        BOOLTYPE_t missing_flag = False
-
-    for i in range(n_time):
-        if k != 0 and not missing_flag:
-            vertline[k] += 1
-            k = 0
-
-        missing_flag = False
-
-        for j in range(n_time):
-            # Compute supremum distance between state vectors
-            temp_diff = diff = 0
-            for l in range(dim):
-                # Use supremum norm
-                temp_diff = abs(embedding[i, l] - embedding[j, l])
-
-                if temp_diff > diff:
-                    diff = temp_diff
-
-            # Check if current point in RP belongs to a missing values
-            if mv_indices[i] or mv_indices[j]:
-                missing_flag = True
-                k = 0
-            elif diff > eps and missing_flag:
-                missing_flag = True
-
-            if not missing_flag:
-                # Check if recurrent point has been reached
-                if diff < eps:
-                    k += 1
-                elif k != 0:
-                    vertline[k] += 1
-                    k = 0
-
-
-def _vertline_dist_rqa(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] vertline,
-    np.ndarray[FLOAT32TYPE_t, ndim=2] embedding, float eps, int dim):
-
-    cdef:
-        int i, j, k = 0, l
-        float temp_diff, diff
-
-    for i in range(n_time):
-        if k != 0:
-            vertline[k] += 1
-            k = 0
-
-        for j in range(n_time):
-            # Compute supremum distance between state vectors
-            temp_diff = diff = 0
-            for l in range(dim):
-                # Use supremum norm
-                temp_diff = abs(embedding[i, l] - embedding[j, l])
-
-                if temp_diff > diff:
-                    diff = temp_diff
-
-            # Check if recurrent point has been reached
-            if diff < eps:
-                k += 1
-            elif k != 0:
-                vertline[k] += 1
-                k = 0
-
-
-def _white_vertline_dist(
-    int n_time, np.ndarray[INT32TYPE_t, ndim=1] white_vertline,
-    np.ndarray[INT8TYPE_t, ndim=2] R):
-
-    cdef int i, j, k = 0
-
-    for i in range(n_time):
-        if k != 0:
-            white_vertline[k] += 1
-            k = 0
-
-        for j in range(n_time):
-            if R[i, j] == 0:
-                k += 1
-            elif k != 0:
-                white_vertline[k] += 1
-                k = 0
-
-
 def _twins_r(
-    int min_dist, int N, np.ndarray[INT8TYPE_t, ndim=2] R,
-    np.ndarray[INTTYPE_t, ndim=1] nR, twins):
+    int min_dist, int N, ndarray[LAG_t, ndim=2] R,
+    ndarray[NODE_t, ndim=1] nR, twins):
 
-    cdef int j, k, l
+    cdef:
+        int j, k, l
+        object twins_j, twins_k
 
     twins.append([])
 
     for j in range(N):
         twins.append([])
         twins_j = twins[j]
 
@@ -736,147 +555,259 @@
                     # this point, j and k are twins
                     if l == N:
                         # And the twins to the twin list
                         twins_k = twins[k]
 
                         twins_j.append(k)
                         twins_k.append(j)
-
                         break
 
-def _twin_surrogates(int n_surrogates, int N, twins,
-                     np.ndarray[FLOATTYPE_t, ndim=2] original_data):
 
-    cdef int i, j, k, l, new_k, n_twins, rand
-    cdef np.ndarray[FLOATTYPE_t, ndim=2] surrogates = np.empty((n_surrogates,N))
+def _twin_surrogates_r(int n_surrogates, int N, int dim, twins,
+                       ndarray[DFIELD_t, ndim=2] embedding):
+    cdef:
+        int i, j, k, new_k, n_twins, rand
+        object twins_k
+        ndarray[DFIELD_t, ndim=2] surrogates = np.empty(
+            (n_surrogates, N, dim), dtype=DFIELD)
+
+    # Initialize random number generator
+    random.seed(datetime.now())
 
     for i in range(n_surrogates):
-        # Get the twin list for time series i
-        twins_i = twins[i]
         # Randomly choose a starting point in the original trajectory
         k = int(floor(random.random() * N))
 
         j = 0
-
         while j < N:
             # Assign state vector of surrogate trajectory
-            surrogates[i,j] = original_data[i,k]
+            surrogates[i, j, :] = embedding[k, :]
             # Get the list of twins of state vector k in the original time
             # series
-            twins_ik = twins_i[k]
+            twins_k = twins[k]
 
             # Get the number of twins of k
-            n_twins = len(twins_ik)
+            n_twins = int(len(twins_k))
             # If k has no twins, go to the next sample k+1, If k has twins at
             # m, choose among m+1 and k+1 with equal probability
             if n_twins == 0:
                 k += 1
             else:
                 # Generate a random integer between 0 and n_twins
                 rand = int(floor(random.random() * (n_twins + 1)))
 
                 # If rand = n_twings go to smple k+1, otherwise jump to the
                 # future of one of the twins
                 if rand == n_twins:
                     k += 1
                 else:
-                    k = twins_ik[rand]
+                    k = twins_k[rand]
                     k += 1
 
             # If the new k >= n_time, choose a new random starting point in the
             # original time series
             if k >= N:
                 while True:
                     new_k = int(floor(random.random() * N))
                     if new_k != k:
                         break
-
                 k = new_k
 
             j += 1
 
     return surrogates
 
-def _test_pearson_correlation(
-    np.ndarray[double, ndim=2, mode='c'] original_data not None,
-    np.ndarray[double, ndim=2, mode='c'] surrogates not None,
-    int N, int n_time):
 
-    cdef double norm = 1.0 / float(n_time)
 
-    #  Initialize Pearson correlation matrix
-    cdef np.ndarray[float, ndim=2, mode='c'] correlation = np.zeros((N, N),
-            dtype="float32")
+# recurrence line distributions ===============================================
 
-    _test_pearson_correlation_fast(
-        <double*> np.PyArray_DATA(original_data),
-        <double*> np.PyArray_DATA(surrogates),
-        <float*> np.PyArray_DATA(correlation),
-        n_time, N, norm)
 
-    return correlation
+# parameters for `_line_dist()`
+ctypedef int     (*line_type_i2J) (int, int)
+ctypedef int     (*line_type_ij2I)(int, int, int)
+ctypedef DFIELD_t (*metric_type)(int, int, int, DFIELD_t[:,:])
+
+cdef:
+    inline int i2J_vertline(int i, int N): return N
+    inline int i2J_diagline(int i, int N): return i+1
+    inline int ij2I_vertline(int i, int j, int N): return i
+    inline int ij2I_diagline(int i, int j, int N): return N - i + j
+    metric_type metric_null = NULL
+    inline DFIELD_t metric_supremum(int I, int j, int dim, DFIELD_t[:,:] E):
+        cdef:
+            int l
+            DFIELD_t diff = 0, tmp_diff
+        for l in range(dim):
+            tmp_diff = abs(E[I, l] - E[j, l])
+            if tmp_diff > diff:
+                diff = tmp_diff
+        return diff
 
 
-def _test_mutual_information(
-    np.ndarray[double, ndim=2, mode='c'] original_data not None,
-    np.ndarray[double, ndim=2, mode='c'] surrogates not None,
-    int N, int n_time, int n_bins):
+cdef void _line_dist(
+    int n_time, ndarray[NODE_t, ndim=1] hist,
+    ndarray[LAG_t, ndim=2] R, ndarray[DFIELD_t, ndim=2] E, float eps, int dim,
+    metric_type metric, bint black,
+    ndarray[MASK_t, ndim=1, cast=True] M, bint missing_values,
+    line_type_i2J i2J, line_type_ij2I ij2I, bint skip_main):
+    """
+    Recurrence line distributions, parametrised by the following arguments:
+
+      - `R` | `E (dim > 0)`: recurrence computation (cached vs. raw embedding)
+      - `metric`: embedding metric (currently only supremum)
+      - `black`: RQA colour (black vs. white)
+      - `M (missing_values == 1)`: missing input values (ignore vs. account)
+      - `line_type_*`, `skip_main`: line type (vertical vs. diagonal)
+    """
 
     cdef:
-        #  Get common range for all histograms
-        double range_min = np.min((original_data.min(), surrogates.min()))
-        double range_max = np.max((original_data.max(), surrogates.max()))
-        #  Rescale all time series to the interval [0,1], using the maximum
-        #  range of the whole dataset
-        double scaling = 1. / (range_max - range_min)
-        #  Create arrays to hold symbolic trajectories
-        np.ndarray[int, ndim=2, mode='c'] symbolic_original = \
-            np.empty((N, n_time), dtype="int32")
-        np.ndarray[int, ndim=2, mode='c'] symbolic_surrogates = \
-            np.empty((N, n_time), dtype="int32")
-        #  Initialize array to hold 1d-histograms of individual time series
-        np.ndarray[int, ndim=2, mode='c'] hist_original = \
-            np.zeros((N, n_bins), dtype="int32")
-        np.ndarray[int, ndim=2, mode='c'] hist_surrogates = \
-            np.zeros((N, n_bins), dtype="int32")
-        #  Initialize array to hold 2d-histogram for one pair of time series
-        np.ndarray[int, ndim=2, mode='c'] hist2d = \
-            np.zeros((n_bins, n_bins), dtype="int32")
-        #  Initialize mutual information array
-        np.ndarray[float, ndim=2, mode='c'] mi = np.zeros((N, N),
-                dtype="float32")
+        int i, I, j, k = 0, N = n_time
+        FIELD_t d
+        bint line, missing_flag = False
+
+    if skip_main:
+        # exclude main diagonal by skipping last outer loop iteration
+        N -= 1
+    for i in range(N):
+        for j in range(i2J(i, N)):
+            I = ij2I(i, j, N)
 
-    _test_mutual_information_fast(
-            N, n_time, n_bins, scaling, range_min,
-            <double*> np.PyArray_DATA(original_data),
-            <double*> np.PyArray_DATA(surrogates),
-            <int*> np.PyArray_DATA(symbolic_original),
-            <int*> np.PyArray_DATA(symbolic_surrogates),
-            <int*> np.PyArray_DATA(hist_original),
-            <int*> np.PyArray_DATA(hist_surrogates),
-            <int*> np.PyArray_DATA(hist2d),
-            <float*> np.PyArray_DATA(mi))
+            if dim == 0:
+                line = R[I, j] == black
+            else:
+                # compute distance between embedding vectors
+                d = metric(I, j, dim, E)
+                line = (d < eps) == black
+
+            if missing_values:
+                # check if current point in RP is a missing value
+                if M[I] or M[j]:
+                    missing_flag = True
+                    k = 0
+                # or if previous point was one, reset flag if not within line
+                elif missing_flag and not line:
+                    missing_flag = False
+
+                # only count line if it does not contain,
+                # directly follow or is followed by a missing value
+                if missing_flag:
+                    continue
 
-    return mi
+            if line:
+                # if within line, increment length
+                k += 1
+            elif k != 0:
+                # if end of line, count line and reset length
+                hist[k-1] += 1
+                k = 0
+
+        if k != 0 and not missing_flag:
+            # at end of subspace, count the last uncounted line and reset length
+            hist[k-1] += 1
+            k = 0
+        missing_flag = False
+
+
+def _vertline_dist(
+        int n_time, ndarray[NODE_t, ndim=1] hist, ndarray[LAG_t, ndim=2] R):
+    cdef:
+        ndarray[DFIELD_t, ndim=2] E_null = np.array([[]], dtype=DFIELD)
+        ndarray[MASK_t, ndim=1] M_null = np.array([], dtype=MASK)
+    _line_dist(
+        n_time, hist, R, E_null, 0, 0, metric_null, True, M_null, False,
+        i2J_vertline, ij2I_vertline, False)
+
+def _diagline_dist(
+        int n_time, ndarray[NODE_t, ndim=1] hist, ndarray[LAG_t, ndim=2] R):
+    cdef:
+        ndarray[DFIELD_t, ndim=2] E_null = np.array([[]], dtype=DFIELD)
+        ndarray[MASK_t, ndim=1] M_null = np.array([], dtype=MASK)
+    _line_dist(
+        n_time, hist, R, E_null, 0, 0, metric_null, True, M_null, False,
+        i2J_diagline, ij2I_diagline, True)
+
+def _white_vertline_dist(
+        int n_time, ndarray[NODE_t, ndim=1] hist, ndarray[LAG_t, ndim=2] R):
+    cdef:
+        ndarray[DFIELD_t, ndim=2] E_null = np.array([[]], dtype=DFIELD)
+        ndarray[MASK_t, ndim=1] M_null = np.array([], dtype=MASK)
+    _line_dist(
+        n_time, hist, R, E_null, 0, 0, metric_null, False, M_null, False,
+        i2J_vertline, ij2I_vertline, False)
+
+def _vertline_dist_sequential(
+        int n_time, ndarray[NODE_t, ndim=1] hist,
+        ndarray[DFIELD_t, ndim=2] E, float eps, int dim):
+    cdef:
+        ndarray[LAG_t, ndim=2] null_R = np.array([[]], dtype=LAG)
+        ndarray[MASK_t, ndim=1] M_null = np.array([], dtype=MASK)
+    _line_dist(
+        n_time, hist, null_R, E, eps, dim, metric_supremum, True, M_null, False,
+        i2J_vertline, ij2I_vertline, False)
+
+def _diagline_dist_sequential(
+        int n_time, ndarray[NODE_t, ndim=1] hist,
+        ndarray[DFIELD_t, ndim=2] E, float eps, int dim):
+    cdef:
+        ndarray[LAG_t, ndim=2] null_R = np.array([[]], dtype=LAG)
+        ndarray[MASK_t, ndim=1] M_null = np.array([], dtype=MASK)
+    _line_dist(
+        n_time, hist, null_R, E, eps, dim, metric_supremum, True, M_null, False,
+        i2J_diagline, ij2I_diagline, True)
+
+def _vertline_dist_missingvalues(
+        int n_time, ndarray[NODE_t, ndim=1] hist, ndarray[LAG_t, ndim=2] R,
+        ndarray[MASK_t, ndim=1, cast=True] M):
+    cdef:
+        ndarray[DFIELD_t, ndim=2] E_null = np.array([[]], dtype=DFIELD)
+    _line_dist(
+        n_time, hist, R, E_null, 0, 0, metric_null, True, M, True,
+        i2J_vertline, ij2I_vertline, False)
+
+def _diagline_dist_missingvalues(
+        int n_time, ndarray[NODE_t, ndim=1] hist, ndarray[LAG_t, ndim=2] R,
+        ndarray[MASK_t, ndim=1, cast=True] M):
+    cdef:
+        ndarray[DFIELD_t, ndim=2] E_null = np.array([[]], dtype=DFIELD)
+    _line_dist(
+        n_time, hist, R, E_null, 0, 0, metric_null, True, M, True,
+        i2J_diagline, ij2I_diagline, True)
+
+def _vertline_dist_sequential_missingvalues(
+        int n_time, ndarray[NODE_t, ndim=1] hist,
+        ndarray[MASK_t, ndim=1, cast=True] M,
+        ndarray[DFIELD_t, ndim=2] E, float eps, int dim):
+    cdef:
+        ndarray[LAG_t, ndim=2] null_R = np.array([[]], dtype=LAG)
+    _line_dist(
+        n_time, hist, null_R, E, eps, dim, metric_supremum, True, M, True,
+        i2J_vertline, ij2I_vertline, False)
+
+def _diagline_dist_sequential_missingvalues(
+        int n_time, ndarray[NODE_t, ndim=1] hist,
+        ndarray[MASK_t, ndim=1, cast=True] M,
+        ndarray[DFIELD_t, ndim=2] E, float eps, int dim):
+    cdef:
+        ndarray[LAG_t, ndim=2] null_R = np.array([[]], dtype=LAG)
+    _line_dist(
+        n_time, hist, null_R, E, eps, dim, metric_supremum, True, M, True,
+        i2J_diagline, ij2I_diagline, True)
 
 
-# visibitly graph =============================================================
+# visibility graph =============================================================
+
 
 def _visibility_relations_missingvalues(
-    np.ndarray[FLOAT32TYPE_t, ndim=1] x, np.ndarray[FLOAT32TYPE_t, ndim=1] t,
-    int N, np.ndarray[INT8TYPE_t, ndim=2] A,
-    np.ndarray[BOOLTYPE_t, ndim=1, cast=True] mv_indices):
-    """
-    >>> 42 == 42
-    True
-    """
+    ndarray[FIELD_t, ndim=1] x, ndarray[FIELD_t, ndim=1] t,
+    int N, ndarray[MASK_t, ndim=2] A,
+    ndarray[MASK_t, ndim=1, cast=True] mv_indices):
 
     cdef:
         int i, j, k
-        float test
+        FIELD_t test
 
     for i in range(N-2):
         for j in range(i+2, N):
             k = i + 1
 
             test = (x[j] - x[i]) / (t[j] - t[i])
 
@@ -890,20 +821,20 @@
     # Add trivial connections of subsequent observations in time series
     for i in range(N-1):
         if not mv_indices[i] and not mv_indices[i+1]:
             A[i, i+1] = A[i+1, i] = 1
 
 
 def _visibility_relations_no_missingvalues(
-    np.ndarray[FLOAT32TYPE_t, ndim=1] x, np.ndarray[FLOAT32TYPE_t, ndim=1] t,
-    int N, np.ndarray[INT8TYPE_t, ndim=2] A):
+    ndarray[FIELD_t, ndim=1] x, ndarray[FIELD_t, ndim=1] t,
+    int N, ndarray[MASK_t, ndim=2] A):
 
     cdef:
         int i, j, k
-        float test
+        FIELD_t test
 
     for i in range(N-2):
         for j in range(i+2, N):
             k = i + 1
 
             test = (x[j] - x[i]) / (t[j] - t[i])
 
@@ -915,20 +846,19 @@
 
     # Add trivial connections of subsequent observations in time series
     for i in range(N-1):
         A[i, i+1] = A[i+1, i] = 1
 
 
 def _visibility_relations_horizontal(
-    np.ndarray[FLOAT32TYPE_t, ndim=1] x, np.ndarray[FLOAT32TYPE_t, ndim=1] t,
-    int N, np.ndarray[INT8TYPE_t, ndim=2] A):
+    ndarray[FIELD_t, ndim=1] x, int N, ndarray[MASK_t, ndim=2] A):
 
     cdef:
         int i, j, k
-        float minimum
+        FIELD_t minimum
 
     for i in range(N-2):
         for j in range(i+2, N):
             k = i + 1
             minimum = min(x[i], x[j])
 
             while x[k] < minimum and k < j:
@@ -938,42 +868,18 @@
                 A[i, j] = A[j, i] = 1
 
     # Add trivial connections of subsequent observations in time series
     for i in range(N-1):
         A[i, i+1] = A[i+1, i] = 1
 
 
-def _visibility(
-        np.ndarray[FLOAT32TYPE_t, ndim=1] time,
-        np.ndarray[FLOAT32TYPE_t, ndim=1] val, int node1, int node2):
-
-    cdef:
-        int i, j, k
-        np.ndarray[BOOLTYPE_t, ndim=1] test
-
-    i = min(node1,node2)
-    j = max(node1,node2)
-
-    """
-    testfun = lambda k: np.less((val[k]-val[i])/(time[k]-time[i]),
-                                (val[j]-val[i])/(time[j]-time[i]))
-    test = np.bool(np.sum(~np.array(map(testfun, range(i+1,j)))))
-    return np.invert(test)
-    """
-    test = np.zeros((j-(i+1)), dtype=np.uint8)
-    for k in range(i+1,j):
-        test[k-(i+1)] = np.less((val[k]-val[i])/(time[k]-time[i]),
-                            (val[j]-val[i])/(time[j]-time[i]))
-    return np.invert(np.bool(np.sum(test)))
-
-
 def _retarded_local_clustering(
-    int N, np.ndarray[INT16TYPE_t, ndim=2] A,
-    np.ndarray[FLOATTYPE_t, ndim=1] norm,
-    np.ndarray[FLOATTYPE_t, ndim=1] retarded_clustering):
+    int N, ndarray[ADJ_t, ndim=2] A,
+    ndarray[DFIELD_t, ndim=1] norm,
+    ndarray[DFIELD_t, ndim=1] retarded_clustering):
 
     cdef:
         int i, j, k
         long counter
 
     # Loop over all nodes
     for i in range(N):
@@ -988,17 +894,17 @@
                     if A[i, j] == 1 and A[j, k] == 1 and A[k, i] == 1:
                         counter += 1
 
             retarded_clustering[i] = counter / norm[i]
 
 
 def _advanced_local_clustering(
-    int N, np.ndarray[INT16TYPE_t, ndim=2] A,
-    np.ndarray[FLOATTYPE_t, ndim=1] norm,
-    np.ndarray[FLOATTYPE_t, ndim=1] advanced_clustering):
+    int N, ndarray[ADJ_t, ndim=2] A,
+    ndarray[DFIELD_t, ndim=1] norm,
+    ndarray[DFIELD_t, ndim=1] advanced_clustering):
 
     cdef:
         int i, j, k
         long counter
 
     # Loop over all nodes
     for i in range(N-2):
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/visibility_graph.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/visibility_graph.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -22,17 +19,18 @@
 """
 
 # array object and fast numerics
 import numpy as np
 
 from ..core import InteractingNetworks
 
+from ..core._ext.types import to_cy, ADJ, MASK, FIELD
 from ._ext.numerics import _visibility_relations_missingvalues, \
     _visibility_relations_no_missingvalues, _visibility_relations_horizontal, \
-    _visibility, _retarded_local_clustering, _advanced_local_clustering
+    _retarded_local_clustering, _advanced_local_clustering
 
 #
 #  Class definitions
 #
 
 
 class VisibilityGraph(InteractingNetworks):
@@ -73,21 +71,21 @@
 
         #  Set missing_values flag
         self.missing_values = missing_values
         """Controls special treatment of missing values in
            :attr:`time_series`."""
 
         #  Store time series
-        self.time_series = time_series.copy().astype("float32")
+        self.time_series = to_cy(time_series, FIELD)
         """The time series from which the visibility graph is constructed."""
 
         if timings is not None:
-            timings = timings.copy().astype("float32")
+            timings = to_cy(timings, FIELD)
         else:
-            timings = np.arange(len(time_series), dtype="float32")
+            timings = np.arange(len(time_series), dtype=FIELD)
 
         #  Store timings
         self.timings = timings
         """The timimgs of the time series data points."""
 
         #  Get missing value indices
         if self.missing_values:
@@ -103,118 +101,83 @@
         InteractingNetworks.__init__(self, A, directed=False,
                                      silence_level=silence_level)
 
     def __str__(self):
         """
         Returns a string representation.
         """
-        return 'VisibilityGraph: time series shape %s.\n%s' % (
-            self.time_series.shape, InteractingNetworks.__str__(self))
+        return ("VisibilityGraph: "
+                f"time series shape {self.time_series.shape}.\n"
+                f"{InteractingNetworks.__str__(self)}")
 
     #
     #  Visibility methods
     #
 
     def visibility_relations(self):
         """
-        TODO
+        Returns visibility between all nodes of self.timeseries
+        :rtype: 2D array of MASK
         """
         if self.silence_level <= 1:
             print("Calculating visibility relations...")
 
         #  Prepare
         x = self.time_series
         t = self.timings
         N = len(self.time_series)
-        A = np.zeros((N, N), dtype="int8")
+        A = np.zeros((N, N), dtype=MASK)
 
         if self.missing_values:
             mv_indices = self.missing_value_indices
             _visibility_relations_missingvalues(x, t, N, A, mv_indices)
 
         else:
             _visibility_relations_no_missingvalues(x, t, N, A)
 
         return A
 
     # FIXME: There is no option for missing values
     def visibility_relations_horizontal(self):
         """
-        TODO
+        Returns horizontal visibility between all nodes of self.timeseries
+        :rtype: 2D array of MASK
         """
         if self.silence_level <= 1:
             print("Calculating horizontal visibility relations...")
 
         #  Prepare
         x = self.time_series
-        t = self.timings
         N = len(self.time_series)
-        A = np.zeros((N, N), dtype="int8")
+        A = np.zeros((N, N), dtype=MASK)
 
-        _visibility_relations_horizontal(x, t, N, A)
+        _visibility_relations_horizontal(x, N, A)
         return A
 
     #
     #  Specific measures for visibility graphs
     #
 
     def visibility(self, node1, node2):
         """
         Returns the visibility between node 1 and 2 as boolean.
         :arg int node1: node index of node 1
         :arg int node2: node index of node 2
         :rtype: bool
         """
-        if node1 == node2:
-            return False
-        elif abs(node2-node1) == 1:
-            return True
-        else:
-            time = self.timings
-            val = self.time_series
-            return _visibility(time, val, node1, node2)
-
-    def visibility_horizontal(self, node1, node2):
-        """
-        Returns the horizontal visibility between node 1 and 2 as boolean.
-        :arg int node1: node index of node 1
-        :arg int node2: node index of node 2
-        :rtype: bool
-        """
-        if node1 == node2:
-            return False
-        else:
-            val = self.time_series
-            i, j = min(node1, node2), max(node1, node2)
-            if np.sum(~(val[i+1:j] < min(val[i], val[j]))):
-                return False
-            else:
-                return True
+        return self.adjacency[node1, node2]
 
     def visibility_single(self, node):
         """
         Returns the visibility between all nodes of self.time_series and node
         as array of booleans.
         :arg int node: node index of the node
         :rtype: 1D array of bool
         """
-        time_series = self.time_series
-        testfun = lambda j: self.visibility(node, j)
-        return np.array(map(testfun, range(len(time_series[1]))))
-
-    def visibility_horizontal_single(self, node):
-        """
-        Returns the horizontal visibility between all nodes of self.time_series
-        and node as array of booleans.
-        :arg int node: node index of the node
-        :rtype: 1D array of bool
-        """
-        time_series = self.time_series
-        testfun = lambda j: self.visibility_horizontal(node, j)
-        return np.array(map(testfun, range(len(time_series[1]))))
+        return self.adjacency[node, :]
 
     def retarded_degree(self):
         """Return number of neighbors in the past of a node."""
         #  Prepare
         retarded_degree = np.zeros(self.N)
         A = self.adjacency
 
@@ -248,15 +211,15 @@
         N = self.N
 
         #  Get left degree
         retarded_degree = self.retarded_degree()
         #  Prepare normalization factor
         norm = retarded_degree * (retarded_degree - 1) / 2.
 
-        _retarded_local_clustering(N, A, norm, retarded_clustering)
+        _retarded_local_clustering(N, to_cy(A, ADJ), norm, retarded_clustering)
         return retarded_clustering
 
     def advanced_local_clustering(self):
         """
         Return probability that two neighbors of a node in its future are
         connected.
         """
@@ -269,15 +232,15 @@
         N = self.N
 
         #  Get right degree
         advanced_degree = self.advanced_degree()
         #  Prepare normalization factor
         norm = advanced_degree * (advanced_degree - 1) / 2.
 
-        _advanced_local_clustering(N, A, norm, advanced_clustering)
+        _advanced_local_clustering(N, to_cy(A, ADJ), norm, advanced_clustering)
         return advanced_clustering
 
     def retarded_closeness(self):
         """Return average path length to nodes in the past of a node."""
         #  Prepare
         retarded_closeness = np.zeros(self.N)
         path_lengths = self.path_lengths()
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/inter_system_recurrence_network.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/inter_system_recurrence_network.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -200,19 +197,19 @@
             raise ValueError("Both time series x and y need to have the same \
                              dimension!")
 
     def __str__(self):
         """
         Returns a string representation.
         """
-        return ('InterSystemRecurrenceNetwork: time series shapes %s, %s.\n'
-                'Embedding dimension %i\nThreshold %s, %s metric.\n%s') % (
-                    self.x.shape, self.y.shape, self.dim if self.dim else 0,
-                    self.threshold, self.metric,
-                    InteractingNetworks.__str__(self))
+        return ("InterSystemRecurrenceNetwork: "
+                f"time series shapes {self.x.shape}, {self.y.shape}.\n"
+                f"Embedding dimension {self.dim if self.dim else 0}\n"
+                f"Threshold {self.threshold}, {self.metric} metric.\n"
+                f"{InteractingNetworks.__str__(self)}")
 
     #
     #  Service methods
     #
 
     def clear_cache(self):
         """
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/surrogates.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/surrogates.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -20,26 +17,27 @@
 multivariate data and generating time series surrogates.
 """
 
 # array object and fast numerics
 import numpy as np
 from numpy import random
 
-from ._ext.numerics import _embed_time_series_array, _recurrence_plot, \
-    _twins_s, _twin_surrogates, _test_pearson_correlation, \
-    _test_mutual_information
-
 # easy progress bar handling
-from ..utils import progressbar
+from tqdm import trange
 
+from ..core._ext.types import to_cy, ADJ, DEGREE, FIELD, DFIELD
+from ._ext.numerics import _embed_time_series_array, _recurrence_plot, \
+    _twins_s, _twin_surrogates_s, _test_pearson_correlation, \
+    _test_mutual_information
 
 #
 #  Define class Surrogates
 #
 
+
 class Surrogates:
 
     """
     Encapsulates structures and methods related to surrogate time series.
 
     Provides data structures and methods to generate surrogate data sets from a
     set of time series and to evaluate the significance of various correlation
@@ -83,16 +81,15 @@
         self._twins = None
         self._original_data_fft = None
 
     def __str__(self):
         """
         Returns a string representation.
         """
-        return 'Surrogates: time series shape %s.' % (
-            self.original_data.shape,)
+        return f"Surrogates: time series shape {self.original_data.shape}."
 
     def clear_cache(self):
         """Clean up cache."""
         try:
             del self._original_data_fft
             del self._twins
         except AttributeError:
@@ -182,18 +179,20 @@
         :return: the embedded time series.
         """
         if self.silence_level <= 1:
             print(f"Embedding all time series in dimension {dimension} "
                   f"and with lag {delay} ...")
         (N, n_time) = time_series_array.shape
 
-        embedding = np.empty((N, n_time - (dimension - 1)*delay, dimension))
+        embedding = np.empty(
+            (N, n_time - (dimension - 1)*delay, dimension), dtype=DFIELD)
 
-        _embed_time_series_array(N, n_time, dimension, delay,
-                                 time_series_array, embedding)
+        _embed_time_series_array(
+            N, n_time, dimension, delay,
+            to_cy(time_series_array, DFIELD), embedding)
         return embedding
 
     # FIXME: I(wb) included the line
     # dimension = embedding.shape[1]
     # whose missing caused an error. I can't guarantee if it is correct.
     def recurrence_plot(self, embedding, threshold):
         """
@@ -209,19 +208,18 @@
         :return: the recurrence matrix.
         """
         if self.silence_level <= 1:
             print("Calculating the recurrence plot...")
 
         n_time = embedding.shape[0]
         dimension = embedding.shape[1]
-        R = np.ones((n_time, n_time), dtype="int8")
+        R = np.ones((n_time, n_time), dtype=ADJ)
 
         _recurrence_plot(n_time, dimension, threshold,
-                         embedding.copy(order='c'),
-                         R.copy(order='c'))
+                         to_cy(embedding, FIELD), R)
         return R
 
     # FIXME: I(wb) included the line
     # dimension = embedding_array.shape[2]
     # whose missing caused an error. I can't guarantee if it is correct.
     def twins(self, embedding_array, threshold, min_dist=7):
         """
@@ -246,21 +244,20 @@
 
         N = embedding_array.shape[0]
         n_time = embedding_array.shape[1]
         dimension = embedding_array.shape[2]
         twins = []
 
         #  Initialize the R matrix with ones
-        R = np.empty((n_time, n_time))
+        R = np.empty((n_time, n_time), dtype=ADJ)
         #  Initialize array to store the number of neighbors for each sample
-        nR = np.empty(n_time)
+        nR = np.empty(n_time, dtype=DEGREE)
 
         _twins_s(N, n_time, dimension, threshold, min_dist,
-                 embedding_array.copy(order='c'), R.copy(order='c'),
-                 nR.copy(order='c'), twins)
+                 to_cy(embedding_array, DFIELD), R, nR, twins)
 
         return twins
 
     #
     #  Define methods to generate sets of surrogate time series
     #
 
@@ -523,16 +520,16 @@
         else:
             embedding = self.embed_time_series_array(original_data,
                                                      dimension, delay)
             twins = self.twins(embedding, threshold, min_dist)
             self._twins = twins
             self._twins_cached = True
 
-        return _twin_surrogates(N, n_time, twins,
-                                original_data.copy(order='c'))
+        return _twin_surrogates_s(N, n_time, twins,
+                                  to_cy(original_data, DFIELD))
 
     #
     #  Defines methods to generate correlation measure matrices based on
     #  original_data and surrogate data for significance testing.
     #
 
     @staticmethod
@@ -581,17 +578,16 @@
         :arg original_data: The original time series.
         :type surrogates: 2D array [index, time]
         :arg surrogates: The surrogate time series.
         :rtype: 2D array [index, index]
         :return: the Pearson correlation test matrix.
         """
         (N, n_time) = original_data.shape
-        norm = 1. / float(n_time)
-        return _test_pearson_correlation(original_data.copy(order='c'),
-                                         surrogates.copy(order='c'),
+        return _test_pearson_correlation(to_cy(original_data, DFIELD),
+                                         to_cy(surrogates, DFIELD),
                                          N, n_time)
 
     @staticmethod
     def test_mutual_information(original_data, surrogates, n_bins=32):
         """
         Return a test matrix of mutual information (zero lag).
 
@@ -612,17 +608,17 @@
         :return: the mutual information test matrix.
         """
         (N, n_time) = original_data.shape
         #  Calculate symbolic time series and histograms
         #  Calculate 2D histograms and mutual information
         #  mi[i,j] gives the mutual information between the ith original_data
         #  time series and the jth surrogate time series.
-        return _test_mutual_information(original_data.copy(order='c'),
-                                        surrogates.copy(order='c'), N, n_time,
-                                        n_bins)
+        return _test_mutual_information(to_cy(original_data, DFIELD),
+                                        to_cy(surrogates, DFIELD),
+                                        N, n_time, n_bins)
 
     #
     #  Define methods to perform significance tests on correlation measures
     #  based on surrogates.
     #
 
     def original_distribution(self, test_function, original_data, n_bins=100):
@@ -704,23 +700,15 @@
         if not self._normalized:
             self.normalize_time_series_array(original_data)
             self._normalized = True
 
         #  Initialize density estimate
         density_estimate = np.zeros(n_bins)
 
-        #  Initialize progress bar
-        if self.silence_level <= 2:
-            progress = progressbar.ProgressBar(maxval=realizations).start()
-
-        for i in range(realizations):
-            #  Update progress bar
-            if self.silence_level <= 2:
-                progress.update(i)
-
+        for _ in trange(realizations, disable=self.silence_level > 2):
             #  Get the surrogate
             #  Mean and variance are conserved by all surrogates
             surrogates = surrogate_function(original_data)
 
             #  Get the correlation measure test matrix
             correlation_measure_test = np.abs(test_function(original_data,
                                                             surrogates))
@@ -738,16 +726,13 @@
             #  Add to density estimate over all realizations
             density_estimate += hist
 
             #  Clean up (should be done automatically by Python,
             #  but you never know...)
             del surrogates, correlation_measure_test
 
-        if self.silence_level <= 2:
-            progress.finish()
-
         #  Normalize density estimate
         density_estimate /= density_estimate.sum()
 
         lbb = lbb[:-1]
 
         return (density_estimate, lbb)
```

### Comparing `pyunicorn-0.6.1/pyunicorn/timeseries/recurrence_plot.py` & `pyunicorn-0.7.0/src/pyunicorn/timeseries/recurrence_plot.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -18,36 +15,35 @@
 """
 Provides classes for the analysis of dynamical systems and time series based
 on recurrence plots, including measures of recurrence quantification
 analysis (RQA) and recurrence network analysis.
 """
 
 from math import factorial
+from typing import Tuple
+from collections.abc import Hashable
 
-# array object and fast numerics
 import numpy as np
+from numpy.typing import NDArray
 
-# Cython inline code
+from ..core.cache import Cached
+from ..core._ext.types import to_cy, NODE, LAG, FIELD, DFIELD
 from ._ext.numerics import _embed_time_series, _manhattan_distance_matrix_rp, \
     _euclidean_distance_matrix_rp, _supremum_distance_matrix_rp, \
-    _set_adaptive_neighborhood_size, _bootstrap_distance_matrix_manhatten, \
-    _bootstrap_distance_matrix_euclidean, _bootstrap_distance_matrix_supremum,\
-    _diagline_dist_norqa_missingvalues, _diagline_dist_norqa, \
-    _diagline_dist_rqa_missingvalues, _diagline_dist_rqa, \
-    _vertline_dist_norqa_missingvalues, _vertline_dist_norqa, \
-    _vertline_dist_rqa_missingvalues, _vertline_dist_rqa, _rejection_sampling,\
-    _white_vertline_dist, _twins_r, _twin_surrogates
-
-#
-#  Class definitions
-#
-
+    _set_adaptive_neighborhood_size, _bootstrap_distance_matrix_manhattan, \
+    _bootstrap_distance_matrix_euclidean, \
+    _bootstrap_distance_matrix_supremum, \
+    _diagline_dist_missingvalues, _diagline_dist, \
+    _diagline_dist_sequential_missingvalues, _diagline_dist_sequential, \
+    _vertline_dist_missingvalues, _vertline_dist, \
+    _vertline_dist_sequential_missingvalues, _vertline_dist_sequential, \
+    _rejection_sampling, _white_vertline_dist, _twins_r, _twin_surrogates_r
 
-class RecurrencePlot:
 
+class RecurrencePlot(Cached):
     """
     Class RecurrencePlot for generating and quantitatively analyzing
     :index:`recurrence plots <single: recurrence plot>`.
 
     The RecurrencePlot class supports the construction of recurrence plots
     from multi-dimensional time series, optionally using embedding. Currently,
     manhattan, euclidean and supremum norms are provided for measuring
@@ -78,17 +74,18 @@
                           recurrence_rate=0.05).recurrence_rate()
     """
 
     #
     #  Internal methods
     #
 
-    def __init__(self, time_series, metric="supremum", normalize=False,
-                 missing_values=False, sparse_rqa=False, silence_level=0,
-                 **kwds):
+    def __init__(self, time_series: NDArray, metric: str = "supremum",
+                 normalize: bool = False, missing_values: bool = False,
+                 sparse_rqa: bool = False, silence_level: int = 0,
+                 **kwargs):
         """
         Initialize an instance of RecurrencePlot.
 
         Either recurrence threshold ``threshold``/``threshold_std``, recurrence
         rate ``recurrence_rate`` or local recurrence rate
         ``local_recurrence_rate`` have to be given as keyword arguments.
 
@@ -107,14 +104,16 @@
             ("manhattan", "euclidean", "supremum").
         :arg bool normalize: Decide whether to normalize the time series to
             zero mean and unit standard deviation.
         :arg bool missing_values: Toggle special treatment of missing values in
             :attr:`.RecurrencePlot.time_series`.
         :arg bool sparse_rqa: Toggles sequential RQA computation using less
             memory for use with long time series.
+        :arg bool skip_recurrence: Skip calculation of recurrence matrix within
+            RP class (e.g. when overloading respective methods in child class)
         :arg int silence_level: Inverse level of verbosity of the object.
         :arg number threshold: The recurrence threshold keyword for generating
             the recurrence plot using a fixed threshold.
         :arg number threshold_std: The recurrence threshold keyword for
             generating the recurrence plot using a fixed threshold in units of
             the time series' STD.
         :arg number recurrence_rate: The recurrence rate keyword for generating
@@ -138,73 +137,70 @@
            :attr:`.RecurrencePlot.time_series`."""
 
         #  Set sparse RQA flag
         self.sparse_rqa = sparse_rqa
         """Controls sequential calculation of RQA measures."""
 
         #  Store time series
-        self.time_series = time_series.copy().astype("float32")
+        self.time_series = to_cy(time_series, FIELD)
         """The time series from which the recurrence plot is constructed."""
 
         #  Reshape time series
         self.time_series.shape = (self.time_series.shape[0], -1)
 
         #  Store type of metric
+        self._known_metrics = ("manhattan", "euclidean", "supremum")
+        assert metric in self._known_metrics
         self.metric = metric
         """The metric used for measuring distances in phase space."""
 
         # minimal denominator for numerical stability
         self._epsilon = 1e-08
 
         #  Normalize time series
         if normalize:
             self.normalize_time_series(self.time_series)
 
-        #  Get embedding dimension and delay from **kwds
-        self.dim = kwds.get("dim")
-        self.tau = kwds.get("tau")
+        #  Get embedding dimension and delay from **kwargs
+        self.dim = kwargs.get("dim")
+        self.tau = kwargs.get("tau")
 
-        if self.dim is not None and self.tau is not None:
-            #  Embed the time series
-            self.embedding = self.embed_time_series(self.time_series, self.dim,
-                                                    self.tau)
-            """The embedded time series."""
-        else:
-            self.embedding = self.time_series
-
-        self.N = self.embedding.shape[0]
+        self.N: int = 0
         """The number of state vectors (number of lines and rows) of the RP."""
         self.R = None
         """The recurrence matrix."""
 
+        self._mut_embedding: int = 0
+        if (self.dim is not None) and (self.tau is not None):
+            #  Embed the time series
+            self.embedding = self.embed_time_series(
+                self.time_series, self.dim, self.tau)
+        else:
+            self.embedding = self.time_series
+
         #  Get missing value indices
         if self.missing_values:
             self.missing_value_indices = \
                 np.isnan(self.embedding).sum(axis=1) != 0
 
-        #  Get threshold or recurrence rate from **kwds, construct recurrence
+        #  Get threshold or recurrence rate from **kwargs, construct recurrence
         #  plot accordingly
-        self.threshold = kwds.get("threshold")
-        self.threshold_std = kwds.get("threshold_std")
+        self.threshold = kwargs.get("threshold")
+        self.threshold_std = kwargs.get("threshold_std")
         #  Make sure not to overwrite the method recurrence_rate()
-        recurrence_rate = kwds.get("recurrence_rate")
-        self.local_recurrence_rate = kwds.get("local_recurrence_rate")
+        recurrence_rate = kwargs.get("recurrence_rate")
+        self.local_recurrence_rate = kwargs.get("local_recurrence_rate")
         self.adaptive_neighborhood_size = \
-            kwds.get("adaptive_neighborhood_size")
+            kwargs.get("adaptive_neighborhood_size")
 
-        #  Initialize cache
-        self._distance_matrix_cached = False
-        self._distance_matrix = None
-        self._diagline_dist_cached = False
-        self._diagline_dist = None
-        self._vertline_dist_cached = False
-        self._vertline_dist = None
+        #  Precompute recurrence matrix only if sequential RQA is switched off,
+        #  and not calling from child class with respective overriding methods.
+        skip_recurrence = kwargs.get("skip_recurrence")
 
-        #  Precompute recurrence matrix only if sequential RQA is switched off.
-        if not sparse_rqa:
+        if not sparse_rqa and not skip_recurrence:
             if self.threshold is not None:
                 #  Calculate the recurrence matrix R using the radius of
                 #  neighborhood threshold
                 RecurrencePlot.set_fixed_threshold(self, self.threshold)
             elif self.threshold_std is not None:
                 #  Calculate the recurrence matrix R using the radius of
                 #  neighborhood threshold in units of the time series' STD
@@ -226,35 +222,39 @@
                 RecurrencePlot.set_adaptive_neighborhood_size(
                     self, self.adaptive_neighborhood_size)
             else:
                 raise NameError("Please give either threshold or \
                                 recurrence_rate to construct the recurrence \
                                 plot!")
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return (self._mut_embedding,)
+
     def __str__(self):
         """
         Returns a string representation.
         """
-        return ('RecurrencePlot: time series shape %s.\n'
-                'Embedding dimension %i\nThreshold %s, %s metric') % (
-                    self.time_series.shape, self.dim if self.dim else 0,
-                    self.threshold, self.metric)
-
-    def clear_cache(self, irreversible=False):
-        """Clean up memory."""
-        if irreversible:
-            if self._distance_matrix_cached:
-                del self._distance_matrix
-                self._distance_matrix_cached = False
-            if self._diagline_dist_cached:
-                del self._diagline_dist
-                self._diagline_dist_cached = False
-            if self._vertline_dist_cached:
-                del self._vertline_dist
-                self._vertline_dist_cached = False
+        return ("RecurrencePlot: "
+                f"time series shape {self.time_series.shape}.\n"
+                f"Embedding dimension {self.dim if self.dim else 0}\n"
+                f"Threshold {self.threshold}, {self.metric} metric")
+
+    @property
+    def embedding(self) -> np.ndarray:
+        """
+        The embedded time series / phase space trajectory
+        (time, embedding dimension).
+        """
+        return self._embedding
+
+    @embedding.setter
+    def embedding(self, embedding: np.ndarray):
+        self._embedding = to_cy(embedding, DFIELD)
+        self.N = self._embedding.shape[0]
+        self._mut_embedding += 1
 
     #
     #  Service methods
     #
 
     def recurrence_matrix(self):
         """
@@ -266,42 +266,26 @@
         if not self.sparse_rqa:
             return self.R
         else:
             print("Exception: Sequential RQA mode is enabled. "
                   "Recurrence matrix is not stored in memory.")
             return None
 
-    def distance_matrix(self, embedding, metric):
+    def distance_matrix(self, metric: str):
         """
         Return phase space distance matrix :math:`D` according to the chosen
         metric.
 
-        :type embedding: 2D array (time, embedding dimension)
-        :arg embedding: The phase space trajectory.
         :arg str metric: The metric for measuring distances in phase space
             ("manhattan", "euclidean", "supremum").
         :rtype: 2D square array
         :return: the phase space distance matrix :math:`D`
         """
-
-        if not self._distance_matrix_cached:
-            #  Return distance matrix according to chosen metric:
-            if metric == "manhattan":
-                self._distance_matrix = \
-                    RecurrencePlot.manhattan_distance_matrix(self, embedding)
-            elif metric == "euclidean":
-                self._distance_matrix = \
-                    RecurrencePlot.euclidean_distance_matrix(self, embedding)
-            elif metric == "supremum":
-                self._distance_matrix = \
-                    RecurrencePlot.supremum_distance_matrix(self, embedding)
-
-            self._distance_matrix_cached = True
-
-        return self._distance_matrix
+        assert metric in self._known_metrics, f"unknown metric: {metric}"
+        return getattr(RecurrencePlot, f"{metric}_distance_matrix")(self)
 
     #
     #  Time series handling methods
     #
 
     @staticmethod
     def normalize_time_series(time_series):
@@ -425,114 +409,162 @@
         :arg int tau: The embedding delay.
         :rtype: 2D array (time, dimension)
         :return: the embedded phase space trajectory.
         """
         #  Make sure that dim and tau are Python integers
         dim = int(dim)
         tau = int(tau)
-        time_series = time_series.astype("float32")
-
+        time_series = to_cy(time_series, FIELD)
+        if time_series.ndim > 1:
+            time_series = time_series.squeeze(axis=-1)
+        assert time_series.ndim == 1
         n_time = time_series.shape[0]
-        embedding = np.empty((n_time - (dim - 1) * tau, dim), dtype="float32")
-
-        # Reshape time series if it is one dimensional
-        if time_series.ndim == 1:
-            time_series.shape = (time_series.shape[0], -1)
 
+        embedding = np.empty((n_time - (dim - 1) * tau, dim), dtype=FIELD)
         _embed_time_series(n_time, dim, tau, time_series, embedding)
         return embedding
 
+    def permutation_entropy(self, normalize=True):
+        """
+        Returns the permutation entropy for an embedded time series.
+        An embedding of 3 <= embedding dimension <= 7 is recommended for this
+        method.
+
+        Reference: [Bandt2002]_
+
+        :rtype: double
+        :return: Permutation entropy of the embedded time series
+        """
+        if self.dim is None or self.tau is None:
+            raise ValueError("Permutation Entropy only works for "
+                             "one-dimensional embedded time series!")
+
+        # Calculate order from embedding
+        temp = self.embedding.argsort(axis=1)
+        ranks = temp.argsort(axis=1)
+
+        # Calculate probability distribution
+        P = np.unique(ranks, return_counts=True, axis=0)[1]
+        P = P / ranks.shape[0]
+
+        entropy = abs(-(P*np.log2(P)).sum())
+        if normalize:
+            entropy = entropy / np.log2(factorial(self.dim))
+
+        return entropy
+
+    def complexity_entropy(self):
+        """
+        Returns the complexity entropy for each dimension of the time series.
+
+        Reference: [Ribeiro2011]_
+
+        :rtype: double
+        :return: Complexity entropy of the embedded time series
+        """
+
+        if self.dim is None or self.tau is None:
+            raise ValueError("Complexity Entropy only works for "
+                             "one-dimensional embedded time series!")
+
+        # Calculate ranks from embedding
+        temp = self.embedding.argsort(axis=1)
+        ranks = temp.argsort(axis=1)
+
+        # Calculate probability distribution
+        P = np.unique(ranks, return_counts=True, axis=0)[1]
+        P = P / ranks.shape[0]
+
+        # Calculate factorial of embedding dimension
+        d_fac = factorial(self.dim)
+
+        # Calculate permutation entropy
+        S_P = abs(-(P*np.log2(P)).sum())
+
+        # Initialize unit probability distribution
+        P_e = np.ones(d_fac) / d_fac
+
+        # Calculate permutation entropy of unit probability distribution
+        S_Pe = abs(-(P_e*np.log2(P_e)).sum())
+
+        # Calculate combined probability distribution
+        P_comb = np.zeros(d_fac)
+        P_comb[:len(P)] = P
+        P_comb = (P_comb + P_e) / 2
+
+        # Calculate permutation entropy of combinded probability distribution
+        S_PPe = abs(-(P_comb*np.log2(P_comb)).sum())
+
+        # Calculation of maximum Q split into several steps for
+        # readability
+        Q_max = (d_fac + 1) / d_fac * np.log2(d_fac + 1)
+        Q_max = Q_max - 2*np.log2(2*d_fac) + np.log2(d_fac)
+        Q_max = - Q_max / 2
+
+        Q = (S_PPe - S_P/2 - S_Pe/2) / Q_max
+
+        complexity_entropy = Q * S_P / np.log2(d_fac)
+
+        return complexity_entropy
+
     #
     #  Calculate recurrence plot
     #
 
-    def manhattan_distance_matrix(self, embedding):
+    @Cached.method(name="the manhattan distance matrix")
+    def manhattan_distance_matrix(self):
         """
         Return the manhattan distance matrix from an embedding of a time
         series.
 
-        :type embedding: 2D array (time, embedding dimension)
-        :arg embedding: The phase space trajectory.
-        :rtype: 2D square array ("float32")
+        :rtype: 2D square array
         :return: the manhattan distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating the manhattan distance matrix...")
-
-        (n_time, dim) = embedding.shape
-        distance = np.zeros((n_time, n_time), dtype="float32")
-
-        _manhattan_distance_matrix_rp(n_time, dim, embedding, distance)
-        return distance
+        (n_time, dim) = self.embedding.shape
+        return _manhattan_distance_matrix_rp(n_time, dim, self.embedding)
 
-    def euclidean_distance_matrix(self, embedding):
+    @Cached.method(name="the euclidean distance matrix")
+    def euclidean_distance_matrix(self):
         """
         Return the euclidean distance matrix from an embedding of a time
         series.
 
-        :type embedding: 2D array (time, embedding dimension)
-        :arg embedding: The phase space trajectory.
-        :rtype: 2D square array ("float32")
+        :rtype: 2D square array
         :return: the euclidean distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating the euclidean distance matrix...")
+        (n_time, dim) = self.embedding.shape
+        return _euclidean_distance_matrix_rp(n_time, dim, self.embedding)
 
-        (n_time, dim) = embedding.shape
-        distance = np.zeros((n_time, n_time), dtype="float32")
-
-        _euclidean_distance_matrix_rp(n_time, dim, embedding, distance)
-        distance = np.sqrt(distance)
-        return distance
-
-    def supremum_distance_matrix(self, embedding):
+    @Cached.method(name="the supremum distance matrix")
+    def supremum_distance_matrix(self):
         """
         Return the supremum distance matrix from an embedding of a time series.
 
-        :type embedding: 2D Numpy array (time, embedding dimension)
-        :arg embedding: The phase space trajectory.
-
-        :rtype: 2D square Numpy array ("float32")
+        :rtype: 2D square Numpy array
         :return: the supremum distance matrix.
         """
-        if self.silence_level <= 1:
-            print("Calculating the supremum distance matrix...")
-
-        (n_time, dim) = embedding.shape
-        distance = np.zeros((n_time, n_time), dtype="float32")
-
-        _supremum_distance_matrix_rp(n_time, dim, embedding, distance)
-        return distance
+        (n_time, dim) = self.embedding.shape
+        return _supremum_distance_matrix_rp(n_time, dim, self.embedding)
 
     def set_fixed_threshold(self, threshold):
         """
         Set the recurrence plot to a fixed threshold.
 
         Modifies / sets the class variables :attr:`R` and :attr:`N`
         accordingly.
 
         :arg number threshold: The recurrence threshold.
         """
         if self.silence_level <= 1:
             print("Calculating recurrence plot at fixed threshold...")
 
-        #  Get distance matrix, according to self.metric
-        distance = RecurrencePlot.distance_matrix(
-            self, self.embedding, self.metric)
-
-        #  Get number of nodes
+        distance = RecurrencePlot.distance_matrix(self, self.metric)
         n_time = distance.shape[0]
-
-        #  Initialize recurrence matrix
         recurrence = np.zeros((n_time, n_time), dtype="int8")
-
-        #  Thresholding the distance matrix
         recurrence[distance < threshold] = 1
-
-        #  Handle missing values
         if self.missing_values:
             #  Write missing value lines and rows to recurrence matrix
             #  NaN flag is not supported by int8 data format -> use 0 here
             recurrence[self.missing_value_indices, :] = 0
             recurrence[:, self.missing_value_indices] = 0
 
         self.R = recurrence
@@ -548,48 +580,35 @@
         :arg number threshold_std: The recurrence threshold in units of the
             standard deviation of the time series.
         """
         if self.silence_level <= 1:
             print("Calculating recurrence plot at fixed threshold in units of "
                   "time series STD...")
 
-        #  Get absolute threshold
         threshold = threshold_std * self.time_series.std()
-
-        #  Call set fixed threshold method
         RecurrencePlot.set_fixed_threshold(self, threshold)
 
     def set_fixed_recurrence_rate(self, recurrence_rate):
         """
         Set the recurrence plot to a fixed recurrence rate.
 
         Modifies / sets the class variables :attr:`R` and :attr:`N`
         accordingly.
 
         :arg number recurrence_rate: The recurrence rate.
         """
         if self.silence_level <= 1:
             print("Calculating recurrence plot at fixed recurrence rate...")
 
-        #  Get distance matrix, according to self.metric
-        distance = self.distance_matrix(self.embedding, self.metric)
-
-        #  Get number of nodes
+        distance = RecurrencePlot.distance_matrix(self, self.metric)
         n_time = distance.shape[0]
-
-        #  Get threshold to obtain fixed recurrence rate
         threshold = self.threshold_from_recurrence_rate(distance,
                                                         recurrence_rate)
-
-        #  Initialize recurrence matrix
         recurrence = np.zeros((n_time, n_time), dtype="int8")
-
-        #  Thresholding the distance matrix
         recurrence[distance < threshold] = 1
-
         self.R = recurrence
 
     def set_fixed_local_recurrence_rate(self, local_recurrence_rate):
         """
         Set the recurrence plot to a fixed local recurrence rate.
 
         This results in a fixed number of recurrences for each state vector,
@@ -601,32 +620,24 @@
 
         :arg number local_recurrence_rate: The local recurrence rate.
         """
         if self.silence_level <= 1:
             print("Calculating recurrence plot at fixed "
                   "local recurrence rate...")
 
-        #  Get distance matrix, according to self.metric
-        distance = self.distance_matrix(self.embedding, self.metric)
-
-        #  Get number of nodes
+        distance = RecurrencePlot.distance_matrix(self, self.metric)
         n_time = distance.shape[0]
-
-        #  Initialize recurrence matrix
         recurrence = np.zeros((n_time, n_time), dtype="int8")
-
         for i in range(n_time):
             #  Get threshold for state vector i to obtain fixed local
             #  recurrence rate
             local_threshold = self.threshold_from_recurrence_rate(
                 distance[i, :], local_recurrence_rate)
-
             #  Thresholding the distance matrix for column i
             recurrence[i, distance[i, :] < local_threshold] = 1
-
         self.R = recurrence
 
     def set_adaptive_neighborhood_size(self, adaptive_neighborhood_size,
                                        order=None):
         """
         Construct recurrence plot using the :index:`adaptive neighborhood
         size <single: adaptive neighborhood size; recurrence plot>` algorithm
@@ -645,39 +656,36 @@
         :arg order: The indices of state vectors in the order desired for
             processing by the algorithm. The standard order is :math:`1,...,N`.
         """
         if self.silence_level <= 1:
             print("Calculating recurrence plot using the "
                   "adaptive neighborhood size algorithm...")
 
-        #  Get distance matrix, according to self.metric
-        distance = self.distance_matrix(self.embedding, self.metric)
+        distance = RecurrencePlot.distance_matrix(self, self.metric)
 
         #  Get indices that would sort the distance matrix.
         #  sorted_neighbors[i,j] contains the index of the jth nearest neighbor
         #  of i. Sorting order is very important here!
-        sorted_neighbors = distance.argsort(axis=1)
-        sorted_neighbors = sorted_neighbors.astype("int32")
+        sorted_neighbors = to_cy(distance.argsort(axis=1), NODE)
 
-        #  Get number of nodes
         n_time = distance.shape[0]
-
-        #  Initialize recurrence matrix
-        recurrence = np.zeros((n_time, n_time), dtype="int8")
+        recurrence = np.zeros((n_time, n_time), dtype=LAG)
 
         #  Set processing order of state vectors
         if order is None:
-            order = np.arange(n_time)
+            order = np.arange(n_time, dtype=NODE)
+        else:
+            order = to_cy(order, NODE)
 
         _set_adaptive_neighborhood_size(n_time, adaptive_neighborhood_size,
                                         sorted_neighbors, order, recurrence)
         self.R = recurrence
 
     @staticmethod
-    def threshold_from_recurrence_rate(distance, recurrence_rate):
+    def threshold_from_recurrence_rate(distance, recurrence_rate: float):
         """
         Return the threshold for recurrence plot construction given the
         recurrence rate.
 
         Be aware, that the returned threshold can only approximately give the
         desired recurrence rate. The accuracy depends on the distribution of
         values in the given distance matrix :math:`D`.
@@ -689,15 +697,17 @@
             recurrence rate.
         """
         #  Flatten and sort distance matrix
         flat_distance = distance.flatten()
         flat_distance.sort()
 
         #  Get threshold
-        threshold = flat_distance[int(recurrence_rate * len(flat_distance))]
+        assert 0 <= recurrence_rate <= 1
+        N = len(flat_distance)
+        threshold = flat_distance[int(recurrence_rate * (N - 1))]
 
         #  Clean up
         del flat_distance
 
         return threshold
 
     @staticmethod
@@ -747,20 +757,20 @@
             ("manhattan", "euclidean", "supremum").
         :arg int M: Number of bootstrap samples
         :rtype: 1D array ("float32")
         :return: the bootstrap samples from distance matrix.
         """
         #  Prepare
         M = int(M)
-        embedding = embedding.astype("float32")
-        distances = np.zeros(M, dtype="float32")
+        embedding = to_cy(embedding, DFIELD)
+        distances = np.zeros(M, dtype=DFIELD)
         (n_time, dim) = embedding.shape
 
         if metric == "manhattan":
-            _bootstrap_distance_matrix_manhatten(n_time, dim, embedding,
+            _bootstrap_distance_matrix_manhattan(n_time, dim, embedding,
                                                  distances, M)
 
         elif metric == "euclidean":
             _bootstrap_distance_matrix_euclidean(n_time, dim, embedding,
                                                  distances, M)
 
         elif metric == "supremum":
@@ -796,24 +806,24 @@
         """
         Return the :index:`recurrence rate` :math:`RR`.
 
         RR gives the percentage of black dots in the recurrence plot.
 
         :return number: the recurrence rate :math:`RR`.
         """
-        #  Prepare
         N = self.N
-
         if not self.sparse_rqa:
             R = self.recurrence_matrix()
-            RR = R.sum() / float(N ** 2)
-        elif self.sparse_rqa and self.metric == "supremum":
-            RR = (self.vertline_dist() * np.arange(N)).sum() / \
-                float(N ** 2)
-
+            RR = R.sum() / N ** 2
+        elif self.metric == "supremum":
+            RR = (self.vertline_dist() * np.arange(1, N + 1)).sum() / N ** 2
+        else:
+            raise NotImplementedError(
+                "Sequential RQA is currently only available for "
+                "fixed threshold and the supremum metric.")
         return RR
 
     def recurrence_probability(self, lag=0):
         """
         Return the recurrence probability. This is the probability, that
         the trajectory is recurrent after 'lag' time steps.
 
@@ -827,72 +837,77 @@
 
         return SUM / float(N-lag)
 
     #
     #  RQA measures based on black diagonal lines
     #
 
+    @Cached.method(attrs=(
+        "metric", "threshold", "missing_values", "sparse_rqa"))
     def diagline_dist(self):
         """
         Return the :index:`frequency distribution of diagonal line lengths
-        <triple: frequency distribution; diagonal; line length>` :math:`P(l)`.
+        <triple: frequency distribution; diagonal; line length>`
+        :math:`P(l-1)`.
 
-        The :math:`l` th entry of :math:`P(l)` contains the number of
+        Note that entry :math:`P(l-1)` contains the number of
         :index:`diagonal lines <pair: diagonal; lines>` of length :math:`l`.
+        Thus, :math:`P(0)` counts lines of length :math:`1`,
+        :math:`P(1)` counts lines of length :math:`2`, asf.
+        The main diagonal is not counted,
+        hence :math:`P(N)` will always be :math:`0`.
 
         .. note::
            Experimental handling of missing values. Diagonal lines
            touching lines and blocks of missing entries in the
            recurrence matrix are not counted.
 
         :rtype: 1D array (int32)
         :return: the frequency distribution of diagonal line lengths
-            :math:`P(l)`.
+            :math:`P(l-1)`.
         """
-        if self._diagline_dist_cached:
-            return self._diagline_dist
+        #  Prepare
+        n_time = self.N
+        diagline = np.zeros(n_time, dtype=NODE)
+
+        if not self.sparse_rqa:
+            #  Get recurrence matrix
+            recmat = self.recurrence_matrix()
+
+            if self.missing_values:
+                mv_indices = self.missing_value_indices
+                _diagline_dist_missingvalues(
+                    n_time, diagline, recmat, mv_indices)
+            else:
+                _diagline_dist(n_time, diagline, recmat)
+
+        #  Calculations for sequential RQA
+        elif self.metric == "supremum" and self.threshold is not None:
+            #  Get embedding
+            embedding = self.embedding
+            #  Get time series dimension
+            dim = embedding.shape[1]
+            #  Get threshold
+            eps = float(self.threshold)
+
+            if self.missing_values:
+                mv_indices = self.missing_value_indices
+                _diagline_dist_sequential_missingvalues(
+                    n_time, diagline, mv_indices, embedding, eps, dim)
+            else:
+                _diagline_dist_sequential(
+                    n_time, diagline, embedding, eps, dim)
+
         else:
-            #  Prepare
-            n_time = self.N
-            diagline = np.zeros(n_time, dtype="int32")
-
-            if not self.sparse_rqa:
-                #  Get recurrence matrix
-                recmat = self.recurrence_matrix()
-
-                if self.missing_values:
-                    mv_indices = self.missing_value_indices
-                    _diagline_dist_norqa_missingvalues(n_time, diagline,
-                                                       recmat, mv_indices)
-                else:
-                    _diagline_dist_norqa(n_time, diagline, recmat)
-
-            #  Calculations for sequential RQA
-            elif self.sparse_rqa and self.metric == "supremum":
-                #  Get embedding
-                embedding = self.embedding
-                #  Get time series dimension
-                dim = embedding.shape[1]
-                #  Get threshold
-                eps = float(self.threshold)
-
-                if self.missing_values:
-                    mv_indices = self.missing_value_indices
-                    _diagline_dist_rqa_missingvalues(n_time, diagline,
-                                                     mv_indices, embedding,
-                                                     eps, dim)
-                else:
-                    _diagline_dist_rqa(n_time, diagline, embedding, eps,
-                                       dim)
-
-            #  Function just runs over the upper triangular matrix
-            self._diagline_dist = 2*diagline
-            self._diagline_dist_cached = True
+            raise NotImplementedError(
+                "Sequential RQA is currently only available for "
+                "fixed threshold and the supremum metric.")
 
-            return self._diagline_dist
+        #  Function just runs over the upper triangular matrix
+        return 2 * diagline
 
     @staticmethod
     def rejection_sampling(dist, M):
         """
         Rejection sampling of discrete frequency distribution.
 
         Use simple rejection sampling algorithm for computing a resampled
@@ -904,18 +919,18 @@
         :rtype: 1D array (integer)
         :return: the resampled frequency distribution.
         """
         #  Get number of support points
         N = len(dist)
 
         #  Prepare
-        resampled_dist = np.zeros(N)
+        resampled_dist = np.zeros(N, dtype=NODE)
 
         #  Prescribed distribution
-        dist = dist.copy().astype(float)
+        dist = to_cy(dist, DFIELD)
         #  Normalize distribution
         dist /= dist.sum()
 
         _rejection_sampling(dist, resampled_dist, N, M)
         return resampled_dist
 
     def resample_diagline_dist(self, M):
@@ -937,39 +952,34 @@
         #  Get original distribution of diagonal lines
         diagline = self.diagline_dist()
 
         #  Get maximal diagonal line length
         L_max = self.max_diaglength()
 
         #  Get resampled distribution
-        resampled_dist = np.zeros(len(diagline))
-        resampled_dist[:L_max + 1] = RecurrencePlot.\
-            rejection_sampling(diagline[:L_max + 1], M)
+        if L_max == 0:
+            resampled_dist = diagline
+        else:
+            resampled_dist = np.zeros(len(diagline), dtype=NODE)
+            resampled_dist[:L_max] = RecurrencePlot.\
+                rejection_sampling(diagline[:L_max], M)
 
         return resampled_dist
 
     def max_diaglength(self):
         """
         Return diagonal line-based RQA measure :index:`maximum diagonal line
         length <triple: maximum; diagonal; line length>` :math:`L_max`.
 
         :math:`L_max` is defined as the maximal length of a diagonal line in
         the recurrence matrix.
 
         :return number: the maximal diagonal line length :math:`L_max`.
         """
-        diagline = self.diagline_dist()
-        n_time = self.N
-        lmax = 1
-
-        for i in range(1, n_time):
-            if diagline[i] != 0:
-                lmax = i
-
-        return lmax
+        return 1 + np.nonzero(self.diagline_dist())[0].max(initial=-1)
 
     def determinism(self, l_min=2, resampled_dist=None):
         """
         Return diagonal line-based RQA measure :index:`determinism <pair: RQA;
         determinism>` :math:`DET`.
 
         :math:`DET` is defined as the ratio of recurrence points that form
@@ -978,28 +988,25 @@
 
         :arg number l_min: The minimum diagonal line length.
         :type resampled_dist: 1D array (integer)
         :arg resampled_dist: resampled frequency distribution of diagonal lines
         :return number: the determinism :math:`DET`.
         """
         #  Use resampled distribution of diagonal lines if provided
-        if resampled_dist is None:
-            diagline = self.diagline_dist()
-        else:
-            diagline = resampled_dist
-
+        diagline = (self.diagline_dist() if resampled_dist is None
+                    else resampled_dist)
         n_time = self.N
 
         #  Number of recurrence points that form diagonal structures (of at
         #  least length l_min)
-        partial_sum = (np.arange(l_min, n_time) * diagline[l_min:]).sum()
+        partial_sum = np.arange(l_min, n_time+1) @ diagline[l_min-1:]
 
         #  Number of all recurrence points that form diagonal lines (except
         #  the main diagonal)
-        full_sum = (np.arange(n_time) * diagline).sum()
+        full_sum = np.arange(1, n_time+1) @ diagline
 
         return partial_sum / float(full_sum + self._epsilon)
 
     def average_diaglength(self, l_min=2, resampled_dist=None):
         """
         Return diagonal line-based RQA measure :index:`average diagonal line
         length <triple: average; diagonal; line length>` :math:`L`.
@@ -1009,27 +1016,24 @@
 
         :arg number l_min: The minimum diagonal line length.
         :type resampled_dist: 1D array (integer)
         :arg resampled_dist: resampled frequency distribution of diagonal lines
         :return number: the average diagonal line length :math:`L`.
         """
         #  Use resampled distribution of diagonal lines if provided
-        if resampled_dist is None:
-            diagline = self.diagline_dist()
-        else:
-            diagline = resampled_dist
-
+        diagline = (self.diagline_dist() if resampled_dist is None
+                    else resampled_dist)
         n_time = self.N
 
         #  Number of recurrence points that form diagonal structures (of at
         #  least length l_min)
-        partial_sum = (np.arange(l_min, n_time) * diagline[l_min:]).sum()
+        partial_sum = np.arange(l_min, n_time+1) @ diagline[l_min-1:]
 
         #  Total number of diagonal lines of at least length l_min
-        number_diagline = diagline[l_min:].sum()
+        number_diagline = diagline[l_min-1:].sum()
 
         return partial_sum / float(number_diagline + self._epsilon)
 
     def diag_entropy(self, l_min=2, resampled_dist=None):
         """
         Return diagonal line-based RQA measure :index:`diagonal line entropy
         <pair: diagonal; line entropy>` :math:`ENTR`.
@@ -1040,88 +1044,89 @@
 
         :arg number l_min: The minimal diagonal line length.
         :type resampled_dist: 1D array (integer)
         :arg resampled_dist: resampled frequency distribution of diagonal lines
         :return number: the diagonal line-based entropy :math:`ENTR`.
         """
         #  Use resampled distribution of diagonal lines if provided
-        if resampled_dist is None:
-            diagline = self.diagline_dist()
-        else:
-            diagline = resampled_dist
+        diagline = (self.diagline_dist() if resampled_dist is None
+                    else resampled_dist)
 
         #  Creates a reduced array of the values (not 0) of the diagonal line
         #  length (langer than l_min)
-        diagline = diagline[l_min:]
+        diagline = diagline[l_min-1:]
         diagline = np.extract(diagline != 0, diagline)
 
         #  Normalized array of the number of all diagonal lines = probability
         #  of diagonal line length
         diagnorm = diagline / float(diagline.sum() + self._epsilon)
 
         return -(diagnorm * np.log(diagnorm)).sum()
 
     #
     #  RQA measures based on black vertical lines
     #
 
+    @Cached.method(attrs=(
+        "metric", "threshold", "missing_values", "sparse_rqa"))
     def vertline_dist(self):
         """
         Return the :index:`frequency distribution of vertical line lengths
-        <triple: frequency distribution; vertical; line length>` :math:`P(v)`.
+        <triple: frequency distribution; vertical; line length>`
+        :math:`P(v-1)`.
 
-        The :math:`v` th entry of :math:`P(v)` contains the number of
+        Note that entry :math:`P(v-1)` contains the number of
         :index:`vertical lines <pair: vertical; lines>` of length :math:`v`.
+        Thus, :math:`P(0)` counts lines of length :math:`1`,
+        :math:`P(1)` counts lines of length :math:`2`, asf.
 
         :rtype: 1D array (int32)
         :return: the frequency distribution of vertical line lengths
-            :math:`P(v)`.
+            :math:`P(v-1)`.
         """
-        if self._vertline_dist_cached:
-            return self._vertline_dist
+        #  Prepare
+        n_time = self.N
+        vertline = np.zeros(n_time, dtype=NODE)
+
+        if not self.sparse_rqa:
+            #  Get recurrence matrix
+            recmat = self.recurrence_matrix()
+
+            if self.missing_values:
+                mv_indices = self.missing_value_indices
+                _vertline_dist_missingvalues(
+                    n_time, vertline, recmat, mv_indices)
+            else:
+                _vertline_dist(n_time, vertline, recmat)
+
+        #  Calculations for sequential RQA
+        elif self.metric == "supremum" and self.threshold is not None:
+            #  Get embedding
+            embedding = self.embedding
+            #  Get time series dimension
+            dim = embedding.shape[1]
+            #  Get threshold
+            eps = float(self.threshold)
+
+            if self.missing_values:
+                mv_indices = self.missing_value_indices
+                _vertline_dist_sequential_missingvalues(
+                    n_time, vertline, mv_indices, embedding, eps, dim)
+
+            else:
+                _vertline_dist_sequential(
+                    n_time, vertline, embedding, eps, dim)
+
         else:
-            #  Prepare
-            n_time = self.N
-            vertline = np.zeros(n_time, dtype="int32")
-
-            if not self.sparse_rqa:
-                #  Get recurrence matrix
-                recmat = self.recurrence_matrix()
-
-                if self.missing_values:
-                    mv_indices = self.missing_value_indices
-                    _vertline_dist_norqa_missingvalues(n_time, vertline,
-                                                       recmat, mv_indices)
-
-                else:
-                    _vertline_dist_norqa(n_time, vertline, recmat)
-
-            #  Calculations for sequential RQA
-            elif self.sparse_rqa and self.metric == "supremum":
-                #  Get embedding
-                embedding = self.embedding
-                #  Get time series dimension
-                dim = embedding.shape[1]
-                #  Get threshold
-                eps = float(self.threshold)
-
-                if self.missing_values:
-                    mv_indices = self.missing_value_indices
-                    _vertline_dist_rqa_missingvalues(n_time, vertline,
-                                                     mv_indices, embedding,
-                                                     eps, dim)
-
-                else:
-                    _vertline_dist_rqa(n_time, vertline, embedding, eps, dim)
-
-            #  Function covers the whole recurrence matrix
-            self._vertline_dist = vertline
-            self._vertline_dist_cached = True
+            raise NotImplementedError(
+                "Sequential RQA is currently only available for "
+                "fixed threshold and the supremum metric.")
 
-            return self._vertline_dist
+        #  Function covers the whole recurrence matrix
+        return vertline
 
     def resample_vertline_dist(self, M):
         """
         Return resampled frequency distribution of vertical lines.
 
         The resampled frequency distribution can be used for obtaining
         confidence bounds on vertical line based RQA measures. This is
@@ -1138,39 +1143,34 @@
         #  Get original distribution of vertical lines
         vertline = self.vertline_dist()
 
         #  Get maximal vertical line length
         L_max = self.max_vertlength()
 
         #  Get resampled distribution
-        resampled_dist = np.zeros(len(vertline))
-        resampled_dist[:L_max + 1] = RecurrencePlot.\
-            rejection_sampling(vertline[:L_max + 1], M)
+        if L_max == 0:
+            resampled_dist = vertline
+        else:
+            resampled_dist = np.zeros(len(vertline), dtype=NODE)
+            resampled_dist[:L_max] = RecurrencePlot.\
+                rejection_sampling(vertline[:L_max], M)
 
         return resampled_dist
 
     def max_vertlength(self):
         """
         Return vertical line-based RQA measure :index:`maximal vertical line
         length <triple: maximum; vertical; line length>` :math:`V_max`.
 
         :math:`V_max` is defined as the maximal length of a vertical line of
         the recurrence matrix.
 
         :return number: the maximal vertical line length :math:`V_max`.
         """
-        vertline = self.vertline_dist()
-        n_time = self.N
-        vmax = 1
-
-        for i in range(1, n_time):
-            if vertline[i] != 0:
-                vmax = i
-
-        return vmax
+        return 1 + np.nonzero(self.vertline_dist())[0].max(initial=-1)
 
     def laminarity(self, v_min=2, resampled_dist=None):
         """
         Return vertical line-based RQA measure :index:`laminarity` :math:`LAM`.
 
         :math:`LAM` is defined as the ratio of recurrence points that form
         vertical structures (of at least length :math:`v_min`) to all
@@ -1178,27 +1178,24 @@
 
         :arg number v_min: The minimal vertical line length.
         :type resampled_dist: 1D array (integer)
         :arg resampled_dist: resampled frequency distribution of vertical lines
         :return number: the laminarity :math:`LAM`.
         """
         #  Use resampled distribution of vertical lines if provided
-        if resampled_dist is None:
-            vertline = self.vertline_dist()
-        else:
-            vertline = resampled_dist
-
+        vertline = (self.vertline_dist() if resampled_dist is None
+                    else resampled_dist)
         n_time = self.N
 
         #  Number of recurrence points that form vertical structures (of at
         #  least length v_min)
-        partial_sum = (np.arange(v_min, n_time) * vertline[v_min:]).sum()
+        partial_sum = np.arange(v_min, n_time+1) @ vertline[v_min-1:]
 
         #  Number of all recurrence points that form vertical lines
-        full_sum = (np.arange(n_time) * vertline).sum()
+        full_sum = np.arange(1, n_time+1) @ vertline
 
         return partial_sum / float(full_sum + self._epsilon)
 
     def average_vertlength(self, v_min=2, resampled_dist=None):
         """
         Return vertical line-based RQA measure :index:`average vertical line
         length <triple: average; vertical; line length>` :math:`TT`.
@@ -1209,27 +1206,24 @@
 
         :arg number v_min: The minimal vertical line length.
         :type resampled_dist: 1D array (integer)
         :arg resampled_dist: resampled frequency distribution of vertical lines
         :return number: the trapping time :math:`TT`.
         """
         #  Use resampled distribution of vertical lines if provided
-        if resampled_dist is None:
-            vertline = self.vertline_dist()
-        else:
-            vertline = resampled_dist
-
+        vertline = (self.vertline_dist() if resampled_dist is None
+                    else resampled_dist)
         n_time = self.N
 
         #  Number of recurrence points that form vertical structures (of at
         #  least length v_min)
-        partial_sum = (np.arange(v_min, n_time) * vertline[v_min:]).sum()
+        partial_sum = np.arange(v_min, n_time+1) @ vertline[v_min-1:]
 
         #  Total number of vertical lines of at least length v_min
-        number_vertline = vertline[v_min:].sum()
+        number_vertline = vertline[v_min-1:].sum()
 
         return partial_sum / (float(number_vertline) + self._epsilon)
 
     def trapping_time(self, v_min=2, resampled_dist=None):
         """
         Alias for :meth:`average_vertlength` (see description there).
         """
@@ -1253,15 +1247,15 @@
         if resampled_dist is None:
             vertline = self.vertline_dist()
         else:
             vertline = resampled_dist
 
         #  Creates a reduced array of the values (not 0) of the vertical line
         #  length (langer than v_min)
-        vertline = vertline[v_min:]
+        vertline = vertline[v_min-1:]
         vertline = np.extract(vertline != 0, vertline)
 
         #  Normalized array of the number of all vertical lines = probability
         #  of vertical line length
         vertline_normed = vertline / float(vertline.sum() + self._epsilon)
 
         return -(vertline_normed * np.log(vertline_normed)).sum()
@@ -1270,31 +1264,31 @@
     #  RQA measures based on white vertical lines
     #
 
     def white_vertline_dist(self):
         """
         Return the :index:`frequency distribution of white vertical line
         lengths <triple: frequency distribution; white vertical; line length>`
-        :math:`P(w)`.
+        :math:`P(w-1)`.
 
-        The :math:`w` th entry of :math:`P(w)` contains the number of
+        Note that entry :math:`P(w-1)` contains the number of
         :index:`white vertical lines <pair: white vertical; lines>` of length
-        :math:`w`.
+        :math:`w`. Thus, :math:`P(0)` counts lines of length :math:`1`,
+        :math:`P(1)` counts lines of length :math:`2`, asf.
 
         The length of a white vertical line in a recurrence plot corresponds to
         the time the system takes to return close to an earlier state.
 
         :rtype: 1D array (int32)
         :return: the frequency distribution of white vertical line lengths
-            :math:`P(w)`.
+            :math:`P(w-1)`.
         """
         R = self.recurrence_matrix()
         n_time = self.N
-        white_vertline = np.zeros(n_time, dtype="int32")
-
+        white_vertline = np.zeros(n_time, dtype=NODE)
         _white_vertline_dist(n_time, white_vertline, R)
 
         #  Function covers the whole recurrence matrix
         return white_vertline
 
     def max_white_vertlength(self):
         """
@@ -1303,23 +1297,15 @@
 
         It is defined as the maximal length of a white vertical line of
         the recurrence matrix and corresponds to the maximum recurrence time
         occuring in the time series.
 
         :return number: the maximal white vertical line length.
         """
-        white_vertline = self.white_vertline_dist()
-        N = self.N
-        vmax = 1
-
-        for i in range(1, N):
-            if white_vertline[i] != 0:
-                vmax = i
-
-        return vmax
+        return 1 + np.nonzero(self.white_vertline_dist())[0].max(initial=-1)
 
     def average_white_vertlength(self, w_min=1):
         """
         Return white vertical line-based RQA measure :index:`average white
         vertical line length <triple: average; white vertical; line length>`.
 
         It is defined as the average white vertical line length (of at least
@@ -1331,18 +1317,18 @@
         :return number: the mean recurrence time.
         """
         white_vertline = self.white_vertline_dist()
         n_time = self.N
 
         #  Number of recurrence points that form white vertical structures
         #  (of at least length w_min)
-        partial_sum = (np.arange(w_min, n_time) * white_vertline[w_min:]).sum()
+        partial_sum = np.arange(w_min, n_time+1) @ white_vertline[w_min-1:]
 
         #  Total number of white vertical lines of at least length v_min
-        number_white_vertline = white_vertline[w_min:].sum()
+        number_white_vertline = white_vertline[w_min-1:].sum()
 
         return partial_sum / float(number_white_vertline + self._epsilon)
 
     def mean_recurrence_time(self, w_min=1):
         """
         Alias for :meth:`average_white_vertlength` (see description there).
         """
@@ -1359,15 +1345,15 @@
 
         :arg int w_min: Minimal white vertical line length (recurrence time).
         :return number: the white vertical line-based entropy.
         """
         #  Creates a reduced array of the values (not 0) of the vertical line
         #  length (langer than v_min)
         white_vertline = self.white_vertline_dist()
-        white_vertline = white_vertline[w_min:]
+        white_vertline = white_vertline[w_min-1:]
         white_vertline = np.extract(white_vertline != 0, white_vertline)
 
         #  Normalized array of the number of all vertical lines = probability
         #  of vertical line length
         white_vertline_normed = white_vertline / float(
             white_vertline.sum() + self._epsilon)
 
@@ -1435,16 +1421,10 @@
         if self.silence_level <= 1:
             print("Generating twin surrogates...")
 
         #  Collect
         N = self.N
         embedding = self.embedding
         dim = embedding.shape[1]
-
         twins = self.twins(min_dist)
 
-        #  Initialize
-        surrogates = np.empty((n_surrogates, N, dim))
-
-        _twin_surrogates(n_surrogates, N, dim, twins, embedding,
-                         surrogates)
-        return surrogates
+        return _twin_surrogates_r(n_surrogates, N, dim, twins, embedding)
```

### Comparing `pyunicorn-0.6.1/pyunicorn/utils/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/funcnet/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,33 +1,25 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
-utils
-=====
-
-
-To do
-~~~~~
-  - ...
+funcnet
+=======
 
-Known Bugs
-~~~~~~~~~~
-  - ...
+Related Publications
+~~~~~~~~~~~~~~~~~~~~
 
 """
 
-__all__ = ['mpi', 'navigator']
+from .coupling_analysis import CouplingAnalysis
+from .coupling_analysis_pure_python import CouplingAnalysisPurePython
```

### Comparing `pyunicorn-0.6.1/pyunicorn/utils/navigator.py` & `pyunicorn-0.7.0/src/pyunicorn/utils/navigator.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -285,20 +282,20 @@
         del fac
         uc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
         lc = "abcdefghijklmnopqrstuvwxyz"
         labelparts = [[uc[i] for i in range(23)]
                       + ["X"+uc[i] for i in range(26)]
                       + ["Y"+uc[i] for i in range(26)]
                       + ["Z"+uc[i] for i in range(26)],
-                      xrange(1, 100),
+                      range(1, 100),
                       [lc[i] for i in range(23)]
                       + ["x"+lc[i] for i in range(26)]
                       + ["y"+lc[i] for i in range(26)]
                       + ["z"+lc[i] for i in range(26)],
-                      xrange(1, 100),
+                      range(1, 100),
                       [lc[i] for i in range(23)]
                       + ["x"+lc[i] for i in range(26)]
                       + ["y"+lc[i] for i in range(26)]
                       + ["z"+lc[i] for i in range(26)]]
         labelnullpart = "~~~~~"
         if self.autolabels:
             self.label = [str(S-i) for i in range(S)]
@@ -345,17 +342,18 @@
         self.boundary = [[] for i in range(S)]
         self.shape = [[] for i in range(S)]
         self.fullshape = [[] for i in range(S)]
         self.representative = [None for i in range(S)]
         if self.is_geo:
             for i in range(S):
                 if self.label != str(S-i):
-                    self.boundary[i], self.shape[i], self.fullshape[i],\
-                        self.representative[i] = \
-                        self.network.get_boundary(self.nodes[i], gap=0.1)
+                    (
+                        self.boundary[i], self.shape[i], self.fullshape[i],
+                        self.representative[i]
+                    ) = self.network.get_boundary(self.nodes[i], gap=0.1)
                     self.representative[i].append((0, 0))
                     self.lat[i], self.lon[i] = self.representative[i][0]
         if self.map:
             for i in range(self.S):
                 self.position[i, 0], self.position[i, 1] = \
                     self.bm(self.lon[i], self.lat[i])
             #  radius of (shown) supernodes
@@ -418,45 +416,44 @@
         if filename is not None:
             # fig.savefig(filename, bbox_inches=mpl.transforms.Bbox(
             #     [[0.02, 1.05], [8.12, 5.09]]))
             fig.savefig(filename, bbox_inches=mpl.transforms.Bbox(
                 [[0.02, 1.0], [7.99, 5.0]]))
         return fig
 
-    def write_kml(self,
-                  path="climate-network-analysis",
-                  pathurl=
-                  "http://localhost/~heitzig-j/climate-network-analysis",
-                  title="Climate Network Analysis",
-                  measures=None,
-                  stats=None
-                  ):
+    def write_kml(
+      self,
+      path="climate-network-analysis",
+      pathurl="http://localhost/~heitzig-j/climate-network-analysis",
+      title="Climate Network Analysis",
+      measures=None,
+      stats=None):
         # TODO: kmz, betweenness correctly, i.png, zip, doublettes
-        f = file(path+"/open-this-in-googleearth.kml", "w")
+        f = open(path+"/open-this-in-googleearth.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
   <NetworkLink>
     <name>&lt;i&gt;&lt;b&gt;"""+title+"""&lt;/b&gt;&lt;/i&gt;</name>
     <Snippet maxLines="1">(please expand folders as needed)</Snippet>
     <open>1</open>
     <Link>
 <!--
-*********************************************************************************
-** if you unzipped the archive into your own (local) webserver,                **
-** change the following to point to the file doc.kml inside it,                **
-** for example:                                                                **
-**    <href>http://localhost/~username/climate-network-analysis/doc.kml</href> **
-*********************************************************************************
+*******************************************************************************
+** if you unzipped the archive into your own (local) webserver,              **
+** change the following to point to the file doc.kml inside it,              **
+** for example:                                                              **
+**  <href>http://localhost/~username/climate-network-analysis/doc.kml</href> **
+*******************************************************************************
 -->
       <href>"""+pathurl+"""/doc.kml</href>
     </Link>
   </NetworkLink>
 </kml>""")
         f.close()
-        f = file(path+"/standard.kml", "w")
+        f = open(path+"/standard.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>doc.kml</targetHref>
     <Change>
       <Folder targetId="resolution"><visibility>1</visibility></Folder>
@@ -466,45 +463,48 @@
       <Folder targetId="links"><visibility>1</visibility></Folder>
       <Folder targetId="labels"><visibility>1</visibility></Folder>
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/no-standard.kml", "w")
+        f = open(path+"/no-standard.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>doc.kml</targetHref>
     <Change>
       <Folder targetId="standard"><visibility>0</visibility></Folder>
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         # TODO: tour
-        f = file(path+"/doc.kml", "w")
+        f = open(path+"/doc.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
-<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">
+<kml xmlns="http://www.opengis.net/kml/2.2" """
+                """xmlns:gx="http://www.google.com/kml/ext/2.2">
   <Document>
     <Style id="check">
       <ListStyle><listItemType>check</listItemType></ListStyle>
     </Style>
     <Style id="radio">
       <ListStyle><listItemType>radioFolder</listItemType></ListStyle>
     </Style>
     <Style id="hide">
-      <ListStyle><listItemType>checkHideChildren</listItemType><ItemIcon/></ListStyle>
+      <ListStyle><listItemType>checkHideChildren</listItemType><ItemIcon/>"""
+                """</ListStyle>
     </Style>
     <Style id="noicon">
       <ListStyle><ItemIcon/></ListStyle>
     </Style>
     <!--<gx:Tour id="intro">
-      <name>&lt;a href=&quot;#intro;flyto&quot;&gt;Introductory tour&lt;/a&gt;</name>
+      <name>&lt;a href=&quot;#intro;flyto&quot;&gt;Introductory tour&lt;"""
+                """/a&gt;</name>
       <gx:Playlist>
         <gx:AnimatedUpdate>
           <Update>
           </Update>
         </gx:AnimatedUpdate>
       </gx:Playlist>
     </gx:Tour>-->
@@ -519,57 +519,64 @@
       <Folder>
         <name>Hierarchy of regions (with slider)...</name>
         <visibility>0</visibility><styleUrl>#radio</styleUrl>
         <Folder>
           <name>&lt;i&gt;show regions only&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#hide</styleUrl>
           <NetworkLink><Link><href>links-off.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>hierarchy-regions.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>hierarchy-regions.kml</href></Link>"""
+                """</NetworkLink>
         </Folder>
         <Folder>
           <name>&lt;i&gt;regions and links&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#hide</styleUrl>
           <NetworkLink><Link><href>no-standard.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>hierarchy-regions.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>hierarchy-links.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>hierarchy-regions.kml</href></Link>"""
+                """</NetworkLink>
+          <NetworkLink><Link><href>hierarchy-links.kml</href></Link>"""
+                """</NetworkLink>
         </Folder>
         <Folder>
           <name>&lt;i&gt;links only&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#hide</styleUrl>
           <NetworkLink><Link><href>no-standard.kml</href></Link></NetworkLink>
           <NetworkLink><Link><href>regions-off.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>hierarchy-links.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>hierarchy-links.kml</href></Link>"""
+                """</NetworkLink>
         </Folder>
       </Folder>""")
-        for level in range(len(self.solutions)):
-            l = self.solutions[level]
+        for s in self.solutions:
             f.write("""
       <Folder>
-        <name>Partition into """+str(l)+""" regions...</name>
+        <name>Partition into """+str(s)+""" regions...</name>
         <visibility>0</visibility><styleUrl>#radio</styleUrl>
         <Folder>
           <name>&lt;i&gt;show regions only&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#hide</styleUrl>
           <NetworkLink><Link><href>no-standard.kml</href></Link></NetworkLink>
           <NetworkLink><Link><href>links-off.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>partition"""+str(l)+"""-regions.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>partition"""+str(s)
+                    + """-regions.kml</href></Link></NetworkLink>
         </Folder>
         <Folder>
           <name>&lt;i&gt;regions and links&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#hide</styleUrl>
           <NetworkLink><Link><href>no-standard.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>partition"""+str(l)+"""-regions.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>partition"""+str(l)+"""-links.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>partition"""+str(s)
+                    + """-regions.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>partition"""+str(s)
+                    + """-links.kml</href></Link></NetworkLink>
         </Folder>
         <Folder>
           <name>&lt;i&gt;links only&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#hide</styleUrl>
           <NetworkLink><Link><href>no-standard.kml</href></Link></NetworkLink>
           <NetworkLink><Link><href>regions-off.kml</href></Link></NetworkLink>
-          <NetworkLink><Link><href>partition"""+str(l)+"""-links.kml</href></Link></NetworkLink>
+          <NetworkLink><Link><href>partition"""+str(s)
+                    + """-links.kml</href></Link></NetworkLink>
         </Folder>
       </Folder>""")
         f.write("""
     </Folder>
     <Folder id="overlays">
       <name>&lt;b&gt;Color-coded maps:&lt;/b&gt;</name>
       <open>1</open><visibility>0</visibility><styleUrl>#radio</styleUrl>""")
@@ -584,18 +591,24 @@
                 f.write("""
         <GroundOverlay>
           <name>&lt;i&gt;"""+measures[i][0]+"""&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#noicon</styleUrl>
           <drawOrder>1</drawOrder>
           <Icon><href>measure"""+str(i)+""".png</href></Icon>
           <Region>
-            <LatLonAltBox><north>90</north><south>-90</south><east>180.1</east><west>-180.1</west><minAltitude>0</minAltitude><maxAltitude>0</maxAltitude></LatLonAltBox>
-            <Lod><minLodPixels>5</minLodPixels><maxLodPixels>12000</maxLodPixels><minFadeExtent>5</minFadeExtent><maxFadeExtent>11000</maxFadeExtent></Lod>
+            <LatLonAltBox><north>90</north><south>-90</south><east>180.1"""
+                        """</east><west>-180.1</west><minAltitude>0"""
+                        """</minAltitude><maxAltitude>0</maxAltitude>"""
+                        """</LatLonAltBox>
+            <Lod><minLodPixels>5</minLodPixels><maxLodPixels>12000"""
+                        """</maxLodPixels><minFadeExtent>5</minFadeExtent>"""
+                        """<maxFadeExtent>11000</maxFadeExtent></Lod>
           </Region>
-          <LatLonBox><north>90</north><south>-90</south><east>-180.1</east><west>180.1</west></LatLonBox>
+          <LatLonBox><north>90</north><south>-90</south><east>-180.1</east>"""
+                        """<west>180.1</west></LatLonBox>
         </GroundOverlay>""")
             f.write("""
       </Folder>""")
         if stats is not None and len(stats) > 0:
             f.write("""
       <Folder>
         <name>Underlying data...</name>
@@ -604,33 +617,40 @@
                 f.write("""
         <GroundOverlay>
           <name>&lt;i&gt;l"""+stats[i][0]+"""&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#noicon</styleUrl>
           <drawOrder>1</drawOrder>
           <Icon><href>stat"""+str(0)+""".png</href></Icon>
           <Region>
-            <LatLonAltBox><north>90</north><south>-90</south><east>180.1</east><west>-180.1</west><minAltitude>0</minAltitude><maxAltitude>0</maxAltitude></LatLonAltBox>
-            <Lod><minLodPixels>5</minLodPixels><maxLodPixels>12000</maxLodPixels><minFadeExtent>5</minFadeExtent><maxFadeExtent>11000</maxFadeExtent></Lod>
+            <LatLonAltBox><north>90</north><south>-90</south><east>180.1"""
+                        """</east><west>-180.1</west><minAltitude>0"""
+                        """</minAltitude><maxAltitude>0</maxAltitude>"""
+                        """</LatLonAltBox>
+            <Lod><minLodPixels>5</minLodPixels><maxLodPixels>12000"""
+                        """</maxLodPixels><minFadeExtent>5</minFadeExtent>"""
+                        """<maxFadeExtent>11000</maxFadeExtent></Lod>
           </Region>
-          <LatLonBox><north>90</north><south>-90</south><east>-180</east><west>180</west></LatLonBox>
+          <LatLonBox><north>90</north><south>-90</south><east>-180</east>"""
+                        """<west>180</west></LatLonBox>
         </GroundOverlay>""")
             f.write("""
       </Folder>""")
         f.write("""
     </Folder>
     <Folder id="options">
       <name>&lt;b&gt;Options:&lt;/b&gt;</name>
       <open>1</open><visibility>0</visibility>
       <Folder id="nodes">
         <name>Node bullets...</name>
         <visibility>0</visibility><styleUrl>#radio</styleUrl>""")
         if self.B0 is not None:
             f.write("""
         <NetworkLink>
-          <name>&lt;i&gt;colored by centrality and betweenness&lt;/i&gt;</name>
+          <name>&lt;i&gt;colored by centrality and betweenness&lt;/i&gt;"""
+                    """</name>
           <visibility>0</visibility><styleUrl>#noicon</styleUrl>
           <Link><href>nodes-betweenness.kml</href></Link>
         </NetworkLink>
         <NetworkLink>
           <name>&lt;i&gt;yellow&lt;/i&gt;</name>
           <visibility>0</visibility><styleUrl>#noicon</styleUrl>""")
         else:
@@ -697,34 +717,35 @@
           <visibility>0</visibility><styleUrl>#noicon</styleUrl>
           <Link><href>labels-off.kml</href></Link>
         </NetworkLink>
       </Folder>
     </Folder>
     <NetworkLink>
       <name>&lt;small&gt;(don't deselect this)&lt;/small&gt;</name>
-      <open>0</open><visibility>1</visibility><refreshVisibility>0</refreshVisibility><styleUrl>#hide</styleUrl>
+      <open>0</open><visibility>1</visibility><refreshVisibility>0"""
+                """</refreshVisibility><styleUrl>#hide</styleUrl>
       <Link><href>data.kmz</href></Link>
     </NetworkLink>
   </Document>
 </kml>""")
         f.close()
-        f = file(path+"/regions-off.kml", "w")
+        f = open(path+"/regions-off.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>
       <Style targetId="a"><PolyStyle><outline>0</outline></PolyStyle></Style>
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/links-off.kml", "w")
+        f = open(path+"/links-off.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>
       <Folder targetId="links"><visibility>0</visibility></Folder>
@@ -749,69 +770,74 @@
                 if j < i < self.parent[j] and self.linked_weight[i, j] > 0:
                     links.append((i, j))
 
         if self.B0 is not None:
             bmax = np.log(0.0001+max(self.B[self.regions]))
             bmin = np.log(0.0001+min(self.B[self.regions]))
             ccmax = max(self.CC[self.regions])
-            f = file(path+"/nodes-betweenness.kml", "w")
+            f = open(path+"/nodes-betweenness.kml", "w")
             f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
             for i in self.regions:
                 b = int((np.log(0.0001+self.B[i])-bmin)/(bmax-bmin)*512)
                 if b < 256:
                     c = hex(511-b)[-2:] + "ffff"
                 else:
                     c = "00" + hex(767-b)[-2:] + "ff"
                 a = hex(256+int(self.CC[i]/ccmax*255))[-2:]
                 f.write("""
-<IconStyle targetId="i"""+str(i)+""""><color>"""+a+c+"""</color><scale>1.5</scale></IconStyle>""")
+<IconStyle targetId="i"""+str(i)+""""><color>"""+a+c
+                        + """</color><scale>1.5</scale></IconStyle>""")
             f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
             f.close()
-        f = file(path+"/nodes-yellow.kml", "w")
+        f = open(path+"/nodes-yellow.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i in self.regions:
             f.write("""
-<IconStyle targetId="i"""+str(i)+""""><color>ff00ffff</color><scale>1.5</scale></IconStyle>""")
+<IconStyle targetId="i"""+str(i)
+                    + """"><color>ff00ffff</color><scale>1.5</scale>"""
+                    """</IconStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/nodes-black.kml", "w")
+        f = open(path+"/nodes-black.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i in self.regions:
             f.write("""
-<IconStyle targetId="i"""+str(i)+""""><color>ff000000</color><scale>1.5</scale></IconStyle>""")
+<IconStyle targetId="i"""+str(i)
+                    + """"><color>ff000000</color><scale>1.5</scale>"""
+                    """</IconStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/nodes-off.kml", "w")
+        f = open(path+"/nodes-off.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i in self.regions:
@@ -832,15 +858,15 @@
             bmax = np.log(0.0001+bmax)
             bmin = np.log(0.0001+bmin)
             if self.D0 is not None:
                 dmax = 0.0
                 for i, j in links:
                     dmax = max(dmax, self.D[i, j])
                 print("DMAX", dmax)
-            f = file(path+"/links-betweenness.kml", "w")
+            f = open(path+"/links-betweenness.kml", "w")
             f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
             for i, j in links:
@@ -853,220 +879,253 @@
                     a = "ff"
                 elif np.isnan(self.D[i, j]):
                     a = "ff"
                     print(i, j, "nan")
                 else:
                     a = hex(511-int((self.D[i, j]-1)/(dmax-1)*255))[-2:]
                 f.write("""
-<LineStyle targetId="a"""+str(i)+"-"+str(j)+""""><color>"""+a+c+"""</color></LineStyle>""")
+<LineStyle targetId="a"""+str(i)+"-"+str(j)+""""><color>"""+a+c
+                        + """</color></LineStyle>""")
             f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
             f.close()
-        f = file(path+"/links-yellow.kml", "w")
+        f = open(path+"/links-yellow.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i, j in links:
             f.write("""
-<LineStyle targetId="a"""+str(i)+"-"+str(j)+""""><color>ff00ffff</color></LineStyle>""")
+<LineStyle targetId="a"""+str(i)+"-"+str(j)
+                    + """"><color>ff00ffff</color></LineStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/links-black.kml", "w")
+        f = open(path+"/links-black.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i, j in links:
             f.write("""
-<LineStyle targetId="a"""+str(i)+"-"+str(j)+""""><color>ff7f0000</color></LineStyle>""")
+<LineStyle targetId="a"""+str(i)+"-"+str(j)
+                    + """"><color>ff7f0000</color></LineStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/labels-large.kml", "w")
+        f = open(path+"/labels-large.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i in self.regions:
             f.write("""
-<Placemark targetId="p"""+str(i)+""""><name>"""+self.label[i]+"""</name></Placemark><LabelStyle targetId="l"""+str(i)+""""><scale>3</scale></LabelStyle>""")
+<Placemark targetId="p"""+str(i)+""""><name>"""+self.label[i]
+                    + """</name></Placemark><LabelStyle targetId="l"""
+                    + str(i)+""""><scale>3</scale></LabelStyle>""")
         for i, j in links:
             f.write("""
-<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><name>"""+self.label[i]+" - "+self.label[j]+"""</name></Placemark><LabelStyle targetId="l"""+str(i)+"-"+str(j)+""""><scale>2</scale></LabelStyle>""")
+<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><name>"""+self.label[i]
+                    + " - "+self.label[j]+"""</name></Placemark><LabelStyle"""
+                    """ targetId="l"""+str(i)+"-"+str(j)
+                    + """"><scale>2</scale></LabelStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/labels-small.kml", "w")
+        f = open(path+"/labels-small.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i in self.regions:
-            l = self.label[i] + \
+            lab = self.label[i] + \
                 (", dg %(k)6.2f, cls %(C)2d, btw %(B)5.2f" % {
                     "k": self.k[i]*510.07,
                     "C": self.C[i]*100,
                     "B": self.B[i]*100}).\
                 replace("  ", " ").replace("  ", " ")
             # TODO: use provided data
             f.write("""
-<Placemark targetId="p"""+str(i)+""""><name>"""+l+"""</name></Placemark><LabelStyle targetId="l"""+str(i)+""""><scale>3</scale></LabelStyle>""")
+<Placemark targetId="p"""+str(i)+""""><name>"""+lab
+                    + """</name></Placemark><LabelStyle targetId="l"""+str(i)
+                    + """"><scale>3</scale></LabelStyle>""")
         for i, j in links:
-            l = self.label[i] + " - " + self.label[j] + \
+            lab = self.label[i] + " - " + self.label[j] + \
                 (", str %(s)5.2f, dst %(l)6.2f, btw %(B)7.4f" % {
                     "s": self.linked_weight[i, j]*510.07**2,
                     "l": self.D[i, j],
                     "B": self.LB[i, j]*100}).\
                 replace("  ", " ").replace("  ", " ")
             # TODO: use provided data
             f.write("""
-<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><name>"""+l+"""</name></Placemark><LabelStyle targetId="l"""+str(i)+"-"+str(j)+""""><scale>2</scale></LabelStyle>""")
+<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><name>"""+lab
+                    + """</name></Placemark><LabelStyle targetId="l"""+str(i)
+                    + "-"+str(j)+""""><scale>2</scale></LabelStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/labels-off.kml", "w")
+        f = open(path+"/labels-off.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i in self.regions:
             f.write("""
-<Placemark targetId="p"""+str(i)+""""><name>"""+self.label[i]+"""</name></Placemark><LabelStyle targetId="l"""+str(i)+""""><scale>0</scale></LabelStyle>""")
+<Placemark targetId="p"""+str(i)+""""><name>"""+self.label[i]
+                    + """</name></Placemark><LabelStyle targetId="l"""+str(i)
+                    + """"><scale>0</scale></LabelStyle>""")
         for i, j in links:
             f.write("""
-<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><name>"""+self.label[i]+" - "+self.label[j]+"""</name></Placemark><LabelStyle targetId="l"""+str(i)+"-"+str(j)+""""><scale>0</scale></LabelStyle>""")
+<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><name>"""+self.label[i]
+                    + " - "+self.label[j]+"""</name></Placemark><LabelStyle """
+                    """targetId="l"""+str(i)+"-"+str(j)
+                    + """"><scale>0</scale></LabelStyle>""")
         f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/hierarchy-regions.kml", "w")
+        f = open(path+"/hierarchy-regions.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>
-      <Style targetId="a"><PolyStyle><outline>1</outline></PolyStyle></Style>""")
+      <Style targetId="a"><PolyStyle><outline>1</outline>"""
+                """</PolyStyle></Style>""")
         for i in self.regions:
             t1 = max(np.min(self.solutions), self.S+1-self.parent[i])
             t2 = min(self.S+1-i, np.max(self.solutions)+1)-1
             f.write("""
-<Placemark targetId="p"""+str(i)+""""><TimeSpan><begin>"""+str(t1)+"""</begin><end>"""+str(t2)+"""-12-31</end></TimeSpan><LookAt><gx:TimeStamp><when>"""+str(t1)+"""</when></gx:TimeStamp></LookAt></Placemark>""")
+<Placemark targetId="p"""+str(i)+""""><TimeSpan><begin>"""+str(t1)
+                    + """</begin><end>"""+str(t2)
+                    + """-12-31</end></TimeSpan><LookAt><gx:TimeStamp><when>"""
+                    + str(t1)
+                    + """</when></gx:TimeStamp></LookAt></Placemark>""")
         f.write("""
       <Folder targetId="regions"><visibility>1</visibility></Folder>
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        f = file(path+"/hierarchy-links.kml", "w")
+        f = open(path+"/hierarchy-links.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
         for i, j in links:
             t1 = max(np.min(self.solutions), self.S+1-self.parent[i],
                      self.S+1-self.parent[j])
             t2 = min(self.S+1-i, self.S+1-j, np.max(self.solutions)+1)-1
             f.write("""
-<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><TimeSpan><begin>"""+str(t1)+"""</begin><end>"""+str(t2)+"""-12-31</end></TimeSpan></Placemark>""")
+<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><TimeSpan><begin>"""+str(t1)
+                    + """</begin><end>"""+str(t2)
+                    + """-12-31</end></TimeSpan></Placemark>""")
         f.write("""
       <Folder targetId="links"><visibility>1</visibility></Folder>
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
         f.close()
-        for level in range(len(self.solutions)):
-            l = self.solutions[level]
-            f = file(path+"/partition"+str(l)+"-regions.kml", "w")
+        for level, s in enumerate(self.solutions):
+            f = open(path+"/partition"+str(s)+"-regions.kml", "w")
             f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>
-      <Style targetId="a"><PolyStyle><outline>1</outline></PolyStyle></Style>""")
+      <Style targetId="a"><PolyStyle><outline>1</outline>"""
+                    """</PolyStyle></Style>""")
             for i in self.solution_nodes[level]:
                 f.write("""
-<Placemark targetId="p"""+str(i)+""""><TimeSpan><begin/><end/></TimeSpan><LookAt><gx:TimeStamp><when/></gx:TimeStamp></LookAt></Placemark>""")
+<Placemark targetId="p"""+str(i)+""""><TimeSpan><begin/><end/></TimeSpan>"""
+                        """<LookAt><gx:TimeStamp><when/></gx:TimeStamp>"""
+                        """</LookAt></Placemark>""")
             f.write("""
       <Folder targetId="regions"><visibility>1</visibility></Folder>
-      <Folder targetId="regions"""+str(l)+""""><visibility>1</visibility></Folder>
+      <Folder targetId="regions"""+str(s)
+                    + """"><visibility>1</visibility></Folder>
       <Folder targetId="regions0"><visibility>0</visibility></Folder>""")
-            for level2 in range(len(self.solutions)):
+            for level2, s2 in enumerate(self.solutions):
                 if level2 != level:
                     f.write("""
-      <Folder targetId="regions"""+str(self.solutions[level2])+""""><visibility>0</visibility></Folder>""")
+      <Folder targetId="regions"""+str(s2)
+                            + """"><visibility>0</visibility></Folder>""")
             f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
             f.close()
-            f = file(path+"/partition"+str(l)+"-links.kml", "w")
+            f = open(path+"/partition"+str(s)+"-links.kml", "w")
             f.write("""<?xml version="1.0" encoding="UTF-8"?>
 <kml xmlns="http://www.opengis.net/kml/2.2">
 <NetworkLinkControl>
   <Update>
     <targetHref>data.kmz</targetHref>
     <Change>""")
             for i in self.solution_nodes[level]:
                 for j in self.solution_nodes[level]:
                     if (i, j) in links:
                         f.write("""
-<Placemark targetId="p"""+str(i)+"-"+str(j)+""""><TimeSpan><begin/><end/></TimeSpan></Placemark>""")
+<Placemark targetId="p"""+str(i)+"-"+str(j)
+                                + """"><TimeSpan><begin/><end/></TimeSpan>"""
+                                """</Placemark>""")
             f.write("""
       <Folder targetId="links"><visibility>1</visibility></Folder>
-      <Folder targetId="links"""+str(l)+""""><visibility>1</visibility></Folder>
+      <Folder targetId="links"""+str(s)
+                    + """"><visibility>1</visibility></Folder>
       <Folder targetId="links0"><visibility>0</visibility></Folder>""")
-            for level2 in range(len(self.solutions)):
+            for level2, s2 in enumerate(self.solutions):
                 if level2 != level:
                     f.write("""
-      <Folder targetId="links"""+str(self.solutions[level2])+""""><visibility>0</visibility></Folder>""")
+      <Folder targetId="links"""+str(s2)
+                            + """"><visibility>0</visibility></Folder>""")
             f.write("""
     </Change>
   </Update>
 </NetworkLinkControl>
 </kml>""")
             f.close()
-        f = file(path+"/data.kml", "w")
+        f = open(path+"/data.kml", "w")
         f.write("""<?xml version="1.0" encoding="UTF-8"?>
-<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">
+<kml xmlns="http://www.opengis.net/kml/2.2" """
+                """xmlns:gx="http://www.google.com/kml/ext/2.2">
  <Document>
   <Folder><visibility>1</visibility></Folder>
   <Style id="a"><!-- common to regions -->
     <PolyStyle>
       <fill>0</fill><outline>1</outline>
     </PolyStyle>
     <BalloonStyle>
@@ -1074,16 +1133,19 @@
         <b>$[l]</b><br/>
         <table>
           <tr><td>Area</td><td>$[a]&nbsp;Mm²</td></tr>
           <tr><td>Ave. degree measure</td><td>$[k]&nbsp;Mm²</td></tr>
           <tr><td>Ave. clustering measure</td><td nowrap>$[C] %</td></tr>
           <tr><td>Ave. centrality measure</td><td nowrap>$[CC] %</td></tr>
           <tr><td>Ave. betweenness measure</td><td nowrap>$[B] %</td></tr>
-          <tr><td>contained in region</td><td><a href="#p$[p];balloonFlyto">$[pl]</a></td></tr>
-          <tr><td>largest contained subregions</td><td><a href="#p$[n1];balloonFlyto">$[l1]</a>, <a href="#p$[n2];balloonFlyto">$[l2]</a></td></tr>
+          <tr><td>contained in region</td><td><a href="#p$[p];balloonFlyto">"""
+                """$[pl]</a></td></tr>
+          <tr><td>largest contained subregions</td><td><a href="#p$[n1];"""
+                """balloonFlyto">$[l1]</a>, <a href="#p$[n2];balloonFlyto">"""
+                """$[l2]</a></td></tr>
         </table>
       ]]></text>
     </BalloonStyle>
   </Style>
   <Style id="b"><!-- highlit regions -->
     <PolyStyle>
       <fill>0</fill><outline>1</outline>
@@ -1102,29 +1164,34 @@
         <b>$[l]</b><br/>
         <table>
           <tr><td>Area</td><td>$[a]&nbsp;Mm²</td></tr>
           <tr><td>Ave. degree measure</td><td>$[k]&nbsp;Mm²</td></tr>
           <tr><td>Ave. clustering measure</td><td nowrap>$[C] %</td></tr>
           <tr><td>Ave. centrality measure</td><td nowrap>$[CC] %</td></tr>
           <tr><td>Ave. betweenness measure</td><td nowrap>$[B] %</td></tr>
-          <tr><td>contained in region</td><td><a href="#p$[p];balloonFlyto">$[pl]</a></td></tr>
-          <tr><td>largest contained subregions</td><td><a href="#p$[n1];balloonFlyto">$[l1]</a>, <a href="#p$[n2];balloonFlyto">$[l2]</a></td></tr>
+          <tr><td>contained in region</td><td><a href="#p$[p];balloonFlyto">"""
+                """$[pl]</a></td></tr>
+          <tr><td>largest contained subregions</td><td><a href="#p$[n1];"""
+                """balloonFlyto">$[l1]</a>, <a href="#p$[n2];balloonFlyto">"""
+                """$[l2]</a></td></tr>
         </table>
       ]]></text>
     </BalloonStyle>
   </Style>
   <Style id="e"><!-- arcs -->
     <IconStyle>
       <color>00000000</color>
     </IconStyle>
     <BalloonStyle>
       <text><![CDATA[
-        <b><a href="#p$[n1];balloonFlyto">$[l1]</a> - <a href="#p$[n2];balloonFlyto">$[l2]</a></b><br/>
+        <b><a href="#p$[n1];balloonFlyto">$[l1]</a> - <a href="#p$[n2];"""
+                """balloonFlyto">$[l2]</a></b><br/>
         <table>
-          <tr><td>Strength (total product of linked area)</td><td nowrap>$[w] (Mm²)²</td></tr>
+          <tr><td>Strength (total product of linked area)</td><td nowrap>"""
+                """$[w] (Mm²)²</td></tr>
           <tr><td>Relative strength</td><td nowrap>$[r] %</td></tr>
           <tr><td>Ave. network distance</td><td nowrap>$[l] steps</td></tr>
           <tr><td>Ave. link betweenness measure</td><td nowrap>$[B] %</td></tr>
         </table>
       ]]></text>
     </BalloonStyle>
   </Style>
@@ -1136,32 +1203,33 @@
       <color>ff3f3fff</color><scale>2.5</scale>
     </LabelStyle>
     <IconStyle>
       <color>00000000</color>
     </IconStyle>
     <BalloonStyle>
       <text><![CDATA[
-        <b><a href="#p$[n1];balloonFlyto">$[l1]</a> - <a href="#p$[n2];balloonFlyto">$[l2]</a></b><br/>
+        <b><a href="#p$[n1];balloonFlyto">$[l1]</a> - <a href="#p$[n2];"""
+                """balloonFlyto">$[l2]</a></b><br/>
         <table>
-          <tr><td>Strength (total product of linked area)</td><td nowrap>$[w] (Mm²)²</td></tr>
+          <tr><td>Strength (total product of linked area)</td><td nowrap>"""
+                """$[w] (Mm²)²</td></tr>
           <tr><td>Relative strength</td><td nowrap>$[r] %</td></tr>
           <tr><td>Ave. network distance</td><td nowrap>$[l] steps</td></tr>
           <tr><td>Ave. link betweenness measure</td><td nowrap>$[B] %</td></tr>
         </table>
       ]]></text>
     </BalloonStyle>
   </Style>
   <Folder id="regions">
     <visibility>0</visibility>""")
         intermediate = set(self.regions)
         intermediate_links = set(links)
-        for level in range(len(self.solutions)):
-            l = self.solutions[level]
+        for leve, s in enumerate(self.solutions):
             f.write("""
-    <Folder id="regions"""+str(l)+"""">""")
+    <Folder id="regions"""+str(s)+"""">""")
             sn = set(self.solution_nodes[level])
             for i in sn.intersection(intermediate):
                 self._write_kml_region(f, i)
             intermediate -= sn
             f.write("""
     </Folder>""")
         f.write("""
@@ -1172,18 +1240,17 @@
     </Folder>
   </Folder>
   <Folder id="links">
     <visibility>0</visibility>""")
         limax = -np.inf
         for i, j in links:
             limax = max(limax, self.linked_weight[i, j])
-        for level in range(len(self.solutions)):
-            l = self.solutions[level]
+        for level, s in enumerate(self.solutions):
             f.write("""
-    <Folder id="links"""+str(l)+"""">""")
+    <Folder id="links"""+str(s)+"""">""")
             for i in self.solution_nodes[level]:
                 for j in self.solution_nodes[level]:
                     if (i, j) in intermediate_links:
                         intermediate_links.remove((i, j))
                         self._write_kml_link(f, i, j,
                                              self.linked_weight[i, j]/limax)
             f.write("""
@@ -1242,30 +1309,37 @@
 """+c1+"""
 </value></Data><Data name="l1"><value>
 """+l1+"""
 </value></Data><Data name="n2"><value>
 """+c2+"""
 </value></Data><Data name="l2"><value>
 """+l2+"""
-</value></Data></ExtendedData><TimeSpan/><LookAt><gx:TimeStamp><when/></gx:TimeStamp><longitude>
+</value></Data></ExtendedData><TimeSpan/><LookAt><gx:TimeStamp><when/>"""
+                """</gx:TimeStamp><longitude>
 """+str(self.lon[i])+"""
 </longitude><latitude>
 """+str(self.lat[i])+"""
-</latitude><range>12000000</range></LookAt><styleUrl>#a</styleUrl><StyleMap><Pair><key>normal</key><Style><IconStyle id="i"""+str(i)+""""><color/>
-<scale>1</scale><Icon><href>i.png</href></Icon></IconStyle><LabelStyle id="l"""+str(i)+""""><color>
+</latitude><range>12000000</range></LookAt><styleUrl>#a</styleUrl><StyleMap>"""
+                """<Pair><key>normal</key><Style><IconStyle id="i"""+str(i)
+                + """"><color/>
+<scale>1</scale><Icon><href>i.png</href></Icon></IconStyle><LabelStyle id="l"""
+                + str(i)+""""><color>
 ff"""+self.color[i][1:7]+"""
 </color><scale>0</scale></LabelStyle><LineStyle><color>
 ff"""+self.color[i][1:7]+"""
-</color><width>6</width></LineStyle></Style></Pair><Pair><key>highlight</key><styleUrl>#b</styleUrl></Pair></StyleMap><MultiGeometry><Point><coordinates>
+</color><width>6</width></LineStyle></Style></Pair><Pair><key>highlight"""
+                """</key><styleUrl>#b</styleUrl></Pair></StyleMap>"""
+                """<MultiGeometry><Point><coordinates>
 """+str(self.lon[i])+","+str(self.lat[i])+"""
 </coordinates></Point>""")
         if self.shape[i] is not None:
             for sh in self.shape[i]:
                 f.write("""
-<Polygon><tessellate>1</tessellate><outerBoundaryIs><LinearRing><coordinates>""")
+<Polygon><tessellate>1</tessellate><outerBoundaryIs>"""
+                        """<LinearRing><coordinates>""")
                 for la, lo in sh:
                     f.write("\n"+str(round(100*lo)/100) +
                             "," + str(round(100*la)/100))
                 f.write("""
 </coordinates></LinearRing></outerBoundaryIs></Polygon>""")
         f.write("""
 </MultiGeometry></Placemark>""")
@@ -1290,15 +1364,16 @@
             d = ""
         lb = self.LB[i, j]
         if lb > 0:
             lb = str(round(1000000*lb)/10000)
         else:
             lb = ""
         f.write("""
-<Placemark id="p"""+str(i)+"-"+str(j)+""""><name/><ExtendedData><Data name="w"><value>
+<Placemark id="p"""+str(i)+"-"+str(j)
+                + """"><name/><ExtendedData><Data name="w"><value>
 """+str(round(self.linked_weight[i, j]*510.07**2*100)/100)+"""
 </value></Data><Data name="r"><value>
 """+str(round(self.linked_proportion[i, j]*10000)/100)+"""
 </value></Data><Data name="l"><value>
 """+d+"""
 </value></Data><Data name="B"><value>
 """+lb+"""
@@ -1306,19 +1381,26 @@
 """+str(i)+"""
 </value></Data><Data name="l1"><value>
 """+self.label[i]+"""
 </value></Data><Data name="n2"><value>
 """+str(i)+"""
 </value></Data><Data name="l2"><value>
 """+self.label[j]+"""
-</value></Data></ExtendedData><TimeSpan/><styleUrl>#e</styleUrl><StyleMap><Pair><key>normal</key><Style><LabelStyle id="l"""+str(i)+"-"+str(j)+""""><color>bf7fffff</color><scale>0</scale></LabelStyle><LineStyle id="a"""+str(i)+"-"+str(j)+""""><color/><width>
+</value></Data></ExtendedData><TimeSpan/><styleUrl>#e</styleUrl><StyleMap>"""
+                """<Pair><key>normal</key><Style><LabelStyle id="l"""+str(i)
+                + "-"+str(j)
+                + """"><color>bf7fffff</color><scale>0</scale></LabelStyle>"""
+                """<LineStyle id="a"""+str(i)+"-"+str(j)+""""><color/><width>
 """+str(relwidth*5+1)+"""
-</width></LineStyle></Style></Pair><Pair><key>highlight</key><styleUrl>#f</styleUrl></Pair></StyleMap><MultiGeometry><Point><altitudeMode>relativeToGround</altitudeMode><coordinates>
+</width></LineStyle></Style></Pair><Pair><key>highlight</key><styleUrl>#f"""
+                """</styleUrl></Pair></StyleMap><MultiGeometry><Point>"""
+                """<altitudeMode>relativeToGround</altitudeMode><coordinates>
 """+hotpos+"""
-</coordinates></Point><LineString><altitudeMode>relativeToGround</altitudeMode><coordinates>""")
+</coordinates></Point><LineString><altitudeMode>relativeToGround"""
+                """</altitudeMode><coordinates>""")
         for s in range(nps):
             la, lo = self.network.cartesian2latlon(pos[s, :])
             f.write("\n" + str(round(100*lo)/100) +
                     "," + str(round(100*la)/100) + "," + str(int(hgt[s])))
         f.write("""
 </coordinates></LineString></MultiGeometry></Placemark>""")
 
@@ -1475,233 +1557,260 @@
     def _collapse(self, i):
         """collapse a supernode and return whether its state changed"""
         if not self.is_expanded[i]:
             return False
         self.is_expanded[i] = False
         return True
 
-    def _dummy():
-        f.write("""<?xml version="1.0" encoding="UTF-8"?>
-<kml xmlns="http://www.opengis.net/kml/2.2">
- <Document>
-  <Style id="a"><!-- common to regions -->
-   <PolyStyle>
-    <fill>0</fill>
-    <outline>1</outline>
-   </PolyStyle>
-   <IconStyle>
-    <color>00000000</color>
-   </IconStyle>
-   <BalloonStyle>
-    <text><![CDATA[
-     <b>$[name]</b><br/>
-     <table>
-      <tr><td>Area</td><td><b>a</b></td><td nowrap>$[a] Mm²</td></tr>
-      <tr><td>Ave. linked area (n.s.i. degree)</td><td><b>k</b></td><td nowrap>$[k] Mm²</td></tr>
-      <tr><td>Ave. n.s.i. clustering coeff.</td><td><b>C</b></td><td nowrap>$[C] %</td></tr>
-      <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td><td nowrap>$[B] %</td></tr>
-      <tr><td>contained in region</td><td/><td>$[p]</td></tr>
-      <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
-      <tr><td>contains regions</td><td/><td>$[ch]</td></tr>
-     </table>
-    ]]></text>
-   </BalloonStyle>
-  </Style>
-  <Style id="b"><!-- highlit regions -->
-   <PolyStyle>
-    <fill>0</fill>
-    <outline>1</outline>
-   </PolyStyle>
-   <LineStyle>
-    <color>ff0000ff</color>
-    <width>12</width>
-   </LineStyle>
-   <LabelStyle>
-    <color>ff3f3fff</color>
-    <scale>4.0</scale>
-   </LabelStyle>
-   <IconStyle>
-    <color>00000000</color>
-   </IconStyle>
-   <BalloonStyle>
-    <text><![CDATA[
-     <b>$[name]</b><br/>
-     <table>
-      <tr><td>Area</td><td><b>a</b></td><td>$[a]&nbsp;Mm²</td></tr>
-      <tr><td>Ave. linked area (n.s.i. degree)</td><td><b>k</b></td><td>$[k]&nbsp;Mm²</td></tr>
-      <tr><td>Ave. n.s.i. clustering coeff.</td><td><b>C</b></td><td nowrap>$[C] %</td></tr>
-      <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td><td nowrap>$[B] %</td></tr>
-      <tr><td>contained in region</td><td/><td>$[p]</td></tr>
-      <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
-      <tr><td>contains regions</td><td/><td>$[ch]</td></tr>
-     </table>
-    ]]></text>
-   </BalloonStyle>
-  </Style>
-  <Style id="c"><!-- common to nodes -->
-   <IconStyle>
-    <color>00000000</color>
-   </IconStyle>
-  </Style>
-  <Style id="d"><!-- highlit nodes -->
-   <LabelStyle>
-    <color>ff3f3fff</color>
-    <scale>4.0</scale>
-   </LabelStyle>
-   <IconStyle>
-    <color>00000000</color>
-   </IconStyle>
-  </Style>
-  <Style id="e"><!-- arcs -->
-   <LabelStyle>
-    <color>bf7fffff</color>
-    <scale>1.0</scale>
-   </LabelStyle>
-   <IconStyle>
-    <color>00000000</color>
-   </IconStyle>
-   <BalloonStyle/>
-    <!--<text><![CDATA[
-      <b>$[name]</b><br/>
-      <table>
-      <tr><td>Strength</td><td><b>a</b></td><td nowrap>$[s] (Mm²)²</td></tr>
-      <tr><td>Relative strength</td><td><b>a</b></td><td nowrap>$[r] %</td></tr>
-      <tr><td>Ave. network distance</td><td><b>l</b></td><td nowrap>$[l] steps</td></tr>
-      <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td><td nowrap>$[B] %</td></tr>
-      <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
-      </table>
-    ]]></text>
-   </BalloonStyle>-->
-  </Style>
-  <Style id="f"><!-- highlit arcs -->
-   <LineStyle>
-    <color>ff0000ff</color>
-    <width>4</width>
-   </LineStyle>
-   <LabelStyle>
-    <color>ff3f3fff</color>
-    <scale>1.5</scale>
-   </LabelStyle>
-   <IconStyle>
-    <color>00000000</color>
-    </IconStyle>
-   <BalloonStyle/>
-    <!--<text><![CDATA[
-      <b>$[name]</b><br/>
-      <table>
-      <tr><td>Strength</td><td><b>a</b></td><td nowrap>$[s] (Mm²)²</td></tr>
-      <tr><td>Relative strength</td><td><b>a</b></td><td nowrap>$[r] %</td></tr>
-      <tr><td>Ave. network distance</td><td><b>l</b></td><td nowrap>$[l] steps</td></tr>
-      <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td><td nowrap>$[B] %</td></tr>
-      <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
-      </table>
-    ]]></text>
-   </BalloonStyle>-->
-  </Style>
-  <Style id="h"><!-- hidden children -->
-   <ListStyle>
-    <listItemType>checkHideChildren</listItemType>
-   </ListStyle>
-  </Style>
-  <Style id="l">
-   <ListStyle>
-    <ItemIcon/>
-   </ListStyle>
-  </Style>
-  <Style id="lh">
-   <ListStyle>
-    <listItemType>checkHideChildren</listItemType>
-   </ListStyle>
-  </Style>
-  <Style id="lr">
-   <ListStyle>
-    <listItemType>radioFolder</listItemType>
-   </ListStyle>
-  </Style>
-  <Folder id="0">
-   <name>"""+title+"""</name>
-   <styleUrl>#lr</styleUrl>
-   <Folder id="h">
-    <name>Slideable Hierarchy of Regions</name>
-    <description><![CDATA[
-     region labels inside subfolders give this information:<br/>
-     <b>round
-      <a href="#h;balloon">code</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#h;balloon">a</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#h;balloon">k</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#h;balloon">C</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#h;balloon">B</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#h;balloon">location</a>
-     </b><br/><br/>
-     <table>
-      <tr>
-       <td nowrap><i>
-        code<br/>
-        a<br/>
-        k<br/>
-        C<br/>
-        B<br/>
-        location
-       </i></td><td nowrap>
-        is a short unique code,<br/>
-        is the region's area,<br/>
-        is the region's average linked area (n.s.i. degree),<br/>
-        is the region's average n.s.i. clustering coeff.,<br/>
-        is the region's average n.s.i. shortest path betweenness,<br/>
-        gives its approximate location.
-       </td>
-      </tr>
-     </table>
-     <h1>Slideable Hierarchy of Regions</h1>
-     <p>This folder contains a hierarchy of regions covering the Earth's surface.
-     Use the slider on the top-left to successively increase the level of detail
-     from a coarse partition into """+str(len(self.solution_nodes[0]))+""" regions
-     to a fine partition into """+str(len(self.solution_nodes[-1]))+""" regions
-     (if the slider shows a "month" and "day", just ignore them).
-     <p>Expand this folder to get more information on individual regions,
-     ordered into subfolders corresponding to certain selected levels of detail.
-     The hierarchy can be used in combination with third-party overlays that do not themselves use the slider.
-     (For third-party overlays using the slider, use the folder <a href="#p;balloonFlyto">Selected Partitions</a> instead.)
-    ]]></description>
-    <visibility>1</visibility>""")
-        f.write("""
-    </Folder>
-   </Folder>
-   <Folder id="p">
-    <name>Selected Partitions</name>
-    <description><![CDATA[
-     region labels inside subfolders give this information:<br/>
-     <b>
-      <a href="#p;balloon">code</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#p;balloon">a</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#p;balloon">k</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#p;balloon">C</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#p;balloon">B</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-      <a href="#p;balloon">location</a>
-     </b><br/><br/>
-     <table>
-      <tr>
-       <td nowrap><i>
-        code<br/>
-        a<br/>
-        k<br/>
-        C<br/>
-        B<br/>
-        location
-       </i></td><td nowrap>
-        is a short unique code,<br/>
-        is the region's area,<br/>
-        is the region's average linked area (n.s.i. degree),<br/>
-        is the region's average n.s.i. clustering coeff.,<br/>
-        is the region's average n.s.i. shortest path betweenness,<br/>
-        gives its approximate location.
-       </td>
-      </tr>
-     </table>
-     <h1>Selected Partitions</h1>
-     <p>This folder contains sets of regions that each cover the Earth's surface
-     and correspond to certain selected levels of detail from the above hierarchy.
-     They can be used in combination with third-party overlays that use a slider.
-     Expand the subfolders to get more information on individual regions.
-     <a href="r5063;balloonFlyto">TEST</a>
-    ]]></description>
-    <styleUrl>#lr</styleUrl>""")
+
+#     def _dummy():
+#         f.write("""<?xml version="1.0" encoding="UTF-8"?>
+# <kml xmlns="http://www.opengis.net/kml/2.2">
+#  <Document>
+#   <Style id="a"><!-- common to regions -->
+#    <PolyStyle>
+#     <fill>0</fill>
+#     <outline>1</outline>
+#    </PolyStyle>
+#    <IconStyle>
+#     <color>00000000</color>
+#    </IconStyle>
+#    <BalloonStyle>
+#     <text><![CDATA[
+#      <b>$[name]</b><br/>
+#      <table>
+#       <tr><td>Area</td><td><b>a</b></td><td nowrap>$[a] Mm²</td></tr>
+#       <tr><td>Ave. linked area (n.s.i. degree)</td><td><b>k</b></td>"""
+#                 """<td nowrap>$[k] Mm²</td></tr>
+#       <tr><td>Ave. n.s.i. clustering coeff.</td><td><b>C</b></td>"""
+#                 """<td nowrap>$[C] %</td></tr>
+#       <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td>"""
+#                 """<td nowrap>$[B] %</td></tr>
+#       <tr><td>contained in region</td><td/><td>$[p]</td></tr>
+#       <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
+#       <tr><td>contains regions</td><td/><td>$[ch]</td></tr>
+#      </table>
+#     ]]></text>
+#    </BalloonStyle>
+#   </Style>
+#   <Style id="b"><!-- highlit regions -->
+#    <PolyStyle>
+#     <fill>0</fill>
+#     <outline>1</outline>
+#    </PolyStyle>
+#    <LineStyle>
+#     <color>ff0000ff</color>
+#     <width>12</width>
+#    </LineStyle>
+#    <LabelStyle>
+#     <color>ff3f3fff</color>
+#     <scale>4.0</scale>
+#    </LabelStyle>
+#    <IconStyle>
+#     <color>00000000</color>
+#    </IconStyle>
+#    <BalloonStyle>
+#     <text><![CDATA[
+#      <b>$[name]</b><br/>
+#      <table>
+#       <tr><td>Area</td><td><b>a</b></td><td>$[a]&nbsp;Mm²</td></tr>
+#       <tr><td>Ave. linked area (n.s.i. degree)</td><td><b>k</b></td><td>"""
+#                 """$[k]&nbsp;Mm²</td></tr>
+#       <tr><td>Ave. n.s.i. clustering coeff.</td><td><b>C</b></td>"""
+#                 """<td nowrap>$[C] %</td></tr>
+#       <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td>"""
+#                 """<td nowrap>$[B] %</td></tr>
+#       <tr><td>contained in region</td><td/><td>$[p]</td></tr>
+#       <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
+#       <tr><td>contains regions</td><td/><td>$[ch]</td></tr>
+#      </table>
+#     ]]></text>
+#    </BalloonStyle>
+#   </Style>
+#   <Style id="c"><!-- common to nodes -->
+#    <IconStyle>
+#     <color>00000000</color>
+#    </IconStyle>
+#   </Style>
+#   <Style id="d"><!-- highlit nodes -->
+#    <LabelStyle>
+#     <color>ff3f3fff</color>
+#     <scale>4.0</scale>
+#    </LabelStyle>
+#    <IconStyle>
+#     <color>00000000</color>
+#    </IconStyle>
+#   </Style>
+#   <Style id="e"><!-- arcs -->
+#    <LabelStyle>
+#     <color>bf7fffff</color>
+#     <scale>1.0</scale>
+#    </LabelStyle>
+#    <IconStyle>
+#     <color>00000000</color>
+#    </IconStyle>
+#    <BalloonStyle/>
+#     <!--<text><![CDATA[
+#       <b>$[name]</b><br/>
+#       <table>
+#       <tr><td>Strength</td><td><b>a</b></td><td nowrap>$[s] (Mm²)²</td></tr>
+#       <tr><td>Relative strength</td><td><b>a</b></td><td nowrap>$[r] %"""
+#                 """</td></tr>
+#       <tr><td>Ave. network distance</td><td><b>l</b></td><td nowrap>"""
+#                 """$[l] steps</td></tr>
+#       <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td>"""
+#                 """<td nowrap>$[B] %</td></tr>
+#       <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
+#       </table>
+#     ]]></text>
+#    </BalloonStyle>-->
+#   </Style>
+#   <Style id="f"><!-- highlit arcs -->
+#    <LineStyle>
+#     <color>ff0000ff</color>
+#     <width>4</width>
+#    </LineStyle>
+#    <LabelStyle>
+#     <color>ff3f3fff</color>
+#     <scale>1.5</scale>
+#    </LabelStyle>
+#    <IconStyle>
+#     <color>00000000</color>
+#     </IconStyle>
+#    <BalloonStyle/>
+#     <!--<text><![CDATA[
+#       <b>$[name]</b><br/>
+#       <table>
+#       <tr><td>Strength</td><td><b>a</b></td><td nowrap>$[s] (Mm²)²</td></tr>
+#       <tr><td>Relative strength</td><td><b>a</b></td><td nowrap>$[r] %"""
+#                 """</td></tr>
+#       <tr><td>Ave. network distance</td><td><b>l</b></td><td nowrap>"""
+#                 """$[l] steps</td></tr>
+#       <tr><td>Ave. n.s.i. shortest path betweenness</td><td><b>B</b></td>"""
+#                 """<td nowrap>$[B] %</td></tr>
+#       <tr><td>used in solution(s) no.</td><td/><td>$[t]</td></tr>
+#       </table>
+#     ]]></text>
+#    </BalloonStyle>-->
+#   </Style>
+#   <Style id="h"><!-- hidden children -->
+#    <ListStyle>
+#     <listItemType>checkHideChildren</listItemType>
+#    </ListStyle>
+#   </Style>
+#   <Style id="l">
+#    <ListStyle>
+#     <ItemIcon/>
+#    </ListStyle>
+#   </Style>
+#   <Style id="lh">
+#    <ListStyle>
+#     <listItemType>checkHideChildren</listItemType>
+#    </ListStyle>
+#   </Style>
+#   <Style id="lr">
+#    <ListStyle>
+#     <listItemType>radioFolder</listItemType>
+#    </ListStyle>
+#   </Style>
+#   <Folder id="0">
+#    <name>"""+title+"""</name>
+#    <styleUrl>#lr</styleUrl>
+#    <Folder id="h">
+#     <name>Slideable Hierarchy of Regions</name>
+#     <description><![CDATA[
+#      region labels inside subfolders give this information:<br/>
+#      <b>round
+#       <a href="#h;balloon">code</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;&nbsp;
+#       <a href="#h;balloon">a</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#h;balloon">k</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#h;balloon">C</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#h;balloon">B</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#h;balloon">location</a>
+#      </b><br/><br/>
+#      <table>
+#       <tr>
+#        <td nowrap><i>
+#         code<br/>
+#         a<br/>
+#         k<br/>
+#         C<br/>
+#         B<br/>
+#         location
+#        </i></td><td nowrap>
+#         is a short unique code,<br/>
+#         is the region's area,<br/>
+#         is the region's average linked area (n.s.i. degree),<br/>
+#         is the region's average n.s.i. clustering coeff.,<br/>
+#         is the region's average n.s.i. shortest path betweenness,<br/>
+#         gives its approximate location.
+#        </td>
+#       </tr>
+#      </table>
+#      <h1>Slideable Hierarchy of Regions</h1>
+#      <p>This folder contains a hierarchy of regions covering the Earth's
+#      surface. Use the slider on the top-left to successively increase the
+#      level of detail from a coarse partition into """
+#      +str(len(self.solution_nodes[0]))+""" regions to a
+#      fine partition into """+str(len(self.solution_nodes[-1]))+""" regions
+#      (if the slider shows a "month" and "day", just ignore them).
+#      <p>Expand this folder to get more information on individual regions,
+#      ordered into subfolders corresponding to certain selected levels of
+#      detail. The hierarchy can be used in combination with third-party
+#      overlays that do not themselves use the slider. (For third-party
+#      overlays using the slider, use the folder """
+#      """<a href="#p;balloonFlyto">Selected Partitions</a> instead.)
+#     ]]></description>
+#     <visibility>1</visibility>""")
+#         f.write("""
+#     </Folder>
+#    </Folder>
+#    <Folder id="p">
+#     <name>Selected Partitions</name>
+#     <description><![CDATA[
+#      region labels inside subfolders give this information:<br/>
+#      <b>
+#       <a href="#p;balloon">code</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;&nbsp;
+#       <a href="#p;balloon">a</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#p;balloon">k</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#p;balloon">C</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#p;balloon">B</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""
+#                 """&nbsp;&nbsp;&nbsp;
+#       <a href="#p;balloon">location</a>
+#      </b><br/><br/>
+#      <table>
+#       <tr>
+#        <td nowrap><i>
+#         code<br/>
+#         a<br/>
+#         k<br/>
+#         C<br/>
+#         B<br/>
+#         location
+#        </i></td><td nowrap>
+#         is a short unique code,<br/>
+#         is the region's area,<br/>
+#         is the region's average linked area (n.s.i. degree),<br/>
+#         is the region's average n.s.i. clustering coeff.,<br/>
+#         is the region's average n.s.i. shortest path betweenness,<br/>
+#         gives its approximate location.
+#        </td>
+#       </tr>
+#      </table>
+#      <h1>Selected Partitions</h1>
+#      <p>This folder contains sets of regions that each cover the Earth's
+#      surface and correspond to certain selected levels of detail from the
+#      above hierarchy. They can be used in combination with third-party
+#      overlays that use a slider. Expand the subfolders to get more
+#      information on individual regions.
+#      <a href="r5063;balloonFlyto">TEST</a>
+#     ]]></description>
+#     <styleUrl>#lr</styleUrl>""")
```

### Comparing `pyunicorn-0.6.1/pyunicorn/utils/mpi.py` & `pyunicorn-0.7.0/src/pyunicorn/utils/mpi.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/funcnet/coupling_analysis_pure_python.py` & `pyunicorn-0.7.0/src/pyunicorn/funcnet/coupling_analysis_pure_python.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -72,29 +69,27 @@
 
         #  Flatten observable anomaly array along lon/lat dimension to allow
         #  for more convinient indexing and transpose the whole array as this
         #  is faster in loops
         if numpy.ndim(dataarray) == 4:
             (self.total_time, n_lev, n_lat, n_lon) = dataarray.shape
             self.N = n_lev * n_lat * n_lon
-            self.dataarray = numpy.\
-                fastCopyAndTranspose(dataarray.reshape(-1, self.N))
+            self.dataarray = dataarray.reshape(-1, self.N).T.copy()
         if numpy.ndim(dataarray) == 3:
             (self.total_time, n_lat, n_lon) = dataarray.shape
             self.N = n_lat * n_lon
-            self.dataarray = numpy.\
-                fastCopyAndTranspose(dataarray.reshape(-1, self.N))
+            self.dataarray = dataarray.reshape(-1, self.N).T.copy()
 
         elif numpy.ndim(dataarray) == 2:
             (self.total_time, self.N) = dataarray.shape
-            self.dataarray = numpy.fastCopyAndTranspose(dataarray)
+            self.dataarray = dataarray.T.copy()
 
         else:
             print("irregular array shape...")
-            self.dataarray = numpy.fastCopyAndTranspose(dataarray)
+            self.dataarray = dataarray.T.copy()
 
         #  factorials below 10 in a list for permutation patterns
         self.factorial = \
             numpy.array([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880])
         self.patternized = False
         self.has_fft = False
         self.originalFFT = None
@@ -104,16 +99,16 @@
 
     def __str__(self):
         """
         Return a string representation of the CouplingAnalysisPurePython
         object.
         """
         shape = self.dataarray.shape
-        return 'CouplingAnalysisPurePython: %i variables, %i timesteps.' % (
-            shape[0], shape[1])
+        return (f'CouplingAnalysisPurePython: {shape[0]} variables, '
+                f'{shape[1]} timesteps.')
 
     #
     #  Define methods to calculate correlation strength and lags
     #
 
     #
     #  Routines for calculating Cross Correlation
@@ -596,18 +591,18 @@
                         indexi = array[tau_max, i, k]
                         indexj = array[t, j, k]
                         hist2D[indexi, indexj] += 1
 
                     # here the joint entropy is calculated by summing over all
                     # pattern combinations
                     jointent = 0.0
-                    for l in range(bins):
-                        for m in range(bins):
-                            jointent -= gfunc[hist2D[l, m]]
-                            hist2D[l, m] = 0
+                    for m in range(bins):
+                        for n in range(bins):
+                            jointent -= gfunc[hist2D[m, n]]
+                            hist2D[m, n] = 0
 
                     jointent /= float(corr_range)
                     jointent += numpy.log(float(corr_range))
 
                     # Mutual Information is...
                     mi = 0.0
                     mi = 2. * numpy.log(bins) - jointent
```

### Comparing `pyunicorn-0.6.1/pyunicorn/funcnet/__init__.py` & `pyunicorn-0.7.0/tests/test_climate/test_coupled_climate_network.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,38 +1,27 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
-funcnet
-=======
-
-
-Related Publications
-~~~~~~~~~~~~~~~~~~~~
-
-To do
-~~~~~
-  - ...
+Simple tests for the CoupledClimateNetwork class.
+"""
 
-Known Bugs
-~~~~~~~~~~
-  - ...
+from pyunicorn.climate import ClimateData, CoupledTsonisClimateNetwork
 
-"""
 
-from .coupling_analysis import CouplingAnalysis
-from .coupling_analysis_pure_python import CouplingAnalysisPurePython
-from .event_synchronization import EventSynchronization
+def test_internal_link_density():
+    cd = ClimateData.SmallTestData()
+    tsonis_ccn = CoupledTsonisClimateNetwork(cd, cd, threshold=.2)
+    res = tsonis_ccn.internal_link_density()
+    assert isinstance(res, tuple) and all(isinstance(d, float) for d in res)
+    assert all(0 <= d <= 1 for d in res)
```

### Comparing `pyunicorn-0.6.1/pyunicorn/funcnet/coupling_analysis.py` & `pyunicorn-0.7.0/src/pyunicorn/funcnet/coupling_analysis.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -22,16 +19,18 @@
 """
 
 import numpy                        # array object and fast numerics
 from scipy import special, linalg   # special math functions
 
 # import mpi                          # parallelized computations
 
+from ..core._ext.types import to_cy, LAG, FIELD, \
+    INT16TYPE, INT32TYPE, INT64TYPE
 from ._ext.numerics import _symmetrize_by_absmax, _cross_correlation_max, \
-    _cross_correlation_all, _get_nearest_neighbors_cython
+    _cross_correlation_all, _get_nearest_neighbors
 
 
 #
 #  Define class Coupling Analysis
 #
 
 class CouplingAnalysis:
@@ -67,16 +66,16 @@
         self.N = self.data.shape[1]
 
         #  precalculation of p*log(p) needed for entropies
         self.plogp = None
 
     def __str__(self):
         """Return a string representation of the CouplingAnalysis object."""
-        return 'CouplingAnalysis: %i variables, %i timesteps.' % (
-            self.N, self.n_time)
+        return (f'CouplingAnalysis: {self.N} variables, '
+                f'{self.n_time} timesteps.')
 
     @staticmethod
     def test_data():
         """
         Return example test data as discussed in pyunicorn description paper.
         """
         numpy.random.seed(42)
@@ -127,23 +126,21 @@
         :type lag_matrix: array-like [int>=0]
         :arg  lag_matrix:  array-like [node, node] matrix of lags
 
         :rtype: tuple of arrays
         :returns: the value at the absolute maximum and the (pos or neg) lag.
         """
 
-        N = self.N
-        return _symmetrize_by_absmax(similarity_matrix.copy(order='c'),
-                                     lag_matrix.copy(order='c'), N)
+        return _symmetrize_by_absmax(to_cy(similarity_matrix, FIELD),
+                                     to_cy(lag_matrix, LAG), self.N)
 
     #
     #  Define methods to estimate similarity measures
     #
     def cross_correlation(self, tau_max=0, lag_mode='max'):
-
         r"""
         Return cross correlation between all pairs of nodes.
 
         Two lag-modes are available (default: lag_mode='max'):
 
         lag_mode = 'all':
         Return 3-dimensional array of lagged cross correlations between all
@@ -191,51 +188,45 @@
         # Sanity checks
         if not isinstance(data, numpy.ndarray):
             raise TypeError(f"data is of type {type(data)}, "
                             "must be numpy.ndarray")
         if N > T:
             print(f"Warning: data.shape = {data.shape},"
                   " is it of shape (observations, variables) ?")
-        if numpy.isnan(data).sum() != 0:
-            raise ValueError("NaNs in the data")
-        if tau_max < 0:
-            raise ValueError("tau_max = %d, but 0 <= tau_max" % tau_max)
-        if lag_mode not in ['max', 'all']:
-            raise ValueError("lag_mode = %s, but must be one of 'max', 'all'"
-                             % lag_mode)
+        assert numpy.isnan(data).sum() == 0, "NaNs in the data"
+        assert tau_max >= 0, f"{tau_max =}"
+        assert lag_mode in ['max', 'all'], f"{lag_mode =}"
 
         #  Normalize time series to zero mean and unit variance for all lags
         corr_range = T - tau_max
-        array = numpy.empty((tau_max + 1, N, corr_range), dtype="float32")
+        array = numpy.empty((tau_max + 1, N, corr_range), dtype=FIELD)
 
         for t in range(tau_max + 1):
             #  Remove mean value from time series at each node
-            array[t] = numpy.fastCopyAndTranspose(
+            array[t] = (
                 data[t:t+corr_range, :]
-                - data[t:t+corr_range, :].mean(axis=0).reshape(1, N))
+                - data[t:t+corr_range, :].mean(axis=0).reshape(1, N)).T
 
             #  Normalize the variance of anomalies to one
             array[t] /= array[t].std(axis=1).reshape(N, 1)
 
             #  Correct for nodes with zero variance in their time series
             array[t][numpy.isnan(array[t])] = 0
 
         if lag_mode == 'max':
-            return _cross_correlation_max(array.copy(order='c'), N, tau_max,
-                                          corr_range)
-
+            return _cross_correlation_max(
+                to_cy(array, FIELD), N, tau_max, corr_range)
         elif lag_mode == 'all':
-            return _cross_correlation_all(array.copy(order='c'), N, tau_max,
-                                          corr_range)
+            return _cross_correlation_all(
+                to_cy(array, FIELD), N, tau_max, corr_range)
         else:
             return None
 
     def mutual_information(self, tau_max=0, estimator='knn',
                            knn=10, bins=6, lag_mode='max'):
-
         r"""
         Return mutual information (MI) between all pairs of nodes.
 
         Three estimators are available:
 
         estimator = 'knn' (Recommended):
         Based on k-nearest-neighbors [Kraskov2004]_,
@@ -315,28 +306,24 @@
                             "must be numpy.ndarray")
         if N > T:
             print(f"Warning: data.shape = {data.shape},"
                   " is it of shape (observations, variables) ?")
         if T < 500:
             print(f"Warning: T = {T} ,"
                   " unreliable estimation using MI estimator")
-        if numpy.isnan(data).sum() != 0:
-            raise ValueError("NaNs in the data")
-        if tau_max < 0:
-            raise ValueError("tau_max = %d, but 0 <= tau_max" % tau_max)
+        assert numpy.isnan(data).sum() == 0, "NaNs in the data"
+        assert tau_max >= 0, f"{tau_max =}"
         if estimator == 'knn':
-            if knn > T/2. or knn < 1:
-                raise ValueError("knn = %s, should be between 1 and T/2"
-                                 % str(knn))
+            assert 1 <= knn <= T/2., f"{knn =}"
 
         if lag_mode == 'max':
-            similarity_matrix = numpy.ones((N, N), dtype='float32')
-            lag_matrix = numpy.zeros((N, N), dtype='int8')
+            similarity_matrix = numpy.ones((N, N), dtype=FIELD)
+            lag_matrix = numpy.zeros((N, N), dtype=LAG)
         elif lag_mode == 'all':
-            lagfuncs = numpy.zeros((N, N, tau_max+1), dtype='float32')
+            lagfuncs = numpy.zeros((N, N, tau_max+1), dtype=FIELD)
 
         if estimator == 'binning':
             self.plogp = self.create_plogp(T)
 
         for i in range(N):
             for j in range(N):
                 maximum = 0.
@@ -354,15 +341,15 @@
                     for d, node in enumerate(XYZ):
                         var, lag = node
                         array[d, :] = data[max_lag + lag: T + lag, var]
 
                     if estimator == 'knn':
                         xyz = numpy.array([0, 1])
 
-                        k_xz, k_yz, k_z = self._get_nearest_neighbors(
+                        k_xz, k_yz, k_z = self.get_nearest_neighbors(
                             array=array, xyz=xyz, k=knn, standardize=True)
 
                         ixy_z = (special.digamma(knn)
                                  + (- special.digamma(k_xz)
                                     - special.digamma(k_yz)
                                     + special.digamma(k_z)).mean())
 
@@ -417,15 +404,14 @@
         elif lag_mode == 'all':
             return lagfuncs
         else:
             return None
 
     def information_transfer(self, tau_max=0, estimator='knn',
                              knn=10, past=1, cond_mode='ity', lag_mode='max'):
-
         r"""
         Return bivariate information transfer between all pairs of nodes.
 
         Two condition modes of information transfer are available
         as described in [Runge2012b]_.
 
         Information transfer to Y (ITY):
@@ -506,35 +492,35 @@
         """
 
         data = self.data
         T, N = data.shape
 
         # Sanity checks
         if not isinstance(data, numpy.ndarray):
-            raise TypeError("data is of type %s, must be numpy.ndarray"
-                            % type(data))
+            raise TypeError(f"data is of type {type(data)},"
+                            " must be numpy.ndarray")
         if N > T:
             print(f"Warning: data.shape = {data.shape},"
                   " is it of shape (observations, variables) ?")
         if estimator == 'knn' and T < 500:
             print(f"Warning: T = {T} ,"
                   " unreliable estimation using knn-estimator")
         if numpy.isnan(data).sum() != 0:
             raise ValueError("NaNs in the data")
         if tau_max < 0:
-            raise ValueError("tau_max = %d, but 0 <= tau_max" % tau_max)
+            raise ValueError(f"tau_max = {tau_max}, but 0 <= tau_max")
         if estimator == 'knn':
             if knn > T/2. or knn < 1:
                 raise ValueError(f"knn = {knn}, should be between 1 and T/2")
 
         if lag_mode == 'max':
-            similarity_matrix = numpy.ones((N, N), dtype='float32')
-            lag_matrix = numpy.zeros((N, N), dtype='int8')
+            similarity_matrix = numpy.ones((N, N), dtype=FIELD)
+            lag_matrix = numpy.zeros((N, N), dtype=LAG)
         elif lag_mode == 'all':
-            lagfuncs = numpy.zeros((N, N, tau_max+1), dtype='float32')
+            lagfuncs = numpy.zeros((N, N, tau_max+1), dtype=FIELD)
 
         for i in range(N):
             for j in range(N):
                 maximum = 0.
                 lag_at_max = 0
                 for tau in range(tau_max + 1):
 
@@ -554,15 +540,15 @@
                     for d, node in enumerate(XYZ):
                         var, lag = node
                         array[d, :] = data[max_lag + lag: T + lag, var]
 
                     if estimator == 'knn':
                         xyz = numpy.array([0, 1])
 
-                        k_xz, k_yz, k_z = self._get_nearest_neighbors(
+                        k_xz, k_yz, k_z = self.get_nearest_neighbors(
                             array=array, xyz=xyz, k=knn, standardize=True)
 
                         ixy_z = (special.digamma(knn)
                                  + (- special.digamma(k_xz)
                                     - special.digamma(k_yz)
                                     + special.digamma(k_z)).mean())
 
@@ -578,17 +564,16 @@
                             raise ValueError("nans after standardizing, \
                                              possibly constant array!")
 
                         x = array[0, :]
                         y = array[1, :]
                         if len(array) > 2:
                             confounds = array[2:, :]
-                            ortho_confounds = linalg.qr(
-                                numpy.fastCopyAndTranspose(confounds),
-                                mode='economic')[0].T
+                            ortho_confounds = linalg.qr(confounds.T.copy(),
+                                                        mode='economic')[0].T
                             x -= numpy.dot(numpy.dot(ortho_confounds, x),
                                            ortho_confounds)
                             y -= numpy.dot(numpy.dot(ortho_confounds, y),
                                            ortho_confounds)
 
                         ixy_z = self._par_corr_to_cmi(
                             numpy.dot(x, y) / numpy.sqrt(
@@ -634,16 +619,15 @@
         :rtype: float
         :returns: transformed partial correlation.
         """
 
         return -0.5*numpy.log(1. - par_corr**2)
 
     @staticmethod
-    def _get_nearest_neighbors(array, xyz, k, standardize=True):
-
+    def get_nearest_neighbors(array, xyz, k, standardize=True):
         """
         Returns nearest-neighbors for conditional mutual information estimator.
 
         Reference: [Kraskov2004]_
 
         :type array: array (float)
         :arg  array: data array.
@@ -656,44 +640,39 @@
 
         :type standardize: bool
         :arg  standardize: standardize array before estimation. (default: True)
 
         :rtype: tuple of arrays
         :returns: nearest neighbors for each sample point.
         """
-
         dim, T = array.shape
 
         if standardize:
             # Standardize
-            array = array.astype('float32')
+            array = array.astype(FIELD)
             array -= array.mean(axis=1).reshape(dim, 1)
             array /= array.std(axis=1).reshape(dim, 1)
             # If the time series is constant, return nan rather than raising
             # Exception
             if numpy.isnan(array).sum() != 0:
                 raise ValueError("nans after standardizing, possibly \
                                  constant array!")
 
         # Add noise to destroy ties...
-        array += 1E-10 * numpy.random.rand(array.shape[0], array.shape[1])
-
-        # Flatten for fast cython access
-        array = array.flatten()
+        array += 1E-10 * numpy.random.rand(dim, T)
 
         dim_x = int(numpy.where(xyz == 0)[0][-1] + 1)
         dim_y = int(numpy.where(xyz == 1)[0][-1] + 1 - dim_x)
         # dim_z = maxdim - dim_x - dim_y
 
-        return _get_nearest_neighbors_cython(array.copy(order='c'), T, dim_x,
-                                             dim_y, k, dim)
+        return _get_nearest_neighbors(
+            to_cy(array, FIELD), dim, T, dim_x, dim_y, k)
 
     @staticmethod
     def _quantile_bin_array(array, bins=6):
-
         """
         Returns symbolified array with aequi-quantile binning.
 
         This partition results in a uniform distribution of the marginals.
 
         :type array: array
         :arg array: data
@@ -706,29 +685,28 @@
         """
 
         dim, T = array.shape
 
         # get the bin quantile steps
         bin_edge = numpy.ceil(T/float(bins))
 
-        symb_array = numpy.zeros((dim, T), dtype='int32')
+        symb_array = numpy.zeros((dim, T), dtype=INT32TYPE)
 
         # get the lower edges of the bins for every time series
         edges = numpy.sort(array, axis=1)[:, ::bin_edge]
         bins = edges.shape[1]
 
         # This gives the symbolic time series
         symb_array = (array.reshape(dim, T, 1)
                       >= edges.reshape(dim, 1, bins)).sum(axis=2) - 1
 
         return symb_array
 
     @staticmethod
     def bincount_hist(symb_array):
-
         """
         Computes histogram from symbolic array.
 
         :type symb_array: array of integers
         :arg symb_array: symbolic data
 
         :rtype: array
@@ -741,32 +719,31 @@
 
         # Needed because numpy.bincount cannot process longs
         assert isinstance(base**D, int)
         assert base**D*16./8./1024.**3 < 3., (
             'Dimension exceeds 3 GB of necessary memory '
             '(change this code line if you got more...)')
         assert D*base**D < 2**65, (
-            'base = %d, D = %d: Histogram failed: '
-            'dimension D*base**D exceeds int64 data type') % (base, D)
+            f'base = {base}, D = {D}: Histogram failed:'
+            ' dimension D*base**D exceeds int64 data type')
 
-        flathist = numpy.zeros((base**D), dtype='int16')
-        multisymb = numpy.zeros(T, dtype='int64')
+        flathist = numpy.zeros((base**D), dtype=INT16TYPE)
+        multisymb = numpy.zeros(T, dtype=INT64TYPE)
 
         for i in range(D):
             multisymb += symb_array[i, :]*base**i
 
         result = numpy.bincount(multisymb)
         flathist[:len(result)] += result
 
         return flathist.reshape(tuple(
             [base, base] + [base for i in range(D-2)])).T
 
     @staticmethod
     def create_plogp(T):
-
         """
         Precalculation of p*log(p) needed for entropies.
 
         :type T: int
         :arg  T: sample length
 
         :rtype: array
```

### Comparing `pyunicorn-0.6.1/pyunicorn/funcnet/_ext/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/core/_ext/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/spearman.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/spearman.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/rainfall.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/rainfall.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -19,15 +16,18 @@
 Provides classes for generating and analyzing complex climate networks.
 """
 
 #
 #  Import essential packages
 #
 
-from ._ext.numerics import _calculate_corr
+# import numpy as np
+
+from ..core._ext.types import to_cy, MASK, FIELD
+from ._ext.numerics import spearman_corr
 
 #  Import cnTsonisClimateNetwork for TsonisClimateNetwork class
 from .climate_network import ClimateNetwork
 
 #
 #  Define class RainfallClimateNetwork
 #
@@ -172,15 +172,15 @@
         # event_threshold
         final_mask = self.calculate_top_events(rainfall, event_threshold)
 
         if self.silence_level <= 1:
             print("Calculating Spearman-Rho-Matrix using Cython...")
 
         # Return the correlation matrix
-        return self.calculate_corr(final_mask, anomaly)
+        return self.spearman_corr(final_mask, anomaly)
 
     @staticmethod
     def calculate_rainfall(observable, scale_fac, offset):
         """
         Returns the rainfall in mm on each measuring point.
 
         :type observable: 2D Numpy array (time, index)
@@ -235,15 +235,15 @@
 
         rainfall = rainfall_copy
 
         down_mask = rainfall >= onelist[downlimit]
 
         up_mask = rainfall <= onelist[uplimit-1]
 
-        no_rain_mask = (rainfall != 0)
+        no_rain_mask = rainfall != 0
 
         final_mask = down_mask & up_mask & no_rain_mask
 
         return final_mask
 
     @staticmethod
     def rank_time_series(anomaly):
@@ -255,15 +255,15 @@
 
         :rtype: 2D Numpy array (index, time)
         :return: The ranked time series for each gridpoint
         """
         rank_time_series = anomaly.argsort(axis=1).argsort(axis=1) + 1.0
         return rank_time_series
 
-    def calculate_corr(self, final_mask, anomaly):
+    def spearman_corr(self, final_mask, anomaly):
         """
         Return the Spearman Correlation Matrix at zero lag.
 
         :type final_mask: 2D Numpy array (index, time)
         :arg final_mask: A bool array with False for every value in the
                          rainfall data, which are zero or outside the top_event
                          interval.
@@ -272,14 +272,11 @@
         :arg anomaly: The rainfall anomaly time series for each measuring
                       point.
 
         :rtype: 2D Numpy array (index, index)
         :return: the Spearman correlation matrix.
         """
         # Get rank time series
-        time_series_ranked = self.rank_time_series(anomaly).astype('float32')
-
+        time_series_ranked = self.rank_time_series(anomaly)
         m, tmax = anomaly.shape
-
-        return _calculate_corr(m, tmax,
-                               final_mask.astype('int32').copy(order='c'),
-                               time_series_ranked.copy(order='c'))
+        return spearman_corr(
+            m, tmax, to_cy(final_mask, MASK), to_cy(time_series_ranked, FIELD))
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -21,41 +18,32 @@
 
 Provides classes for generating and analyzing complex climate networks.
 
 Related Publications
 ~~~~~~~~~~~~~~~~~~~~
 [Donges2009c]_, [Donges2009a]_, [Donges2009b]_, [Donges2011a]_, [Zou2011]_,
 [Tominski2011]_, [Heitzig2012]_
-
-To do
-~~~~~
-  - A lot - See current product backlog.
-
-Known Bugs
-~~~~~~~~~~
-  - ...
-
 """
 
-from ..core import GeoNetwork, Grid, Network
+from ..core import GeoNetwork, GeoGrid, Network
 
 from .climate_data import ClimateData
 from .climate_network import ClimateNetwork
 from .coupled_climate_network import CoupledClimateNetwork
 from .coupled_tsonis import CoupledTsonisClimateNetwork
 from .havlin import HavlinClimateNetwork
 from .hilbert import HilbertClimateNetwork
-from .map_plots import MapPlots
+from .map_plot import MapPlot
 from .mutual_info import MutualInfoClimateNetwork
 from .partial_correlation import PartialCorrelationClimateNetwork
 from .rainfall import RainfallClimateNetwork
 from .spearman import SpearmanClimateNetwork
 from .tsonis import TsonisClimateNetwork
-from .eventsynchronization_climatenetwork import \
-    EventSynchronizationClimateNetwork
+from .eventseries_climatenetwork import \
+    EventSeriesClimateNetwork
 
 
 #
 #  Set global constants
 #
 
 #  Mean earth radius in kilometers
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/hilbert.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/hilbert.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,30 +12,26 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex climate networks.
 """
 
-#
-#  Import essential packages
-#
+from typing import Tuple
+from collections.abc import Hashable
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
-
-#  Import scipy.signal for signal processing
 try:
     import scipy.signal
 except ImportError:
     print("climate: Package scipy.signal could not be loaded. Some "
           "functionality in class HilbertClimateNetwork might not be "
           "available!")
 
-#  Import cnNetwork for Network base class
+from .climate_data import ClimateData
 from .climate_network import ClimateNetwork
 
 
 #
 #  Define class HilbertClimateNetwork
 #
 
@@ -91,16 +84,17 @@
         """
         if silence_level <= 1:
             print("Generating a Hilbert climate network...")
         self.silence_level = silence_level
 
         #  Set instance variables
         self._coherence_phase = None
-        self.data = data
-        """(ClimateData) - The climate data used for network construction."""
+        assert isinstance(data, ClimateData)
+        self.data: ClimateData = data
+        """The climate data used for network construction."""
         self.N = data.grid.N
         self._threshold = threshold
         self._prescribed_link_density = link_density
 
         self._set_directed(directed, calculate_coherence=True)
         ClimateNetwork.__init__(self, grid=self.data.grid,
                                 similarity_measure=self._similarity_measure,
@@ -108,36 +102,34 @@
                                 link_density=link_density,
                                 non_local=non_local,
                                 directed=directed,
                                 node_weight_type=node_weight_type,
                                 silence_level=silence_level)
         self._set_directed(directed, calculate_coherence=False)
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return ClimateNetwork.__cache_state__(self)
+
+    def __rec_cache_state__(self) -> Tuple[object, ...]:
+        return ClimateNetwork.__rec_cache_state__(self) + (self.data,)
+
     def __str__(self):
         """
         Return a string representation.
         """
         return 'HilbertClimateNetwork:\n' + ClimateNetwork.__str__(self)
 
-    def clear_cache(self, irreversible=False):
+    def clear_cache(self):
         """
         Clean up cache.
-
-        If irreversible=True, the network cannot be recalculated using a
-        different threshold, or link density.
-
-        :arg bool irreversible: The irreversibility of clearing the cache.
         """
-        ClimateNetwork.clear_cache(self, irreversible)
-
-        if irreversible:
-            try:
-                del self._coherence_phase
-            except AttributeError:
-                pass
+        try:
+            del self._coherence_phase
+        except AttributeError:
+            pass
 
     #
     #  Defines methods to calculate Hilbert correlation measures
     #
 
     def _set_directed(self, directed, calculate_coherence=True):
         """
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/climate_data.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/climate_data.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,29 +12,25 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex climate networks.
 """
 
-#
-#  Import essential packages
-#
+from typing import Tuple
+from collections.abc import Hashable
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
 from numpy import random
 
 from ..core import Data
+from ..core.cache import Cached
 
 
-#
-#  Define class ClimateData
-#
-class ClimateData(Data):
+class ClimateData(Data, Cached):
 
     """
     Encapsulates spatio-temporal climate data.
 
     Provides methods to manipulate this data, i.e. calculate daily (monthly)
     mean values and anomaly values.
 
@@ -60,82 +53,63 @@
 
             window = {"time_min": 0., "time_max": 0., "lat_min": 0.,
                       "lat_max": 0., "lon_min": 0., "lon_max": 0.}
 
         :type observable: 2D array [time, index]
         :arg observable: The array of time series to be represented by the
             :class:`.Data` instance.
-        :type grid: :class:`.Grid` instance
+        :type grid: :class:`.Grid2D` instance
         :arg grid: The Grid representing the spatial coordinates associated to
             the time series and their temporal sampling.
         :arg int time_cycle: The annual cycle length of the data (units of
             samples).
         :arg bool anomalies: Indicates whether the data are climatological
             anomaly values.
         :arg str observable_name: A short name for the observable.
         :arg str observable_long_name: A long name for the observable.
         :arg dict window: Spatio-temporal window to select a view on the data.
         :arg int silence_level: The inverse level of verbosity of the object.
         """
+        self._mut_window = 0
+        """mutation count"""
+
         Data.__init__(self, observable=observable, grid=grid,
                       observable_name=observable_name,
                       observable_long_name=observable_long_name,
                       window=window, silence_level=silence_level)
 
         #  Set class variables
         self.time_cycle = time_cycle
         """(number (int)) - The annual cycle length of the data
                             (units of samples)."""
 
-        #  Set flags
-        self._flag_phase_mean = False
-        self._phase_mean = None
-
         self.data_source = ""
 
         # If data are anomalies skip automatic calculation of anomalies
-        if anomalies:
-            self._flag_anomaly = True
-            self._anomaly = observable
-        else:
-            self._flag_anomaly = False
+        self.anomalies = anomalies
+
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        # The following attributes are assumed immutable:
+        #   (_full_observable)
+        return (self._mut_window,)
 
     def __str__(self):
         """
         Returns a string representation.
         """
         return 'ClimateData:\n' + Data.__str__(self)
 
-    def clear_cache(self):
-        """
-        Clean up cache.
-
-        Is reversible, since all cached information can be recalculated from
-        basic data.
-        """
-        Data.clear_cache(self)
-
-        if self._flag_phase_mean:
-            del self._phase_mean
-            self._flag_phase_mean = False
-
-        if self._flag_anomaly:
-            del self._anomaly
-            self._flag_anomaly = False
-
     #
     #  Define alternative constructors
     #
 
     @classmethod
-    def Load(cls, file_name, observable_name, time_cycle,
-             time_name="time", latitude_name="lat", longitude_name="lon",
-             data_source=None,
-             file_type="NetCDF", window=None,
-             vertical_level=None, silence_level=0):
+    def Load(cls, file_name, observable_name, file_type="NetCDF",
+             dimension_names=None, window=None, vertical_level=None,
+             silence_level=0, time_cycle=None, data_source=None):
         """
         Initialize an instance of ClimateData.
 
         Supported file types ``file_type`` are:
           - "NetCDF" for regular (rectangular) grids
           - "iNetCDF" for irregular (e.g. geodesic) grids or station data.
 
@@ -144,32 +118,33 @@
 
             window = {"time_min": 0., "time_max": 0., "lat_min": 0.,
                       "lat_max": 0., "lon_min": 0., "lon_max": 0.}
 
         :arg str file_name: The name of the data file.
         :arg str observable_name: The short name of the observable within data
             file (particularly relevant for NetCDF).
-        :arg int time_cycle: The annual cycle length of the data (units of
-            samples).
-        :arg str time_name: The name of the time variable within data file.
-        :arg str latitude_name: The name of the latitude variable within data
-            file.
-        :arg str longitude_name: The name of longitude variable within data
-            file.
-        :arg str data_source: The name of the data source (model, reanalysis,
-            station).
         :arg str file_type: The format of the data file.
+        :arg dict dimension_names: The names of the dimensions as used in the
+            NetCDF file. Default: {"lat": "lat", "lon": "lon", "time": "time"}
         :arg dict window: Spatio-temporal window to select a view on the data.
         :arg int vertical_level: The vertical level to be extracted from the
             data file. Is ignored for horizontal data sets. If None, the first
             level in the data file is chosen.
         :arg int silence_level: The inverse level of verbosity of the object.
+        :arg int time_cycle: The annual cycle length of the data (units of
+            samples). NOTE: This is a required argument!
+        :arg str data_source: The name of the data source (model, reanalysis,
+            station).
         """
-        dimension_names = {"time": time_name, "lat": latitude_name,
-                           "lon": longitude_name}
+        if time_cycle is None:
+            raise TypeError("ClimateData.Load() is missing required "
+                            "keyword argument: 'time_cycle'")
+
+        if dimension_names is None:
+            dimension_names = {"lat": "lat", "lon": "lon", "time": "time"}
 
         #  Load data using _load_data method from parent class
         res = cls._load_data(file_name=file_name, file_type=file_type,
                              dimension_names=dimension_names,
                              observable_name=observable_name,
                              vertical_level=vertical_level)
 
@@ -304,137 +279,89 @@
                     selected_days.append(month * 30 + day)
 
             return self.indices_selected_phases(selected_days)
         else:
             raise NotImplementedError("Currently only time cycles 12 and 360 \
                                       are supported")
 
-    def _calculate_phase_mean(self):
+    @Cached.method(name="climatological mean values")
+    def phase_mean(self):
         """
         Calculate mean values of observable for each phase of the annual cycle.
 
         This is also commonly referred to as climatological mean, e.g., the
         mean temperature for all Januaries in the data set for monthly time
         resolution (time_cycle=12).
 
         .. note::
            Only the currently selected spatio-temporal window is considered.
 
         :rtype: 2D Numpy array [cycle index, node index]
         :return: the mean values of observable for each phase of the annual
                  cycle.
-        """
-        if self.silence_level <= 1:
-            print("Calculating climatological mean values...")
-
-        #  Get raw data
-        observable = self.observable()
-        #  Get time cycle
-        time_cycle = self.time_cycle
-
-        #  Get number of time series
-        N = observable.shape[1]
-
-        #  Initialize
-        phase_mean = np.zeros((time_cycle, N))
-
-        #  Calculate mean value for each day (month) on each node
-        for i in range(time_cycle):
-            phase_mean[i, :] = observable[i::time_cycle, :].mean(axis=0)
-
-        return phase_mean
-
-    def phase_mean(self):
-        """
-        Return mean values of observable for each phase of the annual cycle.
-
-        For further comments, see :meth:`_calculate_phase_mean`.
-
-        .. note::
-           Only the currently selected spatio-temporal window is considered.
 
         **Example:**
 
         >>> r(ClimateData.SmallTestData().phase_mean())
         array([[ 0.5   ,  0.5   , -0.5   , -0.5   ,  0.5   ,  0.5   ],
                [ 0.63  ,  0.321 , -0.63  , -0.321 ,  0.63  ,  0.321 ],
                [ 0.6984,  0.1106, -0.6984, -0.1106,  0.6984,  0.1106],
                [ 0.6984, -0.1106, -0.6984,  0.1106,  0.6984, -0.1106],
                [ 0.63  , -0.321 , -0.63  ,  0.321 ,  0.63  , -0.321 ]])
-
-        :rtype: 2D Numpy array [cycle index, node index]
-        :return: the mean values of observable for each phase of the annual
-                 cycle.
         """
-        if not self._flag_phase_mean:
-            self._phase_mean = self._calculate_phase_mean()
-            self._flag_phase_mean = True
+        observable = self.observable()
+        time_cycle = self.time_cycle
+        N = observable.shape[1]
+        phase_mean = np.zeros((time_cycle, N))
 
-        return self._phase_mean
+        #  Calculate mean value for each day (month) on each node
+        for i in range(time_cycle):
+            phase_mean[i, :] = observable[i::time_cycle, :].mean(axis=0)
+        return phase_mean
 
-    def _calculate_anomaly(self):
+    @Cached.method(name="daily (monthly) anomaly values")
+    def anomaly(self):
         """
         Calculate anomaly time series from observable.
 
         To obtain climatological anomaly time series, the climatological means
         are subtracted from each sample in the original time series. This
         procedure is also known as phase averaging.
 
         .. note::
            Only the currently selected spatio-temporal window is considered.
 
         :rtype: 2D Numpy array [time, node index]
         :return: the anomalized time series.
+
+        **Example:**
+
+        >>> r(ClimateData.SmallTestData().anomaly()[:,0])
+        array([-0.5 , -0.321 , -0.1106,  0.1106,  0.321 ,
+                0.5 ,  0.321 ,  0.1106, -0.1106, -0.321 ])
         """
-        if self.silence_level <= 1:
-            print("Calculating daily (monthly) anomaly values...")
+        # If data are anomalies skip automatic calculation of anomalies
+        if self.anomalies:
+            return self._full_observable
 
-        #  Get raw data
         observable = self.observable()
-        #  Get time cycle
         time_cycle = self.time_cycle
-        #  Initialize array
         anomaly = np.zeros(observable.shape)
 
         #  Thanks to Jakob Runge
         for i in range(time_cycle):
             sample = observable[i::time_cycle, :]
             anomaly[i::time_cycle, :] = sample - sample.mean(axis=0)
-
         return anomaly
 
-    def anomaly(self):
-        """
-        Return anomaly time series from observable.
-
-        For further comments, see :meth:`_calculate_anomaly`.
-
-        .. note::
-           Only the currently selected spatio-temporal window is considered.
-
-        **Example:**
-
-        >>> r(ClimateData.SmallTestData().anomaly()[:,0])
-        array([-0.5 , -0.321 , -0.1106,  0.1106,  0.321 ,
-                0.5 ,  0.321 ,  0.1106, -0.1106, -0.321 ])
-
-        :rtype: 2D Numpy array [time, node index]
-        :return: the anomalized time series.
-        """
-        if not self._flag_anomaly:
-            self._anomaly = self._calculate_anomaly()
-            self._flag_anomaly = True
-
-        return self._anomaly
-
     def anomaly_selected_months(self, selected_months):
         """
         Return anomaly time series from observable for selected months.
 
-        For further comments, see :meth:`_calculate_anomaly`.
+        For further comments, see :meth:`anomaly`.
 
         .. note::
            Only the currently selected spatio-temporal window is considered.
 
         :arg [number] selected_months: The selected months.
         :rtype:  2D array [time, node index]
         :return: the anomalized time series for selected months.
@@ -507,24 +434,23 @@
                [-0.321 ,  0.63  ], [-0.1106,  0.6984], [ 0.1106,  0.6984],
                [ 0.321 ,  0.63  ]])
 
         :type window: dictionary
         :arg window: The spatio-temporal window to select a view on the data.
         """
         Data.set_window(self, window)
-
-        self._flag_phase_mean = False
-        self._flag_anomaly = False
+        # invalidate cache
+        self._mut_window += 1
 
     def set_global_window(self):
         """
         Set the view on the whole data set.
 
         Select the full data set and creates a data array as well as
-        a corresponding Grid object to access this window from outside.
+        a corresponding Grid2D object to access this window from outside.
 
         **Example** (Set smaller window and subsequently restore global
         window):
 
         >>> data = ClimateData.SmallTestData()
         >>> data.set_window(window={"time_min": 0., "time_max": 4.,
         ...                 "lat_min": 10., "lat_max": 20.,
@@ -532,10 +458,9 @@
         >>> data.grid.grid()["lat"]
         array([ 10.,  15.], dtype=float32)
         >>> data.set_global_window()
         >>> data.grid.grid()["lat"]
         array([  0.,   5.,  10.,  15.,  20.,  25.], dtype=float32)
         """
         Data.set_global_window(self)
-
-        self._flag_phase_mean = False
-        self._flag_anomaly = False
+        # invalidate cache
+        self._mut_window += 1
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/tsonis.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/tsonis.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,30 +12,21 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex climate networks.
 """
 
-#
-#  Import essential packages
-#
-
-#  Import NumPy for the array object and fast numerics
 import numpy as np
 
 from .climate_network import ClimateNetwork
 from .climate_data import ClimateData
-from ..core.network import cached_const
+from ..core.cache import Cached
 
 
-#
-#  Define class TsonisClimateNetwork
-#
-
 # TODO: Reconsider storage of correlation matrix without taking absolute value.
 class TsonisClimateNetwork(ClimateNetwork):
 
     """
     Encapsulates a Tsonis climate network.
 
     Construct a static climate network following Tsonis et al. from the
@@ -117,17 +105,17 @@
                  time     lat     lon
            min    0.0    0.00    2.50
            max    9.0   25.00   15.00
         Threshold: 0.5
         Local connections filtered out: False
         Use only data points from winter months: False
         """
-        return ('TsonisClimateNetwork:\n%s\n'
-                'Use only data points from winter months: %s') % (
-                    ClimateNetwork.__str__(self), self.winter_only())
+        return (f'TsonisClimateNetwork:\n{ClimateNetwork.__str__(self)}\n'
+                f'Use only data points from winter months: '
+                f'{self.winter_only()}')
 
     #
     #  Methods for testing purposes
     #
 
     @staticmethod
     def SmallTestNetwork():
@@ -196,15 +184,15 @@
                       correlation matrix at zero lag.
 
         :rtype: 2D Numpy array (index, index)
         :return: the correlation matrix at zero lag.
         """
         return self._calculate_correlation(anomaly)
 
-    @cached_const('base', 'correlation')
+    @Cached.method()
     def correlation(self):
         """
         Return the correlation matrix at zero lag.
 
         **Example:**
 
         >>> TsonisClimateNetwork.SmallTestNetwork().correlation()
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/_ext/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/funcnet/_ext/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/_ext/src_numerics.c` & `pyunicorn-0.7.0/src/pyunicorn/climate/_ext/src_numerics.c`

 * *Files 20% similar despite different names*

```diff
@@ -1,28 +1,37 @@
 /*
 * !/usr/bin/python
 * -*- coding: utf-8 -*-
 *
 * This file is part of pyunicorn.
-* Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
+* Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
 * URL: <http://www.pik-potsdam.de/members/donges/software>
 * License: BSD (3-clause)
 */
 
+#include <math.h>
+#ifdef _MSC_VER
+    #include <malloc.h>
+    #define ALLOCA(sz) _alloca(sz)
+#else
+    #include <alloca.h>
+    #define ALLOCA(sz) alloca(sz)
+#endif
+
 // mutual_info ================================================================
 
-void _cython_calculate_mutual_information(float *anomaly, int n_samples,
+void _mutual_information(float *anomaly, int n_samples,
     int N, int n_bins, float scaling, float range_min, long *symbolic,
     long *hist, long *hist2d, float *mi) {
 
     long i, j, k, l, m, in_bins, jn_bins, ln_bins, in_samples, jn_samples,
          in_nodes;
     double norm, rescaled, hpl, hpm, plm;
 
-    double *p_anomaly;
+    float *p_anomaly;
     float *p_mi, *p_mi2;
     long *p_symbolic, *p_symbolic1, *p_symbolic2, *p_hist, *p_hist1,
          *p_hist2, *p_hist2d;
 
     //  Calculate histogram norm
     norm = 1.0 / n_samples;
 
@@ -40,15 +49,15 @@
 
             //  Rescale sample into interval [0,1]
             rescaled = scaling * (*p_anomaly - range_min);
 
             //  Calculate symbolic trajectories for each time series,
             //  where the symbols are bin numbers.
             if (rescaled < 1.0) {
-                *p_symbolic = rescaled * n_bins;
+                *p_symbolic = (long) (rescaled * n_bins);
             }
             else {
                 *p_symbolic = n_bins - 1;
             }
 
             //  Calculate 1d-histograms for single time series
             //  Set pointer to hist(i, *p_symbolic)
@@ -116,25 +125,25 @@
                 for (l = 0; l < n_bins; l++) {
 
                     //  Set pointer to hist(j,0)
                     p_hist2 = hist + jn_bins;
                     //  Set pointer to hist2d(l,0)
                     p_hist2d = hist2d + ln_bins;
 
-                    hpl = (*p_hist1) * norm;
+                    hpl = (double) (*p_hist1) * norm;
 
                     if (hpl > 0.0) {
                         for (m = 0; m < n_bins; m++) {
 
-                            hpm = (*p_hist2) * norm;
+                            hpm = (double) (*p_hist2) * norm;
 
                             if (hpm > 0.0) {
-                                plm = (*p_hist2d) * norm;
+                                plm = (double) (*p_hist2d) * norm;
                                 if (plm > 0.0) {
-                                    *p_mi += plm * log(plm/hpm/hpl);
+                                    *p_mi += (float) (plm * log(plm/hpm/hpl));
                                 }
                             }
 
                             //  Set pointer to hist(j,m+1)
                             p_hist2++;
                             //  Set pointer to hist2d(l,m+1)
                             p_hist2d++;
@@ -180,38 +189,36 @@
         in_nodes += N;
     }
 }
 
 
 // rainfall ===================================================================
 
-void _calculate_corr_fast(int m, int tmax, int *final_mask,
+
+void _spearman_corr(int m, int tmax, int *final_mask,
     float *time_series_ranked, float *spearman_rho)  {
 
-    double cov = 0;
-    double sigmai = 0;
-    double sigmaj = 0;
-    double meani = 0;
-    double meanj = 0;
+    double cov = 0, sigmai = 0, sigmaj = 0, meani = 0, meanj = 0;
     int zerocount = 0;
-    double rankedi[tmax];
-    double rankedj[tmax];
-    double normalizedi[tmax];
-    double normalizedj[tmax];
+    unsigned int T = (unsigned int) tmax;
+    double *rankedi = ALLOCA(T * sizeof(double)),
+           *rankedj = ALLOCA(T * sizeof(double)),
+           *normalizedi = ALLOCA(T * sizeof(double)),
+           *normalizedj = ALLOCA(T * sizeof(double));
 
     for (int i=0; i<m; i++) {
         for (int j=i; j<m; j++) {
             for (int t=0; t<tmax; t++) {
                 if ((final_mask[i*m+t] | final_mask[j*m+t]) == 0)
                     zerocount = zerocount+1;
             }
 
             for (int t=0; t<tmax; t++) {
-                rankedi[t] = time_series_ranked[i*m+t] - zerocount;
-                rankedj[t] = time_series_ranked[j*m+t] - zerocount;
+                rankedi[t] = time_series_ranked[i*m+t] - (float) zerocount;
+                rankedj[t] = time_series_ranked[j*m+t] - (float) zerocount;
             }
 
             for (int t=0; t<tmax; t++) {
                 if (rankedi[t]>=0)
                     meani = meani + rankedi[t];
                 if (rankedj[t]>=0)
                     meanj = meanj + rankedj[t];
@@ -225,18 +232,18 @@
                     normalizedi[t] = rankedi[t] - meani;
                     normalizedj[t] = rankedj[t] - meanj;
                     cov = cov + normalizedi[t]*normalizedj[t];
                     sigmai = sigmai + normalizedi[t]*normalizedi[t];
                     sigmaj = sigmaj + normalizedj[t]*normalizedj[t];
                 }
             }
-            spearman_rho[i*m+j]=spearman_rho[j*m+i] = cov/sqrt(sigmai*sigmaj);
+            spearman_rho[i*m+j] = spearman_rho[j*m+i] =
+                (float) (cov/sqrt(sigmai*sigmaj));
             meani = 0;
             meanj = 0;
             cov = 0;
             sigmai = 0;
             sigmaj = 0;
             zerocount = 0;
-
         }
     }
 }
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/_ext/numerics.pyx` & `pyunicorn-0.7.0/src/pyunicorn/climate/_ext/numerics.pyx`

 * *Files 26% similar despite different names*

```diff
@@ -1,93 +1,74 @@
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 cimport cython
-from cpython cimport bool
-
 
 import numpy as np
-cimport numpy as np
-
-
-BOOLTYPE = np.uint8
-INTTYPE = np.int
-INT8TYPE = np.int8
-INT16TYPE = np.int16
-INT32TYPE = np.int32
-INT64TYPE = np.int64
-FLOATTYPE = np.float
-FLOAT32TYPE = np.float32
-FLOAT64TYPE = np.float64
-ctypedef np.uint8_t BOOLTYPE_t
-ctypedef np.int_t INTTYPE_t
-ctypedef np.int8_t INT8TYPE_t
-ctypedef np.int16_t INT16TYPE_t
-ctypedef np.int32_t INT32TYPE_t
-ctypedef np.int64_t INT64TYPE_t
-ctypedef np.float_t FLOATTYPE_t
-ctypedef np.float32_t FLOAT32TYPE_t
-ctypedef np.float64_t FLOAT64TYPE_t
+cimport numpy as cnp
+from numpy cimport ndarray
 
+from ...core._ext.types import FIELD, DFIELD
+from ...core._ext.types cimport MASK_t, FIELD_t, DFIELD_t
 
 cdef extern from "src_numerics.c":
-    void _cython_calculate_mutual_information(
+    void _mutual_information(
             float *anomaly, int n_samples, int N, int n_bins, double scaling,
             double range_min, long *symbolic, long *hist, long *hist2d,
             float *mi)
-    void _calculate_corr_fast(int m, int tmax, int *final_mask,
+    void _spearman_corr(int m, int tmax, bint *final_mask,
             float *time_series_ranked, float *spearman_rho)
 
 
 # mutual_info =================================================================
 
-def _calculate_mutual_information_cython(
-    np.ndarray[float, ndim=2, mode='c'] anomaly not None,
-    int n_samples, int N, int n_bins, double scaling, double range_min):
+
+def mutual_information(
+    ndarray[FIELD_t, ndim=2, mode='c'] anomaly not None,
+    int n_samples, int N, int n_bins, float scaling, float range_min):
 
     cdef:
-        np.ndarray[long, ndim=2, mode='c'] symbolic = \
-            np.zeros((N, n_samples), dtype='int64')
-        np.ndarray[long, ndim=2, mode='c'] hist = \
-            np.zeros((N, n_bins), dtype='int64')
-        np.ndarray[long, ndim=2, mode='c'] hist2d = \
-            np.zeros((n_bins, n_bins), dtype='int64')
-        np.ndarray[float, ndim=2, mode='c'] mi = \
-            np.zeros((N, N), dtype='float32')
-
-    _cython_calculate_mutual_information(
-        <float*> np.PyArray_DATA(anomaly), n_samples, N, n_bins, scaling,
-        range_min, <long*> np.PyArray_DATA(symbolic),
-        <long*> np.PyArray_DATA(hist), <long*> np.PyArray_DATA(hist2d),
-        <float*> np.PyArray_DATA(mi))
+        ndarray[long, ndim=2, mode='c'] symbolic = np.zeros(
+            (N, n_samples), dtype=long)
+        ndarray[long, ndim=2, mode='c'] hist = np.zeros(
+            (N, n_bins), dtype=long)
+        ndarray[long, ndim=2, mode='c'] hist2d = np.zeros(
+            (n_bins, n_bins), dtype=long)
+        ndarray[FIELD_t, ndim=2, mode='c'] mi = np.zeros(
+            (N, N), dtype=FIELD)
+
+    _mutual_information(
+        <FIELD_t*> cnp.PyArray_DATA(anomaly), n_samples, N, n_bins, scaling,
+        range_min, <long*> cnp.PyArray_DATA(symbolic),
+        <long*> cnp.PyArray_DATA(hist), <long*> cnp.PyArray_DATA(hist2d),
+        <FIELD_t*> cnp.PyArray_DATA(mi))
 
     return mi
 
 
 # rainfall ====================================================================
 
-def _calculate_corr(int m, int tmax,
-    np.ndarray[int, ndim=2, mode='c'] final_mask not None,
-    np.ndarray[float, ndim=2, mode='c'] time_series_ranked not None):
-
-    cdef np.ndarray[float, ndim=2, mode='c'] spearman_rho = \
-            np.zeros((m, m), dtype='float32')
-
-    _calculate_corr_fast(m, tmax,
-            <int*> np.PyArray_DATA(final_mask),
-            <float*> np.PyArray_DATA(time_series_ranked),
-            <float*> np.PyArray_DATA(spearman_rho))
+
+def spearman_corr(int m, int tmax,
+    ndarray[MASK_t, ndim=2, mode='c'] final_mask not None,
+    ndarray[FIELD_t, ndim=2, mode='c'] time_series_ranked not None):
+
+    cdef ndarray[FIELD_t, ndim=2, mode='c'] spearman_rho = np.zeros(
+        (m, m), dtype=FIELD)
+
+    _spearman_corr(m, tmax,
+            <bint*> cnp.PyArray_DATA(final_mask),
+            <FIELD_t*> cnp.PyArray_DATA(time_series_ranked),
+            <FIELD_t*> cnp.PyArray_DATA(spearman_rho))
 
     return spearman_rho
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/mutual_info.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/mutual_info.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,36 +12,26 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex climate networks.
 """
 
-#
-#  Import essential packages
-#
+from typing import Tuple
+from collections.abc import Hashable
 
-# array object and fast numerics
 import numpy as np
 
-from ._ext.numerics import _calculate_mutual_information_cython
-
-#  Import progress bar for easy progress bar handling
-from ..utils import progressbar
-
-#  Import cnNetwork for Network base class
+from ..core._ext.types import to_cy, FIELD
+from ._ext.numerics import mutual_information
+from .climate_data import ClimateData
 from .climate_network import ClimateNetwork
 
-#
-#  Define class MutualInfoClimateNetwork
-#
-
 
 class MutualInfoClimateNetwork(ClimateNetwork):
-
     """
     Represents a mutual information climate network.
 
     Constructs a static climate network based on mutual information at zero
     lag, as in [Ueoka2008]_.
 
     Mutual information climate networks are undirected, since mutual
@@ -88,16 +75,17 @@
         :arg int silence_level: The inverse level of verbosity of the object.
         """
         if silence_level <= 1:
             print("Generating a mutual information climate network...")
         self.silence_level = silence_level
 
         #  Set instance variables
-        self.data = data
-        """(ClimateData) - The climate data used for network construction."""
+        assert isinstance(data, ClimateData)
+        self.data: ClimateData = data
+        """The climate data used for network construction."""
         self.N = self.data.grid.N
         self._prescribed_link_density = link_density
         self._winter_only = winter_only
 
         #  Class specific settings
         self.mi_file = "mutual_information_" + data.data_source + "_" \
             + data.observable_name + ".data"
@@ -109,14 +97,20 @@
                                 similarity_measure=self._similarity_measure,
                                 threshold=threshold,
                                 non_local=non_local,
                                 directed=False,
                                 node_weight_type=node_weight_type,
                                 silence_level=silence_level)
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return ClimateNetwork.__cache_state__(self)
+
+    def __rec_cache_state__(self) -> Tuple[object, ...]:
+        return ClimateNetwork.__rec_cache_state__(self) + (self.data,)
+
     def __str__(self):
         """
         Return a string representation of MutualInfoClimateNetwork.
         """
         return 'MutualInfoClimateNetwork:\n' + ClimateNetwork.__str__(self)
 
     def _cython_calculate_mutual_information(self, anomaly, n_bins=32):
@@ -139,126 +133,34 @@
             print("Calculating mutual information matrix at zero lag from "
                   "anomaly values using cython...")
 
         #  Normalize anomaly time series to zero mean and unit variance
         self.data.normalize_time_series_array(anomaly)
 
         #  Create local transposed copy of anomaly
-        anomaly = np.fastCopyAndTranspose(anomaly)
+        anomaly = anomaly.T.copy()
 
         (N, n_samples) = anomaly.shape
 
         #  Get common range for all histograms
         range_min = float(anomaly.min())
         range_max = float(anomaly.max())
 
         #  Rescale all time series to the interval [0,1],
         #  using the maximum range of the whole dataset.
         scaling = 1./(range_max - range_min)
 
-        anomaly = anomaly.astype(np.float32).copy(order='c')
-        mi = _calculate_mutual_information_cython(anomaly, n_samples, N,
-                                                  n_bins, scaling,
-                                                  range_min)
+        mi = mutual_information(
+            to_cy(anomaly, FIELD), n_samples, N, n_bins, scaling, range_min)
 
         if self.silence_level <= 1:
             print("Done!")
 
         return mi
 
-    def _calculate_mutual_information(self, anomaly, n_bins=32):
-        """
-        Calculate the mutual information matrix at zero lag.
-
-        .. note::
-           Slow since solely based on Python and Numpy!
-
-        :type anomaly: 2D array (time, index)
-        :arg anomaly: The anomaly time series.
-        :arg int n_bins: The number of bins for estimating probability
-                     distributions.
-        :rtype: 2D array (index, index)
-        :return: the mutual information matrix at zero lag.
-        """
-        if self.silence_level <= 1:
-            print("Calculating mutual information matrix at zero lag from "
-                  "anomaly values...")
-
-        #  Define references to numpy functions for faster function calls
-        histogram = np.histogram
-        histogram2d = np.histogram2d
-        log = np.log
-
-        #  Normalize anomaly time series to zero mean and unit variance
-        self.data.normalize_time_series_array(anomaly)
-
-        #  Get faster reference to length of time series = number of samples
-        #  per grid point.
-        n_samples = anomaly.shape[0]
-
-        #  Initialize mutual information array
-        mi = np.zeros((self.N, self.N))
-
-        #  Get common range for all histograms
-        range_min = anomaly.min()
-        range_max = anomaly.max()
-
-        #  Calculate the histograms for each time series
-        p = np.zeros((self.N, n_bins))
-
-        for i in range(self.N):
-            p[i, :] = histogram(
-                anomaly[:, i], bins=n_bins, range=(range_min, range_max)
-            )[0].astype("float64")
-
-        #  Normalize by total number of samples = length of each time series
-        p /= n_samples
-
-        #  Make sure that bins with zero estimated probability are not counted
-        #  in the entropy measures.
-        p[p == 0] = 1
-
-        #  Compute the information entropies of each time series
-        H = - (p * log(p)).sum(axis=1)
-
-        # Initialize progress bar
-        if self.silence_level <= 1:
-            progress = progressbar.ProgressBar(maxval=self.N**2).start()
-
-        #  Calculate only the lower half of the MI matrix, since MI is
-        #  symmetric with respect to X and Y.
-        for i in range(self.N):
-            # Update progress bar every 10 steps
-            if self.silence_level <= 1:
-                if (i % 10) == 0:
-                    progress.update(i**2)
-
-            for j in range(i):
-                #  Calculate the joint probability distribution
-                pxy = histogram2d(
-                    anomaly[:, i], anomaly[:, j], bins=n_bins,
-                    range=((range_min, range_max),
-                           (range_min, range_max)))[0].astype("float64")
-
-                #  Normalize joint distribution
-                pxy /= n_samples
-
-                #  Compute the joint information entropy
-                pxy[pxy == 0] = 1
-                HXY = - (pxy * log(pxy)).sum()
-
-                #  ... and store the result
-                mi.itemset((i, j), H.item(i) + H.item(j) - HXY)
-                mi.itemset((j, i), mi.item((i, j)))
-
-        if self.silence_level <= 1:
-            progress.finish()
-
-        return mi
-
     def calculate_similarity_measure(self, anomaly):
         """
         Calculate the mutual information matrix.
 
         Encapsulates calculation of mutual information with standard
         parameters.
 
@@ -287,15 +189,15 @@
         """
         try:
             #  Try to load MI from file
             if self.silence_level <= 1:
                 print("Loading mutual information matrix from "
                       f"{self.mi_file}...")
 
-            with open(self.mi_file, 'r') as f:
+            with open(self.mi_file, 'r', encoding="utf-8") as f:
                 mi = np.load(f)
                 #  Check if the dimensions of mutual_information correspond to
                 #  the grid.
                 if mi.shape != (self.N, self.N):
                     print(f"{self.mi_file} in current directory has "
                           "incorrect dimensions!")
                     raise RuntimeError
@@ -304,15 +206,15 @@
             if self.silence_level <= 1:
                 print("An error occured while loading data from "
                       f"{self.mi_file}.")
                 print("Recalculating mutual information.")
 
             mi = self._cython_calculate_mutual_information(anomaly)
             if dump:
-                with open(self.mi_file, 'w') as f:
+                with open(self.mi_file, 'w', encoding="utf-8") as f:
                     if self.silence_level <= 1:
                         print("Storing in", self.mi_file)
                     mi.dump(f)
 
         return mi
 
     def winter_only(self):
@@ -359,38 +261,35 @@
 
     def mutual_information_weighted_average_path_length(self):
         """
         Return mutual information weighted average path length.
 
         :return float: the mutual information weighted average path length.
         """
-        if "mutual_information" not in self._path_lengths_cached:
-            self.set_link_attribute("mutual_information",
-                                    abs(self.mutual_information()))
-
-        return self.average_path_length("mutual_information")
+        return self._weighted_metric(
+            "mutual_information",
+            lambda: np.abs(self.mutual_information()),
+            "average_path_length")
 
     def mutual_information_weighted_closeness(self):
         """
         Return mutual information weighted closeness.
 
         :rtype: 1D Numpy array [index]
         :return: the mutual information weighted closeness sequence.
         """
-        if "mutual_information" not in self._path_lengths_cached:
-            self.set_link_attribute("mutual_information",
-                                    abs(self.mutual_information()))
-
-        return self.closeness("mutual_information")
+        return self._weighted_metric(
+            "mutual_information",
+            lambda: np.abs(self.mutual_information()),
+            "closeness")
 
     def local_mutual_information_weighted_vulnerability(self):
         """
         Return mutual information weighted vulnerability.
 
         :rtype: 1D Numpy array [index]
         :return: the mutual information weighted vulnerability sequence.
         """
-        if "mutual_information" not in self._path_lengths_cached:
-            self.set_link_attribute("mutual_information",
-                                    abs(self.mutual_information()))
-
-        return self.local_vulnerability("mutual_information")
+        return self._weighted_metric(
+            "mutual_information",
+            lambda: np.abs(self.mutual_information()),
+            "local_vulnerability")
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/coupled_climate_network.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/coupled_climate_network.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,34 +12,21 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex coupled climate networks.
 """
 
-#
-#  Import essential packages
-#
-
-#  Import NumPy for the array object and fast numerics
 import numpy as np
 
-#  Import climate_network for ClimateNetwork class
+from ..core import InteractingNetworks, GeoNetwork, GeoGrid
 from .climate_network import ClimateNetwork
 
-#  Import grid for Grid class
-from ..core import InteractingNetworks, GeoNetwork, Grid
-
-
-#
-#  Define class CoupledClimateNetwork
-#
 
 class CoupledClimateNetwork(InteractingNetworks, ClimateNetwork):
-
     """
     Encapsulates a coupled similarity network embedded on a spherical surface.
 
     Particularly provides functionality to generate a complex network from the
     matrix of a similarity measure of time series from two different
     observables (temperature, pressure), vertical levels etc.
 
@@ -69,19 +53,19 @@
            Either threshold **OR** link_density have to be given!
 
         Possible choices for ``node_weight_type``:
           - None (constant unit weights)
           - "surface" (cos lat)
           - "irrigation" (cos**2 lat)
 
-        :type grid_1: :class:`.Grid`
-        :arg  grid_1: The Grid object describing the first layer's spatial
+        :type grid_1: :class:`.GeoGrid`
+        :arg  grid_1: The GeoGrid object describing the first layer's spatial
             embedding.
-        :type grid_2: :class:`.Grid`
-        :arg  grid_2: The Grid object describing the second layer's spatial
+        :type grid_2: :class:`.GeoGrid`
+        :arg  grid_2: The GeoGrid object describing the second layer's spatial
             embedding.
         :type similarity_measure: 2D array [index, index]
         :arg similarity_measure: The similarity measure for all pairs of nodes.
         :arg float threshold: The threshold of similarity measure, above which
             two nodes are linked in the network.
         :arg float link_density: The networks's desired link density.
         :arg bool non_local: Determines, whether links between spatially close
@@ -90,46 +74,46 @@
             directed.
         :arg strnode_weight_type: The type of geographical node weight to be
             used.
         :arg int silence_level: The inverse level of verbosity of the object.
         """
         #  Store single grids
         self.grid_1 = grid_1
-        """(Grid) - The Grid object describing the first layer's spatial
+        """(Grid) - The GeoGrid object describing the first layer's spatial
                     embedding."""
         self.grid_2 = grid_2
-        """(Grid) - The Grid object describing the second layer's spatial
+        """(Grid) - The GeoGrid object describing the second layer's spatial
                     embedding."""
 
         #  Construct grid object describing both layers
         time_1 = grid_1.grid()["time"]
         lat_1 = grid_1.grid()["lat"]
         lon_1 = grid_1.grid()["lon"]
 
         time_2 = grid_2.grid()["time"]
         lat_2 = grid_2.grid()["lat"]
         lon_2 = grid_2.grid()["lon"]
 
         if len(time_1) == len(time_2):
-            grid = Grid(time_1, np.concatenate((lat_1, lat_2)),
-                        np.concatenate((lon_1, lon_2)))
+            grid = GeoGrid(time_1, np.concatenate((lat_1, lat_2)),
+                           np.concatenate((lon_1, lon_2)))
             #  Set total number of nodes
             self.N = grid.N
             """(number (int)) - The total number of nodes in both layers."""
 
             #  Set number of nodes for both layers
             self.N_1 = len(lat_1)
             """(number (int)) - The number of nodes in the first layer."""
             self.N_2 = len(lat_2)
             """(number (int)) - The number of nodes in the second layer."""
 
             #  Create lists of node indices for both layers
-            self.nodes_1 = range(self.N_1)
+            self.nodes_1 = list(range(self.N_1))
             """(list (int)) - List of node indices for first layer"""
-            self.nodes_2 = range(self.N_1, self.N)
+            self.nodes_2 = list(range(self.N_1, self.N))
             """(list (int)) - List of node indices for second layer"""
 
             #  Call the constructor of the parent class ClimateNetwork
             ClimateNetwork.__init__(self, grid=grid,
                                     similarity_measure=similarity_measure,
                                     threshold=threshold,
                                     link_density=link_density,
@@ -142,16 +126,16 @@
             print("The two observables (layers) have to have the same number "
                   "of temporal sampling points!")
 
     def __str__(self):
         """
         Return a string representation of CoupledClimateNetwork object.
         """
-        return 'CoupledClimateNetwork:\n%s\nN1: %s\nN2: %s' % (
-            ClimateNetwork.__str__(self), self.N_1, self.N_2)
+        return (f'CoupledClimateNetwork:\n{ClimateNetwork.__str__(self)}\n'
+                f'N1: {self.N_1}\nN2: self.N_2')
 
     #
     #  Define methods for handling the coupled network
     #
 
     def network_1(self):
         """
@@ -307,14 +291,25 @@
         :return: the cross path length matrix.
         """
         return InteractingNetworks.\
             cross_path_lengths(self, node_list1=self.nodes_1,
                                node_list2=self.nodes_2,
                                link_attribute=link_attribute)
 
+    def cross_link_distance(self):
+        """
+        Return cross link distance matrix.
+
+        Contains the distance between nodes from different layers.
+
+        :rtype: 2D array [index_1, index_2]
+        :return: the cross link distance matrix.
+        """
+        return self.distance()[self.nodes_1, :][:, self.nodes_2]
+
     #
     #  Define scalar coupled network statistics
     #
 
     def number_cross_layer_links(self):
         """
         Return the number of links between the two layers.
@@ -422,14 +417,38 @@
         """
         ct_12 = InteractingNetworks.cross_transitivity(
             self, node_list1=self.nodes_1, node_list2=self.nodes_2)
         ct_21 = InteractingNetworks.cross_transitivity(
             self, node_list1=self.nodes_2, node_list2=self.nodes_1)
         return (ct_12, ct_21)
 
+    def cross_average_link_distance(self, reverse=False):
+        """
+        Return the cross average link distance
+
+        The cross average link distance is the average link distance of each
+        node of the first subnetwork to the nodes of the second subnetwork
+        it is connected to. If reverse is set to True, the method calculates
+        the average link distance of each node of the second subnetwork to the
+        nodes of the first subnetwork.
+
+        :arg bool reverse: Replace the subnetworks.
+
+        :rtype: 1D Numpy array
+        :return: the cross average link distances
+        """
+        if reverse:
+            ax = 0
+        else:
+            ax = 1
+
+        adj = self.cross_layer_adjacency()
+        cld = self.cross_link_distance()
+        return np.sum(adj*cld, axis=ax) / np.sum(adj, axis=ax)
+
     def cross_average_path_length(self, link_attribute=None):
         """
         Return cross average path length.
 
         Return the average (weighted) shortest path length between all pairs
         of nodes from different layers only.
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/havlin.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/havlin.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,32 +12,24 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex climate networks.
 """
 
-#
-#  Import essential packages
-#
+from typing import Tuple
+from collections.abc import Hashable
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
+from tqdm import trange
 
-#  Import progress bar for easy progress bar handling
-from ..utils import progressbar
-
-#  Import cnNetwork for Network base class
+from .climate_data import ClimateData
 from .climate_network import ClimateNetwork
 
 
-#
-#  Define class HavlinClimateNetwork
-#
-
 class HavlinClimateNetwork(ClimateNetwork):
 
     """
     Encapsulates a Havlin climate network.
 
     The similarity matrix associated with a Havlin climate network is the
     maximum-lag correlation matrix with each entry normalized by the
@@ -89,54 +78,54 @@
         if silence_level <= 1:
             print("Generating a Havlin climate network...")
         self.silence_level = silence_level
 
         #  Set instance variables
         self._max_delay = 0
         self._correlation_lag = None
-        self.data = data
-        """(ClimateData) - The climate data used for network construction."""
+        assert isinstance(data, ClimateData)
+        self.data: ClimateData = data
+        """The climate data used for network construction."""
         self.N = data.grid.N
         self._prescribed_link_density = link_density
 
+        self._mut_clim: int = 0
         self._set_max_delay(max_delay)
         ClimateNetwork.__init__(self, grid=self.data.grid,
                                 similarity_measure=self._similarity_measure,
                                 threshold=threshold,
                                 link_density=link_density,
                                 non_local=non_local,
                                 directed=False,
                                 node_weight_type=node_weight_type,
                                 silence_level=silence_level)
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return ClimateNetwork.__cache_state__(self)
+
+    def __rec_cache_state__(self) -> Tuple[object, ...]:
+        return ClimateNetwork.__rec_cache_state__(self) + (self.data,)
+
     def __str__(self):
         """
         Return a string version of the instance of HavlinClimateNetwork.
         """
-        return (f'HavlinClimateNetwork:\n'
-                '{ClimateNetwork.__str__(self)}\n'
-                'Maximum delay used for correlation strength estimation: '
-                '{self.get_max_delay()}')
+        return f'HavlinClimateNetwork:\n \
+                {ClimateNetwork.__str__(self)}\n \
+                Maximum delay used for correlation strength estimation: \
+                {self.get_max_delay()}'
 
-    def clear_cache(self, irreversible=False):
+    def clear_cache(self):
         """
         Clean up cache.
-
-        If irreversible=True, the network cannot be recalculated using a
-        different threshold, or link density.
-
-        :arg bool irreversible: The irreversibility of clearing the cache.
         """
-        ClimateNetwork.clear_cache(self, irreversible)
-
-        if irreversible:
-            try:
-                del self._correlation_lag
-            except AttributeError:
-                pass
+        try:
+            del self._correlation_lag
+        except AttributeError:
+            pass
 
     #
     #  Defines methods to calculate correlation strength and lags
     #
 
     #  TODO: Implement an algorithm, which is NOT based on FFT!
     def _calculate_correlation_strength(self, anomaly, max_delay, gamma=0.2):
@@ -151,47 +140,27 @@
         :arg anomaly: The anomaly data for network construction.
         :arg int max_delay: The maximum delay for cross-correlation functions.
         :arg float gamma: The width of decay region in cosine shaped window
             used for FFT cross-correlation estimation.
         :rtype: tuple of two 2D arrays [index, index]
         :return: the correlation strength and maximum lag matrices.
         """
-        if self.silence_level <= 1:
-            print("Calculating correlation strength matrix "
-                  "following [Yamasaki2008]_...")
-
-        #  Initialize
         N = self.N
-
-        #  Normalize anomaly time series to zero mean and unit variance
         self.data.normalize_time_series_array(anomaly)
-
-        #  Apply cosine window to anomaly data
         anomaly *= self.data.cos_window(anomaly, gamma)
-
         #  Zero pad windowed data to set the length of each time series to
         #  a power of two
         anomaly = self.data.zero_pad_data(anomaly)
-
         correlation_strength = np.empty((N, N))
         max_lag_matrix = np.empty((N, N))
 
-        #  Initialize progress bar
-        if self.silence_level <= 1:
-            progress = progressbar.ProgressBar(maxval=N).start()
-
         #  Calculate the inverse Fourier transform of all time series
         ifft = np.fft.ifft(anomaly, axis=0)
 
-        for i in range(N):
-            # Update progress bar every 10 steps
-            if self.silence_level <= 1:
-                if (i % 10) == 0:
-                    progress.update(i)
-
+        for i in trange(N, disable=self.silence_level > 1):
             #  Calculate the cross correlation function of node i to all other
             #  nodes which is not normalized yet.
             #  The real part has to be taken to get rid of small imaginary
             #  parts due to rounding errors.
             cc_one_to_all = np.conjugate(np.tile(ifft[:, i],
                                                  (N, 1)).transpose()) * ifft
             cc_one_to_all = np.real(np.fft.fft(cc_one_to_all, axis=0))
@@ -209,17 +178,14 @@
             #  Store correlation strengths
             correlation_strength[i, :] = \
                 cc_one_to_all.max(axis=0) / cc_one_to_all.std(axis=0)
 
             #  Store time delays at maximum cross correlation
             max_lag_matrix[i, :] = cc_one_to_all.argmax(axis=0) - max_delay
 
-        if self.silence_level <= 1:
-            progress.finish()
-
         return (correlation_strength, max_lag_matrix)
 
     def get_max_delay(self):
         """
         Return the maximum delay used for cross-correlation estimation.
 
         :return float: the maximum delay used for cross-correlation estimation.
@@ -228,18 +194,16 @@
 
     def _set_max_delay(self, max_delay):
         """
         Set the maximum lag time used for cross-correlation estimation.
 
         :arg int max_delay: The maximum delay for cross-correlation functions.
         """
-        #  Set class variable _max_delay
+        self._mut_clim += 1
         self._max_delay = max_delay
-
-        #  Calculate correlation strength and lag
         results = self._calculate_correlation_strength(self.data.anomaly(),
                                                        max_delay)
         self._similarity_measure = results[0]
         self._correlation_lag = results[1]
 
     def set_max_delay(self, max_delay):
         """
@@ -255,105 +219,91 @@
     def correlation_strength(self):
         """
         Return the correlation strength matrix.
 
         :rtype: 2D array [index, index]
         :return: the correlation strength matrix.
         """
-        try:
-            return self._similarity_measure
-        except AttributeError:
-            print("Correlation strength matrix was deleted earlier and "
-                  "cannot be retrieved.")
+        return self._similarity_measure
 
     def correlation_lag(self):
         """
         Return the lag at maximum cross-correlation matrix.
 
         :rtype: 2D array [index, index]
         :return: the lag at maximum cross-correlation matrix.
         """
-        try:
-            return self._correlation_lag
-        except AttributeError:
-            print("Lag matrix was deleted earlier and "
-                  "cannot be retrieved.")
+        return self._correlation_lag
 
     #
     #  Methods to calculate weighted network measures
     #
 
     def correlation_strength_weighted_average_path_length(self):
         """
         Return correlation strength weighted average path length.
 
         :return float: the correlation strength weighted average path length.
         """
-        if "correlation_strength" not in self._path_lengths_cached:
-            self.set_link_attribute("correlation_strength",
-                                    np.abs(self.correlation_strength()))
-
-        return self.average_path_length("correlation_strength")
+        return self._weighted_metric(
+            "correlation_strength",
+            lambda: np.abs(self.correlation_strength()),
+            "average_path_length")
 
     def correlation_strength_weighted_closeness(self):
         """
         Return correlation strength weighted closeness.
 
         :rtype: 1D array [index]
         :return: the correlation strength weighted closeness sequence.
         """
-        if "correlation_strength" not in self._path_lengths_cached:
-            self.set_link_attribute("correlation_strength",
-                                    np.abs(self.correlation_strength()))
-
-        return self.closeness("correlation_strength")
+        return self._weighted_metric(
+            "correlation_strength",
+            lambda: np.abs(self.correlation_strength()),
+            "closeness")
 
     def correlation_lag_weighted_average_path_length(self):
         """
         Return correlation lag weighted average path length.
 
         :return float: the correlation lag weighted average path length.
         """
-        if "correlation_lag" not in self._path_lengths_cached:
-            self.set_link_attribute("correlation_lag",
-                                    np.abs(self.correlation_lag()))
-
-        return self.average_path_length("correlation_lag")
+        return self._weighted_metric(
+            "correlation_lag",
+            lambda: np.abs(self.correlation_lag()),
+            "average_path_length")
 
     def correlation_lag_weighted_closeness(self):
         """
         Return correlation lag weighted closeness.
 
         :rtype: 1D array [index]
         :return: the correlation lag weighted closeness sequence.
         """
-        if "correlation_lag" not in self._path_lengths_cached:
-            self.set_link_attribute("correlation_lag",
-                                    np.abs(self.correlation_lag()))
-
-        return self.closeness("correlation_lag")
+        return self._weighted_metric(
+            "correlation_lag",
+            lambda: np.abs(self.correlation_lag()),
+            "closeness")
 
     def local_correlation_strength_weighted_vulnerability(self):
         """
         Return correlation strength weighted vulnerability.
 
         :rtype: 1D array [index]
         :return: the correlation strength weighted vulnerability sequence.
         """
-        if "correlation_strength" not in self._path_lengths_cached:
-            self.set_link_attribute("correlation_strength",
-                                    np.abs(self.correlation_strength()))
-
-        return self.local_vulnerability("correlation_strength")
+        return self._weighted_metric(
+            "correlation_strength",
+            lambda: np.abs(self.correlation_strength()),
+            "local_vulnerability")
 
     def local_correlation_lag_weighted_vulnerability(self):
         """
         Return correlation lag weighted vulnerability.
 
         :rtype: 1D array [index]
         :return: the correlation lag weighted vulnerability sequence.
         """
-        if "correlation_lag" not in self._path_lengths_cached:
-            self.set_link_attribute("correlation_lag",
-                                    np.abs(self.correlation_lag()))
-
-        return self.local_vulnerability("correlation_lag")
+        return self._weighted_metric(
+            "correlation_lag",
+            lambda: np.abs(self.correlation_lag()),
+            "local_vulnerability")
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/climate_network.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/climate_network.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,33 +12,24 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex climate networks.
 """
 
-#
-#  Import essential packages
-#
+from typing import Tuple
+from collections.abc import Hashable, Callable
 
-#  Import NumPy for the array object and fast numerics
 import numpy as np
-
-#  Import iGraph for high performance graph theory tools written in pure ANSI-C
 import igraph
 
-#  Import GeoNetwork and Grid classes
-from ..core import GeoNetwork, Grid
-from ..core.network import cached_const
+from ..core.cache import Cached
+from ..core import GeoNetwork, GeoGrid
 
 
-#
-#  Define class ClimateNetwork
-#
-
 class ClimateNetwork(GeoNetwork):
 
     """
     Encapsulates a similarity network embedded on a spherical surface.
 
     Particularly provides functionality to generate a complex network from the
     matrix of a similarity measure of time series.
@@ -49,48 +37,56 @@
     The analysis of climate time series based on similarity networks was first
     introduced in [Tsonis2004]_.
     """
     #
     #  Definitions of internal methods
     #
 
-    def __init__(self, grid, similarity_measure, threshold=None,
-                 link_density=None, non_local=False, directed=False,
-                 node_weight_type="surface", silence_level=0):
+    def __init__(self, grid: GeoGrid, similarity_measure: np.ndarray,
+                 threshold=None, link_density=None, non_local=False,
+                 directed=False, node_weight_type="surface", silence_level=0):
         """
         Initialize an instance of :class:`ClimateNetwork`.
 
         .. note::
            Either threshold **OR** link_density have to be given!
 
         Possible choices for ``node_weight_type``:
           - None (constant unit weights)
           - "surface" (cos lat)
           - "irrigation" (cos**2 lat)
 
-        :type grid: :class:`.Grid`
-        :arg  grid: The Grid object describing the network's spatial embedding.
+        :type grid: :class:`.GeoGrid`
+        :arg  grid: The GeoGrid object describing the network's spatial
+            embedding.
         :type similarity_measure: 2D array [index, index]
         :arg similarity_measure: The similarity measure for all pairs of nodes.
         :arg float threshold: The threshold of similarity measure, above which
             two nodes are linked in the network.
         :arg float link_density: The networks's desired link density.
         :arg bool non_local: Determines, whether links between spatially close
             nodes should be suppressed.
         :arg bool directed: Determines, whether the network is treated as
             directed.
         :arg str node_weight_type: The type of geographical node weight to be
             used.
         :arg int silence_level: The inverse level of verbosity of the object.
         """
         #  Initialize
-        self.grid = grid
+        assert isinstance(grid, GeoGrid)
+        self.grid: GeoGrid = grid
         self.directed = directed
         self.silence_level = silence_level
 
+        # mutation count
+        if not hasattr(self, "_mut_clim"):
+            self._mut_clim: int = 0
+        else:
+            self._mut_clim += 1
+
         #  FIXME: Is taking the absolute value by default OK?
         self._similarity_measure = np.abs(similarity_measure.astype("float32"))
         self._non_local = non_local
         self.N = grid.N
         self.node_weight_type = node_weight_type
 
         #  Sets the threshold and generates the network by thresholding and
@@ -103,14 +99,20 @@
             print("Either threshold or link_density have to be prescribed "
                   "for network construction!")
         GeoNetwork.__init__(self, adjacency=self.adjacency, grid=self.grid,
                             directed=self.directed,
                             node_weight_type=self.node_weight_type,
                             silence_level=self.silence_level)
 
+    def __cache_state__(self) -> Tuple[Hashable, ...]:
+        return GeoNetwork.__cache_state__(self) + (self._mut_clim,)
+
+    def __rec_cache_state__(self) -> Tuple[object, ...]:
+        return (self.grid,)
+
     def __str__(self):
         """
         Return a string representation of the ClimateNetwork object.
 
         **Example:**
 
         >>> print(ClimateNetwork.SmallTestNetwork())
@@ -120,39 +122,21 @@
         Geographical boundaries:
                  time     lat     lon
            min    0.0    0.00    2.50
            max    9.0   25.00   15.00
         Threshold: 0.5
         Local connections filtered out: False
         """
-        return ('ClimateNetwork:\n%s\nThreshold: %s\n'
-                'Local connections filtered out: %s') % (
-                    GeoNetwork.__str__(self), self.threshold(),
-                    self.non_local())
-
-    def clear_cache(self, irreversible=False):
-        """
-        Clean up cache.
-
-        If irreversible=True, the network cannot be recalculated using a
-        different threshold, or link density.
-
-        :arg bool irreversible: The irreversibility of clearing the cache.
-        """
-        GeoNetwork.clear_cache(self)
-
-        if irreversible:
-            try:
-                del self._similarity_measure
-            except AttributeError:
-                pass
+        return (f'ClimateNetwork:\n{GeoNetwork.__str__(self)}\n' +
+                f'Threshold: {self.threshold()}\n' +
+                f'Local connections filtered out: {self.non_local()}')
 
     def _regenerate_network(self):
         """
-        Regenerate the current climate network according to new similarity
+        Regenerate the current climate network according to a new similarity
         measure.
         """
         ClimateNetwork.__init__(self, grid=self.data.grid,
                                 similarity_measure=self._similarity_measure,
                                 threshold=self._threshold,
                                 link_density=self.link_density,
                                 non_local=self._non_local,
@@ -160,17 +144,15 @@
                                 node_weight_type=self.node_weight_type,
                                 silence_level=self.silence_level)
 
     #
     #  Load and save ClimateNetwork object
     #
 
-    def save(self, filename_network, filename_grid=None,
-             filename_similarity_measure=None, fileformat=None, *args,
-             **kwds):
+    def save(self, filename, fileformat=None, *args, **kwds):
         """
         Save the ClimateNetwork object to files.
 
         Unified writing function for graphs. Relies on and partially extends
         the corresponding igraph function. Refer to igraph documentation for
         further details on the various writer methods for different formats.
 
@@ -185,45 +167,50 @@
         .. note::
            The similarity measure matrix and grid are not stored if
            the corresponding filenames are None.
 
         The remaining arguments are passed to the writer method without
         any changes.
 
-        :arg str filename_network:  The name of the file where the Network
-            object is to be stored.
-        :arg str filename_grid:  The name of the file where the Grid object is
-            to be stored (including ending).
-        :arg str filename_similarity_measure:  The name of the file where the
-            similarity measure matrix is to be stored.
+        :arg tuple/list filename: Tuple or list of three strings, namely
+            the paths to the files where the Network object, the
+            GeoGrid object and the similarity measure matrix are to be stored.
         :arg str fileformat: the format of the file (if one wants to override
             the format determined from the filename extension, or the filename
             itself is a stream). ``None`` means auto-detection.  Possible
             values are: ``"ncol"`` (NCOL format), ``"lgl"`` (LGL format),
             ``"graphml"``, ``"graphmlz"`` (GraphML and gzipped GraphML format),
             ``"gml"`` (GML format), ``"dot"``, ``"graphviz"`` (DOT format, used
             by GraphViz), ``"net"``, ``"pajek"`` (Pajek format), ``"dimacs"``
             (DIMACS format), ``"edgelist"``, ``"edges"`` or ``"edge"`` (edge
             list), ``"adjacency"`` (adjacency matrix), ``"pickle"`` (Python
             pickled format), ``"svg"`` (Scalable Vector Graphics).
+        :arg str filename_similarity_measure:  The name of the file where the
+            similarity measure matrix is to be stored.
         """
+        try:
+            (filename_network, filename_grid,
+             filename_similarity_measure) = filename
+        except ValueError as e:
+            raise ValueError("'filename' must be a tuple or list of three "
+                             "items: filename_network, filename_grid, "
+                             "filename_similarity_measure") from e
+
         #  Store GeoNetwork
-        GeoNetwork.save(self, filename_network=filename_network,
-                        filename_grid=filename_grid,
+        GeoNetwork.save(self, filename=(filename_network, filename_grid),
                         fileformat=fileformat,
                         *args, **kwds)
 
         #  Store similarity measure
         if filename_similarity_measure is not None:
             similarity_measure = self.similarity_measure()
             similarity_measure.dump(filename_similarity_measure)
 
     @staticmethod
-    def Load(filename_network, filename_grid, filename_similarity_measure,
-             fileformat=None, *args, **kwds):
+    def Load(filename, fileformat=None, silence_level=0, *args, **kwds):
         """
         Return a ClimateNetwork object stored in files.
 
         Unified reading function for graphs. Relies on and partially extends
         the corresponding igraph function. Refer to igraph documentation for
         further details on the various reader methods for different formats.
 
@@ -233,32 +220,38 @@
         Existing node and link attributes/weights are also restored depending
         on the chosen file format. E.g., the formats GraphML and gzipped
         GraphML are able to store both node and link weights.
 
         The remaining arguments are passed to the reader method without
         any changes.
 
-        :arg str filename_network:  The name of the file where the Network
-            object is to be stored.
-        :arg str filename_grid:  The name of the file where the Grid object is
-            to be stored (including ending).
-        :arg str filename_similarity_measure:  The name of the file where the
-            similarity measure matrix is to be stored.
+        :arg tuple/list filename: Tuple or list of three strings, namely
+            the paths to the files containing the Network object, the
+            GeoGrid object and the similarity measure matrix.
+            (filename_network, filename_grid, filename_similarity_measure)
         :arg str fileformat: the format of the file (if known in advance)
             ``None`` means auto-detection. Possible values are: ``"ncol"``
             (NCOL format), ``"lgl"`` (LGL format), ``"graphml"``,
             ``"graphmlz"`` (GraphML and gzipped GraphML format), ``"gml"`` (GML
             format), ``"net"``, ``"pajek"`` (Pajek format), ``"dimacs"``
             (DIMACS format), ``"edgelist"``, ``"edges"`` or ``"edge"`` (edge
             list), ``"adjacency"`` (adjacency matrix), ``"pickle"`` (Python
             pickled format).
         :return: :class:`ClimateNetwork` instance.
         """
-        #  Load Grid object
-        grid = Grid.Load(filename_grid)
+        try:
+            (filename_network, filename_grid,
+             filename_similarity_measure) = filename
+        except ValueError as e:
+            raise ValueError("'filename' must be a tuple or list of three "
+                             "items: filename_network, filename_grid, "
+                             "filename_similarity_measure") from e
+
+        #  Load GeoGrid object
+        grid = GeoGrid.Load(filename_grid)
 
         #  Load similarity measure
         similarity_measure = np.load(filename_similarity_measure)
 
         #  Load to igraph Graph object
         graph = igraph.Graph.Read(f=filename_network, format=fileformat,
                                   *args, **kwds)
@@ -271,24 +264,24 @@
             node_weights = np.array(
                 graph.vs.get_attribute_values("node_weight_nsi"))
         else:
             node_weights = None
 
         #  Create ClimateNetwork instance
         net = ClimateNetwork(grid=grid, similarity_measure=similarity_measure,
-                             directed=graph.is_directed())
+                             directed=graph.is_directed(),
+                             silence_level=silence_level)
         net.adjacency = A
         net.node_weights = node_weights
 
         #  Overwrite igraph Graph object in Network instance to restore link
         #  attributes/weights
         net.graph = graph
-        #  Restore link attributes/weights
-        net.clear_paths_cache()
-
+        #  invalidate cache
+        net._mut_la += 1
         return net
 
     #
     #  Methods for testing purposes
     #
 
     @staticmethod
@@ -307,15 +300,15 @@
 
         >>> r(ClimateNetwork.SmallTestNetwork().adjacency)
         array([[0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0],
                [1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0]])
 
         :rtype: :class:`.Network` instance
         """
-        return ClimateNetwork(grid=Grid.SmallTestGrid(),
+        return ClimateNetwork(grid=GeoGrid.SmallTestGrid(),
                               similarity_measure=np.array(
                                   [[1.0, 0.1, 0.2, 0.6, 0.7, 0.55],
                                    [0.1, 1.0, 0.55, 0.9, 1.0, 0.3],
                                    [0.2, 0.55, 1.0, 0.2, 0.8, 0.1],
                                    [0.6, 0.9, 0.1, 1.0, 0.1, 0.3],
                                    [0.7, 1.0, 0.8, 0.1, 1.0, 0.4],
                                    [0.55, 0.3, 0.1, 0.3, 0.4, 1.0]]),
@@ -483,21 +476,20 @@
         :rtype:  2D Numpy array (int8) [index, index]
         :return: the network's adjacency matrix.
         """
         if self.silence_level <= 1:
             print("Extracting network adjacency matrix removing local "
                   "connections...")
 
-        #  This function provides a smooth transition of distance weight
-        #  centered around distance d_min.
-        #  Other sigmoidal type functions could be used as well.
-        f = lambda x, a, b: 0.5 * (np.tanh(a * (x - b)) + 1)
-
         weighted_similarity = similarity_measure * \
-            f(self.grid.angular_distance(), a, d_min)
+            (0.5 * (np.tanh(a * (self.grid.angular_distance() - d_min)) + 1))
+        # The above line is a function that provides a smooth
+        # transition of distance weight, centered around distance d_min.
+        # Other sigmoidal type functions could be used as well.
+
         return self._calculate_threshold_adjacency(weighted_similarity,
                                                    threshold)
 
     def similarity_measure(self):
         """
         Return the similarity measure used for network construction.
 
@@ -507,17 +499,17 @@
         array([ 1. , 0.1 , 0.2 , 0.6 , 0.7 , 0.55])
 
         :rtype: 2D Numpy array [index, index]
         :return: The similarity measure for all pairs of nodes.
         """
         try:
             return self._similarity_measure
-        except AttributeError:
-            print("The similarity matrix was deleted earlier and cannot be "
-                  "returned.")
+        except AttributeError as e:
+            raise AttributeError("Similarity matrix was deleted "
+                                 "earlier and cannot be retrieved.") from e
 
     def non_local(self):
         """
         Indicate if links between spatially close nodes were suppressed.
 
         **Example:**
 
@@ -616,15 +608,15 @@
 
         :type link_density: number (float)
         :arg link_density: The networks's desired link density.
         """
         threshold = self.threshold_from_link_density(link_density)
         self.set_threshold(threshold)
 
-    @cached_const('base', 'correlation_distance')
+    @Cached.method()
     def correlation_distance(self):
         """
         Return correlation weighted distances between nodes.
 
         Defined as the elementwise product of the correlation measure and
         angular great circle distance matrices.
 
@@ -648,15 +640,15 @@
                [ 0.27, 0.12, 0.03, 0.06, 0.04, 0.  ]])
 
         :rtype: 2D matrix [index, index]
         :return: the correlation distance matrix.
         """
         return self.similarity_measure() * self.grid.angular_distance()
 
-    @cached_const('base', 'inv_correlation_distance')
+    @Cached.method()
     def inv_correlation_distance(self):
         """
         Return correlation weighted distances between nodes.
 
         :rtype: 2D matrix [index, index]
         """
         m = self.correlation_distance()
@@ -709,7 +701,12 @@
 
         :rtype: 1D Numpy array
         :return: the local correlation distance weighted vulnerability
                  sequence.
         """
         self.inv_correlation_distance()
         return self.local_vulnerability('inv_correlation_distance')
+
+    def _weighted_metric(self, attr: str, calc: Callable, metric: str):
+        if not self.find_link_attribute(attr):
+            self.set_link_attribute(attr, calc())
+        return getattr(self, metric)(attr)
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/partial_correlation.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/partial_correlation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
```

### Comparing `pyunicorn-0.6.1/pyunicorn/climate/coupled_tsonis.py` & `pyunicorn-0.7.0/src/pyunicorn/climate/coupled_tsonis.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -15,29 +12,20 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Provides classes for generating and analyzing complex coupled climate networks.
 """
 
-#
-#  Import essential packages
-#
-
-#  Import NumPy for the array object and fast numerics
 import numpy as np
 
-#  Import climate_network for CoupledClimateNetwork class
 from .coupled_climate_network import CoupledClimateNetwork
 
 
-#
-#  Define class CoupledClimateNetwork
-#
-
+# pylint: disable=too-many-ancestors
 class CoupledTsonisClimateNetwork(CoupledClimateNetwork):
 
     """
     Encapsulates a coupled similarity network embedded on a spherical surface.
 
     Particularly provides functionality to generate a complex network from the
     Pearson correlation matrix of time series from two different
```

### Comparing `pyunicorn-0.6.1/pyunicorn.egg-info/SOURCES.txt` & `pyunicorn-0.7.0/src/pyunicorn.egg-info/SOURCES.txt`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,15 @@
+CHANGELOG.rst
 CONTRIBUTIONS.rst
 LICENSE.txt
 MANIFEST.in
 README.rst
-pylintrc
-pytest.ini
-requirements.txt
+pyproject.toml
+setup.cfg
 setup.py
-tox.ini
 docs/Makefile
 docs/source/api_doc.rst
 docs/source/changelog.rst
 docs/source/conf.py
 docs/source/contact.rst
 docs/source/development.rst
 docs/source/download.rst
@@ -33,127 +32,140 @@
 docs/source/api/climate/map_plots.rst
 docs/source/api/climate/mutual_info.rst
 docs/source/api/climate/partial_correlation.rst
 docs/source/api/climate/rainfall.rst
 docs/source/api/climate/spearman.rst
 docs/source/api/climate/tsonis.rst
 docs/source/api/core/data.rst
+docs/source/api/core/geo_grid.rst
 docs/source/api/core/geo_network.rst
 docs/source/api/core/grid.rst
 docs/source/api/core/interacting_networks.rst
 docs/source/api/core/netcdf_dictionary.rst
 docs/source/api/core/network.rst
 docs/source/api/core/resistive_network.rst
-docs/source/api/eventseries/eca.rst
+docs/source/api/core/spatial_network.rst
+docs/source/api/eventseries/event_series.rst
 docs/source/api/funcnet/coupling_analysis.rst
 docs/source/api/funcnet/coupling_analysis_pure_python.rst
 docs/source/api/timeseries/cross_recurrence_plot.rst
 docs/source/api/timeseries/inter_system_recurrence_network.rst
 docs/source/api/timeseries/joint_recurrence_network.rst
 docs/source/api/timeseries/joint_recurrence_plot.rst
 docs/source/api/timeseries/recurrence_network.rst
 docs/source/api/timeseries/recurrence_plot.rst
 docs/source/api/timeseries/surrogates.rst
 docs/source/api/timeseries/visibility_graph.rst
 docs/source/api/utils/mpi.rst
 docs/source/api/utils/navigator.rst
-docs/source/tutorials/climate_network_1.rst
-docs/source/tutorials/recurrence_network_1.rst
+docs/source/tutorials/ClimateNetworks.nblink
+docs/source/tutorials/CoupledClimateNetworks.nblink
+docs/source/tutorials/EventSeriesAnalysis.nblink
+docs/source/tutorials/RecurrenceNetworks.nblink
+docs/source/tutorials/VisibilityGraphs.nblink
 examples/modules/mpi/network_large.py
 examples/modules/mpi/network_mc.py
 examples/modules/mpi/network_scan_no_comm.py
 examples/modules/timeseries/recurrence_network.py
-examples/tutorials/climate_network.py
-examples/tutorials/recurrence_network.py
-pyunicorn/__init__.py
-pyunicorn/conftest.py
-pyunicorn.egg-info/PKG-INFO
-pyunicorn.egg-info/SOURCES.txt
-pyunicorn.egg-info/dependency_links.txt
-pyunicorn.egg-info/requires.txt
-pyunicorn.egg-info/top_level.txt
-pyunicorn/climate/__init__.py
-pyunicorn/climate/climate_data.py
-pyunicorn/climate/climate_network.py
-pyunicorn/climate/coupled_climate_network.py
-pyunicorn/climate/coupled_tsonis.py
-pyunicorn/climate/eventsynchronization_climatenetwork.py
-pyunicorn/climate/havlin.py
-pyunicorn/climate/hilbert.py
-pyunicorn/climate/map_plots.py
-pyunicorn/climate/mutual_info.py
-pyunicorn/climate/partial_correlation.py
-pyunicorn/climate/rainfall.py
-pyunicorn/climate/spearman.py
-pyunicorn/climate/tsonis.py
-pyunicorn/climate/_ext/__init__.py
-pyunicorn/climate/_ext/numerics.c
-pyunicorn/climate/_ext/numerics.pyx
-pyunicorn/climate/_ext/src_numerics.c
-pyunicorn/core/__init__.py
-pyunicorn/core/data.py
-pyunicorn/core/geo_network.py
-pyunicorn/core/grid.py
-pyunicorn/core/interacting_networks.py
-pyunicorn/core/netcdf_dictionary.py
-pyunicorn/core/network.py
-pyunicorn/core/numerics.c
-pyunicorn/core/resistive_network.py
-pyunicorn/core/_ext/__init__.py
-pyunicorn/core/_ext/numerics.c
-pyunicorn/core/_ext/numerics.pyx
-pyunicorn/core/_ext/src_numerics.c
-pyunicorn/eventseries/eca.py
-pyunicorn/funcnet/__init__.py
-pyunicorn/funcnet/coupling_analysis.py
-pyunicorn/funcnet/coupling_analysis_pure_python.py
-pyunicorn/funcnet/event_synchronization.py
-pyunicorn/funcnet/_ext/__init__.py
-pyunicorn/funcnet/_ext/numerics.c
-pyunicorn/funcnet/_ext/numerics.pyx
-pyunicorn/funcnet/_ext/src_numerics.c
-pyunicorn/timeseries/__init__.py
-pyunicorn/timeseries/cross_recurrence_plot.py
-pyunicorn/timeseries/inter_system_recurrence_network.py
-pyunicorn/timeseries/joint_recurrence_network.py
-pyunicorn/timeseries/joint_recurrence_plot.py
-pyunicorn/timeseries/numerics.c
-pyunicorn/timeseries/recurrence_network.py
-pyunicorn/timeseries/recurrence_plot.py
-pyunicorn/timeseries/surrogates.py
-pyunicorn/timeseries/visibility_graph.py
-pyunicorn/timeseries/_ext/__init__.py
-pyunicorn/timeseries/_ext/numerics.c
-pyunicorn/timeseries/_ext/numerics.pyx
-pyunicorn/timeseries/_ext/src_numerics.c
-pyunicorn/utils/__init__.py
-pyunicorn/utils/mpi.py
-pyunicorn/utils/navigator.py
-pyunicorn/utils/progressbar/__init__.py
-pyunicorn/utils/progressbar/compat.py
-pyunicorn/utils/progressbar/progressbar.py
-pyunicorn/utils/progressbar/widgets.py
-tests/__init__.py
+examples/tutorials/ClimateNetworks.ipynb
+examples/tutorials/CoupledClimateNetworks.ipynb
+examples/tutorials/EventSeriesAnalysis.ipynb
+examples/tutorials/RecurrenceNetworks.ipynb
+examples/tutorials/VisibilityGraphs.ipynb
+examples/tutorials/images/Characteristics_rP.png
+examples/tutorials/images/ECA.png
+examples/tutorials/images/EventSynchronisation.png
+examples/tutorials/images/HVG.png
+examples/tutorials/images/REcurrencePlot_v2.png
+examples/tutorials/images/SimpleVG.png
+src/pyunicorn/__init__.py
+src/pyunicorn/version.py
+src/pyunicorn.egg-info/PKG-INFO
+src/pyunicorn.egg-info/SOURCES.txt
+src/pyunicorn.egg-info/dependency_links.txt
+src/pyunicorn.egg-info/not-zip-safe
+src/pyunicorn.egg-info/requires.txt
+src/pyunicorn.egg-info/top_level.txt
+src/pyunicorn/climate/__init__.py
+src/pyunicorn/climate/climate_data.py
+src/pyunicorn/climate/climate_network.py
+src/pyunicorn/climate/coupled_climate_network.py
+src/pyunicorn/climate/coupled_tsonis.py
+src/pyunicorn/climate/eventseries_climatenetwork.py
+src/pyunicorn/climate/havlin.py
+src/pyunicorn/climate/hilbert.py
+src/pyunicorn/climate/map_plot.py
+src/pyunicorn/climate/mutual_info.py
+src/pyunicorn/climate/partial_correlation.py
+src/pyunicorn/climate/rainfall.py
+src/pyunicorn/climate/spearman.py
+src/pyunicorn/climate/tsonis.py
+src/pyunicorn/climate/_ext/__init__.py
+src/pyunicorn/climate/_ext/numerics.pyx
+src/pyunicorn/climate/_ext/src_numerics.c
+src/pyunicorn/core/__init__.py
+src/pyunicorn/core/cache.py
+src/pyunicorn/core/data.py
+src/pyunicorn/core/geo_grid.py
+src/pyunicorn/core/geo_network.py
+src/pyunicorn/core/grid.py
+src/pyunicorn/core/interacting_networks.py
+src/pyunicorn/core/netcdf_dictionary.py
+src/pyunicorn/core/network.py
+src/pyunicorn/core/resistive_network.py
+src/pyunicorn/core/spatial_network.py
+src/pyunicorn/core/_ext/__init__.py
+src/pyunicorn/core/_ext/numerics.pyx
+src/pyunicorn/core/_ext/src_numerics.c
+src/pyunicorn/core/_ext/types.pxd
+src/pyunicorn/core/_ext/types.py
+src/pyunicorn/eventseries/__init__.py
+src/pyunicorn/eventseries/event_series.py
+src/pyunicorn/funcnet/__init__.py
+src/pyunicorn/funcnet/coupling_analysis.py
+src/pyunicorn/funcnet/coupling_analysis_pure_python.py
+src/pyunicorn/funcnet/_ext/__init__.py
+src/pyunicorn/funcnet/_ext/numerics.pyx
+src/pyunicorn/timeseries/__init__.py
+src/pyunicorn/timeseries/cross_recurrence_plot.py
+src/pyunicorn/timeseries/inter_system_recurrence_network.py
+src/pyunicorn/timeseries/joint_recurrence_network.py
+src/pyunicorn/timeseries/joint_recurrence_plot.py
+src/pyunicorn/timeseries/recurrence_network.py
+src/pyunicorn/timeseries/recurrence_plot.py
+src/pyunicorn/timeseries/surrogates.py
+src/pyunicorn/timeseries/visibility_graph.py
+src/pyunicorn/timeseries/_ext/__init__.py
+src/pyunicorn/timeseries/_ext/numerics.pyx
+src/pyunicorn/timeseries/_ext/src_numerics.c
+src/pyunicorn/utils/__init__.py
+src/pyunicorn/utils/mpi.py
+src/pyunicorn/utils/navigator.py
+tests/conftest.py
 tests/test_generic.py
 tests/test_climate/__init__.py
 tests/test_climate/test_climate_data.py
 tests/test_climate/test_climate_network.py
-tests/test_climate/test_eventsynchronization_climatenetwork.py
+tests/test_climate/test_coupled_climate_network.py
+tests/test_climate/test_eventseries_climatenetwork.py
+tests/test_climate/test_map_plot.py
 tests/test_climate/test_tsonis.py
 tests/test_core/ResistiveNetwork_utils.py
-tests/test_core/TestResitiveNetwork-circuits.py
-tests/test_core/TestResitiveNetwork-complexInput.py
-tests/test_core/TestResitiveNetwork-cython.py
-tests/test_core/TestResitiveNetwork-types.py
+tests/test_core/TestResistiveNetwork-circuits.py
+tests/test_core/TestResistiveNetwork-complexInput.py
+tests/test_core/TestResistiveNetwork-cython.py
+tests/test_core/TestResistiveNetwork-types.py
 tests/test_core/__init__.py
+tests/test_core/test_cache.py
 tests/test_core/test_data.py
+tests/test_core/test_geo_grid.py
 tests/test_core/test_geo_network.py
 tests/test_core/test_grid.py
 tests/test_core/test_interacting_networks.py
 tests/test_core/test_network.py
 tests/test_core/test_resistive_networks.py
-tests/test_funcnet/__init__.py
+tests/test_core/test_spatial_network.py
+tests/test_eventseries/test_event_series.py
 tests/test_funcnet/test_coupling_analysis.py
-tests/test_funcnet/test_event_synchronization.py
-tests/test_timeseries/__init__.py
-tests/test_timeseries/test_surrogates.py
+tests/test_timeseries/test_joint_recurrence_plot.py
+tests/test_timeseries/test_recurrence_plot.py
 tests/test_timeseries/test_timeseries.py
```

### Comparing `pyunicorn-0.6.1/tests/test_timeseries/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/eventseries/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,16 +1,32 @@
-# This file is part of pyunicorn
-# (Unified Complex Network and Recurrence Analysis Toolbox).
-#
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-#
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# This file is part of pyunicorn.
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
+
+"""
+eventseries
+===========
+
+Provides a class for analyzing event series, namely event synchronization and
+event coincidence analysis
+
+Related Publications
+~~~~~~~~~~~~~~~~~~~~
+[Quiroga2002]_, [Boers2014]_, [Donges2016]_, [Odenweller2020]_, [Kreuz2007]_,
+[Marwan2015]_, [Schleussner2016]_.
+
+To do
+~~~~~
+  - Combine precursor and trigger coincidence rate to obtain one ECA measure
+"""
+
+from .event_series import EventSeries
```

### Comparing `pyunicorn-0.6.1/tests/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/version.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,18 +1,17 @@
-# This file is part of pyunicorn
-# (Unified Complex Network and Recurrence Analysis Toolbox).
-#
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-#
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# This file is part of pyunicorn.
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
-__all__ = ['test_generic']
+from importlib import metadata
+
+__version__ = metadata.version('pyunicorn')
```

### Comparing `pyunicorn-0.6.1/tests/test_generic.py` & `pyunicorn-0.7.0/tests/test_generic.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,12 +1,10 @@
-#! /usr/bin/env python2
-
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -14,16 +12,22 @@
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 
 """
 Generic consistency checks.
 """
 
-import numpy as np
-from pyunicorn import core, climate, timeseries, funcnet
+from pyunicorn import __version__, core, climate, timeseries, funcnet
+
+
+def test_version():
+    """
+    Valid version information.
+    """
+    assert isinstance(__version__, str)
 
 
 def test_init_str():
     """
     Reasonable __init__ and __str__ for most classes.
     """
     for i in simple_instances():
@@ -34,40 +38,42 @@
     """
     Minimally initialized instances for most classes.
     """
     cd = climate.ClimateData.SmallTestData()
     ca = funcnet.CouplingAnalysis.test_data()[:50]
     ts = ca[:, 0]
     t1, t2, t3 = [{'threshold': t} for t in [0.2, (0.2, 0.2), (0.2, 0.2, 0.2)]]
-    es = 1-(np.random.rand(100, 10) > 0.4).astype(int)
-    ec = climate.EventSynchronizationClimateNetwork.SmallTestData()
+    # es = 1-(np.random.rand(100, 10) > 0.4).astype(int)
+    # ec = climate.EventSynchronizationClimateNetwork.SmallTestData()
     return [
         core.Network.SmallTestNetwork(),
         core.Grid.SmallTestGrid(),
+        core.SpatialNetwork.SmallTestNetwork(),
+        core.GeoGrid.SmallTestGrid(),
         core.GeoNetwork.SmallTestNetwork(),
         core.InteractingNetworks.SmallTestNetwork(),
         core.ResNetwork.SmallTestNetwork(),
         core.NetCDFDictionary(),
         cd,
         climate.ClimateNetwork.SmallTestNetwork(),
         climate.HavlinClimateNetwork(cd, 0, **t1),
         climate.HilbertClimateNetwork(cd, **t1),
         climate.TsonisClimateNetwork.SmallTestNetwork(),
         climate.PartialCorrelationClimateNetwork(cd, winter_only=False, **t1),
         climate.RainfallClimateNetwork(cd, **t1),
         climate.SpearmanClimateNetwork(cd, winter_only=False, **t1),
         climate.MutualInfoClimateNetwork(cd, winter_only=False, **t1),
         climate.CoupledTsonisClimateNetwork(cd, cd, **t1),
-        climate.EventSynchronizationClimateNetwork(ec, 0.8, 16,
-                                                   eventsynctype="directedES"),
+        # climate.EventSynchronizationClimateNetwork(
+        #     ec, 0.8, 16, eventsynctype="directedES"),
         timeseries.RecurrencePlot(ts, **t1),
         timeseries.RecurrenceNetwork(ts, **t1),
         timeseries.JointRecurrencePlot(ts, ts, **t2),
         timeseries.JointRecurrenceNetwork(ts, ts, **t2),
         timeseries.CrossRecurrencePlot(ts, ts, **t1),
         timeseries.InterSystemRecurrenceNetwork(ts, ts, **t3),
         timeseries.Surrogates.SmallTestData(),
         timeseries.VisibilityGraph(ts),
         funcnet.CouplingAnalysis(ca),
         funcnet.CouplingAnalysisPurePython(ca),
-        funcnet.EventSynchronization(es, 16)
+        # funcnet.EventSynchronization(es, 16)
     ]
```

### Comparing `pyunicorn-0.6.1/tests/test_funcnet/__init__.py` & `pyunicorn-0.7.0/src/pyunicorn/__init__.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,33 @@
-# This file is part of pyunicorn
-# (Unified Complex Network and Recurrence Analysis Toolbox).
-#
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-#
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# This file is part of pyunicorn.
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
+
+"""
+pyunicorn
+=========
+
+Subpackages
+-----------
+core
+    Spatially embedded complex networks and multivariate data
+climate
+    Climate networks
+funcnet
+    Functional networks
+timeseries
+    Time series surrogates
+"""
+
+from .version import __version__
+from .utils import mpi
+from .core import *
```

### Comparing `pyunicorn-0.6.1/tests/test_funcnet/test_coupling_analysis.py` & `pyunicorn-0.7.0/tests/test_funcnet/test_coupling_analysis.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -19,25 +16,27 @@
 Simple tests for the funcnet CouplingAnalysis class.
 """
 import numpy as np
 
 from pyunicorn.core.data import Data
 from pyunicorn.funcnet import CouplingAnalysis
 
+from pyunicorn.core._ext.types import FIELD
+
 
 def create_test_data():
     # Create test time series
     tdata = Data.SmallTestData().observable()
-    n_index, n_times = tdata.shape
     # subtract means form the input data
     tdata -= np.mean(tdata, axis=1)[:, None]
     # normalize the data
     tdata /= np.sqrt(np.sum(tdata*tdata, axis=1))[:, None]
     return tdata
 
+
 def test_symmetrize_by_absmax():
     # Test example
     ca = CouplingAnalysis(CouplingAnalysis.test_data())
     similarity_matrix, lag_matrix = ca.cross_correlation(tau_max=2)
 
     res = (similarity_matrix, lag_matrix)
     exp = (np.array([[1., 0.698, 0.7788, 0.7535],
@@ -57,33 +56,46 @@
                      [-1, 2, 0, 1], [-2, 2, -1, 0]]))
     assert np.allclose(res, exp, atol=1e-04)
 
     # Random consistency test
     tdata = create_test_data()
     n_index, n_times = tdata.shape
     coup_ana = CouplingAnalysis(tdata)
-    similarity_matrix = np.random.rand(n_index, n_times).astype('float32')
+    similarity_matrix = np.random.rand(n_index, n_times).astype(FIELD)
     lag_matrix = np.random.rand(n_index, n_times).astype(np.int8)
     sm_new = coup_ana.symmetrize_by_absmax(similarity_matrix, lag_matrix)[0]
     for i in range(n_index):
         for j in range(n_times):
             assert sm_new[i, j] >= similarity_matrix[i, j]
 
-def test_cross_correlation():
+
+def test_cross_correlation_max():
     coup_ana = CouplingAnalysis(CouplingAnalysis.test_data())
     similarity_matrix, lag_matrix = coup_ana.cross_correlation(
         tau_max=5, lag_mode='max')
     res = (similarity_matrix, lag_matrix)
-    exp = (np.array([[1., 0.757, 0.779, 0.7536],
+    exp = (np.array([[1., 0.7570, 0.7790, 0.7536],
                      [0.4847, 1., 0.4502, 0.5197],
                      [0.6219, 0.5844, 1., 0.5992],
                      [0.4827, 0.5509, 0.4996, 1.]]),
            np.array([[0, 4, 1, 2], [0, 0, 0, 0], [0, 3, 0, 1], [0, 2, 0, 0]]))
     assert np.allclose(res, exp, atol=1e-04)
 
+
+def test_cross_correlation_all():
+    coup_ana = CouplingAnalysis(CouplingAnalysis.test_data())
+    res = coup_ana.cross_correlation(tau_max=1, lag_mode='all')
+    exp = np.array(
+        [[[1., 0.8173], [0.4849, 0.5804], [0.6214, 0.7786], [0.4831, 0.6042]],
+         [[0.4849, 0.4101], [1., 0.9362], [0.4503, 0.3780], [0.5199, 0.4286]],
+         [[0.6214, 0.5178], [0.4503, 0.5376], [1., 0.4962], [0.5004, 0.5996]],
+         [[0.4831, 0.3762], [0.5199, 0.5404], [0.5004, 0.4092], [1., 0.4380]]])
+    assert np.allclose(res, exp, atol=1e-04)
+
+
 def test_mutual_information():
     coup_ana = CouplingAnalysis(CouplingAnalysis.test_data())
     similarity_matrix, lag_matrix = coup_ana.mutual_information(
         tau_max=5, knn=10, estimator='knn')
     res = (similarity_matrix, lag_matrix)
     exp = (np.array([[4.6505, 0.4387, 0.4652, 0.4126],
                      [0.147, 4.6505, 0.1065, 0.1639],
@@ -91,14 +103,15 @@
                      [0.1209, 0.199, 0.1453, 4.6505]]),
            np.array([[0, 4, 1, 2],
                      [0, 0, 0, 0],
                      [0, 2, 0, 1],
                      [0, 2, 0, 0]], dtype=np.int8))
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_information_transfer():
     coup_ana = CouplingAnalysis(CouplingAnalysis.test_data())
     similarity_matrix, lag_matrix = coup_ana.information_transfer(
         tau_max=5, estimator='knn', knn=10)
     res = (similarity_matrix, lag_matrix)
     exp = (np.array([[0., 0.1544, 0.3261, 0.3047],
                      [0.0218, 0., 0.0394, 0.0976],
```

### Comparing `pyunicorn-0.6.1/tests/test_core/test_grid.py` & `pyunicorn-0.7.0/tests/test_core/test_geo_grid.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,135 +1,126 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
 """
-Simple tests for the Grid class.
+Simple tests for the GeoGrid class.
 """
 import numpy as np
 
-from pyunicorn.core.grid import Grid
+from pyunicorn.core.geo_grid import GeoGrid
 
 
 def test_RegularGrid():
-    res = Grid.RegularGrid(time_seq=np.arange(2),
-                           lat_grid=np.array([0., 5.]),
-                           lon_grid=np.array([1., 2.]),
-                           silence_level=2).lat_sequence()
+    res = GeoGrid.RegularGrid(time_seq=np.arange(2),
+                              space_grid=(np.array([0., 5.]),
+                                          np.array([1., 2.])),
+                              silence_level=2).lat_sequence()
     exp = np.array([0., 0., 5., 5.], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
-    res = Grid.RegularGrid(time_seq=np.arange(2),
-                           lat_grid=np.array([0., 5.]),
-                           lon_grid=np.array([1., 2.]),
-                           silence_level=2).lon_sequence()
+    res = GeoGrid.RegularGrid(time_seq=np.arange(2),
+                              space_grid=(np.array([0., 5.]),
+                                          np.array([1., 2.])),
+                              silence_level=2).lon_sequence()
     exp = np.array([1., 2., 1., 2.], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_coord_sequence_from_rect_grid():
-    res = Grid.coord_sequence_from_rect_grid(lat_grid=np.array([0., 5.]),
-                                             lon_grid=np.array([1., 2.]))
+    res = GeoGrid.coord_sequence_from_rect_grid(lat_grid=np.array([0., 5.]),
+                                                lon_grid=np.array([1., 2.]))
     exp = (np.array([0., 0., 5., 5.]), np.array([1., 2., 1., 2.]))
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_lat_sequence():
-    res = Grid.SmallTestGrid().lat_sequence()
+    res = GeoGrid.SmallTestGrid().lat_sequence()
     exp = np.array([0., 5., 10., 15., 20., 25.], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_lon_sequence():
-    res = Grid.SmallTestGrid().lon_sequence()
+    res = GeoGrid.SmallTestGrid().lon_sequence()
     exp = np.array([2.5, 5., 7.5, 10., 12.5, 15.], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_convert_lon_coordinates():
-    res = Grid.SmallTestGrid().convert_lon_coordinates(
+    res = GeoGrid.SmallTestGrid().convert_lon_coordinates(
         np.array([10., 350., 20., 340., 170., 190.]))
     exp = np.array([10., -10., 20., -20., 170., -170.])
     assert np.allclose(res, exp, atol=1e-04)
 
-def test_node_coordinates():
-    res = Grid.SmallTestGrid().node_coordinates(3)
-    exp = (15.0, 10.0)
-    assert np.allclose(res, exp, atol=1e-04)
 
-def test_node_number():
-    res = Grid.SmallTestGrid().node_number(lat_node=14., lon_node=9.)
+def test_node_number2d():
+    res = GeoGrid.SmallTestGrid().node_number(lat_node=14., lon_node=9.)
     exp = 3
     assert res == exp
 
+
 def test_cos_lat():
-    res = Grid.SmallTestGrid().cos_lat()[:2]
+    res = GeoGrid.SmallTestGrid().cos_lat()[:2]
     exp = np.array([1., 0.9962])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_sin_lat():
-    res = Grid.SmallTestGrid().sin_lat()[:2]
+    res = GeoGrid.SmallTestGrid().sin_lat()[:2]
     exp = np.array([0., 0.0872])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_cos_lon():
-    res = Grid.SmallTestGrid().cos_lon()[:2]
+    res = GeoGrid.SmallTestGrid().cos_lon()[:2]
     exp = np.array([0.999, 0.9962])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_sin_lon():
-    res = Grid.SmallTestGrid().sin_lon()[:2]
+    res = GeoGrid.SmallTestGrid().sin_lon()[:2]
     exp = np.array([0.0436, 0.0872])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_angular_distance():
-    res = Grid.SmallTestGrid().angular_distance().round(2)
+    res = GeoGrid.SmallTestGrid().angular_distance().round(2)
     exp = np.array([[0., 0.1, 0.19, 0.29, 0.39, 0.48],
                     [0.1, 0., 0.1, 0.19, 0.29, 0.39],
                     [0.19, 0.1, 0., 0.1, 0.19, 0.29],
                     [0.29, 0.19, 0.1, 0., 0.1, 0.19],
                     [0.39, 0.29, 0.19, 0.1, 0., 0.1],
                     [0.48, 0.39, 0.29, 0.19, 0.1, 0.]], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_boundaries():
-    res = Grid.SmallTestGrid().print_boundaries()
+    res = GeoGrid.SmallTestGrid().print_boundaries()
     exp = "         time     lat     lon\n   min    0.0    0.00    2.50\n" + \
           "   max    9.0   25.00   15.00"
     assert res == exp
 
-def test_grid():
-    res = Grid.SmallTestGrid().grid()["lat"]
-    exp = np.array([0., 5., 10., 15., 20., 25.], dtype=np.float32)
-    assert np.allclose(res, exp, atol=1e-04)
-
-    res = Grid.SmallTestGrid().grid()["lon"]
-    exp = np.array([2.5, 5., 7.5, 10., 12.5, 15.], dtype=np.float32)
-    assert np.allclose(res, exp, atol=1e-04)
-
-def test_grid_size():
-    res = Grid.SmallTestGrid().print_grid_size()
-    exp = '     space    time\n         6      10'
-    assert res == exp
 
 def test_geometric_distance_distribution():
-    res = Grid.SmallTestGrid().geometric_distance_distribution(3)[0]
+    res = GeoGrid.SmallTestGrid().geometric_distance_distribution(3)[0]
     exp = np.array([0.3333, 0.4667, 0.2])
     assert np.allclose(res, exp, atol=1e-04)
 
-    res = Grid.SmallTestGrid().geometric_distance_distribution(3)[1]
+    res = GeoGrid.SmallTestGrid().geometric_distance_distribution(3)[1]
     exp = np.array([0., 0.1616, 0.3231, 0.4847])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_region_indices():
-    res = Grid.SmallTestGrid().region_indices(
+    res = GeoGrid.SmallTestGrid().region_indices(
         np.array([0., 0., 0., 11., 11., 11., 11., 0.])).astype(int)
     exp = np.array([0, 1, 1, 0, 0, 0])
     assert np.allclose(res, exp, atol=1e-04)
```

### Comparing `pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-circuits.py` & `pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-circuits.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,21 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#
 # Copyright (C) 2014 SWIPO Project
 #
 # Authors (this file):
 #   Stefan Schinkel <stefan.schinkel@gmail.com>
 """
 Provides sanity checks for basic for parallel and serial circiuts.
 """
 import numpy as np
 import networkx as nx
 
 
 from pyunicorn import ResNetwork
-from .ResistiveNetwork_utils import makeNW, parallelCopy, serialCopy, nx2nw
+from .ResistiveNetwork_utils import \
+    makeNW, parallelCopy, serialCopy, nx2nw
 
 debug = 0
 """ Test for basic sanity, parallel and serial circiuts
 """
 
 
 def testParallelTrivial():
@@ -230,15 +228,15 @@
     rnw1 = ResNetwork(nw1)
     rnw2 = ResNetwork(nw2)
 
     ER1 = rnw1.effective_resistance(0, 2)
     ER2 = rnw2.effective_resistance(0, 4)
 
     print("Effective resistances (0,2)")
-    print("NW1 %.3f\tNW2 %.3f\t 2*NW1 = %.3f" % (ER1, ER2, 2*ER1))
+    print(f"NW1 {ER1:.3f}\tNW2 {ER2:.3f}\t 2*NW1 = {(2*ER1):.3f}")
 
     assert (ER1*2-ER2) < 1E-6
 
 
 def testSerialRandom():
     """ 50 Random serial test cases
     """
```

### Comparing `pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-cython.py` & `pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-cython.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#
 # Copyright (C) 2014 SWIPO Project
 #
 # Authors (this file):
 #   Stefan Schinkel <stefan.schinkel@gmail.com>
 """
 Weave tests to check that python and weave implementations give the same
 results
@@ -19,53 +16,53 @@
 
 
 def testVCFB():
     for i in range(5):
         admittance = res.get_admittance()
         R = res.get_R()
         # set params
-        Is = It = np.float(1.0)
+        Is = It = np.float32(1.0)
         # alloc output
-        vcfbPython = np.float(0)
+        vcfbPython = np.float32(0)
         for t in range(res.N):
             for s in range(t):
-                I = 0.0
+                K = 0.0
                 if i in (t, s):
                     pass
                 else:
                     for j in range(res.N):
-                        I += admittance[i][j] * np.abs(
+                        K += admittance[i][j] * np.abs(
                             Is*(R[i][s]-R[j][s]) + It*(R[j][t]-R[i][t]))/2.
-                vcfbPython += 2.*I/(res.N*(res.N-1))
+                vcfbPython += 2.*K/(res.N*(res.N-1))
 
         vcfbCython = res.vertex_current_flow_betweenness(i)
         assert round(vcfbPython, 4) == round(vcfbCython, 4)
 
 
 def testECFB():
     # set currents
-    Is = It = np.float(1)
+    Is = It = np.float32(1)
     # alloc output
     if res.flagComplex:
         dtype = complex
     else:
         dtype = float
     ecfbPython = np.zeros([res.N, res.N], dtype=dtype)
     # the usual
     admittance = res.get_admittance()
     R = res.get_R()
     for i in range(res.N):
         for j in range(res.N):
-            I = 0
+            K = 0
             for t in range(res.N):
                 for s in range(t):
-                    I += admittance[i][j] * np.abs(
+                    K += admittance[i][j] * np.abs(
                         Is*(R[i][s]-R[j][s])+It*(R[j][t]-R[i][t]))
             # Lets try to compute the in
-            ecfbPython[i][j] = 2*I/(res.N*(res.N-1))
+            ecfbPython[i][j] = 2*K/(res.N*(res.N-1))
 
     ecfbCython = res.edge_current_flow_betweenness()
-    l = len(ecfbPython)
-    for i in range(l):
-        for j in range(l):
+    L = len(ecfbPython)
+    for i in range(L):
+        for j in range(L):
             assert round((ecfbPython[i][j].astype('float32')), 4) == \
                    round((ecfbCython[i][j].astype('float32')), 4)
```

### Comparing `pyunicorn-0.6.1/tests/test_core/test_geo_network.py` & `pyunicorn-0.7.0/tests/test_core/test_geo_network.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -16,239 +13,277 @@
 # for complex systems science: The pyunicorn package"
 """
 Simple tests for the GeoNetwork class.
 """
 import numpy as np
 
 from pyunicorn.core.geo_network import GeoNetwork
-from pyunicorn.core.grid import Grid
+from pyunicorn.core.spatial_network import SpatialNetwork
+from pyunicorn.core.geo_grid import GeoGrid
+
 
 def test_ErdosRenyi(capsys):
-    print(GeoNetwork.ErdosRenyi(grid=Grid.SmallTestGrid(),
-                                n_nodes=6, n_links=5))
+    print(GeoNetwork.Model("ErdosRenyi", grid=GeoGrid.SmallTestGrid(),
+                           n_nodes=6, n_links=5))
     out, err = capsys.readouterr()
     out_ref = "Generating Erdos-Renyi random graph with 6 nodes and 5 " + \
               "links...\nSetting area weights according to type surface " + \
-              "...\nGeoNetwork:\n" + \
+              "...\nGeoNetwork:\nSpatialNetwork:\n" + \
               "Network: undirected, 6 nodes, 5 links, " + \
               "link density 0.333.\nGeographical boundaries:\n" + \
               "         time     lat     lon\n" + \
               "   min    0.0    0.00    2.50\n" + \
               "   max    9.0   25.00   15.00\n"
     assert out == out_ref
 
+
 def test_ConfigurationModel():
     n = 0
     while n != 7:
-        net = GeoNetwork.ConfigurationModel(
-            grid=Grid.SmallTestGrid(),
-            degrees=GeoNetwork.SmallTestNetwork().degree(),
-            silence_level=2)
+        net = GeoNetwork.Model("Configuration", grid=GeoGrid.SmallTestGrid(),
+                               degrees=GeoNetwork.SmallTestNetwork().degree(),
+                               silence_level=2)
         n = net.n_links
     res = net.link_density
     exp = 0.46666667
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_randomly_rewire_geomodel_I():
     net = GeoNetwork.SmallTestNetwork()
-    net.randomly_rewire_geomodel_I(distance_matrix=net.grid.angular_distance(),
+    net.randomly_rewire_geomodel_I(distance_matrix=net.grid.distance(),
                                    iterations=100, inaccuracy=1.0)
     res = net.degree()
     exp = np.array([3, 3, 2, 2, 3, 1])
     assert (res == exp).all()
 
+
 def test_set_random_links_by_distance():
     net = GeoNetwork.SmallTestNetwork()
     while net.n_links != 5:
         net.set_random_links_by_distance(a=0., b=-4.)
     res = net.n_links
     exp = 5
     assert res == exp
 
+
 def test_geographical_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.geographical_distribution(sequence=net.degree(), n_bins=3)[0]
     exp = np.array([0.15645071, 0.33674395, 0.50680541])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_geographical_cumulative_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.geographical_cumulative_distribution(sequence=net.degree(),
                                                    n_bins=3)[0]
     exp = np.array([1.00000007, 0.84354936, 0.50680541])
     assert np.allclose(res, exp, atol=1e-04)
 
-def test_link_distance_distribution():
-    net = GeoNetwork.SmallTestNetwork()
 
-    res = net.link_distance_distribution(n_bins=4, geometry_corrected=False)[0]
-    exp = np.array([0.14285714, 0.28571429, 0.28571429, 0.28571429])
+def test_link_distance_distribution():
+    """Check consistency of link distance distribution on spherical grid with
+    distribution on euclidean grid"""
+    net = SpatialNetwork.SmallTestNetwork()
+    geo_net = GeoNetwork.SmallTestNetwork()
+
+    res = geo_net.link_distance_distribution(n_bins=4,
+                                             geometry_corrected=False,
+                                             grid_type="spherical")[0]
+    exp = net.link_distance_distribution(n_bins=4, geometry_corrected=False)[0]
     assert np.allclose(res, exp, atol=1e-04)
 
-    res = net.link_distance_distribution(n_bins=4, geometry_corrected=True)[0]
-    exp = np.array([0.09836066, 0.24590164, 0.32786885, 0.32786885])
+    res = geo_net.link_distance_distribution(n_bins=4, geometry_corrected=True,
+                                             grid_type="spherical")[0]
+    exp = net.link_distance_distribution(n_bins=4, geometry_corrected=True)[0]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_area_weighted_connectivity():
     res = GeoNetwork.SmallTestNetwork().area_weighted_connectivity()
     exp = np.array([0.48540673, 0.4989577, 0.33418113, 0.34459165, 0.51459336,
                     0.17262428], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_inarea_weighted_connectivity():
     res = GeoNetwork.SmallTestNetwork().inarea_weighted_connectivity()
     exp = np.array([0.48540673, 0.4989577, 0.33418113, 0.34459165, 0.51459336,
                     0.17262428], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_outarea_weighted_connectivity():
     res = GeoNetwork.SmallTestNetwork().outarea_weighted_connectivity()
     exp = np.array([0.4854067, 0.4989577, 0.33418113, 0.34459165, 0.51459336,
                     0.17262428], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_area_weighted_connectivity_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.area_weighted_connectivity_distribution(n_bins=4)[0]
     exp = np.array([0.15645071, 0.33674395, 0.34459165, 0.16221375])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_inarea_weighted_connectivity_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.inarea_weighted_connectivity_distribution(n_bins=4)[0]
     exp = np.array([0.15645071, 0.33674395, 0.34459165, 0.16221375])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_outarea_weighted_connectivity_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.outarea_weighted_connectivity_distribution(n_bins=4)[0]
     exp = np.array([0.15645071, 0.33674395, 0.34459165, 0.16221375])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_area_weighted_connectivity_cumulative_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.area_weighted_connectivity_cumulative_distribution(n_bins=4)[0]
     exp = np.array([1.00000007, 0.84354936, 0.50680541, 0.16221375])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_inarea_weighted_connectivity_cumulative_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.inarea_weighted_connectivity_cumulative_distribution(n_bins=4)[0]
     exp = np.array([1.00000007, 0.84354936, 0.50680541, 0.16221375])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_outarea_weighted_connectivity_cumulative_distribution():
     net = GeoNetwork.SmallTestNetwork()
     res = net.outarea_weighted_connectivity_cumulative_distribution(
         n_bins=4)[0]
     exp = np.array([1.00000007, 0.84354936, 0.50680541, 0.16221375])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_average_neighbor_area_weighted_connectivity():
     net = GeoNetwork.SmallTestNetwork()
     res = net.average_neighbor_area_weighted_connectivity()
     exp = np.array([0.3439364, 0.39778873, 0.5067755, 0.4921822, 0.4395152,
                     0.48540673], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_max_neighbor_area_weighted_connectivity():
     net = GeoNetwork.SmallTestNetwork()
     res = net.max_neighbor_area_weighted_connectivity()
     exp = np.array([0.51459336, 0.51459336, 0.51459336, 0.49895769, 0.49895769,
                     0.48540673])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_average_link_distance():
     net = GeoNetwork.SmallTestNetwork()
 
     res = net.average_link_distance(geometry_corrected=False)
     exp = np.array([0.3884563, 0.19434186, 0.14557932, 0.24325928, 0.29118925,
                     0.48467883])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.average_link_distance(geometry_corrected=True)[:-1]
     exp = np.array([1.5987561, 1.0920637, 1.00011046, 1.67081917, 1.63841055])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_inaverage_link_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.inaverage_link_distance(geometry_corrected=False)
     exp = np.array([0.3884563, 0.19434186, 0.14557932, 0.24325928, 0.29118925,
                     0.48467883])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_outaverage_link_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.outaverage_link_distance(geometry_corrected=False)
     exp = np.array([0.3884563, 0.19434186, 0.14557932, 0.24325928, 0.29118925,
                     0.48467883])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_total_link_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.total_link_distance(geometry_corrected=False)
     exp = np.array([0.1885593, 0.09696837, 0.04864986, 0.08382512, 0.14984406,
                     0.08366733])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_intotal_link_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.intotal_link_distance(geometry_corrected=False)
     exp = np.array([0.1885593, 0.09696837, 0.04864986, 0.08382512, 0.14984406,
                     0.08366733])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_outtotal_link_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.outtotal_link_distance(geometry_corrected=False)
     exp = np.array([0.18855929, 0.09696837, 0.04864986, 0.08382512, 0.14984406,
                     0.08366733])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_connectivity_weighted_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.connectivity_weighted_distance()
     exp = np.array([0.0625227, 0.03207134, 0.02408994, 0.04192858, 0.0500332,
                     0.08366733])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_inconnectivity_weighted_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.inconnectivity_weighted_distance()
     exp = np.array([0.0625227, 0.03207134, 0.02408994, 0.04192858, 0.0500332,
                     0.08366733])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_outconnectivity_weighted_distance():
     net = GeoNetwork.SmallTestNetwork()
     res = net.outconnectivity_weighted_distance()
     exp = np.array([0.0625227, 0.03207134, 0.02408994, 0.04192858, 0.0500332,
                     0.08366733])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_max_link_distance():
     res = GeoNetwork.SmallTestNetwork().max_link_distance()
     exp = np.array([0.48467883, 0.2911402, 0.19376467, 0.2920272, 0.38866287,
                     0.48467883], dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_average_distance_weighted_path_length():
     res = GeoNetwork.SmallTestNetwork().average_distance_weighted_path_length()
     exp = 0.49846491
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_distance_weighted_closeness():
     res = GeoNetwork.SmallTestNetwork().distance_weighted_closeness()
     exp = np.array([2.23782229, 2.45008978, 2.23956348, 2.45008978, 2.2396005,
                     1.19817005])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_local_distance_weighted_vulnerability():
     res = GeoNetwork.SmallTestNetwork().local_distance_weighted_vulnerability()
     exp = np.array([0.03252519, 0.3136603, 0.20562718, 0.02799094, -0.02828809,
                     -0.28798557])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_local_geographical_clustering():
     res = GeoNetwork.SmallTestNetwork().local_geographical_clustering()
     exp = np.array([0., 0.0998, 0.1489, 0., 0.2842, 0.])
     assert np.allclose(res, exp, atol=1e-04)
```

### Comparing `pyunicorn-0.6.1/tests/test_core/TestResitiveNetwork-complexInput.py` & `pyunicorn-0.7.0/tests/test_core/TestResistiveNetwork-complexInput.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#
 # Copyright (C) 2014 SWIPO Project
 #
 # Authors (this file):
 #   Stefan Schinkel <stefan.schinkel@gmail.com>
 """
 Provides Simple test for the treatment of complex admittances
 in resistive networks.
```

### Comparing `pyunicorn-0.6.1/tests/test_core/test_network.py` & `pyunicorn-0.7.0/tests/test_core/test_network.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,43 +1,40 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
+
 """
 Simple tests for the Network class.
 """
+
 from functools import partial
 from itertools import islice, product, repeat
-from multiprocessing import Pool, cpu_count
+from multiprocessing import get_context, cpu_count
 
+import pytest
 import numpy as np
 import scipy.sparse as sp
 
 from pyunicorn import Network
 
 
 # -----------------------------------------------------------------------------
 # utilities
 # -----------------------------------------------------------------------------
 
-# turn off for weave compilation & error detection
-parallel = False
-
 
 def compare_results(desired, actual, rev_perm=None):
     assert type(desired) is type(actual)
     if isinstance(desired, dict):
         _ = [compare_results(*rs, rev_perm=rev_perm)
              for rs in zip(desired.values(), actual.values())]
     else:
@@ -58,18 +55,16 @@
 
 
 def compare_permutations(net, permutations, measures):
     pnets, rev_perms = zip(
         *((net.permuted_copy(p), p.argsort()) for p in
           map(np.random.permutation, repeat(net.N, permutations))))
     tasks = list(product(measures, range(permutations)))
-    if not parallel:
-        compare_measures(net, pnets, rev_perms, tasks)
-    else:
-        pool, cores = Pool(), cpu_count()
+    cores = cpu_count()
+    with get_context("spawn").Pool() as pool:
         pool.map(partial(compare_measures, net, pnets, rev_perms),
                  (list(islice(tasks, c, None, cores)) for c in range(cores)))
         pool.close()
         pool.join()
 
 
 def compare_nsi(net, nsi_measures):
@@ -90,14 +85,15 @@
                                getattr(netc, nsi_measure)(**kwargs)[-1])
 
 
 # -----------------------------------------------------------------------------
 # stability
 # -----------------------------------------------------------------------------
 
+
 def test_int_overflow():
     """
     Avoid integer overflow in scipy.sparse representation.
     """
     for n in [10, 200, 2000, 33000]:
         adj = sp.lil_matrix((n, n), dtype=np.int8)
         adj[0, 1:] = 1
@@ -105,14 +101,15 @@
         assert (deg.min(), deg.max()) == (0, n - 1)
 
 
 # -----------------------------------------------------------------------------
 # consistency
 # -----------------------------------------------------------------------------
 
+
 def test_permutations():
     """
     Permutation invariance of topological information.
     """
     compare_permutations(
         Network.SmallTestNetwork(), 3, [
             "degree", "indegree", "outdegree", "nsi_degree", "nsi_indegree",
@@ -174,353 +171,439 @@
 
     compare_nsi(dnw, nsi_measures)
     compare_nsi(nw, nsi_measures + nsi_undirected_measures)
 
 # -----------------------------------------------------------------------------
 # Class member tests with TestNetwork
 # -----------------------------------------------------------------------------
+
+
 def test_init():
     Network(adjacency=[[0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1],
                        [0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 1, 0],
                        [0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0]])
     assert True
 
+
 def test_str(capsys):
     print(Network.SmallTestNetwork())
     out, err = capsys.readouterr()
     out_ref = "Network: undirected, 6 nodes, 7 links, link density 0.467.\n"
     assert out == out_ref
 
+
 def test_len():
     assert np.allclose(len(Network.SmallTestNetwork()), 6)
 
+
 def test_undirected_copy(capsys):
     net = Network(adjacency=[[0, 1], [0, 0]], directed=True)
 
     print(net)
     out1, err = capsys.readouterr()
     out1_ref = "Network: directed, 2 nodes, 1 links, link density 0.500.\n"
     assert out1 == out1_ref
 
     print(net.undirected_copy())
     out2, err = capsys.readouterr()
     out2_ref = "Network: undirected, 2 nodes, 1 links, link density 1.000.\n"
     assert out2 == out2_ref
 
+
 def test_splitted_copy(capsys):
     net = Network.SmallTestNetwork()
     net2 = net.splitted_copy(node=5, proportion=0.2)
     print(net2)
     out, err = capsys.readouterr()
     out_ref = "Network: undirected, 7 nodes, 9 links, link density 0.429.\n"
     assert out == out_ref
 
     nw1_ref = [1.5, 1.7, 1.9, 2.1, 2.3, 2.5]
     nw2_ref = [1.5, 1.7, 1.9, 2.1, 2.3, 2., 0.5]
 
     assert np.allclose(net.node_weights, nw1_ref)
     assert np.allclose(net2.node_weights, nw2_ref)
 
+
 def test_adjacency():
     adj_ref = np.array([[0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0],
                         [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0],
                         [1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0]])
     assert np.array_equal(Network.SmallTestNetwork().adjacency, adj_ref)
 
+
 def test_set_adjacency(capsys):
     net = Network.SmallTestNetwork()
     net.adjacency = [[0, 1], [1, 0]]
     print(net)
     out, err = capsys.readouterr()
     out_ref = "Network: undirected, 2 nodes, 1 links, link density 1.000.\n"
     assert out == out_ref
 
+
 def test_set_node_weights(capsys):
     net = Network.SmallTestNetwork()
     nw_ref = [1.5, 1.7, 1.9, 2.1, 2.3, 2.5]
     assert np.allclose(net.node_weights, nw_ref)
 
     net.node_weights = [1, 1, 1, 1, 1, 1]
     nw_ref = [1., 1., 1., 1., 1., 1.]
     assert np.allclose(net.node_weights, nw_ref)
 
+
 def test_ErdosRenyi(capsys):
-    print(Network.ErdosRenyi(n_nodes=10, n_links=18))
+    print(Network.Model("ErdosRenyi", n_nodes=10, n_links=18))
     out, err = capsys.readouterr()
     out_ref = "Generating Erdos-Renyi random graph with 10 " + \
               "nodes and 18 links...\n" + \
               "Network: undirected, 10 nodes, 18 links, link density 0.400.\n"
     assert out == out_ref
 
+
 def test_BarabasiAlbert_igraph():
-    net = Network.BarabasiAlbert_igraph(n_nodes=100, n_links_each=1)
+    net = Network.Model("BarabasiAlbert_igraph", n_nodes=100, n_links_each=1)
     assert np.allclose(net.link_density, 0.02)
 
+
 def test_ConfigurationModel():
-    net = Network.ConfigurationModel([3 for _ in range(0, 1000)])
+    net = Network.Model("Configuration", degrees=[3 for _ in range(0, 1000)])
     assert int(round(net.degree().mean())) == 3
 
+
+def test_WattsStrogatz():
+    net = Network.Model("WattsStrogatz", N=100, k=2, p=0.1)
+    assert int(round(net.degree().mean())) == 4
+
+
 def test_randomly_rewire(capsys):
     net = Network.SmallTestNetwork()
     net.randomly_rewire(iterations=10)
     out, err = capsys.readouterr()
     out_ref = "Randomly rewiring the network,preserving " + \
               "the degree sequence...\n"
     assert out == out_ref
     print(net)
     out, err = capsys.readouterr()
     out_ref = "Network: undirected, 6 nodes, 7 links, link density 0.467.\n"
     assert out == out_ref
 
+
 def test_edge_list():
     edges = Network.SmallTestNetwork().edge_list()[:8]
     edges_ref = [[0, 3], [0, 4], [0, 5], [1, 2],
                  [1, 3], [1, 4], [2, 1], [2, 4]]
     assert np.array_equal(edges, edges_ref)
 
+
 def test_undirected_adjacency():
     net = Network(adjacency=[[0, 1], [0, 0]], directed=True)
     adj_ref = [[0, 1], [1, 0]]
     assert np.array_equal(net.undirected_adjacency().A, adj_ref)
 
+
 def test_laplacian():
     lap_ref = np.array([[3, 0, 0, -1, -1, -1], [0, 3, -1, -1, -1, 0],
                         [0, -1, 2, 0, -1, 0], [-1, -1, 0, 2, 0, 0],
                         [-1, -1, -1, 0, 3, 0], [-1, 0, 0, 0, 0, 1]])
     assert np.allclose(Network.SmallTestNetwork().laplacian(), lap_ref)
 
+
 def test_nsi_laplacian():
     nsi_lap_ref = np.array([[6.9, 0., 0., -2.1, -2.3, -2.5],
                             [0., 6.3, -1.9, -2.1, -2.3, 0.],
                             [0., -1.7, 4., 0., -2.3, 0.],
                             [-1.5, -1.7, 0., 3.2, 0., 0.],
                             [-1.5, -1.7, -1.9, 0., 5.1, 0.],
                             [-1.5, 0., 0., 0., 0., 1.5]])
     assert np.allclose(Network.SmallTestNetwork().nsi_laplacian(), nsi_lap_ref)
 
+
 def test_degree():
     deg = Network.SmallTestNetwork().degree()
     deg_ref = np.array([3, 3, 2, 2, 3, 1])
     assert (deg == deg_ref).all()
 
+
 def test_indegree():
     deg = Network.SmallDirectedTestNetwork().indegree()
     deg_ref = np.array([2, 2, 2, 1, 1, 0])
     assert (deg == deg_ref).all()
 
+
 def test_outdegree():
     deg = Network.SmallDirectedTestNetwork().outdegree()
     deg_ref = np.array([2, 2, 0, 1, 2, 1])
     assert (deg == deg_ref).all()
 
+
 def test_bildegree():
     deg = Network.SmallDirectedTestNetwork().bildegree()
     deg_ref = np.array([0, 0, 0, 0, 0, 0], dtype=np.int16)
     assert (deg == deg_ref).all()
 
     net = Network.SmallTestNetwork()
     assert (net.bildegree() == net.degree()).all()
 
+
 def test_nsi_degree():
     net = Network.SmallTestNetwork()
 
     deg_ref = np.array([8.4, 8., 5.9, 5.3, 7.4, 4.])
     assert np.allclose(net.nsi_degree(), deg_ref)
 
     deg_ref = np.array([8.4, 8., 5.9, 5.3, 7.4, 4., 4.])
     assert np.allclose(net.splitted_copy().nsi_degree(), deg_ref)
 
     deg_ref = np.array([3.2, 3., 1.95, 1.65, 2.7, 1.])
     assert np.allclose(net.nsi_degree(typical_weight=2.0), deg_ref)
 
     deg_ref = np.array([3.2, 3., 1.95, 1.65, 2.7, 1., 1.])
-
     assert np.allclose(net.splitted_copy().nsi_degree(typical_weight=2.0),
                        deg_ref)
 
-def test_nsi_indegree():
-    net = Network.SmallDirectedTestNetwork()
 
-    deg_ref = np.array([6.3, 5.3, 5.9, 3.6, 4., 2.5])
-    assert np.allclose(net.nsi_indegree(), deg_ref)
+@pytest.mark.parametrize("tw, exp, exp_split", [
+    (None,
+     np.array([6.3, 5.3, 5.9, 3.6, 4., 2.5]),
+     np.array([6.3, 5.3, 5.9, 3.6, 4., 2.5, 2.5])),
+    (2.,
+     np.array([2.15, 1.65, 1.95, 0.8, 1., 0.25]),
+     np.array([2.15, 1.65, 1.95, 0.8, 1., 0.25, 0.25]))
+    ])
+def test_nsi_indegree(tw, exp, exp_split):
+    net = Network.SmallDirectedTestNetwork()
+    assert np.allclose(net.nsi_indegree(typical_weight=tw), exp)
+    assert np.allclose(
+        net.splitted_copy().nsi_indegree(typical_weight=tw), exp_split)
 
-    deg_ref = np.array([6.3, 5.3, 5.9, 3.6, 4., 2.5, 2.5])
-    assert np.allclose(net.splitted_copy().nsi_indegree(), deg_ref)
 
-def test_nsi_outdegree():
+@pytest.mark.parametrize("tw, exp, exp_split", [
+    (None,
+     np.array([5.3, 5.9, 1.9, 3.8, 5.7, 4.]),
+     np.array([5.3, 5.9, 1.9, 3.8, 5.7, 4., 4.])),
+    (2.,
+     np.array([1.65, 1.95, -0.05, 0.9, 1.85, 1.]),
+     np.array([1.65, 1.95, -0.05, 0.9, 1.85, 1., 1.]))
+    ])
+def test_nsi_outdegree(tw, exp, exp_split):
     net = Network.SmallDirectedTestNetwork()
+    assert np.allclose(net.nsi_outdegree(typical_weight=tw), exp)
+    assert np.allclose(net.splitted_copy().nsi_outdegree(typical_weight=tw),
+                       exp_split)
+
 
-    deg_ref = np.array([5.3, 5.9, 1.9, 3.8, 5.7, 4.])
-    assert np.allclose(net.nsi_outdegree(), deg_ref)
+@pytest.mark.parametrize("tw, exp, exp_split", [
+    (None,
+     np.array([1.5, 1.7, 1.9, 2.1, 2.3, 2.5]),
+     np.array([1.5, 1.7, 1.9, 2.1, 2.3, 2.5, 2.5])),
+    (2.,
+     np.array([-0.25, -0.15, -0.05,  0.05,  0.15,  0.25]),
+     np.array([-0.25, -0.15, -0.05,  0.05,  0.15,  0.25,  0.25]))
+    ])
+def test_nsi_bildegree(tw, exp, exp_split):
+    net = Network.SmallDirectedTestNetwork()
+    assert np.allclose(net.nsi_bildegree(typical_weight=tw), exp)
+    assert np.allclose(net.splitted_copy().nsi_bildegree(typical_weight=tw),
+                       exp_split)
 
-    deg_ref = np.array([5.3, 5.9, 1.9, 3.8, 5.7, 4., 4.])
-    assert np.allclose(net.splitted_copy().nsi_outdegree(), deg_ref)
 
 def test_degree_distribution():
     dist = Network.SmallTestNetwork().degree_distribution()
     dist_ref = np.array([0.16666667, 0.33333333, 0.5])
     assert np.allclose(dist, dist_ref)
 
+
 def test_indegree_distribution():
     dist = Network.SmallTestNetwork().indegree_distribution()
     dist_ref = np.array([0.16666667, 0.33333333, 0.5])
     assert np.allclose(dist, dist_ref)
 
+
 def test_outdegree_distribution():
     dist = Network.SmallTestNetwork().outdegree_distribution()
     dist_ref = np.array([0.16666667, 0., 0.33333333, 0.5])
     assert np.allclose(dist, dist_ref)
 
+
 def test_degree_cdf():
     cdf_ref = np.array([1., 0.83333333, 0.5])
     assert np.allclose(Network.SmallTestNetwork().degree_cdf(), cdf_ref)
 
+
 def test_indegree_cdf():
     cdf_ref = np.array([1., 0.83333333, 0.83333333, 0.5])
     assert np.allclose(Network.SmallTestNetwork().indegree_cdf(), cdf_ref)
 
+
 def test_outdegree_cdf():
     cdf_ref = np.array([1., 0.83333333, 0.83333333, 0.5])
     assert np.allclose(Network.SmallTestNetwork().outdegree_cdf(), cdf_ref)
 
+
 def test_nsi_degree_histogram():
     hist = Network.SmallTestNetwork().nsi_degree_histogram()
     hist_ref = (np.array([0.33333333, 0.16666667, 0.5]),
                 np.array([0.11785113, 0.16666667, 0.09622504]),
                 np.array([4., 5.46666667, 6.93333333]))
     assert np.allclose(hist, hist_ref)
 
+
 def test_nsi_degree_cumulative_histogram():
     res = Network.SmallTestNetwork().nsi_degree_cumulative_histogram()
     exp = (np.array([1., 0.66666667, 0.5]),
            np.array([4., 5.46666667, 6.93333333]))
     assert np.allclose(res, exp)
 
+
 def test_average_neighbors_degree():
     res = Network.SmallTestNetwork().average_neighbors_degree()
     exp = np.array([2., 2.33333333, 3., 3., 2.66666667, 3.])
     assert np.allclose(res, exp)
 
+
 def test_max_neighbors_degree():
     res = Network.SmallTestNetwork().max_neighbors_degree()
     exp = np.array([3, 3, 3, 3, 3, 3])
     assert (res == exp).all()
 
+
 def test_nsi_average_neighbors_degree():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_average_neighbors_degree()
     exp = np.array([6.0417, 6.62, 7.0898, 7.0434, 7.3554, 5.65])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_average_neighbors_degree()
     exp = np.array([6.0417, 6.62, 7.0898, 7.0434, 7.3554, 5.65, 5.65])
     assert np.allclose(res, exp)
 
+
 def test_nsi_max_neighbors_degree():
     res = Network.SmallTestNetwork().nsi_max_neighbors_degree()
     exp = np.array([8.4, 8., 8., 8.4, 8.4, 8.4])
     assert np.allclose(res, exp)
 
+
 def test_local_clustering():
     res = Network.SmallTestNetwork().local_clustering()
     exp = np.array([0., 0.33333333, 1., 0., 0.33333333, 0.])
     assert np.allclose(res, exp)
 
+
 def test_global_clustering():
     res = Network.SmallTestNetwork().global_clustering()
     exp = 0.27777777
     assert np.allclose(res, exp)
 
+
 def test_local_cyclemotif_clustering():
     res = Network.SmallDirectedTestNetwork().local_cyclemotif_clustering()
     exp = np.array([0.25, 0.25, 0., 0., 0.5, 0.])
     assert np.allclose(res, exp)
 
+
 def test_local_midmotif_clustering():
     res = Network.SmallDirectedTestNetwork().local_midmotif_clustering()
     exp = np.array([0., 0., 0., 1., 0.5, 0.])
     assert np.allclose(res, exp)
 
+
 def test_local_inmotif_clustering():
     res = Network.SmallDirectedTestNetwork().local_inmotif_clustering()
     exp = np.array([0., 0.5, 0.5, 0., 0., 0.])
     assert np.allclose(res, exp)
 
+
 def test_local_outmotif_clustering():
     res = Network.SmallDirectedTestNetwork().local_outmotif_clustering()
     exp = np.array([0.5, 0.5, 0., 0., 0., 0.])
     assert np.allclose(res, exp)
 
-def test_nsi_local_cyclemotif_clustering():
-    net = Network.SmallDirectedTestNetwork()
 
-    res = net.nsi_local_cyclemotif_clustering()
-    exp = np.array([0.18448637, 0.20275024, 0.3220339,
-                    0.32236842, 0.34385965, 0.625])
-    assert np.allclose(res, exp)
+@pytest.mark.parametrize("tw, exp, exp_split", [
+    (None,
+     np.array([0.18448637, 0.20275024, 0.3220339,
+               0.32236842, 0.34385965, 0.625]),
+     np.array([0.18448637, 0.20275024, 0.3220339,
+               0.32236842, 0.34385965, 0.625, 0.20275024])),
+    (2.,
+     np.array([0.3309814,  0.29011913,  0.05236908,
+               -0.0260989,  0.22417582, -0.13636364]),
+     np.array([0.3309814,  0.29011913,  0.05236908,
+               -0.0260989,  0.22417582, -0.13636364,  0.29011913]))
+    ])
+def test_nsi_local_cyclemotif_clustering(tw, exp, exp_split):
+    net = Network.SmallDirectedTestNetwork()
+    assert np.allclose(net.nsi_local_cyclemotif_clustering(typical_weight=tw),
+                       exp)
+    assert np.allclose(
+        net.splitted_copy(node=1).nsi_local_cyclemotif_clustering(
+            typical_weight=tw),
+        exp_split)
 
-    res = net.splitted_copy(node=1).nsi_local_cyclemotif_clustering()
-    exp = np.array([0.18448637, 0.20275024, 0.3220339,
-                    0.32236842, 0.34385965, 0.625, 0.20275024])
-    assert np.allclose(res, exp)
 
 def test_nsi_local_midmotif_clustering():
     net = Network.SmallDirectedTestNetwork()
 
     res = net.nsi_local_midmotif_clustering()
     exp = np.array([0.45372866, 0.51646946, 1., 1., 0.88815789, 1.])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy(node=4).local_midmotif_clustering()
     exp = np.array([0., 0., 0., 1., 0.8, 0., 0.8])
     assert np.allclose(res, exp)
 
+
 def test_nsi_local_inmotif_clustering():
     net = Network.SmallDirectedTestNetwork()
 
     res = net.nsi_local_inmotif_clustering()
     exp = np.array([0.52884858, 0.66998932, 0.66934789, 0.75694444, 0.755625,
                     1.])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy(node=1).nsi_local_inmotif_clustering()
     exp = np.array([0.52884858, 0.66998932, 0.66934789, 0.75694444, 0.755625,
                     1., 0.66998932])
     assert np.allclose(res, exp)
 
+
 def test_nsi_local_outmotif_clustering():
     net = Network.SmallDirectedTestNetwork()
 
     res = net.nsi_local_outmotif_clustering()
     exp = np.array([0.66998932, 0.66934789, 1., 0.75277008, 0.58387196,
                     0.765625])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy(node=1).nsi_local_outmotif_clustering()
     exp = np.array([0.66998932, 0.66934789, 1., 0.75277008, 0.58387196,
                     0.765625, 0.66934789])
     assert np.allclose(res, exp)
 
+
 def test_transitivity():
     res = Network.SmallTestNetwork().transitivity()
     exp = 0.27272727
     assert np.allclose(res, exp)
 
+
 def test_weighted_local_clustering():
     res = Network.weighted_local_clustering(
         weighted_A=[[0., 0., 0., 0.55, 0.65, 0.75],
                     [0., 0., 0.63, 0.77, 0.91, 0.],
                     [0., 0.63, 0., 0., 1.17, 0.],
                     [0.55, 0.77, 0., 0., 0., 0.],
                     [0.65, 0.91, 1.17, 0., 0., 0.],
                     [0.75, 0., 0., 0., 0., 0.]])
     exp = np.array([0., 0.21487603, 0.35388889, 0., 0.15384615, 0.])
     assert np.allclose(res, exp)
 
+
 def test_nsi_twinness():
     net = Network.SmallDirectedTestNetwork()
 
     res = net.nsi_twinness()
     exp = np.array([[0.12931034, 0.45689655, 0., 0.31034483, 0., 0.],
                     [0., 0.15178571, 0.52678571, 0., 0.35714286, 0.],
                     [0., 0., 0.24358974, 0., 0., 0.],
@@ -535,218 +618,247 @@
                     [0., 0., 0.24358974, 0., 0., 0., 0.],
                     [0., 0.33928571, 0., 0.28378378, 0., 0., 0.],
                     [0.32758621, 0., 0.43298969, 0., 0.2371134, 0., 0.],
                     [0.34482759, 0., 0., 0., 0., 0.38461538, 0.38461538],
                     [0.34482759, 0., 0., 0., 0., 0.38461538, 0.38461538]])
     assert np.allclose(res, exp)
 
+
 def test_assortativity():
     res = Network.SmallTestNetwork().assortativity()
     exp = -0.47368421
     assert np.allclose(res, exp)
 
-def test_nsi_local_clustering():
+
+@pytest.mark.parametrize("tw, exp, exp_split", [
+    (None,
+     np.array([0.55130385, 0.724375, 1., 0.81844073, 0.80277575, 1.]),
+     np.array([0.55130385, 0.724375, 1., 0.81844073, 0.80277575, 1., 1.])),
+    (3.,
+     np.array([-1.44290123, -0.764, 1., 4.16770186, -0.75324675, 1.]),
+     np.array([-1.44290123, -0.764, 1., 4.16770186, -0.75324675, 1., 1.]))
+    ])
+def test_nsi_local_clustering(tw, exp, exp_split):
     net = Network.SmallTestNetwork()
 
-    res = net.nsi_local_clustering()
-    exp = np.array([0.55130385, 0.724375, 1., 0.81844073, 0.80277575, 1.])
-    assert np.allclose(res, exp)
+    assert np.allclose(net.nsi_local_clustering(typical_weight=tw), exp)
+    assert np.allclose(
+        net.splitted_copy().nsi_local_clustering(typical_weight=tw),
+        exp_split)
 
-    res = net.splitted_copy().nsi_local_clustering()
-    exp = np.array([0.55130385, 0.724375, 1., 0.81844073, 0.80277575, 1., 1.])
-    assert np.allclose(res, exp)
 
 def test_nsi_global_clustering():
     res = Network.SmallTestNetwork().nsi_global_clustering()
     exp = 0.83529192
     assert np.allclose(res, exp)
 
+
 def test_nsi_local_soffer_clustering():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_local_soffer_clustering()
     exp = np.array([0.76650246, 0.87537764, 1., 0.81844073, 0.84685032, 1.])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_local_soffer_clustering()
     exp = np.array([0.76650246, 0.87537764, 1., 0.81844073, 0.84685032, 1.,
                     1.])
     assert np.allclose(res, exp)
 
+
 def test_path_lengths():
     res = Network.SmallTestNetwork().path_lengths()
     exp = np.array([[0., 2., 2., 1., 1., 1.],
                     [2., 0., 1., 1., 1., 3.],
                     [2., 1., 0., 2., 1., 3.],
                     [1., 1., 2., 0., 2., 2.],
                     [1., 1., 1., 2., 0., 2.],
                     [1., 3., 3., 2., 2., 0.]])
     assert np.allclose(res, exp)
 
+
 def test_average_path_length():
     res = Network.SmallTestNetwork().average_path_length()
     exp = 1.66666667
     assert np.allclose(res, exp)
 
+
 def test_nsi_average_path_length():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_average_path_length()
     exp = 1.60027778
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_average_path_length()
     exp = 1.60027778
     assert np.allclose(res, exp)
 
+
 def test_diameter():
     res = Network.SmallTestNetwork().diameter()
     exp = 3
     assert np.allclose(res, exp)
 
+
 def test_matching_index():
     res = Network.SmallTestNetwork().matching_index()
     exp = np.array([[1., 0.5, 0.25, 0., 0., 0.],
                     [0.5, 1., 0.25, 0., 0.2, 0.],
                     [0.25, 0.25, 1., 0.33333333, 0.25, 0.],
                     [0., 0., 0.33333333, 1., 0.66666667, 0.5],
                     [0., 0.2, 0.25, 0.66666667, 1., 0.33333333],
                     [0., 0., 0., 0.5, 0.33333333, 1.]])
     assert np.allclose(res, exp)
 
+
 def test_link_betweenness():
     res = Network.SmallTestNetwork().link_betweenness()
     exp = np.array([[0., 0., 0., 3.5, 5.5, 5.],
                     [0., 0., 2., 3.5, 2.5, 0.],
                     [0., 2., 0., 0., 3., 0.],
                     [3.5, 3.5, 0., 0., 0., 0.],
                     [5.5, 2.5, 3., 0., 0., 0.],
                     [5., 0., 0., 0., 0., 0.]])
     assert np.allclose(res, exp)
 
+
 def test_edge_betweenness():
     res = Network.SmallTestNetwork().edge_betweenness()
     exp = np.array([[0., 0., 0., 3.5, 5.5, 5.],
                     [0., 0., 2., 3.5, 2.5, 0.],
                     [0., 2., 0., 0., 3., 0.],
                     [3.5, 3.5, 0., 0., 0., 0.],
                     [5.5, 2.5, 3., 0., 0., 0.],
                     [5., 0., 0., 0., 0., 0.]])
     assert np.allclose(res, exp)
 
+
 def test_betweenness():
     res = Network.SmallTestNetwork().betweenness()
     exp = np.array([4.5, 1.5, 0., 1., 3., 0.])
     assert np.allclose(res, exp)
 
+
 def test_interregional_betweenness():
     net = Network.SmallTestNetwork()
     res = net.interregional_betweenness(sources=[2], targets=[3, 5])
     exp = np.array([1., 1., 0., 0., 1., 0.])
     assert np.allclose(res, exp)
 
     res = net.interregional_betweenness(sources=range(0, 6),
                                         targets=range(0, 6))
     exp = np.array([9., 3., 0., 2., 6., 0.])
     assert np.allclose(res, exp)
 
+
 def test_nsi_interregional_betweenness():
     res = Network.SmallTestNetwork().nsi_interregional_betweenness(
         sources=[2], targets=[3, 5])
     exp = np.array([3.16666689, 2.34705893, 0., 0., 2.06521743, 0.])
     assert np.allclose(res, exp)
 
-def test_nsi_betweenness():
+
+@pytest.mark.parametrize("parallelize", [False, True])
+def test_nsi_betweenness(parallelize):
     net = Network.SmallTestNetwork()
 
-    res = net.nsi_betweenness()
+    res = net.nsi_betweenness(parallelize=parallelize)
     exp = np.array([29.68541738, 7.7128677, 0., 3.09090906, 9.69960462, 0.])
     assert np.allclose(res, exp)
 
-    res = net.splitted_copy().nsi_betweenness()
-    exp = np.array([29.68541738, 7.7128677, 0., 3.09090906, 9.69960462, 0.,
-                    0.])
+    res = net.splitted_copy().nsi_betweenness(parallelize=parallelize)
+    exp = np.append(exp, [0.])
     assert np.allclose(res, exp)
 
+
 def test_eigenvector_centrality():
     res = Network.SmallTestNetwork().eigenvector_centrality()
     exp = np.array([0.7895106, 0.97303126, 0.77694188, 0.69405519, 1.,
                     0.31089413])
     assert np.allclose(res, exp)
 
+
 def test_nsi_eigenvector_centrality():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_eigenvector_centrality()
     exp = np.array([0.80454492, 1., 0.80931481, 0.61787145, 0.98666885,
                     0.28035747])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_eigenvector_centrality()
     exp = np.array([0.80454492, 1., 0.80931481, 0.61787145, 0.98666885,
                     0.28035747, 0.28035747])
     assert np.allclose(res, exp)
 
+
 def test_pagerank():
     res = Network.SmallTestNetwork().pagerank()
     exp = np.array([0.21836231, 0.20440819, 0.14090543, 0.14478497, 0.20466978,
                     0.08686932])
     assert np.allclose(res, exp)
 
+
 def test_closeness():
     res = Network.SmallTestNetwork().closeness()
     exp = np.array([0.71428571, 0.625, 0.55555556, 0.625, 0.71428571,
                     0.45454545])
     assert np.allclose(res, exp)
 
+
 def test_nsi_closeness():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_closeness()
     exp = np.array([0.76923077, 0.64864865, 0.58252427, 0.64171123, 0.72289157,
                     0.50847458])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_closeness()
     exp = np.array([0.76923077, 0.64864865, 0.58252427, 0.64171123, 0.72289157,
                     0.50847458, 0.50847458])
     assert np.allclose(res, exp)
 
+
 def test_nsi_harmonic_closeness():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_harmonic_closeness()
     exp = np.array([0.85, 0.79861111, 0.71111111, 0.72083333, 0.80833333,
                     0.61666667])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_harmonic_closeness()
     exp = np.array([0.85, 0.79861111, 0.71111111, 0.72083333, 0.80833333,
                     0.61666667, 0.61666667])
     assert np.allclose(res, exp)
 
+
 def test_nsi_exponential_closeness():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_exponential_closeness()
     exp = np.array([0.425, 0.390625, 0.346875, 0.36041667, 0.40416667,
                     0.29583333])
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_exponential_closeness()
     exp = np.array([0.425, 0.390625, 0.346875, 0.36041667, 0.40416667,
                     0.29583333, 0.29583333])
     assert np.allclose(res, exp)
 
+
 def test_arenas_betweenness():
     res = Network.SmallTestNetwork().arenas_betweenness()
     exp = np.array([50.18181818, 50.18181818, 33.45454545, 33.45454545,
                     50.18181818, 16.72727273])
     assert np.allclose(res, exp)
 
+
 def test_nsi_arenas_betweenness():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_arenas_betweenness()
     exp = np.array([20.58135241, 29.21033898, 27.00747741, 19.5433536,
                     25.28490117, 24.84826305])
     assert np.allclose(res, exp)
@@ -762,20 +874,22 @@
     assert np.allclose(res, exp)
 
     res = net.nsi_arenas_betweenness(stopping_mode="twinness")
     exp = np.array([22.61533156, 41.23139296, 38.64105931, 28.61953314,
                     38.58242175, 30.29941829])
     assert np.allclose(res, exp)
 
+
 def test_newman_betweenness():
     res = Network.SmallTestNetwork().newman_betweenness()
     exp = np.array([4.1818182, 3.41818185, 2.5090909, 3.0181818, 3.60000002,
                     2.])
     assert np.allclose(res, exp)
 
+
 def test_nsi_newman_betweenness():
     net = Network.SmallTestNetwork()
 
     res = net.nsi_newman_betweenness()
     exp = np.array([0.40476082, 0., 0.85212808, 3.33573728, 1.36618345, 0.])
     assert np.allclose(res, exp)
 
@@ -790,32 +904,37 @@
     assert np.allclose(res, exp)
 
     res = net.splitted_copy().nsi_newman_betweenness(add_local_ends=True)
     exp = np.array([131.44476082, 128., 107.64212808, 102.44573728,
                     124.20618345, 80., 80.])
     assert np.allclose(res, exp)
 
+
 def test_global_efficiency():
     res = Network.SmallTestNetwork().global_efficiency()
     exp = 0.71111111
     assert np.allclose(res, exp)
 
+
 def test_nsi_global_efficiency():
     res = Network.SmallTestNetwork().nsi_global_efficiency()
     exp = 0.74152777
     assert np.allclose(res, exp)
 
+
 def test_local_vulnerability():
     res = Network.SmallTestNetwork().local_vulnerability()
     exp = np.array([0.296875, 0.0625, -0.03125, -0.0078125, 0.09765625,
                     -0.125])
     assert np.allclose(res, exp)
 
+
 def test_coreness():
     res = Network.SmallTestNetwork().coreness()
     exp = np.array([2, 2, 2, 2, 2, 1])
     assert (res == exp).all()
 
+
 def test_msf_synchronizability():
     res = Network.SmallTestNetwork().msf_synchronizability()
     exp = 6.77842586
     assert np.allclose(res, exp)
```

### Comparing `pyunicorn-0.6.1/tests/test_core/test_interacting_networks.py` & `pyunicorn-0.7.0/tests/test_core/test_interacting_networks.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -32,137 +29,170 @@
     exp = [3, 3, 2, 2, 3, 1]
     assert (res == exp).all()
 
     res = rewired_net.cross_degree(node_list1=[0, 3, 5], node_list2=[1, 2, 4])
     exp = [1, 1, 0]
     assert (res == exp).all()
 
+
 def test_internal_adjacency():
     net = InteractingNetworks.SmallTestNetwork()
     res = net.internal_adjacency([0, 3, 5])
     exp = np.array([[0, 1, 1], [1, 0, 0], [1, 0, 0]], dtype=np.int8)
     assert (res == exp).all()
 
     res = net.internal_adjacency([1, 2, 4])
     exp = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]], dtype=np.int8)
     assert (res == exp).all()
 
+
 def test_cross_adjacency():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_adjacency([1, 2, 4], [0, 3, 5])
     exp = np.array([[0, 1, 0], [0, 0, 0], [1, 0, 0]])
     assert (res == exp).all()
 
     res = net.cross_adjacency([1, 2, 3, 4], [0, 5])
     exp = np.array([[0, 0], [0, 0], [1, 0], [1, 0]])
     assert (res == exp).all()
 
+
 def test_cross_adjacency_sparse():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_adjacency_sparse([1, 2, 4], [0, 3, 5])
     exp = [[0, 1, 0], [0, 0, 0], [1, 0, 0]]
     assert (res == exp).all()
 
+
 def test_internal_link_attribute():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_link_attribute("link_weights", [1, 2, 3])
     exp = np.array([[0., 2.3, 2.9],
                     [2.3, 0., 0.],
                     [2.9, 0., 0.]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_cross_link_attribute():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_link_attribute("link_weights", [1, 2, 3], [0, 4])
     exp = np.array([[0., 2.7],
                     [0., 1.5],
                     [1.3, 0.]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_internal_path_lengths():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_path_lengths([0, 3, 5], None)
     exp = np.array([[0., 1., 1.], [1., 0., 2.], [1., 2., 0.]])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.internal_path_lengths([1, 2, 4], None)
     exp = np.array([[0., 1., 1.], [1., 0., 1.], [1., 1., 0.]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_cross_path_lengths():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_path_lengths([0, 3, 5], [1, 2, 4], None)
     exp = np.array([[2., 2., 1.], [1., 2., 2.], [3., 3., 2.]])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.cross_path_lengths([0, 5], [1, 2, 3, 4], None)
     exp = np.array([[2., 2., 1., 1.], [3., 3., 2., 2.]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_number_cross_links():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.number_cross_links([0, 3, 5], [1, 2, 4])
     exp = 2
     assert res == exp
 
     res = net.number_cross_links([0, 5], [1, 2, 3, 4])
     exp = 2
     assert res == exp
 
+
+def test_total_cross_degree():
+    net = InteractingNetworks.SmallTestNetwork()
+
+    res = net.total_cross_degree([0, 3, 5], [1, 2, 4])
+    exp = 0.6667
+    assert np.isclose(res, exp, atol=1e-04)
+
+    res = net.total_cross_degree([0, 5], [1, 2, 3, 4])
+    exp = 1.0
+    assert np.isclose(res, exp, atol=1e-04)
+
+
 def test_number_internal_links():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.number_internal_links([0, 3, 5])
     exp = 2
     assert res == exp
 
     res = net.number_internal_links([1, 2, 4])
     exp = 3
     assert res == exp
 
+
+def test_cross_degree_density():
+    net = InteractingNetworks.SmallTestNetwork()
+
+    res = net.cross_degree_density([0, 3, 5], [1, 2, 4])
+    exp = np.array([0.33333333, 0.33333333, 0.])
+    assert np.allclose(res, exp, atol=1e-04)
+
+
 def test_cross_link_density():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_link_density([0, 3, 5], [1, 2, 4])
     exp = 0.2222
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_link_density([0, 5], [1, 2, 3, 4])
     exp = 0.25
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_internal_link_density():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_link_density([0, 3, 5])
     exp = 0.6667
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.internal_link_density([1, 2, 3, 4])
     exp = 0.6667
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_internal_global_clustering():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_global_clustering([0, 3, 5])
     exp = 0.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.internal_global_clustering([1, 2, 4])
     exp = 0.5556
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_cross_global_clustering():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_global_clustering([0, 3, 5], [1, 2, 4])
     exp = 0.0
     assert np.isclose(res, exp, atol=1e-04)
 
@@ -170,14 +200,15 @@
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_global_clustering([3, 4], [1, 2])
     exp = 0.5
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_cross_global_clustering_sparse():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_global_clustering_sparse([0, 3, 5], [1, 2, 4])
     exp = 0.0
     assert np.isclose(res, exp, atol=1e-04)
 
@@ -185,28 +216,30 @@
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_global_clustering_sparse([3, 4], [1, 2])
     exp = 0.5
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_cross_transitivity():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_transitivity([0, 3, 5], [1, 2, 4])
     exp = 0.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_transitivity([2], [1, 3, 4])
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_transitivity([3, 4], [1, 2])
     exp = 1.0
 
+
 def test_cross_transitivity_sparse():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_transitivity_sparse([0, 3, 5], [1, 2, 4])
     exp = 0.0
     assert np.isclose(res, exp, atol=1e-04)
 
@@ -214,36 +247,55 @@
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_transitivity_sparse([3, 4], [1, 2])
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_cross_average_path_length():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_average_path_length([0, 3, 5], [1, 2, 4], None)
     exp = 2.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.cross_average_path_length([0, 5], [1, 2, 3, 4], None)
     exp = 2.0
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_internal_average_path_length():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_average_path_length([0, 3, 5], None)
     exp = 1.3333
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.internal_average_path_length([1, 2, 4], None)
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
+
+def test_average_cross_closeness():
+    net = InteractingNetworks.SmallTestNetwork()
+
+    res = net.average_cross_closeness([0, 5], [1, 2, 3, 4])
+    exp = 0.5333
+    assert np.isclose(res, exp, atol=1e-04)
+
+
+def test_global_efficiency():
+    net = InteractingNetworks.SmallTestNetwork()
+
+    res = net.global_efficiency([0, 5], [1, 2, 3, 4])
+    exp = 1.7143
+    assert np.isclose(res, exp, atol=1e-04)
+
+
 def test_cross_degree():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_degree([0, 3, 5], [1, 2, 4])
     exp = np.array([1, 1, 0])
     assert (res == exp).all()
 
@@ -251,53 +303,59 @@
     exp = np.array([1, 0, 1])
     assert (res == exp).all()
 
     res = net.cross_degree([1, 2, 3, 4], [0, 5])
     exp = np.array([0, 0, 1, 1])
     assert (res == exp).all()
 
+
 def test_cross_indegree():
     net = InteractingNetworks.SmallDirectedTestNetwork()
 
     res = net.cross_indegree([1, 2], [0, 3, 4])
     exp = np.array([2, 1])
     assert (res == exp).all()
 
+
 def test_cross_outdegree():
     net = InteractingNetworks.SmallDirectedTestNetwork()
 
     res = net.cross_outdegree([1, 2], [0, 3, 4])
     exp = np.array([1, 0])
     assert (res == exp).all()
 
+
 def test_internal_degree():
     net = InteractingNetworks.SmallDirectedTestNetwork()
 
     res = net.internal_degree([0, 3, 5])
     exp = np.array([2, 1, 1])
     assert (res == exp).all()
 
     res = net.internal_degree([1, 2, 4])
     exp = np.array([2, 2, 2])
     assert (res == exp).all()
 
+
 def test_internal_indegree():
     net = InteractingNetworks.SmallDirectedTestNetwork()
 
     res = net.internal_indegree([0, 1, 3])
     exp = np.array([0, 2, 1])
     assert (res == exp).all()
 
+
 def test_internal_outdegree():
     net = InteractingNetworks.SmallDirectedTestNetwork()
 
     res = net.internal_outdegree([0, 1, 3])
     exp = np.array([2, 0, 1])
     assert (res == exp).all()
 
+
 def test_cross_local_clustering():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_local_clustering([0, 3, 5], [1, 2, 4])
     exp = np.array([0., 0., 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
@@ -305,14 +363,15 @@
     exp = np.array([1.])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.cross_local_clustering([3, 4], [1, 2])
     exp = np.array([0., 1.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_cross_local_clustering_sparse():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_local_clustering_sparse([0, 3, 5], [1, 2, 4])
     exp = np.array([0., 0., 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
@@ -320,171 +379,195 @@
     exp = np.array([1.])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.cross_local_clustering_sparse([3, 4], [1, 2])
     exp = np.array([0., 1.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_cross_closeness():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_closeness([0, 3, 5], [1, 2, 4], None)
     exp = np.array([0.6, 0.6, 0.375])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.cross_closeness([0, 5], [1, 2, 3, 4], None)
     exp = np.array([0.66666667, 0.4])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_internal_closeness():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_closeness([0, 3, 5], None)
     exp = np.array([1., 0.66666667, 0.66666667])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.internal_closeness([1, 2, 4], None)
     exp = np.array([1., 1., 1.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_cross_betweenness():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.cross_betweenness([2], [3, 5])
     exp = np.array([1., 1., 0., 0., 1., 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.cross_betweenness(range(0, 6), range(0, 6))
     exp = np.array([9., 3., 0., 2., 6., 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_internal_betweenness():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.internal_betweenness(range(0, 6))
     exp = np.array([9., 3., 0., 2., 6., 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
+def test_local_efficiency():
+    net = InteractingNetworks.SmallTestNetwork()
+
+    res = net.local_efficiency([0, 5], [1, 2, 3, 4])
+    exp = np.array([0.75, 0.41666667])
+    assert np.allclose(res, exp, atol=1e-04)
+
+
 def test_nsi_cross_degree():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_degree([0, 1, 2], [3, 4, 5])
     exp = np.array([4.2, 2.6, 1.4])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_degree([0, 2, 5], [1, 4])
     exp = np.array([1.4, 2.2, 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_mean_degree():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_mean_degree([0, 1, 2], [3, 4, 5])
     exp = 2.5
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_mean_degree([0, 2, 5], [1, 4])
     exp = 0.95
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_nsi_internal_degree():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_internal_degree([0, 3, 5])
     exp = np.array([3.4, 1.8, 2.2])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_internal_degree([0, 1, 3, 5])
     exp = np.array([3.4, 2., 2.6, 2.2])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_local_clustering():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_local_clustering([0, 1, 2], [3, 4, 5])
     exp = np.array([0.33786848, 0.50295858, 1.])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_local_clustering([0, 2, 5], [1, 4])
     exp = np.array([1., 1., 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_closeness_centrality():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_closeness_centrality([0, 1, 2], [3, 4, 5])
     exp = np.array([1., 0.56756757, 0.48837209])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_closeness_centrality([0, 2, 5], [1, 4])
     exp = np.array([0.73333333, 1., 0.42307692])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_internal_closeness_centrality():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_internal_closeness_centrality([0, 3, 5])
     exp = np.array([1., 0.68, 0.73913043])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_internal_closeness_centrality([0, 1, 3, 5])
     exp = np.array([0.84, 0.525, 0.72413793, 0.6])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_global_clustering():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_global_clustering([0, 1, 2], [3, 4, 5])
     exp = 0.6688
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_nsi_internal_local_clustering():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_internal_local_clustering([1, 2, 3, 5])
     exp = np.array([0.73333333, 1., 1., 1.])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_internal_local_clustering([0, 2, 4])
     exp = np.array([1., 1., 0.86666667])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_betweenness():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_betweenness([0, 4, 5], [1, 3])
     exp = np.array([6.5333, 1.2, 0., 0.6769, 0.6769, 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_betweenness([0, 1], [2, 3, 4, 5])
     exp = np.array([2.1333, 0., 0., 0.4923, 0.9209, 0.])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_edge_density():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_edge_density([1, 2, 3], [0, 5])
     exp = 0.1091
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_edge_density([0], [1, 4, 5])
     exp = 0.7895
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_transitivity():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_transitivity([1, 2], [0, 3, 4, 5])
     exp = 0.6352
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.nsi_cross_transitivity([0, 2, 3], [1])
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_nsi_cross_average_path_length():
     net = InteractingNetworks.SmallTestNetwork()
 
     res = net.nsi_cross_average_path_length([0, 5], [1, 2, 4])
     exp = 3.3306
     assert np.isclose(res, exp, atol=1e-04)
```

### Comparing `pyunicorn-0.6.1/tests/test_core/test_data.py` & `pyunicorn-0.7.0/tests/test_core/test_data.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -44,37 +41,40 @@
                          8.09016994e-01, 5.87785252e-01, -8.09016994e-01],
                         [3.09016994e-01, -9.51056516e-01, -3.09016994e-01,
                          9.51056516e-01, 3.09016994e-01, -9.51056516e-01]])
 
     isequal = np.allclose(obs, obs_ref)
     assert isequal
 
+
 def test_window():
     lon_min = Data.SmallTestData().window()["lon_min"]
     lon_max = Data.SmallTestData().window()["lon_max"]
     lon_min_ref = 2.5
     lon_max_ref = 15.0
     isequal = np.allclose(lon_min, lon_min_ref) and \
-              np.allclose(lon_max, lon_max_ref)
+        np.allclose(lon_max, lon_max_ref)
     assert isequal
 
+
 def test_set_window():
     data = Data.SmallTestData()
     data.set_window(window={"time_min": 0., "time_max": 4., "lat_min": 10.,
                             "lat_max": 20., "lon_min": 5., "lon_max": 10.})
     obs = data.observable()
     obs_ref = np.array([[1.22464680e-16, -1.00000000e+00],
                         [-3.09016994e-01, -9.51056516e-01],
                         [-5.87785252e-01, -8.09016994e-01],
                         [-8.09016994e-01, -5.87785252e-01],
                         [-9.51056516e-01, -3.09016994e-01]])
 
     isequal = np.allclose(obs, obs_ref)
     assert isequal
 
+
 def test_set_global_window():
     data = Data.SmallTestData()
     data.set_window(window={"time_min": 0., "time_max": 4.,
                             "lat_min": 10., "lat_max": 20., "lon_min": 5.,
                             "lon_max": 10.})
 
     lat1 = data.grid.grid()["lat"]
@@ -83,46 +83,50 @@
 
     lat1_ref = np.array([10., 15.], dtype=np.float32)
     lat2_ref = np.array([0., 5., 10., 15., 20., 25.], dtype=np.float32)
 
     isequal = np.allclose(lat1, lat1_ref) and np.allclose(lat2, lat2_ref)
     assert isequal
 
+
 def test_normalize_time_series_array():
     ts = np.arange(16).reshape(4, 4).astype("float")
     Data.normalize_time_series_array(ts)
 
     mean = ts.mean(axis=0)
     std = ts.std(axis=0)
     ts = ts[:, 0]
 
     mean_ref = np.array([0., 0., 0., 0.])
     std_ref = np.array([1., 1., 1., 1.])
     ts_ref = np.array([-1.34164079, -0.4472136, 0.4472136, 1.34164079])
 
     isequal = np.allclose(mean, mean_ref) and np.allclose(std, std_ref) and \
-              np.allclose(ts, ts_ref)
+        np.allclose(ts, ts_ref)
     assert isequal
 
+
 def test_next_power_2():
     isequal = np.allclose(Data.next_power_2(253), 256)
     assert isequal
 
+
 def test_zero_pad_data():
     ts = np.arange(20).reshape(5, 4)
     zpd = Data.zero_pad_data(ts)
 
     zpd_ref = np.array([[0., 0., 0., 0.], [0., 1., 2., 3.],
                         [4., 5., 6., 7.], [8., 9., 10., 11.],
                         [12., 13., 14., 15.], [16., 17., 18., 19.],
                         [0., 0., 0., 0.], [0., 0., 0., 0.]])
 
     isequal = np.allclose(zpd, zpd_ref)
     assert isequal
 
+
 def test_cos_window():
     ts = np.arange(24).reshape(12, 2)
     cw = Data.cos_window(data=ts, gamma=0.75)
     cw_ref = np.array([[0., 0.], [0.14644661, 0.14644661],
                        [0.5, 0.5], [0.85355339, 0.85355339],
                        [1., 1.], [1., 1.],
                        [1., 1.], [1., 1.],
```

### Comparing `pyunicorn-0.6.1/tests/test_core/test_resistive_networks.py` & `pyunicorn-0.7.0/tests/test_core/test_resistive_networks.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -20,29 +17,33 @@
 import numpy as np
 
 from pyunicorn import ResNetwork
 
 # -----------------------------------------------------------------------------
 # Class member tests with TestNetwork
 # -----------------------------------------------------------------------------
+
+
 def test_init(capsys):
     print(ResNetwork.SmallTestNetwork())
     out, err = capsys.readouterr()
-    out_ref = "ResNetwork:\nGeoNetwork:\n" + \
+    out_ref = "ResNetwork:\nGeoNetwork:\nSpatialNetwork:\n" + \
               "Network: undirected, 5 nodes, 5 links, link density 0.500." + \
               "\nGeographical boundaries:\n" + \
               "         time     lat     lon\n" + \
               "   min    0.0    0.00 -180.00\n" + \
               "   max    9.0   90.00  180.00\n" + \
               "Average resistance: 2.4\n"
     assert out == out_ref
 
+
 def test_SmallTestNetwork():
     assert isinstance(ResNetwork.SmallTestNetwork(), ResNetwork)
 
+
 def test_SmallComplexNetwork():
     net = ResNetwork.SmallComplexNetwork()
     assert net.flagComplex
 
     adm = net.get_admittance()
 
     res = adm.real
@@ -57,14 +58,15 @@
     exp = [[0., -0.2, 0., 0., 0.],
            [-0.2, 0., -0.0625, -0.25, 0.],
            [0., -0.0625, 0., -0.0625, 0.],
            [0., -0.25, -0.0625, 0., -0.05],
            [0., 0., 0., -0.05, 0.]]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_update_resistances():
     net = ResNetwork.SmallTestNetwork()
     net.update_resistances(net.adjacency)
 
     res = net.get_admittance()
     exp = [[0., 1., 0., 0., 0.],
            [1., 0., 1., 1., 0.],
@@ -77,112 +79,127 @@
     exp = [[1., -1., 0., 0., 0.],
            [-1., 3., -1., -1., 0.],
            [0., -1., 2., -1., 0.],
            [0., -1., -1., 3., -1.],
            [0., 0., 0., -1., 1.]]
     assert (res == exp).all()
 
+
 def test_update_admittance():
     net = ResNetwork.SmallTestNetwork()
     net.update_admittance()
     assert True
 
+
 def test_get_admittance():
     net = ResNetwork.SmallTestNetwork()
 
     res = net.get_admittance()
     exp = [[0., 0.5, 0., 0., 0.],
            [0.5, 0., 0.125, 0.5, 0.],
            [0., 0.125, 0., 0.125, 0.],
            [0., 0.5, 0.125, 0., 0.1],
            [0., 0., 0., 0.1, 0.]]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_update_R():
     net = ResNetwork.SmallTestNetwork()
     net.update_R()
     assert True
 
+
 def test_get_R():
     res = ResNetwork.SmallTestNetwork().get_R()
     exp = [[2.28444444, 0.68444444, -0.56, -0.20444444, -2.20444444],
            [0.68444444, 1.08444444, -0.16, 0.19555556, -1.80444444],
            [-0.56, -0.16, 3.04, -0.16, -2.16],
            [-0.20444444, 0.19555556, -0.16, 1.08444444, -0.91555556],
            [-2.20444444, -1.80444444, -2.16, -0.91555556, 7.08444444]]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_admittance_laplacian():
     res = ResNetwork.SmallTestNetwork().admittance_lapacian()
-    exp = [[0.5, -0.5, 0., 0., 0.,],
+    exp = [[0.5, -0.5, 0., 0., 0.],
            [-0.5, 1.125, -0.125, -0.5, 0.],
            [0., -0.125, 0.25, -0.125, 0.],
            [0., -0.5, -0.125, 0.725, -0.1],
            [0., 0., 0., -0.1, 0.1]]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_admittive_degree():
     res = ResNetwork.SmallTestNetwork().admittive_degree()
     exp = [0.5, 1.125, 0.25, 0.725, 0.1]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_average_neighbors_admittive_degree():
     res = ResNetwork.SmallTestNetwork().average_neighbors_admittive_degree()
     exp = [2.25, 1.31111111, 7.4, 2.03448276, 7.25]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_local_admittive_clustering():
     res = ResNetwork.SmallTestNetwork().local_admittive_clustering()
     exp = [0., 0.00694444, 0.0625, 0.01077586, 0.]
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_global_admittive_clustering():
     res = ResNetwork.SmallTestNetwork().global_admittive_clustering()
     exp = 0.016
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_effective_resistance():
     net = ResNetwork.SmallTestNetwork()
 
     res = net.effective_resistance(1, 1)
     exp = 0.0
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.effective_resistance(1, 2)
     exp = 4.4444
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_average_effective_resistance():
     res = ResNetwork.SmallTestNetwork().average_effective_resistance()
     exp = 7.2889
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_diameter_effective_resistance():
     res = ResNetwork.SmallTestNetwork().diameter_effective_resistance()
     exp = 14.4444
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_effective_resistance_closeness_centrality():
     net = ResNetwork.SmallTestNetwork()
 
     res = net.effective_resistance_closeness_centrality(0)
     exp = 0.1538
     assert np.isclose(res, exp, atol=1e-04)
 
     res = net.effective_resistance_closeness_centrality(4)
     exp = 0.08
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_vertex_current_flow_betweenness():
     net = ResNetwork.SmallTestNetwork()
 
     res = net.vertex_current_flow_betweenness(1)
     exp = 0.3889
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_edge_current_flow_betweenness():
     net = ResNetwork.SmallTestNetwork()
 
     res = net.edge_current_flow_betweenness()
     exp = [[0., 0.4, 0., 0., 0.],
            [0.4, 0., 0.2444, 0.5333, 0.],
            [0., 0.2444, 0., 0.2444, 0.],
```

### Comparing `pyunicorn-0.6.1/tests/test_core/ResistiveNetwork_utils.py` & `pyunicorn-0.7.0/tests/test_core/ResistiveNetwork_utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,14 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#
 # Copyright (C) 2014 SWIPO Project
 #
 # Authors (this file):
 #   Stefan Schinkel <stefan.schinkel@gmail.com>
-""" Utils needed for Unit Tests in resistive networks
+
+"""
+Utils needed for Unit Tests in resistive networks
 """
 import numpy as np
 
 
 def makeNW(idI, idJ, val=None):
     """Construct NW from edges
     """
```

### Comparing `pyunicorn-0.6.1/tests/test_climate/test_climate_network.py` & `pyunicorn-0.7.0/tests/test_climate/test_climate_network.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -17,112 +14,126 @@
 """
 Simple tests for the ClimateNetwork class.
 """
 import numpy as np
 
 from pyunicorn.climate.climate_network import ClimateNetwork
 
+
 def test_str(capsys):
     print(ClimateNetwork.SmallTestNetwork())
     out, err = capsys.readouterr()
     out_ref = "ClimateNetwork:\n" + \
               "GeoNetwork:\n" + \
+              "SpatialNetwork:\n" + \
               "Network: undirected, 6 nodes, 7 links, link density 0.467." + \
               "\nGeographical boundaries:\n" + \
               "         time     lat     lon\n" + \
               "   min    0.0    0.00    2.50\n" + \
               "   max    9.0   25.00   15.00\n" + \
               "Threshold: 0.5\n" + \
               "Local connections filtered out: False\n"
     assert out == out_ref
 
+
 def test_SmallTestNetwork():
     res = ClimateNetwork.SmallTestNetwork().adjacency
     exp = np.array([[0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0],
                     [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0],
                     [1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_link_density_function():
     res = ClimateNetwork.SmallTestNetwork().link_density_function(5)
     exp = (np.array([0., 0.2778, 0.4444, 0.6111, 0.7222]),
            np.array([0.1, 0.28, 0.46, 0.64, 0.82, 1.]))
 
     assert np.allclose(res[0], exp[0], atol=1e-04)
     assert np.allclose(res[1], exp[1], atol=1e-04)
 
+
 def test_threshold_from_link_density():
     res = ClimateNetwork.SmallTestNetwork().\
         threshold_from_link_density(link_density=0.5)
     exp = 0.4
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_similarity_measure():
     res = ClimateNetwork.SmallTestNetwork().similarity_measure()[0, :]
     exp = np.array([1., 0.1, 0.2, 0.6, 0.7, 0.55])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_non_local():
     res = ClimateNetwork.SmallTestNetwork().non_local()
     exp = False
     assert res == exp
 
+
 def test_set_non_local():
     net = ClimateNetwork.SmallTestNetwork()
     net.set_non_local(non_local=True)
 
     res = net.adjacency
     exp = np.array([[0, 0, 0, 1, 1, 1], [0, 0, 0, 1, 1, 0],
                     [0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0],
                     [1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_threshold():
     res = ClimateNetwork.SmallTestNetwork().threshold()
     exp = 0.5
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_set_threshold():
     net = ClimateNetwork.SmallTestNetwork()
 
     res = net.n_links
     exp = 7
     assert res == exp
 
     net.set_threshold(threshold=0.7)
     res = net.n_links
     exp = 3
     assert res == exp
 
+
 def test_set_link_density():
     net = ClimateNetwork.SmallTestNetwork()
 
     res = net.link_density
     exp = 0.4667
     assert np.isclose(res, exp, atol=1e-04)
 
     net.set_link_density(link_density=0.7)
     res = net.link_density
     exp = 0.6667
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_correlation_distance():
     res = ClimateNetwork.SmallTestNetwork().correlation_distance().round(2)
     exp = np.array([[0., 0.01, 0.04, 0.18, 0.27, 0.27],
                     [0.01, 0., 0.05, 0.18, 0.29, 0.12],
                     [0.04, 0.05, 0., 0.02, 0.16, 0.03],
                     [0.18, 0.18, 0.01, 0., 0.01, 0.06],
                     [0.27, 0.29, 0.16, 0.01, 0., 0.04],
                     [0.27, 0.12, 0.03, 0.06, 0.04, 0.]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_correlation_distance_weighted_closeness():
     res = ClimateNetwork.SmallTestNetwork().\
         correlation_distance_weighted_closeness()
     exp = np.array([0.1646, 0.1351, 0.0894, 0.1096, 0.1659, 0.1102])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_local_correlation_distance_weighted_vulnerability():
     res = ClimateNetwork.SmallTestNetwork().\
         local_correlation_distance_weighted_vulnerability()
     exp = np.array([0.4037, 0.035, -0.1731, -0.081, 0.3121, -0.0533])
     assert np.allclose(res, exp, atol=1e-04)
```

### Comparing `pyunicorn-0.6.1/tests/test_climate/test_climate_data.py` & `pyunicorn-0.7.0/tests/test_climate/test_climate_data.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -21,74 +18,83 @@
 
 from pyunicorn.core.data import Data
 from pyunicorn.climate.climate_data import ClimateData
 
 # -----------------------------------------------------------------------------
 # Class member tests
 # -----------------------------------------------------------------------------
+
+
 def test_SmallTestData():
     res = Data.SmallTestData().observable()
     exp = np.array([[0., 1., 0., -1., -0., 1.],
                     [0.309, 0.9511, -0.309, -0.9511, 0.309, 0.9511],
                     [0.5878, 0.809, -0.5878, -0.809, 0.5878, 0.809],
                     [0.809, 0.5878, -0.809, -0.5878, 0.809, 0.5878],
                     [0.9511, 0.309, -0.9511, -0.309, 0.9511, 0.309],
                     [1., 0., -1., -0., 1., 0.],
                     [0.9511, -0.309, -0.9511, 0.309, 0.9511, -0.309],
                     [0.809, -0.5878, -0.809, 0.5878, 0.809, -0.5878],
                     [0.5878, -0.809, -0.5878, 0.809, 0.5878, -0.809],
                     [0.309, -0.9511, -0.309, 0.9511, 0.309, -0.9511]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_phase_indices():
     res = ClimateData.SmallTestData().phase_indices()
     exp = np.array([[0, 5], [1, 6], [2, 7], [3, 8], [4, 9]])
     assert (res == exp).all()
 
+
 def test_indices_selected_phases():
     res = ClimateData.SmallTestData().indices_selected_phases([0, 1, 4])
     exp = np.array([0, 1, 4, 5, 6, 9])
     assert (res == exp).all()
 
+
 def test_phase_mean():
     res = ClimateData.SmallTestData().phase_mean()
     exp = np.array([[0.5, 0.5, -0.5, -0.5, 0.5, 0.5],
                     [0.63, 0.321, -0.63, -0.321, 0.63, 0.321],
                     [0.6984, 0.1106, -0.6984, -0.1106, 0.6984, 0.1106],
                     [0.6984, -0.1106, -0.6984, 0.1106, 0.6984, -0.1106],
                     [0.63, -0.321, -0.63, 0.321, 0.63, -0.321]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_anomaly():
     res = ClimateData.SmallTestData().anomaly()[:, 0]
     exp = np.array([-0.5, -0.321, -0.1106, 0.1106, 0.321,
                     0.5, 0.321, 0.1106, -0.1106, -0.321])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_shuffled_anomaly():
     res = ClimateData.SmallTestData().anomaly().std(axis=0)
     exp = np.array([0.31, 0.6355, 0.31, 0.6355, 0.31, 0.6355])
     assert np.allclose(res, exp, atol=1e-04)
 
     res = ClimateData.SmallTestData().shuffled_anomaly().std(axis=0)
     exp = np.array([0.31, 0.6355, 0.31, 0.6355, 0.31, 0.6355])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_window():
     data = ClimateData.SmallTestData()
     data.set_window(window={"time_min": 0., "time_max": 0.,
                             "lat_min": 10., "lat_max": 20.,
                             "lon_min": 5., "lon_max": 10.})
     res = data.anomaly()
     exp = np.array([[0.5, -0.5], [0.321, -0.63], [0.1106, -0.6984],
                     [-0.1106, -0.6984], [-0.321, -0.63], [-0.5, 0.5],
                     [-0.321, 0.63], [-0.1106, 0.6984], [0.1106, 0.6984],
                     [0.321, 0.63]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_set_global_window():
     data = ClimateData.SmallTestData()
     data.set_window(window={"time_min": 0., "time_max": 4.,
                             "lat_min": 10., "lat_max": 20.,
                             "lon_min": 5., "lon_max": 10.})
     res = data.grid.grid()["lat"]
     exp = np.array([10., 15.], dtype=np.float32)
```

### Comparing `pyunicorn-0.6.1/tests/test_climate/test_eventsynchronization_climatenetwork.py` & `pyunicorn-0.7.0/tests/test_climate/test_eventseries_climatenetwork.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,55 +1,59 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
 # L. Tupikina, V. Stolbova, R.V. Donner, N. Marwan, H.A. Dijkstra,
 # and J. Kurths, "Unified functional network and nonlinear time series analysis
 # for complex systems science: The pyunicorn package"
+
 """
-Tests for the EventSynchronizationClimateNetworkClimateData class.
+Tests for the EventSeriesClimateNetwork class.
 """
 import numpy as np
 
 from pyunicorn.core.data import Data
-from pyunicorn.climate.eventsynchronization_climatenetwork import\
- EventSynchronizationClimateNetwork
+from pyunicorn.climate.eventseries_climatenetwork import\
+ EventSeriesClimateNetwork
 
 
 def test_str(capsys):
-    data = EventSynchronizationClimateNetwork.SmallTestData()
-    print(EventSynchronizationClimateNetwork(data, 0.8, 16))
+    data = EventSeriesClimateNetwork.SmallTestData()
+    print(EventSeriesClimateNetwork(data, method='ES',
+                                    threshold_method='quantile',
+                                    threshold_values=0.8, taumax=16,
+                                    threshold_types='above'))
     out, err = capsys.readouterr()
     out_ref = "Extracting network adjacency matrix by thresholding...\n" + \
               "Setting area weights according to type surface ...\n" + \
               "Setting area weights according to type surface ...\n" + \
-              "EventSynchronizationClimateNetwork:\n" + \
-              "EventSynchronization: 6 variables, 10 timesteps, taumax: 16" + \
+              "EventSeriesClimateNetwork:\n" + \
+              "EventSeries: 6 variables, 10 timesteps, taumax: 16.0, " \
+              "lag: 0.0" + \
               "\nClimateNetwork:\n" + \
               "GeoNetwork:\n" + \
+              "SpatialNetwork:\n" + \
               "Network: directed, 6 nodes, 0 links, link density 0.000.\n" + \
               "Geographical boundaries:\n" + \
               "         time     lat     lon\n" + \
               "   min    0.0    0.00    2.50\n" + \
               "   max    9.0   25.00   15.00\n" + \
               "Threshold: 0\n" + \
               "Local connections filtered out: False\n" + \
-              "Type of event synchronization to construct " + \
+              "Type of event series measure to construct " + \
               "the network: directedES\n"
     assert out == out_ref
 
+
 def test_SmallTestData():
     res = Data.SmallTestData().observable()
     exp = np.array([[0., 1., 0., -1., -0., 1.],
                     [0.309, 0.9511, -0.309, -0.9511, 0.309, 0.9511],
                     [0.5878, 0.809, -0.5878, -0.809, 0.5878, 0.809],
                     [0.809, 0.5878, -0.809, -0.5878, 0.809, 0.5878],
                     [0.9511, 0.309, -0.9511, -0.309, 0.9511, 0.309],
```

### Comparing `pyunicorn-0.6.1/tests/test_climate/test_tsonis.py` & `pyunicorn-0.7.0/tests/test_climate/test_tsonis.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,10 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
 # This file is part of pyunicorn.
-# Copyright (C) 2008--2019 Jonathan F. Donges and pyunicorn authors
-# URL: <http://www.pik-potsdam.de/members/donges/software>
+# Copyright (C) 2008--2024 Jonathan F. Donges and pyunicorn authors
+# URL: <https://www.pik-potsdam.de/members/donges/software-2/software>
 # License: BSD (3-clause)
 #
 # Please acknowledge and cite the use of this software and its authors
 # when results are used in publications or published elsewhere.
 #
 # You can use the following reference:
 # J.F. Donges, J. Heitzig, B. Beronov, M. Wiedermann, J. Runge, Q.-Y. Feng,
@@ -18,83 +15,93 @@
 Tests for the TsonisClimateNetwork class.
 """
 import numpy as np
 
 from pyunicorn.climate.climate_data import ClimateData
 from pyunicorn.climate.tsonis import TsonisClimateNetwork
 
+
 def test_str(capsys):
     print(TsonisClimateNetwork.SmallTestNetwork())
     out, err = capsys.readouterr()
     out_ref = "TsonisClimateNetwork:\n" + \
               "ClimateNetwork:\n" + \
               "GeoNetwork:\n" + \
+              "SpatialNetwork:\n" + \
               "Network: undirected, 6 nodes, 6 links, link density 0.400." + \
               "\nGeographical boundaries:\n" + \
               "         time     lat     lon\n" + \
               "   min    0.0    0.00    2.50\n" + \
               "   max    9.0   25.00   15.00\n" + \
               "Threshold: 0.5\n" + \
               "Local connections filtered out: False\n" + \
               "Use only data points from winter months: False\n"
     assert out == out_ref
 
+
 def test_SmallTestNetwork():
     res = TsonisClimateNetwork.SmallTestNetwork().adjacency
     exp = np.array([[0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1],
                     [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1],
                     [1, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0]])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_calculate_similarity_measure():
     res = TsonisClimateNetwork.SmallTestNetwork().calculate_similarity_measure(
         anomaly=ClimateData.SmallTestData().anomaly())
     exp = np.array([[1., -0.2538, -1., 0.2538, 1., -0.2538],
                     [-0.2538, 1., 0.2538, -1., -0.2538, 1.],
                     [-1., 0.2538, 1., -0.2538, -1., 0.2538],
                     [0.2538, -1., -0.2538, 1., 0.2538, -1.],
                     [1., -0.2538, -1., 0.2538, 1., -0.2538],
                     [-0.2538, 1., 0.2538, -1., -0.2538, 1.]],
                    dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_correlation():
     res = TsonisClimateNetwork.SmallTestNetwork().correlation()
     exp = np.array([[1., 0.25377226, 1., 0.25377226, 1., 0.25377226],
                     [0.25377226, 1., 0.25377226, 1., 0.25377226, 1.],
                     [1., 0.25377226, 1., 0.25377226, 1., 0.25377226],
                     [0.25377226, 1., 0.25377226, 1., 0.25377226, 1.],
                     [1., 0.25377226, 1., 0.25377226, 1., 0.25377226],
                     [0.25377226, 1., 0.25377226, 1., 0.25377226, 1.]],
                    dtype=np.float32)
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_winter_only():
     res = TsonisClimateNetwork.SmallTestNetwork().winter_only()
     exp = False
     assert res == exp
 
+
 def test_set_winter_only():
     net = TsonisClimateNetwork.SmallTestNetwork()
     net.set_winter_only(winter_only=False)
 
     res = net.n_links
     exp = 6
     assert res == exp
 
+
 def test_correlation_weighted_average_path_length():
     res = TsonisClimateNetwork.SmallTestNetwork().\
             correlation_weighted_average_path_length()
     exp = 1.0
     assert np.isclose(res, exp, atol=1e-04)
 
+
 def test_correlation_weighted_closeness():
     res = TsonisClimateNetwork.SmallTestNetwork().\
                 correlation_weighted_closeness()
     exp = np.array([0.25, 0.25, 0.25, 0.25, 0.25, 0.25])
     assert np.allclose(res, exp, atol=1e-04)
 
+
 def test_local_correlation_weighted_vulnerability():
     res = TsonisClimateNetwork.SmallTestNetwork().\
                 local_correlation_weighted_vulnerability()
     exp = np.array([0., 0., 0., 0., 0., 0.])
     assert np.allclose(res, exp, atol=1e-04)
```

### Comparing `pyunicorn-0.6.1/docs/Makefile` & `pyunicorn-0.7.0/docs/Makefile`

 * *Files identical despite different names*

### Comparing `pyunicorn-0.6.1/docs/source/conf.py` & `pyunicorn-0.7.0/docs/source/conf.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-#
 # pyunicorn documentation build configuration file, created by
 # sphinx-quickstart on Thu Feb 23 19:15:07 2017.
 #
 # This file is execfile()d with the current directory set to its
 # containing dir.
 #
 # Note that not all possible configuration values are present in this
@@ -17,15 +15,15 @@
 # documentation root, use os.path.abspath to make it absolute, like shown here.
 
 import re
 import os
 import sys
 
 sys.path.insert(0, os.path.abspath('../..'))
-from setup import __version__
+from pyunicorn import __version__
 
 
 # -- General configuration ------------------------------------------------
 
 # If your documentation needs a minimal Sphinx version, state it here.
 needs_sphinx = '1.3'
 
@@ -36,15 +34,17 @@
     'sphinx.ext.autodoc',
     'sphinx.ext.doctest',
     'sphinx.ext.todo',
     'sphinx.ext.coverage',
     'sphinx.ext.mathjax',
     'sphinx.ext.ifconfig',
     'sphinx.ext.viewcode',
-    'sphinx.ext.githubpages'
+    'sphinx.ext.githubpages',
+    'nbsphinx',
+    'nbsphinx_link',
 ]
 
 # Add any paths that contain templates here, relative to this directory.
 templates_path = ['_templates']
 
 # The suffix(es) of source filenames.
 # You can specify multiple suffix as a list of string:
@@ -52,23 +52,23 @@
 source_suffix = ['.rst', '.md']
 
 # The master toctree document.
 master_doc = 'sitemap'
 
 # General information about the project.
 project = u'pyunicorn'
-copyright = u'2008-2019, Jonathan F. Donges and pyunicorn authors'
+copyright = u'2008-2024, Jonathan F. Donges and pyunicorn authors'
 author = u'Jonathan F. Donges'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
 # built documents.
 #
 # The short X.Y version.
-version = re.search('\d*\.\d*', __version__).group()
+version = re.search(r'\d*\.\d*', __version__).group()
 # The full version, including alpha/beta/rc tags.
 release = __version__
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
 #
 # This is also used if you do content translation via gettext catalogs.
```

### Comparing `pyunicorn-0.6.1/docs/source/_static/logo.png` & `pyunicorn-0.7.0/docs/source/_static/logo.png`

 * *Files identical despite different names*

### Comparing `pyunicorn-0.6.1/docs/source/_static/default.css` & `pyunicorn-0.7.0/docs/source/_static/default.css`

 * *Files identical despite different names*

### Comparing `pyunicorn-0.6.1/docs/source/_static/logo.psd` & `pyunicorn-0.7.0/docs/source/_static/logo.psd`

 * *Files identical despite different names*

### Comparing `pyunicorn-0.6.1/docs/source/api_doc.rst` & `pyunicorn-0.7.0/docs/source/api_doc.rst`

 * *Files identical despite different names*

### Comparing `pyunicorn-0.6.1/docs/source/methods.rst` & `pyunicorn-0.7.0/docs/source/methods.rst`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 
-Methods
-=======
+Package Overview
+================
 
 A brief introduction to the methods, measures and algorithms provided by
 ``pyunicorn``.
 
 General complex networks
 ------------------------
 Many standard complex network measures, network models and algorithms are
@@ -17,61 +17,61 @@
 possible.
 
 * :doc:`api/core/network`
 
 Spatially embedded networks
 ---------------------------
 ``pyunicorn`` includes measures and models specifically designed for spatially
-embedded networks (or simply spatial networks) via the GeoNetwork and Grid
+embedded networks (or simply spatial networks) via the ``GeoNetwork`` and ``Grid``
 classes.
 
 * :doc:`api/core/geo_network`
 * :doc:`api/core/grid`
 
-Interacting/interdependent/multiplex networks / networks of networks
---------------------------------------------------------------------
-The InteractingNetworks class provides a rich collection of network measures and models specifically designed for investigating the structure of networks of
+Interacting/multiplex networks (networks of networks)
+-----------------------------------------------------
+The ``InteractingNetworks`` class provides a rich collection of network measures and models specifically designed for investigating the structure of networks of
 networks (also called interacting networks, interdependent networks or
 multiplex networks in different contexts). Examples include the cross-link
 density of connections between different subnetworks or the cross-shortest
 path betweenness quantifying the importance of nodes for mediating interactions
 between different subnetworks. Models of interacting networks allow to assess
 the degree of organization of the cross-connectivity between subnetworks.
 
 * :doc:`api/core/interacting_networks`
 
-Node-weighted network measures / node-splitting invariance
-----------------------------------------------------------
+Node-weighted (node-splitting invariant) network measures
+---------------------------------------------------------
 Node-weighted networks measures derived following the node-splitting invariance
 approach are useful for studying systems with nodes representing subsystems of
 heterogeneous size, weight, area, volume or importance, e.g., nodes
 representing grid cells of widely different area in climate networks or voxels
 of differing volume in functional brain networks. ``pyunicorn`` provides
 node-weighted variants of most standard and non-standard measures for networks
 as well as interacting networks.
 
 * :doc:`api/core/network`
 * :doc:`api/core/interacting_networks`
 
-Climate networks / Coupled climate networks
--------------------------------------------
+(Coupled) Climate networks
+--------------------------
 ``pyunicorn`` provides classes for the easy construction and analysis of the
 statistical interdependency structure within and between fields of time series (functional networks) using various similarity measures such as Pearson and Spearman correlation, lagged linear correlation, mutual information and event
 synchronization. Climate networks allow the analysis of single fields of time series, whereas coupled climate networks focus on studying the
 interrelationships between two fields of time series. While there is a
 historical focus on applications to climate data, those methods can also be
 applied to other sources of time series data such as neuroscientific (e.g.,
 FMRI and EEG data) or financial data (e.g., stock market indices).
 
 * :doc:`api/climate/climate_network`
 * :doc:`api/climate/coupled_climate_network`
 * :doc:`api/climate/climate_data`
 
-Recurrence networks / recurrence quantification analysis / recurrence plots
----------------------------------------------------------------------------
+Recurrence quantification/network analysis
+------------------------------------------
 Recurrence analysis is a powerful method for studying nonlinear systems,
 particularly based on univariate and multivariate time series data. Recurrence
 quantification analysis (RQA) and recurrence network analysis (RNA) allow to
 classify different dynamical regimes in time series and to detect regime
 shifts, dynamical transitions or tipping points, among many other applications.
 Bivariate methods such as joint recurrence plots/networks, cross recurrence
 plots or inter system recurrence networks allow to investigate the coupling
```

### Comparing `pyunicorn-0.6.1/docs/source/publications.rst` & `pyunicorn-0.7.0/docs/source/publications.rst`

 * *Files 6% similar despite different names*

```diff
@@ -3,17 +3,20 @@
 ############
 
 References to peer-reviewed publications, theses and reports describing in
 detail and applying the methods implemented in the ``pyunicorn`` package.
 
 General complex networks
 ========================
-*Review papers*
-~~~~~~~~~~~~~~~
-[Newman2003]_, [Boccaletti2006]_, [Costa2007]_.
+- Review papers: [Newman2003]_, [Boccaletti2006]_, [Costa2007]_.
+- Further network papers: [Watts1998]_, [Newman2001]_, [Newman2002]_,
+  [Arenas2003]_, [Newman2005]_, [Soffer2005]_, [Holme2007]_, [Tsonis2008a]_,
+  [Ueoka2008]_.
+
+....
 
 .. [Newman2003] M.E.J. Newman.
     "The structure and function of complex networks".
     In *SIAM Review*, vol. 45 (no. 2), p167-256 (2003)
     `doi:10.1137/S003614450342480
     <http://dx.doi.org/10.1137/S003614450342480>`__
 
@@ -25,19 +28,14 @@
 
 .. [Costa2007] L.D.F. Costa, F.A. Rodrigues, G. Travieso, P.R. Villas Boas.
     "Characterization of complex networks: A survey of measurements".
     In *Advances in Physics*, vol. 56(1), 167-242 (2007)
     `doi:10.1080/00018730601170527
     <http://dx.doi.org/10.1080/00018730601170527>`__
 
-*Further network papers*
-~~~~~~~~~~~~~~~~~~~~~~~~
-[Watts1998]_, [Newman2001]_, [Newman2002]_, [Arenas2003]_, [Newman2005]_,
-[Soffer2005]_, [Holme2007]_, [Tsonis2008a]_, [Ueoka2008]_.
-
 .. [Watts1998] D.J. Watts and S.H. Strogatz.
     "Collective dynamics of small-world networks".
     In *Nature* vol. 393, 440–442 (1998)
     `doi:10.1038/30918 <http://dx.doi.org/10.1038/30918>`__
 
 .. [Newman2001] M.E.J. Newman.
     "Scientific collaboration networks. II. Shortest paths, weighted
@@ -89,65 +87,64 @@
 
 .. [Ueoka2008] Y. Ueoka, T. Suzuki, T. Ikeguchi, Y. Horio.
     "Efficiency of Statistical Measures to Estimate Network Structure of Chaos
     Coupled Systems".
     Proceedings of NOLTA (2008)
     http://tsuzuki.ise.ibaraki.ac.jp/MyPaper/Meeting/08NOLTA.pdf
 
+
 Spatially embedded networks
 ===========================
-[Bartelemy2011]_.
+- [Bartelemy2011]_.
+
+....
 
 .. [Bartelemy2011] M. Barthelemy.
     "Spatial networks".
     In *Physics Reports*, vol. 499 (no. 1-3), p1-101 (2011)
     `doi:10.1016/j.physrep.2010.11.002
     <http://dx.doi.org/10.1016/j.physrep.2010.11.002>`__
 
-Interacting/interdependent networks / networks of networks
+
+Interacting/interdependent networks (networks of networks)
 ==========================================================
-*Introduction to structural analysis of interacting networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donges2011a]_.
+- Introduction to structural analysis of interacting networks: [Donges2011a]_.
+- Random graph models & network surrogates for interacting networks: [Schultz2010]_.
+
+....
 
 .. [Donges2011a] J.F. Donges, H.C.H. Schultz, N. Marwan, Y. Zou, J. Kurths.
     "Investigating the topology of interacting networks - Theory and
     application to coupled climate subnetworks".
     In *European Physical Journal B: Condensed Matter and Complex Systems*,
     vol. 84 (no. 4) p635-652 (2011)
     `doi:10.1140/epjb/e2011-10795-8
     <http://dx.doi.org/10.1140/epjb/e2011-10795-8>`__
 
-Node-weighted network measures / node-splitting invariance
-==========================================================
-*Introduction*
-~~~~~~~~~~~~~~
-[Heitzig2012]_.
+.. [Schultz2010] H.C.H. Schultz.
+    "Coupled climate networks: Investigating the terrestrial atmosphere's
+    dynamical structure".
+    Diploma thesis, Free University, Berlin (2010)
+
+
+Node-weighted (node-splitting invariant) network measures
+=========================================================
+- Introduction: [Heitzig2012]_.
+- Analysis of node-weighted interacting networks: [Wiedermann2011]_, [Wiedermann2013]_.
+
+....
 
 .. [Heitzig2012] J. Heitzig, J. F. Donges, Y. Zou, N. Marwan, J. Kurths.
     "Node-weighted measures for complex networks with spatially embedded,
     sampled, or differently sized nodes".
     In *European Physical Journal B: Condensed Matter and Complex Systems*,
     vol. 85 p38 (2012)
     `doi:10.1140/epjb/e2011-20678-7
     <http://dx.doi.org/10.1140/epjb/e2011-20678-7>`__
 
-*Random graph models and network surrogates for interacting networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Schultz2010]_.
-
-.. [Schultz2010] H.C.H. Schultz.
-    "Coupled climate networks: Investigating the terrestrial atmosphere's
-    dynamical structure".
-    Diploma thesis, Free University, Berlin (2010)
-
-*Analysis of node-weighted interacting networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Wiedermann2011]_, [Wiedermann2013]_.
-
 .. [Wiedermann2011] M. Wiedermann.
     "Coupled climate network analysis of multidecadal dynamics in the Arctic".
     Bachelor's thesis, Humboldt University, Berlin (2011)
 
 .. [Wiedermann2013] M. Wiedermann, J.F. Donges, J. Heitzig, J. Kurths.
     "Node-weighted interacting network measures improve the representation
     of real-world complex systems".
@@ -158,91 +155,79 @@
 .. [Zemp2014] D.C. Zemp,  M. Wiedermann, J. Kurths, A. Rammig, J.F. Donges.
     "Node-weighted measures for complex networks with directed and weighted
     edges for studying continental moisture recycling".
     In *Europhysics Letters*, vol. 107.5, p58005 (2014)
     `doi:10.1209/0295-5075/107/58005
     <http://dx.doi.org/10.1209/0295-5075/107/58005>`__
 
+
 Climate data analysis (general)
 ===============================
-[Bretherton1992]_.
+- [Bretherton1992]_.
+
+....
 
 .. [Bretherton1992] C.S. Bretherton, C. Smith, J.M. Wallace.
     "An intercomparison of methods for finding coupled patterns in climate
     data".
     In *Journal of Climate*, vol. 5, p541-560 (1992)
     `doi:10.1175/1520-0442(1992)005<0541:AIOMFF>2.0.CO;2
     <http://dx.doi.org/10.1175/1520-0442(1992)005%3C0541%3AAIOMFF%3E2.0.CO%3B2>`__
 
-Climate networks / Coupled climate networks
-===========================================
-*Comparing linear and nonlinear construction of climate networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donges2009a]_.
+
+(Coupled) Climate networks
+==========================
+- Comparing linear & nonlinear construction of climate networks: [Donges2009a]_.
+- Studying the dynamical structure of the surface air temperature field:
+  [Donges2009b]_, [Radebach2010]_.
+- Introduction to coupled climate networks & applications:
+  [Schultz2010]_, [Donges2011a]_, [Wiedermann2011]_.
+- Review of climate network analysis (in Chinese!): [Zou2011]_.
+- Visualization of climate networks: [Tominski2011]_.
+- Evolving climate networks: [Radebach2013]_.
+- General: [Tsonis2004]_, [Tsonis2006]_, [Gozolchiani2008]_, [Tsonis2008b]_,
+  [Tsonis2008c]_, [Yamasaki2008]_, [Donges2009c]_, [Yamasaki2009]_.
+
+....
 
 .. [Donges2009a] J.F. Donges, Y. Zou, N. Marwan, J. Kurths.
     "Complex networks in climate dynamics".
     In *European Physical Journal Special Topics*, vol. 174 (no. 1), p157-179
     (2009)
     `doi:10.1140/epjst/e2009-01098-2
     <http://dx.doi.org/10.1140/epjst/e2009-01098-2>`__
 
-*Studying the dynamical structure of the surface air temperature field*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donges2009b]_, [Radebach2010]_.
-
 .. [Donges2009b] J.F. Donges, Y. Zou, N. Marwan, J. Kurths.
     "The backbone of the climate network".
     In *Europhysics Letters*, vol. 87 (no. 4), 48007 (2009)
     `doi:10.1209/0295-5075/87/48007
     <http://dx.doi.org/10.1209/0295-5075/87/48007>`__
 
 .. [Radebach2010] A. Radebach.
     "Evolving climate networks: Investigating the evolution of correlation
     structure of the Earth's climate system".
     Diploma thesis, Humboldt University, Berlin (2010)
 
-*Introduction to coupled climate networks and applications*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Schultz2010]_, [Donges2011a]_, [Wiedermann2011]_.
-
-*Review of climate network analysis (in Chinese!)*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Zou2011]_.
-
 .. [Zou2011] Y. Zou, J.F. Donges, J. Kurths.
     "Recent advances in complex climate network analysis".
     In *Complex Systems and Complexity Science*, vol. 8 (no. 1), p27-38 (2011)
 
-*Visualization of climate networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Tominski2011]_.
-
 .. [Tominski2011] C. Tominski, J.F. Donges, T. Nocke.
     "Information Visualization in Climate Research".
     In *Proceedings of the International Conference on Information
     Visualisation (IV), London*, p298-305 (2011)
     `doi:10.1109/IV.2011.12 <http://dx.doi.org/10.1109/IV.2011.12>`__
 
-*Evolving climate networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Radebach2013]_.
-
 .. [Radebach2013] A. Radebach, R.V. Donner, J. Runge, J.F. Donges, J. Kurths.
     "Disentangling different types of El Nino episodes by evolving climate
     network analysis".
     In *Physical Review E*, vol. 88, 052807 (2013)
     `doi:10.1103/PhysRevE.88.052807
     <http://dx.doi.org/10.1103/PhysRevE.88.052807>`__
 
-*General*
-~~~~~~~~~
-[Tsonis2004]_, [Tsonis2006]_, [Gozolchiani2008]_, [Tsonis2008b]_,
-[Tsonis2008c]_, [Yamasaki2008]_, [Donges2009c]_, [Yamasaki2009]_.
-
 .. [Tsonis2004] A.A. Tsonis and P.J. Roebber.
     "The architecture of the climate network".
     In *Physica A: Statistical Mechanics and its Applications*,
     vol. 333, p497-504 (2004)
     `doi:10.1016/j.physa.2003.10.045
     <http://dx.doi.org/10.1016/j.physa.2003.10.045>`__
 
@@ -281,47 +266,57 @@
     URN: ``urn:nbn:de:kobv:517-opus-49775``.
 
 .. [Yamasaki2009] K. Yamasaki, A. Gozolchiani, S. Havlin.
     "Climate Networks Based on Phase Synchronization Analysis Track El-Niño".
     In *Progress Of Theoretical Physics Supplement*, vol. 179, p178-188 (2009)
     `doi:10.1143/PTPS.179.178 <http://dx.doi.org/10.1143/PTPS.179.178>`__
 
-Power Grids/Power Networks
-===========================================
-*Resistance based networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Schultz2014]_, [Schultz2014a]_.
+
+Power grids & Power networks
+============================
+- Resistance based networks: [Schultz2014]_, [Schultz2014a]_.
+
+....
 
 .. [Schultz2014] P. Schultz "Stability Analysis of Power Grid Networks".
     *M.Sc. Thesis*, Humboldt-Universität zu Berlin (2014)
 
 .. [Schultz2014a] P. Schultz, J. Heitzig, J. Kurths
     A Random Growth Model for Power Grids and Other
     Spatially Embedded Infrastructure Networks".
     In *Eur. Phys. J. Special Topics: Resilient Power Grids and Extreme Events* (2014)
 
-Time series analysis and synchronization
-========================================
-*General*
-~~~~~~~~~
-[Pecora1998]_, [Schreiber2000]_, [Kraskov2004]_, [Kantz2006]_, [Thiel2006]_,
-[Bergner2008]_, [Pompe2011]_, [Runge2012b]_.
+
+Time series analysis & Synchronization
+======================================
+- General: [Pecora1998]_, [Schreiber2000]_, [Bandt2002]_, [Kraskov2004]_,
+  [Kantz2006]_, [Thiel2006]_, [Bergner2008]_, [Pompe2011]_, [Ribeiro2011]_, [Runge2012b]_.
+- Event synchronization: [Quiroga2002]_, [Boers2014]_.
+- Event coincidence analysis: [Odenweller2020]_.
+
+....
 
 .. [Pecora1998] L.M. Pecora and T.L. Carroll.
     "Master Stability Functions for Synchronized Coupled Systems".
     In *Physical Review Letters*, vol. 80, 2109 (1998)
     `doi:10.1103/PhysRevLett.80.2109
     <http://dx.doi.org/10.1103/PhysRevLett.80.2109>`__
 
 .. [Schreiber2000] T. Schreiber and A. Schmitz.
     "Surrogate time series".
     In *Physica D* vol. 142 (no. 3-4), p346-382 (2000)
     `doi:10.1016/S0167-2789(00)00043-9
     <http://dx.doi.org/10.1016/S0167-2789(00)00043-9>`__
 
+.. [Bandt2002] C. Bandt, B. Pompe
+    "Permutation Entropy: A Natural Complexity Measure for Time Series".
+    In *Phys. Rev. Lett.*, vol. 88(17), 174102 (2002)
+    `doi:10.1103/PhysRevLett.88.174102
+    <http://dx.doi.org/10.1103/PhysRevLett.88.174102>`__
+
 .. [Kraskov2004] A. Kraskov, H. Stögbauer, P. Grassberger.
     "Estimating mutual information".
     In *Physical Review E*, vol. 69(6), 066138 (2004)
     `doi:10.1103/PhysRevE.69.066138
     <http://dx.doi.org/10.1103/PhysRevE.69.066138>`__
 
 .. [Kantz2006] H. Kantz and T. Schreiber.
@@ -344,25 +339,29 @@
 
 .. [Pompe2011] B. Pompe, J. Runge.
     "Momentary information transfer as a coupling measure of time series".
     In *Physical Review E* vol. 83, 051122 (2011)
     `doi:10.1103/PhysRevE.83.051122
     <http://dx.doi.org/10.1103/PhysRevE.83.051122>`__
 
+.. [Ribeiro2011] H.V. Ribeiro, L. Zunino, R.S. Mendes and E.K. Lenzi
+    "Complexity–entropy causality plane: A useful approach for
+    distinguishing songs",
+    In *Physica A: Statistical Mechanics and its Applications*,
+    vol. 391, p2421-2428 (2011)
+    `doi:10.1016/j.physa.2011.12.009
+    <http://dx.doi.org/10.1016/j.physa.2011.12.009>`__
+
 .. [Runge2012b] J. Runge, J. Heitzig, N. Marwan, J. Kurths.
     "Quantifying causal coupling strength: A lag-specific measure for
     multivariate time series related to transfer entropy".
     In *Physical Review E*, vol. 86(6), 1-15 (2012)
     `doi:10.1103/PhysRevE.86.061121
     <http://dx.doi.org/10.1103/PhysRevE.86.061121>`__
 
-*Event synchronization*
-~~~~~~~~~~~~~~~~~~~~~~~
-[Quiroga2002]_, [Boers2014]_.
-
 .. [Quiroga2002] R.Q. Quiroga, T. Kreuz, P. Grassberger.
     "Event synchronization: a simple and fast method to measure synchronicity
     and time delay patterns."
     In *Physical Review E*, vol. 66(4), 041904 (2002)
     `doi:10.1103/PhysRevE.66.041904
     <http://dx.doi.org/10.1103/PhysRevE.66.041904>`__
 
@@ -370,93 +369,86 @@
     J.A. Marengo.
     "Prediction of extreme floods in the eastern Central Andes based on a
     complex networks approach".
     In *Nature communications*, vol. 5, 1--7 (2014)
     `doi:10.1038/ncomms6199
     <http://dx.doi.org/10.1038/ncomms6199>`__
 
-Recurrence networks / quantification analysis / plots
-=====================================================
-*Review of recurrence plots and RQA*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Marwan2007]_.
+.. [Odenweller2020] A. Odenweller, R.V. Donner.
+    "Disentangling synchrony from serial dependency in paired-event time series".
+    In *Pyhsical Review E*, vol. 101, 052213 (2020)
+    `doi:10.1103/PhysRevE.101.052213
+    <https://doi.org/10.1103/PhysRevE.101.052213>`__
+
+
+Recurrence quantification/network analysis
+==========================================
+- Review of recurrence plots & RQA: [Marwan2007]_.
+- Introduction & application of recurrence networks in the context of RQA: [Marwan2009]_.
+- Thorough introduction to recurrence network analysis: [Donner2010b]_.
+- Discussion of choosing an appropriate recurrence threshold: [Donner2010a]_, [Zou2010]_.
+- Review of various methods for network-based time series analysis: [Donner2011a]_.
+- Introduction to measures of (fractal) transitivity dimensions: [Donner2011b]_.
+- Applications of recurrence network analysis to paleoclimate data: [Donges2011b]_,
+  [Donges2011c]_, [Feldhoff2012]_.
+- Theory of recurrence networks: [Donges2012]_, [Zou2012]_.
+- Multivariate extensions of recurrence network analysis: [Feldhoff2012]_, [Feldhoff2013]_.
+- General: [Ngamga2007]_, [Xu2008]_, [Schinkel2009]_.
+
+....
 
 .. [Marwan2007] N. Marwan, M.C. Romano, M. Thiel, J. Kurths.
     "Recurrence plots for the analysis of complex systems".
     In *Physics Reports*, vol. 438 (no. 5–6), p237-329 (2007)
     `doi:10.1016/j.physrep.2006.11.001
     <http://dx.doi.org/10.1016/j.physrep.2006.11.001>`__
 
-*Introduction and application of recurrence networks in the context of RQA*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Marwan2009]_.
-
 .. [Marwan2009] N. Marwan, J.F. Donges, Y. Zou, R.V. Donner, J. Kurths.
     "Complex network approach for recurrence analysis of time series".
     In *Physics Letters A*, vol. 373 (no. 46), p4246-4254 (2009)
     `doi:10.1016/j.physleta.2009.09.042
     <http://dx.doi.org/10.1016/j.physleta.2009.09.042>`__
 
-*A thorough introduction to recurrence network analysis*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donner2010b]_.
-
 .. [Donner2010b] R.V. Donner, Y. Zou, J.F. Donges, N. Marwan, J. Kurths.
     "Recurrence networks -- A novel paradigm for nonlinear time series
     analysis".
     In *New Journal of Physics*, vol. 12 (no. 3), 033205 (2010)
     `doi:10.1088/1367-2630/12/3/033025
     <http://dx.doi.org/10.1088/1367-2630/12/3/033025>`__
 
-*Discussion of choosing an appropriate recurrence threshold*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donner2010a]_, [Zou2010]_.
-
 .. [Donner2010a] R.V. Donner, Y. Zou, J.F. Donges, N. Marwan, J. Kurths.
     "Ambiguities in recurrence-based complex network representations of time
     series".
     In *Physical Review E*,
     vol. 81 (no. 1), 015101(R) (2010)
     `doi:10.1103/PhysRevE.81.015101
     <http://dx.doi.org/10.1103/PhysRevE.81.015101>`__
 
 .. [Zou2010] Y. Zou, R.V. Donner, J.F. Donges, N. Marwan, J. Kurths.
     "Identifying complex periodic windows in continuous-time dynamical systems
     using recurrence-based methods".
     In *Chaos*, vol. 20 (no. 4), 043130 (2010)
     `doi:10.1063/1.3523304 <http://dx.doi.org/10.1063/1.3523304>`__
 
-*Review of various methods for network-based time series analysis*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donner2011a]_.
-
 .. [Donner2011a] R.V. Donner, M. Small, J.F. Donges, N. Marwan, Y. Zou, R.
     Xiang, J. Kurths.
     "Recurrence-based time series analysis by means of complex network
     methods".
     In *International Journal of Bifurcation and Chaos*, vol. 21 (no. 4),
     p1019-1046 (2011)
     `doi:10.1142/S0218127411029021
     <http://dx.doi.org/10.1142/S0218127411029021>`__
 
-*Introduction to measures of (fractal) transitivity dimensions*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donner2011b]_.
-
 .. [Donner2011b] R.V. Donner, J. Heitzig, J.F. Donges, Y. Zou, J. Kurths.
     "The geometry of chaotic dynamics -- A complex network perspective".
     In *European Physical Journal B: Condensed Matter and Complex Systems*,
     vol. 84 (no. 4), p653-672 (2011)
     `doi:10.1140/epjb/e2011-10899-1
     <http://dx.doi.org/10.1140/epjb/e2011-10899-1>`__
 
-*Applications of recurrence network analysis to paleoclimate data*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donges2011b]_, [Donges2011c]_, [Feldhoff2012]_.
-
 .. [Donges2011b] J.F. Donges, R.V. Donner, K. Rehfeld, N. Marwan, M.H.
     Trauth, J. Kurths.
     "Identification of dynamical transitions in marine palaeoclimate records
     by recurrence network analysis".
     In *Nonlinear Processes in Geophysics*, vol. 18 (no. 5), p545-562 (2011)
     `doi:10.5194/npg-18-545-2011
     <http://dx.doi.org/10.5194/npg-18-545-2011>`__
@@ -466,36 +458,28 @@
     "Nonlinear detection of paleoclimate-variability transitions possibly
     related to human evolution".
     In *Proceedings of the National Academy of Sciences of the United States of
     America*, vol. 108 (no. 51), p20422-20427 (2011)
     `doi:10.1073/pnas.1117052108
     <http://dx.doi.org/10.1073/pnas.1117052108>`__
 
-*Theory of recurrence networks*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donges2012]_, [Zou2012]_.
-
 .. [Donges2012] J.F. Donges, J. Heitzig, R.V. Donner, J. Kurths.
     "Analytical framework for recurrence network analysis of time series".
     In *Physical Review E: Statistical, Nonlinear, and Soft Matter Physics*,
     vol. 85, 046105 (2012)
     `doi:10.1103/PhysRevE.85.046105
     <http://dx.doi.org/10.1103/PhysRevE.85.046105>`__
 
 .. [Zou2012] Y. Zou, J. Heitzig, R.V. Donner, J.F. Donges, J.D. Farmer, R.
     Meucci, S. Euzzor, N. Marwan, J. Kurths.
     "Power-laws in recurrence networks from dynamical systems".
     In *Europhysics Letters*, vol. 98, 48001 (2012)
     `doi:10.1209/0295-5075/98/48001
     <http://dx.doi.org/10.1209/0295-5075/98/48001>`__
 
-*Multivariate extensions of recurrence network analysis*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Feldhoff2012]_, [Feldhoff2013]_.
-
 .. [Feldhoff2012] J.H. Feldhoff, R.V. Donner, J.F. Donges, N. Marwan,
     J. Kurths.
     "Geometric detection of coupling directions by means of inter-system
     recurrence networks".
     In *Physics Letters A*, vol. 376, 3504-3513 (2012),
     `doi:10.1016/j.physleta.2012.10.008
     <http://dx.doi.org/10.1016/j.physleta.2012.10.008>`__
@@ -503,18 +487,14 @@
 .. [Feldhoff2013] J.H. Feldhoff, R.V. Donner, J.F. Donges, N. Marwan,
     J. Kurths.
     "Geometric signature of complex synchronisation scenarios".
     In *Europhysics Letters* vol. 102, 30007 (2013),
     `doi:10.1209/0295-5075/102/30007
     <http://dx.doi.org/10.1209/0295-5075/102/30007>`__
 
-*General*
-~~~~~~~~~
-[Ngamga2007]_, [Xu2008]_, [Schinkel2009]_.
-
 .. [Ngamga2007] E.J. Ngamga, A. Nandi, R. Ramaswamy, M.C. Romano, M. Thiel, J. Kurths.
     "Recurrence analysis of strange nonchaotic dynamics".
     In *Physical Review E*, vol. 75, 036222 (2007)
     `doi:10.1103/PhysRevE.75.036222
     <http://dx.doi.org/10.1103/PhysRevE.75.036222>`__
 
 .. [Xu2008] X. Xu, J. Zhang, M. Small.
@@ -526,39 +506,34 @@
 
 .. [Schinkel2009] S. Schinkel, N. Marwan, O. Dimigen, J. Kurths.
     "Confidence bounds of recurrence-based complexity measures".
     In *Physics Letters A*, vol. 373 (no. 26) p2245–2250 (2009)
     `doi:10.1016/j.physleta.2009.04.045
     <http://dx.doi.org/10.1016/j.physleta.2009.04.045>`__
 
+
 Visibility graph analysis
 =========================
-*Introduction*
-~~~~~~~~~~~~~~
-[Lacasa2008]_.
+- Introduction: [Lacasa2008]_.
+- Application to geophysical time series: [Donner2012]_.
+- Tests for time series irreversibility: [Donges2013]_.
+
+....
 
 .. [Lacasa2008] L. Lacasa, B. Luque, F. Ballesteros, J. Luque, J.C. Nuno.
     "From time series to complex networks: The visibility graph".
     In *Proceedings of the National Academy of Sciences of the United States of
     America*, vol. 105 (no. 13), p4972-4975 (2008)
     `doi:10.1073/pnas.0709247105 <http://dx.doi.org/10.1073/pnas.0709247105>`__
 
-*Application to geophysical time series*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donner2012]_.
-
 .. [Donner2012] R.V. Donner and J.F. Donges.
     "Visibility graph analysis of geophysical time series: Potentials and
     possible pitfalls".
     In *Acta Geophysica*, vol. 60 p589-623 (2012)
     `doi:10.2478/s11600-012-0032-x
     <http://dx.doi.org/10.2478/s11600-012-0032-x>`__
 
-*Tests for time series irreversibility*
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-[Donges2013]_.
-
 .. [Donges2013] J.F. Donges, R.V. Donner, J. Kurths.
     "Testing time series irreversibility using complex network methods".
     In *Europhysics Letters*, vol. 102.1, 10004 (2013)
     `doi:10.1209/0295-5075/102/10004
     <http://dx.doi.org/10.1209/0295-5075/102/10004>`__
```

### Comparing `pyunicorn-0.6.1/LICENSE.txt` & `pyunicorn-0.7.0/LICENSE.txt`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 
-Copyright (C) 2008-2019, Jonathan F. Donges (Potsdam-Institute for Climate
+Copyright (C) 2008-2024, Jonathan F. Donges (Potsdam-Institute for Climate
 Impact Research), pyunicorn authors
 
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
```

