# Comparing `tmp/pybase16384-0.3.5-pp39-pypy39_pp73-win_amd64.whl.zip` & `tmp/pybase16384-0.3.6-cp38-cp38-macosx_10_9_universal2.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,23 @@
-Zip file size: 269181 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat     2540 b- defN 24-Mar-26 16:30 pybase16384/__init__.py
--rw-rw-rw-  2.0 fat       56 b- defN 24-Mar-26 16:30 pybase16384/backends/__init__.py
--rw-rw-rw-  2.0 fat     7604 b- defN 24-Mar-26 16:30 pybase16384/backends/cffi/__init__.py
--rw-rw-rw-  2.0 fat    18944 b- defN 24-Mar-26 16:42 pybase16384/backends/cffi/_core.pypy39-pp73-win_amd64.pyd
--rw-rw-rw-  2.0 fat     3095 b- defN 24-Mar-26 16:30 pybase16384/backends/cffi/build.py
--rw-rw-rw-  2.0 fat      353 b- defN 24-Mar-26 16:30 pybase16384/backends/cython/__init__.py
--rw-rw-rw-  2.0 fat  1296347 b- defN 24-Mar-26 16:42 pybase16384/backends/cython/_core.c
--rw-rw-rw-  2.0 fat      542 b- defN 24-Mar-26 16:30 pybase16384/backends/cython/_core.pxi
--rw-rw-rw-  2.0 fat   168960 b- defN 24-Mar-26 16:42 pybase16384/backends/cython/_core.pypy39-pp73-win_amd64.pyd
--rw-rw-rw-  2.0 fat    11775 b- defN 24-Mar-26 16:30 pybase16384/backends/cython/_core.pyx
--rw-rw-rw-  2.0 fat     2326 b- defN 24-Mar-26 16:30 pybase16384/backends/cython/base16384.pxd
--rw-rw-rw-  2.0 fat    35821 b- defN 24-Mar-26 16:42 pybase16384-0.3.5.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     5539 b- defN 24-Mar-26 16:42 pybase16384-0.3.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat      107 b- defN 24-Mar-26 16:42 pybase16384-0.3.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       12 b- defN 24-Mar-26 16:42 pybase16384-0.3.5.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1469 b- defN 24-Mar-26 16:42 pybase16384-0.3.5.dist-info/RECORD
-16 files, 1555490 bytes uncompressed, 266723 bytes compressed:  82.9%
+Zip file size: 398907 bytes, number of entries: 21
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 07:48 pybase16384-0.3.6.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 07:49 pybase16384/
+-rw-rw-r--  2.0 unx     1450 b- defN 24-Apr-04 07:49 pybase16384-0.3.6.dist-info/RECORD
+-rw-r--r--  2.0 unx    35148 b- defN 24-Apr-04 07:48 pybase16384-0.3.6.dist-info/LICENSE
+-rw-r--r--  2.0 unx      113 b- defN 24-Apr-04 07:48 pybase16384-0.3.6.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 24-Apr-04 07:48 pybase16384-0.3.6.dist-info/top_level.txt
+-rw-r--r--  2.0 unx     5387 b- defN 24-Apr-04 07:48 pybase16384-0.3.6.dist-info/METADATA
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 07:48 pybase16384/backends/
+-rw-r--r--  2.0 unx     2933 b- defN 24-Apr-04 07:46 pybase16384/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 07:48 pybase16384/backends/cffi/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-04 07:48 pybase16384/backends/cython/
+-rw-r--r--  2.0 unx       55 b- defN 24-Apr-04 07:46 pybase16384/backends/__init__.py
+-rw-r--r--  2.0 unx     4396 b- defN 24-Apr-04 07:46 pybase16384/backends/cffi/build.py
+-rw-r--r--  2.0 unx     9507 b- defN 24-Apr-04 07:46 pybase16384/backends/cffi/__init__.py
+-rwxr-xr-x  2.0 unx   154432 b- defN 24-Apr-04 07:48 pybase16384/backends/cffi/_core.abi3.so
+-rw-r--r--  2.0 unx  1393172 b- defN 24-Apr-04 07:48 pybase16384/backends/cython/_core.c
+-rw-r--r--  2.0 unx      551 b- defN 24-Apr-04 07:46 pybase16384/backends/cython/__init__.py
+-rw-r--r--  2.0 unx     4654 b- defN 24-Apr-04 07:46 pybase16384/backends/cython/base16384.pxd
+-rwxr-xr-x  2.0 unx   491536 b- defN 24-Apr-04 07:48 pybase16384/backends/cython/_core.abi3.so
+-rw-r--r--  2.0 unx    15375 b- defN 24-Apr-04 07:46 pybase16384/backends/cython/_core.pyx
+-rw-r--r--  2.0 unx      530 b- defN 24-Apr-04 07:46 pybase16384/backends/cython/_core.pxi
+21 files, 2119251 bytes uncompressed, 395911 bytes compressed:  81.3%
```

## zipnote {}

```diff
@@ -1,49 +1,64 @@
-Filename: pybase16384/__init__.py
+Filename: pybase16384-0.3.6.dist-info/
 Comment: 
 
-Filename: pybase16384/backends/__init__.py
+Filename: pybase16384/
 Comment: 
 
-Filename: pybase16384/backends/cffi/__init__.py
+Filename: pybase16384-0.3.6.dist-info/RECORD
 Comment: 
 
-Filename: pybase16384/backends/cffi/_core.pypy39-pp73-win_amd64.pyd
+Filename: pybase16384-0.3.6.dist-info/LICENSE
 Comment: 
 
-Filename: pybase16384/backends/cffi/build.py
+Filename: pybase16384-0.3.6.dist-info/WHEEL
 Comment: 
 
-Filename: pybase16384/backends/cython/__init__.py
+Filename: pybase16384-0.3.6.dist-info/top_level.txt
 Comment: 
 
-Filename: pybase16384/backends/cython/_core.c
+Filename: pybase16384-0.3.6.dist-info/METADATA
 Comment: 
 
-Filename: pybase16384/backends/cython/_core.pxi
+Filename: pybase16384/backends/
 Comment: 
 
-Filename: pybase16384/backends/cython/_core.pypy39-pp73-win_amd64.pyd
+Filename: pybase16384/__init__.py
 Comment: 
 
-Filename: pybase16384/backends/cython/_core.pyx
+Filename: pybase16384/backends/cffi/
 Comment: 
 
-Filename: pybase16384/backends/cython/base16384.pxd
+Filename: pybase16384/backends/cython/
+Comment: 
+
+Filename: pybase16384/backends/__init__.py
+Comment: 
+
+Filename: pybase16384/backends/cffi/build.py
+Comment: 
+
+Filename: pybase16384/backends/cffi/__init__.py
+Comment: 
+
+Filename: pybase16384/backends/cffi/_core.abi3.so
 Comment: 
 
-Filename: pybase16384-0.3.5.dist-info/LICENSE
+Filename: pybase16384/backends/cython/_core.c
 Comment: 
 
-Filename: pybase16384-0.3.5.dist-info/METADATA
+Filename: pybase16384/backends/cython/__init__.py
 Comment: 
 
-Filename: pybase16384-0.3.5.dist-info/WHEEL
+Filename: pybase16384/backends/cython/base16384.pxd
 Comment: 
 
-Filename: pybase16384-0.3.5.dist-info/top_level.txt
+Filename: pybase16384/backends/cython/_core.abi3.so
 Comment: 
 
-Filename: pybase16384-0.3.5.dist-info/RECORD
+Filename: pybase16384/backends/cython/_core.pyx
+Comment: 
+
+Filename: pybase16384/backends/cython/_core.pxi
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## pybase16384/__init__.py

```diff
@@ -1,111 +1,129 @@
-import os
-import platform
-from io import BytesIO
-
-impl = platform.python_implementation()
-
-
-def _should_use_cffi() -> bool:
-    ev = os.getenv("B14_USE_CFFI")
-    if ev is not None:
-        return True
-    if impl == "CPython":
-        return False
-    else:
-        return True
-
-
-if not _should_use_cffi():
-    from pybase16384.backends.cython import (
-        _decode,
-        _decode_into,
-        _encode,
-        _encode_into,
-        decode_fd,
-        decode_file,
-        decode_len,
-        decode_local_file,
-        encode_fd,
-        encode_file,
-        encode_len,
-        encode_local_file,
-        is_64bits,
-    )
-else:
-    from pybase16384.backends.cffi import (
-        _decode,
-        _decode_into,
-        _encode,
-        _encode_into,
-        decode_fd,
-        decode_file,
-        decode_len,
-        decode_local_file,
-        encode_fd,
-        encode_file,
-        encode_len,
-        encode_local_file,
-        is_64bits,
-    )
-
-__version__ = "0.3.5"
-
-
-def encode(data: bytes) -> bytes:
-    inp = BytesIO(data)
-    out = BytesIO()
-    encode_file(inp, out, False, len(data) // 7)
-    return out.getvalue()
-
-
-def decode(data: bytes) -> bytes:
-    inp = BytesIO(data)
-    out = BytesIO()
-    decode_file(inp, out, len(data) // 8)
-    return out.getvalue()
-
-
-def encode_from_string(data: str, write_head: bool = False) -> bytes:
-    bt = data.encode()
-    inp = BytesIO(bt)
-    out = BytesIO()
-    encode_file(inp, out, write_head, len(bt) // 7)
-    return out.getvalue()
-
-
-def encode_to_string(data: bytes) -> str:
-    inp = BytesIO(data)
-    out = BytesIO()
-    encode_file(inp, out, False, len(data) // 7)
-    return out.getvalue().decode("utf-16-be")
-
-
-def encode_string(data: str) -> str:
-    data = data.encode()
-    inp = BytesIO(data)
-    out = BytesIO()
-    encode_file(inp, out, False, len(data) // 7)
-    return out.getvalue().decode("utf-16-be")
-
-
-def decode_from_bytes(data: bytes) -> str:
-    inp = BytesIO(data)
-    out = BytesIO()
-    decode_file(inp, out, len(data) // 8)
-    return out.getvalue().decode()
-
-
-def decode_from_string(data: str) -> bytes:
-    bt = data.encode("utf-16-be")
-    inp = BytesIO(bt)
-    out = BytesIO()
-    decode_file(inp, out, len(bt) // 8)
-    return out.getvalue()
-
-
-def decode_string(data: str) -> str:
-    bt = data.encode("utf-16-be")
-    inp = BytesIO(bt)
-    out = BytesIO()
-    decode_file(inp, out, len(bt) // 8)
-    return out.getvalue().decode()
+import os
+import platform
+from io import BytesIO
+
+impl = platform.python_implementation()
+
+
+def _should_use_cffi() -> bool:
+    ev = os.getenv("B14_USE_CFFI")
+    if ev is not None:
+        return True
+    if impl == "CPython":
+        return False
+    else:
+        return True
+
+
+if not _should_use_cffi():
+    from pybase16384.backends.cython import (
+        DECBUFSZ,
+        ENCBUFSZ,
+        FLAG_NOHEADER,
+        FLAG_SUM_CHECK_ON_REMAIN,
+        SIMPLE_SUM_INIT_VALUE,
+        _decode,
+        _decode_into,
+        _encode,
+        _encode_into,
+        decode_fd,
+        decode_fd_detailed,
+        decode_file,
+        decode_len,
+        decode_local_file,
+        decode_local_file_detailed,
+        encode_fd,
+        encode_fd_detailed,
+        encode_file,
+        encode_len,
+        encode_local_file,
+        encode_local_file_detailed,
+        is_64bits,
+    )
+else:
+    from pybase16384.backends.cffi import (
+        DECBUFSZ,
+        ENCBUFSZ,
+        FLAG_NOHEADER,
+        FLAG_SUM_CHECK_ON_REMAIN,
+        SIMPLE_SUM_INIT_VALUE,
+        _decode,
+        _decode_into,
+        _encode,
+        _encode_into,
+        decode_fd,
+        decode_fd_detailed,
+        decode_file,
+        decode_len,
+        decode_local_file,
+        decode_local_file_detailed,
+        encode_fd,
+        encode_fd_detailed,
+        encode_file,
+        encode_len,
+        encode_local_file,
+        encode_local_file_detailed,
+        is_64bits,
+    )
+
+__version__ = "0.3.6"
+
+
+def encode(data: bytes) -> bytes:
+    inp = BytesIO(data)
+    out = BytesIO()
+    encode_file(inp, out, False, len(data) // 7)
+    return out.getvalue()
+
+
+def decode(data: bytes) -> bytes:
+    inp = BytesIO(data)
+    out = BytesIO()
+    decode_file(inp, out, len(data) // 8)
+    return out.getvalue()
+
+
+def encode_from_string(data: str, write_head: bool = False) -> bytes:
+    bt = data.encode()
+    inp = BytesIO(bt)
+    out = BytesIO()
+    encode_file(inp, out, write_head, len(bt) // 7)
+    return out.getvalue()
+
+
+def encode_to_string(data: bytes) -> str:
+    inp = BytesIO(data)
+    out = BytesIO()
+    encode_file(inp, out, False, len(data) // 7)
+    return out.getvalue().decode("utf-16-be")
+
+
+def encode_string(data: str) -> str:
+    data = data.encode()
+    inp = BytesIO(data)
+    out = BytesIO()
+    encode_file(inp, out, False, len(data) // 7)
+    return out.getvalue().decode("utf-16-be")
+
+
+def decode_from_bytes(data: bytes) -> str:
+    inp = BytesIO(data)
+    out = BytesIO()
+    decode_file(inp, out, len(data) // 8)
+    return out.getvalue().decode()
+
+
+def decode_from_string(data: str) -> bytes:
+    bt = data.encode("utf-16-be")
+    inp = BytesIO(bt)
+    out = BytesIO()
+    decode_file(inp, out, len(bt) // 8)
+    return out.getvalue()
+
+
+def decode_string(data: str) -> str:
+    bt = data.encode("utf-16-be")
+    inp = BytesIO(bt)
+    out = BytesIO()
+    decode_file(inp, out, len(bt) // 8)
+    return out.getvalue().decode()
```

## pybase16384/backends/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-# Make cython happy, otherwise couldn't find pxd files
+# Make cython happy, otherwise couldn't find pxd files
```

## pybase16384/backends/cffi/__init__.py

```diff
@@ -1,218 +1,267 @@
-"""
-Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
-"""
-from pathlib import Path
-from typing import IO
-
-from pybase16384.backends.cffi._core import ffi, lib
-
-__version__ = "0.1.0"
-
-encode_len = lib.base16384_encode_len
-decode_len = lib.base16384_decode_len
-
-
-# -----------------low level api------------------------------
-def _encode(data: bytes) -> bytes:
-    length = len(data)
-    output_size = encode_len(length) + 16
-    output_buf = ffi.new(f"char[{output_size}]")
-    if output_buf == ffi.NULL:
-        raise MemoryError
-    count = lib.base16384_encode(ffi.from_buffer(data), length, output_buf)
-    return ffi.unpack(output_buf, count)
-
-
-def _encode_into(data: bytes, out: bytearray) -> int:
-    return lib.base16384_encode(
-        ffi.from_buffer(data), len(data), ffi.from_buffer(out)
-    )
-
-
-def _decode(data: bytes) -> bytes:
-    length = len(data)
-    output_size = decode_len(length, 0) + 16
-    output_buf = ffi.new(f"char[{output_size}]")
-    if output_buf == ffi.NULL:
-        raise MemoryError
-    count = lib.base16384_decode(ffi.from_buffer(data), length, output_buf)
-    return ffi.unpack(output_buf, count)
-
-
-def _decode_into(data: bytes, out: bytearray) -> int:
-    return lib.base16384_decode(
-        ffi.from_buffer(data), len(data), ffi.from_buffer(out)
-    )
-
-
-def is_64bits() -> bool:
-    return bool(lib.pybase16384_64bits())
-
-
-# ----------------------------
-def _check_file(file) -> bool:
-    if hasattr(file, "read") and hasattr(file, "write") and hasattr(file, "seek"):
-        return True
-    return False
-
-
-def encode_file(input: IO, output: IO, write_head: bool = False, buf_rate: int = 10):
-    if not _check_file(input):
-        raise TypeError(
-            "input except a file-like object, got %s" % type(input).__name__
-        )
-    if not _check_file(output):
-        raise TypeError(
-            "output except a file-like object, got %s" % type(input).__name__
-        )
-    if buf_rate <= 0:
-        buf_rate = 1
-    if write_head:
-        output.write(b"\xfe\xff")
-
-    current_buf_len: int = buf_rate * 7  # 一次读取这么多字节
-    output_size: int = encode_len(current_buf_len) + 16  # 因为encode_len不是单调的 这16备用
-    output_buf = ffi.new(f"char[{output_size}]")
-    if output_buf == ffi.NULL:
-        raise MemoryError
-    first_check: int = 1  # 检查一次就行了 怎么可能出现第一次读出来是bytes 以后又变卦了的对象呢 不会吧不会吧
-    while True:
-        chunk = input.read(current_buf_len)
-        if first_check:
-            first_check = 0
-            if not isinstance(chunk, bytes):
-                raise TypeError(
-                    f"input must be a file-like rb object, got {type(input).__name__}"
-                )
-        size = len(chunk)
-        if size < current_buf_len:  # 数据不够了 要减小一次读取的量
-            if buf_rate > 1:  # 重新设置一次读取的大小 重新设置流的位置 当然要是已经是一次读取7字节了 那就不能再变小了 直接encode吧
-                buf_rate = buf_rate // 2
-                current_buf_len = buf_rate * 7
-                input.seek(-size, 1)
-                continue
-
-        count = lib.base16384_encode(
-            ffi.from_buffer(chunk), size, output_buf
-        )
-        output.write(ffi.unpack(output_buf, count))
-        if size < 7:
-            break
-
-
-def decode_file(input: IO, output: IO, buf_rate: int = 10):
-    if not _check_file(input):
-        raise TypeError(
-            "input except a file-like object, got %s" % type(input).__name__
-        )
-    if not _check_file(output):
-        raise TypeError(
-            "output except a file-like object, got %s" % type(output).__name__
-        )
-    if buf_rate <= 0:
-        buf_rate = 1
-
-    chunk = input.read(1)  # type: bytes
-    if not isinstance(chunk, bytes):
-        raise TypeError(
-            f"input must be a file-like rb object, got {type(input).__name__}"
-        )
-    if chunk == b"\xfe":  # 去头
-        input.read(1)
-    else:
-        input.seek(0, 0)  # 没有头 回到开头
-
-    current_buf_len: int = buf_rate * 8
-    output_size: int = decode_len(current_buf_len, 0) + 16
-    output_buf = ffi.new(f"char[{output_size}]")
-    if output_buf == ffi.NULL:
-        raise MemoryError
-    while True:
-        chunk = input.read(current_buf_len)  # 8的倍数
-        size = len(chunk)
-        if size == 0:
-            break
-        if size < current_buf_len:  # 长度不够了
-            if buf_rate > 1:  # 还能继续变小
-                buf_rate = buf_rate // 2  # 重新设置一次读取的大小
-                current_buf_len = buf_rate * 8
-                input.seek(-size, 1)
-                continue
-        tmp = input.read(2)  # type: bytes
-        if len(tmp) == 2:
-            if tmp[0] == 61:  # = stream完了   一次解码8n+2个字节
-                chunk += tmp
-                size += 2
-            else:
-                input.seek(-2, 1)
-
-        count = lib.base16384_decode(
-            ffi.from_buffer(chunk), size, output_buf
-        )
-        output.write(ffi.unpack(output_buf, count))
-
-
-def ensure_bytes(inp) -> bytes:
-    if isinstance(inp, str):
-        return inp.encode()
-    elif isinstance(inp, bytes):
-        return inp
-    elif isinstance(inp, Path):
-        return str(inp).encode()
-    else:
-        return bytes(inp)
-
-
-def err_to_str(ret) -> str:
-    if ret == lib.base16384_err_get_file_size:
-        return "base16384_err_get_file_size"
-    elif ret == lib.base16384_err_fopen_output_file:
-        return "base16384_err_fopen_output_file"
-    elif ret == lib.base16384_err_fopen_input_file:
-        return "base16384_err_fopen_input_file"
-    elif ret == lib.base16384_err_write_file:
-        return "base16384_err_write_file"
-    elif ret == lib.base16384_err_open_input_file:
-        return "base16384_err_open_input_file"
-    elif ret == lib.base16384_err_map_input_file:
-        return "base16384_err_map_input_file"
-
-
-def encode_local_file(inp, out) -> None:
-    inp_name: bytes = ensure_bytes(inp)
-    out_name: bytes = ensure_bytes(out)
-    encbuf = ffi.new(f"char[{lib.get_encsize()}]")
-    decbuf = ffi.new(f"char[{lib.get_decsize()}]")
-    ret = lib.base16384_encode_file(
-        ffi.from_buffer(inp_name), ffi.from_buffer(out_name), encbuf, decbuf
-    )
-    if ret != lib.base16384_err_ok:
-        raise ValueError(err_to_str(ret))
-
-
-def decode_local_file(inp, out) -> None:
-    inp_name: bytes = ensure_bytes(inp)
-    out_name: bytes = ensure_bytes(out)
-    encbuf = ffi.new(f"char[{lib.get_encsize()}]")
-    decbuf = ffi.new(f"char[{lib.get_decsize()}]")
-    ret = lib.base16384_decode_file(
-        ffi.from_buffer(inp_name), ffi.from_buffer(out_name), encbuf, decbuf
-    )
-    if ret != lib.base16384_err_ok:
-        raise ValueError(err_to_str(ret))
-
-
-def encode_fd(inp: int, out: int) -> None:
-    encbuf = ffi.new(f"char[{lib.get_encsize()}]")
-    decbuf = ffi.new(f"char[{lib.get_decsize()}]")
-    ret = lib.base16384_encode_fd(inp, out, encbuf, decbuf)
-    if ret != lib.base16384_err_ok:
-        raise ValueError(err_to_str(ret))
-
-
-def decode_fd(inp: int, out: int) -> None:
-    encbuf = ffi.new(f"char[{lib.get_encsize()}]")
-    decbuf = ffi.new(f"char[{lib.get_decsize()}]")
-    ret = lib.base16384_decode_fd(inp, out, encbuf, decbuf)
-    if ret != lib.base16384_err_ok:
-        raise ValueError(err_to_str(ret))
+"""
+Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
+"""
+from pathlib import Path
+from typing import IO
+
+from pybase16384.backends.cffi._core import ffi, lib
+
+__version__ = "0.1.0"
+
+encode_len = lib.base16384_encode_len
+decode_len = lib.base16384_decode_len
+
+ENCBUFSZ = lib.get_encsize()
+DECBUFSZ = lib.get_decsize()
+FLAG_NOHEADER = lib.BASE16384_FLAG_NOHEADER_()
+FLAG_SUM_CHECK_ON_REMAIN = lib.BASE16384_FLAG_SUM_CHECK_ON_REMAIN_()
+SIMPLE_SUM_INIT_VALUE = lib.BASE16384_SIMPLE_SUM_INIT_VALUE_()
+
+
+# -----------------low level api------------------------------
+def _encode(data: bytes) -> bytes:
+    length = len(data)
+    output_size = encode_len(length) + 16
+    output_buf = ffi.new(f"char[{output_size}]")
+    if output_buf == ffi.NULL:
+        raise MemoryError
+    count = lib.base16384_encode(ffi.from_buffer(data), length, output_buf)
+    return ffi.unpack(output_buf, count)
+
+
+def _encode_into(data: bytes, out: bytearray) -> int:
+    return lib.base16384_encode(ffi.from_buffer(data), len(data), ffi.from_buffer(out))
+
+
+def _decode(data: bytes) -> bytes:
+    length = len(data)
+    output_size = decode_len(length, 0) + 16
+    output_buf = ffi.new(f"char[{output_size}]")
+    if output_buf == ffi.NULL:
+        raise MemoryError
+    count = lib.base16384_decode(ffi.from_buffer(data), length, output_buf)
+    return ffi.unpack(output_buf, count)
+
+
+def _decode_into(data: bytes, out: bytearray) -> int:
+    return lib.base16384_decode(ffi.from_buffer(data), len(data), ffi.from_buffer(out))
+
+
+def is_64bits() -> bool:
+    return bool(lib.pybase16384_64bits())
+
+
+# ----------------------------
+def _check_file(file) -> bool:
+    if hasattr(file, "read") and hasattr(file, "write") and hasattr(file, "seek"):
+        return True
+    return False
+
+
+def encode_file(input: IO, output: IO, write_head: bool = False, buf_rate: int = 10):
+    if not _check_file(input):
+        raise TypeError(
+            "input except a file-like object, got %s" % type(input).__name__
+        )
+    if not _check_file(output):
+        raise TypeError(
+            "output except a file-like object, got %s" % type(input).__name__
+        )
+    if buf_rate <= 0:
+        buf_rate = 1
+    if write_head:
+        output.write(b"\xfe\xff")
+
+    current_buf_len: int = buf_rate * 7  # 一次读取这么多字节
+    output_size: int = encode_len(current_buf_len) + 16  # 因为encode_len不是单调的 这16备用
+    output_buf = ffi.new(f"char[{output_size}]")
+    if output_buf == ffi.NULL:
+        raise MemoryError
+    first_check: int = 1  # 检查一次就行了 怎么可能出现第一次读出来是bytes 以后又变卦了的对象呢 不会吧不会吧
+    while True:
+        chunk = input.read(current_buf_len)
+        if first_check:
+            first_check = 0
+            if not isinstance(chunk, bytes):
+                raise TypeError(
+                    f"input must be a file-like rb object, got {type(input).__name__}"
+                )
+        size = len(chunk)
+        if size < current_buf_len:  # 数据不够了 要减小一次读取的量
+            if buf_rate > 1:  # 重新设置一次读取的大小 重新设置流的位置 当然要是已经是一次读取7字节了 那就不能再变小了 直接encode吧
+                buf_rate = buf_rate // 2
+                current_buf_len = buf_rate * 7
+                input.seek(-size, 1)
+                continue
+
+        count = lib.base16384_encode(ffi.from_buffer(chunk), size, output_buf)
+        output.write(ffi.unpack(output_buf, count))
+        if size < 7:
+            break
+
+
+def decode_file(input: IO, output: IO, buf_rate: int = 10):
+    if not _check_file(input):
+        raise TypeError(
+            "input except a file-like object, got %s" % type(input).__name__
+        )
+    if not _check_file(output):
+        raise TypeError(
+            "output except a file-like object, got %s" % type(output).__name__
+        )
+    if buf_rate <= 0:
+        buf_rate = 1
+
+    chunk = input.read(1)  # type: bytes
+    if not isinstance(chunk, bytes):
+        raise TypeError(
+            f"input must be a file-like rb object, got {type(input).__name__}"
+        )
+    if chunk == b"\xfe":  # 去头
+        input.read(1)
+    else:
+        input.seek(0, 0)  # 没有头 回到开头
+
+    current_buf_len: int = buf_rate * 8
+    output_size: int = decode_len(current_buf_len, 0) + 16
+    output_buf = ffi.new(f"char[{output_size}]")
+    if output_buf == ffi.NULL:
+        raise MemoryError
+    while True:
+        chunk = input.read(current_buf_len)  # 8的倍数
+        size = len(chunk)
+        if size == 0:
+            break
+        if size < current_buf_len:  # 长度不够了
+            if buf_rate > 1:  # 还能继续变小
+                buf_rate = buf_rate // 2  # 重新设置一次读取的大小
+                current_buf_len = buf_rate * 8
+                input.seek(-size, 1)
+                continue
+        tmp = input.read(2)  # type: bytes
+        if len(tmp) == 2:
+            if tmp[0] == 61:  # = stream完了   一次解码8n+2个字节
+                chunk += tmp
+                size += 2
+            else:
+                input.seek(-2, 1)
+
+        count = lib.base16384_decode(ffi.from_buffer(chunk), size, output_buf)
+        output.write(ffi.unpack(output_buf, count))
+
+
+def ensure_bytes(inp) -> bytes:
+    if isinstance(inp, str):
+        return inp.encode()
+    elif isinstance(inp, bytes):
+        return inp
+    elif isinstance(inp, Path):
+        return str(inp).encode()
+    else:
+        return bytes(inp)
+
+
+def err_to_str(ret) -> str:
+    if ret == lib.base16384_err_get_file_size:
+        return "base16384_err_get_file_size"
+    elif ret == lib.base16384_err_fopen_output_file:
+        return "base16384_err_fopen_output_file"
+    elif ret == lib.base16384_err_fopen_input_file:
+        return "base16384_err_fopen_input_file"
+    elif ret == lib.base16384_err_write_file:
+        return "base16384_err_write_file"
+    elif ret == lib.base16384_err_open_input_file:
+        return "base16384_err_open_input_file"
+    elif ret == lib.base16384_err_map_input_file:
+        return "base16384_err_map_input_file"
+    elif ret == lib.base16384_err_read_file:
+        return "base16384_err_read_file"
+    elif ret == lib.base16384_err_invalid_file_name:
+        return "base16384_err_invalid_file_name"
+    elif ret == lib.base16384_err_invalid_file_name:
+        return "base16384_err_invalid_file_name"
+    elif ret == lib.base16384_err_invalid_commandline_parameter:
+        return "base16384_err_invalid_commandline_parameter"
+    elif ret == lib.base16384_err_invalid_decoding_checksum:
+        return "base16384_err_invalid_decoding_checksum"
+
+
+def encode_local_file(inp, out) -> None:
+    inp_name: bytes = ensure_bytes(inp)
+    out_name: bytes = ensure_bytes(out)
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_encode_file(
+        ffi.from_buffer(inp_name), ffi.from_buffer(out_name), encbuf, decbuf
+    )
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+def decode_local_file(inp, out) -> None:
+    inp_name: bytes = ensure_bytes(inp)
+    out_name: bytes = ensure_bytes(out)
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_decode_file(
+        ffi.from_buffer(inp_name), ffi.from_buffer(out_name), encbuf, decbuf
+    )
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+def encode_fd(inp: int, out: int) -> None:
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_encode_fd(inp, out, encbuf, decbuf)
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+def decode_fd(inp: int, out: int) -> None:
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_decode_fd(inp, out, encbuf, decbuf)
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+# detail
+def encode_local_file_detailed(inp, out, flag: int) -> None:
+    inp_name: bytes = ensure_bytes(inp)
+    out_name: bytes = ensure_bytes(out)
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_encode_file_detailed(
+        ffi.from_buffer(inp_name), ffi.from_buffer(out_name), encbuf, decbuf, flag
+    )
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+def decode_local_file_detailed(inp, out, flag: int) -> None:
+    inp_name: bytes = ensure_bytes(inp)
+    out_name: bytes = ensure_bytes(out)
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_decode_file_detailed(
+        ffi.from_buffer(inp_name), ffi.from_buffer(out_name), encbuf, decbuf, flag
+    )
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+def encode_fd_detailed(inp: int, out: int, flag: int) -> None:
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
+
+
+def decode_fd_detailed(inp: int, out: int, flag: int) -> None:
+    encbuf = ffi.new(f"char[{ENCBUFSZ}]")
+    decbuf = ffi.new(f"char[{DECBUFSZ}]")
+    ret = lib.base16384_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+    if ret != lib.base16384_err_ok:
+        raise ValueError(err_to_str(ret))
```

## pybase16384/backends/cffi/build.py

```diff
@@ -1,107 +1,143 @@
-"""
-Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
-"""
-import platform
-import sys
-
-from cffi import FFI
-
-if sys.maxsize > 2**32:
-    CPUBIT = 64
-else:
-    CPUBIT = 32
-
-system = platform.system()
-if system == "Windows":
-    macro_base = [("_WIN64", None)]
-elif system == "Linux":
-    macro_base = [("__linux__", None)]
-elif system == "Darwin":
-    macro_base = [("__MAC_10_0", None)]
-else:
-    macro_base = []
-
-if sys.byteorder != "little":
-    macro_base.append(("WORDS_BIGENDIAN", None))
-
-if CPUBIT == 64:
-    macro_base.append(("CPUBIT64", None))
-else:
-    macro_base.append(("CPUBIT32", None))
-
-ffibuilder = FFI()
-ffibuilder.cdef(
-    """
-// base16384_err_t is the return value of base16384_en/decode_file
-enum base16384_err_t {
-	base16384_err_ok,
-	base16384_err_get_file_size,
-	base16384_err_fopen_output_file,
-	base16384_err_fopen_input_file,
-	base16384_err_write_file,
-	base16384_err_open_input_file,
-	base16384_err_map_input_file,
-};
-// base16384_err_t is the return value of base16384_en/decode_file
-typedef enum base16384_err_t base16384_err_t;
-int base16384_encode_len(int dlen);
-int base16384_decode_len(int dlen, int offset);
-int base16384_encode(const char* data, int dlen, char* buf);
-int base16384_decode(const char* data, int dlen, char* buf);
-base16384_err_t base16384_encode_file(const char* input, const char* output, char* encbuf, char* decbuf);
-base16384_err_t base16384_decode_file(const char* input, const char* output, char* encbuf, char* decbuf);
-
-// base16384_encode_fp encodes input file to output file.
-//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-base16384_err_t base16384_encode_fp(FILE* input, FILE* output, char* encbuf, char* decbuf);
-
-// base16384_encode_fd encodes input fd to output fd.
-//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-base16384_err_t base16384_encode_fd(int input, int output, char* encbuf, char* decbuf);
-
-// base16384_decode_fp decodes input file to output file.
-//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-base16384_err_t base16384_decode_fp(FILE* input, FILE* output, char* encbuf, char* decbuf);
-
-// base16384_decode_fd decodes input fd to output fd.
-//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-base16384_err_t base16384_decode_fd(int input, int output, char* encbuf, char* decbuf);
-
-int32_t pybase16384_64bits();
-
-int get_encsize();
-
-int get_decsize();
-    """
-)
-
-source = """
-#include "base16384.h"
-
-#ifdef CPUBIT32
-#define pybase16384_64bits() 0
-#else
-#define pybase16384_64bits() 1
-#endif
-
-int get_encsize()
-{
-    return BASE16384_ENCBUFSZ;
-}
-
-int get_decsize()
-{
-    return BASE16384_DECBUFSZ;
-}
-"""
-
-ffibuilder.set_source(
-    "pybase16384.backends.cffi._core",
-    source,
-    sources=[f"./base16384/base14{CPUBIT}.c", "./base16384/file.c"],
-    include_dirs=["./base16384"],
-    define_macros=macro_base,
-)
-
-if __name__ == "__main__":
-    ffibuilder.compile()
+"""
+Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
+"""
+import platform
+import sys
+
+from cffi import FFI
+
+if sys.maxsize > 2**32:
+    CPUBIT = 64
+else:
+    CPUBIT = 32
+
+system = platform.system()
+if system == "Windows":
+    macro_base = [("_WIN64", None)]
+elif system == "Linux":
+    macro_base = [("__linux__", None)]
+elif system == "Darwin":
+    macro_base = [("__MAC_10_0", None)]
+else:
+    macro_base = []
+
+if sys.byteorder != "little":
+    macro_base.append(("WORDS_BIGENDIAN", None))
+
+if CPUBIT == 64:
+    macro_base.append(("CPUBIT64", None))
+    macro_base.append(("IS_64BIT_PROCESSOR", None))
+else:
+    macro_base.append(("CPUBIT32", None))
+
+ffibuilder = FFI()
+ffibuilder.cdef(
+    """
+// base16384_err_t is the return value of base16384_en/decode_file
+enum base16384_err_t {
+	base16384_err_ok,
+	base16384_err_get_file_size,
+	base16384_err_fopen_output_file,
+	base16384_err_fopen_input_file,
+	base16384_err_write_file,
+	base16384_err_open_input_file,
+	base16384_err_map_input_file,
+	base16384_err_read_file,
+    base16384_err_invalid_file_name,
+    base16384_err_invalid_commandline_parameter,
+    base16384_err_invalid_decoding_checksum
+};
+// base16384_err_t is the return value of base16384_en/decode_file
+typedef enum base16384_err_t base16384_err_t;
+int base16384_encode_len(int dlen);
+int base16384_decode_len(int dlen, int offset);
+int base16384_encode(const char* data, int dlen, char* buf);
+int base16384_decode(const char* data, int dlen, char* buf);
+base16384_err_t base16384_encode_file(const char* input, const char* output, char* encbuf, char* decbuf);
+base16384_err_t base16384_decode_file(const char* input, const char* output, char* encbuf, char* decbuf);
+
+// base16384_encode_fp encodes input file to output file.
+//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+base16384_err_t base16384_encode_fp(FILE* input, FILE* output, char* encbuf, char* decbuf);
+
+// base16384_encode_fd encodes input fd to output fd.
+//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+base16384_err_t base16384_encode_fd(int input, int output, char* encbuf, char* decbuf);
+
+// base16384_decode_fp decodes input file to output file.
+//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+base16384_err_t base16384_decode_fp(FILE* input, FILE* output, char* encbuf, char* decbuf);
+
+// base16384_decode_fd decodes input fd to output fd.
+//    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+base16384_err_t base16384_decode_fd(int input, int output, char* encbuf, char* decbuf);
+
+int base16384_encode_unsafe(const char * data, int dlen, char * buf);
+int base16384_decode_unsafe(const char * data, int dlen, char * buf);
+
+base16384_err_t base16384_encode_file_detailed(const char* input, const char* output, char* encbuf, char* decbuf, int flag);
+base16384_err_t base16384_decode_file_detailed(const char* input, const char* output, char* encbuf, char* decbuf, int flag);
+base16384_err_t base16384_encode_fd_detailed(int input, int output, char* encbuf, char* decbuf, int flag);
+base16384_err_t base16384_decode_fd_detailed(int input, int output, char* encbuf, char* decbuf, int flag);
+base16384_err_t base16384_encode_fp_detailed(FILE* input, FILE* output, char* encbuf, char* decbuf, int flag);
+base16384_err_t base16384_decode_fp_detailed(FILE* input, FILE* output, char* encbuf, char* decbuf, int flag);
+
+int32_t pybase16384_64bits();
+
+int get_encsize();
+
+int get_decsize();
+
+int BASE16384_FLAG_NOHEADER_();
+
+int BASE16384_FLAG_SUM_CHECK_ON_REMAIN_();
+
+int BASE16384_SIMPLE_SUM_INIT_VALUE_();
+    """
+)
+
+source = """
+#include "base16384.h"
+
+#ifdef CPUBIT32
+#define pybase16384_64bits() 0
+#else
+#define pybase16384_64bits() 1
+#endif
+
+int get_encsize()
+{
+    return BASE16384_ENCBUFSZ;
+}
+
+int get_decsize()
+{
+    return BASE16384_DECBUFSZ;
+}
+
+int BASE16384_FLAG_NOHEADER_()
+{
+    return BASE16384_FLAG_NOHEADER;
+}
+
+int BASE16384_FLAG_SUM_CHECK_ON_REMAIN_()
+{
+    return BASE16384_FLAG_SUM_CHECK_ON_REMAIN;
+}
+
+int BASE16384_SIMPLE_SUM_INIT_VALUE_()
+{
+    return BASE16384_SIMPLE_SUM_INIT_VALUE;
+}
+"""
+
+ffibuilder.set_source(
+    "pybase16384.backends.cffi._core",
+    source,
+    sources=[f"./base16384/base14{CPUBIT}.c", "./base16384/file.c"],
+    include_dirs=["./base16384"],
+    define_macros=macro_base,
+)
+
+if __name__ == "__main__":
+    ffibuilder.compile()
```

## pybase16384/backends/cython/__init__.py

```diff
@@ -1,18 +1,27 @@
-"""
-Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
-"""
-from pybase16384.backends.cython._core import (
-    _decode,
-    _decode_into,
-    _encode,
-    _encode_into,
-    decode_fd,
-    decode_file,
-    decode_len,
-    decode_local_file,
-    encode_fd,
-    encode_file,
-    encode_len,
-    encode_local_file,
-    is_64bits,
-)
+"""
+Copyright (c) 2008-2021 synodriver <synodriver@gmail.com>
+"""
+from pybase16384.backends.cython._core import (
+    DECBUFSZ,
+    ENCBUFSZ,
+    FLAG_NOHEADER,
+    FLAG_SUM_CHECK_ON_REMAIN,
+    SIMPLE_SUM_INIT_VALUE,
+    _decode,
+    _decode_into,
+    _encode,
+    _encode_into,
+    decode_fd,
+    decode_fd_detailed,
+    decode_file,
+    decode_len,
+    decode_local_file,
+    decode_local_file_detailed,
+    encode_fd,
+    encode_fd_detailed,
+    encode_file,
+    encode_len,
+    encode_local_file,
+    encode_local_file_detailed,
+    is_64bits,
+)
```

## pybase16384/backends/cython/_core.c

```diff
@@ -1,24 +1,28 @@
-/* Generated by Cython 3.0.9 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "define_macros": [
             [
-                "_WIN64",
+                "__MAC_10_0",
                 null
             ],
             [
                 "CPUBIT64",
                 null
+            ],
+            [
+                "IS_64BIT_PROCESSOR",
+                null
             ]
         ],
         "depends": [
-            "base16384\\base16384.h"
+            "base16384/base16384.h"
         ],
         "include_dirs": [
             "./base16384"
         ],
         "library_dirs": [
             "./base16384"
         ],
@@ -53,18 +57,18 @@
     #error Cython requires Python 2.7+ or Python 3.3+.
 #else
 #if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
 #define __PYX_EXTRA_ABI_MODULE_NAME "limited"
 #else
 #define __PYX_EXTRA_ABI_MODULE_NAME ""
 #endif
-#define CYTHON_ABI "3_0_9" __PYX_EXTRA_ABI_MODULE_NAME
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
 #define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
 #define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030009F0
+#define CYTHON_HEX_VERSION 0x03000AF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -148,14 +152,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(PYPY_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
@@ -209,14 +215,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(CYTHON_LIMITED_API)
   #ifdef Py_LIMITED_API
     #undef __PYX_LIMITED_VERSION_HEX
     #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
   #endif
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
@@ -270,60 +278,83 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
@@ -406,14 +437,17 @@
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if !defined(CYTHON_VECTORCALL)
 #define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
 #endif
@@ -1479,15 +1513,15 @@
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm = __FILE__;
 static const char *__pyx_filename;
 
 /* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
-  "pybase16384\\\\backends\\\\cython\\\\_core.pyx",
+  "pybase16384/backends/cython/_core.pyx",
   "<stringsource>",
   "type.pxd",
 };
 /* #### Code section: utility_code_proto_before_types ### */
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
@@ -2412,30 +2446,30 @@
 
 /* SetupReduce.proto */
 #if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce(PyObject* type_obj);
 #endif
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto_3_0_9
-#define __PYX_HAVE_RT_ImportType_proto_3_0_9
+#ifndef __PYX_HAVE_RT_ImportType_proto_3_0_10
+#define __PYX_HAVE_RT_ImportType_proto_3_0_10
 #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
 #include <stdalign.h>
 #endif
 #if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || __cplusplus >= 201103L
-#define __PYX_GET_STRUCT_ALIGNMENT_3_0_9(s) alignof(s)
+#define __PYX_GET_STRUCT_ALIGNMENT_3_0_10(s) alignof(s)
 #else
-#define __PYX_GET_STRUCT_ALIGNMENT_3_0_9(s) sizeof(void*)
+#define __PYX_GET_STRUCT_ALIGNMENT_3_0_10(s) sizeof(void*)
 #endif
-enum __Pyx_ImportType_CheckSize_3_0_9 {
-   __Pyx_ImportType_CheckSize_Error_3_0_9 = 0,
-   __Pyx_ImportType_CheckSize_Warn_3_0_9 = 1,
-   __Pyx_ImportType_CheckSize_Ignore_3_0_9 = 2
+enum __Pyx_ImportType_CheckSize_3_0_10 {
+   __Pyx_ImportType_CheckSize_Error_3_0_10 = 0,
+   __Pyx_ImportType_CheckSize_Warn_3_0_10 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_3_0_10 = 2
 };
-static PyTypeObject *__Pyx_ImportType_3_0_9(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_9 check_size);
+static PyTypeObject *__Pyx_ImportType_3_0_10(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_10 check_size);
 #endif
 
 /* FetchSharedCythonModule.proto */
 static PyObject *__Pyx_FetchSharedCythonABIModule(void);
 
 /* FetchCommonType.proto */
 #if !CYTHON_USE_TYPE_SPECS
@@ -2788,14 +2822,18 @@
 static CYTHON_INLINE int __pyx_f_11pybase16384_8backends_6cython_5_core__decode_into(__Pyx_memviewslice, __Pyx_memviewslice, int __pyx_skip_dispatch); /*proto*/
 static CYTHON_INLINE int __pyx_f_11pybase16384_8backends_6cython_5_core_is_64bits(int __pyx_skip_dispatch); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(base16384_err_t); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_encode_local_file(PyObject *, PyObject *, int __pyx_skip_dispatch); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_decode_local_file(PyObject *, PyObject *, int __pyx_skip_dispatch); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_encode_fd(int, int, int __pyx_skip_dispatch); /*proto*/
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_decode_fd(int, int, int __pyx_skip_dispatch); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_encode_local_file_detailed(PyObject *, PyObject *, int, int __pyx_skip_dispatch); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_decode_local_file_detailed(PyObject *, PyObject *, int, int __pyx_skip_dispatch); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_encode_fd_detailed(int, int, int, int __pyx_skip_dispatch); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_decode_fd_detailed(int, int, int, int __pyx_skip_dispatch); /*proto*/
 static int __pyx_array_allocate_buffer(struct __pyx_array_obj *); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
 static int assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
@@ -2854,15 +2892,15 @@
 static const char __pyx_k__3[] = "*";
 static const char __pyx_k__6[] = "'";
 static const char __pyx_k__7[] = ")";
 static const char __pyx_k_gc[] = "gc";
 static const char __pyx_k_id[] = "id";
 static const char __pyx_k__10[] = "\376\377";
 static const char __pyx_k__11[] = "\376";
-static const char __pyx_k__45[] = "?";
+static const char __pyx_k__50[] = "?";
 static const char __pyx_k_abc[] = "abc";
 static const char __pyx_k_and[] = " and ";
 static const char __pyx_k_got[] = " (got ";
 static const char __pyx_k_inp[] = "inp";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
 static const char __pyx_k_out[] = "out";
@@ -2870,14 +2908,15 @@
 static const char __pyx_k_tmp[] = "tmp";
 static const char __pyx_k_Path[] = "Path";
 static const char __pyx_k_base[] = "base";
 static const char __pyx_k_data[] = "data";
 static const char __pyx_k_dest[] = "dest";
 static const char __pyx_k_dict[] = "__dict__";
 static const char __pyx_k_dlen[] = "dlen";
+static const char __pyx_k_flag[] = "flag";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
 static const char __pyx_k_pack[] = "pack";
 static const char __pyx_k_read[] = "read";
 static const char __pyx_k_seek[] = "seek";
@@ -2953,14 +2992,15 @@
 static const char __pyx_k_first_check[] = "first_check";
 static const char __pyx_k_output_size[] = "output_size";
 static const char __pyx_k_initializing[] = "_initializing";
 static const char __pyx_k_is_coroutine[] = "_is_coroutine";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
 static const char __pyx_k_stringsource[] = "<stringsource>";
 static const char __pyx_k_version_info[] = "version_info";
+static const char __pyx_k_FLAG_NOHEADER[] = "FLAG_NOHEADER";
 static const char __pyx_k_class_getitem[] = "__class_getitem__";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_AssertionError[] = "AssertionError";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
 static const char __pyx_k_collections_abc[] = "collections.abc";
 static const char __pyx_k_current_buf_len[] = "current_buf_len";
@@ -2968,53 +3008,63 @@
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_decode_local_file[] = "decode_local_file";
 static const char __pyx_k_encode_local_file[] = "encode_local_file";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
 static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
+static const char __pyx_k_decode_fd_detailed[] = "decode_fd_detailed";
+static const char __pyx_k_encode_fd_detailed[] = "encode_fd_detailed";
 static const char __pyx_k_strided_and_direct[] = "<strided and direct>";
 static const char __pyx_k_strided_and_indirect[] = "<strided and indirect>";
 static const char __pyx_k_Invalid_shape_in_axis[] = "Invalid shape in axis ";
+static const char __pyx_k_SIMPLE_SUM_INIT_VALUE[] = "SIMPLE_SUM_INIT_VALUE";
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
 static const char __pyx_k_Cannot_index_with_type[] = "Cannot index with type '";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
+static const char __pyx_k_base16384_err_read_file[] = "base16384_err_read_file";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
+static const char __pyx_k_FLAG_SUM_CHECK_ON_REMAIN[] = "FLAG_SUM_CHECK_ON_REMAIN";
 static const char __pyx_k_base16384_err_write_file[] = "base16384_err_write_file";
 static const char __pyx_k_Dimension_d_is_not_direct[] = "Dimension %d is not direct";
 static const char __pyx_k_Index_out_of_bounds_axis_d[] = "Index out of bounds (axis %d)";
+static const char __pyx_k_decode_local_file_detailed[] = "decode_local_file_detailed";
+static const char __pyx_k_encode_local_file_detailed[] = "encode_local_file_detailed";
 static const char __pyx_k_Step_may_not_be_zero_axis_d[] = "Step may not be zero (axis %d)";
 static const char __pyx_k_base16384_err_get_file_size[] = "base16384_err_get_file_size";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
 static const char __pyx_k_base16384_err_map_input_file[] = "base16384_err_map_input_file";
 static const char __pyx_k_base16384_err_open_input_file[] = "base16384_err_open_input_file";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_base16384_err_fopen_input_file[] = "base16384_err_fopen_input_file";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_base16384_err_fopen_output_file[] = "base16384_err_fopen_output_file";
+static const char __pyx_k_base16384_err_invalid_file_name[] = "base16384_err_invalid_file_name";
 static const char __pyx_k_input_except_a_file_like_object[] = "input except a file-like object, got %s";
 static const char __pyx_k_All_dimensions_preceding_dimensi[] = "All dimensions preceding dimension %d must be indexed and not sliced";
 static const char __pyx_k_Buffer_is_too_small_to_hold_resu[] = "Buffer is too small to hold result";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Cannot_transpose_memoryview_with[] = "Cannot transpose memoryview with indirect dimensions";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got ";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis ";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
+static const char __pyx_k_base16384_err_invalid_commandlin[] = "base16384_err_invalid_commandline_parameter";
+static const char __pyx_k_base16384_err_invalid_decoding_c[] = "base16384_err_invalid_decoding_checksum";
 static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension ";
 static const char __pyx_k_input_must_be_a_file_like_rb_obj[] = "input must be a file-like rb object, got ";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_output_except_a_file_like_object[] = "output except a file-like object, got %s";
-static const char __pyx_k_pybase16384_backends_cython__cor[] = "pybase16384\\backends\\cython\\_core.pyx";
+static const char __pyx_k_pybase16384_backends_cython__cor[] = "pybase16384/backends/cython/_core.pyx";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
 static const char __pyx_k_pybase16384_backends_cython__cor_2[] = "pybase16384.backends.cython._core";
 /* #### Code section: decls ### */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
@@ -3064,14 +3114,18 @@
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_12encode_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, PyObject *__pyx_v_output, int __pyx_v_write_head, int32_t __pyx_v_buf_rate); /* proto */
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_14decode_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_input, PyObject *__pyx_v_output, int32_t __pyx_v_buf_rate); /* proto */
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_16is_64bits(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_18encode_local_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_inp, PyObject *__pyx_v_out); /* proto */
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_20decode_local_file(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_inp, PyObject *__pyx_v_out); /* proto */
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_22encode_fd(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_inp, int __pyx_v_out); /* proto */
 static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_24decode_fd(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_inp, int __pyx_v_out); /* proto */
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_26encode_local_file_detailed(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_inp, PyObject *__pyx_v_out, int __pyx_v_flag); /* proto */
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_28decode_local_file_detailed(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_inp, PyObject *__pyx_v_out, int __pyx_v_flag); /* proto */
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_30encode_fd_detailed(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_inp, int __pyx_v_out, int __pyx_v_flag); /* proto */
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_32decode_fd_detailed(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_inp, int __pyx_v_out, int __pyx_v_flag); /* proto */
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 /* #### Code section: late_includes ### */
 /* #### Code section: module_state ### */
 typedef struct {
@@ -3142,50 +3196,57 @@
   PyObject *__pyx_kp_u_Cannot_index_with_type;
   PyObject *__pyx_kp_s_Cannot_transpose_memoryview_with;
   PyObject *__pyx_n_s_DECBUFSZ;
   PyObject *__pyx_kp_s_Dimension_d_is_not_direct;
   PyObject *__pyx_n_s_ENCBUFSZ;
   PyObject *__pyx_n_s_Ellipsis;
   PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
+  PyObject *__pyx_n_s_FLAG_NOHEADER;
+  PyObject *__pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN;
   PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
   PyObject *__pyx_n_s_IndexError;
   PyObject *__pyx_kp_s_Index_out_of_bounds_axis_d;
   PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
   PyObject *__pyx_kp_u_Invalid_mode_expected_c_or_fortr;
   PyObject *__pyx_kp_u_Invalid_shape_in_axis;
   PyObject *__pyx_n_s_MemoryError;
   PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
   PyObject *__pyx_kp_s_MemoryView_of_r_object;
   PyObject *__pyx_n_b_O;
   PyObject *__pyx_kp_u_Out_of_bounds_on_buffer_access_a;
   PyObject *__pyx_n_s_Path;
   PyObject *__pyx_n_s_PickleError;
+  PyObject *__pyx_n_s_SIMPLE_SUM_INIT_VALUE;
   PyObject *__pyx_n_s_Sequence;
   PyObject *__pyx_kp_s_Step_may_not_be_zero_axis_d;
   PyObject *__pyx_n_s_TypeError;
   PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
   PyObject *__pyx_n_s_ValueError;
   PyObject *__pyx_n_s_View_MemoryView;
   PyObject *__pyx_kp_b__10;
   PyObject *__pyx_kp_b__11;
   PyObject *__pyx_kp_u__2;
   PyObject *__pyx_n_s__3;
-  PyObject *__pyx_n_s__45;
+  PyObject *__pyx_n_s__50;
   PyObject *__pyx_kp_u__6;
   PyObject *__pyx_kp_u__7;
   PyObject *__pyx_n_s_abc;
   PyObject *__pyx_n_s_allocate_buffer;
   PyObject *__pyx_kp_u_and;
   PyObject *__pyx_n_s_asyncio_coroutines;
   PyObject *__pyx_n_s_base;
   PyObject *__pyx_n_u_base16384_err_fopen_input_file;
   PyObject *__pyx_n_u_base16384_err_fopen_output_file;
   PyObject *__pyx_n_u_base16384_err_get_file_size;
+  PyObject *__pyx_n_u_base16384_err_invalid_commandlin;
+  PyObject *__pyx_n_u_base16384_err_invalid_decoding_c;
+  PyObject *__pyx_n_u_base16384_err_invalid_file_name;
   PyObject *__pyx_n_u_base16384_err_map_input_file;
   PyObject *__pyx_n_u_base16384_err_open_input_file;
+  PyObject *__pyx_n_u_base16384_err_read_file;
   PyObject *__pyx_n_u_base16384_err_write_file;
   PyObject *__pyx_n_s_buf_rate;
   PyObject *__pyx_n_s_c;
   PyObject *__pyx_n_u_c;
   PyObject *__pyx_n_s_chunk;
   PyObject *__pyx_n_s_chunk_ptr;
   PyObject *__pyx_n_s_class;
@@ -3196,34 +3257,39 @@
   PyObject *__pyx_kp_s_contiguous_and_direct;
   PyObject *__pyx_kp_s_contiguous_and_indirect;
   PyObject *__pyx_n_s_count;
   PyObject *__pyx_n_s_current_buf_len;
   PyObject *__pyx_n_s_data;
   PyObject *__pyx_n_s_decode;
   PyObject *__pyx_n_s_decode_fd;
+  PyObject *__pyx_n_s_decode_fd_detailed;
   PyObject *__pyx_n_s_decode_file;
   PyObject *__pyx_n_s_decode_into;
   PyObject *__pyx_n_s_decode_len;
   PyObject *__pyx_n_s_decode_local_file;
+  PyObject *__pyx_n_s_decode_local_file_detailed;
   PyObject *__pyx_n_s_dest;
   PyObject *__pyx_n_s_dict;
   PyObject *__pyx_kp_u_disable;
   PyObject *__pyx_n_s_dlen;
   PyObject *__pyx_n_s_dtype_is_object;
   PyObject *__pyx_kp_u_enable;
   PyObject *__pyx_n_s_encode;
   PyObject *__pyx_n_s_encode_2;
   PyObject *__pyx_n_s_encode_fd;
+  PyObject *__pyx_n_s_encode_fd_detailed;
   PyObject *__pyx_n_s_encode_file;
   PyObject *__pyx_n_s_encode_into;
   PyObject *__pyx_n_s_encode_len;
   PyObject *__pyx_n_s_encode_local_file;
+  PyObject *__pyx_n_s_encode_local_file_detailed;
   PyObject *__pyx_n_s_enumerate;
   PyObject *__pyx_n_s_error;
   PyObject *__pyx_n_s_first_check;
+  PyObject *__pyx_n_s_flag;
   PyObject *__pyx_n_s_flags;
   PyObject *__pyx_n_s_format;
   PyObject *__pyx_n_s_fortran;
   PyObject *__pyx_n_u_fortran;
   PyObject *__pyx_kp_u_gc;
   PyObject *__pyx_n_s_getstate;
   PyObject *__pyx_kp_u_got;
@@ -3327,28 +3393,33 @@
   PyObject *__pyx_tuple__25;
   PyObject *__pyx_tuple__27;
   PyObject *__pyx_tuple__29;
   PyObject *__pyx_tuple__32;
   PyObject *__pyx_tuple__35;
   PyObject *__pyx_tuple__37;
   PyObject *__pyx_tuple__40;
+  PyObject *__pyx_tuple__45;
   PyObject *__pyx_codeobj__24;
   PyObject *__pyx_codeobj__26;
   PyObject *__pyx_codeobj__28;
   PyObject *__pyx_codeobj__30;
   PyObject *__pyx_codeobj__31;
   PyObject *__pyx_codeobj__33;
   PyObject *__pyx_codeobj__34;
   PyObject *__pyx_codeobj__36;
   PyObject *__pyx_codeobj__38;
   PyObject *__pyx_codeobj__39;
   PyObject *__pyx_codeobj__41;
   PyObject *__pyx_codeobj__42;
   PyObject *__pyx_codeobj__43;
   PyObject *__pyx_codeobj__44;
+  PyObject *__pyx_codeobj__46;
+  PyObject *__pyx_codeobj__47;
+  PyObject *__pyx_codeobj__48;
+  PyObject *__pyx_codeobj__49;
 } __pyx_mstate;
 
 #if CYTHON_USE_MODULE_STATE
 #ifdef __cplusplus
 namespace {
   extern struct PyModuleDef __pyx_moduledef;
 } /* anonymous namespace */
@@ -3408,50 +3479,57 @@
   Py_CLEAR(clear_module_state->__pyx_kp_u_Cannot_index_with_type);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
   Py_CLEAR(clear_module_state->__pyx_n_s_DECBUFSZ);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
   Py_CLEAR(clear_module_state->__pyx_n_s_ENCBUFSZ);
   Py_CLEAR(clear_module_state->__pyx_n_s_Ellipsis);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
+  Py_CLEAR(clear_module_state->__pyx_n_s_FLAG_NOHEADER);
+  Py_CLEAR(clear_module_state->__pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
   Py_CLEAR(clear_module_state->__pyx_n_s_IndexError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_shape_in_axis);
   Py_CLEAR(clear_module_state->__pyx_n_s_MemoryError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
   Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_object);
   Py_CLEAR(clear_module_state->__pyx_n_b_O);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
   Py_CLEAR(clear_module_state->__pyx_n_s_Path);
   Py_CLEAR(clear_module_state->__pyx_n_s_PickleError);
+  Py_CLEAR(clear_module_state->__pyx_n_s_SIMPLE_SUM_INIT_VALUE);
   Py_CLEAR(clear_module_state->__pyx_n_s_Sequence);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
   Py_CLEAR(clear_module_state->__pyx_n_s_TypeError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
   Py_CLEAR(clear_module_state->__pyx_n_s_ValueError);
   Py_CLEAR(clear_module_state->__pyx_n_s_View_MemoryView);
   Py_CLEAR(clear_module_state->__pyx_kp_b__10);
   Py_CLEAR(clear_module_state->__pyx_kp_b__11);
   Py_CLEAR(clear_module_state->__pyx_kp_u__2);
   Py_CLEAR(clear_module_state->__pyx_n_s__3);
-  Py_CLEAR(clear_module_state->__pyx_n_s__45);
+  Py_CLEAR(clear_module_state->__pyx_n_s__50);
   Py_CLEAR(clear_module_state->__pyx_kp_u__6);
   Py_CLEAR(clear_module_state->__pyx_kp_u__7);
   Py_CLEAR(clear_module_state->__pyx_n_s_abc);
   Py_CLEAR(clear_module_state->__pyx_n_s_allocate_buffer);
   Py_CLEAR(clear_module_state->__pyx_kp_u_and);
   Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
   Py_CLEAR(clear_module_state->__pyx_n_s_base);
   Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_fopen_input_file);
   Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_fopen_output_file);
   Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_get_file_size);
+  Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_invalid_commandlin);
+  Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_invalid_decoding_c);
+  Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_invalid_file_name);
   Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_map_input_file);
   Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_open_input_file);
+  Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_read_file);
   Py_CLEAR(clear_module_state->__pyx_n_u_base16384_err_write_file);
   Py_CLEAR(clear_module_state->__pyx_n_s_buf_rate);
   Py_CLEAR(clear_module_state->__pyx_n_s_c);
   Py_CLEAR(clear_module_state->__pyx_n_u_c);
   Py_CLEAR(clear_module_state->__pyx_n_s_chunk);
   Py_CLEAR(clear_module_state->__pyx_n_s_chunk_ptr);
   Py_CLEAR(clear_module_state->__pyx_n_s_class);
@@ -3462,34 +3540,39 @@
   Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_direct);
   Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_indirect);
   Py_CLEAR(clear_module_state->__pyx_n_s_count);
   Py_CLEAR(clear_module_state->__pyx_n_s_current_buf_len);
   Py_CLEAR(clear_module_state->__pyx_n_s_data);
   Py_CLEAR(clear_module_state->__pyx_n_s_decode);
   Py_CLEAR(clear_module_state->__pyx_n_s_decode_fd);
+  Py_CLEAR(clear_module_state->__pyx_n_s_decode_fd_detailed);
   Py_CLEAR(clear_module_state->__pyx_n_s_decode_file);
   Py_CLEAR(clear_module_state->__pyx_n_s_decode_into);
   Py_CLEAR(clear_module_state->__pyx_n_s_decode_len);
   Py_CLEAR(clear_module_state->__pyx_n_s_decode_local_file);
+  Py_CLEAR(clear_module_state->__pyx_n_s_decode_local_file_detailed);
   Py_CLEAR(clear_module_state->__pyx_n_s_dest);
   Py_CLEAR(clear_module_state->__pyx_n_s_dict);
   Py_CLEAR(clear_module_state->__pyx_kp_u_disable);
   Py_CLEAR(clear_module_state->__pyx_n_s_dlen);
   Py_CLEAR(clear_module_state->__pyx_n_s_dtype_is_object);
   Py_CLEAR(clear_module_state->__pyx_kp_u_enable);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode_2);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode_fd);
+  Py_CLEAR(clear_module_state->__pyx_n_s_encode_fd_detailed);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode_file);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode_into);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode_len);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode_local_file);
+  Py_CLEAR(clear_module_state->__pyx_n_s_encode_local_file_detailed);
   Py_CLEAR(clear_module_state->__pyx_n_s_enumerate);
   Py_CLEAR(clear_module_state->__pyx_n_s_error);
   Py_CLEAR(clear_module_state->__pyx_n_s_first_check);
+  Py_CLEAR(clear_module_state->__pyx_n_s_flag);
   Py_CLEAR(clear_module_state->__pyx_n_s_flags);
   Py_CLEAR(clear_module_state->__pyx_n_s_format);
   Py_CLEAR(clear_module_state->__pyx_n_s_fortran);
   Py_CLEAR(clear_module_state->__pyx_n_u_fortran);
   Py_CLEAR(clear_module_state->__pyx_kp_u_gc);
   Py_CLEAR(clear_module_state->__pyx_n_s_getstate);
   Py_CLEAR(clear_module_state->__pyx_kp_u_got);
@@ -3593,28 +3676,33 @@
   Py_CLEAR(clear_module_state->__pyx_tuple__25);
   Py_CLEAR(clear_module_state->__pyx_tuple__27);
   Py_CLEAR(clear_module_state->__pyx_tuple__29);
   Py_CLEAR(clear_module_state->__pyx_tuple__32);
   Py_CLEAR(clear_module_state->__pyx_tuple__35);
   Py_CLEAR(clear_module_state->__pyx_tuple__37);
   Py_CLEAR(clear_module_state->__pyx_tuple__40);
+  Py_CLEAR(clear_module_state->__pyx_tuple__45);
   Py_CLEAR(clear_module_state->__pyx_codeobj__24);
   Py_CLEAR(clear_module_state->__pyx_codeobj__26);
   Py_CLEAR(clear_module_state->__pyx_codeobj__28);
   Py_CLEAR(clear_module_state->__pyx_codeobj__30);
   Py_CLEAR(clear_module_state->__pyx_codeobj__31);
   Py_CLEAR(clear_module_state->__pyx_codeobj__33);
   Py_CLEAR(clear_module_state->__pyx_codeobj__34);
   Py_CLEAR(clear_module_state->__pyx_codeobj__36);
   Py_CLEAR(clear_module_state->__pyx_codeobj__38);
   Py_CLEAR(clear_module_state->__pyx_codeobj__39);
   Py_CLEAR(clear_module_state->__pyx_codeobj__41);
   Py_CLEAR(clear_module_state->__pyx_codeobj__42);
   Py_CLEAR(clear_module_state->__pyx_codeobj__43);
   Py_CLEAR(clear_module_state->__pyx_codeobj__44);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__46);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__47);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__48);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__49);
   return 0;
 }
 #endif
 /* #### Code section: module_state_traverse ### */
 #if CYTHON_USE_MODULE_STATE
 static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
   __pyx_mstate *traverse_module_state = __pyx_mstate(m);
@@ -3652,50 +3740,57 @@
   Py_VISIT(traverse_module_state->__pyx_kp_u_Cannot_index_with_type);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
   Py_VISIT(traverse_module_state->__pyx_n_s_DECBUFSZ);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
   Py_VISIT(traverse_module_state->__pyx_n_s_ENCBUFSZ);
   Py_VISIT(traverse_module_state->__pyx_n_s_Ellipsis);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
+  Py_VISIT(traverse_module_state->__pyx_n_s_FLAG_NOHEADER);
+  Py_VISIT(traverse_module_state->__pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
   Py_VISIT(traverse_module_state->__pyx_n_s_IndexError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_shape_in_axis);
   Py_VISIT(traverse_module_state->__pyx_n_s_MemoryError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
   Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_object);
   Py_VISIT(traverse_module_state->__pyx_n_b_O);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
   Py_VISIT(traverse_module_state->__pyx_n_s_Path);
   Py_VISIT(traverse_module_state->__pyx_n_s_PickleError);
+  Py_VISIT(traverse_module_state->__pyx_n_s_SIMPLE_SUM_INIT_VALUE);
   Py_VISIT(traverse_module_state->__pyx_n_s_Sequence);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
   Py_VISIT(traverse_module_state->__pyx_n_s_TypeError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
   Py_VISIT(traverse_module_state->__pyx_n_s_ValueError);
   Py_VISIT(traverse_module_state->__pyx_n_s_View_MemoryView);
   Py_VISIT(traverse_module_state->__pyx_kp_b__10);
   Py_VISIT(traverse_module_state->__pyx_kp_b__11);
   Py_VISIT(traverse_module_state->__pyx_kp_u__2);
   Py_VISIT(traverse_module_state->__pyx_n_s__3);
-  Py_VISIT(traverse_module_state->__pyx_n_s__45);
+  Py_VISIT(traverse_module_state->__pyx_n_s__50);
   Py_VISIT(traverse_module_state->__pyx_kp_u__6);
   Py_VISIT(traverse_module_state->__pyx_kp_u__7);
   Py_VISIT(traverse_module_state->__pyx_n_s_abc);
   Py_VISIT(traverse_module_state->__pyx_n_s_allocate_buffer);
   Py_VISIT(traverse_module_state->__pyx_kp_u_and);
   Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
   Py_VISIT(traverse_module_state->__pyx_n_s_base);
   Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_fopen_input_file);
   Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_fopen_output_file);
   Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_get_file_size);
+  Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_invalid_commandlin);
+  Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_invalid_decoding_c);
+  Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_invalid_file_name);
   Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_map_input_file);
   Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_open_input_file);
+  Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_read_file);
   Py_VISIT(traverse_module_state->__pyx_n_u_base16384_err_write_file);
   Py_VISIT(traverse_module_state->__pyx_n_s_buf_rate);
   Py_VISIT(traverse_module_state->__pyx_n_s_c);
   Py_VISIT(traverse_module_state->__pyx_n_u_c);
   Py_VISIT(traverse_module_state->__pyx_n_s_chunk);
   Py_VISIT(traverse_module_state->__pyx_n_s_chunk_ptr);
   Py_VISIT(traverse_module_state->__pyx_n_s_class);
@@ -3706,34 +3801,39 @@
   Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_direct);
   Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_indirect);
   Py_VISIT(traverse_module_state->__pyx_n_s_count);
   Py_VISIT(traverse_module_state->__pyx_n_s_current_buf_len);
   Py_VISIT(traverse_module_state->__pyx_n_s_data);
   Py_VISIT(traverse_module_state->__pyx_n_s_decode);
   Py_VISIT(traverse_module_state->__pyx_n_s_decode_fd);
+  Py_VISIT(traverse_module_state->__pyx_n_s_decode_fd_detailed);
   Py_VISIT(traverse_module_state->__pyx_n_s_decode_file);
   Py_VISIT(traverse_module_state->__pyx_n_s_decode_into);
   Py_VISIT(traverse_module_state->__pyx_n_s_decode_len);
   Py_VISIT(traverse_module_state->__pyx_n_s_decode_local_file);
+  Py_VISIT(traverse_module_state->__pyx_n_s_decode_local_file_detailed);
   Py_VISIT(traverse_module_state->__pyx_n_s_dest);
   Py_VISIT(traverse_module_state->__pyx_n_s_dict);
   Py_VISIT(traverse_module_state->__pyx_kp_u_disable);
   Py_VISIT(traverse_module_state->__pyx_n_s_dlen);
   Py_VISIT(traverse_module_state->__pyx_n_s_dtype_is_object);
   Py_VISIT(traverse_module_state->__pyx_kp_u_enable);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode_2);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode_fd);
+  Py_VISIT(traverse_module_state->__pyx_n_s_encode_fd_detailed);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode_file);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode_into);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode_len);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode_local_file);
+  Py_VISIT(traverse_module_state->__pyx_n_s_encode_local_file_detailed);
   Py_VISIT(traverse_module_state->__pyx_n_s_enumerate);
   Py_VISIT(traverse_module_state->__pyx_n_s_error);
   Py_VISIT(traverse_module_state->__pyx_n_s_first_check);
+  Py_VISIT(traverse_module_state->__pyx_n_s_flag);
   Py_VISIT(traverse_module_state->__pyx_n_s_flags);
   Py_VISIT(traverse_module_state->__pyx_n_s_format);
   Py_VISIT(traverse_module_state->__pyx_n_s_fortran);
   Py_VISIT(traverse_module_state->__pyx_n_u_fortran);
   Py_VISIT(traverse_module_state->__pyx_kp_u_gc);
   Py_VISIT(traverse_module_state->__pyx_n_s_getstate);
   Py_VISIT(traverse_module_state->__pyx_kp_u_got);
@@ -3837,28 +3937,33 @@
   Py_VISIT(traverse_module_state->__pyx_tuple__25);
   Py_VISIT(traverse_module_state->__pyx_tuple__27);
   Py_VISIT(traverse_module_state->__pyx_tuple__29);
   Py_VISIT(traverse_module_state->__pyx_tuple__32);
   Py_VISIT(traverse_module_state->__pyx_tuple__35);
   Py_VISIT(traverse_module_state->__pyx_tuple__37);
   Py_VISIT(traverse_module_state->__pyx_tuple__40);
+  Py_VISIT(traverse_module_state->__pyx_tuple__45);
   Py_VISIT(traverse_module_state->__pyx_codeobj__24);
   Py_VISIT(traverse_module_state->__pyx_codeobj__26);
   Py_VISIT(traverse_module_state->__pyx_codeobj__28);
   Py_VISIT(traverse_module_state->__pyx_codeobj__30);
   Py_VISIT(traverse_module_state->__pyx_codeobj__31);
   Py_VISIT(traverse_module_state->__pyx_codeobj__33);
   Py_VISIT(traverse_module_state->__pyx_codeobj__34);
   Py_VISIT(traverse_module_state->__pyx_codeobj__36);
   Py_VISIT(traverse_module_state->__pyx_codeobj__38);
   Py_VISIT(traverse_module_state->__pyx_codeobj__39);
   Py_VISIT(traverse_module_state->__pyx_codeobj__41);
   Py_VISIT(traverse_module_state->__pyx_codeobj__42);
   Py_VISIT(traverse_module_state->__pyx_codeobj__43);
   Py_VISIT(traverse_module_state->__pyx_codeobj__44);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__46);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__47);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__48);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__49);
   return 0;
 }
 #endif
 /* #### Code section: module_state_defines ### */
 #define __pyx_d __pyx_mstate_global->__pyx_d
 #define __pyx_b __pyx_mstate_global->__pyx_b
 #define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
@@ -3926,50 +4031,57 @@
 #define __pyx_kp_u_Cannot_index_with_type __pyx_mstate_global->__pyx_kp_u_Cannot_index_with_type
 #define __pyx_kp_s_Cannot_transpose_memoryview_with __pyx_mstate_global->__pyx_kp_s_Cannot_transpose_memoryview_with
 #define __pyx_n_s_DECBUFSZ __pyx_mstate_global->__pyx_n_s_DECBUFSZ
 #define __pyx_kp_s_Dimension_d_is_not_direct __pyx_mstate_global->__pyx_kp_s_Dimension_d_is_not_direct
 #define __pyx_n_s_ENCBUFSZ __pyx_mstate_global->__pyx_n_s_ENCBUFSZ
 #define __pyx_n_s_Ellipsis __pyx_mstate_global->__pyx_n_s_Ellipsis
 #define __pyx_kp_s_Empty_shape_tuple_for_cython_arr __pyx_mstate_global->__pyx_kp_s_Empty_shape_tuple_for_cython_arr
+#define __pyx_n_s_FLAG_NOHEADER __pyx_mstate_global->__pyx_n_s_FLAG_NOHEADER
+#define __pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN __pyx_mstate_global->__pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN
 #define __pyx_kp_s_Incompatible_checksums_0x_x_vs_0 __pyx_mstate_global->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0
 #define __pyx_n_s_IndexError __pyx_mstate_global->__pyx_n_s_IndexError
 #define __pyx_kp_s_Index_out_of_bounds_axis_d __pyx_mstate_global->__pyx_kp_s_Index_out_of_bounds_axis_d
 #define __pyx_kp_s_Indirect_dimensions_not_supporte __pyx_mstate_global->__pyx_kp_s_Indirect_dimensions_not_supporte
 #define __pyx_kp_u_Invalid_mode_expected_c_or_fortr __pyx_mstate_global->__pyx_kp_u_Invalid_mode_expected_c_or_fortr
 #define __pyx_kp_u_Invalid_shape_in_axis __pyx_mstate_global->__pyx_kp_u_Invalid_shape_in_axis
 #define __pyx_n_s_MemoryError __pyx_mstate_global->__pyx_n_s_MemoryError
 #define __pyx_kp_s_MemoryView_of_r_at_0x_x __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_at_0x_x
 #define __pyx_kp_s_MemoryView_of_r_object __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_object
 #define __pyx_n_b_O __pyx_mstate_global->__pyx_n_b_O
 #define __pyx_kp_u_Out_of_bounds_on_buffer_access_a __pyx_mstate_global->__pyx_kp_u_Out_of_bounds_on_buffer_access_a
 #define __pyx_n_s_Path __pyx_mstate_global->__pyx_n_s_Path
 #define __pyx_n_s_PickleError __pyx_mstate_global->__pyx_n_s_PickleError
+#define __pyx_n_s_SIMPLE_SUM_INIT_VALUE __pyx_mstate_global->__pyx_n_s_SIMPLE_SUM_INIT_VALUE
 #define __pyx_n_s_Sequence __pyx_mstate_global->__pyx_n_s_Sequence
 #define __pyx_kp_s_Step_may_not_be_zero_axis_d __pyx_mstate_global->__pyx_kp_s_Step_may_not_be_zero_axis_d
 #define __pyx_n_s_TypeError __pyx_mstate_global->__pyx_n_s_TypeError
 #define __pyx_kp_s_Unable_to_convert_item_to_object __pyx_mstate_global->__pyx_kp_s_Unable_to_convert_item_to_object
 #define __pyx_n_s_ValueError __pyx_mstate_global->__pyx_n_s_ValueError
 #define __pyx_n_s_View_MemoryView __pyx_mstate_global->__pyx_n_s_View_MemoryView
 #define __pyx_kp_b__10 __pyx_mstate_global->__pyx_kp_b__10
 #define __pyx_kp_b__11 __pyx_mstate_global->__pyx_kp_b__11
 #define __pyx_kp_u__2 __pyx_mstate_global->__pyx_kp_u__2
 #define __pyx_n_s__3 __pyx_mstate_global->__pyx_n_s__3
-#define __pyx_n_s__45 __pyx_mstate_global->__pyx_n_s__45
+#define __pyx_n_s__50 __pyx_mstate_global->__pyx_n_s__50
 #define __pyx_kp_u__6 __pyx_mstate_global->__pyx_kp_u__6
 #define __pyx_kp_u__7 __pyx_mstate_global->__pyx_kp_u__7
 #define __pyx_n_s_abc __pyx_mstate_global->__pyx_n_s_abc
 #define __pyx_n_s_allocate_buffer __pyx_mstate_global->__pyx_n_s_allocate_buffer
 #define __pyx_kp_u_and __pyx_mstate_global->__pyx_kp_u_and
 #define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
 #define __pyx_n_s_base __pyx_mstate_global->__pyx_n_s_base
 #define __pyx_n_u_base16384_err_fopen_input_file __pyx_mstate_global->__pyx_n_u_base16384_err_fopen_input_file
 #define __pyx_n_u_base16384_err_fopen_output_file __pyx_mstate_global->__pyx_n_u_base16384_err_fopen_output_file
 #define __pyx_n_u_base16384_err_get_file_size __pyx_mstate_global->__pyx_n_u_base16384_err_get_file_size
+#define __pyx_n_u_base16384_err_invalid_commandlin __pyx_mstate_global->__pyx_n_u_base16384_err_invalid_commandlin
+#define __pyx_n_u_base16384_err_invalid_decoding_c __pyx_mstate_global->__pyx_n_u_base16384_err_invalid_decoding_c
+#define __pyx_n_u_base16384_err_invalid_file_name __pyx_mstate_global->__pyx_n_u_base16384_err_invalid_file_name
 #define __pyx_n_u_base16384_err_map_input_file __pyx_mstate_global->__pyx_n_u_base16384_err_map_input_file
 #define __pyx_n_u_base16384_err_open_input_file __pyx_mstate_global->__pyx_n_u_base16384_err_open_input_file
+#define __pyx_n_u_base16384_err_read_file __pyx_mstate_global->__pyx_n_u_base16384_err_read_file
 #define __pyx_n_u_base16384_err_write_file __pyx_mstate_global->__pyx_n_u_base16384_err_write_file
 #define __pyx_n_s_buf_rate __pyx_mstate_global->__pyx_n_s_buf_rate
 #define __pyx_n_s_c __pyx_mstate_global->__pyx_n_s_c
 #define __pyx_n_u_c __pyx_mstate_global->__pyx_n_u_c
 #define __pyx_n_s_chunk __pyx_mstate_global->__pyx_n_s_chunk
 #define __pyx_n_s_chunk_ptr __pyx_mstate_global->__pyx_n_s_chunk_ptr
 #define __pyx_n_s_class __pyx_mstate_global->__pyx_n_s_class
@@ -3980,34 +4092,39 @@
 #define __pyx_kp_s_contiguous_and_direct __pyx_mstate_global->__pyx_kp_s_contiguous_and_direct
 #define __pyx_kp_s_contiguous_and_indirect __pyx_mstate_global->__pyx_kp_s_contiguous_and_indirect
 #define __pyx_n_s_count __pyx_mstate_global->__pyx_n_s_count
 #define __pyx_n_s_current_buf_len __pyx_mstate_global->__pyx_n_s_current_buf_len
 #define __pyx_n_s_data __pyx_mstate_global->__pyx_n_s_data
 #define __pyx_n_s_decode __pyx_mstate_global->__pyx_n_s_decode
 #define __pyx_n_s_decode_fd __pyx_mstate_global->__pyx_n_s_decode_fd
+#define __pyx_n_s_decode_fd_detailed __pyx_mstate_global->__pyx_n_s_decode_fd_detailed
 #define __pyx_n_s_decode_file __pyx_mstate_global->__pyx_n_s_decode_file
 #define __pyx_n_s_decode_into __pyx_mstate_global->__pyx_n_s_decode_into
 #define __pyx_n_s_decode_len __pyx_mstate_global->__pyx_n_s_decode_len
 #define __pyx_n_s_decode_local_file __pyx_mstate_global->__pyx_n_s_decode_local_file
+#define __pyx_n_s_decode_local_file_detailed __pyx_mstate_global->__pyx_n_s_decode_local_file_detailed
 #define __pyx_n_s_dest __pyx_mstate_global->__pyx_n_s_dest
 #define __pyx_n_s_dict __pyx_mstate_global->__pyx_n_s_dict
 #define __pyx_kp_u_disable __pyx_mstate_global->__pyx_kp_u_disable
 #define __pyx_n_s_dlen __pyx_mstate_global->__pyx_n_s_dlen
 #define __pyx_n_s_dtype_is_object __pyx_mstate_global->__pyx_n_s_dtype_is_object
 #define __pyx_kp_u_enable __pyx_mstate_global->__pyx_kp_u_enable
 #define __pyx_n_s_encode __pyx_mstate_global->__pyx_n_s_encode
 #define __pyx_n_s_encode_2 __pyx_mstate_global->__pyx_n_s_encode_2
 #define __pyx_n_s_encode_fd __pyx_mstate_global->__pyx_n_s_encode_fd
+#define __pyx_n_s_encode_fd_detailed __pyx_mstate_global->__pyx_n_s_encode_fd_detailed
 #define __pyx_n_s_encode_file __pyx_mstate_global->__pyx_n_s_encode_file
 #define __pyx_n_s_encode_into __pyx_mstate_global->__pyx_n_s_encode_into
 #define __pyx_n_s_encode_len __pyx_mstate_global->__pyx_n_s_encode_len
 #define __pyx_n_s_encode_local_file __pyx_mstate_global->__pyx_n_s_encode_local_file
+#define __pyx_n_s_encode_local_file_detailed __pyx_mstate_global->__pyx_n_s_encode_local_file_detailed
 #define __pyx_n_s_enumerate __pyx_mstate_global->__pyx_n_s_enumerate
 #define __pyx_n_s_error __pyx_mstate_global->__pyx_n_s_error
 #define __pyx_n_s_first_check __pyx_mstate_global->__pyx_n_s_first_check
+#define __pyx_n_s_flag __pyx_mstate_global->__pyx_n_s_flag
 #define __pyx_n_s_flags __pyx_mstate_global->__pyx_n_s_flags
 #define __pyx_n_s_format __pyx_mstate_global->__pyx_n_s_format
 #define __pyx_n_s_fortran __pyx_mstate_global->__pyx_n_s_fortran
 #define __pyx_n_u_fortran __pyx_mstate_global->__pyx_n_u_fortran
 #define __pyx_kp_u_gc __pyx_mstate_global->__pyx_kp_u_gc
 #define __pyx_n_s_getstate __pyx_mstate_global->__pyx_n_s_getstate
 #define __pyx_kp_u_got __pyx_mstate_global->__pyx_kp_u_got
@@ -4111,28 +4228,33 @@
 #define __pyx_tuple__25 __pyx_mstate_global->__pyx_tuple__25
 #define __pyx_tuple__27 __pyx_mstate_global->__pyx_tuple__27
 #define __pyx_tuple__29 __pyx_mstate_global->__pyx_tuple__29
 #define __pyx_tuple__32 __pyx_mstate_global->__pyx_tuple__32
 #define __pyx_tuple__35 __pyx_mstate_global->__pyx_tuple__35
 #define __pyx_tuple__37 __pyx_mstate_global->__pyx_tuple__37
 #define __pyx_tuple__40 __pyx_mstate_global->__pyx_tuple__40
+#define __pyx_tuple__45 __pyx_mstate_global->__pyx_tuple__45
 #define __pyx_codeobj__24 __pyx_mstate_global->__pyx_codeobj__24
 #define __pyx_codeobj__26 __pyx_mstate_global->__pyx_codeobj__26
 #define __pyx_codeobj__28 __pyx_mstate_global->__pyx_codeobj__28
 #define __pyx_codeobj__30 __pyx_mstate_global->__pyx_codeobj__30
 #define __pyx_codeobj__31 __pyx_mstate_global->__pyx_codeobj__31
 #define __pyx_codeobj__33 __pyx_mstate_global->__pyx_codeobj__33
 #define __pyx_codeobj__34 __pyx_mstate_global->__pyx_codeobj__34
 #define __pyx_codeobj__36 __pyx_mstate_global->__pyx_codeobj__36
 #define __pyx_codeobj__38 __pyx_mstate_global->__pyx_codeobj__38
 #define __pyx_codeobj__39 __pyx_mstate_global->__pyx_codeobj__39
 #define __pyx_codeobj__41 __pyx_mstate_global->__pyx_codeobj__41
 #define __pyx_codeobj__42 __pyx_mstate_global->__pyx_codeobj__42
 #define __pyx_codeobj__43 __pyx_mstate_global->__pyx_codeobj__43
 #define __pyx_codeobj__44 __pyx_mstate_global->__pyx_codeobj__44
+#define __pyx_codeobj__46 __pyx_mstate_global->__pyx_codeobj__46
+#define __pyx_codeobj__47 __pyx_mstate_global->__pyx_codeobj__47
+#define __pyx_codeobj__48 __pyx_mstate_global->__pyx_codeobj__48
+#define __pyx_codeobj__49 __pyx_mstate_global->__pyx_codeobj__49
 /* #### Code section: module_code ### */
 
 /* "View.MemoryView":131
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
@@ -17753,16 +17875,16 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":22
- * DECBUFSZ = BASE16384_DECBUFSZ
+/* "pybase16384/backends/cython/_core.pyx":30
+ * SIMPLE_SUM_INIT_VALUE = BASE16384_SIMPLE_SUM_INIT_VALUE
  * 
  * cdef inline bytes ensure_bytes(object inp):             # <<<<<<<<<<<<<<
  *     if isinstance(inp, unicode):
  *         return inp.encode()
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(PyObject *__pyx_v_inp) {
@@ -17774,33 +17896,33 @@
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("ensure_bytes", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":23
+  /* "pybase16384/backends/cython/_core.pyx":31
  * 
  * cdef inline bytes ensure_bytes(object inp):
  *     if isinstance(inp, unicode):             # <<<<<<<<<<<<<<
  *         return inp.encode()
  *     elif isinstance(inp, bytes):
  */
   __pyx_t_1 = PyUnicode_Check(__pyx_v_inp); 
   if (__pyx_t_1) {
 
-    /* "pybase16384/backends/cython/_core.pyx":24
+    /* "pybase16384/backends/cython/_core.pyx":32
  * cdef inline bytes ensure_bytes(object inp):
  *     if isinstance(inp, unicode):
  *         return inp.encode()             # <<<<<<<<<<<<<<
  *     elif isinstance(inp, bytes):
  *         return inp
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_inp, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 24, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_inp, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 32, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_4 = NULL;
     __pyx_t_5 = 0;
     #if CYTHON_UNPACK_METHODS
     if (likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
@@ -17812,88 +17934,88 @@
       }
     }
     #endif
     {
       PyObject *__pyx_callargs[2] = {__pyx_t_4, NULL};
       __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 0+__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 24, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 32, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
-    if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_2))) __PYX_ERR(0, 24, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_2))) __PYX_ERR(0, 32, __pyx_L1_error)
     __pyx_r = ((PyObject*)__pyx_t_2);
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":23
+    /* "pybase16384/backends/cython/_core.pyx":31
  * 
  * cdef inline bytes ensure_bytes(object inp):
  *     if isinstance(inp, unicode):             # <<<<<<<<<<<<<<
  *         return inp.encode()
  *     elif isinstance(inp, bytes):
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":25
+  /* "pybase16384/backends/cython/_core.pyx":33
  *     if isinstance(inp, unicode):
  *         return inp.encode()
  *     elif isinstance(inp, bytes):             # <<<<<<<<<<<<<<
  *         return inp
  *     elif isinstance(inp, Path):
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_inp); 
   if (__pyx_t_1) {
 
-    /* "pybase16384/backends/cython/_core.pyx":26
+    /* "pybase16384/backends/cython/_core.pyx":34
  *         return inp.encode()
  *     elif isinstance(inp, bytes):
  *         return inp             # <<<<<<<<<<<<<<
  *     elif isinstance(inp, Path):
  *         return str(inp).encode()
  */
     __Pyx_XDECREF(__pyx_r);
-    if (!(likely(PyBytes_CheckExact(__pyx_v_inp))||((__pyx_v_inp) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_v_inp))) __PYX_ERR(0, 26, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_v_inp))||((__pyx_v_inp) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_v_inp))) __PYX_ERR(0, 34, __pyx_L1_error)
     __Pyx_INCREF(__pyx_v_inp);
     __pyx_r = ((PyObject*)__pyx_v_inp);
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":25
+    /* "pybase16384/backends/cython/_core.pyx":33
  *     if isinstance(inp, unicode):
  *         return inp.encode()
  *     elif isinstance(inp, bytes):             # <<<<<<<<<<<<<<
  *         return inp
  *     elif isinstance(inp, Path):
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":27
+  /* "pybase16384/backends/cython/_core.pyx":35
  *     elif isinstance(inp, bytes):
  *         return inp
  *     elif isinstance(inp, Path):             # <<<<<<<<<<<<<<
  *         return str(inp).encode()
  *     else:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 27, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Path); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 35, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = PyObject_IsInstance(__pyx_v_inp, __pyx_t_2); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 27, __pyx_L1_error)
+  __pyx_t_1 = PyObject_IsInstance(__pyx_v_inp, __pyx_t_2); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 35, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   if (__pyx_t_1) {
 
-    /* "pybase16384/backends/cython/_core.pyx":28
+    /* "pybase16384/backends/cython/_core.pyx":36
  *         return inp
  *     elif isinstance(inp, Path):
  *         return str(inp).encode()             # <<<<<<<<<<<<<<
  *     else:
  *         return bytes(inp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyObject_Str(__pyx_v_inp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 28, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Str(__pyx_v_inp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 36, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 28, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 36, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_3 = NULL;
     __pyx_t_5 = 0;
     #if CYTHON_UNPACK_METHODS
     if (likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
@@ -17906,50 +18028,50 @@
       }
     }
     #endif
     {
       PyObject *__pyx_callargs[2] = {__pyx_t_3, NULL};
       __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_5, 0+__pyx_t_5);
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 36, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     }
-    if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_2))) __PYX_ERR(0, 28, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None) || __Pyx_RaiseUnexpectedTypeError("bytes", __pyx_t_2))) __PYX_ERR(0, 36, __pyx_L1_error)
     __pyx_r = ((PyObject*)__pyx_t_2);
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":27
+    /* "pybase16384/backends/cython/_core.pyx":35
  *     elif isinstance(inp, bytes):
  *         return inp
  *     elif isinstance(inp, Path):             # <<<<<<<<<<<<<<
  *         return str(inp).encode()
  *     else:
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":30
+  /* "pybase16384/backends/cython/_core.pyx":38
  *         return str(inp).encode()
  *     else:
  *         return bytes(inp)             # <<<<<<<<<<<<<<
  * 
  * cdef inline uint8_t PyFile_Check(object file):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_inp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_inp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 38, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = ((PyObject*)__pyx_t_2);
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":22
- * DECBUFSZ = BASE16384_DECBUFSZ
+  /* "pybase16384/backends/cython/_core.pyx":30
+ * SIMPLE_SUM_INIT_VALUE = BASE16384_SIMPLE_SUM_INIT_VALUE
  * 
  * cdef inline bytes ensure_bytes(object inp):             # <<<<<<<<<<<<<<
  *     if isinstance(inp, unicode):
  *         return inp.encode()
  */
 
   /* function exit code */
@@ -17961,28 +18083,28 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":32
+/* "pybase16384/backends/cython/_core.pyx":40
  *         return bytes(inp)
  * 
  * cdef inline uint8_t PyFile_Check(object file):             # <<<<<<<<<<<<<<
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,
  *                                                                                                                  "seek"):
  */
 
 static CYTHON_INLINE uint8_t __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(PyObject *__pyx_v_file) {
   uint8_t __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
 
-  /* "pybase16384/backends/cython/_core.pyx":33
+  /* "pybase16384/backends/cython/_core.pyx":41
  * 
  * cdef inline uint8_t PyFile_Check(object file):
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,             # <<<<<<<<<<<<<<
  *                                                                                                                  "seek"):
  *         return 1
  */
   __pyx_t_2 = PyObject_HasAttrString(__pyx_v_file, ((char const *)"read"));
@@ -17998,57 +18120,57 @@
     goto __pyx_L4_bool_binop_done;
   }
   __pyx_t_2 = PyObject_HasAttrString(__pyx_v_file, ((char const *)"seek"));
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "pybase16384/backends/cython/_core.pyx":35
+    /* "pybase16384/backends/cython/_core.pyx":43
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,
  *                                                                                                                  "seek"):
  *         return 1             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
     __pyx_r = 1;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":33
+    /* "pybase16384/backends/cython/_core.pyx":41
  * 
  * cdef inline uint8_t PyFile_Check(object file):
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,             # <<<<<<<<<<<<<<
  *                                                                                                                  "seek"):
  *         return 1
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":36
+  /* "pybase16384/backends/cython/_core.pyx":44
  *                                                                                                                  "seek"):
  *         return 1
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * cpdef inline int encode_len(int dlen) nogil:
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "pybase16384/backends/cython/_core.pyx":32
+  /* "pybase16384/backends/cython/_core.pyx":40
  *         return bytes(inp)
  * 
  * cdef inline uint8_t PyFile_Check(object file):             # <<<<<<<<<<<<<<
  *     if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,
  *                                                                                                                  "seek"):
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":38
+/* "pybase16384/backends/cython/_core.pyx":46
  *     return 0
  * 
  * cpdef inline int encode_len(int dlen) nogil:             # <<<<<<<<<<<<<<
  *     return b14_encode_len(dlen)
  * 
  */
 
@@ -18058,25 +18180,25 @@
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
 static CYTHON_INLINE int __pyx_f_11pybase16384_8backends_6cython_5_core_encode_len(int __pyx_v_dlen, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_r;
 
-  /* "pybase16384/backends/cython/_core.pyx":39
+  /* "pybase16384/backends/cython/_core.pyx":47
  * 
  * cpdef inline int encode_len(int dlen) nogil:
  *     return b14_encode_len(dlen)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline int decode_len(int dlen, int offset) nogil:
  */
   __pyx_r = base16384_encode_len(__pyx_v_dlen);
   goto __pyx_L0;
 
-  /* "pybase16384/backends/cython/_core.pyx":38
+  /* "pybase16384/backends/cython/_core.pyx":46
  *     return 0
  * 
  * cpdef inline int encode_len(int dlen) nogil:             # <<<<<<<<<<<<<<
  *     return b14_encode_len(dlen)
  * 
  */
 
@@ -18135,31 +18257,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dlen)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 46, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_len") < 0)) __PYX_ERR(0, 38, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_len") < 0)) __PYX_ERR(0, 46, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_dlen = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_dlen == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L3_error)
+    __pyx_v_dlen = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_dlen == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 46, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encode_len", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 38, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encode_len", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 46, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -18188,16 +18310,16 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encode_len", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_len(__pyx_v_dlen, 0); if (unlikely(__pyx_t_1 == ((int)-1) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_len(__pyx_v_dlen, 0); if (unlikely(__pyx_t_1 == ((int)-1) && PyErr_Occurred())) __PYX_ERR(0, 46, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -18206,15 +18328,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":41
+/* "pybase16384/backends/cython/_core.pyx":49
  *     return b14_encode_len(dlen)
  * 
  * cpdef inline int decode_len(int dlen, int offset) nogil:             # <<<<<<<<<<<<<<
  *     return b14_decode_len(dlen, offset)
  * 
  */
 
@@ -18224,25 +18346,25 @@
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
 static CYTHON_INLINE int __pyx_f_11pybase16384_8backends_6cython_5_core_decode_len(int __pyx_v_dlen, int __pyx_v_offset, CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_r;
 
-  /* "pybase16384/backends/cython/_core.pyx":42
+  /* "pybase16384/backends/cython/_core.pyx":50
  * 
  * cpdef inline int decode_len(int dlen, int offset) nogil:
  *     return b14_decode_len(dlen, offset)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline bytes _encode(const uint8_t[::1] data):
  */
   __pyx_r = base16384_decode_len(__pyx_v_dlen, __pyx_v_offset);
   goto __pyx_L0;
 
-  /* "pybase16384/backends/cython/_core.pyx":41
+  /* "pybase16384/backends/cython/_core.pyx":49
  *     return b14_encode_len(dlen)
  * 
  * cpdef inline int decode_len(int dlen, int offset) nogil:             # <<<<<<<<<<<<<<
  *     return b14_decode_len(dlen, offset)
  * 
  */
 
@@ -18304,43 +18426,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dlen)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 41, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 49, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_offset)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 41, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 49, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("decode_len", 1, 2, 2, 1); __PYX_ERR(0, 41, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decode_len", 1, 2, 2, 1); __PYX_ERR(0, 49, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_len") < 0)) __PYX_ERR(0, 41, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_len") < 0)) __PYX_ERR(0, 49, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_dlen = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_dlen == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 41, __pyx_L3_error)
-    __pyx_v_offset = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_offset == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 41, __pyx_L3_error)
+    __pyx_v_dlen = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_dlen == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 49, __pyx_L3_error)
+    __pyx_v_offset = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_offset == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 49, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decode_len", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 41, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decode_len", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 49, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -18369,16 +18491,16 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decode_len", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_len(__pyx_v_dlen, __pyx_v_offset, 0); if (unlikely(__pyx_t_1 == ((int)-1) && PyErr_Occurred())) __PYX_ERR(0, 41, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_len(__pyx_v_dlen, __pyx_v_offset, 0); if (unlikely(__pyx_t_1 == ((int)-1) && PyErr_Occurred())) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -18387,15 +18509,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":44
+/* "pybase16384/backends/cython/_core.pyx":52
  *     return b14_decode_len(dlen, offset)
  * 
  * cpdef inline bytes _encode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  */
 
@@ -18427,70 +18549,70 @@
   PyObject *__pyx_t_12 = NULL;
   PyObject *__pyx_t_13 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_encode", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":45
+  /* "pybase16384/backends/cython/_core.pyx":53
  * 
  * cpdef inline bytes _encode(const uint8_t[::1] data):
  *     cdef size_t length = data.shape[0]             # <<<<<<<<<<<<<<
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  *     cdef char *output_buf = <char*>PyMem_Malloc(output_size)
  */
   __pyx_v_length = (__pyx_v_data.shape[0]);
 
-  /* "pybase16384/backends/cython/_core.pyx":46
+  /* "pybase16384/backends/cython/_core.pyx":54
  * cpdef inline bytes _encode(const uint8_t[::1] data):
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16             # <<<<<<<<<<<<<<
  *     cdef char *output_buf = <char*>PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  */
   __pyx_v_output_size = (((size_t)base16384_encode_len(((int)__pyx_v_length))) + 16);
 
-  /* "pybase16384/backends/cython/_core.pyx":47
+  /* "pybase16384/backends/cython/_core.pyx":55
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  *     cdef char *output_buf = <char*>PyMem_Malloc(output_size)             # <<<<<<<<<<<<<<
  *     if output_buf == NULL:
  *         raise MemoryError
  */
   __pyx_v_output_buf = ((char *)PyMem_Malloc(__pyx_v_output_size));
 
-  /* "pybase16384/backends/cython/_core.pyx":48
+  /* "pybase16384/backends/cython/_core.pyx":56
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  *     cdef char *output_buf = <char*>PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef int count
  */
   __pyx_t_1 = (__pyx_v_output_buf == NULL);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":49
+    /* "pybase16384/backends/cython/_core.pyx":57
  *     cdef char *output_buf = <char*>PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef int count
  *     with nogil:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 49, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 57, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":48
+    /* "pybase16384/backends/cython/_core.pyx":56
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  *     cdef char *output_buf = <char*>PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef int count
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":51
+  /* "pybase16384/backends/cython/_core.pyx":59
  *         raise MemoryError
  *     cdef int count
  *     with nogil:             # <<<<<<<<<<<<<<
  *         count = b14_encode(<const char*> &data[0],
  *                                         <int>length,
  */
   {
@@ -18498,34 +18620,34 @@
       PyThreadState *_save;
       _save = NULL;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pybase16384/backends/cython/_core.pyx":52
+        /* "pybase16384/backends/cython/_core.pyx":60
  *     cdef int count
  *     with nogil:
  *         count = b14_encode(<const char*> &data[0],             # <<<<<<<<<<<<<<
  *                                         <int>length,
  *                                         output_buf) # encode
  */
         __pyx_t_2 = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":54
+        /* "pybase16384/backends/cython/_core.pyx":62
  *         count = b14_encode(<const char*> &data[0],
  *                                         <int>length,
  *                                         output_buf) # encode             # <<<<<<<<<<<<<<
  *     try:
  *         return <bytes>output_buf[:count]
  */
         __pyx_v_count = base16384_encode(((char const *)(&(*((uint8_t const  *) ( /* dim=0 */ ((char *) (((uint8_t const  *) __pyx_v_data.data) + __pyx_t_2)) ))))), ((int)__pyx_v_length), __pyx_v_output_buf);
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":51
+      /* "pybase16384/backends/cython/_core.pyx":59
  *         raise MemoryError
  *     cdef int count
  *     with nogil:             # <<<<<<<<<<<<<<
  *         count = b14_encode(<const char*> &data[0],
  *                                         <int>length,
  */
       /*finally:*/ {
@@ -18536,40 +18658,40 @@
           #endif
           goto __pyx_L6;
         }
         __pyx_L6:;
       }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":55
+  /* "pybase16384/backends/cython/_core.pyx":63
  *                                         <int>length,
  *                                         output_buf) # encode
  *     try:             # <<<<<<<<<<<<<<
  *         return <bytes>output_buf[:count]
  *     finally:
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":56
+    /* "pybase16384/backends/cython/_core.pyx":64
  *                                         output_buf) # encode
  *     try:
  *         return <bytes>output_buf[:count]             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(output_buf)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 56, __pyx_L8_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 64, __pyx_L8_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(((PyObject*)__pyx_t_3));
     __pyx_r = ((PyObject*)__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L7_return;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":58
+  /* "pybase16384/backends/cython/_core.pyx":66
  *         return <bytes>output_buf[:count]
  *     finally:
  *         PyMem_Free(output_buf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline bytes _decode(const uint8_t[::1] data):
  */
   /*finally:*/ {
@@ -18611,15 +18733,15 @@
       PyMem_Free(__pyx_v_output_buf);
       __pyx_r = __pyx_t_13;
       __pyx_t_13 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":44
+  /* "pybase16384/backends/cython/_core.pyx":52
  *     return b14_decode_len(dlen, offset)
  * 
  * cpdef inline bytes _encode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  */
 
@@ -18684,31 +18806,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_data)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 44, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 52, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_encode") < 0)) __PYX_ERR(0, 44, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_encode") < 0)) __PYX_ERR(0, 52, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 44, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 52, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_encode", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 44, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_encode", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 52, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -18738,16 +18860,16 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_encode", 1);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 44, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__encode(__pyx_v_data, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 52, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__encode(__pyx_v_data, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 52, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -18756,15 +18878,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":60
+/* "pybase16384/backends/cython/_core.pyx":68
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bytes _decode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  */
 
@@ -18796,70 +18918,70 @@
   PyObject *__pyx_t_12 = NULL;
   PyObject *__pyx_t_13 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decode", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":61
+  /* "pybase16384/backends/cython/_core.pyx":69
  * 
  * cpdef inline bytes _decode(const uint8_t[::1] data):
  *     cdef size_t length = data.shape[0]             # <<<<<<<<<<<<<<
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  */
   __pyx_v_length = (__pyx_v_data.shape[0]);
 
-  /* "pybase16384/backends/cython/_core.pyx":62
+  /* "pybase16384/backends/cython/_core.pyx":70
  * cpdef inline bytes _decode(const uint8_t[::1] data):
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16             # <<<<<<<<<<<<<<
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  */
   __pyx_v_output_size = (((size_t)base16384_decode_len(((int)__pyx_v_length), 0)) + 16);
 
-  /* "pybase16384/backends/cython/_core.pyx":63
+  /* "pybase16384/backends/cython/_core.pyx":71
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)             # <<<<<<<<<<<<<<
  *     if output_buf == NULL:
  *         raise MemoryError
  */
   __pyx_v_output_buf = ((char *)PyMem_Malloc(__pyx_v_output_size));
 
-  /* "pybase16384/backends/cython/_core.pyx":64
+  /* "pybase16384/backends/cython/_core.pyx":72
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef int count
  */
   __pyx_t_1 = (__pyx_v_output_buf == NULL);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":65
+    /* "pybase16384/backends/cython/_core.pyx":73
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef int count
  *     with nogil:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 65, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 73, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":64
+    /* "pybase16384/backends/cython/_core.pyx":72
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef int count
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":67
+  /* "pybase16384/backends/cython/_core.pyx":75
  *         raise MemoryError
  *     cdef int count
  *     with nogil:             # <<<<<<<<<<<<<<
  *         count = b14_decode(<const char *> &data[0],
  *                                         <int> length,
  */
   {
@@ -18867,34 +18989,34 @@
       PyThreadState *_save;
       _save = NULL;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pybase16384/backends/cython/_core.pyx":68
+        /* "pybase16384/backends/cython/_core.pyx":76
  *     cdef int count
  *     with nogil:
  *         count = b14_decode(<const char *> &data[0],             # <<<<<<<<<<<<<<
  *                                         <int> length,
  *                                         output_buf)  # decode
  */
         __pyx_t_2 = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":70
+        /* "pybase16384/backends/cython/_core.pyx":78
  *         count = b14_decode(<const char *> &data[0],
  *                                         <int> length,
  *                                         output_buf)  # decode             # <<<<<<<<<<<<<<
  *     try:
  *         return <bytes> output_buf[:count]
  */
         __pyx_v_count = base16384_decode(((char const *)(&(*((uint8_t const  *) ( /* dim=0 */ ((char *) (((uint8_t const  *) __pyx_v_data.data) + __pyx_t_2)) ))))), ((int)__pyx_v_length), __pyx_v_output_buf);
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":67
+      /* "pybase16384/backends/cython/_core.pyx":75
  *         raise MemoryError
  *     cdef int count
  *     with nogil:             # <<<<<<<<<<<<<<
  *         count = b14_decode(<const char *> &data[0],
  *                                         <int> length,
  */
       /*finally:*/ {
@@ -18905,40 +19027,40 @@
           #endif
           goto __pyx_L6;
         }
         __pyx_L6:;
       }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":71
+  /* "pybase16384/backends/cython/_core.pyx":79
  *                                         <int> length,
  *                                         output_buf)  # decode
  *     try:             # <<<<<<<<<<<<<<
  *         return <bytes> output_buf[:count]
  *     finally:
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":72
+    /* "pybase16384/backends/cython/_core.pyx":80
  *                                         output_buf)  # decode
  *     try:
  *         return <bytes> output_buf[:count]             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(output_buf)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 72, __pyx_L8_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 80, __pyx_L8_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(((PyObject*)__pyx_t_3));
     __pyx_r = ((PyObject*)__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L7_return;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":74
+  /* "pybase16384/backends/cython/_core.pyx":82
  *         return <bytes> output_buf[:count]
  *     finally:
  *         PyMem_Free(output_buf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
  */
   /*finally:*/ {
@@ -18980,15 +19102,15 @@
       PyMem_Free(__pyx_v_output_buf);
       __pyx_r = __pyx_t_13;
       __pyx_t_13 = 0;
       goto __pyx_L0;
     }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":60
+  /* "pybase16384/backends/cython/_core.pyx":68
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bytes _decode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  */
 
@@ -19053,31 +19175,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_data)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 60, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 68, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_decode") < 0)) __PYX_ERR(0, 60, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_decode") < 0)) __PYX_ERR(0, 68, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 60, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 68, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decode", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 60, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decode", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 68, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -19107,16 +19229,16 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decode", 1);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 60, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__decode(__pyx_v_data, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 60, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 68, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__decode(__pyx_v_data, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -19125,15 +19247,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":76
+/* "pybase16384/backends/cython/_core.pyx":84
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  */
 
@@ -19155,74 +19277,74 @@
   Py_ssize_t __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_encode_into", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":77
+  /* "pybase16384/backends/cython/_core.pyx":85
  * 
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
  *     cdef size_t input_size = data.shape[0]             # <<<<<<<<<<<<<<
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  *     cdef size_t output_buf_size = dest.shape[0]
  */
   __pyx_v_input_size = (__pyx_v_data.shape[0]);
 
-  /* "pybase16384/backends/cython/_core.pyx":78
+  /* "pybase16384/backends/cython/_core.pyx":86
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)             # <<<<<<<<<<<<<<
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:
  */
   __pyx_v_output_size = ((size_t)base16384_encode_len(((int)__pyx_v_input_size)));
 
-  /* "pybase16384/backends/cython/_core.pyx":79
+  /* "pybase16384/backends/cython/_core.pyx":87
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  *     cdef size_t output_buf_size = dest.shape[0]             # <<<<<<<<<<<<<<
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")
  */
   __pyx_v_output_buf_size = (__pyx_v_dest.shape[0]);
 
-  /* "pybase16384/backends/cython/_core.pyx":80
+  /* "pybase16384/backends/cython/_core.pyx":88
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:             # <<<<<<<<<<<<<<
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  */
   __pyx_t_1 = (__pyx_v_output_buf_size < __pyx_v_output_size);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":81
+    /* "pybase16384/backends/cython/_core.pyx":89
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")             # <<<<<<<<<<<<<<
  *     with nogil:
  *         return b14_encode(<const char *> &data[0],
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 81, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 81, __pyx_L1_error)
+    __PYX_ERR(0, 89, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":80
+    /* "pybase16384/backends/cython/_core.pyx":88
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:             # <<<<<<<<<<<<<<
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":82
+  /* "pybase16384/backends/cython/_core.pyx":90
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:             # <<<<<<<<<<<<<<
  *         return b14_encode(<const char *> &data[0],
  *                                 <int> input_size,
  */
   {
@@ -19230,44 +19352,44 @@
       PyThreadState *_save;
       _save = NULL;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pybase16384/backends/cython/_core.pyx":83
+        /* "pybase16384/backends/cython/_core.pyx":91
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  *         return b14_encode(<const char *> &data[0],             # <<<<<<<<<<<<<<
  *                                 <int> input_size,
  *                                 <char *> &dest[0])
  */
         __pyx_t_3 = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":85
+        /* "pybase16384/backends/cython/_core.pyx":93
  *         return b14_encode(<const char *> &data[0],
  *                                 <int> input_size,
  *                                 <char *> &dest[0])             # <<<<<<<<<<<<<<
  * 
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
  */
         __pyx_t_4 = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":83
+        /* "pybase16384/backends/cython/_core.pyx":91
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  *         return b14_encode(<const char *> &data[0],             # <<<<<<<<<<<<<<
  *                                 <int> input_size,
  *                                 <char *> &dest[0])
  */
         __pyx_r = base16384_encode(((char const *)(&(*((uint8_t const  *) ( /* dim=0 */ ((char *) (((uint8_t const  *) __pyx_v_data.data) + __pyx_t_3)) ))))), ((int)__pyx_v_input_size), ((char *)(&(*((uint8_t *) ( /* dim=0 */ ((char *) (((uint8_t *) __pyx_v_dest.data) + __pyx_t_4)) ))))));
         goto __pyx_L4_return;
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":82
+      /* "pybase16384/backends/cython/_core.pyx":90
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:             # <<<<<<<<<<<<<<
  *         return b14_encode(<const char *> &data[0],
  *                                 <int> input_size,
  */
       /*finally:*/ {
@@ -19277,15 +19399,15 @@
           Py_BLOCK_THREADS
           #endif
           goto __pyx_L0;
         }
       }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":76
+  /* "pybase16384/backends/cython/_core.pyx":84
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  */
 
@@ -19352,43 +19474,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_data)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 76, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 84, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dest)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 76, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 84, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("_encode_into", 1, 2, 2, 1); __PYX_ERR(0, 76, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_encode_into", 1, 2, 2, 1); __PYX_ERR(0, 84, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_encode_into") < 0)) __PYX_ERR(0, 76, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_encode_into") < 0)) __PYX_ERR(0, 84, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 76, __pyx_L3_error)
-    __pyx_v_dest = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_dest.memview)) __PYX_ERR(0, 76, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 84, __pyx_L3_error)
+    __pyx_v_dest = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_dest.memview)) __PYX_ERR(0, 84, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_encode_into", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 76, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_encode_into", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 84, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -19421,18 +19543,18 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_encode_into", 1);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 76, __pyx_L1_error) }
-  if (unlikely(!__pyx_v_dest.memview)) { __Pyx_RaiseUnboundLocalError("dest"); __PYX_ERR(0, 76, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__encode_into(__pyx_v_data, __pyx_v_dest, 0); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 76, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 76, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 84, __pyx_L1_error) }
+  if (unlikely(!__pyx_v_dest.memview)) { __Pyx_RaiseUnboundLocalError("dest"); __PYX_ERR(0, 84, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__encode_into(__pyx_v_data, __pyx_v_dest, 0); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 84, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 84, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -19441,15 +19563,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":87
+/* "pybase16384/backends/cython/_core.pyx":95
  *                                 <char *> &dest[0])
  * 
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  */
 
@@ -19471,74 +19593,74 @@
   Py_ssize_t __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decode_into", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":88
+  /* "pybase16384/backends/cython/_core.pyx":96
  * 
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
  *     cdef size_t input_size = data.shape[0]             # <<<<<<<<<<<<<<
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  *     cdef size_t output_buf_size = dest.shape[0]
  */
   __pyx_v_input_size = (__pyx_v_data.shape[0]);
 
-  /* "pybase16384/backends/cython/_core.pyx":89
+  /* "pybase16384/backends/cython/_core.pyx":97
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)             # <<<<<<<<<<<<<<
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:
  */
   __pyx_v_output_size = ((size_t)base16384_decode_len(((int)__pyx_v_input_size), 0));
 
-  /* "pybase16384/backends/cython/_core.pyx":90
+  /* "pybase16384/backends/cython/_core.pyx":98
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  *     cdef size_t output_buf_size = dest.shape[0]             # <<<<<<<<<<<<<<
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")
  */
   __pyx_v_output_buf_size = (__pyx_v_dest.shape[0]);
 
-  /* "pybase16384/backends/cython/_core.pyx":91
+  /* "pybase16384/backends/cython/_core.pyx":99
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:             # <<<<<<<<<<<<<<
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  */
   __pyx_t_1 = (__pyx_v_output_buf_size < __pyx_v_output_size);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":92
+    /* "pybase16384/backends/cython/_core.pyx":100
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")             # <<<<<<<<<<<<<<
  *     with nogil:
  *         return b14_decode(<const char *> &data[0],
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 92, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 92, __pyx_L1_error)
+    __PYX_ERR(0, 100, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":91
+    /* "pybase16384/backends/cython/_core.pyx":99
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:             # <<<<<<<<<<<<<<
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":93
+  /* "pybase16384/backends/cython/_core.pyx":101
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:             # <<<<<<<<<<<<<<
  *         return b14_decode(<const char *> &data[0],
  *                                 <int> input_size,
  */
   {
@@ -19546,44 +19668,44 @@
       PyThreadState *_save;
       _save = NULL;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pybase16384/backends/cython/_core.pyx":94
+        /* "pybase16384/backends/cython/_core.pyx":102
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  *         return b14_decode(<const char *> &data[0],             # <<<<<<<<<<<<<<
  *                                 <int> input_size,
  *                                 <char *> &dest[0])
  */
         __pyx_t_3 = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":96
+        /* "pybase16384/backends/cython/_core.pyx":104
  *         return b14_decode(<const char *> &data[0],
  *                                 <int> input_size,
  *                                 <char *> &dest[0])             # <<<<<<<<<<<<<<
  * 
  * 
  */
         __pyx_t_4 = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":94
+        /* "pybase16384/backends/cython/_core.pyx":102
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:
  *         return b14_decode(<const char *> &data[0],             # <<<<<<<<<<<<<<
  *                                 <int> input_size,
  *                                 <char *> &dest[0])
  */
         __pyx_r = base16384_decode(((char const *)(&(*((uint8_t const  *) ( /* dim=0 */ ((char *) (((uint8_t const  *) __pyx_v_data.data) + __pyx_t_3)) ))))), ((int)__pyx_v_input_size), ((char *)(&(*((uint8_t *) ( /* dim=0 */ ((char *) (((uint8_t *) __pyx_v_dest.data) + __pyx_t_4)) ))))));
         goto __pyx_L4_return;
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":93
+      /* "pybase16384/backends/cython/_core.pyx":101
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")
  *     with nogil:             # <<<<<<<<<<<<<<
  *         return b14_decode(<const char *> &data[0],
  *                                 <int> input_size,
  */
       /*finally:*/ {
@@ -19593,15 +19715,15 @@
           Py_BLOCK_THREADS
           #endif
           goto __pyx_L0;
         }
       }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":87
+  /* "pybase16384/backends/cython/_core.pyx":95
  *                                 <char *> &dest[0])
  * 
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  */
 
@@ -19668,43 +19790,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_data)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 87, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 95, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_dest)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 87, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 95, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("_decode_into", 1, 2, 2, 1); __PYX_ERR(0, 87, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_decode_into", 1, 2, 2, 1); __PYX_ERR(0, 95, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_decode_into") < 0)) __PYX_ERR(0, 87, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "_decode_into") < 0)) __PYX_ERR(0, 95, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 87, __pyx_L3_error)
-    __pyx_v_dest = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_dest.memview)) __PYX_ERR(0, 87, __pyx_L3_error)
+    __pyx_v_data = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t__const__(values[0], 0); if (unlikely(!__pyx_v_data.memview)) __PYX_ERR(0, 95, __pyx_L3_error)
+    __pyx_v_dest = __Pyx_PyObject_to_MemoryviewSlice_dc_nn_uint8_t(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_dest.memview)) __PYX_ERR(0, 95, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_decode_into", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 87, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_decode_into", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 95, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -19737,18 +19859,18 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_decode_into", 1);
   __Pyx_XDECREF(__pyx_r);
-  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 87, __pyx_L1_error) }
-  if (unlikely(!__pyx_v_dest.memview)) { __Pyx_RaiseUnboundLocalError("dest"); __PYX_ERR(0, 87, __pyx_L1_error) }
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__decode_into(__pyx_v_data, __pyx_v_dest, 0); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 87, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
+  if (unlikely(!__pyx_v_data.memview)) { __Pyx_RaiseUnboundLocalError("data"); __PYX_ERR(0, 95, __pyx_L1_error) }
+  if (unlikely(!__pyx_v_dest.memview)) { __Pyx_RaiseUnboundLocalError("dest"); __PYX_ERR(0, 95, __pyx_L1_error) }
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core__decode_into(__pyx_v_data, __pyx_v_dest, 0); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 95, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -19757,15 +19879,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":99
+/* "pybase16384/backends/cython/_core.pyx":107
  * 
  * 
  * def encode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        bint write_head = False,
  */
 
@@ -19828,44 +19950,44 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_input)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_output)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("encode_file", 0, 2, 4, 1); __PYX_ERR(0, 99, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("encode_file", 0, 2, 4, 1); __PYX_ERR(0, 107, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_write_head);
           if (value) { values[2] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L3_error)
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
           PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_buf_rate);
           if (value) { values[3] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 99, __pyx_L3_error)
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_file") < 0)) __PYX_ERR(0, 99, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_file") < 0)) __PYX_ERR(0, 107, __pyx_L3_error)
       }
     } else {
       switch (__pyx_nargs) {
         case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
         case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
@@ -19874,35 +19996,35 @@
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_input = values[0];
     __pyx_v_output = values[1];
     if (values[2]) {
-      __pyx_v_write_head = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_write_head == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 101, __pyx_L3_error)
+      __pyx_v_write_head = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_write_head == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 109, __pyx_L3_error)
     } else {
 
-      /* "pybase16384/backends/cython/_core.pyx":101
+      /* "pybase16384/backends/cython/_core.pyx":109
  * def encode_file(object input,
  *                        object output,
  *                        bint write_head = False,             # <<<<<<<<<<<<<<
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):
  */
       __pyx_v_write_head = ((int)((int)0));
     }
     if (values[3]) {
-      __pyx_v_buf_rate = __Pyx_PyInt_As_int32_t(values[3]); if (unlikely((__pyx_v_buf_rate == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 102, __pyx_L3_error)
+      __pyx_v_buf_rate = __Pyx_PyInt_As_int32_t(values[3]); if (unlikely((__pyx_v_buf_rate == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 110, __pyx_L3_error)
     } else {
       __pyx_v_buf_rate = ((int32_t)((int32_t)10));
     }
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encode_file", 0, 2, 4, __pyx_nargs); __PYX_ERR(0, 99, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encode_file", 0, 2, 4, __pyx_nargs); __PYX_ERR(0, 107, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -19910,15 +20032,15 @@
   }
   __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_file", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_11pybase16384_8backends_6cython_5_core_12encode_file(__pyx_self, __pyx_v_input, __pyx_v_output, __pyx_v_write_head, __pyx_v_buf_rate);
 
-  /* "pybase16384/backends/cython/_core.pyx":99
+  /* "pybase16384/backends/cython/_core.pyx":107
  * 
  * 
  * def encode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        bint write_head = False,
  */
 
@@ -19961,137 +20083,137 @@
   PyObject *__pyx_t_15 = NULL;
   PyObject *__pyx_t_16 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encode_file", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":103
+  /* "pybase16384/backends/cython/_core.pyx":111
  *                        bint write_head = False,
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_input); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_input); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 111, __pyx_L1_error)
   __pyx_t_2 = (!(__pyx_t_1 != 0));
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":104
+    /* "pybase16384/backends/cython/_core.pyx":112
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 112, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 104, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 112, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 112, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 104, __pyx_L1_error)
+    __PYX_ERR(0, 112, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":103
+    /* "pybase16384/backends/cython/_core.pyx":111
  *                        bint write_head = False,
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":105
+  /* "pybase16384/backends/cython/_core.pyx":113
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_output); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 105, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_output); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 113, __pyx_L1_error)
   __pyx_t_2 = (!(__pyx_t_1 != 0));
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":106
+    /* "pybase16384/backends/cython/_core.pyx":114
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)             # <<<<<<<<<<<<<<
  *     if buf_rate <= 0:
  *         buf_rate = 1
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 106, __pyx_L1_error)
+    __PYX_ERR(0, 114, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":105
+    /* "pybase16384/backends/cython/_core.pyx":113
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":107
+  /* "pybase16384/backends/cython/_core.pyx":115
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:             # <<<<<<<<<<<<<<
  *         buf_rate = 1
  * 
  */
   __pyx_t_2 = (__pyx_v_buf_rate <= 0);
   if (__pyx_t_2) {
 
-    /* "pybase16384/backends/cython/_core.pyx":108
+    /* "pybase16384/backends/cython/_core.pyx":116
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:
  *         buf_rate = 1             # <<<<<<<<<<<<<<
  * 
  *     if write_head:
  */
     __pyx_v_buf_rate = 1;
 
-    /* "pybase16384/backends/cython/_core.pyx":107
+    /* "pybase16384/backends/cython/_core.pyx":115
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:             # <<<<<<<<<<<<<<
  *         buf_rate = 1
  * 
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":110
+  /* "pybase16384/backends/cython/_core.pyx":118
  *         buf_rate = 1
  * 
  *     if write_head:             # <<<<<<<<<<<<<<
  *         output.write(b'\xfe\xff')
  * 
  */
   if (__pyx_v_write_head) {
 
-    /* "pybase16384/backends/cython/_core.pyx":111
+    /* "pybase16384/backends/cython/_core.pyx":119
  * 
  *     if write_head:
  *         output.write(b'\xfe\xff')             # <<<<<<<<<<<<<<
  * 
  *     cdef int32_t current_buf_len = buf_rate * 7  #
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 111, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 119, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_5 = NULL;
     __pyx_t_6 = 0;
     #if CYTHON_UNPACK_METHODS
     if (likely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
@@ -20103,130 +20225,130 @@
       }
     }
     #endif
     {
       PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_kp_b__10};
       __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 111, __pyx_L1_error)
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 119, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     }
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "pybase16384/backends/cython/_core.pyx":110
+    /* "pybase16384/backends/cython/_core.pyx":118
  *         buf_rate = 1
  * 
  *     if write_head:             # <<<<<<<<<<<<<<
  *         output.write(b'\xfe\xff')
  * 
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":113
+  /* "pybase16384/backends/cython/_core.pyx":121
  *         output.write(b'\xfe\xff')
  * 
  *     cdef int32_t current_buf_len = buf_rate * 7  #             # <<<<<<<<<<<<<<
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # encode_len 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  */
   __pyx_v_current_buf_len = (__pyx_v_buf_rate * 7);
 
-  /* "pybase16384/backends/cython/_core.pyx":114
+  /* "pybase16384/backends/cython/_core.pyx":122
  * 
  *     cdef int32_t current_buf_len = buf_rate * 7  #
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # encode_len 16             # <<<<<<<<<<<<<<
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  */
   __pyx_v_output_size = (((size_t)base16384_encode_len(((int)__pyx_v_current_buf_len))) + 16);
 
-  /* "pybase16384/backends/cython/_core.pyx":115
+  /* "pybase16384/backends/cython/_core.pyx":123
  *     cdef int32_t current_buf_len = buf_rate * 7  #
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # encode_len 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)             # <<<<<<<<<<<<<<
  *     if output_buf == NULL:
  *         raise MemoryError
  */
   __pyx_v_output_buf = ((char *)PyMem_Malloc(__pyx_v_output_size));
 
-  /* "pybase16384/backends/cython/_core.pyx":116
+  /* "pybase16384/backends/cython/_core.pyx":124
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # encode_len 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  * 
  */
   __pyx_t_2 = (__pyx_v_output_buf == NULL);
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":117
+    /* "pybase16384/backends/cython/_core.pyx":125
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  * 
  *     cdef Py_ssize_t size
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 117, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 125, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":116
+    /* "pybase16384/backends/cython/_core.pyx":124
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # encode_len 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  * 
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":120
+  /* "pybase16384/backends/cython/_core.pyx":128
  * 
  *     cdef Py_ssize_t size
  *     cdef uint8_t first_check = 1  #  bytes             # <<<<<<<<<<<<<<
  *     cdef int count = 0
  *     cdef const char *chunk_ptr
  */
   __pyx_v_first_check = 1;
 
-  /* "pybase16384/backends/cython/_core.pyx":121
+  /* "pybase16384/backends/cython/_core.pyx":129
  *     cdef Py_ssize_t size
  *     cdef uint8_t first_check = 1  #  bytes
  *     cdef int count = 0             # <<<<<<<<<<<<<<
  *     cdef const char *chunk_ptr
  *     try:
  */
   __pyx_v_count = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":123
+  /* "pybase16384/backends/cython/_core.pyx":131
  *     cdef int count = 0
  *     cdef const char *chunk_ptr
  *     try:             # <<<<<<<<<<<<<<
  *         while True:
  *             chunk = input.read(current_buf_len)
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":124
+    /* "pybase16384/backends/cython/_core.pyx":132
  *     cdef const char *chunk_ptr
  *     try:
  *         while True:             # <<<<<<<<<<<<<<
  *             chunk = input.read(current_buf_len)
  *             if first_check:
  */
     while (1) {
 
-      /* "pybase16384/backends/cython/_core.pyx":125
+      /* "pybase16384/backends/cython/_core.pyx":133
  *     try:
  *         while True:
  *             chunk = input.read(current_buf_len)             # <<<<<<<<<<<<<<
  *             if first_check:
  *                 first_check = 0
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 125, __pyx_L9_error)
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 133, __pyx_L9_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_current_buf_len); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 125, __pyx_L9_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_current_buf_len); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 133, __pyx_L9_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_7 = NULL;
       __pyx_t_6 = 0;
       #if CYTHON_UNPACK_METHODS
       if (likely(PyMethod_Check(__pyx_t_4))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
         if (likely(__pyx_t_7)) {
@@ -20239,148 +20361,148 @@
       }
       #endif
       {
         PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
         __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 125, __pyx_L9_error)
+        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 133, __pyx_L9_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       }
       __Pyx_XDECREF_SET(__pyx_v_chunk, __pyx_t_3);
       __pyx_t_3 = 0;
 
-      /* "pybase16384/backends/cython/_core.pyx":126
+      /* "pybase16384/backends/cython/_core.pyx":134
  *         while True:
  *             chunk = input.read(current_buf_len)
  *             if first_check:             # <<<<<<<<<<<<<<
  *                 first_check = 0
  *                 if not PyBytes_Check(chunk):
  */
       __pyx_t_2 = (__pyx_v_first_check != 0);
       if (__pyx_t_2) {
 
-        /* "pybase16384/backends/cython/_core.pyx":127
+        /* "pybase16384/backends/cython/_core.pyx":135
  *             chunk = input.read(current_buf_len)
  *             if first_check:
  *                 first_check = 0             # <<<<<<<<<<<<<<
  *                 if not PyBytes_Check(chunk):
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  */
         __pyx_v_first_check = 0;
 
-        /* "pybase16384/backends/cython/_core.pyx":128
+        /* "pybase16384/backends/cython/_core.pyx":136
  *             if first_check:
  *                 first_check = 0
  *                 if not PyBytes_Check(chunk):             # <<<<<<<<<<<<<<
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *             size = PyBytes_Size(chunk)
  */
         __pyx_t_2 = (!PyBytes_Check(__pyx_v_chunk));
         if (unlikely(__pyx_t_2)) {
 
-          /* "pybase16384/backends/cython/_core.pyx":129
+          /* "pybase16384/backends/cython/_core.pyx":137
  *                 first_check = 0
  *                 if not PyBytes_Check(chunk):
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")             # <<<<<<<<<<<<<<
  *             size = PyBytes_Size(chunk)
  *             if <int32_t> size < current_buf_len:  #
  */
-          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 129, __pyx_L9_error)
+          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 137, __pyx_L9_error)
           __Pyx_GOTREF(__pyx_t_3);
-          __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 129, __pyx_L9_error)
+          __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 137, __pyx_L9_error)
           __Pyx_GOTREF(__pyx_t_4);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_input_must_be_a_file_like_rb_obj, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 129, __pyx_L9_error)
+          __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_input_must_be_a_file_like_rb_obj, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 137, __pyx_L9_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 129, __pyx_L9_error)
+          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 137, __pyx_L9_error)
           __Pyx_GOTREF(__pyx_t_4);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           __Pyx_Raise(__pyx_t_4, 0, 0, 0);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __PYX_ERR(0, 129, __pyx_L9_error)
+          __PYX_ERR(0, 137, __pyx_L9_error)
 
-          /* "pybase16384/backends/cython/_core.pyx":128
+          /* "pybase16384/backends/cython/_core.pyx":136
  *             if first_check:
  *                 first_check = 0
  *                 if not PyBytes_Check(chunk):             # <<<<<<<<<<<<<<
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *             size = PyBytes_Size(chunk)
  */
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":126
+        /* "pybase16384/backends/cython/_core.pyx":134
  *         while True:
  *             chunk = input.read(current_buf_len)
  *             if first_check:             # <<<<<<<<<<<<<<
  *                 first_check = 0
  *                 if not PyBytes_Check(chunk):
  */
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":130
+      /* "pybase16384/backends/cython/_core.pyx":138
  *                 if not PyBytes_Check(chunk):
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *             size = PyBytes_Size(chunk)             # <<<<<<<<<<<<<<
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #   7  encode
  */
-      __pyx_t_8 = PyBytes_Size(__pyx_v_chunk); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1L))) __PYX_ERR(0, 130, __pyx_L9_error)
+      __pyx_t_8 = PyBytes_Size(__pyx_v_chunk); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1L))) __PYX_ERR(0, 138, __pyx_L9_error)
       __pyx_v_size = __pyx_t_8;
 
-      /* "pybase16384/backends/cython/_core.pyx":131
+      /* "pybase16384/backends/cython/_core.pyx":139
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *             size = PyBytes_Size(chunk)
  *             if <int32_t> size < current_buf_len:  #             # <<<<<<<<<<<<<<
  *                 if buf_rate > 1:  #   7  encode
  *                     buf_rate = buf_rate / 2
  */
       __pyx_t_2 = (((int32_t)__pyx_v_size) < __pyx_v_current_buf_len);
       if (__pyx_t_2) {
 
-        /* "pybase16384/backends/cython/_core.pyx":132
+        /* "pybase16384/backends/cython/_core.pyx":140
  *             size = PyBytes_Size(chunk)
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #   7  encode             # <<<<<<<<<<<<<<
  *                     buf_rate = buf_rate / 2
  *                     current_buf_len = buf_rate * 7
  */
         __pyx_t_2 = (__pyx_v_buf_rate > 1);
         if (__pyx_t_2) {
 
-          /* "pybase16384/backends/cython/_core.pyx":133
+          /* "pybase16384/backends/cython/_core.pyx":141
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #   7  encode
  *                     buf_rate = buf_rate / 2             # <<<<<<<<<<<<<<
  *                     current_buf_len = buf_rate * 7
  *                     input.seek(-size, 1)
  */
           __pyx_v_buf_rate = (((long)__pyx_v_buf_rate) / 2);
 
-          /* "pybase16384/backends/cython/_core.pyx":134
+          /* "pybase16384/backends/cython/_core.pyx":142
  *                 if buf_rate > 1:  #   7  encode
  *                     buf_rate = buf_rate / 2
  *                     current_buf_len = buf_rate * 7             # <<<<<<<<<<<<<<
  *                     input.seek(-size, 1)
  *                     continue
  */
           __pyx_v_current_buf_len = (__pyx_v_buf_rate * 7);
 
-          /* "pybase16384/backends/cython/_core.pyx":135
+          /* "pybase16384/backends/cython/_core.pyx":143
  *                     buf_rate = buf_rate / 2
  *                     current_buf_len = buf_rate * 7
  *                     input.seek(-size, 1)             # <<<<<<<<<<<<<<
  *                     continue
  *             chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
  */
-          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 135, __pyx_L9_error)
+          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 143, __pyx_L9_error)
           __Pyx_GOTREF(__pyx_t_3);
-          __pyx_t_5 = PyInt_FromSsize_t((-__pyx_v_size)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 135, __pyx_L9_error)
+          __pyx_t_5 = PyInt_FromSsize_t((-__pyx_v_size)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 143, __pyx_L9_error)
           __Pyx_GOTREF(__pyx_t_5);
           __pyx_t_7 = NULL;
           __pyx_t_6 = 0;
           #if CYTHON_UNPACK_METHODS
           if (likely(PyMethod_Check(__pyx_t_3))) {
             __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
             if (likely(__pyx_t_7)) {
@@ -20393,57 +20515,57 @@
           }
           #endif
           {
             PyObject *__pyx_callargs[3] = {__pyx_t_7, __pyx_t_5, __pyx_int_1};
             __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
             __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-            if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 135, __pyx_L9_error)
+            if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 143, __pyx_L9_error)
             __Pyx_GOTREF(__pyx_t_4);
             __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           }
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-          /* "pybase16384/backends/cython/_core.pyx":136
+          /* "pybase16384/backends/cython/_core.pyx":144
  *                     current_buf_len = buf_rate * 7
  *                     input.seek(-size, 1)
  *                     continue             # <<<<<<<<<<<<<<
  *             chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
  *             with nogil:
  */
           goto __pyx_L11_continue;
 
-          /* "pybase16384/backends/cython/_core.pyx":132
+          /* "pybase16384/backends/cython/_core.pyx":140
  *             size = PyBytes_Size(chunk)
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #   7  encode             # <<<<<<<<<<<<<<
  *                     buf_rate = buf_rate / 2
  *                     current_buf_len = buf_rate * 7
  */
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":131
+        /* "pybase16384/backends/cython/_core.pyx":139
  *                     raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *             size = PyBytes_Size(chunk)
  *             if <int32_t> size < current_buf_len:  #             # <<<<<<<<<<<<<<
  *                 if buf_rate > 1:  #   7  encode
  *                     buf_rate = buf_rate / 2
  */
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":137
+      /* "pybase16384/backends/cython/_core.pyx":145
  *                     input.seek(-size, 1)
  *                     continue
  *             chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)
  */
       __pyx_v_chunk_ptr = ((char const *)PyBytes_AS_STRING(__pyx_v_chunk));
 
-      /* "pybase16384/backends/cython/_core.pyx":138
+      /* "pybase16384/backends/cython/_core.pyx":146
  *                     continue
  *             chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)
  *             output.write(<bytes>output_buf[:count])
  */
       {
@@ -20451,25 +20573,25 @@
           PyThreadState *_save;
           _save = NULL;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "pybase16384/backends/cython/_core.pyx":139
+            /* "pybase16384/backends/cython/_core.pyx":147
  *             chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
  *             with nogil:
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)             # <<<<<<<<<<<<<<
  *             output.write(<bytes>output_buf[:count])
  *             if size < 7:
  */
             __pyx_v_count = base16384_encode(__pyx_v_chunk_ptr, ((int)__pyx_v_size), __pyx_v_output_buf);
           }
 
-          /* "pybase16384/backends/cython/_core.pyx":138
+          /* "pybase16384/backends/cython/_core.pyx":146
  *                     continue
  *             chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)
  *             output.write(<bytes>output_buf[:count])
  */
           /*finally:*/ {
@@ -20480,24 +20602,24 @@
               #endif
               goto __pyx_L21;
             }
             __pyx_L21:;
           }
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":140
+      /* "pybase16384/backends/cython/_core.pyx":148
  *             with nogil:
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)
  *             output.write(<bytes>output_buf[:count])             # <<<<<<<<<<<<<<
  *             if size < 7:
  *                 break
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 140, __pyx_L9_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 148, __pyx_L9_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 140, __pyx_L9_error)
+      __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 148, __pyx_L9_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_7 = NULL;
       __pyx_t_6 = 0;
       #if CYTHON_UNPACK_METHODS
       if (likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_7)) {
@@ -20510,53 +20632,53 @@
       }
       #endif
       {
         PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
         __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 140, __pyx_L9_error)
+        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 148, __pyx_L9_error)
         __Pyx_GOTREF(__pyx_t_4);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-      /* "pybase16384/backends/cython/_core.pyx":141
+      /* "pybase16384/backends/cython/_core.pyx":149
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)
  *             output.write(<bytes>output_buf[:count])
  *             if size < 7:             # <<<<<<<<<<<<<<
  *                 break
  *     finally:
  */
       __pyx_t_2 = (__pyx_v_size < 7);
       if (__pyx_t_2) {
 
-        /* "pybase16384/backends/cython/_core.pyx":142
+        /* "pybase16384/backends/cython/_core.pyx":150
  *             output.write(<bytes>output_buf[:count])
  *             if size < 7:
  *                 break             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(output_buf)
  */
         goto __pyx_L12_break;
 
-        /* "pybase16384/backends/cython/_core.pyx":141
+        /* "pybase16384/backends/cython/_core.pyx":149
  *                 count = b14_encode(chunk_ptr, <int>size, output_buf)
  *             output.write(<bytes>output_buf[:count])
  *             if size < 7:             # <<<<<<<<<<<<<<
  *                 break
  *     finally:
  */
       }
       __pyx_L11_continue:;
     }
     __pyx_L12_break:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":144
+  /* "pybase16384/backends/cython/_core.pyx":152
  *                 break
  *     finally:
  *         PyMem_Free(output_buf)             # <<<<<<<<<<<<<<
  * 
  * def decode_file(object input,
  */
   /*finally:*/ {
@@ -20598,15 +20720,15 @@
       __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
       __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_9; __pyx_filename = __pyx_t_10;
       goto __pyx_L1_error;
     }
     __pyx_L10:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":99
+  /* "pybase16384/backends/cython/_core.pyx":107
  * 
  * 
  * def encode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        bint write_head = False,
  */
 
@@ -20623,15 +20745,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_chunk);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":146
+/* "pybase16384/backends/cython/_core.pyx":154
  *         PyMem_Free(output_buf)
  * 
  * def decode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        int32_t buf_rate = 10):
  */
 
@@ -20691,59 +20813,59 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_input)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 146, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 154, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_output)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 146, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 154, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("decode_file", 0, 2, 3, 1); __PYX_ERR(0, 146, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decode_file", 0, 2, 3, 1); __PYX_ERR(0, 154, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_buf_rate);
           if (value) { values[2] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 146, __pyx_L3_error)
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 154, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_file") < 0)) __PYX_ERR(0, 146, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_file") < 0)) __PYX_ERR(0, 154, __pyx_L3_error)
       }
     } else {
       switch (__pyx_nargs) {
         case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
         values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_input = values[0];
     __pyx_v_output = values[1];
     if (values[2]) {
-      __pyx_v_buf_rate = __Pyx_PyInt_As_int32_t(values[2]); if (unlikely((__pyx_v_buf_rate == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 148, __pyx_L3_error)
+      __pyx_v_buf_rate = __Pyx_PyInt_As_int32_t(values[2]); if (unlikely((__pyx_v_buf_rate == ((int32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 156, __pyx_L3_error)
     } else {
       __pyx_v_buf_rate = ((int32_t)((int32_t)10));
     }
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decode_file", 0, 2, 3, __pyx_nargs); __PYX_ERR(0, 146, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decode_file", 0, 2, 3, __pyx_nargs); __PYX_ERR(0, 154, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -20794,128 +20916,128 @@
   PyObject *__pyx_t_15 = NULL;
   PyObject *__pyx_t_16 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decode_file", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":149
+  /* "pybase16384/backends/cython/_core.pyx":157
  *                        object output,
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_input); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 149, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_input); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 157, __pyx_L1_error)
   __pyx_t_2 = (!(__pyx_t_1 != 0));
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":150
+    /* "pybase16384/backends/cython/_core.pyx":158
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_input_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 158, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 150, __pyx_L1_error)
+    __PYX_ERR(0, 158, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":149
+    /* "pybase16384/backends/cython/_core.pyx":157
  *                        object output,
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):             # <<<<<<<<<<<<<<
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":151
+  /* "pybase16384/backends/cython/_core.pyx":159
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_output); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 151, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_PyFile_Check(__pyx_v_output); if (unlikely(__pyx_t_1 == ((uint8_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 159, __pyx_L1_error)
   __pyx_t_2 = (!(__pyx_t_1 != 0));
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":152
+    /* "pybase16384/backends/cython/_core.pyx":160
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)             # <<<<<<<<<<<<<<
  *     if buf_rate <= 0:
  *         buf_rate = 1
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_output)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 152, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_output_except_a_file_like_object, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 160, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(0, 152, __pyx_L1_error)
+    __PYX_ERR(0, 160, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":151
+    /* "pybase16384/backends/cython/_core.pyx":159
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  *     if not PyFile_Check(output):             # <<<<<<<<<<<<<<
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":153
+  /* "pybase16384/backends/cython/_core.pyx":161
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:             # <<<<<<<<<<<<<<
  *         buf_rate = 1
  * 
  */
   __pyx_t_2 = (__pyx_v_buf_rate <= 0);
   if (__pyx_t_2) {
 
-    /* "pybase16384/backends/cython/_core.pyx":154
+    /* "pybase16384/backends/cython/_core.pyx":162
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:
  *         buf_rate = 1             # <<<<<<<<<<<<<<
  * 
  *     chunk = input.read(1)  # type: bytes
  */
     __pyx_v_buf_rate = 1;
 
-    /* "pybase16384/backends/cython/_core.pyx":153
+    /* "pybase16384/backends/cython/_core.pyx":161
  *     if not PyFile_Check(output):
  *         raise TypeError("output except a file-like object, got %s" % type(output).__name__)
  *     if buf_rate <= 0:             # <<<<<<<<<<<<<<
  *         buf_rate = 1
  * 
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":156
+  /* "pybase16384/backends/cython/_core.pyx":164
  *         buf_rate = 1
  * 
  *     chunk = input.read(1)  # type: bytes             # <<<<<<<<<<<<<<
  *     if not PyBytes_Check(chunk):
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 164, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   __pyx_t_6 = 0;
   #if CYTHON_UNPACK_METHODS
   if (likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_5)) {
@@ -20927,80 +21049,80 @@
     }
   }
   #endif
   {
     PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_int_1};
     __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 156, __pyx_L1_error)
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 164, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __pyx_v_chunk = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":157
+  /* "pybase16384/backends/cython/_core.pyx":165
  * 
  *     chunk = input.read(1)  # type: bytes
  *     if not PyBytes_Check(chunk):             # <<<<<<<<<<<<<<
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *     if chunk == b"\xfe":  #
  */
   __pyx_t_2 = (!PyBytes_Check(__pyx_v_chunk));
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":158
+    /* "pybase16384/backends/cython/_core.pyx":166
  *     chunk = input.read(1)  # type: bytes
  *     if not PyBytes_Check(chunk):
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")             # <<<<<<<<<<<<<<
  *     if chunk == b"\xfe":  #
  *         input.read(1)
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 158, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_input)), __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 158, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_input_must_be_a_file_like_rb_obj, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 158, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_input_must_be_a_file_like_rb_obj, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 158, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 166, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_Raise(__pyx_t_4, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __PYX_ERR(0, 158, __pyx_L1_error)
+    __PYX_ERR(0, 166, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":157
+    /* "pybase16384/backends/cython/_core.pyx":165
  * 
  *     chunk = input.read(1)  # type: bytes
  *     if not PyBytes_Check(chunk):             # <<<<<<<<<<<<<<
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *     if chunk == b"\xfe":  #
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":159
+  /* "pybase16384/backends/cython/_core.pyx":167
  *     if not PyBytes_Check(chunk):
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *     if chunk == b"\xfe":  #             # <<<<<<<<<<<<<<
  *         input.read(1)
  *     else:
  */
-  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_chunk, __pyx_kp_b__11, Py_EQ)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 159, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyBytes_Equals(__pyx_v_chunk, __pyx_kp_b__11, Py_EQ)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 167, __pyx_L1_error)
   if (__pyx_t_2) {
 
-    /* "pybase16384/backends/cython/_core.pyx":160
+    /* "pybase16384/backends/cython/_core.pyx":168
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *     if chunk == b"\xfe":  #
  *         input.read(1)             # <<<<<<<<<<<<<<
  *     else:
  *         input.seek(0, 0)  #
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_5 = NULL;
     __pyx_t_6 = 0;
     #if CYTHON_UNPACK_METHODS
     if (likely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
@@ -21012,139 +21134,139 @@
       }
     }
     #endif
     {
       PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_int_1};
       __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 160, __pyx_L1_error)
+      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 168, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     }
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pybase16384/backends/cython/_core.pyx":159
+    /* "pybase16384/backends/cython/_core.pyx":167
  *     if not PyBytes_Check(chunk):
  *         raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
  *     if chunk == b"\xfe":  #             # <<<<<<<<<<<<<<
  *         input.read(1)
  *     else:
  */
     goto __pyx_L7;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":162
+  /* "pybase16384/backends/cython/_core.pyx":170
  *         input.read(1)
  *     else:
  *         input.seek(0, 0)  #             # <<<<<<<<<<<<<<
  * 
  *     cdef int32_t current_buf_len = buf_rate * 8
  */
   /*else*/ {
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 162, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 170, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 170, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L7:;
 
-  /* "pybase16384/backends/cython/_core.pyx":164
+  /* "pybase16384/backends/cython/_core.pyx":172
  *         input.seek(0, 0)  #
  * 
  *     cdef int32_t current_buf_len = buf_rate * 8             # <<<<<<<<<<<<<<
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  */
   __pyx_v_current_buf_len = (__pyx_v_buf_rate * 8);
 
-  /* "pybase16384/backends/cython/_core.pyx":165
+  /* "pybase16384/backends/cython/_core.pyx":173
  * 
  *     cdef int32_t current_buf_len = buf_rate * 8
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16             # <<<<<<<<<<<<<<
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  */
   __pyx_v_output_size = (((size_t)base16384_decode_len(((int)__pyx_v_current_buf_len), 0)) + 16);
 
-  /* "pybase16384/backends/cython/_core.pyx":166
+  /* "pybase16384/backends/cython/_core.pyx":174
  *     cdef int32_t current_buf_len = buf_rate * 8
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)             # <<<<<<<<<<<<<<
  *     if output_buf == NULL:
  *         raise MemoryError
  */
   __pyx_v_output_buf = ((char *)PyMem_Malloc(__pyx_v_output_size));
 
-  /* "pybase16384/backends/cython/_core.pyx":167
+  /* "pybase16384/backends/cython/_core.pyx":175
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef Py_ssize_t size
  */
   __pyx_t_2 = (__pyx_v_output_buf == NULL);
   if (unlikely(__pyx_t_2)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":168
+    /* "pybase16384/backends/cython/_core.pyx":176
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t size
  *     cdef int count = 0
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 168, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 176, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":167
+    /* "pybase16384/backends/cython/_core.pyx":175
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16
  *     cdef char *output_buf = <char *> PyMem_Malloc(output_size)
  *     if output_buf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef Py_ssize_t size
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":170
+  /* "pybase16384/backends/cython/_core.pyx":178
  *         raise MemoryError
  *     cdef Py_ssize_t size
  *     cdef int count = 0             # <<<<<<<<<<<<<<
  *     cdef const char *chunk_ptr
  *     try:
  */
   __pyx_v_count = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":172
+  /* "pybase16384/backends/cython/_core.pyx":180
  *     cdef int count = 0
  *     cdef const char *chunk_ptr
  *     try:             # <<<<<<<<<<<<<<
  *         while True:
  *             chunk = input.read(current_buf_len)  # 8
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":173
+    /* "pybase16384/backends/cython/_core.pyx":181
  *     cdef const char *chunk_ptr
  *     try:
  *         while True:             # <<<<<<<<<<<<<<
  *             chunk = input.read(current_buf_len)  # 8
  *             size = PyBytes_Size(chunk)
  */
     while (1) {
 
-      /* "pybase16384/backends/cython/_core.pyx":174
+      /* "pybase16384/backends/cython/_core.pyx":182
  *     try:
  *         while True:
  *             chunk = input.read(current_buf_len)  # 8             # <<<<<<<<<<<<<<
  *             size = PyBytes_Size(chunk)
  *             if size == 0:
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 174, __pyx_L10_error)
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 182, __pyx_L10_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_current_buf_len); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 174, __pyx_L10_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_current_buf_len); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 182, __pyx_L10_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_7 = NULL;
       __pyx_t_6 = 0;
       #if CYTHON_UNPACK_METHODS
       if (likely(PyMethod_Check(__pyx_t_4))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
         if (likely(__pyx_t_7)) {
@@ -21157,107 +21279,107 @@
       }
       #endif
       {
         PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
         __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 174, __pyx_L10_error)
+        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 182, __pyx_L10_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       }
       __Pyx_DECREF_SET(__pyx_v_chunk, __pyx_t_3);
       __pyx_t_3 = 0;
 
-      /* "pybase16384/backends/cython/_core.pyx":175
+      /* "pybase16384/backends/cython/_core.pyx":183
  *         while True:
  *             chunk = input.read(current_buf_len)  # 8
  *             size = PyBytes_Size(chunk)             # <<<<<<<<<<<<<<
  *             if size == 0:
  *                 break
  */
-      __pyx_t_8 = PyBytes_Size(__pyx_v_chunk); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1L))) __PYX_ERR(0, 175, __pyx_L10_error)
+      __pyx_t_8 = PyBytes_Size(__pyx_v_chunk); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1L))) __PYX_ERR(0, 183, __pyx_L10_error)
       __pyx_v_size = __pyx_t_8;
 
-      /* "pybase16384/backends/cython/_core.pyx":176
+      /* "pybase16384/backends/cython/_core.pyx":184
  *             chunk = input.read(current_buf_len)  # 8
  *             size = PyBytes_Size(chunk)
  *             if size == 0:             # <<<<<<<<<<<<<<
  *                 break
  *             if <int32_t> size < current_buf_len:  #
  */
       __pyx_t_2 = (__pyx_v_size == 0);
       if (__pyx_t_2) {
 
-        /* "pybase16384/backends/cython/_core.pyx":177
+        /* "pybase16384/backends/cython/_core.pyx":185
  *             size = PyBytes_Size(chunk)
  *             if size == 0:
  *                 break             # <<<<<<<<<<<<<<
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #
  */
         goto __pyx_L13_break;
 
-        /* "pybase16384/backends/cython/_core.pyx":176
+        /* "pybase16384/backends/cython/_core.pyx":184
  *             chunk = input.read(current_buf_len)  # 8
  *             size = PyBytes_Size(chunk)
  *             if size == 0:             # <<<<<<<<<<<<<<
  *                 break
  *             if <int32_t> size < current_buf_len:  #
  */
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":178
+      /* "pybase16384/backends/cython/_core.pyx":186
  *             if size == 0:
  *                 break
  *             if <int32_t> size < current_buf_len:  #             # <<<<<<<<<<<<<<
  *                 if buf_rate > 1:  #
  *                     buf_rate = buf_rate / 2  #
  */
       __pyx_t_2 = (((int32_t)__pyx_v_size) < __pyx_v_current_buf_len);
       if (__pyx_t_2) {
 
-        /* "pybase16384/backends/cython/_core.pyx":179
+        /* "pybase16384/backends/cython/_core.pyx":187
  *                 break
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #             # <<<<<<<<<<<<<<
  *                     buf_rate = buf_rate / 2  #
  *                     current_buf_len = buf_rate * 8
  */
         __pyx_t_2 = (__pyx_v_buf_rate > 1);
         if (__pyx_t_2) {
 
-          /* "pybase16384/backends/cython/_core.pyx":180
+          /* "pybase16384/backends/cython/_core.pyx":188
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #
  *                     buf_rate = buf_rate / 2  #             # <<<<<<<<<<<<<<
  *                     current_buf_len = buf_rate * 8
  *                     input.seek(-size, 1)
  */
           __pyx_v_buf_rate = (((long)__pyx_v_buf_rate) / 2);
 
-          /* "pybase16384/backends/cython/_core.pyx":181
+          /* "pybase16384/backends/cython/_core.pyx":189
  *                 if buf_rate > 1:  #
  *                     buf_rate = buf_rate / 2  #
  *                     current_buf_len = buf_rate * 8             # <<<<<<<<<<<<<<
  *                     input.seek(-size, 1)
  *                     continue
  */
           __pyx_v_current_buf_len = (__pyx_v_buf_rate * 8);
 
-          /* "pybase16384/backends/cython/_core.pyx":182
+          /* "pybase16384/backends/cython/_core.pyx":190
  *                     buf_rate = buf_rate / 2  #
  *                     current_buf_len = buf_rate * 8
  *                     input.seek(-size, 1)             # <<<<<<<<<<<<<<
  *                     continue
  *             tmp = input.read(2)  # type: bytes
  */
-          __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 182, __pyx_L10_error)
+          __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 190, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_4);
-          __pyx_t_5 = PyInt_FromSsize_t((-__pyx_v_size)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 182, __pyx_L10_error)
+          __pyx_t_5 = PyInt_FromSsize_t((-__pyx_v_size)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 190, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_5);
           __pyx_t_7 = NULL;
           __pyx_t_6 = 0;
           #if CYTHON_UNPACK_METHODS
           if (likely(PyMethod_Check(__pyx_t_4))) {
             __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
             if (likely(__pyx_t_7)) {
@@ -21270,55 +21392,55 @@
           }
           #endif
           {
             PyObject *__pyx_callargs[3] = {__pyx_t_7, __pyx_t_5, __pyx_int_1};
             __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
             __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-            if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 182, __pyx_L10_error)
+            if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L10_error)
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
           }
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-          /* "pybase16384/backends/cython/_core.pyx":183
+          /* "pybase16384/backends/cython/_core.pyx":191
  *                     current_buf_len = buf_rate * 8
  *                     input.seek(-size, 1)
  *                     continue             # <<<<<<<<<<<<<<
  *             tmp = input.read(2)  # type: bytes
  *             if PyBytes_Size(tmp) == 2:
  */
           goto __pyx_L12_continue;
 
-          /* "pybase16384/backends/cython/_core.pyx":179
+          /* "pybase16384/backends/cython/_core.pyx":187
  *                 break
  *             if <int32_t> size < current_buf_len:  #
  *                 if buf_rate > 1:  #             # <<<<<<<<<<<<<<
  *                     buf_rate = buf_rate / 2  #
  *                     current_buf_len = buf_rate * 8
  */
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":178
+        /* "pybase16384/backends/cython/_core.pyx":186
  *             if size == 0:
  *                 break
  *             if <int32_t> size < current_buf_len:  #             # <<<<<<<<<<<<<<
  *                 if buf_rate > 1:  #
  *                     buf_rate = buf_rate / 2  #
  */
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":184
+      /* "pybase16384/backends/cython/_core.pyx":192
  *                     input.seek(-size, 1)
  *                     continue
  *             tmp = input.read(2)  # type: bytes             # <<<<<<<<<<<<<<
  *             if PyBytes_Size(tmp) == 2:
  *                 if tmp[0] == 61:  # = stream   8n+2
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 184, __pyx_L10_error)
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_read); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L10_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_5 = NULL;
       __pyx_t_6 = 0;
       #if CYTHON_UNPACK_METHODS
       if (likely(PyMethod_Check(__pyx_t_4))) {
         __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
         if (likely(__pyx_t_5)) {
@@ -21330,112 +21452,112 @@
         }
       }
       #endif
       {
         PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_int_2};
         __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
         __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L10_error)
+        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L10_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       }
       __Pyx_XDECREF_SET(__pyx_v_tmp, __pyx_t_3);
       __pyx_t_3 = 0;
 
-      /* "pybase16384/backends/cython/_core.pyx":185
+      /* "pybase16384/backends/cython/_core.pyx":193
  *                     continue
  *             tmp = input.read(2)  # type: bytes
  *             if PyBytes_Size(tmp) == 2:             # <<<<<<<<<<<<<<
  *                 if tmp[0] == 61:  # = stream   8n+2
  *                     chunk += tmp
  */
-      __pyx_t_8 = PyBytes_Size(__pyx_v_tmp); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1L))) __PYX_ERR(0, 185, __pyx_L10_error)
+      __pyx_t_8 = PyBytes_Size(__pyx_v_tmp); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1L))) __PYX_ERR(0, 193, __pyx_L10_error)
       __pyx_t_2 = (__pyx_t_8 == 2);
       if (__pyx_t_2) {
 
-        /* "pybase16384/backends/cython/_core.pyx":186
+        /* "pybase16384/backends/cython/_core.pyx":194
  *             tmp = input.read(2)  # type: bytes
  *             if PyBytes_Size(tmp) == 2:
  *                 if tmp[0] == 61:  # = stream   8n+2             # <<<<<<<<<<<<<<
  *                     chunk += tmp
  *                     size += 2
  */
-        __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_tmp, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 186, __pyx_L10_error)
+        __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_tmp, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 194, __pyx_L10_error)
         __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_2 = (__Pyx_PyInt_BoolEqObjC(__pyx_t_3, __pyx_int_61, 61, 0)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 186, __pyx_L10_error)
+        __pyx_t_2 = (__Pyx_PyInt_BoolEqObjC(__pyx_t_3, __pyx_int_61, 61, 0)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 194, __pyx_L10_error)
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         if (__pyx_t_2) {
 
-          /* "pybase16384/backends/cython/_core.pyx":187
+          /* "pybase16384/backends/cython/_core.pyx":195
  *             if PyBytes_Size(tmp) == 2:
  *                 if tmp[0] == 61:  # = stream   8n+2
  *                     chunk += tmp             # <<<<<<<<<<<<<<
  *                     size += 2
  *                 else:
  */
-          __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_chunk, __pyx_v_tmp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 187, __pyx_L10_error)
+          __pyx_t_3 = PyNumber_InPlaceAdd(__pyx_v_chunk, __pyx_v_tmp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 195, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF_SET(__pyx_v_chunk, __pyx_t_3);
           __pyx_t_3 = 0;
 
-          /* "pybase16384/backends/cython/_core.pyx":188
+          /* "pybase16384/backends/cython/_core.pyx":196
  *                 if tmp[0] == 61:  # = stream   8n+2
  *                     chunk += tmp
  *                     size += 2             # <<<<<<<<<<<<<<
  *                 else:
  *                     input.seek(-2, 1)
  */
           __pyx_v_size = (__pyx_v_size + 2);
 
-          /* "pybase16384/backends/cython/_core.pyx":186
+          /* "pybase16384/backends/cython/_core.pyx":194
  *             tmp = input.read(2)  # type: bytes
  *             if PyBytes_Size(tmp) == 2:
  *                 if tmp[0] == 61:  # = stream   8n+2             # <<<<<<<<<<<<<<
  *                     chunk += tmp
  *                     size += 2
  */
           goto __pyx_L18;
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":190
+        /* "pybase16384/backends/cython/_core.pyx":198
  *                     size += 2
  *                 else:
  *                     input.seek(-2, 1)             # <<<<<<<<<<<<<<
  *             chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
  *             with nogil:
  */
         /*else*/ {
-          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L10_error)
+          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_input, __pyx_n_s_seek); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 198, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_3);
-          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 190, __pyx_L10_error)
+          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 198, __pyx_L10_error)
           __Pyx_GOTREF(__pyx_t_4);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         }
         __pyx_L18:;
 
-        /* "pybase16384/backends/cython/_core.pyx":185
+        /* "pybase16384/backends/cython/_core.pyx":193
  *                     continue
  *             tmp = input.read(2)  # type: bytes
  *             if PyBytes_Size(tmp) == 2:             # <<<<<<<<<<<<<<
  *                 if tmp[0] == 61:  # = stream   8n+2
  *                     chunk += tmp
  */
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":191
+      /* "pybase16384/backends/cython/_core.pyx":199
  *                 else:
  *                     input.seek(-2, 1)
  *             chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)             # <<<<<<<<<<<<<<
  *             with nogil:
  *                 count = b14_decode(chunk_ptr, <int> size, output_buf)
  */
       __pyx_v_chunk_ptr = ((char const *)PyBytes_AS_STRING(__pyx_v_chunk));
 
-      /* "pybase16384/backends/cython/_core.pyx":192
+      /* "pybase16384/backends/cython/_core.pyx":200
  *                     input.seek(-2, 1)
  *             chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 count = b14_decode(chunk_ptr, <int> size, output_buf)
  *             output.write(<bytes>output_buf[:count])
  */
       {
@@ -21443,25 +21565,25 @@
           PyThreadState *_save;
           _save = NULL;
           Py_UNBLOCK_THREADS
           __Pyx_FastGIL_Remember();
           #endif
           /*try:*/ {
 
-            /* "pybase16384/backends/cython/_core.pyx":193
+            /* "pybase16384/backends/cython/_core.pyx":201
  *             chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
  *             with nogil:
  *                 count = b14_decode(chunk_ptr, <int> size, output_buf)             # <<<<<<<<<<<<<<
  *             output.write(<bytes>output_buf[:count])
  *     finally:
  */
             __pyx_v_count = base16384_decode(__pyx_v_chunk_ptr, ((int)__pyx_v_size), __pyx_v_output_buf);
           }
 
-          /* "pybase16384/backends/cython/_core.pyx":192
+          /* "pybase16384/backends/cython/_core.pyx":200
  *                     input.seek(-2, 1)
  *             chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
  *             with nogil:             # <<<<<<<<<<<<<<
  *                 count = b14_decode(chunk_ptr, <int> size, output_buf)
  *             output.write(<bytes>output_buf[:count])
  */
           /*finally:*/ {
@@ -21472,24 +21594,24 @@
               #endif
               goto __pyx_L23;
             }
             __pyx_L23:;
           }
       }
 
-      /* "pybase16384/backends/cython/_core.pyx":194
+      /* "pybase16384/backends/cython/_core.pyx":202
  *             with nogil:
  *                 count = b14_decode(chunk_ptr, <int> size, output_buf)
  *             output.write(<bytes>output_buf[:count])             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(output_buf)
  */
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 194, __pyx_L10_error)
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_output, __pyx_n_s_write); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 202, __pyx_L10_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 194, __pyx_L10_error)
+      __pyx_t_5 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_output_buf + 0, __pyx_v_count - 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 202, __pyx_L10_error)
       __Pyx_GOTREF(__pyx_t_5);
       __pyx_t_7 = NULL;
       __pyx_t_6 = 0;
       #if CYTHON_UNPACK_METHODS
       if (likely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_7)) {
@@ -21502,25 +21624,25 @@
       }
       #endif
       {
         PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
         __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 194, __pyx_L10_error)
+        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 202, __pyx_L10_error)
         __Pyx_GOTREF(__pyx_t_4);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       }
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       __pyx_L12_continue:;
     }
     __pyx_L13_break:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":196
+  /* "pybase16384/backends/cython/_core.pyx":204
  *             output.write(<bytes>output_buf[:count])
  *     finally:
  *         PyMem_Free(output_buf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline bint is_64bits() nogil:
  */
   /*finally:*/ {
@@ -21562,15 +21684,15 @@
       __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
       __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_9; __pyx_filename = __pyx_t_10;
       goto __pyx_L1_error;
     }
     __pyx_L11:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":146
+  /* "pybase16384/backends/cython/_core.pyx":154
  *         PyMem_Free(output_buf)
  * 
  * def decode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        int32_t buf_rate = 10):
  */
 
@@ -21588,37 +21710,37 @@
   __Pyx_XDECREF(__pyx_v_chunk);
   __Pyx_XDECREF(__pyx_v_tmp);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":198
+/* "pybase16384/backends/cython/_core.pyx":206
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bint is_64bits() nogil:             # <<<<<<<<<<<<<<
  *     return pybase16384_64bits()
  * 
  */
 
 static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_17is_64bits(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
 static CYTHON_INLINE int __pyx_f_11pybase16384_8backends_6cython_5_core_is_64bits(CYTHON_UNUSED int __pyx_skip_dispatch) {
   int __pyx_r;
 
-  /* "pybase16384/backends/cython/_core.pyx":199
+  /* "pybase16384/backends/cython/_core.pyx":207
  * 
  * cpdef inline bint is_64bits() nogil:
  *     return pybase16384_64bits()             # <<<<<<<<<<<<<<
  * 
  * cdef inline str err_to_str(base16384_err_t ret):
  */
   __pyx_r = pybase16384_64bits();
   goto __pyx_L0;
 
-  /* "pybase16384/backends/cython/_core.pyx":198
+  /* "pybase16384/backends/cython/_core.pyx":206
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bint is_64bits() nogil:             # <<<<<<<<<<<<<<
  *     return pybase16384_64bits()
  * 
  */
 
@@ -21650,16 +21772,16 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("is_64bits", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_is_64bits(0); if (unlikely(__pyx_t_1 == ((int)-1) && PyErr_Occurred())) __PYX_ERR(0, 198, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 198, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_is_64bits(0); if (unlikely(__pyx_t_1 == ((int)-1) && PyErr_Occurred())) __PYX_ERR(0, 206, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -21668,171 +21790,259 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":201
+/* "pybase16384/backends/cython/_core.pyx":209
  *     return pybase16384_64bits()
  * 
  * cdef inline str err_to_str(base16384_err_t ret):             # <<<<<<<<<<<<<<
  *     if ret == base16384_err_get_file_size:
  *         return "base16384_err_get_file_size"
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(base16384_err_t __pyx_v_ret) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("err_to_str", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":202
+  /* "pybase16384/backends/cython/_core.pyx":210
  * 
  * cdef inline str err_to_str(base16384_err_t ret):
  *     if ret == base16384_err_get_file_size:             # <<<<<<<<<<<<<<
  *         return "base16384_err_get_file_size"
  *     elif ret == base16384_err_fopen_output_file:
  */
   switch (__pyx_v_ret) {
     case base16384_err_get_file_size:
 
-    /* "pybase16384/backends/cython/_core.pyx":203
+    /* "pybase16384/backends/cython/_core.pyx":211
  * cdef inline str err_to_str(base16384_err_t ret):
  *     if ret == base16384_err_get_file_size:
  *         return "base16384_err_get_file_size"             # <<<<<<<<<<<<<<
  *     elif ret == base16384_err_fopen_output_file:
  *         return "base16384_err_fopen_output_file"
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_n_u_base16384_err_get_file_size);
     __pyx_r = __pyx_n_u_base16384_err_get_file_size;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":202
+    /* "pybase16384/backends/cython/_core.pyx":210
  * 
  * cdef inline str err_to_str(base16384_err_t ret):
  *     if ret == base16384_err_get_file_size:             # <<<<<<<<<<<<<<
  *         return "base16384_err_get_file_size"
  *     elif ret == base16384_err_fopen_output_file:
  */
     break;
     case base16384_err_fopen_output_file:
 
-    /* "pybase16384/backends/cython/_core.pyx":205
+    /* "pybase16384/backends/cython/_core.pyx":213
  *         return "base16384_err_get_file_size"
  *     elif ret == base16384_err_fopen_output_file:
  *         return "base16384_err_fopen_output_file"             # <<<<<<<<<<<<<<
  *     elif ret == base16384_err_fopen_input_file:
  *         return "base16384_err_fopen_input_file"
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_n_u_base16384_err_fopen_output_file);
     __pyx_r = __pyx_n_u_base16384_err_fopen_output_file;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":204
+    /* "pybase16384/backends/cython/_core.pyx":212
  *     if ret == base16384_err_get_file_size:
  *         return "base16384_err_get_file_size"
  *     elif ret == base16384_err_fopen_output_file:             # <<<<<<<<<<<<<<
  *         return "base16384_err_fopen_output_file"
  *     elif ret == base16384_err_fopen_input_file:
  */
     break;
     case base16384_err_fopen_input_file:
 
-    /* "pybase16384/backends/cython/_core.pyx":207
+    /* "pybase16384/backends/cython/_core.pyx":215
  *         return "base16384_err_fopen_output_file"
  *     elif ret == base16384_err_fopen_input_file:
  *         return "base16384_err_fopen_input_file"             # <<<<<<<<<<<<<<
  *     elif ret == base16384_err_write_file:
  *         return "base16384_err_write_file"
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_n_u_base16384_err_fopen_input_file);
     __pyx_r = __pyx_n_u_base16384_err_fopen_input_file;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":206
+    /* "pybase16384/backends/cython/_core.pyx":214
  *     elif ret == base16384_err_fopen_output_file:
  *         return "base16384_err_fopen_output_file"
  *     elif ret == base16384_err_fopen_input_file:             # <<<<<<<<<<<<<<
  *         return "base16384_err_fopen_input_file"
  *     elif ret == base16384_err_write_file:
  */
     break;
     case base16384_err_write_file:
 
-    /* "pybase16384/backends/cython/_core.pyx":209
+    /* "pybase16384/backends/cython/_core.pyx":217
  *         return "base16384_err_fopen_input_file"
  *     elif ret == base16384_err_write_file:
  *         return "base16384_err_write_file"             # <<<<<<<<<<<<<<
  *     elif ret == base16384_err_open_input_file:
  *         return "base16384_err_open_input_file"
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_n_u_base16384_err_write_file);
     __pyx_r = __pyx_n_u_base16384_err_write_file;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":208
+    /* "pybase16384/backends/cython/_core.pyx":216
  *     elif ret == base16384_err_fopen_input_file:
  *         return "base16384_err_fopen_input_file"
  *     elif ret == base16384_err_write_file:             # <<<<<<<<<<<<<<
  *         return "base16384_err_write_file"
  *     elif ret == base16384_err_open_input_file:
  */
     break;
     case base16384_err_open_input_file:
 
-    /* "pybase16384/backends/cython/_core.pyx":211
+    /* "pybase16384/backends/cython/_core.pyx":219
  *         return "base16384_err_write_file"
  *     elif ret == base16384_err_open_input_file:
  *         return "base16384_err_open_input_file"             # <<<<<<<<<<<<<<
  *     elif ret == base16384_err_map_input_file:
  *         return "base16384_err_map_input_file"
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_n_u_base16384_err_open_input_file);
     __pyx_r = __pyx_n_u_base16384_err_open_input_file;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":210
+    /* "pybase16384/backends/cython/_core.pyx":218
  *     elif ret == base16384_err_write_file:
  *         return "base16384_err_write_file"
  *     elif ret == base16384_err_open_input_file:             # <<<<<<<<<<<<<<
  *         return "base16384_err_open_input_file"
  *     elif ret == base16384_err_map_input_file:
  */
     break;
     case base16384_err_map_input_file:
 
-    /* "pybase16384/backends/cython/_core.pyx":213
+    /* "pybase16384/backends/cython/_core.pyx":221
  *         return "base16384_err_open_input_file"
  *     elif ret == base16384_err_map_input_file:
  *         return "base16384_err_map_input_file"             # <<<<<<<<<<<<<<
- * 
- * cpdef inline encode_local_file(object inp, object out):
+ *     elif ret == base16384_err_read_file:
+ *         return "base16384_err_read_file"
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_n_u_base16384_err_map_input_file);
     __pyx_r = __pyx_n_u_base16384_err_map_input_file;
     goto __pyx_L0;
 
-    /* "pybase16384/backends/cython/_core.pyx":212
+    /* "pybase16384/backends/cython/_core.pyx":220
  *     elif ret == base16384_err_open_input_file:
  *         return "base16384_err_open_input_file"
  *     elif ret == base16384_err_map_input_file:             # <<<<<<<<<<<<<<
  *         return "base16384_err_map_input_file"
+ *     elif ret == base16384_err_read_file:
+ */
+    break;
+    case base16384_err_read_file:
+
+    /* "pybase16384/backends/cython/_core.pyx":223
+ *         return "base16384_err_map_input_file"
+ *     elif ret == base16384_err_read_file:
+ *         return "base16384_err_read_file"             # <<<<<<<<<<<<<<
+ *     elif ret == base16384_err_invalid_file_name:
+ *         return "base16384_err_invalid_file_name"
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(__pyx_n_u_base16384_err_read_file);
+    __pyx_r = __pyx_n_u_base16384_err_read_file;
+    goto __pyx_L0;
+
+    /* "pybase16384/backends/cython/_core.pyx":222
+ *     elif ret == base16384_err_map_input_file:
+ *         return "base16384_err_map_input_file"
+ *     elif ret == base16384_err_read_file:             # <<<<<<<<<<<<<<
+ *         return "base16384_err_read_file"
+ *     elif ret == base16384_err_invalid_file_name:
+ */
+    break;
+    case base16384_err_invalid_file_name:
+
+    /* "pybase16384/backends/cython/_core.pyx":225
+ *         return "base16384_err_read_file"
+ *     elif ret == base16384_err_invalid_file_name:
+ *         return "base16384_err_invalid_file_name"             # <<<<<<<<<<<<<<
+ *     elif ret == base16384_err_invalid_commandline_parameter:
+ *         return "base16384_err_invalid_commandline_parameter"
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(__pyx_n_u_base16384_err_invalid_file_name);
+    __pyx_r = __pyx_n_u_base16384_err_invalid_file_name;
+    goto __pyx_L0;
+
+    /* "pybase16384/backends/cython/_core.pyx":224
+ *     elif ret == base16384_err_read_file:
+ *         return "base16384_err_read_file"
+ *     elif ret == base16384_err_invalid_file_name:             # <<<<<<<<<<<<<<
+ *         return "base16384_err_invalid_file_name"
+ *     elif ret == base16384_err_invalid_commandline_parameter:
+ */
+    break;
+    case base16384_err_invalid_commandline_parameter:
+
+    /* "pybase16384/backends/cython/_core.pyx":227
+ *         return "base16384_err_invalid_file_name"
+ *     elif ret == base16384_err_invalid_commandline_parameter:
+ *         return "base16384_err_invalid_commandline_parameter"             # <<<<<<<<<<<<<<
+ *     elif ret == base16384_err_invalid_decoding_checksum:
+ *         return "base16384_err_invalid_decoding_checksum"
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(__pyx_n_u_base16384_err_invalid_commandlin);
+    __pyx_r = __pyx_n_u_base16384_err_invalid_commandlin;
+    goto __pyx_L0;
+
+    /* "pybase16384/backends/cython/_core.pyx":226
+ *     elif ret == base16384_err_invalid_file_name:
+ *         return "base16384_err_invalid_file_name"
+ *     elif ret == base16384_err_invalid_commandline_parameter:             # <<<<<<<<<<<<<<
+ *         return "base16384_err_invalid_commandline_parameter"
+ *     elif ret == base16384_err_invalid_decoding_checksum:
+ */
+    break;
+    case base16384_err_invalid_decoding_checksum:
+
+    /* "pybase16384/backends/cython/_core.pyx":229
+ *         return "base16384_err_invalid_commandline_parameter"
+ *     elif ret == base16384_err_invalid_decoding_checksum:
+ *         return "base16384_err_invalid_decoding_checksum"             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline encode_local_file(object inp, object out):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __Pyx_INCREF(__pyx_n_u_base16384_err_invalid_decoding_c);
+    __pyx_r = __pyx_n_u_base16384_err_invalid_decoding_c;
+    goto __pyx_L0;
+
+    /* "pybase16384/backends/cython/_core.pyx":228
+ *     elif ret == base16384_err_invalid_commandline_parameter:
+ *         return "base16384_err_invalid_commandline_parameter"
+ *     elif ret == base16384_err_invalid_decoding_checksum:             # <<<<<<<<<<<<<<
+ *         return "base16384_err_invalid_decoding_checksum"
  * 
  */
     break;
     default: break;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":201
+  /* "pybase16384/backends/cython/_core.pyx":209
  *     return pybase16384_64bits()
  * 
  * cdef inline str err_to_str(base16384_err_t ret):             # <<<<<<<<<<<<<<
  *     if ret == base16384_err_get_file_size:
  *         return "base16384_err_get_file_size"
  */
 
@@ -21840,16 +22050,16 @@
   __pyx_r = ((PyObject*)Py_None); __Pyx_INCREF(Py_None);
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":215
- *         return "base16384_err_map_input_file"
+/* "pybase16384/backends/cython/_core.pyx":231
+ *         return "base16384_err_invalid_decoding_checksum"
  * 
  * cpdef inline encode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
 
 static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_19encode_local_file(PyObject *__pyx_self, 
@@ -21884,159 +22094,159 @@
   PyObject *__pyx_t_13 = NULL;
   PyObject *__pyx_t_14 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encode_local_file", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":216
+  /* "pybase16384/backends/cython/_core.pyx":232
  * 
  * cpdef inline encode_local_file(object inp, object out):
  *     cdef bytes inp_name = ensure_bytes(inp)             # <<<<<<<<<<<<<<
  *     cdef bytes out_name = ensure_bytes(out)
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_inp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_inp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 232, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_inp_name = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":217
+  /* "pybase16384/backends/cython/_core.pyx":233
  * cpdef inline encode_local_file(object inp, object out):
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)             # <<<<<<<<<<<<<<
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  *     cdef const char * out_name_ptr = <const char *> out_name
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 217, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 233, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_out_name = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":218
+  /* "pybase16384/backends/cython/_core.pyx":234
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  *     cdef const char * inp_name_ptr = <const char *> inp_name             # <<<<<<<<<<<<<<
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  */
   if (unlikely(__pyx_v_inp_name == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(0, 218, __pyx_L1_error)
+    __PYX_ERR(0, 234, __pyx_L1_error)
   }
-  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_inp_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 218, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_inp_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 234, __pyx_L1_error)
   __pyx_v_inp_name_ptr = ((char const *)__pyx_t_2);
 
-  /* "pybase16384/backends/cython/_core.pyx":219
+  /* "pybase16384/backends/cython/_core.pyx":235
  *     cdef bytes out_name = ensure_bytes(out)
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  *     cdef const char * out_name_ptr = <const char *> out_name             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
   if (unlikely(__pyx_v_out_name == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(0, 219, __pyx_L1_error)
+    __PYX_ERR(0, 235, __pyx_L1_error)
   }
-  __pyx_t_3 = __Pyx_PyBytes_AsString(__pyx_v_out_name); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 219, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyBytes_AsString(__pyx_v_out_name); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 235, __pyx_L1_error)
   __pyx_v_out_name_ptr = ((char const *)__pyx_t_3);
 
-  /* "pybase16384/backends/cython/_core.pyx":220
+  /* "pybase16384/backends/cython/_core.pyx":236
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
  *     if encbuf == NULL:
  *         raise MemoryError
  */
   __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":221
+  /* "pybase16384/backends/cython/_core.pyx":237
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   __pyx_t_4 = (__pyx_v_encbuf == NULL);
   if (unlikely(__pyx_t_4)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":222
+    /* "pybase16384/backends/cython/_core.pyx":238
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 222, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 238, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":221
+    /* "pybase16384/backends/cython/_core.pyx":237
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":223
+  /* "pybase16384/backends/cython/_core.pyx":239
  *     if encbuf == NULL:
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  */
   __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":224
+  /* "pybase16384/backends/cython/_core.pyx":240
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   __pyx_t_4 = (__pyx_v_decbuf == NULL);
   if (unlikely(__pyx_t_4)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":225
+    /* "pybase16384/backends/cython/_core.pyx":241
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef base16384_err_t ret
  */
     PyMem_Free(__pyx_v_encbuf);
 
-    /* "pybase16384/backends/cython/_core.pyx":226
+    /* "pybase16384/backends/cython/_core.pyx":242
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef base16384_err_t ret
  *     try:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 226, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 242, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":224
+    /* "pybase16384/backends/cython/_core.pyx":240
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":228
+  /* "pybase16384/backends/cython/_core.pyx":244
  *         raise MemoryError
  *     cdef base16384_err_t ret
  *     try:             # <<<<<<<<<<<<<<
  *         with nogil:
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":229
+    /* "pybase16384/backends/cython/_core.pyx":245
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:
  */
     {
@@ -22044,25 +22254,25 @@
         PyThreadState *_save;
         _save = NULL;
         Py_UNBLOCK_THREADS
         __Pyx_FastGIL_Remember();
         #endif
         /*try:*/ {
 
-          /* "pybase16384/backends/cython/_core.pyx":230
+          /* "pybase16384/backends/cython/_core.pyx":246
  *     try:
  *         with nogil:
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)             # <<<<<<<<<<<<<<
  *         if ret !=  base16384_err_ok:
  *             raise ValueError(err_to_str(ret))
  */
           __pyx_v_ret = base16384_encode_file(__pyx_v_inp_name_ptr, __pyx_v_out_name_ptr, __pyx_v_encbuf, __pyx_v_decbuf);
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":229
+        /* "pybase16384/backends/cython/_core.pyx":245
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:
  */
         /*finally:*/ {
@@ -22073,62 +22283,62 @@
             #endif
             goto __pyx_L10;
           }
           __pyx_L10:;
         }
     }
 
-    /* "pybase16384/backends/cython/_core.pyx":231
+    /* "pybase16384/backends/cython/_core.pyx":247
  *         with nogil:
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     __pyx_t_4 = (__pyx_v_ret != base16384_err_ok);
     if (unlikely(__pyx_t_4)) {
 
-      /* "pybase16384/backends/cython/_core.pyx":232
+      /* "pybase16384/backends/cython/_core.pyx":248
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:
  *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(encbuf)
  */
-      __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 232, __pyx_L6_error)
+      __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 232, __pyx_L6_error)
+      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 248, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(0, 232, __pyx_L6_error)
+      __PYX_ERR(0, 248, __pyx_L6_error)
 
-      /* "pybase16384/backends/cython/_core.pyx":231
+      /* "pybase16384/backends/cython/_core.pyx":247
  *         with nogil:
  *             ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":234
+  /* "pybase16384/backends/cython/_core.pyx":250
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
  * 
  */
   /*finally:*/ {
     /*normal exit:*/{
       PyMem_Free(__pyx_v_encbuf);
 
-      /* "pybase16384/backends/cython/_core.pyx":235
+      /* "pybase16384/backends/cython/_core.pyx":251
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline decode_local_file(object inp, object out):
  */
       PyMem_Free(__pyx_v_decbuf);
@@ -22148,24 +22358,24 @@
       __Pyx_XGOTREF(__pyx_t_11);
       __Pyx_XGOTREF(__pyx_t_12);
       __Pyx_XGOTREF(__pyx_t_13);
       __Pyx_XGOTREF(__pyx_t_14);
       __pyx_t_6 = __pyx_lineno; __pyx_t_7 = __pyx_clineno; __pyx_t_8 = __pyx_filename;
       {
 
-        /* "pybase16384/backends/cython/_core.pyx":234
+        /* "pybase16384/backends/cython/_core.pyx":250
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
  * 
  */
         PyMem_Free(__pyx_v_encbuf);
 
-        /* "pybase16384/backends/cython/_core.pyx":235
+        /* "pybase16384/backends/cython/_core.pyx":251
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline decode_local_file(object inp, object out):
  */
         PyMem_Free(__pyx_v_decbuf);
@@ -22183,16 +22393,16 @@
       __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0;
       __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_7; __pyx_filename = __pyx_t_8;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":215
- *         return "base16384_err_map_input_file"
+  /* "pybase16384/backends/cython/_core.pyx":231
+ *         return "base16384_err_invalid_decoding_checksum"
  * 
  * cpdef inline encode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
 
   /* function exit code */
@@ -22264,43 +22474,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 215, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 231, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 215, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 231, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("encode_local_file", 1, 2, 2, 1); __PYX_ERR(0, 215, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("encode_local_file", 1, 2, 2, 1); __PYX_ERR(0, 231, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_local_file") < 0)) __PYX_ERR(0, 215, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_local_file") < 0)) __PYX_ERR(0, 231, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
     __pyx_v_inp = values[0];
     __pyx_v_out = values[1];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encode_local_file", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 215, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encode_local_file", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 231, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -22328,15 +22538,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encode_local_file", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_local_file(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 215, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_local_file(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 231, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -22345,15 +22555,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":237
+/* "pybase16384/backends/cython/_core.pyx":253
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
 
@@ -22389,159 +22599,159 @@
   PyObject *__pyx_t_13 = NULL;
   PyObject *__pyx_t_14 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decode_local_file", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":238
+  /* "pybase16384/backends/cython/_core.pyx":254
  * 
  * cpdef inline decode_local_file(object inp, object out):
  *     cdef bytes inp_name = ensure_bytes(inp)             # <<<<<<<<<<<<<<
  *     cdef bytes out_name = ensure_bytes(out)
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_inp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_inp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 254, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_inp_name = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":239
+  /* "pybase16384/backends/cython/_core.pyx":255
  * cpdef inline decode_local_file(object inp, object out):
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)             # <<<<<<<<<<<<<<
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  *     cdef const char * out_name_ptr = <const char *> out_name
  */
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 255, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_out_name = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":240
+  /* "pybase16384/backends/cython/_core.pyx":256
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  *     cdef const char * inp_name_ptr = <const char *> inp_name             # <<<<<<<<<<<<<<
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  */
   if (unlikely(__pyx_v_inp_name == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(0, 240, __pyx_L1_error)
+    __PYX_ERR(0, 256, __pyx_L1_error)
   }
-  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_inp_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 240, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_inp_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L1_error)
   __pyx_v_inp_name_ptr = ((char const *)__pyx_t_2);
 
-  /* "pybase16384/backends/cython/_core.pyx":241
+  /* "pybase16384/backends/cython/_core.pyx":257
  *     cdef bytes out_name = ensure_bytes(out)
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  *     cdef const char * out_name_ptr = <const char *> out_name             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
   if (unlikely(__pyx_v_out_name == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(0, 241, __pyx_L1_error)
+    __PYX_ERR(0, 257, __pyx_L1_error)
   }
-  __pyx_t_3 = __Pyx_PyBytes_AsString(__pyx_v_out_name); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 241, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyBytes_AsString(__pyx_v_out_name); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 257, __pyx_L1_error)
   __pyx_v_out_name_ptr = ((char const *)__pyx_t_3);
 
-  /* "pybase16384/backends/cython/_core.pyx":242
+  /* "pybase16384/backends/cython/_core.pyx":258
  *     cdef const char * inp_name_ptr = <const char *> inp_name
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
  *     if encbuf == NULL:
  *         raise MemoryError
  */
   __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":243
+  /* "pybase16384/backends/cython/_core.pyx":259
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   __pyx_t_4 = (__pyx_v_encbuf == NULL);
   if (unlikely(__pyx_t_4)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":244
+    /* "pybase16384/backends/cython/_core.pyx":260
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 244, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 260, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":243
+    /* "pybase16384/backends/cython/_core.pyx":259
  *     cdef const char * out_name_ptr = <const char *> out_name
  *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":245
+  /* "pybase16384/backends/cython/_core.pyx":261
  *     if encbuf == NULL:
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  */
   __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":246
+  /* "pybase16384/backends/cython/_core.pyx":262
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   __pyx_t_4 = (__pyx_v_decbuf == NULL);
   if (unlikely(__pyx_t_4)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":247
+    /* "pybase16384/backends/cython/_core.pyx":263
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef base16384_err_t ret
  */
     PyMem_Free(__pyx_v_encbuf);
 
-    /* "pybase16384/backends/cython/_core.pyx":248
+    /* "pybase16384/backends/cython/_core.pyx":264
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef base16384_err_t ret
  *     try:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 248, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 264, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":246
+    /* "pybase16384/backends/cython/_core.pyx":262
  *         raise MemoryError
  *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":250
+  /* "pybase16384/backends/cython/_core.pyx":266
  *         raise MemoryError
  *     cdef base16384_err_t ret
  *     try:             # <<<<<<<<<<<<<<
  *         with nogil:
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":251
+    /* "pybase16384/backends/cython/_core.pyx":267
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:
  */
     {
@@ -22549,25 +22759,25 @@
         PyThreadState *_save;
         _save = NULL;
         Py_UNBLOCK_THREADS
         __Pyx_FastGIL_Remember();
         #endif
         /*try:*/ {
 
-          /* "pybase16384/backends/cython/_core.pyx":252
+          /* "pybase16384/backends/cython/_core.pyx":268
  *     try:
  *         with nogil:
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)             # <<<<<<<<<<<<<<
  *         if ret !=  base16384_err_ok:
  *             raise ValueError(err_to_str(ret))
  */
           __pyx_v_ret = base16384_decode_file(__pyx_v_inp_name_ptr, __pyx_v_out_name_ptr, __pyx_v_encbuf, __pyx_v_decbuf);
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":251
+        /* "pybase16384/backends/cython/_core.pyx":267
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:
  */
         /*finally:*/ {
@@ -22578,62 +22788,62 @@
             #endif
             goto __pyx_L10;
           }
           __pyx_L10:;
         }
     }
 
-    /* "pybase16384/backends/cython/_core.pyx":253
+    /* "pybase16384/backends/cython/_core.pyx":269
  *         with nogil:
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     __pyx_t_4 = (__pyx_v_ret != base16384_err_ok);
     if (unlikely(__pyx_t_4)) {
 
-      /* "pybase16384/backends/cython/_core.pyx":254
+      /* "pybase16384/backends/cython/_core.pyx":270
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:
  *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(encbuf)
  */
-      __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 254, __pyx_L6_error)
+      __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 270, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 254, __pyx_L6_error)
+      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 270, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(0, 254, __pyx_L6_error)
+      __PYX_ERR(0, 270, __pyx_L6_error)
 
-      /* "pybase16384/backends/cython/_core.pyx":253
+      /* "pybase16384/backends/cython/_core.pyx":269
  *         with nogil:
  *             ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
  *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":256
+  /* "pybase16384/backends/cython/_core.pyx":272
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
  * 
  */
   /*finally:*/ {
     /*normal exit:*/{
       PyMem_Free(__pyx_v_encbuf);
 
-      /* "pybase16384/backends/cython/_core.pyx":257
+      /* "pybase16384/backends/cython/_core.pyx":273
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline encode_fd(int inp, int out):
  */
       PyMem_Free(__pyx_v_decbuf);
@@ -22653,24 +22863,24 @@
       __Pyx_XGOTREF(__pyx_t_11);
       __Pyx_XGOTREF(__pyx_t_12);
       __Pyx_XGOTREF(__pyx_t_13);
       __Pyx_XGOTREF(__pyx_t_14);
       __pyx_t_6 = __pyx_lineno; __pyx_t_7 = __pyx_clineno; __pyx_t_8 = __pyx_filename;
       {
 
-        /* "pybase16384/backends/cython/_core.pyx":256
+        /* "pybase16384/backends/cython/_core.pyx":272
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
  * 
  */
         PyMem_Free(__pyx_v_encbuf);
 
-        /* "pybase16384/backends/cython/_core.pyx":257
+        /* "pybase16384/backends/cython/_core.pyx":273
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline encode_fd(int inp, int out):
  */
         PyMem_Free(__pyx_v_decbuf);
@@ -22688,15 +22898,15 @@
       __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0;
       __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_7; __pyx_filename = __pyx_t_8;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":237
+  /* "pybase16384/backends/cython/_core.pyx":253
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
 
@@ -22769,43 +22979,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 237, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 253, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 237, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 253, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("decode_local_file", 1, 2, 2, 1); __PYX_ERR(0, 237, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decode_local_file", 1, 2, 2, 1); __PYX_ERR(0, 253, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_local_file") < 0)) __PYX_ERR(0, 237, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_local_file") < 0)) __PYX_ERR(0, 253, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
     __pyx_v_inp = values[0];
     __pyx_v_out = values[1];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decode_local_file", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 237, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decode_local_file", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 253, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -22833,15 +23043,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decode_local_file", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_local_file(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_local_file(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -22850,15 +23060,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":259
+/* "pybase16384/backends/cython/_core.pyx":275
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline encode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
 
@@ -22888,107 +23098,107 @@
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encode_fd", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":260
+  /* "pybase16384/backends/cython/_core.pyx":276
  * 
  * cpdef inline encode_fd(int inp, int out):
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
  *     if encbuf == NULL:
  *         raise MemoryError
  */
   __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":261
+  /* "pybase16384/backends/cython/_core.pyx":277
  * cpdef inline encode_fd(int inp, int out):
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   __pyx_t_1 = (__pyx_v_encbuf == NULL);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":262
+    /* "pybase16384/backends/cython/_core.pyx":278
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 262, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 278, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":261
+    /* "pybase16384/backends/cython/_core.pyx":277
  * cpdef inline encode_fd(int inp, int out):
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":263
+  /* "pybase16384/backends/cython/_core.pyx":279
  *     if encbuf == NULL:
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  */
   __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":264
+  /* "pybase16384/backends/cython/_core.pyx":280
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   __pyx_t_1 = (__pyx_v_decbuf == NULL);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":265
+    /* "pybase16384/backends/cython/_core.pyx":281
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef base16384_err_t ret
  */
     PyMem_Free(__pyx_v_encbuf);
 
-    /* "pybase16384/backends/cython/_core.pyx":266
+    /* "pybase16384/backends/cython/_core.pyx":282
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef base16384_err_t ret
  *     try:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 266, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 282, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":264
+    /* "pybase16384/backends/cython/_core.pyx":280
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":268
+  /* "pybase16384/backends/cython/_core.pyx":284
  *         raise MemoryError
  *     cdef base16384_err_t ret
  *     try:             # <<<<<<<<<<<<<<
  *         with nogil:
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":269
+    /* "pybase16384/backends/cython/_core.pyx":285
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:
  */
     {
@@ -22996,25 +23206,25 @@
         PyThreadState *_save;
         _save = NULL;
         Py_UNBLOCK_THREADS
         __Pyx_FastGIL_Remember();
         #endif
         /*try:*/ {
 
-          /* "pybase16384/backends/cython/_core.pyx":270
+          /* "pybase16384/backends/cython/_core.pyx":286
  *     try:
  *         with nogil:
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)             # <<<<<<<<<<<<<<
  *         if ret != base16384_err_ok:
  *             raise ValueError(err_to_str(ret))
  */
           __pyx_v_ret = base16384_encode_fd(__pyx_v_inp, __pyx_v_out, __pyx_v_encbuf, __pyx_v_decbuf);
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":269
+        /* "pybase16384/backends/cython/_core.pyx":285
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:
  */
         /*finally:*/ {
@@ -23025,62 +23235,62 @@
             #endif
             goto __pyx_L10;
           }
           __pyx_L10:;
         }
     }
 
-    /* "pybase16384/backends/cython/_core.pyx":271
+    /* "pybase16384/backends/cython/_core.pyx":287
  *         with nogil:
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     __pyx_t_1 = (__pyx_v_ret != base16384_err_ok);
     if (unlikely(__pyx_t_1)) {
 
-      /* "pybase16384/backends/cython/_core.pyx":272
+      /* "pybase16384/backends/cython/_core.pyx":288
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:
  *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(encbuf)
  */
-      __pyx_t_2 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 272, __pyx_L6_error)
+      __pyx_t_2 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 288, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 272, __pyx_L6_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 288, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 272, __pyx_L6_error)
+      __PYX_ERR(0, 288, __pyx_L6_error)
 
-      /* "pybase16384/backends/cython/_core.pyx":271
+      /* "pybase16384/backends/cython/_core.pyx":287
  *         with nogil:
  *             ret = b14_encode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":274
+  /* "pybase16384/backends/cython/_core.pyx":290
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
  * 
  */
   /*finally:*/ {
     /*normal exit:*/{
       PyMem_Free(__pyx_v_encbuf);
 
-      /* "pybase16384/backends/cython/_core.pyx":275
+      /* "pybase16384/backends/cython/_core.pyx":291
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline decode_fd(int inp, int out):
  */
       PyMem_Free(__pyx_v_decbuf);
@@ -23100,24 +23310,24 @@
       __Pyx_XGOTREF(__pyx_t_9);
       __Pyx_XGOTREF(__pyx_t_10);
       __Pyx_XGOTREF(__pyx_t_11);
       __Pyx_XGOTREF(__pyx_t_12);
       __pyx_t_4 = __pyx_lineno; __pyx_t_5 = __pyx_clineno; __pyx_t_6 = __pyx_filename;
       {
 
-        /* "pybase16384/backends/cython/_core.pyx":274
+        /* "pybase16384/backends/cython/_core.pyx":290
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
  * 
  */
         PyMem_Free(__pyx_v_encbuf);
 
-        /* "pybase16384/backends/cython/_core.pyx":275
+        /* "pybase16384/backends/cython/_core.pyx":291
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
  * 
  * cpdef inline decode_fd(int inp, int out):
  */
         PyMem_Free(__pyx_v_decbuf);
@@ -23135,15 +23345,15 @@
       __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":259
+  /* "pybase16384/backends/cython/_core.pyx":275
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline encode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
 
@@ -23214,43 +23424,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 259, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 275, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 259, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 275, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("encode_fd", 1, 2, 2, 1); __PYX_ERR(0, 259, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("encode_fd", 1, 2, 2, 1); __PYX_ERR(0, 275, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_fd") < 0)) __PYX_ERR(0, 259, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_fd") < 0)) __PYX_ERR(0, 275, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_inp = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_inp == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 259, __pyx_L3_error)
-    __pyx_v_out = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_out == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 259, __pyx_L3_error)
+    __pyx_v_inp = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_inp == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 275, __pyx_L3_error)
+    __pyx_v_out = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_out == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 275, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("encode_fd", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 259, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("encode_fd", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 275, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -23278,15 +23488,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("encode_fd", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_fd(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_fd(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 275, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -23295,15 +23505,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pybase16384/backends/cython/_core.pyx":277
+/* "pybase16384/backends/cython/_core.pyx":293
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
 
@@ -23333,107 +23543,107 @@
   PyObject *__pyx_t_11 = NULL;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decode_fd", 1);
 
-  /* "pybase16384/backends/cython/_core.pyx":278
+  /* "pybase16384/backends/cython/_core.pyx":294
  * 
  * cpdef inline decode_fd(int inp, int out):
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
  *     if encbuf == NULL:
  *         raise MemoryError
  */
   __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":279
+  /* "pybase16384/backends/cython/_core.pyx":295
  * cpdef inline decode_fd(int inp, int out):
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   __pyx_t_1 = (__pyx_v_encbuf == NULL);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":280
+    /* "pybase16384/backends/cython/_core.pyx":296
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 280, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 296, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":279
+    /* "pybase16384/backends/cython/_core.pyx":295
  * cpdef inline decode_fd(int inp, int out):
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":281
+  /* "pybase16384/backends/cython/_core.pyx":297
  *     if encbuf == NULL:
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  */
   __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
 
-  /* "pybase16384/backends/cython/_core.pyx":282
+  /* "pybase16384/backends/cython/_core.pyx":298
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   __pyx_t_1 = (__pyx_v_decbuf == NULL);
   if (unlikely(__pyx_t_1)) {
 
-    /* "pybase16384/backends/cython/_core.pyx":283
+    /* "pybase16384/backends/cython/_core.pyx":299
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         raise MemoryError
  *     cdef base16384_err_t ret
  */
     PyMem_Free(__pyx_v_encbuf);
 
-    /* "pybase16384/backends/cython/_core.pyx":284
+    /* "pybase16384/backends/cython/_core.pyx":300
  *     if decbuf == NULL:
  *         PyMem_Free(encbuf)
  *         raise MemoryError             # <<<<<<<<<<<<<<
  *     cdef base16384_err_t ret
  *     try:
  */
-    PyErr_NoMemory(); __PYX_ERR(0, 284, __pyx_L1_error)
+    PyErr_NoMemory(); __PYX_ERR(0, 300, __pyx_L1_error)
 
-    /* "pybase16384/backends/cython/_core.pyx":282
+    /* "pybase16384/backends/cython/_core.pyx":298
  *         raise MemoryError
  *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
  *     if decbuf == NULL:             # <<<<<<<<<<<<<<
  *         PyMem_Free(encbuf)
  *         raise MemoryError
  */
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":286
+  /* "pybase16384/backends/cython/_core.pyx":302
  *         raise MemoryError
  *     cdef base16384_err_t ret
  *     try:             # <<<<<<<<<<<<<<
  *         with nogil:
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)
  */
   /*try:*/ {
 
-    /* "pybase16384/backends/cython/_core.pyx":287
+    /* "pybase16384/backends/cython/_core.pyx":303
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:
  */
     {
@@ -23441,25 +23651,25 @@
         PyThreadState *_save;
         _save = NULL;
         Py_UNBLOCK_THREADS
         __Pyx_FastGIL_Remember();
         #endif
         /*try:*/ {
 
-          /* "pybase16384/backends/cython/_core.pyx":288
+          /* "pybase16384/backends/cython/_core.pyx":304
  *     try:
  *         with nogil:
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)             # <<<<<<<<<<<<<<
  *         if ret != base16384_err_ok:
  *             raise ValueError(err_to_str(ret))
  */
           __pyx_v_ret = base16384_decode_fd(__pyx_v_inp, __pyx_v_out, __pyx_v_encbuf, __pyx_v_decbuf);
         }
 
-        /* "pybase16384/backends/cython/_core.pyx":287
+        /* "pybase16384/backends/cython/_core.pyx":303
  *     cdef base16384_err_t ret
  *     try:
  *         with nogil:             # <<<<<<<<<<<<<<
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:
  */
         /*finally:*/ {
@@ -23470,64 +23680,67 @@
             #endif
             goto __pyx_L10;
           }
           __pyx_L10:;
         }
     }
 
-    /* "pybase16384/backends/cython/_core.pyx":289
+    /* "pybase16384/backends/cython/_core.pyx":305
  *         with nogil:
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     __pyx_t_1 = (__pyx_v_ret != base16384_err_ok);
     if (unlikely(__pyx_t_1)) {
 
-      /* "pybase16384/backends/cython/_core.pyx":290
+      /* "pybase16384/backends/cython/_core.pyx":306
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:
  *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
  *     finally:
  *         PyMem_Free(encbuf)
  */
-      __pyx_t_2 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L6_error)
+      __pyx_t_2 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 306, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 290, __pyx_L6_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 306, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 290, __pyx_L6_error)
+      __PYX_ERR(0, 306, __pyx_L6_error)
 
-      /* "pybase16384/backends/cython/_core.pyx":289
+      /* "pybase16384/backends/cython/_core.pyx":305
  *         with nogil:
  *             ret = b14_decode_fd(inp, out, encbuf, decbuf)
  *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
  *             raise ValueError(err_to_str(ret))
  *     finally:
  */
     }
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":292
+  /* "pybase16384/backends/cython/_core.pyx":308
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
+ * 
  */
   /*finally:*/ {
     /*normal exit:*/{
       PyMem_Free(__pyx_v_encbuf);
 
-      /* "pybase16384/backends/cython/_core.pyx":293
+      /* "pybase16384/backends/cython/_core.pyx":309
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * # detailed
  */
       PyMem_Free(__pyx_v_decbuf);
       goto __pyx_L7;
     }
     __pyx_L6_error:;
     /*exception exit:*/{
       __Pyx_PyThreadState_declare
@@ -23542,26 +23755,29 @@
       __Pyx_XGOTREF(__pyx_t_9);
       __Pyx_XGOTREF(__pyx_t_10);
       __Pyx_XGOTREF(__pyx_t_11);
       __Pyx_XGOTREF(__pyx_t_12);
       __pyx_t_4 = __pyx_lineno; __pyx_t_5 = __pyx_clineno; __pyx_t_6 = __pyx_filename;
       {
 
-        /* "pybase16384/backends/cython/_core.pyx":292
+        /* "pybase16384/backends/cython/_core.pyx":308
  *             raise ValueError(err_to_str(ret))
  *     finally:
  *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
  *         PyMem_Free(decbuf)
+ * 
  */
         PyMem_Free(__pyx_v_encbuf);
 
-        /* "pybase16384/backends/cython/_core.pyx":293
+        /* "pybase16384/backends/cython/_core.pyx":309
  *     finally:
  *         PyMem_Free(encbuf)
  *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * # detailed
  */
         PyMem_Free(__pyx_v_decbuf);
       }
       if (PY_MAJOR_VERSION >= 3) {
         __Pyx_XGIVEREF(__pyx_t_10);
         __Pyx_XGIVEREF(__pyx_t_11);
         __Pyx_XGIVEREF(__pyx_t_12);
@@ -23574,15 +23790,15 @@
       __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
       __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "pybase16384/backends/cython/_core.pyx":277
+  /* "pybase16384/backends/cython/_core.pyx":293
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
 
@@ -23653,43 +23869,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 277, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 293, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 277, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 293, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("decode_fd", 1, 2, 2, 1); __PYX_ERR(0, 277, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("decode_fd", 1, 2, 2, 1); __PYX_ERR(0, 293, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_fd") < 0)) __PYX_ERR(0, 277, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_fd") < 0)) __PYX_ERR(0, 293, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_inp = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_inp == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 277, __pyx_L3_error)
-    __pyx_v_out = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_out == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 277, __pyx_L3_error)
+    __pyx_v_inp = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_inp == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 293, __pyx_L3_error)
+    __pyx_v_out = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_out == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 293, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("decode_fd", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 277, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("decode_fd", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 293, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -23717,15 +23933,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("decode_fd", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_fd(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_fd(__pyx_v_inp, __pyx_v_out, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 293, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -23733,14 +23949,1968 @@
   __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_fd", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
+
+/* "pybase16384/backends/cython/_core.pyx":312
+ * 
+ * # detailed
+ * cpdef inline encode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_27encode_local_file_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_encode_local_file_detailed(PyObject *__pyx_v_inp, PyObject *__pyx_v_out, int __pyx_v_flag, CYTHON_UNUSED int __pyx_skip_dispatch) {
+  PyObject *__pyx_v_inp_name = 0;
+  PyObject *__pyx_v_out_name = 0;
+  char const *__pyx_v_inp_name_ptr;
+  char const *__pyx_v_out_name_ptr;
+  char *__pyx_v_encbuf;
+  char *__pyx_v_decbuf;
+  base16384_err_t __pyx_v_ret;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  char const *__pyx_t_2;
+  char const *__pyx_t_3;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  char const *__pyx_t_8;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("encode_local_file_detailed", 1);
+
+  /* "pybase16384/backends/cython/_core.pyx":313
+ * # detailed
+ * cpdef inline encode_local_file_detailed(object inp, object out, int flag):
+ *     cdef bytes inp_name = ensure_bytes(inp)             # <<<<<<<<<<<<<<
+ *     cdef bytes out_name = ensure_bytes(out)
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ */
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_inp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 313, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_inp_name = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":314
+ * cpdef inline encode_local_file_detailed(object inp, object out, int flag):
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)             # <<<<<<<<<<<<<<
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ */
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 314, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_out_name = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":315
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ *     cdef const char * inp_name_ptr = <const char *> inp_name             # <<<<<<<<<<<<<<
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ */
+  if (unlikely(__pyx_v_inp_name == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
+    __PYX_ERR(0, 315, __pyx_L1_error)
+  }
+  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_inp_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 315, __pyx_L1_error)
+  __pyx_v_inp_name_ptr = ((char const *)__pyx_t_2);
+
+  /* "pybase16384/backends/cython/_core.pyx":316
+ *     cdef bytes out_name = ensure_bytes(out)
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ *     cdef const char * out_name_ptr = <const char *> out_name             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+  if (unlikely(__pyx_v_out_name == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
+    __PYX_ERR(0, 316, __pyx_L1_error)
+  }
+  __pyx_t_3 = __Pyx_PyBytes_AsString(__pyx_v_out_name); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 316, __pyx_L1_error)
+  __pyx_v_out_name_ptr = ((char const *)__pyx_t_3);
+
+  /* "pybase16384/backends/cython/_core.pyx":317
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ */
+  __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":318
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  __pyx_t_4 = (__pyx_v_encbuf == NULL);
+  if (unlikely(__pyx_t_4)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":319
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 319, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":318
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":320
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ */
+  __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":321
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  __pyx_t_4 = (__pyx_v_decbuf == NULL);
+  if (unlikely(__pyx_t_4)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":322
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ */
+    PyMem_Free(__pyx_v_encbuf);
+
+    /* "pybase16384/backends/cython/_core.pyx":323
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef base16384_err_t ret
+ *     try:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 323, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":321
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":325
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ *     try:             # <<<<<<<<<<<<<<
+ *         with nogil:
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ */
+  /*try:*/ {
+
+    /* "pybase16384/backends/cython/_core.pyx":326
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        _save = NULL;
+        Py_UNBLOCK_THREADS
+        __Pyx_FastGIL_Remember();
+        #endif
+        /*try:*/ {
+
+          /* "pybase16384/backends/cython/_core.pyx":327
+ *     try:
+ *         with nogil:
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)             # <<<<<<<<<<<<<<
+ *         if ret !=  base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))
+ */
+          __pyx_v_ret = base16384_encode_file_detailed(__pyx_v_inp_name_ptr, __pyx_v_out_name_ptr, __pyx_v_encbuf, __pyx_v_decbuf, __pyx_v_flag);
+        }
+
+        /* "pybase16384/backends/cython/_core.pyx":326
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:
+ */
+        /*finally:*/ {
+          /*normal exit:*/{
+            #ifdef WITH_THREAD
+            __Pyx_FastGIL_Forget();
+            Py_BLOCK_THREADS
+            #endif
+            goto __pyx_L10;
+          }
+          __pyx_L10:;
+        }
+    }
+
+    /* "pybase16384/backends/cython/_core.pyx":328
+ *         with nogil:
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    __pyx_t_4 = (__pyx_v_ret != base16384_err_ok);
+    if (unlikely(__pyx_t_4)) {
+
+      /* "pybase16384/backends/cython/_core.pyx":329
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
+ *     finally:
+ *         PyMem_Free(encbuf)
+ */
+      __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 329, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 329, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __PYX_ERR(0, 329, __pyx_L6_error)
+
+      /* "pybase16384/backends/cython/_core.pyx":328
+ *         with nogil:
+ *             ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    }
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":331
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ * 
+ */
+  /*finally:*/ {
+    /*normal exit:*/{
+      PyMem_Free(__pyx_v_encbuf);
+
+      /* "pybase16384/backends/cython/_core.pyx":332
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):
+ */
+      PyMem_Free(__pyx_v_decbuf);
+      goto __pyx_L7;
+    }
+    __pyx_L6_error:;
+    /*exception exit:*/{
+      __Pyx_PyThreadState_declare
+      __Pyx_PyThreadState_assign
+      __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0;
+      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11) < 0)) __Pyx_ErrFetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_9);
+      __Pyx_XGOTREF(__pyx_t_10);
+      __Pyx_XGOTREF(__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_12);
+      __Pyx_XGOTREF(__pyx_t_13);
+      __Pyx_XGOTREF(__pyx_t_14);
+      __pyx_t_6 = __pyx_lineno; __pyx_t_7 = __pyx_clineno; __pyx_t_8 = __pyx_filename;
+      {
+
+        /* "pybase16384/backends/cython/_core.pyx":331
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ * 
+ */
+        PyMem_Free(__pyx_v_encbuf);
+
+        /* "pybase16384/backends/cython/_core.pyx":332
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):
+ */
+        PyMem_Free(__pyx_v_decbuf);
+      }
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_12);
+        __Pyx_XGIVEREF(__pyx_t_13);
+        __Pyx_XGIVEREF(__pyx_t_14);
+        __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_13, __pyx_t_14);
+      }
+      __Pyx_XGIVEREF(__pyx_t_9);
+      __Pyx_XGIVEREF(__pyx_t_10);
+      __Pyx_XGIVEREF(__pyx_t_11);
+      __Pyx_ErrRestore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
+      __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0;
+      __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_7; __pyx_filename = __pyx_t_8;
+      goto __pyx_L1_error;
+    }
+    __pyx_L7:;
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":312
+ * 
+ * # detailed
+ * cpdef inline encode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_local_file_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_inp_name);
+  __Pyx_XDECREF(__pyx_v_out_name);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_27encode_local_file_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+PyDoc_STRVAR(__pyx_doc_11pybase16384_8backends_6cython_5_core_26encode_local_file_detailed, "encode_local_file_detailed(inp, out, int flag)");
+static PyMethodDef __pyx_mdef_11pybase16384_8backends_6cython_5_core_27encode_local_file_detailed = {"encode_local_file_detailed", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_11pybase16384_8backends_6cython_5_core_27encode_local_file_detailed, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_11pybase16384_8backends_6cython_5_core_26encode_local_file_detailed};
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_27encode_local_file_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_inp = 0;
+  PyObject *__pyx_v_out = 0;
+  int __pyx_v_flag;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[3] = {0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("encode_local_file_detailed (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_inp,&__pyx_n_s_out,&__pyx_n_s_flag,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 312, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 312, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("encode_local_file_detailed", 1, 3, 3, 1); __PYX_ERR(0, 312, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_flag)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 312, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("encode_local_file_detailed", 1, 3, 3, 2); __PYX_ERR(0, 312, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_local_file_detailed") < 0)) __PYX_ERR(0, 312, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 3)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+    }
+    __pyx_v_inp = values[0];
+    __pyx_v_out = values[1];
+    __pyx_v_flag = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_flag == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 312, __pyx_L3_error)
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("encode_local_file_detailed", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 312, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_local_file_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_11pybase16384_8backends_6cython_5_core_26encode_local_file_detailed(__pyx_self, __pyx_v_inp, __pyx_v_out, __pyx_v_flag);
+
+  /* function exit code */
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_26encode_local_file_detailed(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_inp, PyObject *__pyx_v_out, int __pyx_v_flag) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("encode_local_file_detailed", 1);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_local_file_detailed(__pyx_v_inp, __pyx_v_out, __pyx_v_flag, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 312, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_local_file_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "pybase16384/backends/cython/_core.pyx":334
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_29decode_local_file_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_decode_local_file_detailed(PyObject *__pyx_v_inp, PyObject *__pyx_v_out, int __pyx_v_flag, CYTHON_UNUSED int __pyx_skip_dispatch) {
+  PyObject *__pyx_v_inp_name = 0;
+  PyObject *__pyx_v_out_name = 0;
+  char const *__pyx_v_inp_name_ptr;
+  char const *__pyx_v_out_name_ptr;
+  char *__pyx_v_encbuf;
+  char *__pyx_v_decbuf;
+  base16384_err_t __pyx_v_ret;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  char const *__pyx_t_2;
+  char const *__pyx_t_3;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  char const *__pyx_t_8;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_13 = NULL;
+  PyObject *__pyx_t_14 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("decode_local_file_detailed", 1);
+
+  /* "pybase16384/backends/cython/_core.pyx":335
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):
+ *     cdef bytes inp_name = ensure_bytes(inp)             # <<<<<<<<<<<<<<
+ *     cdef bytes out_name = ensure_bytes(out)
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ */
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_inp); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 335, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_inp_name = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":336
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)             # <<<<<<<<<<<<<<
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ */
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_ensure_bytes(__pyx_v_out); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 336, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v_out_name = ((PyObject*)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":337
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ *     cdef const char * inp_name_ptr = <const char *> inp_name             # <<<<<<<<<<<<<<
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ */
+  if (unlikely(__pyx_v_inp_name == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
+    __PYX_ERR(0, 337, __pyx_L1_error)
+  }
+  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_inp_name); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 337, __pyx_L1_error)
+  __pyx_v_inp_name_ptr = ((char const *)__pyx_t_2);
+
+  /* "pybase16384/backends/cython/_core.pyx":338
+ *     cdef bytes out_name = ensure_bytes(out)
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ *     cdef const char * out_name_ptr = <const char *> out_name             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+  if (unlikely(__pyx_v_out_name == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
+    __PYX_ERR(0, 338, __pyx_L1_error)
+  }
+  __pyx_t_3 = __Pyx_PyBytes_AsString(__pyx_v_out_name); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 338, __pyx_L1_error)
+  __pyx_v_out_name_ptr = ((char const *)__pyx_t_3);
+
+  /* "pybase16384/backends/cython/_core.pyx":339
+ *     cdef const char * inp_name_ptr = <const char *> inp_name
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ */
+  __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":340
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  __pyx_t_4 = (__pyx_v_encbuf == NULL);
+  if (unlikely(__pyx_t_4)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":341
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 341, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":340
+ *     cdef const char * out_name_ptr = <const char *> out_name
+ *     cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":342
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ */
+  __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":343
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  __pyx_t_4 = (__pyx_v_decbuf == NULL);
+  if (unlikely(__pyx_t_4)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":344
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ */
+    PyMem_Free(__pyx_v_encbuf);
+
+    /* "pybase16384/backends/cython/_core.pyx":345
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef base16384_err_t ret
+ *     try:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 345, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":343
+ *         raise MemoryError
+ *     cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":347
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ *     try:             # <<<<<<<<<<<<<<
+ *         with nogil:
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ */
+  /*try:*/ {
+
+    /* "pybase16384/backends/cython/_core.pyx":348
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        _save = NULL;
+        Py_UNBLOCK_THREADS
+        __Pyx_FastGIL_Remember();
+        #endif
+        /*try:*/ {
+
+          /* "pybase16384/backends/cython/_core.pyx":349
+ *     try:
+ *         with nogil:
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)             # <<<<<<<<<<<<<<
+ *         if ret !=  base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))
+ */
+          __pyx_v_ret = base16384_decode_file_detailed(__pyx_v_inp_name_ptr, __pyx_v_out_name_ptr, __pyx_v_encbuf, __pyx_v_decbuf, __pyx_v_flag);
+        }
+
+        /* "pybase16384/backends/cython/_core.pyx":348
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:
+ */
+        /*finally:*/ {
+          /*normal exit:*/{
+            #ifdef WITH_THREAD
+            __Pyx_FastGIL_Forget();
+            Py_BLOCK_THREADS
+            #endif
+            goto __pyx_L10;
+          }
+          __pyx_L10:;
+        }
+    }
+
+    /* "pybase16384/backends/cython/_core.pyx":350
+ *         with nogil:
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    __pyx_t_4 = (__pyx_v_ret != base16384_err_ok);
+    if (unlikely(__pyx_t_4)) {
+
+      /* "pybase16384/backends/cython/_core.pyx":351
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
+ *     finally:
+ *         PyMem_Free(encbuf)
+ */
+      __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 351, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 351, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __PYX_ERR(0, 351, __pyx_L6_error)
+
+      /* "pybase16384/backends/cython/_core.pyx":350
+ *         with nogil:
+ *             ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+ *         if ret !=  base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    }
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":353
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ * 
+ */
+  /*finally:*/ {
+    /*normal exit:*/{
+      PyMem_Free(__pyx_v_encbuf);
+
+      /* "pybase16384/backends/cython/_core.pyx":354
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):
+ */
+      PyMem_Free(__pyx_v_decbuf);
+      goto __pyx_L7;
+    }
+    __pyx_L6_error:;
+    /*exception exit:*/{
+      __Pyx_PyThreadState_declare
+      __Pyx_PyThreadState_assign
+      __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0;
+      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11) < 0)) __Pyx_ErrFetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_9);
+      __Pyx_XGOTREF(__pyx_t_10);
+      __Pyx_XGOTREF(__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_12);
+      __Pyx_XGOTREF(__pyx_t_13);
+      __Pyx_XGOTREF(__pyx_t_14);
+      __pyx_t_6 = __pyx_lineno; __pyx_t_7 = __pyx_clineno; __pyx_t_8 = __pyx_filename;
+      {
+
+        /* "pybase16384/backends/cython/_core.pyx":353
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ * 
+ */
+        PyMem_Free(__pyx_v_encbuf);
+
+        /* "pybase16384/backends/cython/_core.pyx":354
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):
+ */
+        PyMem_Free(__pyx_v_decbuf);
+      }
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_12);
+        __Pyx_XGIVEREF(__pyx_t_13);
+        __Pyx_XGIVEREF(__pyx_t_14);
+        __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_13, __pyx_t_14);
+      }
+      __Pyx_XGIVEREF(__pyx_t_9);
+      __Pyx_XGIVEREF(__pyx_t_10);
+      __Pyx_XGIVEREF(__pyx_t_11);
+      __Pyx_ErrRestore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
+      __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0;
+      __pyx_lineno = __pyx_t_6; __pyx_clineno = __pyx_t_7; __pyx_filename = __pyx_t_8;
+      goto __pyx_L1_error;
+    }
+    __pyx_L7:;
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":334
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_local_file_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_inp_name);
+  __Pyx_XDECREF(__pyx_v_out_name);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_29decode_local_file_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+PyDoc_STRVAR(__pyx_doc_11pybase16384_8backends_6cython_5_core_28decode_local_file_detailed, "decode_local_file_detailed(inp, out, int flag)");
+static PyMethodDef __pyx_mdef_11pybase16384_8backends_6cython_5_core_29decode_local_file_detailed = {"decode_local_file_detailed", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_11pybase16384_8backends_6cython_5_core_29decode_local_file_detailed, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_11pybase16384_8backends_6cython_5_core_28decode_local_file_detailed};
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_29decode_local_file_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_inp = 0;
+  PyObject *__pyx_v_out = 0;
+  int __pyx_v_flag;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[3] = {0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("decode_local_file_detailed (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_inp,&__pyx_n_s_out,&__pyx_n_s_flag,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 334, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 334, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("decode_local_file_detailed", 1, 3, 3, 1); __PYX_ERR(0, 334, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_flag)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 334, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("decode_local_file_detailed", 1, 3, 3, 2); __PYX_ERR(0, 334, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_local_file_detailed") < 0)) __PYX_ERR(0, 334, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 3)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+    }
+    __pyx_v_inp = values[0];
+    __pyx_v_out = values[1];
+    __pyx_v_flag = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_flag == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 334, __pyx_L3_error)
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("decode_local_file_detailed", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 334, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_local_file_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_11pybase16384_8backends_6cython_5_core_28decode_local_file_detailed(__pyx_self, __pyx_v_inp, __pyx_v_out, __pyx_v_flag);
+
+  /* function exit code */
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_28decode_local_file_detailed(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_inp, PyObject *__pyx_v_out, int __pyx_v_flag) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("decode_local_file_detailed", 1);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_local_file_detailed(__pyx_v_inp, __pyx_v_out, __pyx_v_flag, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 334, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_local_file_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "pybase16384/backends/cython/_core.pyx":356
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_31encode_fd_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_encode_fd_detailed(int __pyx_v_inp, int __pyx_v_out, int __pyx_v_flag, CYTHON_UNUSED int __pyx_skip_dispatch) {
+  char *__pyx_v_encbuf;
+  char *__pyx_v_decbuf;
+  base16384_err_t __pyx_v_ret;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  char const *__pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("encode_fd_detailed", 1);
+
+  /* "pybase16384/backends/cython/_core.pyx":357
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ */
+  __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":358
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  __pyx_t_1 = (__pyx_v_encbuf == NULL);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":359
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 359, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":358
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":360
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ */
+  __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":361
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  __pyx_t_1 = (__pyx_v_decbuf == NULL);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":362
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ */
+    PyMem_Free(__pyx_v_encbuf);
+
+    /* "pybase16384/backends/cython/_core.pyx":363
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef base16384_err_t ret
+ *     try:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 363, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":361
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":365
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ *     try:             # <<<<<<<<<<<<<<
+ *         with nogil:
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ */
+  /*try:*/ {
+
+    /* "pybase16384/backends/cython/_core.pyx":366
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        _save = NULL;
+        Py_UNBLOCK_THREADS
+        __Pyx_FastGIL_Remember();
+        #endif
+        /*try:*/ {
+
+          /* "pybase16384/backends/cython/_core.pyx":367
+ *     try:
+ *         with nogil:
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)             # <<<<<<<<<<<<<<
+ *         if ret != base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))
+ */
+          __pyx_v_ret = base16384_encode_fd_detailed(__pyx_v_inp, __pyx_v_out, __pyx_v_encbuf, __pyx_v_decbuf, __pyx_v_flag);
+        }
+
+        /* "pybase16384/backends/cython/_core.pyx":366
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:
+ */
+        /*finally:*/ {
+          /*normal exit:*/{
+            #ifdef WITH_THREAD
+            __Pyx_FastGIL_Forget();
+            Py_BLOCK_THREADS
+            #endif
+            goto __pyx_L10;
+          }
+          __pyx_L10:;
+        }
+    }
+
+    /* "pybase16384/backends/cython/_core.pyx":368
+ *         with nogil:
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    __pyx_t_1 = (__pyx_v_ret != base16384_err_ok);
+    if (unlikely(__pyx_t_1)) {
+
+      /* "pybase16384/backends/cython/_core.pyx":369
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
+ *     finally:
+ *         PyMem_Free(encbuf)
+ */
+      __pyx_t_2 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 369, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __PYX_ERR(0, 369, __pyx_L6_error)
+
+      /* "pybase16384/backends/cython/_core.pyx":368
+ *         with nogil:
+ *             ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    }
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":371
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ * 
+ */
+  /*finally:*/ {
+    /*normal exit:*/{
+      PyMem_Free(__pyx_v_encbuf);
+
+      /* "pybase16384/backends/cython/_core.pyx":372
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):
+ */
+      PyMem_Free(__pyx_v_decbuf);
+      goto __pyx_L7;
+    }
+    __pyx_L6_error:;
+    /*exception exit:*/{
+      __Pyx_PyThreadState_declare
+      __Pyx_PyThreadState_assign
+      __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
+      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9) < 0)) __Pyx_ErrFetch(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
+      __Pyx_XGOTREF(__pyx_t_7);
+      __Pyx_XGOTREF(__pyx_t_8);
+      __Pyx_XGOTREF(__pyx_t_9);
+      __Pyx_XGOTREF(__pyx_t_10);
+      __Pyx_XGOTREF(__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_12);
+      __pyx_t_4 = __pyx_lineno; __pyx_t_5 = __pyx_clineno; __pyx_t_6 = __pyx_filename;
+      {
+
+        /* "pybase16384/backends/cython/_core.pyx":371
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ * 
+ */
+        PyMem_Free(__pyx_v_encbuf);
+
+        /* "pybase16384/backends/cython/_core.pyx":372
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):
+ */
+        PyMem_Free(__pyx_v_decbuf);
+      }
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_10);
+        __Pyx_XGIVEREF(__pyx_t_11);
+        __Pyx_XGIVEREF(__pyx_t_12);
+        __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
+      }
+      __Pyx_XGIVEREF(__pyx_t_7);
+      __Pyx_XGIVEREF(__pyx_t_8);
+      __Pyx_XGIVEREF(__pyx_t_9);
+      __Pyx_ErrRestore(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+      __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
+      __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
+      goto __pyx_L1_error;
+    }
+    __pyx_L7:;
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":356
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_fd_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_31encode_fd_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+PyDoc_STRVAR(__pyx_doc_11pybase16384_8backends_6cython_5_core_30encode_fd_detailed, "encode_fd_detailed(int inp, int out, int flag)");
+static PyMethodDef __pyx_mdef_11pybase16384_8backends_6cython_5_core_31encode_fd_detailed = {"encode_fd_detailed", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_11pybase16384_8backends_6cython_5_core_31encode_fd_detailed, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_11pybase16384_8backends_6cython_5_core_30encode_fd_detailed};
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_31encode_fd_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  int __pyx_v_inp;
+  int __pyx_v_out;
+  int __pyx_v_flag;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[3] = {0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("encode_fd_detailed (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_inp,&__pyx_n_s_out,&__pyx_n_s_flag,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("encode_fd_detailed", 1, 3, 3, 1); __PYX_ERR(0, 356, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_flag)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("encode_fd_detailed", 1, 3, 3, 2); __PYX_ERR(0, 356, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "encode_fd_detailed") < 0)) __PYX_ERR(0, 356, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 3)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+    }
+    __pyx_v_inp = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_inp == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L3_error)
+    __pyx_v_out = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_out == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L3_error)
+    __pyx_v_flag = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_flag == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L3_error)
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("encode_fd_detailed", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 356, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_fd_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_11pybase16384_8backends_6cython_5_core_30encode_fd_detailed(__pyx_self, __pyx_v_inp, __pyx_v_out, __pyx_v_flag);
+
+  /* function exit code */
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_30encode_fd_detailed(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_inp, int __pyx_v_out, int __pyx_v_flag) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("encode_fd_detailed", 1);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_encode_fd_detailed(__pyx_v_inp, __pyx_v_out, __pyx_v_flag, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 356, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.encode_fd_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "pybase16384/backends/cython/_core.pyx":374
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_33decode_fd_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static CYTHON_INLINE PyObject *__pyx_f_11pybase16384_8backends_6cython_5_core_decode_fd_detailed(int __pyx_v_inp, int __pyx_v_out, int __pyx_v_flag, CYTHON_UNUSED int __pyx_skip_dispatch) {
+  char *__pyx_v_encbuf;
+  char *__pyx_v_decbuf;
+  base16384_err_t __pyx_v_ret;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  char const *__pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  PyObject *__pyx_t_11 = NULL;
+  PyObject *__pyx_t_12 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("decode_fd_detailed", 1);
+
+  /* "pybase16384/backends/cython/_core.pyx":375
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)             # <<<<<<<<<<<<<<
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ */
+  __pyx_v_encbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_ENCBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":376
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  __pyx_t_1 = (__pyx_v_encbuf == NULL);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":377
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 377, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":376
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":378
+ *     if encbuf == NULL:
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)             # <<<<<<<<<<<<<<
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ */
+  __pyx_v_decbuf = ((char *)PyMem_Malloc(((size_t)BASE16384_DECBUFSZ)));
+
+  /* "pybase16384/backends/cython/_core.pyx":379
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  __pyx_t_1 = (__pyx_v_decbuf == NULL);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "pybase16384/backends/cython/_core.pyx":380
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ */
+    PyMem_Free(__pyx_v_encbuf);
+
+    /* "pybase16384/backends/cython/_core.pyx":381
+ *     if decbuf == NULL:
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError             # <<<<<<<<<<<<<<
+ *     cdef base16384_err_t ret
+ *     try:
+ */
+    PyErr_NoMemory(); __PYX_ERR(0, 381, __pyx_L1_error)
+
+    /* "pybase16384/backends/cython/_core.pyx":379
+ *         raise MemoryError
+ *     cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+ *     if decbuf == NULL:             # <<<<<<<<<<<<<<
+ *         PyMem_Free(encbuf)
+ *         raise MemoryError
+ */
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":383
+ *         raise MemoryError
+ *     cdef base16384_err_t ret
+ *     try:             # <<<<<<<<<<<<<<
+ *         with nogil:
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ */
+  /*try:*/ {
+
+    /* "pybase16384/backends/cython/_core.pyx":384
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:
+ */
+    {
+        #ifdef WITH_THREAD
+        PyThreadState *_save;
+        _save = NULL;
+        Py_UNBLOCK_THREADS
+        __Pyx_FastGIL_Remember();
+        #endif
+        /*try:*/ {
+
+          /* "pybase16384/backends/cython/_core.pyx":385
+ *     try:
+ *         with nogil:
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)             # <<<<<<<<<<<<<<
+ *         if ret != base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))
+ */
+          __pyx_v_ret = base16384_decode_fd_detailed(__pyx_v_inp, __pyx_v_out, __pyx_v_encbuf, __pyx_v_decbuf, __pyx_v_flag);
+        }
+
+        /* "pybase16384/backends/cython/_core.pyx":384
+ *     cdef base16384_err_t ret
+ *     try:
+ *         with nogil:             # <<<<<<<<<<<<<<
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:
+ */
+        /*finally:*/ {
+          /*normal exit:*/{
+            #ifdef WITH_THREAD
+            __Pyx_FastGIL_Forget();
+            Py_BLOCK_THREADS
+            #endif
+            goto __pyx_L10;
+          }
+          __pyx_L10:;
+        }
+    }
+
+    /* "pybase16384/backends/cython/_core.pyx":386
+ *         with nogil:
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    __pyx_t_1 = (__pyx_v_ret != base16384_err_ok);
+    if (unlikely(__pyx_t_1)) {
+
+      /* "pybase16384/backends/cython/_core.pyx":387
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:
+ *             raise ValueError(err_to_str(ret))             # <<<<<<<<<<<<<<
+ *     finally:
+ *         PyMem_Free(encbuf)
+ */
+      __pyx_t_2 = __pyx_f_11pybase16384_8backends_6cython_5_core_err_to_str(__pyx_v_ret); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 387, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 387, __pyx_L6_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __PYX_ERR(0, 387, __pyx_L6_error)
+
+      /* "pybase16384/backends/cython/_core.pyx":386
+ *         with nogil:
+ *             ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+ *         if ret != base16384_err_ok:             # <<<<<<<<<<<<<<
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ */
+    }
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":389
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ */
+  /*finally:*/ {
+    /*normal exit:*/{
+      PyMem_Free(__pyx_v_encbuf);
+
+      /* "pybase16384/backends/cython/_core.pyx":390
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ */
+      PyMem_Free(__pyx_v_decbuf);
+      goto __pyx_L7;
+    }
+    __pyx_L6_error:;
+    /*exception exit:*/{
+      __Pyx_PyThreadState_declare
+      __Pyx_PyThreadState_assign
+      __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
+      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
+      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9) < 0)) __Pyx_ErrFetch(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
+      __Pyx_XGOTREF(__pyx_t_7);
+      __Pyx_XGOTREF(__pyx_t_8);
+      __Pyx_XGOTREF(__pyx_t_9);
+      __Pyx_XGOTREF(__pyx_t_10);
+      __Pyx_XGOTREF(__pyx_t_11);
+      __Pyx_XGOTREF(__pyx_t_12);
+      __pyx_t_4 = __pyx_lineno; __pyx_t_5 = __pyx_clineno; __pyx_t_6 = __pyx_filename;
+      {
+
+        /* "pybase16384/backends/cython/_core.pyx":389
+ *             raise ValueError(err_to_str(ret))
+ *     finally:
+ *         PyMem_Free(encbuf)             # <<<<<<<<<<<<<<
+ *         PyMem_Free(decbuf)
+ */
+        PyMem_Free(__pyx_v_encbuf);
+
+        /* "pybase16384/backends/cython/_core.pyx":390
+ *     finally:
+ *         PyMem_Free(encbuf)
+ *         PyMem_Free(decbuf)             # <<<<<<<<<<<<<<
+ */
+        PyMem_Free(__pyx_v_decbuf);
+      }
+      if (PY_MAJOR_VERSION >= 3) {
+        __Pyx_XGIVEREF(__pyx_t_10);
+        __Pyx_XGIVEREF(__pyx_t_11);
+        __Pyx_XGIVEREF(__pyx_t_12);
+        __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
+      }
+      __Pyx_XGIVEREF(__pyx_t_7);
+      __Pyx_XGIVEREF(__pyx_t_8);
+      __Pyx_XGIVEREF(__pyx_t_9);
+      __Pyx_ErrRestore(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+      __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0;
+      __pyx_lineno = __pyx_t_4; __pyx_clineno = __pyx_t_5; __pyx_filename = __pyx_t_6;
+      goto __pyx_L1_error;
+    }
+    __pyx_L7:;
+  }
+
+  /* "pybase16384/backends/cython/_core.pyx":374
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_fd_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* Python wrapper */
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_33decode_fd_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+PyDoc_STRVAR(__pyx_doc_11pybase16384_8backends_6cython_5_core_32decode_fd_detailed, "decode_fd_detailed(int inp, int out, int flag)");
+static PyMethodDef __pyx_mdef_11pybase16384_8backends_6cython_5_core_33decode_fd_detailed = {"decode_fd_detailed", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_11pybase16384_8backends_6cython_5_core_33decode_fd_detailed, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_11pybase16384_8backends_6cython_5_core_32decode_fd_detailed};
+static PyObject *__pyx_pw_11pybase16384_8backends_6cython_5_core_33decode_fd_detailed(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  int __pyx_v_inp;
+  int __pyx_v_out;
+  int __pyx_v_flag;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[3] = {0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("decode_fd_detailed (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_inp,&__pyx_n_s_out,&__pyx_n_s_flag,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_inp)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 374, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_out)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 374, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("decode_fd_detailed", 1, 3, 3, 1); __PYX_ERR(0, 374, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_flag)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 374, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("decode_fd_detailed", 1, 3, 3, 2); __PYX_ERR(0, 374, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "decode_fd_detailed") < 0)) __PYX_ERR(0, 374, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 3)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+    }
+    __pyx_v_inp = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_inp == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 374, __pyx_L3_error)
+    __pyx_v_out = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_out == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 374, __pyx_L3_error)
+    __pyx_v_flag = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_flag == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 374, __pyx_L3_error)
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("decode_fd_detailed", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 374, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_fd_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_11pybase16384_8backends_6cython_5_core_32decode_fd_detailed(__pyx_self, __pyx_v_inp, __pyx_v_out, __pyx_v_flag);
+
+  /* function exit code */
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_11pybase16384_8backends_6cython_5_core_32decode_fd_detailed(CYTHON_UNUSED PyObject *__pyx_self, int __pyx_v_inp, int __pyx_v_out, int __pyx_v_flag) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("decode_fd_detailed", 1);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_11pybase16384_8backends_6cython_5_core_decode_fd_detailed(__pyx_v_inp, __pyx_v_out, __pyx_v_flag, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 374, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("pybase16384.backends.cython._core.decode_fd_detailed", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
   PyObject *o;
   #if CYTHON_COMPILING_IN_LIMITED_API
   allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
@@ -24712,50 +26882,57 @@
     {&__pyx_kp_u_Cannot_index_with_type, __pyx_k_Cannot_index_with_type, sizeof(__pyx_k_Cannot_index_with_type), 0, 1, 0, 0},
     {&__pyx_kp_s_Cannot_transpose_memoryview_with, __pyx_k_Cannot_transpose_memoryview_with, sizeof(__pyx_k_Cannot_transpose_memoryview_with), 0, 0, 1, 0},
     {&__pyx_n_s_DECBUFSZ, __pyx_k_DECBUFSZ, sizeof(__pyx_k_DECBUFSZ), 0, 0, 1, 1},
     {&__pyx_kp_s_Dimension_d_is_not_direct, __pyx_k_Dimension_d_is_not_direct, sizeof(__pyx_k_Dimension_d_is_not_direct), 0, 0, 1, 0},
     {&__pyx_n_s_ENCBUFSZ, __pyx_k_ENCBUFSZ, sizeof(__pyx_k_ENCBUFSZ), 0, 0, 1, 1},
     {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
     {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
+    {&__pyx_n_s_FLAG_NOHEADER, __pyx_k_FLAG_NOHEADER, sizeof(__pyx_k_FLAG_NOHEADER), 0, 0, 1, 1},
+    {&__pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN, __pyx_k_FLAG_SUM_CHECK_ON_REMAIN, sizeof(__pyx_k_FLAG_SUM_CHECK_ON_REMAIN), 0, 0, 1, 1},
     {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
     {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
     {&__pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_k_Index_out_of_bounds_axis_d, sizeof(__pyx_k_Index_out_of_bounds_axis_d), 0, 0, 1, 0},
     {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
     {&__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 1, 0, 0},
     {&__pyx_kp_u_Invalid_shape_in_axis, __pyx_k_Invalid_shape_in_axis, sizeof(__pyx_k_Invalid_shape_in_axis), 0, 1, 0, 0},
     {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
     {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
     {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
     {&__pyx_n_b_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 0, 0, 1},
     {&__pyx_kp_u_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 1, 0, 0},
     {&__pyx_n_s_Path, __pyx_k_Path, sizeof(__pyx_k_Path), 0, 0, 1, 1},
     {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
+    {&__pyx_n_s_SIMPLE_SUM_INIT_VALUE, __pyx_k_SIMPLE_SUM_INIT_VALUE, sizeof(__pyx_k_SIMPLE_SUM_INIT_VALUE), 0, 0, 1, 1},
     {&__pyx_n_s_Sequence, __pyx_k_Sequence, sizeof(__pyx_k_Sequence), 0, 0, 1, 1},
     {&__pyx_kp_s_Step_may_not_be_zero_axis_d, __pyx_k_Step_may_not_be_zero_axis_d, sizeof(__pyx_k_Step_may_not_be_zero_axis_d), 0, 0, 1, 0},
     {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
     {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
     {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
     {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
     {&__pyx_kp_b__10, __pyx_k__10, sizeof(__pyx_k__10), 0, 0, 0, 0},
     {&__pyx_kp_b__11, __pyx_k__11, sizeof(__pyx_k__11), 0, 0, 0, 0},
     {&__pyx_kp_u__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 1, 0, 0},
     {&__pyx_n_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 1},
-    {&__pyx_n_s__45, __pyx_k__45, sizeof(__pyx_k__45), 0, 0, 1, 1},
+    {&__pyx_n_s__50, __pyx_k__50, sizeof(__pyx_k__50), 0, 0, 1, 1},
     {&__pyx_kp_u__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 1, 0, 0},
     {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
     {&__pyx_n_s_abc, __pyx_k_abc, sizeof(__pyx_k_abc), 0, 0, 1, 1},
     {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
     {&__pyx_kp_u_and, __pyx_k_and, sizeof(__pyx_k_and), 0, 1, 0, 0},
     {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
     {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
     {&__pyx_n_u_base16384_err_fopen_input_file, __pyx_k_base16384_err_fopen_input_file, sizeof(__pyx_k_base16384_err_fopen_input_file), 0, 1, 0, 1},
     {&__pyx_n_u_base16384_err_fopen_output_file, __pyx_k_base16384_err_fopen_output_file, sizeof(__pyx_k_base16384_err_fopen_output_file), 0, 1, 0, 1},
     {&__pyx_n_u_base16384_err_get_file_size, __pyx_k_base16384_err_get_file_size, sizeof(__pyx_k_base16384_err_get_file_size), 0, 1, 0, 1},
+    {&__pyx_n_u_base16384_err_invalid_commandlin, __pyx_k_base16384_err_invalid_commandlin, sizeof(__pyx_k_base16384_err_invalid_commandlin), 0, 1, 0, 1},
+    {&__pyx_n_u_base16384_err_invalid_decoding_c, __pyx_k_base16384_err_invalid_decoding_c, sizeof(__pyx_k_base16384_err_invalid_decoding_c), 0, 1, 0, 1},
+    {&__pyx_n_u_base16384_err_invalid_file_name, __pyx_k_base16384_err_invalid_file_name, sizeof(__pyx_k_base16384_err_invalid_file_name), 0, 1, 0, 1},
     {&__pyx_n_u_base16384_err_map_input_file, __pyx_k_base16384_err_map_input_file, sizeof(__pyx_k_base16384_err_map_input_file), 0, 1, 0, 1},
     {&__pyx_n_u_base16384_err_open_input_file, __pyx_k_base16384_err_open_input_file, sizeof(__pyx_k_base16384_err_open_input_file), 0, 1, 0, 1},
+    {&__pyx_n_u_base16384_err_read_file, __pyx_k_base16384_err_read_file, sizeof(__pyx_k_base16384_err_read_file), 0, 1, 0, 1},
     {&__pyx_n_u_base16384_err_write_file, __pyx_k_base16384_err_write_file, sizeof(__pyx_k_base16384_err_write_file), 0, 1, 0, 1},
     {&__pyx_n_s_buf_rate, __pyx_k_buf_rate, sizeof(__pyx_k_buf_rate), 0, 0, 1, 1},
     {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
     {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
     {&__pyx_n_s_chunk, __pyx_k_chunk, sizeof(__pyx_k_chunk), 0, 0, 1, 1},
     {&__pyx_n_s_chunk_ptr, __pyx_k_chunk_ptr, sizeof(__pyx_k_chunk_ptr), 0, 0, 1, 1},
     {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
@@ -24766,34 +26943,39 @@
     {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
     {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
     {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
     {&__pyx_n_s_current_buf_len, __pyx_k_current_buf_len, sizeof(__pyx_k_current_buf_len), 0, 0, 1, 1},
     {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
     {&__pyx_n_s_decode, __pyx_k_decode, sizeof(__pyx_k_decode), 0, 0, 1, 1},
     {&__pyx_n_s_decode_fd, __pyx_k_decode_fd, sizeof(__pyx_k_decode_fd), 0, 0, 1, 1},
+    {&__pyx_n_s_decode_fd_detailed, __pyx_k_decode_fd_detailed, sizeof(__pyx_k_decode_fd_detailed), 0, 0, 1, 1},
     {&__pyx_n_s_decode_file, __pyx_k_decode_file, sizeof(__pyx_k_decode_file), 0, 0, 1, 1},
     {&__pyx_n_s_decode_into, __pyx_k_decode_into, sizeof(__pyx_k_decode_into), 0, 0, 1, 1},
     {&__pyx_n_s_decode_len, __pyx_k_decode_len, sizeof(__pyx_k_decode_len), 0, 0, 1, 1},
     {&__pyx_n_s_decode_local_file, __pyx_k_decode_local_file, sizeof(__pyx_k_decode_local_file), 0, 0, 1, 1},
+    {&__pyx_n_s_decode_local_file_detailed, __pyx_k_decode_local_file_detailed, sizeof(__pyx_k_decode_local_file_detailed), 0, 0, 1, 1},
     {&__pyx_n_s_dest, __pyx_k_dest, sizeof(__pyx_k_dest), 0, 0, 1, 1},
     {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
     {&__pyx_kp_u_disable, __pyx_k_disable, sizeof(__pyx_k_disable), 0, 1, 0, 0},
     {&__pyx_n_s_dlen, __pyx_k_dlen, sizeof(__pyx_k_dlen), 0, 0, 1, 1},
     {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
     {&__pyx_kp_u_enable, __pyx_k_enable, sizeof(__pyx_k_enable), 0, 1, 0, 0},
     {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
     {&__pyx_n_s_encode_2, __pyx_k_encode_2, sizeof(__pyx_k_encode_2), 0, 0, 1, 1},
     {&__pyx_n_s_encode_fd, __pyx_k_encode_fd, sizeof(__pyx_k_encode_fd), 0, 0, 1, 1},
+    {&__pyx_n_s_encode_fd_detailed, __pyx_k_encode_fd_detailed, sizeof(__pyx_k_encode_fd_detailed), 0, 0, 1, 1},
     {&__pyx_n_s_encode_file, __pyx_k_encode_file, sizeof(__pyx_k_encode_file), 0, 0, 1, 1},
     {&__pyx_n_s_encode_into, __pyx_k_encode_into, sizeof(__pyx_k_encode_into), 0, 0, 1, 1},
     {&__pyx_n_s_encode_len, __pyx_k_encode_len, sizeof(__pyx_k_encode_len), 0, 0, 1, 1},
     {&__pyx_n_s_encode_local_file, __pyx_k_encode_local_file, sizeof(__pyx_k_encode_local_file), 0, 0, 1, 1},
+    {&__pyx_n_s_encode_local_file_detailed, __pyx_k_encode_local_file_detailed, sizeof(__pyx_k_encode_local_file_detailed), 0, 0, 1, 1},
     {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
     {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
     {&__pyx_n_s_first_check, __pyx_k_first_check, sizeof(__pyx_k_first_check), 0, 0, 1, 1},
+    {&__pyx_n_s_flag, __pyx_k_flag, sizeof(__pyx_k_flag), 0, 0, 1, 1},
     {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
     {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
     {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
     {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
     {&__pyx_kp_u_gc, __pyx_k_gc, sizeof(__pyx_k_gc), 0, 1, 0, 0},
     {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
     {&__pyx_kp_u_got, __pyx_k_got, sizeof(__pyx_k_got), 0, 1, 0, 0},
@@ -24870,17 +27052,17 @@
     {&__pyx_n_s_write_head, __pyx_k_write_head, sizeof(__pyx_k_write_head), 0, 0, 1, 1},
     {0, 0, 0, 0, 0, 0, 0}
   };
   return __Pyx_InitStrings(__pyx_string_tab);
 }
 /* #### Code section: cached_builtins ### */
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 49, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 81, __pyx_L1_error)
-  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 104, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 57, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 112, __pyx_L1_error)
   __pyx_builtin___import__ = __Pyx_GetBuiltinName(__pyx_n_s_import); if (!__pyx_builtin___import__) __PYX_ERR(1, 100, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 159, __pyx_L1_error)
   __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 261, __pyx_L1_error)
   __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(1, 373, __pyx_L1_error)
   __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 408, __pyx_L1_error)
   __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 618, __pyx_L1_error)
   __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 914, __pyx_L1_error)
@@ -24926,44 +27108,44 @@
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
  */
   __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_136983863, __pyx_int_112105877, __pyx_int_184977713); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "pybase16384/backends/cython/_core.pyx":81
+  /* "pybase16384/backends/cython/_core.pyx":89
  *     cdef size_t output_buf_size = dest.shape[0]
  *     if output_buf_size < output_size:
  *         raise ValueError("Buffer is too small to hold result")             # <<<<<<<<<<<<<<
  *     with nogil:
  *         return b14_encode(<const char *> &data[0],
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Buffer_is_too_small_to_hold_resu); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Buffer_is_too_small_to_hold_resu); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 89, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "pybase16384/backends/cython/_core.pyx":162
+  /* "pybase16384/backends/cython/_core.pyx":170
  *         input.read(1)
  *     else:
  *         input.seek(0, 0)  #             # <<<<<<<<<<<<<<
  * 
  *     cdef int32_t current_buf_len = buf_rate * 8
  */
-  __pyx_tuple__12 = PyTuple_Pack(2, __pyx_int_0, __pyx_int_0); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_tuple__12 = PyTuple_Pack(2, __pyx_int_0, __pyx_int_0); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 170, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
 
-  /* "pybase16384/backends/cython/_core.pyx":190
+  /* "pybase16384/backends/cython/_core.pyx":198
  *                     size += 2
  *                 else:
  *                     input.seek(-2, 1)             # <<<<<<<<<<<<<<
  *             chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
  *             with nogil:
  */
-  __pyx_tuple__13 = PyTuple_Pack(2, __pyx_int_neg_2, __pyx_int_1); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_tuple__13 = PyTuple_Pack(2, __pyx_int_neg_2, __pyx_int_1); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 198, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
   /* "View.MemoryView":100
  * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
  * try:
  *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
@@ -25060,151 +27242,190 @@
  *     cdef object __pyx_result
  */
   __pyx_tuple__23 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__23);
   __Pyx_GIVEREF(__pyx_tuple__23);
   __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(1, 1, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":38
+  /* "pybase16384/backends/cython/_core.pyx":46
  *     return 0
  * 
  * cpdef inline int encode_len(int dlen) nogil:             # <<<<<<<<<<<<<<
  *     return b14_encode_len(dlen)
  * 
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_n_s_dlen); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_n_s_dlen); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__25);
   __Pyx_GIVEREF(__pyx_tuple__25);
-  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_len, 38, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_len, 46, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 46, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":41
+  /* "pybase16384/backends/cython/_core.pyx":49
  *     return b14_encode_len(dlen)
  * 
  * cpdef inline int decode_len(int dlen, int offset) nogil:             # <<<<<<<<<<<<<<
  *     return b14_decode_len(dlen, offset)
  * 
  */
-  __pyx_tuple__27 = PyTuple_Pack(2, __pyx_n_s_dlen, __pyx_n_s_offset); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_tuple__27 = PyTuple_Pack(2, __pyx_n_s_dlen, __pyx_n_s_offset); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 49, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__27);
   __Pyx_GIVEREF(__pyx_tuple__27);
-  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_len, 41, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_len, 49, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(0, 49, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":44
+  /* "pybase16384/backends/cython/_core.pyx":52
  *     return b14_decode_len(dlen, offset)
  * 
  * cpdef inline bytes _encode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  */
-  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_n_s_data); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 44, __pyx_L1_error)
+  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_n_s_data); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 52, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__29);
   __Pyx_GIVEREF(__pyx_tuple__29);
-  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_2, 44, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 44, __pyx_L1_error)
+  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_2, 52, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 52, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":60
+  /* "pybase16384/backends/cython/_core.pyx":68
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bytes _decode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  */
-  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode, 60, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 60, __pyx_L1_error)
+  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode, 68, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 68, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":76
+  /* "pybase16384/backends/cython/_core.pyx":84
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  */
-  __pyx_tuple__32 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_dest); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __pyx_tuple__32 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_dest); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 84, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__32);
   __Pyx_GIVEREF(__pyx_tuple__32);
-  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_into, 76, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_into, 84, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 84, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":87
+  /* "pybase16384/backends/cython/_core.pyx":95
  *                                 <char *> &dest[0])
  * 
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  */
-  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_into, 87, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_into, 95, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 95, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":99
+  /* "pybase16384/backends/cython/_core.pyx":107
  * 
  * 
  * def encode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        bint write_head = False,
  */
-  __pyx_tuple__35 = PyTuple_Pack(12, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_write_head, __pyx_n_s_buf_rate, __pyx_n_s_current_buf_len, __pyx_n_s_output_size, __pyx_n_s_output_buf, __pyx_n_s_size, __pyx_n_s_first_check, __pyx_n_s_count, __pyx_n_s_chunk_ptr, __pyx_n_s_chunk); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_tuple__35 = PyTuple_Pack(12, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_write_head, __pyx_n_s_buf_rate, __pyx_n_s_current_buf_len, __pyx_n_s_output_size, __pyx_n_s_output_buf, __pyx_n_s_size, __pyx_n_s_first_check, __pyx_n_s_count, __pyx_n_s_chunk_ptr, __pyx_n_s_chunk); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__35);
   __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(4, 0, 0, 12, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_file, 99, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(4, 0, 0, 12, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_file, 107, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 107, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":146
+  /* "pybase16384/backends/cython/_core.pyx":154
  *         PyMem_Free(output_buf)
  * 
  * def decode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        int32_t buf_rate = 10):
  */
-  __pyx_tuple__37 = PyTuple_Pack(11, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_buf_rate, __pyx_n_s_chunk, __pyx_n_s_current_buf_len, __pyx_n_s_output_size, __pyx_n_s_output_buf, __pyx_n_s_size, __pyx_n_s_count, __pyx_n_s_chunk_ptr, __pyx_n_s_tmp); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_tuple__37 = PyTuple_Pack(11, __pyx_n_s_input, __pyx_n_s_output, __pyx_n_s_buf_rate, __pyx_n_s_chunk, __pyx_n_s_current_buf_len, __pyx_n_s_output_size, __pyx_n_s_output_buf, __pyx_n_s_size, __pyx_n_s_count, __pyx_n_s_chunk_ptr, __pyx_n_s_tmp); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__37);
   __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_file, 146, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_file, 154, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 154, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":198
+  /* "pybase16384/backends/cython/_core.pyx":206
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bint is_64bits() nogil:             # <<<<<<<<<<<<<<
  *     return pybase16384_64bits()
  * 
  */
-  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_is_64bits, 198, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 198, __pyx_L1_error)
+  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_is_64bits, 206, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 206, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":215
- *         return "base16384_err_map_input_file"
+  /* "pybase16384/backends/cython/_core.pyx":231
+ *         return "base16384_err_invalid_decoding_checksum"
  * 
  * cpdef inline encode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
-  __pyx_tuple__40 = PyTuple_Pack(2, __pyx_n_s_inp, __pyx_n_s_out); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 215, __pyx_L1_error)
+  __pyx_tuple__40 = PyTuple_Pack(2, __pyx_n_s_inp, __pyx_n_s_out); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 231, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__40);
   __Pyx_GIVEREF(__pyx_tuple__40);
-  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_local_file, 215, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 215, __pyx_L1_error)
+  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_local_file, 231, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 231, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":237
+  /* "pybase16384/backends/cython/_core.pyx":253
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
-  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_local_file, 237, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 237, __pyx_L1_error)
+  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_local_file, 253, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 253, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":259
+  /* "pybase16384/backends/cython/_core.pyx":275
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline encode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
-  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_fd, 259, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_fd, 275, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 275, __pyx_L1_error)
 
-  /* "pybase16384/backends/cython/_core.pyx":277
+  /* "pybase16384/backends/cython/_core.pyx":293
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
-  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_fd, 277, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_fd, 293, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 293, __pyx_L1_error)
+
+  /* "pybase16384/backends/cython/_core.pyx":312
+ * 
+ * # detailed
+ * cpdef inline encode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+  __pyx_tuple__45 = PyTuple_Pack(3, __pyx_n_s_inp, __pyx_n_s_out, __pyx_n_s_flag); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 312, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__45);
+  __Pyx_GIVEREF(__pyx_tuple__45);
+  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_local_file_detailed, 312, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 312, __pyx_L1_error)
+
+  /* "pybase16384/backends/cython/_core.pyx":334
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_local_file_detailed, 334, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 334, __pyx_L1_error)
+
+  /* "pybase16384/backends/cython/_core.pyx":356
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_encode_fd_detailed, 356, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) __PYX_ERR(0, 356, __pyx_L1_error)
+
+  /* "pybase16384/backends/cython/_core.pyx":374
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pybase16384_backends_cython__cor, __pyx_n_s_decode_fd_detailed, 374, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 /* #### Code section: init_constants ### */
@@ -25439,23 +27660,23 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_3_0_9(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_3_0_10(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_9(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyTypeObject),
   #elif CYTHON_COMPILING_IN_LIMITED_API
-  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_9(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_9(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn_3_0_9); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(2, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -26270,260 +28491,344 @@
  *     cdef object __pyx_result
  */
   __pyx_t_7 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_7) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":17
+  /* "pybase16384/backends/cython/_core.pyx":22
  *     base16384_err_write_file, pybase16384_64bits)
  * 
  * from pathlib import Path             # <<<<<<<<<<<<<<
  * 
  * ENCBUFSZ = BASE16384_ENCBUFSZ
  */
-  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 17, __pyx_L1_error)
+  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_n_s_Path);
   __Pyx_GIVEREF(__pyx_n_s_Path);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_Path)) __PYX_ERR(0, 17, __pyx_L1_error);
-  __pyx_t_4 = __Pyx_Import(__pyx_n_s_pathlib, __pyx_t_7, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 17, __pyx_L1_error)
+  if (__Pyx_PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_Path)) __PYX_ERR(0, 22, __pyx_L1_error);
+  __pyx_t_4 = __Pyx_Import(__pyx_n_s_pathlib, __pyx_t_7, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_Path); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 17, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_Path); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Path, __pyx_t_7) < 0) __PYX_ERR(0, 17, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Path, __pyx_t_7) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":19
+  /* "pybase16384/backends/cython/_core.pyx":24
  * from pathlib import Path
  * 
  * ENCBUFSZ = BASE16384_ENCBUFSZ             # <<<<<<<<<<<<<<
  * DECBUFSZ = BASE16384_DECBUFSZ
- * 
+ * FLAG_NOHEADER = BASE16384_FLAG_NOHEADER
  */
-  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_ENCBUFSZ); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 19, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_ENCBUFSZ); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 24, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ENCBUFSZ, __pyx_t_4) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ENCBUFSZ, __pyx_t_4) < 0) __PYX_ERR(0, 24, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":20
+  /* "pybase16384/backends/cython/_core.pyx":25
  * 
  * ENCBUFSZ = BASE16384_ENCBUFSZ
  * DECBUFSZ = BASE16384_DECBUFSZ             # <<<<<<<<<<<<<<
+ * FLAG_NOHEADER = BASE16384_FLAG_NOHEADER
+ * FLAG_SUM_CHECK_ON_REMAIN = BASE16384_FLAG_SUM_CHECK_ON_REMAIN
+ */
+  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_DECBUFSZ); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 25, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DECBUFSZ, __pyx_t_4) < 0) __PYX_ERR(0, 25, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":26
+ * ENCBUFSZ = BASE16384_ENCBUFSZ
+ * DECBUFSZ = BASE16384_DECBUFSZ
+ * FLAG_NOHEADER = BASE16384_FLAG_NOHEADER             # <<<<<<<<<<<<<<
+ * FLAG_SUM_CHECK_ON_REMAIN = BASE16384_FLAG_SUM_CHECK_ON_REMAIN
+ * SIMPLE_SUM_INIT_VALUE = BASE16384_SIMPLE_SUM_INIT_VALUE
+ */
+  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_FLAG_NOHEADER); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 26, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FLAG_NOHEADER, __pyx_t_4) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":27
+ * DECBUFSZ = BASE16384_DECBUFSZ
+ * FLAG_NOHEADER = BASE16384_FLAG_NOHEADER
+ * FLAG_SUM_CHECK_ON_REMAIN = BASE16384_FLAG_SUM_CHECK_ON_REMAIN             # <<<<<<<<<<<<<<
+ * SIMPLE_SUM_INIT_VALUE = BASE16384_SIMPLE_SUM_INIT_VALUE
+ * 
+ */
+  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_FLAG_SUM_CHECK_ON_REMAIN); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 27, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FLAG_SUM_CHECK_ON_REMAIN, __pyx_t_4) < 0) __PYX_ERR(0, 27, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":28
+ * FLAG_NOHEADER = BASE16384_FLAG_NOHEADER
+ * FLAG_SUM_CHECK_ON_REMAIN = BASE16384_FLAG_SUM_CHECK_ON_REMAIN
+ * SIMPLE_SUM_INIT_VALUE = BASE16384_SIMPLE_SUM_INIT_VALUE             # <<<<<<<<<<<<<<
  * 
  * cdef inline bytes ensure_bytes(object inp):
  */
-  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_DECBUFSZ); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_From_int(BASE16384_SIMPLE_SUM_INIT_VALUE); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 28, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DECBUFSZ, __pyx_t_4) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SIMPLE_SUM_INIT_VALUE, __pyx_t_4) < 0) __PYX_ERR(0, 28, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":38
+  /* "pybase16384/backends/cython/_core.pyx":46
  *     return 0
  * 
  * cpdef inline int encode_len(int dlen) nogil:             # <<<<<<<<<<<<<<
  *     return b14_encode_len(dlen)
  * 
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_1encode_len, 0, __pyx_n_s_encode_len, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_1encode_len, 0, __pyx_n_s_encode_len, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_len, __pyx_t_4) < 0) __PYX_ERR(0, 38, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_len, __pyx_t_4) < 0) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":41
+  /* "pybase16384/backends/cython/_core.pyx":49
  *     return b14_encode_len(dlen)
  * 
  * cpdef inline int decode_len(int dlen, int offset) nogil:             # <<<<<<<<<<<<<<
  *     return b14_decode_len(dlen, offset)
  * 
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_3decode_len, 0, __pyx_n_s_decode_len, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__28)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_3decode_len, 0, __pyx_n_s_decode_len, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__28)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 49, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_len, __pyx_t_4) < 0) __PYX_ERR(0, 41, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_len, __pyx_t_4) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":44
+  /* "pybase16384/backends/cython/_core.pyx":52
  *     return b14_decode_len(dlen, offset)
  * 
  * cpdef inline bytes _encode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_5_encode, 0, __pyx_n_s_encode_2, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__30)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 44, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_5_encode, 0, __pyx_n_s_encode_2, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__30)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 52, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_2, __pyx_t_4) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_2, __pyx_t_4) < 0) __PYX_ERR(0, 52, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":60
+  /* "pybase16384/backends/cython/_core.pyx":68
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bytes _decode(const uint8_t[::1] data):             # <<<<<<<<<<<<<<
  *     cdef size_t length = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_7_decode, 0, __pyx_n_s_decode, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 60, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_7_decode, 0, __pyx_n_s_decode, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode, __pyx_t_4) < 0) __PYX_ERR(0, 60, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode, __pyx_t_4) < 0) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":76
+  /* "pybase16384/backends/cython/_core.pyx":84
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_9_encode_into, 0, __pyx_n_s_encode_into, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_9_encode_into, 0, __pyx_n_s_encode_into, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 84, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_into, __pyx_t_4) < 0) __PYX_ERR(0, 76, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_into, __pyx_t_4) < 0) __PYX_ERR(0, 84, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":87
+  /* "pybase16384/backends/cython/_core.pyx":95
  *                                 <char *> &dest[0])
  * 
  * cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:             # <<<<<<<<<<<<<<
  *     cdef size_t input_size = data.shape[0]
  *     cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_11_decode_into, 0, __pyx_n_s_decode_into, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_11_decode_into, 0, __pyx_n_s_decode_into, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_into, __pyx_t_4) < 0) __PYX_ERR(0, 87, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_into, __pyx_t_4) < 0) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":101
+  /* "pybase16384/backends/cython/_core.pyx":109
  * def encode_file(object input,
  *                        object output,
  *                        bint write_head = False,             # <<<<<<<<<<<<<<
  *                        int32_t buf_rate = 10):
  *     if not PyFile_Check(input):
  */
-  __pyx_t_4 = __Pyx_PyBool_FromLong(((int)0)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyBool_FromLong(((int)0)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
 
-  /* "pybase16384/backends/cython/_core.pyx":102
+  /* "pybase16384/backends/cython/_core.pyx":110
  *                        object output,
  *                        bint write_head = False,
  *                        int32_t buf_rate = 10):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
-  __pyx_t_7 = __Pyx_PyInt_From_int32_t(((int32_t)10)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_int32_t(((int32_t)10)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 110, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "pybase16384/backends/cython/_core.pyx":99
+  /* "pybase16384/backends/cython/_core.pyx":107
  * 
  * 
  * def encode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        bint write_head = False,
  */
-  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GIVEREF(__pyx_t_4);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4)) __PYX_ERR(0, 99, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4)) __PYX_ERR(0, 107, __pyx_L1_error);
   __Pyx_GIVEREF(__pyx_t_7);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_7)) __PYX_ERR(0, 99, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_7)) __PYX_ERR(0, 107, __pyx_L1_error);
   __pyx_t_4 = 0;
   __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_13encode_file, 0, __pyx_n_s_encode_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_13encode_file, 0, __pyx_n_s_encode_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_t_5);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_file, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_file, __pyx_t_7) < 0) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":148
+  /* "pybase16384/backends/cython/_core.pyx":156
  * def decode_file(object input,
  *                        object output,
  *                        int32_t buf_rate = 10):             # <<<<<<<<<<<<<<
  *     if not PyFile_Check(input):
  *         raise TypeError("input except a file-like object, got %s" % type(input).__name__)
  */
-  __pyx_t_7 = __Pyx_PyInt_From_int32_t(((int32_t)10)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 148, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_int32_t(((int32_t)10)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
 
-  /* "pybase16384/backends/cython/_core.pyx":146
+  /* "pybase16384/backends/cython/_core.pyx":154
  *         PyMem_Free(output_buf)
  * 
  * def decode_file(object input,             # <<<<<<<<<<<<<<
  *                        object output,
  *                        int32_t buf_rate = 10):
  */
-  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_GIVEREF(__pyx_t_7);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7)) __PYX_ERR(0, 146, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7)) __PYX_ERR(0, 154, __pyx_L1_error);
   __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_15decode_file, 0, __pyx_n_s_decode_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_15decode_file, 0, __pyx_n_s_decode_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_t_5);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_file, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_file, __pyx_t_7) < 0) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":198
+  /* "pybase16384/backends/cython/_core.pyx":206
  *         PyMem_Free(output_buf)
  * 
  * cpdef inline bint is_64bits() nogil:             # <<<<<<<<<<<<<<
  *     return pybase16384_64bits()
  * 
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_17is_64bits, 0, __pyx_n_s_is_64bits, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 198, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_17is_64bits, 0, __pyx_n_s_is_64bits, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 206, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_64bits, __pyx_t_7) < 0) __PYX_ERR(0, 198, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_64bits, __pyx_t_7) < 0) __PYX_ERR(0, 206, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":215
- *         return "base16384_err_map_input_file"
+  /* "pybase16384/backends/cython/_core.pyx":231
+ *         return "base16384_err_invalid_decoding_checksum"
  * 
  * cpdef inline encode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_19encode_local_file, 0, __pyx_n_s_encode_local_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__41)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 215, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_19encode_local_file, 0, __pyx_n_s_encode_local_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__41)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 231, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_local_file, __pyx_t_7) < 0) __PYX_ERR(0, 215, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_local_file, __pyx_t_7) < 0) __PYX_ERR(0, 231, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":237
+  /* "pybase16384/backends/cython/_core.pyx":253
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_local_file(object inp, object out):             # <<<<<<<<<<<<<<
  *     cdef bytes inp_name = ensure_bytes(inp)
  *     cdef bytes out_name = ensure_bytes(out)
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_21decode_local_file, 0, __pyx_n_s_decode_local_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 237, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_21decode_local_file, 0, __pyx_n_s_decode_local_file, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 253, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_local_file, __pyx_t_7) < 0) __PYX_ERR(0, 237, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_local_file, __pyx_t_7) < 0) __PYX_ERR(0, 253, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":259
+  /* "pybase16384/backends/cython/_core.pyx":275
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline encode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_23encode_fd, 0, __pyx_n_s_encode_fd, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_23encode_fd, 0, __pyx_n_s_encode_fd, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 275, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_fd, __pyx_t_7) < 0) __PYX_ERR(0, 259, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_fd, __pyx_t_7) < 0) __PYX_ERR(0, 275, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pybase16384/backends/cython/_core.pyx":277
+  /* "pybase16384/backends/cython/_core.pyx":293
  *         PyMem_Free(decbuf)
  * 
  * cpdef inline decode_fd(int inp, int out):             # <<<<<<<<<<<<<<
  *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
  *     if encbuf == NULL:
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_25decode_fd, 0, __pyx_n_s_decode_fd, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__44)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 277, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_25decode_fd, 0, __pyx_n_s_decode_fd, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__44)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 293, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_fd, __pyx_t_7) < 0) __PYX_ERR(0, 293, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":312
+ * 
+ * # detailed
+ * cpdef inline encode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_27encode_local_file_detailed, 0, __pyx_n_s_encode_local_file_detailed, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__46)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 312, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_local_file_detailed, __pyx_t_7) < 0) __PYX_ERR(0, 312, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":334
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_local_file_detailed(object inp, object out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef bytes inp_name = ensure_bytes(inp)
+ *     cdef bytes out_name = ensure_bytes(out)
+ */
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_29decode_local_file_detailed, 0, __pyx_n_s_decode_local_file_detailed, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 334, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_local_file_detailed, __pyx_t_7) < 0) __PYX_ERR(0, 334, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":356
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline encode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_31encode_fd_detailed, 0, __pyx_n_s_encode_fd_detailed, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__48)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 356, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_fd_detailed, __pyx_t_7) < 0) __PYX_ERR(0, 356, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+
+  /* "pybase16384/backends/cython/_core.pyx":374
+ *         PyMem_Free(decbuf)
+ * 
+ * cpdef inline decode_fd_detailed(int inp, int out, int flag):             # <<<<<<<<<<<<<<
+ *     cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+ *     if encbuf == NULL:
+ */
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_11pybase16384_8backends_6cython_5_core_33decode_fd_detailed, 0, __pyx_n_s_decode_fd_detailed, NULL, __pyx_n_s_pybase16384_backends_cython__cor_2, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_fd, __pyx_t_7) < 0) __PYX_ERR(0, 277, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_decode_fd_detailed, __pyx_t_7) < 0) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
   /* "pybase16384/backends/cython/_core.pyx":1
  * # cython: language_level=3             # <<<<<<<<<<<<<<
  * # cython: cdivision=True
  * from cpython.bytes cimport PyBytes_AS_STRING, PyBytes_Check, PyBytes_Size
  */
@@ -29704,18 +32009,18 @@
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 #endif
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType_3_0_9
-#define __PYX_HAVE_RT_ImportType_3_0_9
-static PyTypeObject *__Pyx_ImportType_3_0_9(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_9 check_size)
+#ifndef __PYX_HAVE_RT_ImportType_3_0_10
+#define __PYX_HAVE_RT_ImportType_3_0_10
+static PyTypeObject *__Pyx_ImportType_3_0_10(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_10 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
     Py_ssize_t itemsize;
 #if CYTHON_COMPILING_IN_LIMITED_API
     PyObject *py_basicsize;
@@ -29761,23 +32066,23 @@
     if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize+itemsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error_3_0_9 &&
+    if (check_size == __Pyx_ImportType_CheckSize_Error_3_0_10 &&
             ((size_t)basicsize > size || (size_t)(basicsize + itemsize) < size)) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd-%zd from PyObject",
             module_name, class_name, size, basicsize, basicsize+itemsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn_3_0_9 && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_3_0_10 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
@@ -33670,15 +35975,15 @@
 __Pyx_PyType_GetName(PyTypeObject* tp)
 {
     PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
                                                __pyx_n_s_name_2);
     if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
         PyErr_Clear();
         Py_XDECREF(name);
-        name = __Pyx_NewRef(__pyx_n_s__45);
+        name = __Pyx_NewRef(__pyx_n_s__50);
     }
     return name;
 }
 #endif
 
 /* CheckBinaryVersion */
   static unsigned long __Pyx_get_runtime_version(void) {
```

## pybase16384/backends/cython/_core.pxi

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-from typing import BinaryIO
-
-def decode_len(dlen: int, offset: int) -> int: ...
-def _decode(data: bytes) -> bytes: ...
-def _decode_into(data: memoryview, dest: memoryview) -> int: ...
-def decode_file(input: BinaryIO, output: BinaryIO, buf_rate: int = 10) -> None: ...
-def encode_len(dlen: int) -> int: ...
-def _encode(data: bytes) -> bytes: ...
-def _encode_into(data: memoryview, dest: memoryview) -> int: ...
-def encode_file(
-    input: BinaryIO, output: BinaryIO, boolwrite_head: bool = False, buf_rate: int = 10
-) -> None: ...
+from typing import BinaryIO
+
+def decode_len(dlen: int, offset: int) -> int: ...
+def _decode(data: bytes) -> bytes: ...
+def _decode_into(data: memoryview, dest: memoryview) -> int: ...
+def decode_file(input: BinaryIO, output: BinaryIO, buf_rate: int = 10) -> None: ...
+def encode_len(dlen: int) -> int: ...
+def _encode(data: bytes) -> bytes: ...
+def _encode_into(data: memoryview, dest: memoryview) -> int: ...
+def encode_file(
+    input: BinaryIO, output: BinaryIO, boolwrite_head: bool = False, buf_rate: int = 10
+) -> None: ...
```

## pybase16384/backends/cython/_core.pyx

```diff
@@ -1,293 +1,390 @@
-# cython: language_level=3
-# cython: cdivision=True
-from cpython.bytes cimport PyBytes_AS_STRING, PyBytes_Check, PyBytes_Size
-from cpython.mem cimport PyMem_Free, PyMem_Malloc
-from cpython.object cimport PyObject_HasAttrString
-from libc.stdint cimport int32_t, uint8_t
-
-from pybase16384.backends.cython.base16384 cimport (
-    b14_decode, b14_decode_fd, b14_decode_file, b14_decode_len, b14_encode,
-    b14_encode_fd, b14_encode_file, b14_encode_len,
-    base16384_err_fopen_input_file, base16384_err_fopen_output_file,
-    base16384_err_get_file_size, base16384_err_map_input_file,
-    base16384_err_ok, base16384_err_open_input_file, base16384_err_t, BASE16384_ENCBUFSZ,
-    BASE16384_DECBUFSZ,
-    base16384_err_write_file, pybase16384_64bits)
-
-from pathlib import Path
-
-ENCBUFSZ = BASE16384_ENCBUFSZ
-DECBUFSZ = BASE16384_DECBUFSZ
-
-cdef inline bytes ensure_bytes(object inp):
-    if isinstance(inp, unicode):
-        return inp.encode()
-    elif isinstance(inp, bytes):
-        return inp
-    elif isinstance(inp, Path):
-        return str(inp).encode()
-    else:
-        return bytes(inp)
-
-cdef inline uint8_t PyFile_Check(object file):
-    if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,
-                                                                                                                 "seek"):
-        return 1
-    return 0
-
-cpdef inline int encode_len(int dlen) nogil:
-    return b14_encode_len(dlen)
-
-cpdef inline int decode_len(int dlen, int offset) nogil:
-    return b14_decode_len(dlen, offset)
-
-cpdef inline bytes _encode(const uint8_t[::1] data):
-    cdef size_t length = data.shape[0]
-    cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
-    cdef char *output_buf = <char*>PyMem_Malloc(output_size)
-    if output_buf == NULL:
-        raise MemoryError
-    cdef int count
-    with nogil:
-        count = b14_encode(<const char*> &data[0],
-                                        <int>length,
-                                        output_buf) # encode 整数倍的那个
-    try:
-        return <bytes>output_buf[:count]
-    finally:
-        PyMem_Free(output_buf)
-
-cpdef inline bytes _decode(const uint8_t[::1] data):
-    cdef size_t length = data.shape[0]
-    cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
-    cdef char *output_buf = <char *> PyMem_Malloc(output_size)
-    if output_buf == NULL:
-        raise MemoryError
-    cdef int count
-    with nogil:
-        count = b14_decode(<const char *> &data[0],
-                                        <int> length,
-                                        output_buf)  # decode
-    try:
-        return <bytes> output_buf[:count]
-    finally:
-        PyMem_Free(output_buf)
-
-cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
-    cdef size_t input_size = data.shape[0]
-    cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
-    cdef size_t output_buf_size = dest.shape[0]
-    if output_buf_size < output_size:
-        raise ValueError("Buffer is too small to hold result")
-    with nogil:
-        return b14_encode(<const char *> &data[0],
-                                <int> input_size,
-                                <char *> &dest[0])
-
-cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
-    cdef size_t input_size = data.shape[0]
-    cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
-    cdef size_t output_buf_size = dest.shape[0]
-    if output_buf_size < output_size:
-        raise ValueError("Buffer is too small to hold result")
-    with nogil:
-        return b14_decode(<const char *> &data[0],
-                                <int> input_size,
-                                <char *> &dest[0])
-
-
-def encode_file(object input,
-                       object output,
-                       bint write_head = False,
-                       int32_t buf_rate = 10):
-    if not PyFile_Check(input):
-        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
-    if not PyFile_Check(output):
-        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
-    if buf_rate <= 0:
-        buf_rate = 1
-
-    if write_head:
-        output.write(b'\xfe\xff')
-
-    cdef int32_t current_buf_len = buf_rate * 7  # 一次读取这么多字节
-    cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # 因为encode_len不是单调的 这16备用
-    cdef char *output_buf = <char *> PyMem_Malloc(output_size)
-    if output_buf == NULL:
-        raise MemoryError
-
-    cdef Py_ssize_t size
-    cdef uint8_t first_check = 1  # 检查一次就行了 怎么可能出现第一次读出来是bytes 以后又变卦了的对象呢 不会吧不会吧
-    cdef int count = 0
-    cdef const char *chunk_ptr
-    try:
-        while True:
-            chunk = input.read(current_buf_len)
-            if first_check:
-                first_check = 0
-                if not PyBytes_Check(chunk):
-                    raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
-            size = PyBytes_Size(chunk)
-            if <int32_t> size < current_buf_len:  # 数据不够了 要减小一次读取的量
-                if buf_rate > 1:  # 重新设置一次读取的大小 重新设置流的位置 当然要是已经是一次读取7字节了 那就不能再变小了 直接encode吧
-                    buf_rate = buf_rate / 2
-                    current_buf_len = buf_rate * 7
-                    input.seek(-size, 1)
-                    continue
-            chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
-            with nogil:
-                count = b14_encode(chunk_ptr, <int>size, output_buf)
-            output.write(<bytes>output_buf[:count])
-            if size < 7:
-                break
-    finally:
-        PyMem_Free(output_buf)
-
-def decode_file(object input,
-                       object output,
-                       int32_t buf_rate = 10):
-    if not PyFile_Check(input):
-        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
-    if not PyFile_Check(output):
-        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
-    if buf_rate <= 0:
-        buf_rate = 1
-
-    chunk = input.read(1)  # type: bytes
-    if not PyBytes_Check(chunk):
-        raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
-    if chunk == b"\xfe":  # 去头
-        input.read(1)
-    else:
-        input.seek(0, 0)  # 没有头 回到开头
-
-    cdef int32_t current_buf_len = buf_rate * 8
-    cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16
-    cdef char *output_buf = <char *> PyMem_Malloc(output_size)
-    if output_buf == NULL:
-        raise MemoryError
-    cdef Py_ssize_t size
-    cdef int count = 0
-    cdef const char *chunk_ptr
-    try:
-        while True:
-            chunk = input.read(current_buf_len)  # 8的倍数
-            size = PyBytes_Size(chunk)
-            if size == 0:
-                break
-            if <int32_t> size < current_buf_len:  # 长度不够了
-                if buf_rate > 1:  # 还能继续变小
-                    buf_rate = buf_rate / 2  # 重新设置一次读取的大小
-                    current_buf_len = buf_rate * 8
-                    input.seek(-size, 1)
-                    continue
-            tmp = input.read(2)  # type: bytes
-            if PyBytes_Size(tmp) == 2:
-                if tmp[0] == 61:  # = stream完了   一次解码8n+2个字节
-                    chunk += tmp
-                    size += 2
-                else:
-                    input.seek(-2, 1)
-            chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
-            with nogil:
-                count = b14_decode(chunk_ptr, <int> size, output_buf)
-            output.write(<bytes>output_buf[:count])
-    finally:
-        PyMem_Free(output_buf)
-
-cpdef inline bint is_64bits() nogil:
-    return pybase16384_64bits()
-
-cdef inline str err_to_str(base16384_err_t ret):
-    if ret == base16384_err_get_file_size:
-        return "base16384_err_get_file_size"
-    elif ret == base16384_err_fopen_output_file:
-        return "base16384_err_fopen_output_file"
-    elif ret == base16384_err_fopen_input_file:
-        return "base16384_err_fopen_input_file"
-    elif ret == base16384_err_write_file:
-        return "base16384_err_write_file"
-    elif ret == base16384_err_open_input_file:
-        return "base16384_err_open_input_file"
-    elif ret == base16384_err_map_input_file:
-        return "base16384_err_map_input_file"
-
-cpdef inline encode_local_file(object inp, object out):
-    cdef bytes inp_name = ensure_bytes(inp)
-    cdef bytes out_name = ensure_bytes(out)
-    cdef const char * inp_name_ptr = <const char *> inp_name
-    cdef const char * out_name_ptr = <const char *> out_name
-    cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
-    if encbuf == NULL:
-        raise MemoryError
-    cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
-    if decbuf == NULL:
-        PyMem_Free(encbuf)
-        raise MemoryError
-    cdef base16384_err_t ret
-    try:
-        with nogil:
-            ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
-        if ret !=  base16384_err_ok:
-            raise ValueError(err_to_str(ret))
-    finally:
-        PyMem_Free(encbuf)
-        PyMem_Free(decbuf)
-
-cpdef inline decode_local_file(object inp, object out):
-    cdef bytes inp_name = ensure_bytes(inp)
-    cdef bytes out_name = ensure_bytes(out)
-    cdef const char * inp_name_ptr = <const char *> inp_name
-    cdef const char * out_name_ptr = <const char *> out_name
-    cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
-    if encbuf == NULL:
-        raise MemoryError
-    cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
-    if decbuf == NULL:
-        PyMem_Free(encbuf)
-        raise MemoryError
-    cdef base16384_err_t ret
-    try:
-        with nogil:
-            ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
-        if ret !=  base16384_err_ok:
-            raise ValueError(err_to_str(ret))
-    finally:
-        PyMem_Free(encbuf)
-        PyMem_Free(decbuf)
-
-cpdef inline encode_fd(int inp, int out):
-    cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
-    if encbuf == NULL:
-        raise MemoryError
-    cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
-    if decbuf == NULL:
-        PyMem_Free(encbuf)
-        raise MemoryError
-    cdef base16384_err_t ret
-    try:
-        with nogil:
-            ret = b14_encode_fd(inp, out, encbuf, decbuf)
-        if ret != base16384_err_ok:
-            raise ValueError(err_to_str(ret))
-    finally:
-        PyMem_Free(encbuf)
-        PyMem_Free(decbuf)
-
-cpdef inline decode_fd(int inp, int out):
-    cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
-    if encbuf == NULL:
-        raise MemoryError
-    cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
-    if decbuf == NULL:
-        PyMem_Free(encbuf)
-        raise MemoryError
-    cdef base16384_err_t ret
-    try:
-        with nogil:
-            ret = b14_decode_fd(inp, out, encbuf, decbuf)
-        if ret != base16384_err_ok:
-            raise ValueError(err_to_str(ret))
-    finally:
-        PyMem_Free(encbuf)
-        PyMem_Free(decbuf)
+# cython: language_level=3
+# cython: cdivision=True
+from cpython.bytes cimport PyBytes_AS_STRING, PyBytes_Check, PyBytes_Size
+from cpython.mem cimport PyMem_Free, PyMem_Malloc
+from cpython.object cimport PyObject_HasAttrString
+from libc.stdint cimport int32_t, uint8_t
+
+from pybase16384.backends.cython.base16384 cimport (
+    BASE16384_DECBUFSZ, BASE16384_ENCBUFSZ, BASE16384_FLAG_NOHEADER,
+    BASE16384_FLAG_SUM_CHECK_ON_REMAIN, BASE16384_SIMPLE_SUM_INIT_VALUE,
+    b14_decode, b14_decode_fd, b14_decode_fd_detailed, b14_decode_file,
+    b14_decode_file_detailed, b14_decode_len, b14_encode, b14_encode_fd,
+    b14_encode_fd_detailed, b14_encode_file, b14_encode_file_detailed,
+    b14_encode_len, base16384_err_fopen_input_file,
+    base16384_err_fopen_output_file, base16384_err_get_file_size,
+    base16384_err_invalid_commandline_parameter,
+    base16384_err_invalid_decoding_checksum, base16384_err_invalid_file_name,
+    base16384_err_map_input_file, base16384_err_ok,
+    base16384_err_open_input_file, base16384_err_read_file, base16384_err_t,
+    base16384_err_write_file, pybase16384_64bits)
+
+from pathlib import Path
+
+ENCBUFSZ = BASE16384_ENCBUFSZ
+DECBUFSZ = BASE16384_DECBUFSZ
+FLAG_NOHEADER = BASE16384_FLAG_NOHEADER
+FLAG_SUM_CHECK_ON_REMAIN = BASE16384_FLAG_SUM_CHECK_ON_REMAIN
+SIMPLE_SUM_INIT_VALUE = BASE16384_SIMPLE_SUM_INIT_VALUE
+
+cdef inline bytes ensure_bytes(object inp):
+    if isinstance(inp, unicode):
+        return inp.encode()
+    elif isinstance(inp, bytes):
+        return inp
+    elif isinstance(inp, Path):
+        return str(inp).encode()
+    else:
+        return bytes(inp)
+
+cdef inline uint8_t PyFile_Check(object file):
+    if PyObject_HasAttrString(file, "read") and PyObject_HasAttrString(file, "write") and PyObject_HasAttrString(file,
+                                                                                                                 "seek"):
+        return 1
+    return 0
+
+cpdef inline int encode_len(int dlen) nogil:
+    return b14_encode_len(dlen)
+
+cpdef inline int decode_len(int dlen, int offset) nogil:
+    return b14_decode_len(dlen, offset)
+
+cpdef inline bytes _encode(const uint8_t[::1] data):
+    cdef size_t length = data.shape[0]
+    cdef size_t output_size = <size_t> b14_encode_len(<int>length) + 16
+    cdef char *output_buf = <char*>PyMem_Malloc(output_size)
+    if output_buf == NULL:
+        raise MemoryError
+    cdef int count
+    with nogil:
+        count = b14_encode(<const char*> &data[0],
+                                        <int>length,
+                                        output_buf) # encode 整数倍的那个
+    try:
+        return <bytes>output_buf[:count]
+    finally:
+        PyMem_Free(output_buf)
+
+cpdef inline bytes _decode(const uint8_t[::1] data):
+    cdef size_t length = data.shape[0]
+    cdef size_t output_size = <size_t> b14_decode_len(<int>length, 0) + 16
+    cdef char *output_buf = <char *> PyMem_Malloc(output_size)
+    if output_buf == NULL:
+        raise MemoryError
+    cdef int count
+    with nogil:
+        count = b14_decode(<const char *> &data[0],
+                                        <int> length,
+                                        output_buf)  # decode
+    try:
+        return <bytes> output_buf[:count]
+    finally:
+        PyMem_Free(output_buf)
+
+cpdef inline int _encode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
+    cdef size_t input_size = data.shape[0]
+    cdef size_t output_size = <size_t> b14_encode_len(<int> input_size)
+    cdef size_t output_buf_size = dest.shape[0]
+    if output_buf_size < output_size:
+        raise ValueError("Buffer is too small to hold result")
+    with nogil:
+        return b14_encode(<const char *> &data[0],
+                                <int> input_size,
+                                <char *> &dest[0])
+
+cpdef inline int _decode_into(const uint8_t[::1] data, uint8_t[::1] dest) except -1:
+    cdef size_t input_size = data.shape[0]
+    cdef size_t output_size = <size_t> b14_decode_len(<int> input_size, 0)
+    cdef size_t output_buf_size = dest.shape[0]
+    if output_buf_size < output_size:
+        raise ValueError("Buffer is too small to hold result")
+    with nogil:
+        return b14_decode(<const char *> &data[0],
+                                <int> input_size,
+                                <char *> &dest[0])
+
+
+def encode_file(object input,
+                       object output,
+                       bint write_head = False,
+                       int32_t buf_rate = 10):
+    if not PyFile_Check(input):
+        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+    if not PyFile_Check(output):
+        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+    if buf_rate <= 0:
+        buf_rate = 1
+
+    if write_head:
+        output.write(b'\xfe\xff')
+
+    cdef int32_t current_buf_len = buf_rate * 7  # 一次读取这么多字节
+    cdef size_t output_size = <size_t> b14_encode_len(<int> current_buf_len) + 16 # 因为encode_len不是单调的 这16备用
+    cdef char *output_buf = <char *> PyMem_Malloc(output_size)
+    if output_buf == NULL:
+        raise MemoryError
+
+    cdef Py_ssize_t size
+    cdef uint8_t first_check = 1  # 检查一次就行了 怎么可能出现第一次读出来是bytes 以后又变卦了的对象呢 不会吧不会吧
+    cdef int count = 0
+    cdef const char *chunk_ptr
+    try:
+        while True:
+            chunk = input.read(current_buf_len)
+            if first_check:
+                first_check = 0
+                if not PyBytes_Check(chunk):
+                    raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
+            size = PyBytes_Size(chunk)
+            if <int32_t> size < current_buf_len:  # 数据不够了 要减小一次读取的量
+                if buf_rate > 1:  # 重新设置一次读取的大小 重新设置流的位置 当然要是已经是一次读取7字节了 那就不能再变小了 直接encode吧
+                    buf_rate = buf_rate / 2
+                    current_buf_len = buf_rate * 7
+                    input.seek(-size, 1)
+                    continue
+            chunk_ptr = <const char*>PyBytes_AS_STRING(chunk)
+            with nogil:
+                count = b14_encode(chunk_ptr, <int>size, output_buf)
+            output.write(<bytes>output_buf[:count])
+            if size < 7:
+                break
+    finally:
+        PyMem_Free(output_buf)
+
+def decode_file(object input,
+                       object output,
+                       int32_t buf_rate = 10):
+    if not PyFile_Check(input):
+        raise TypeError("input except a file-like object, got %s" % type(input).__name__)
+    if not PyFile_Check(output):
+        raise TypeError("output except a file-like object, got %s" % type(output).__name__)
+    if buf_rate <= 0:
+        buf_rate = 1
+
+    chunk = input.read(1)  # type: bytes
+    if not PyBytes_Check(chunk):
+        raise TypeError(f"input must be a file-like rb object, got {type(input).__name__}")
+    if chunk == b"\xfe":  # 去头
+        input.read(1)
+    else:
+        input.seek(0, 0)  # 没有头 回到开头
+
+    cdef int32_t current_buf_len = buf_rate * 8
+    cdef size_t output_size = <size_t> b14_decode_len(<int> current_buf_len, 0) + 16
+    cdef char *output_buf = <char *> PyMem_Malloc(output_size)
+    if output_buf == NULL:
+        raise MemoryError
+    cdef Py_ssize_t size
+    cdef int count = 0
+    cdef const char *chunk_ptr
+    try:
+        while True:
+            chunk = input.read(current_buf_len)  # 8的倍数
+            size = PyBytes_Size(chunk)
+            if size == 0:
+                break
+            if <int32_t> size < current_buf_len:  # 长度不够了
+                if buf_rate > 1:  # 还能继续变小
+                    buf_rate = buf_rate / 2  # 重新设置一次读取的大小
+                    current_buf_len = buf_rate * 8
+                    input.seek(-size, 1)
+                    continue
+            tmp = input.read(2)  # type: bytes
+            if PyBytes_Size(tmp) == 2:
+                if tmp[0] == 61:  # = stream完了   一次解码8n+2个字节
+                    chunk += tmp
+                    size += 2
+                else:
+                    input.seek(-2, 1)
+            chunk_ptr = <const char *> PyBytes_AS_STRING(chunk)
+            with nogil:
+                count = b14_decode(chunk_ptr, <int> size, output_buf)
+            output.write(<bytes>output_buf[:count])
+    finally:
+        PyMem_Free(output_buf)
+
+cpdef inline bint is_64bits() nogil:
+    return pybase16384_64bits()
+
+cdef inline str err_to_str(base16384_err_t ret):
+    if ret == base16384_err_get_file_size:
+        return "base16384_err_get_file_size"
+    elif ret == base16384_err_fopen_output_file:
+        return "base16384_err_fopen_output_file"
+    elif ret == base16384_err_fopen_input_file:
+        return "base16384_err_fopen_input_file"
+    elif ret == base16384_err_write_file:
+        return "base16384_err_write_file"
+    elif ret == base16384_err_open_input_file:
+        return "base16384_err_open_input_file"
+    elif ret == base16384_err_map_input_file:
+        return "base16384_err_map_input_file"
+    elif ret == base16384_err_read_file:
+        return "base16384_err_read_file"
+    elif ret == base16384_err_invalid_file_name:
+        return "base16384_err_invalid_file_name"
+    elif ret == base16384_err_invalid_commandline_parameter:
+        return "base16384_err_invalid_commandline_parameter"
+    elif ret == base16384_err_invalid_decoding_checksum:
+        return "base16384_err_invalid_decoding_checksum"
+
+cpdef inline encode_local_file(object inp, object out):
+    cdef bytes inp_name = ensure_bytes(inp)
+    cdef bytes out_name = ensure_bytes(out)
+    cdef const char * inp_name_ptr = <const char *> inp_name
+    cdef const char * out_name_ptr = <const char *> out_name
+    cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_encode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
+        if ret !=  base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+cpdef inline decode_local_file(object inp, object out):
+    cdef bytes inp_name = ensure_bytes(inp)
+    cdef bytes out_name = ensure_bytes(out)
+    cdef const char * inp_name_ptr = <const char *> inp_name
+    cdef const char * out_name_ptr = <const char *> out_name
+    cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_decode_file(inp_name_ptr, out_name_ptr, encbuf, decbuf)
+        if ret !=  base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+cpdef inline encode_fd(int inp, int out):
+    cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_encode_fd(inp, out, encbuf, decbuf)
+        if ret != base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+cpdef inline decode_fd(int inp, int out):
+    cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_decode_fd(inp, out, encbuf, decbuf)
+        if ret != base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+# detailed
+cpdef inline encode_local_file_detailed(object inp, object out, int flag):
+    cdef bytes inp_name = ensure_bytes(inp)
+    cdef bytes out_name = ensure_bytes(out)
+    cdef const char * inp_name_ptr = <const char *> inp_name
+    cdef const char * out_name_ptr = <const char *> out_name
+    cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_encode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+        if ret !=  base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+cpdef inline decode_local_file_detailed(object inp, object out, int flag):
+    cdef bytes inp_name = ensure_bytes(inp)
+    cdef bytes out_name = ensure_bytes(out)
+    cdef const char * inp_name_ptr = <const char *> inp_name
+    cdef const char * out_name_ptr = <const char *> out_name
+    cdef char * encbuf = <char*>PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char*>PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_decode_file_detailed(inp_name_ptr, out_name_ptr, encbuf, decbuf, flag)
+        if ret !=  base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+cpdef inline encode_fd_detailed(int inp, int out, int flag):
+    cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_encode_fd_detailed(inp, out, encbuf, decbuf, flag)
+        if ret != base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
+
+cpdef inline decode_fd_detailed(int inp, int out, int flag):
+    cdef char * encbuf = <char *> PyMem_Malloc(<size_t>BASE16384_ENCBUFSZ)
+    if encbuf == NULL:
+        raise MemoryError
+    cdef char * decbuf = <char *> PyMem_Malloc(<size_t>BASE16384_DECBUFSZ)
+    if decbuf == NULL:
+        PyMem_Free(encbuf)
+        raise MemoryError
+    cdef base16384_err_t ret
+    try:
+        with nogil:
+            ret = b14_decode_fd_detailed(inp, out, encbuf, decbuf, flag)
+        if ret != base16384_err_ok:
+            raise ValueError(err_to_str(ret))
+    finally:
+        PyMem_Free(encbuf)
+        PyMem_Free(decbuf)
```

## pybase16384/backends/cython/base16384.pxd

```diff
@@ -1,54 +1,95 @@
-# cython: language_level=3
-# cython: cdivision=True
-from libc.stdint cimport int32_t
-from libc.stdio cimport FILE
-
-
-cdef extern from "base16384.h" nogil:
-    int BASE16384_ENCBUFSZ
-    int BASE16384_DECBUFSZ
-    ctypedef enum base16384_err_t:
-        base16384_err_ok
-        base16384_err_get_file_size
-        base16384_err_fopen_output_file
-        base16384_err_fopen_input_file
-        base16384_err_write_file
-        base16384_err_open_input_file
-        base16384_err_map_input_file
-    # encode_len calc min buf size to fill encode result
-    int b14_encode_len "base16384_encode_len" (int dlen)
-# decode_len calc min buf size to fill decode result
-    int b14_decode_len "base16384_decode_len" (int dlen, int offset)
-
-# encode data and write result into buf
-    int b14_encode "base16384_encode" (const char* data, int dlen, char* buf)
-# decode data and write result into buf
-    int b14_decode "base16384_decode" (const char* data, int dlen, char* buf)
-
-    base16384_err_t b14_encode_file "base16384_encode_file" (const char * input, const char * output, char * encbuf, char * decbuf)
-    base16384_err_t b14_decode_file "base16384_decode_file" (const char * input, const char * output, char * encbuf, char * decbuf)
-
-    base16384_err_t b14_encode_fp "base16384_encode_fp" (FILE* input, FILE* output, char* encbuf, char* decbuf)
-
-    # base16384_encode_fd encodes input fd to output fd.
-    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-    base16384_err_t b14_encode_fd "base16384_encode_fd" (int input, int output, char* encbuf, char* decbuf)
-
-
-    # base16384_decode_fp decodes input file to output file.
-    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-    base16384_err_t b14_decode_fp "base16384_decode_fp"(FILE* input, FILE* output, char* encbuf, char* decbuf)
-
-    # base16384_decode_fd decodes input fd to output fd.
-    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
-    base16384_err_t b14_decode_fd "base16384_decode_fd"(int input, int output, char* encbuf, char* decbuf)
-
-cdef extern from * nogil:
-    """
-#ifdef CPUBIT32
-#define pybase16384_64bits() 0
-#else
-#define pybase16384_64bits() 1
-#endif
-    """
-    int32_t pybase16384_64bits()
+# cython: language_level=3
+# cython: cdivision=True
+from libc.stdint cimport int32_t
+from libc.stdio cimport FILE
+
+
+cdef extern from "base16384.h" nogil:
+    int BASE16384_ENCBUFSZ
+    int BASE16384_DECBUFSZ
+
+    int BASE16384_FLAG_NOHEADER
+    int BASE16384_FLAG_SUM_CHECK_ON_REMAIN
+    int BASE16384_SIMPLE_SUM_INIT_VALUE
+
+    ctypedef enum base16384_err_t:
+        base16384_err_ok
+        base16384_err_get_file_size
+        base16384_err_fopen_output_file
+        base16384_err_fopen_input_file
+        base16384_err_write_file
+        base16384_err_open_input_file
+        base16384_err_map_input_file
+        base16384_err_read_file
+        base16384_err_invalid_file_name
+        base16384_err_invalid_commandline_parameter
+        base16384_err_invalid_decoding_checksum
+    # encode_len calc min buf size to fill encode result
+    int b14_encode_len "base16384_encode_len" (int dlen)
+# decode_len calc min buf size to fill decode result
+    int b14_decode_len "base16384_decode_len" (int dlen, int offset)
+
+# encode data and write result into buf
+    int b14_encode "base16384_encode" (const char* data, int dlen, char* buf)
+
+    int b14_encode_unsafe "base16384_encode_unsafe" (const char * data, int dlen, char * buf)
+# decode data and write result into buf
+    int b14_decode "base16384_decode" (const char* data, int dlen, char* buf)
+
+    int b14_decode_unsafe "base16384_decode_unsafe"(const char * data, int dlen, char * buf)
+
+    base16384_err_t b14_encode_file "base16384_encode_file" (const char * input, const char * output, char * encbuf, char * decbuf)
+    base16384_err_t b14_decode_file "base16384_decode_file" (const char * input, const char * output, char * encbuf, char * decbuf)
+
+    base16384_err_t b14_encode_fp "base16384_encode_fp" (FILE* input, FILE* output, char* encbuf, char* decbuf)
+
+    # base16384_encode_fd encodes input fd to output fd.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_encode_fd "base16384_encode_fd" (int input, int output, char* encbuf, char* decbuf)
+
+
+    # base16384_decode_fp decodes input file to output file.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_decode_fp "base16384_decode_fp"(FILE* input, FILE* output, char* encbuf, char* decbuf)
+
+    # base16384_decode_fd decodes input fd to output fd.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_decode_fd "base16384_decode_fd"(int input, int output, char* encbuf, char* decbuf)
+
+    # detailed
+        # base16384_encode_file_detailed encodes input file to output file.
+    #    use `-` to specify stdin/stdout
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_encode_file_detailed "base16384_encode_file_detailed" (const char* input, const char* output, char* encbuf, char* decbuf, int flag)
+
+    # base16384_encode_fp_detailed encodes input file to output file.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_encode_fp_detailed "base16384_encode_fp_detailed" (FILE* input, FILE* output, char* encbuf, char* decbuf, int flag)
+
+    # base16384_encode_fd_detailed encodes input fd to output fd.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_encode_fd_detailed "base16384_encode_fd_detailed" (int input, int output, char* encbuf, char* decbuf, int flag)
+
+    # base16384_decode_file_detailed decodes input file to output file.
+    #    use `-` to specify stdin/stdout
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_decode_file_detailed "base16384_decode_file_detailed" (const char* input, const char* output, char* encbuf, char* decbuf, int flag)
+
+    # base16384_decode_fp_detailed decodes input file to output file.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_decode_fp_detailed "base16384_decode_fp_detailed" (FILE* input, FILE* output, char* encbuf, char* decbuf, int flag)
+
+    # base16384_decode_fd_detailed decodes input fd to output fd.
+    #    encbuf & decbuf must be no less than BASE16384_ENCBUFSZ & BASE16384_DECBUFSZ
+    base16384_err_t b14_decode_fd_detailed "base16384_decode_fd_detailed" (int input, int output, char* encbuf, char* decbuf, int flag)
+
+
+cdef extern from * nogil:
+    """
+#ifdef CPUBIT32
+#define pybase16384_64bits() 0
+#else
+#define pybase16384_64bits() 1
+#endif
+    """
+    int32_t pybase16384_64bits()
```

## Comparing `pybase16384-0.3.5.dist-info/LICENSE` & `pybase16384-0.3.6.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,674 +1,674 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<https://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<https://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
 <https://www.gnu.org/licenses/why-not-lgpl.html>.
```

## Comparing `pybase16384-0.3.5.dist-info/METADATA` & `pybase16384-0.3.6.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,152 +1,152 @@
-Metadata-Version: 2.1
-Name: pybase16384
-Version: 0.3.5
-Summary: fast base16384 encode and decode
-Home-page: https://github.com/synodriver/pybase16384
-Author: synodriver
-Author-email: diguohuangjiajinweijun@gmail.com
-License: GPLv3
-Keywords: encode,decode,base16384
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Operating System :: OS Independent
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
-Classifier: Topic :: Security :: Cryptography
-Classifier: Programming Language :: C
-Classifier: Programming Language :: Cython
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: 3.12
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: cffi (>=1.0.0)
-
-<h1 align="center"><i>✨ pybase16384 ✨ </i></h1>
-
-<h3 align="center">The python binding for <a href="https://github.com/fumiama/base16384">base16384</a> </h3>
-
-<h3 align="center"><i>一种神奇的编码 </i></h3>
-
-[![pypi](https://img.shields.io/pypi/v/pybase16384.svg)](https://pypi.org/project/pybase16384/)
-![python](https://img.shields.io/pypi/pyversions/pybase16384)
-![implementation](https://img.shields.io/pypi/implementation/pybase16384)
-![wheel](https://img.shields.io/pypi/wheel/pybase16384)
-![license](https://img.shields.io/github/license/synodriver/pybase16384.svg)
-![action](https://img.shields.io/github/workflow/status/synodriver/pybase16384/build%20wheel)
-
-
-### 使用
-
-- 编码/解码文本
-```python
->>> import pybase16384 as pybs
->>> pybs.encode_string('hello!!')
-'栙擆羼漡'
->>> pybs.decode_string('栙擆羼漡')
-'hello!!'
-```
-
-- 编码文件
-
-```python
-from io import BytesIO
-
-import pybase16384 as pybs
-
-with open("input.pcm", "rb") as f:
-    data = f.read()
-for i in range(1):
-    pybs.encode_file(BytesIO(data), open("output2.pcm", 'wb'), True)
-```
-- 解码文件
-
-```python
-from io import BytesIO
-
-import pybase16384 as pybs
-
-with open("output2.pcm", "rb") as f:
-    data = f.read()
-for i in range(1):
-    pybs.decode_file(BytesIO(data), open("input2.pcm", 'wb'))
-```
-
-### 公开函数
-```python
-def encode_len(dlen: int) -> int: ...
-
-def decode_len(dlen: int, offset: int) -> int: ...
-
-def encode(data: bytes) -> bytes: ...
-
-def decode(data: bytes) -> bytes: ...
-
-def decode_file(input: BinaryIO, output: BinaryIO, buf_rate: int = 10) -> None: ...
-
-def encode_file(input: BinaryIO, output: BinaryIO, boolwrite_head: bool = False, buf_rate: int = 10) -> None: ...
-
-def encode_from_string(data: str, write_head: bool = False) -> bytes: ...
-
-def encode_to_string(data: bytes) -> str: ...
-
-def encode_string(data: str) -> str: ...
-
-def decode_from_bytes(data: bytes) -> str: ...
-
-def decode_from_string(data: str) -> bytes: ...
-
-def decode_string(data: str) -> str: ...
-
-def encode_local_file(inp: Union[str, bytes, Path], out: Union[str, bytes, Path], encsize: int, decsize: int) -> None: ...
-
-def decode_local_file(inp: Union[str, bytes, Path], out: Union[str, bytes, Path], encsize: int, decsize: int) -> None: ...
-
-def encode_fd(inp: int, out: int) -> None: ...
-    
-def decode_fd(inp: int, out: int) -> None: ...
-```
-- write_head将显式指明编码出的文本格式(utf16be)，以便文本编辑器(如记事本)能够正确渲染，一般在写入文件时使用。
-
-- buf_rate指定读取文件的策略。当它为n时，则表示一次读取7n或者8n个字节。如果读到的字节长度小于预期，则说明长度不够，
-此时，n将减半，恢复文件指针，重新读取。如果当n=1时长度仍然不够，就地encode/decode处理之。
-
-- ```encode_len```和```decode_len```用于计算输出的长度
-
-### 内部函数
-
-- 他们直接来自底层的C库，高性能，但是一般不需要在外部使用（除非是增加性能）
-
-```python
-def _encode(data: BufferProtocol) -> bytes: ...
-
-def _decode(data: BufferProtocol) -> bytes: ...
-
-def _encode_into(data: BufferProtocol, dest: BufferProtocol) -> int: ...
-
-def _decode_into(data: BufferProtocol, dest: BufferProtocol) -> int: ...
-
-def is_64bits() -> bool: ...
-```
-- ```_decode```在解码```b'='```开头的数据时***不安全***：***解释器异常***
-- ```_encode_into```和```_decode_into```直接操作缓冲区对象的底层指针，0拷贝，当然也和上面一样的问题，他们是没有检查的
-
-### ✨  v0.3更新 ✨ 
-融合了 [CFFI](https://github.com/synodriver/pybase16384-cffi) 版本的成果，现在一个包可以同时在cpython和pypy上运行
-
-### 本机编译
-```
-python -m pip install setuptools wheel cython cffi
-git clone https://github.com/synodriver/pybase16384
-cd pybase16384
-git submodule update --init --recursive
-python setup.py bdist_wheel --use-cython --use-cffi
-```
-- 为了在windows上编译，需要加点料，把 [这个](https://gist.github.com/synodriver/8f1afae7b1a221754cb04ce417dc7e4d) 放进msvc的目录
-
-### 后端选择
-默认由py实现决定，在cpython上自动选择cython后端，在pypy上自动选择cffi后端，使用```B14_USE_CFFI```环境变量可以强制选择cffi
+Metadata-Version: 2.1
+Name: pybase16384
+Version: 0.3.6
+Summary: fast base16384 encode and decode
+Home-page: https://github.com/synodriver/pybase16384
+Author: synodriver
+Author-email: diguohuangjiajinweijun@gmail.com
+License: GPLv3
+Keywords: encode,decode,base16384
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Operating System :: OS Independent
+Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
+Classifier: Topic :: Security :: Cryptography
+Classifier: Programming Language :: C
+Classifier: Programming Language :: Cython
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: cffi (>=1.0.0)
+
+<h1 align="center"><i>✨ pybase16384 ✨ </i></h1>
+
+<h3 align="center">The python binding for <a href="https://github.com/fumiama/base16384">base16384</a> </h3>
+
+<h3 align="center"><i>一种神奇的编码 </i></h3>
+
+[![pypi](https://img.shields.io/pypi/v/pybase16384.svg)](https://pypi.org/project/pybase16384/)
+![python](https://img.shields.io/pypi/pyversions/pybase16384)
+![implementation](https://img.shields.io/pypi/implementation/pybase16384)
+![wheel](https://img.shields.io/pypi/wheel/pybase16384)
+![license](https://img.shields.io/github/license/synodriver/pybase16384.svg)
+![action](https://img.shields.io/github/workflow/status/synodriver/pybase16384/build%20wheel)
+
+
+### 使用
+
+- 编码/解码文本
+```python
+>>> import pybase16384 as pybs
+>>> pybs.encode_string('hello!!')
+'栙擆羼漡'
+>>> pybs.decode_string('栙擆羼漡')
+'hello!!'
+```
+
+- 编码文件
+
+```python
+from io import BytesIO
+
+import pybase16384 as pybs
+
+with open("input.pcm", "rb") as f:
+    data = f.read()
+for i in range(1):
+    pybs.encode_file(BytesIO(data), open("output2.pcm", 'wb'), True)
+```
+- 解码文件
+
+```python
+from io import BytesIO
+
+import pybase16384 as pybs
+
+with open("output2.pcm", "rb") as f:
+    data = f.read()
+for i in range(1):
+    pybs.decode_file(BytesIO(data), open("input2.pcm", 'wb'))
+```
+
+### 公开函数
+```python
+def encode_len(dlen: int) -> int: ...
+
+def decode_len(dlen: int, offset: int) -> int: ...
+
+def encode(data: bytes) -> bytes: ...
+
+def decode(data: bytes) -> bytes: ...
+
+def decode_file(input: BinaryIO, output: BinaryIO, buf_rate: int = 10) -> None: ...
+
+def encode_file(input: BinaryIO, output: BinaryIO, boolwrite_head: bool = False, buf_rate: int = 10) -> None: ...
+
+def encode_from_string(data: str, write_head: bool = False) -> bytes: ...
+
+def encode_to_string(data: bytes) -> str: ...
+
+def encode_string(data: str) -> str: ...
+
+def decode_from_bytes(data: bytes) -> str: ...
+
+def decode_from_string(data: str) -> bytes: ...
+
+def decode_string(data: str) -> str: ...
+
+def encode_local_file(inp: Union[str, bytes, Path], out: Union[str, bytes, Path], encsize: int, decsize: int) -> None: ...
+
+def decode_local_file(inp: Union[str, bytes, Path], out: Union[str, bytes, Path], encsize: int, decsize: int) -> None: ...
+
+def encode_fd(inp: int, out: int) -> None: ...
+    
+def decode_fd(inp: int, out: int) -> None: ...
+```
+- write_head将显式指明编码出的文本格式(utf16be)，以便文本编辑器(如记事本)能够正确渲染，一般在写入文件时使用。
+
+- buf_rate指定读取文件的策略。当它为n时，则表示一次读取7n或者8n个字节。如果读到的字节长度小于预期，则说明长度不够，
+此时，n将减半，恢复文件指针，重新读取。如果当n=1时长度仍然不够，就地encode/decode处理之。
+
+- ```encode_len```和```decode_len```用于计算输出的长度
+
+### 内部函数
+
+- 他们直接来自底层的C库，高性能，但是一般不需要在外部使用（除非是增加性能）
+
+```python
+def _encode(data: BufferProtocol) -> bytes: ...
+
+def _decode(data: BufferProtocol) -> bytes: ...
+
+def _encode_into(data: BufferProtocol, dest: BufferProtocol) -> int: ...
+
+def _decode_into(data: BufferProtocol, dest: BufferProtocol) -> int: ...
+
+def is_64bits() -> bool: ...
+```
+- ```_decode```在解码```b'='```开头的数据时***不安全***：***解释器异常***
+- ```_encode_into```和```_decode_into```直接操作缓冲区对象的底层指针，0拷贝，当然也和上面一样的问题，他们是没有检查的
+
+### ✨  v0.3更新 ✨ 
+融合了 [CFFI](https://github.com/synodriver/pybase16384-cffi) 版本的成果，现在一个包可以同时在cpython和pypy上运行
+
+### 本机编译
+```
+python -m pip install setuptools wheel cython cffi
+git clone https://github.com/synodriver/pybase16384
+cd pybase16384
+git submodule update --init --recursive
+python setup.py bdist_wheel --use-cython --use-cffi
+```
+- 为了在windows上编译，需要加点料，把 [这个](https://gist.github.com/synodriver/8f1afae7b1a221754cb04ce417dc7e4d) 放进msvc的目录
+
+### 后端选择
+默认由py实现决定，在cpython上自动选择cython后端，在pypy上自动选择cffi后端，使用```B14_USE_CFFI```环境变量可以强制选择cffi
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: pybase16384 Version: 0.3.5 Summary: fast base16384
+Metadata-Version: 2.1 Name: pybase16384 Version: 0.3.6 Summary: fast base16384
 encode and decode Home-page: https://github.com/synodriver/pybase16384 Author:
 synodriver Author-email: diguohuangjiajinweijun@gmail.com License: GPLv3
 Keywords: encode,decode,base16384 Classifier: Development Status :: 5 -
 Production/Stable Classifier: Operating System :: OS Independent Classifier:
 License :: OSI Approved :: GNU General Public License v3 (GPLv3) Classifier:
 Topic :: Security :: Cryptography Classifier: Programming Language :: C
 Classifier: Programming Language :: Cython Classifier: Programming Language ::
```

