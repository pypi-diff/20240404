# Comparing `tmp/authentik_client-2024.2.2.post1710845398.tar.gz` & `tmp/authentik_client-2024.2.2.post1712239192.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "authentik_client-2024.2.2.post1710845398.tar", max compression
+gzip compressed data, was "authentik_client-2024.2.2.post1712239192.tar", max compression
```

## Comparing `authentik_client-2024.2.2.post1710845398.tar` & `authentik_client-2024.2.2.post1712239192.tar`

### file list

```diff
@@ -1,578 +1,580 @@
--rw-r--r--   0        0        0   139921 2024-03-19 10:50:07.331888 authentik_client-2024.2.2.post1710845398/README.md
--rw-r--r--   0        0        0    47074 2024-03-19 10:50:07.351524 authentik_client-2024.2.2.post1710845398/authentik_client/__init__.py
--rw-r--r--   0        0        0     1170 2024-03-19 10:50:07.356950 authentik_client-2024.2.2.post1710845398/authentik_client/api/__init__.py
--rw-r--r--   0        0        0    59024 2024-03-19 10:50:06.929377 authentik_client-2024.2.2.post1710845398/authentik_client/api/admin_api.py
--rw-r--r--   0        0        0   430160 2024-03-19 10:50:06.950183 authentik_client-2024.2.2.post1710845398/authentik_client/api/authenticators_api.py
--rw-r--r--   0        0        0   428970 2024-03-19 10:50:06.982602 authentik_client-2024.2.2.post1710845398/authentik_client/api/core_api.py
--rw-r--r--   0        0        0    72725 2024-03-19 10:50:06.998978 authentik_client-2024.2.2.post1710845398/authentik_client/api/crypto_api.py
--rw-r--r--   0        0        0    66369 2024-03-19 10:50:07.008439 authentik_client-2024.2.2.post1710845398/authentik_client/api/enterprise_api.py
--rw-r--r--   0        0        0   251627 2024-03-19 10:50:07.025623 authentik_client-2024.2.2.post1710845398/authentik_client/api/events_api.py
--rw-r--r--   0        0        0   172473 2024-03-19 10:50:07.045996 authentik_client-2024.2.2.post1710845398/authentik_client/api/flows_api.py
--rw-r--r--   0        0        0    62473 2024-03-19 10:50:07.063713 authentik_client-2024.2.2.post1710845398/authentik_client/api/managed_api.py
--rw-r--r--   0        0        0    83655 2024-03-19 10:50:07.073679 authentik_client-2024.2.2.post1710845398/authentik_client/api/oauth2_api.py
--rw-r--r--   0        0        0   257000 2024-03-19 10:50:07.091099 authentik_client-2024.2.2.post1710845398/authentik_client/api/outposts_api.py
--rw-r--r--   0        0        0   448625 2024-03-19 10:50:07.117414 authentik_client-2024.2.2.post1710845398/authentik_client/api/policies_api.py
--rw-r--r--   0        0        0   341285 2024-03-19 10:50:07.172214 authentik_client-2024.2.2.post1710845398/authentik_client/api/propertymappings_api.py
--rw-r--r--   0        0        0   444262 2024-03-19 10:50:07.195685 authentik_client-2024.2.2.post1710845398/authentik_client/api/providers_api.py
--rw-r--r--   0        0        0    93002 2024-03-19 10:50:07.209074 authentik_client-2024.2.2.post1710845398/authentik_client/api/rac_api.py
--rw-r--r--   0        0        0   128779 2024-03-19 10:50:07.222891 authentik_client-2024.2.2.post1710845398/authentik_client/api/rbac_api.py
--rw-r--r--   0        0        0     6565 2024-03-19 10:50:07.231682 authentik_client-2024.2.2.post1710845398/authentik_client/api/root_api.py
--rw-r--r--   0        0        0     7565 2024-03-19 10:50:07.236429 authentik_client-2024.2.2.post1710845398/authentik_client/api/schema_api.py
--rw-r--r--   0        0        0   494371 2024-03-19 10:50:07.253364 authentik_client-2024.2.2.post1710845398/authentik_client/api/sources_api.py
--rw-r--r--   0        0        0  1184744 2024-03-19 10:50:07.297591 authentik_client-2024.2.2.post1710845398/authentik_client/api/stages_api.py
--rw-r--r--   0        0        0    97010 2024-03-19 10:50:07.319076 authentik_client-2024.2.2.post1710845398/authentik_client/api/tenants_api.py
--rw-r--r--   0        0        0    29509 2024-03-19 10:50:07.362070 authentik_client-2024.2.2.post1710845398/authentik_client/api_client.py
--rw-r--r--   0        0        0      852 2024-03-19 10:50:07.362816 authentik_client-2024.2.2.post1710845398/authentik_client/api_response.py
--rw-r--r--   0        0        0    15247 2024-03-19 10:50:07.348929 authentik_client-2024.2.2.post1710845398/authentik_client/configuration.py
--rw-r--r--   0        0        0     5387 2024-03-19 10:50:07.358728 authentik_client-2024.2.2.post1710845398/authentik_client/exceptions.py
--rw-r--r--   0        0        0    45376 2024-03-19 10:50:07.354692 authentik_client-2024.2.2.post1710845398/authentik_client/models/__init__.py
--rw-r--r--   0        0        0     4014 2024-03-19 10:50:03.055288 authentik_client-2024.2.2.post1710845398/authentik_client/models/access_denied_challenge.py
--rw-r--r--   0        0        0     1869 2024-03-19 10:50:03.072963 authentik_client-2024.2.2.post1710845398/authentik_client/models/app.py
--rw-r--r--   0        0        0     4155 2024-03-19 10:50:03.081602 authentik_client-2024.2.2.post1710845398/authentik_client/models/app_enum.py
--rw-r--r--   0        0        0     2123 2024-03-19 10:50:03.091321 authentik_client-2024.2.2.post1710845398/authentik_client/models/apple_challenge_response_request.py
--rw-r--r--   0        0        0     4027 2024-03-19 10:50:03.099475 authentik_client-2024.2.2.post1710845398/authentik_client/models/apple_login_challenge.py
--rw-r--r--   0        0        0     5928 2024-03-19 10:50:03.109426 authentik_client-2024.2.2.post1710845398/authentik_client/models/application.py
--rw-r--r--   0        0        0     3846 2024-03-19 10:50:03.119114 authentik_client-2024.2.2.post1710845398/authentik_client/models/application_request.py
--rw-r--r--   0        0        0      708 2024-03-19 10:50:03.125106 authentik_client-2024.2.2.post1710845398/authentik_client/models/auth_mode_enum.py
--rw-r--r--   0        0        0      706 2024-03-19 10:50:03.131147 authentik_client-2024.2.2.post1710845398/authentik_client/models/auth_type_enum.py
--rw-r--r--   0        0        0     5398 2024-03-19 10:50:03.136096 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticate_web_authn_stage.py
--rw-r--r--   0        0        0     4570 2024-03-19 10:50:03.143215 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticate_web_authn_stage_request.py
--rw-r--r--   0        0        0     4441 2024-03-19 10:50:03.149012 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session.py
--rw-r--r--   0        0        0     2553 2024-03-19 10:50:03.154292 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_asn.py
--rw-r--r--   0        0        0     2357 2024-03-19 10:50:03.159468 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_geo_ip.py
--rw-r--r--   0        0        0     3394 2024-03-19 10:50:03.165365 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent.py
--rw-r--r--   0        0        0     2174 2024-03-19 10:50:03.170642 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent_device.py
--rw-r--r--   0        0        0     2330 2024-03-19 10:50:03.176766 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent_os.py
--rw-r--r--   0        0        0     2278 2024-03-19 10:50:03.182507 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent_user_agent.py
--rw-r--r--   0        0        0      904 2024-03-19 10:50:03.188273 authentik_client-2024.2.2.post1710845398/authentik_client/models/authentication_enum.py
--rw-r--r--   0        0        0      809 2024-03-19 10:50:03.193287 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_attachment_enum.py
--rw-r--r--   0        0        0     4242 2024-03-19 10:50:03.198775 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_challenge.py
--rw-r--r--   0        0        0     2208 2024-03-19 10:50:03.204444 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_challenge_response_request.py
--rw-r--r--   0        0        0     4678 2024-03-19 10:50:03.210367 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage.py
--rw-r--r--   0        0        0     2225 2024-03-19 10:50:03.215113 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage_device_import_response.py
--rw-r--r--   0        0        0     2261 2024-03-19 10:50:03.219933 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage_manual_device_import_request.py
--rw-r--r--   0        0        0     4166 2024-03-19 10:50:03.226449 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage_request.py
--rw-r--r--   0        0        0     4111 2024-03-19 10:50:03.231798 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_challenge.py
--rw-r--r--   0        0        0     2472 2024-03-19 10:50:03.236497 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_challenge_response_request.py
--rw-r--r--   0        0        0     5766 2024-03-19 10:50:03.243987 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_stage.py
--rw-r--r--   0        0        0     5010 2024-03-19 10:50:03.248754 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_stage_request.py
--rw-r--r--   0        0        0     4019 2024-03-19 10:50:03.253956 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_challenge.py
--rw-r--r--   0        0        0     2238 2024-03-19 10:50:03.259751 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_challenge_response_request.py
--rw-r--r--   0        0        0     4638 2024-03-19 10:50:03.264833 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_stage.py
--rw-r--r--   0        0        0     3810 2024-03-19 10:50:03.268582 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_stage_request.py
--rw-r--r--   0        0        0     4002 2024-03-19 10:50:03.273194 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_challenge.py
--rw-r--r--   0        0        0     2347 2024-03-19 10:50:03.278008 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_challenge_response_request.py
--rw-r--r--   0        0        0     4474 2024-03-19 10:50:03.283648 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_stage.py
--rw-r--r--   0        0        0     3646 2024-03-19 10:50:03.288607 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_stage_request.py
--rw-r--r--   0        0        0     4971 2024-03-19 10:50:03.293502 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validate_stage.py
--rw-r--r--   0        0        0     4143 2024-03-19 10:50:03.299014 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validate_stage_request.py
--rw-r--r--   0        0        0     5302 2024-03-19 10:50:03.306394 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validation_challenge.py
--rw-r--r--   0        0        0     3283 2024-03-19 10:50:03.310925 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validation_challenge_response_request.py
--rw-r--r--   0        0        0     4054 2024-03-19 10:50:03.316232 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_web_authn_challenge.py
--rw-r--r--   0        0        0     2368 2024-03-19 10:50:03.322171 authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_web_authn_challenge_response_request.py
--rw-r--r--   0        0        0     2159 2024-03-19 10:50:03.336781 authentik_client-2024.2.2.post1710845398/authentik_client/models/auto_submit_challenge_response_request.py
--rw-r--r--   0        0        0     3881 2024-03-19 10:50:03.346103 authentik_client-2024.2.2.post1710845398/authentik_client/models/autosubmit_challenge.py
--rw-r--r--   0        0        0      947 2024-03-19 10:50:03.350912 authentik_client-2024.2.2.post1710845398/authentik_client/models/backends_enum.py
--rw-r--r--   0        0        0      751 2024-03-19 10:50:03.356412 authentik_client-2024.2.2.post1710845398/authentik_client/models/binding_type_enum.py
--rw-r--r--   0        0        0     2403 2024-03-19 10:50:03.363346 authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_file.py
--rw-r--r--   0        0        0     3788 2024-03-19 10:50:03.372033 authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_instance.py
--rw-r--r--   0        0        0     2630 2024-03-19 10:50:03.380324 authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_instance_request.py
--rw-r--r--   0        0        0      863 2024-03-19 10:50:03.391390 authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_instance_status_enum.py
--rw-r--r--   0        0        0     5583 2024-03-19 10:50:03.427100 authentik_client-2024.2.2.post1710845398/authentik_client/models/brand.py
--rw-r--r--   0        0        0     5592 2024-03-19 10:50:03.454078 authentik_client-2024.2.2.post1710845398/authentik_client/models/brand_request.py
--rw-r--r--   0        0        0     1849 2024-03-19 10:50:03.480354 authentik_client-2024.2.2.post1710845398/authentik_client/models/cache.py
--rw-r--r--   0        0        0      880 2024-03-19 10:50:03.494088 authentik_client-2024.2.2.post1710845398/authentik_client/models/capabilities_enum.py
--rw-r--r--   0        0        0     3983 2024-03-19 10:50:03.519388 authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_challenge.py
--rw-r--r--   0        0        0     2231 2024-03-19 10:50:03.541882 authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_challenge_response_request.py
--rw-r--r--   0        0        0     3748 2024-03-19 10:50:03.566667 authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_stage.py
--rw-r--r--   0        0        0     3147 2024-03-19 10:50:03.586401 authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_stage_request.py
--rw-r--r--   0        0        0     1910 2024-03-19 10:50:03.604843 authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_data.py
--rw-r--r--   0        0        0     2311 2024-03-19 10:50:03.627981 authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_generation_request.py
--rw-r--r--   0        0        0     5792 2024-03-19 10:50:03.646589 authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_key_pair.py
--rw-r--r--   0        0        0     2396 2024-03-19 10:50:03.668417 authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_key_pair_request.py
--rw-r--r--   0        0        0      752 2024-03-19 10:50:03.682565 authentik_client-2024.2.2.post1710845398/authentik_client/models/challenge_choices.py
--rw-r--r--   0        0        0    23086 2024-03-19 10:50:03.716501 authentik_client-2024.2.2.post1710845398/authentik_client/models/challenge_types.py
--rw-r--r--   0        0        0      730 2024-03-19 10:50:03.729068 authentik_client-2024.2.2.post1710845398/authentik_client/models/client_type_enum.py
--rw-r--r--   0        0        0     3029 2024-03-19 10:50:03.744355 authentik_client-2024.2.2.post1710845398/authentik_client/models/config.py
--rw-r--r--   0        0        0     3422 2024-03-19 10:50:03.763754 authentik_client-2024.2.2.post1710845398/authentik_client/models/connection_token.py
--rw-r--r--   0        0        0     2142 2024-03-19 10:50:03.791482 authentik_client-2024.2.2.post1710845398/authentik_client/models/connection_token_request.py
--rw-r--r--   0        0        0     5270 2024-03-19 10:50:03.816583 authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_challenge.py
--rw-r--r--   0        0        0     2272 2024-03-19 10:50:03.834242 authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_challenge_response_request.py
--rw-r--r--   0        0        0     1956 2024-03-19 10:50:03.850452 authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_permission.py
--rw-r--r--   0        0        0     3808 2024-03-19 10:50:03.869877 authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_stage.py
--rw-r--r--   0        0        0      796 2024-03-19 10:50:03.882246 authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_stage_mode_enum.py
--rw-r--r--   0        0        0     2969 2024-03-19 10:50:03.899816 authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_stage_request.py
--rw-r--r--   0        0        0     2355 2024-03-19 10:50:03.916546 authentik_client-2024.2.2.post1710845398/authentik_client/models/contextual_flow_info.py
--rw-r--r--   0        0        0      908 2024-03-19 10:50:03.926961 authentik_client-2024.2.2.post1710845398/authentik_client/models/contextual_flow_info_layout_enum.py
--rw-r--r--   0        0        0     2004 2024-03-19 10:50:03.941516 authentik_client-2024.2.2.post1710845398/authentik_client/models/coordinate.py
--rw-r--r--   0        0        0     4129 2024-03-19 10:50:03.958818 authentik_client-2024.2.2.post1710845398/authentik_client/models/current_brand.py
--rw-r--r--   0        0        0      776 2024-03-19 10:50:03.968885 authentik_client-2024.2.2.post1710845398/authentik_client/models/denied_action_enum.py
--rw-r--r--   0        0        0     3493 2024-03-19 10:50:03.985977 authentik_client-2024.2.2.post1710845398/authentik_client/models/deny_stage.py
--rw-r--r--   0        0        0     2641 2024-03-19 10:50:04.003677 authentik_client-2024.2.2.post1710845398/authentik_client/models/deny_stage_request.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:04.022092 authentik_client-2024.2.2.post1710845398/authentik_client/models/device.py
--rw-r--r--   0        0        0     2133 2024-03-19 10:50:04.040290 authentik_client-2024.2.2.post1710845398/authentik_client/models/device_challenge.py
--rw-r--r--   0        0        0     2227 2024-03-19 10:50:04.056161 authentik_client-2024.2.2.post1710845398/authentik_client/models/device_challenge_request.py
--rw-r--r--   0        0        0      787 2024-03-19 10:50:04.065215 authentik_client-2024.2.2.post1710845398/authentik_client/models/device_classes_enum.py
--rw-r--r--   0        0        0     1255 2024-03-19 10:50:04.073467 authentik_client-2024.2.2.post1710845398/authentik_client/models/digest_algorithm_enum.py
--rw-r--r--   0        0        0      688 2024-03-19 10:50:04.080003 authentik_client-2024.2.2.post1710845398/authentik_client/models/digits_enum.py
--rw-r--r--   0        0        0     4277 2024-03-19 10:50:04.097800 authentik_client-2024.2.2.post1710845398/authentik_client/models/docker_service_connection.py
--rw-r--r--   0        0        0     3490 2024-03-19 10:50:04.115049 authentik_client-2024.2.2.post1710845398/authentik_client/models/docker_service_connection_request.py
--rw-r--r--   0        0        0     2188 2024-03-19 10:50:04.130445 authentik_client-2024.2.2.post1710845398/authentik_client/models/domain.py
--rw-r--r--   0        0        0     2136 2024-03-19 10:50:04.143261 authentik_client-2024.2.2.post1710845398/authentik_client/models/domain_request.py
--rw-r--r--   0        0        0     3615 2024-03-19 10:50:04.161466 authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_challenge.py
--rw-r--r--   0        0        0     2102 2024-03-19 10:50:04.176221 authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_challenge_response_request.py
--rw-r--r--   0        0        0     3695 2024-03-19 10:50:04.191519 authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_policy.py
--rw-r--r--   0        0        0     2604 2024-03-19 10:50:04.203066 authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_policy_request.py
--rw-r--r--   0        0        0     3510 2024-03-19 10:50:04.221627 authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_stage.py
--rw-r--r--   0        0        0     2647 2024-03-19 10:50:04.235809 authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_stage_request.py
--rw-r--r--   0        0        0     2035 2024-03-19 10:50:04.249072 authentik_client-2024.2.2.post1710845398/authentik_client/models/duo_device.py
--rw-r--r--   0        0        0     2023 2024-03-19 10:50:04.263349 authentik_client-2024.2.2.post1710845398/authentik_client/models/duo_device_enrollment_status.py
--rw-r--r--   0        0        0     1983 2024-03-19 10:50:04.275817 authentik_client-2024.2.2.post1710845398/authentik_client/models/duo_device_request.py
--rw-r--r--   0        0        0      751 2024-03-19 10:50:04.286717 authentik_client-2024.2.2.post1710845398/authentik_client/models/duo_response_enum.py
--rw-r--r--   0        0        0     3537 2024-03-19 10:50:04.303435 authentik_client-2024.2.2.post1710845398/authentik_client/models/email_challenge.py
--rw-r--r--   0        0        0     2191 2024-03-19 10:50:04.318838 authentik_client-2024.2.2.post1710845398/authentik_client/models/email_challenge_response_request.py
--rw-r--r--   0        0        0     5091 2024-03-19 10:50:04.331166 authentik_client-2024.2.2.post1710845398/authentik_client/models/email_stage.py
--rw-r--r--   0        0        0     4415 2024-03-19 10:50:04.336005 authentik_client-2024.2.2.post1710845398/authentik_client/models/email_stage_request.py
--rw-r--r--   0        0        0     4064 2024-03-19 10:50:04.341781 authentik_client-2024.2.2.post1710845398/authentik_client/models/endpoint.py
--rw-r--r--   0        0        0     3112 2024-03-19 10:50:04.357093 authentik_client-2024.2.2.post1710845398/authentik_client/models/endpoint_request.py
--rw-r--r--   0        0        0     1949 2024-03-19 10:50:04.372412 authentik_client-2024.2.2.post1710845398/authentik_client/models/error_detail.py
--rw-r--r--   0        0        0     2650 2024-03-19 10:50:04.384944 authentik_client-2024.2.2.post1710845398/authentik_client/models/error_reporting_config.py
--rw-r--r--   0        0        0     3487 2024-03-19 10:50:04.396725 authentik_client-2024.2.2.post1710845398/authentik_client/models/event.py
--rw-r--r--   0        0        0     1727 2024-03-19 10:50:04.404808 authentik_client-2024.2.2.post1710845398/authentik_client/models/event_actions.py
--rw-r--r--   0        0        0     5228 2024-03-19 10:50:04.416760 authentik_client-2024.2.2.post1710845398/authentik_client/models/event_matcher_policy.py
--rw-r--r--   0        0        0     4161 2024-03-19 10:50:04.428507 authentik_client-2024.2.2.post1710845398/authentik_client/models/event_matcher_policy_request.py
--rw-r--r--   0        0        0     3349 2024-03-19 10:50:04.440857 authentik_client-2024.2.2.post1710845398/authentik_client/models/event_request.py
--rw-r--r--   0        0        0     2173 2024-03-19 10:50:04.451049 authentik_client-2024.2.2.post1710845398/authentik_client/models/event_top_per_user.py
--rw-r--r--   0        0        0     3176 2024-03-19 10:50:04.463910 authentik_client-2024.2.2.post1710845398/authentik_client/models/expiring_base_grant_model.py
--rw-r--r--   0        0        0     3466 2024-03-19 10:50:04.475613 authentik_client-2024.2.2.post1710845398/authentik_client/models/expression_policy.py
--rw-r--r--   0        0        0     2399 2024-03-19 10:50:04.485012 authentik_client-2024.2.2.post1710845398/authentik_client/models/expression_policy_request.py
--rw-r--r--   0        0        0     3766 2024-03-19 10:50:04.498160 authentik_client-2024.2.2.post1710845398/authentik_client/models/extra_role_object_permission.py
--rw-r--r--   0        0        0     3766 2024-03-19 10:50:04.504149 authentik_client-2024.2.2.post1710845398/authentik_client/models/extra_user_object_permission.py
--rw-r--r--   0        0        0     1887 2024-03-19 10:50:04.508743 authentik_client-2024.2.2.post1710845398/authentik_client/models/file_path_request.py
--rw-r--r--   0        0        0     5217 2024-03-19 10:50:04.512488 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow.py
--rw-r--r--   0        0        0    24360 2024-03-19 10:50:04.517847 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_challenge_response_request.py
--rw-r--r--   0        0        0      945 2024-03-19 10:50:04.521535 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_designation_enum.py
--rw-r--r--   0        0        0     1905 2024-03-19 10:50:04.528202 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_diagram.py
--rw-r--r--   0        0        0     3968 2024-03-19 10:50:04.533686 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_error_challenge.py
--rw-r--r--   0        0        0     2108 2024-03-19 10:50:04.538392 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_import_result.py
--rw-r--r--   0        0        0     2892 2024-03-19 10:50:04.546665 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_inspection.py
--rw-r--r--   0        0        0     3221 2024-03-19 10:50:04.557189 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_inspector_plan.py
--rw-r--r--   0        0        0      838 2024-03-19 10:50:04.564183 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_layout_enum.py
--rw-r--r--   0        0        0     4059 2024-03-19 10:50:04.574933 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_request.py
--rw-r--r--   0        0        0     4463 2024-03-19 10:50:04.587716 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_set.py
--rw-r--r--   0        0        0     3797 2024-03-19 10:50:04.599971 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_set_request.py
--rw-r--r--   0        0        0     4095 2024-03-19 10:50:04.610302 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_stage_binding.py
--rw-r--r--   0        0        0     3402 2024-03-19 10:50:04.622309 authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_stage_binding_request.py
--rw-r--r--   0        0        0     1988 2024-03-19 10:50:04.633077 authentik_client-2024.2.2.post1710845398/authentik_client/models/footer_link.py
--rw-r--r--   0        0        0     1958 2024-03-19 10:50:04.647043 authentik_client-2024.2.2.post1710845398/authentik_client/models/generic_error.py
--rw-r--r--   0        0        0      870 2024-03-19 10:50:04.654535 authentik_client-2024.2.2.post1710845398/authentik_client/models/geoip_binding_enum.py
--rw-r--r--   0        0        0     4486 2024-03-19 10:50:04.660108 authentik_client-2024.2.2.post1710845398/authentik_client/models/group.py
--rw-r--r--   0        0        0     3504 2024-03-19 10:50:04.663589 authentik_client-2024.2.2.post1710845398/authentik_client/models/group_member.py
--rw-r--r--   0        0        0     3356 2024-03-19 10:50:04.667800 authentik_client-2024.2.2.post1710845398/authentik_client/models/group_member_request.py
--rw-r--r--   0        0        0     2740 2024-03-19 10:50:04.671622 authentik_client-2024.2.2.post1710845398/authentik_client/models/group_request.py
--rw-r--r--   0        0        0     5420 2024-03-19 10:50:04.676344 authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_challenge.py
--rw-r--r--   0        0        0     2632 2024-03-19 10:50:04.680053 authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_challenge_response_request.py
--rw-r--r--   0        0        0     6754 2024-03-19 10:50:04.684162 authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_stage.py
--rw-r--r--   0        0        0     5902 2024-03-19 10:50:04.690442 authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_stage_request.py
--rw-r--r--   0        0        0     1822 2024-03-19 10:50:04.694897 authentik_client-2024.2.2.post1710845398/authentik_client/models/install_id.py
--rw-r--r--   0        0        0      764 2024-03-19 10:50:04.698160 authentik_client-2024.2.2.post1710845398/authentik_client/models/intent_enum.py
--rw-r--r--   0        0        0      823 2024-03-19 10:50:04.701116 authentik_client-2024.2.2.post1710845398/authentik_client/models/invalid_response_action_enum.py
--rw-r--r--   0        0        0     3955 2024-03-19 10:50:04.706422 authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation.py
--rw-r--r--   0        0        0     3055 2024-03-19 10:50:04.711252 authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation_request.py
--rw-r--r--   0        0        0     3817 2024-03-19 10:50:04.715225 authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation_stage.py
--rw-r--r--   0        0        0     2954 2024-03-19 10:50:04.718900 authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation_stage_request.py
--rw-r--r--   0        0        0      730 2024-03-19 10:50:04.722921 authentik_client-2024.2.2.post1710845398/authentik_client/models/issuer_mode_enum.py
--rw-r--r--   0        0        0     3714 2024-03-19 10:50:04.727169 authentik_client-2024.2.2.post1710845398/authentik_client/models/kubernetes_service_connection.py
--rw-r--r--   0        0        0     2892 2024-03-19 10:50:04.730797 authentik_client-2024.2.2.post1710845398/authentik_client/models/kubernetes_service_connection_request.py
--rw-r--r--   0        0        0     2171 2024-03-19 10:50:04.739530 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_debug.py
--rw-r--r--   0        0        0     5058 2024-03-19 10:50:04.743324 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_outpost_config.py
--rw-r--r--   0        0        0     3703 2024-03-19 10:50:04.746033 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_property_mapping.py
--rw-r--r--   0        0        0     2876 2024-03-19 10:50:04.751016 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_property_mapping_request.py
--rw-r--r--   0        0        0     7744 2024-03-19 10:50:04.755701 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_provider.py
--rw-r--r--   0        0        0     5519 2024-03-19 10:50:04.760769 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_provider_request.py
--rw-r--r--   0        0        0    10516 2024-03-19 10:50:04.764753 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_source.py
--rw-r--r--   0        0        0     8405 2024-03-19 10:50:04.768575 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_source_request.py
--rw-r--r--   0        0        0     2531 2024-03-19 10:50:04.774104 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_sync_status.py
--rw-r--r--   0        0        0      733 2024-03-19 10:50:04.734810 authentik_client-2024.2.2.post1710845398/authentik_client/models/ldapapi_access_mode.py
--rw-r--r--   0        0        0     2562 2024-03-19 10:50:04.777505 authentik_client-2024.2.2.post1710845398/authentik_client/models/license.py
--rw-r--r--   0        0        0     2358 2024-03-19 10:50:04.780345 authentik_client-2024.2.2.post1710845398/authentik_client/models/license_forecast.py
--rw-r--r--   0        0        0     1873 2024-03-19 10:50:04.785397 authentik_client-2024.2.2.post1710845398/authentik_client/models/license_request.py
--rw-r--r--   0        0        0     2730 2024-03-19 10:50:04.791283 authentik_client-2024.2.2.post1710845398/authentik_client/models/license_summary.py
--rw-r--r--   0        0        0     1789 2024-03-19 10:50:04.796319 authentik_client-2024.2.2.post1710845398/authentik_client/models/link.py
--rw-r--r--   0        0        0     6360 2024-03-19 10:50:04.801549 authentik_client-2024.2.2.post1710845398/authentik_client/models/login_challenge_types.py
--rw-r--r--   0        0        0     3558 2024-03-19 10:50:04.805369 authentik_client-2024.2.2.post1710845398/authentik_client/models/login_metrics.py
--rw-r--r--   0        0        0     2628 2024-03-19 10:50:04.813930 authentik_client-2024.2.2.post1710845398/authentik_client/models/login_source.py
--rw-r--r--   0        0        0     1948 2024-03-19 10:50:04.818691 authentik_client-2024.2.2.post1710845398/authentik_client/models/metadata.py
--rw-r--r--   0        0        0     7513 2024-03-19 10:50:04.821589 authentik_client-2024.2.2.post1710845398/authentik_client/models/model_enum.py
--rw-r--r--   0        0        0     9468 2024-03-19 10:50:04.826584 authentik_client-2024.2.2.post1710845398/authentik_client/models/model_request.py
--rw-r--r--   0        0        0     1564 2024-03-19 10:50:04.829935 authentik_client-2024.2.2.post1710845398/authentik_client/models/name_id_policy_enum.py
--rw-r--r--   0        0        0      840 2024-03-19 10:50:04.832471 authentik_client-2024.2.2.post1710845398/authentik_client/models/network_binding_enum.py
--rw-r--r--   0        0        0      783 2024-03-19 10:50:04.835979 authentik_client-2024.2.2.post1710845398/authentik_client/models/not_configured_action_enum.py
--rw-r--r--   0        0        0     2812 2024-03-19 10:50:04.839753 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification.py
--rw-r--r--   0        0        0     2297 2024-03-19 10:50:04.844158 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_request.py
--rw-r--r--   0        0        0     3398 2024-03-19 10:50:04.847395 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_rule.py
--rw-r--r--   0        0        0     2956 2024-03-19 10:50:04.850443 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_rule_request.py
--rw-r--r--   0        0        0     3154 2024-03-19 10:50:04.854721 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_transport.py
--rw-r--r--   0        0        0      849 2024-03-19 10:50:04.858900 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_transport_mode_enum.py
--rw-r--r--   0        0        0     2925 2024-03-19 10:50:04.862218 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_transport_request.py
--rw-r--r--   0        0        0     2000 2024-03-19 10:50:04.866775 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_transport_test.py
--rw-r--r--   0        0        0     2165 2024-03-19 10:50:04.869826 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_webhook_mapping.py
--rw-r--r--   0        0        0     2155 2024-03-19 10:50:04.873598 authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_webhook_mapping_request.py
--rw-r--r--   0        0        0     7939 2024-03-19 10:50:04.877679 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth2_provider.py
--rw-r--r--   0        0        0     5926 2024-03-19 10:50:04.881590 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth2_provider_request.py
--rw-r--r--   0        0        0     2776 2024-03-19 10:50:04.885382 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth2_provider_setup_urls.py
--rw-r--r--   0        0        0     3651 2024-03-19 10:50:04.889405 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_challenge.py
--rw-r--r--   0        0        0     2327 2024-03-19 10:50:04.892884 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_challenge_response_request.py
--rw-r--r--   0        0        0     3724 2024-03-19 10:50:04.897023 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_finish_challenge.py
--rw-r--r--   0        0        0     2301 2024-03-19 10:50:04.900507 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_finish_challenge_response_request.py
--rw-r--r--   0        0        0     9555 2024-03-19 10:50:04.904727 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_source.py
--rw-r--r--   0        0        0     7291 2024-03-19 10:50:04.910560 authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_source_request.py
--rw-r--r--   0        0        0     3562 2024-03-19 10:50:04.913820 authentik_client-2024.2.2.post1710845398/authentik_client/models/open_id_connect_configuration.py
--rw-r--r--   0        0        0     4908 2024-03-19 10:50:04.917784 authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost.py
--rw-r--r--   0        0        0     1977 2024-03-19 10:50:04.923215 authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_default_config.py
--rw-r--r--   0        0        0     2987 2024-03-19 10:50:04.927441 authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_health.py
--rw-r--r--   0        0        0     3460 2024-03-19 10:50:04.931314 authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_request.py
--rw-r--r--   0        0        0      755 2024-03-19 10:50:04.933834 authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_type_enum.py
--rw-r--r--   0        0        0     2822 2024-03-19 10:50:04.937960 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_application_list.py
--rw-r--r--   0        0        0     2993 2024-03-19 10:50:04.943181 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticate_web_authn_stage_list.py
--rw-r--r--   0        0        0     2931 2024-03-19 10:50:04.946868 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticated_session_list.py
--rw-r--r--   0        0        0     2944 2024-03-19 10:50:04.951166 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_duo_stage_list.py
--rw-r--r--   0        0        0     2944 2024-03-19 10:50:04.955034 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_sms_stage_list.py
--rw-r--r--   0        0        0     2980 2024-03-19 10:50:04.960140 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_static_stage_list.py
--rw-r--r--   0        0        0     2956 2024-03-19 10:50:04.964396 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_totp_stage_list.py
--rw-r--r--   0        0        0     3004 2024-03-19 10:50:04.968649 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_validate_stage_list.py
--rw-r--r--   0        0        0     2895 2024-03-19 10:50:04.972432 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_blueprint_instance_list.py
--rw-r--r--   0        0        0     2750 2024-03-19 10:50:04.976530 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_brand_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:04.979622 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_captcha_stage_list.py
--rw-r--r--   0        0        0     2908 2024-03-19 10:50:04.983114 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_certificate_key_pair_list.py
--rw-r--r--   0        0        0     2871 2024-03-19 10:50:04.986515 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_connection_token_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:04.991714 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_consent_stage_list.py
--rw-r--r--   0        0        0     2799 2024-03-19 10:50:04.995143 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_deny_stage_list.py
--rw-r--r--   0        0        0     2968 2024-03-19 10:50:04.998771 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_docker_service_connection_list.py
--rw-r--r--   0        0        0     2762 2024-03-19 10:50:05.003225 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_domain_list.py
--rw-r--r--   0        0        0     2823 2024-03-19 10:50:05.007000 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_dummy_policy_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.010481 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_dummy_stage_list.py
--rw-r--r--   0        0        0     2799 2024-03-19 10:50:05.016925 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_duo_device_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.019863 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_email_stage_list.py
--rw-r--r--   0        0        0     2786 2024-03-19 10:50:05.024422 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_endpoint_list.py
--rw-r--r--   0        0        0     2750 2024-03-19 10:50:05.028235 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_event_list.py
--rw-r--r--   0        0        0     2908 2024-03-19 10:50:05.031391 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_event_matcher_policy_list.py
--rw-r--r--   0        0        0     2957 2024-03-19 10:50:05.034445 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_expiring_base_grant_model_list.py
--rw-r--r--   0        0        0     2883 2024-03-19 10:50:05.037686 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_expression_policy_list.py
--rw-r--r--   0        0        0     2993 2024-03-19 10:50:05.044134 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_extra_role_object_permission_list.py
--rw-r--r--   0        0        0     2993 2024-03-19 10:50:05.048678 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_extra_user_object_permission_list.py
--rw-r--r--   0        0        0     2738 2024-03-19 10:50:05.052407 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_flow_list.py
--rw-r--r--   0        0        0     2884 2024-03-19 10:50:05.056644 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_flow_stage_binding_list.py
--rw-r--r--   0        0        0     2750 2024-03-19 10:50:05.060588 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_group_list.py
--rw-r--r--   0        0        0     2919 2024-03-19 10:50:05.064525 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_identification_stage_list.py
--rw-r--r--   0        0        0     2810 2024-03-19 10:50:05.069023 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_invitation_list.py
--rw-r--r--   0        0        0     2871 2024-03-19 10:50:05.072542 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_invitation_stage_list.py
--rw-r--r--   0        0        0     3016 2024-03-19 10:50:05.076687 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_kubernetes_service_connection_list.py
--rw-r--r--   0        0        0     2896 2024-03-19 10:50:05.079590 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_outpost_config_list.py
--rw-r--r--   0        0        0     2920 2024-03-19 10:50:05.082494 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_property_mapping_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:05.085542 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_provider_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.090255 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_source_list.py
--rw-r--r--   0        0        0     2774 2024-03-19 10:50:05.093880 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_license_list.py
--rw-r--r--   0        0        0     2834 2024-03-19 10:50:05.099078 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_list.py
--rw-r--r--   0        0        0     2883 2024-03-19 10:50:05.103595 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_rule_list.py
--rw-r--r--   0        0        0     2943 2024-03-19 10:50:05.108134 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_transport_list.py
--rw-r--r--   0        0        0     3004 2024-03-19 10:50:05.112086 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_webhook_mapping_list.py
--rw-r--r--   0        0        0     2860 2024-03-19 10:50:05.115346 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_o_auth2_provider_list.py
--rw-r--r--   0        0        0     2824 2024-03-19 10:50:05.119084 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_o_auth_source_list.py
--rw-r--r--   0        0        0     2774 2024-03-19 10:50:05.124431 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_outpost_list.py
--rw-r--r--   0        0        0     2932 2024-03-19 10:50:05.128512 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_password_expiry_policy_list.py
--rw-r--r--   0        0        0     2859 2024-03-19 10:50:05.133300 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_password_policy_list.py
--rw-r--r--   0        0        0     2847 2024-03-19 10:50:05.137666 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_password_stage_list.py
--rw-r--r--   0        0        0     2810 2024-03-19 10:50:05.143717 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_permission_list.py
--rw-r--r--   0        0        0     2932 2024-03-19 10:50:05.147067 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_plex_source_connection_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.150441 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_plex_source_list.py
--rw-r--r--   0        0        0     2847 2024-03-19 10:50:05.153450 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_policy_binding_list.py
--rw-r--r--   0        0        0     2762 2024-03-19 10:50:05.157001 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_policy_list.py
--rw-r--r--   0        0        0     2762 2024-03-19 10:50:05.160396 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_prompt_list.py
--rw-r--r--   0        0        0     2823 2024-03-19 10:50:05.163608 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_prompt_stage_list.py
--rw-r--r--   0        0        0     2871 2024-03-19 10:50:05.166355 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_property_mapping_list.py
--rw-r--r--   0        0        0     2786 2024-03-19 10:50:05.169614 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_provider_list.py
--rw-r--r--   0        0        0     2908 2024-03-19 10:50:05.173376 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_proxy_outpost_config_list.py
--rw-r--r--   0        0        0     2847 2024-03-19 10:50:05.177321 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_proxy_provider_list.py
--rw-r--r--   0        0        0     2908 2024-03-19 10:50:05.180952 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_rac_property_mapping_list.py
--rw-r--r--   0        0        0     2823 2024-03-19 10:50:05.185160 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_rac_provider_list.py
--rw-r--r--   0        0        0     2920 2024-03-19 10:50:05.189212 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_radius_outpost_config_list.py
--rw-r--r--   0        0        0     2859 2024-03-19 10:50:05.193700 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_radius_provider_list.py
--rw-r--r--   0        0        0     2810 2024-03-19 10:50:05.198030 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_reputation_list.py
--rw-r--r--   0        0        0     2883 2024-03-19 10:50:05.201586 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_reputation_policy_list.py
--rw-r--r--   0        0        0     3029 2024-03-19 10:50:05.205737 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_role_assigned_object_permission_list.py
--rw-r--r--   0        0        0     2738 2024-03-19 10:50:05.209369 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_role_list.py
--rw-r--r--   0        0        0     2920 2024-03-19 10:50:05.212687 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_saml_property_mapping_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:05.215911 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_saml_provider_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.219883 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_saml_source_list.py
--rw-r--r--   0        0        0     2823 2024-03-19 10:50:05.225367 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_scim_mapping_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:05.228863 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_scim_provider_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:05.237012 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_scope_mapping_list.py
--rw-r--r--   0        0        0     2895 2024-03-19 10:50:05.241731 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_service_connection_list.py
--rw-r--r--   0        0        0     2799 2024-03-19 10:50:05.233476 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_sms_device_list.py
--rw-r--r--   0        0        0     2762 2024-03-19 10:50:05.247093 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_source_list.py
--rw-r--r--   0        0        0     2823 2024-03-19 10:50:05.251938 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_source_stage_list.py
--rw-r--r--   0        0        0     2750 2024-03-19 10:50:05.257979 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_stage_list.py
--rw-r--r--   0        0        0     2835 2024-03-19 10:50:05.262936 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_static_device_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.266691 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_system_task_list.py
--rw-r--r--   0        0        0     2762 2024-03-19 10:50:05.273949 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_tenant_list.py
--rw-r--r--   0        0        0     2750 2024-03-19 10:50:05.277223 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_token_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.280655 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_token_model_list.py
--rw-r--r--   0        0        0     2811 2024-03-19 10:50:05.270070 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_totp_device_list.py
--rw-r--r--   0        0        0     3029 2024-03-19 10:50:05.284304 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_assigned_object_permission_list.py
--rw-r--r--   0        0        0     2823 2024-03-19 10:50:05.287815 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_consent_list.py
--rw-r--r--   0        0        0     2872 2024-03-19 10:50:05.291764 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_delete_stage_list.py
--rw-r--r--   0        0        0     2738 2024-03-19 10:50:05.294839 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_list.py
--rw-r--r--   0        0        0     2860 2024-03-19 10:50:05.299157 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_login_stage_list.py
--rw-r--r--   0        0        0     2872 2024-03-19 10:50:05.305511 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_logout_stage_list.py
--rw-r--r--   0        0        0     2994 2024-03-19 10:50:05.314607 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_o_auth_source_connection_list.py
--rw-r--r--   0        0        0     2981 2024-03-19 10:50:05.319235 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_saml_source_connection_list.py
--rw-r--r--   0        0        0     2932 2024-03-19 10:50:05.322836 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_source_connection_list.py
--rw-r--r--   0        0        0     2860 2024-03-19 10:50:05.326669 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_write_stage_list.py
--rw-r--r--   0        0        0     2860 2024-03-19 10:50:05.329950 authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_web_authn_device_list.py
--rw-r--r--   0        0        0     2559 2024-03-19 10:50:05.333030 authentik_client-2024.2.2.post1710845398/authentik_client/models/pagination.py
--rw-r--r--   0        0        0     3939 2024-03-19 10:50:05.336329 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_challenge.py
--rw-r--r--   0        0        0     2257 2024-03-19 10:50:05.340448 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_challenge_response_request.py
--rw-r--r--   0        0        0     3621 2024-03-19 10:50:05.343740 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_expiry_policy.py
--rw-r--r--   0        0        0     2530 2024-03-19 10:50:05.351172 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_expiry_policy_request.py
--rw-r--r--   0        0        0     5521 2024-03-19 10:50:05.355513 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_policy.py
--rw-r--r--   0        0        0     4489 2024-03-19 10:50:05.359286 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_policy_request.py
--rw-r--r--   0        0        0     4524 2024-03-19 10:50:05.364002 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_stage.py
--rw-r--r--   0        0        0     3672 2024-03-19 10:50:05.368521 authentik_client-2024.2.2.post1710845398/authentik_client/models/password_stage_request.py
--rw-r--r--   0        0        0     3969 2024-03-19 10:50:05.372348 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_application_request.py
--rw-r--r--   0        0        0     4623 2024-03-19 10:50:05.377750 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticate_web_authn_stage_request.py
--rw-r--r--   0        0        0     4231 2024-03-19 10:50:05.382016 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_duo_stage_request.py
--rw-r--r--   0        0        0     5079 2024-03-19 10:50:05.389183 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_sms_stage_request.py
--rw-r--r--   0        0        0     3863 2024-03-19 10:50:05.393908 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_static_stage_request.py
--rw-r--r--   0        0        0     3703 2024-03-19 10:50:05.397504 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_totp_stage_request.py
--rw-r--r--   0        0        0     4196 2024-03-19 10:50:05.401740 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_validate_stage_request.py
--rw-r--r--   0        0        0     2676 2024-03-19 10:50:05.406399 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_blueprint_instance_request.py
--rw-r--r--   0        0        0     5652 2024-03-19 10:50:05.412084 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_brand_request.py
--rw-r--r--   0        0        0     3222 2024-03-19 10:50:05.416019 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_captcha_stage_request.py
--rw-r--r--   0        0        0     2460 2024-03-19 10:50:05.419381 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_certificate_key_pair_request.py
--rw-r--r--   0        0        0     2192 2024-03-19 10:50:05.424144 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_connection_token_request.py
--rw-r--r--   0        0        0     3022 2024-03-19 10:50:05.427437 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_consent_stage_request.py
--rw-r--r--   0        0        0     2687 2024-03-19 10:50:05.430506 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_deny_stage_request.py
--rw-r--r--   0        0        0     3554 2024-03-19 10:50:05.433547 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_docker_service_connection_request.py
--rw-r--r--   0        0        0     2186 2024-03-19 10:50:05.436632 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_domain_request.py
--rw-r--r--   0        0        0     2657 2024-03-19 10:50:05.441875 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_dummy_policy_request.py
--rw-r--r--   0        0        0     2693 2024-03-19 10:50:05.445209 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_dummy_stage_request.py
--rw-r--r--   0        0        0     2070 2024-03-19 10:50:05.450270 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_duo_device_request.py
--rw-r--r--   0        0        0     4468 2024-03-19 10:50:05.454748 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_email_stage_request.py
--rw-r--r--   0        0        0     3174 2024-03-19 10:50:05.459507 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_endpoint_request.py
--rw-r--r--   0        0        0     4214 2024-03-19 10:50:05.462751 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_event_matcher_policy_request.py
--rw-r--r--   0        0        0     3399 2024-03-19 10:50:05.465100 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_event_request.py
--rw-r--r--   0        0        0     2456 2024-03-19 10:50:05.468443 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_expression_policy_request.py
--rw-r--r--   0        0        0     4197 2024-03-19 10:50:05.473678 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_flow_request.py
--rw-r--r--   0        0        0     3463 2024-03-19 10:50:05.476950 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_flow_stage_binding_request.py
--rw-r--r--   0        0        0     2793 2024-03-19 10:50:05.480239 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_group_request.py
--rw-r--r--   0        0        0     5955 2024-03-19 10:50:05.486649 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_identification_stage_request.py
--rw-r--r--   0        0        0     3160 2024-03-19 10:50:05.495862 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_invitation_request.py
--rw-r--r--   0        0        0     3007 2024-03-19 10:50:05.500054 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_invitation_stage_request.py
--rw-r--r--   0        0        0     2945 2024-03-19 10:50:05.509614 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_kubernetes_service_connection_request.py
--rw-r--r--   0        0        0     2937 2024-03-19 10:50:05.512420 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_ldap_property_mapping_request.py
--rw-r--r--   0        0        0     5583 2024-03-19 10:50:05.517902 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_ldap_provider_request.py
--rw-r--r--   0        0        0     8536 2024-03-19 10:50:05.524304 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_ldap_source_request.py
--rw-r--r--   0        0        0     1946 2024-03-19 10:50:05.528219 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_license_request.py
--rw-r--r--   0        0        0     2346 2024-03-19 10:50:05.532672 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_notification_request.py
--rw-r--r--   0        0        0     3009 2024-03-19 10:50:05.536953 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_notification_rule_request.py
--rw-r--r--   0        0        0     2978 2024-03-19 10:50:05.543563 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_notification_transport_request.py
--rw-r--r--   0        0        0     2232 2024-03-19 10:50:05.547221 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_notification_webhook_mapping_request.py
--rw-r--r--   0        0        0     5990 2024-03-19 10:50:05.551210 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_o_auth2_provider_request.py
--rw-r--r--   0        0        0     7426 2024-03-19 10:50:05.555926 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_o_auth_source_request.py
--rw-r--r--   0        0        0     3525 2024-03-19 10:50:05.561452 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_outpost_request.py
--rw-r--r--   0        0        0     2587 2024-03-19 10:50:05.564803 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_password_expiry_policy_request.py
--rw-r--r--   0        0        0     4542 2024-03-19 10:50:05.568296 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_password_policy_request.py
--rw-r--r--   0        0        0     3736 2024-03-19 10:50:05.575314 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_password_stage_request.py
--rw-r--r--   0        0        0     2350 2024-03-19 10:50:05.579797 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_permission_assign_request.py
--rw-r--r--   0        0        0     2210 2024-03-19 10:50:05.586369 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_plex_source_connection_request.py
--rw-r--r--   0        0        0     5164 2024-03-19 10:50:05.593128 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_plex_source_request.py
--rw-r--r--   0        0        0     3655 2024-03-19 10:50:05.597370 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_policy_binding_request.py
--rw-r--r--   0        0        0     4376 2024-03-19 10:50:05.601228 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_prompt_request.py
--rw-r--r--   0        0        0     2839 2024-03-19 10:50:05.606065 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_prompt_stage_request.py
--rw-r--r--   0        0        0     6207 2024-03-19 10:50:05.611903 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_proxy_provider_request.py
--rw-r--r--   0        0        0     2919 2024-03-19 10:50:05.615692 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_rac_property_mapping_request.py
--rw-r--r--   0        0        0     3793 2024-03-19 10:50:05.619049 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_rac_provider_request.py
--rw-r--r--   0        0        0     3931 2024-03-19 10:50:05.624529 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_radius_provider_request.py
--rw-r--r--   0        0        0     2693 2024-03-19 10:50:05.628385 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_reputation_policy_request.py
--rw-r--r--   0        0        0     1942 2024-03-19 10:50:05.633970 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_role_request.py
--rw-r--r--   0        0        0     3284 2024-03-19 10:50:05.637952 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_saml_property_mapping_request.py
--rw-r--r--   0        0        0     6786 2024-03-19 10:50:05.643061 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_saml_provider_request.py
--rw-r--r--   0        0        0     7865 2024-03-19 10:50:05.647701 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_saml_source_request.py
--rw-r--r--   0        0        0     2734 2024-03-19 10:50:05.653680 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_scim_mapping_request.py
--rw-r--r--   0        0        0     3267 2024-03-19 10:50:05.658326 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_scim_provider_request.py
--rw-r--r--   0        0        0     3162 2024-03-19 10:50:05.666093 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_scope_mapping_request.py
--rw-r--r--   0        0        0     3912 2024-03-19 10:50:05.669013 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_settings_request.py
--rw-r--r--   0        0        0     2070 2024-03-19 10:50:05.662610 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_sms_device_request.py
--rw-r--r--   0        0        0     2973 2024-03-19 10:50:05.674147 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_source_stage_request.py
--rw-r--r--   0        0        0     2094 2024-03-19 10:50:05.680685 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_static_device_request.py
--rw-r--r--   0        0        0     2190 2024-03-19 10:50:05.694372 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_tenant_request.py
--rw-r--r--   0        0        0     3556 2024-03-19 10:50:05.700110 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_token_request.py
--rw-r--r--   0        0        0     2078 2024-03-19 10:50:05.686228 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_totp_device_request.py
--rw-r--r--   0        0        0     2610 2024-03-19 10:50:05.704974 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_delete_stage_request.py
--rw-r--r--   0        0        0     4142 2024-03-19 10:50:05.713846 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_login_stage_request.py
--rw-r--r--   0        0        0     2610 2024-03-19 10:50:05.718523 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_logout_stage_request.py
--rw-r--r--   0        0        0     2566 2024-03-19 10:50:05.726150 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_o_auth_source_connection_request.py
--rw-r--r--   0        0        0     3296 2024-03-19 10:50:05.730426 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_request.py
--rw-r--r--   0        0        0     2190 2024-03-19 10:50:05.734313 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_saml_source_connection_request.py
--rw-r--r--   0        0        0     3876 2024-03-19 10:50:05.737335 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_write_stage_request.py
--rw-r--r--   0        0        0     2042 2024-03-19 10:50:05.742220 authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_web_authn_device_request.py
--rw-r--r--   0        0        0     2773 2024-03-19 10:50:05.745629 authentik_client-2024.2.2.post1710845398/authentik_client/models/permission.py
--rw-r--r--   0        0        0     2304 2024-03-19 10:50:05.748482 authentik_client-2024.2.2.post1710845398/authentik_client/models/permission_assign_request.py
--rw-r--r--   0        0        0     3840 2024-03-19 10:50:05.751416 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_authentication_challenge.py
--rw-r--r--   0        0        0     2199 2024-03-19 10:50:05.756035 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_authentication_challenge_response_request.py
--rw-r--r--   0        0        0     6866 2024-03-19 10:50:05.760157 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_source.py
--rw-r--r--   0        0        0     2661 2024-03-19 10:50:05.763944 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_source_connection.py
--rw-r--r--   0        0        0     2133 2024-03-19 10:50:05.767803 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_source_connection_request.py
--rw-r--r--   0        0        0     5030 2024-03-19 10:50:05.771621 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_source_request.py
--rw-r--r--   0        0        0     1972 2024-03-19 10:50:05.777142 authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_token_redeem_request.py
--rw-r--r--   0        0        0     3277 2024-03-19 10:50:05.780483 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy.py
--rw-r--r--   0        0        0     4910 2024-03-19 10:50:05.784125 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_binding.py
--rw-r--r--   0        0        0     3598 2024-03-19 10:50:05.790109 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_binding_request.py
--rw-r--r--   0        0        0      716 2024-03-19 10:50:05.793634 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_engine_mode.py
--rw-r--r--   0        0        0     2186 2024-03-19 10:50:05.799010 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_request.py
--rw-r--r--   0        0        0     2041 2024-03-19 10:50:05.802621 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_test_request.py
--rw-r--r--   0        0        0     2254 2024-03-19 10:50:05.806920 authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_test_result.py
--rw-r--r--   0        0        0     4250 2024-03-19 10:50:05.812637 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt.py
--rw-r--r--   0        0        0     4120 2024-03-19 10:50:05.818136 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_challenge.py
--rw-r--r--   0        0        0     2686 2024-03-19 10:50:05.823084 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_challenge_response_request.py
--rw-r--r--   0        0        0     4304 2024-03-19 10:50:05.828298 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_request.py
--rw-r--r--   0        0        0     3641 2024-03-19 10:50:05.833316 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_stage.py
--rw-r--r--   0        0        0     2789 2024-03-19 10:50:05.837590 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_stage_request.py
--rw-r--r--   0        0        0     1186 2024-03-19 10:50:05.841675 authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_type_enum.py
--rw-r--r--   0        0        0     3560 2024-03-19 10:50:05.844295 authentik_client-2024.2.2.post1710845398/authentik_client/models/property_mapping.py
--rw-r--r--   0        0        0     2054 2024-03-19 10:50:05.847526 authentik_client-2024.2.2.post1710845398/authentik_client/models/property_mapping_preview.py
--rw-r--r--   0        0        0     2151 2024-03-19 10:50:05.851339 authentik_client-2024.2.2.post1710845398/authentik_client/models/property_mapping_test_result.py
--rw-r--r--   0        0        0      712 2024-03-19 10:50:05.856083 authentik_client-2024.2.2.post1710845398/authentik_client/models/protocol_enum.py
--rw-r--r--   0        0        0     4884 2024-03-19 10:50:05.862114 authentik_client-2024.2.2.post1710845398/authentik_client/models/provider.py
--rw-r--r--   0        0        0      710 2024-03-19 10:50:05.865576 authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_enum.py
--rw-r--r--   0        0        0     1321 2024-03-19 10:50:05.868470 authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_model_enum.py
--rw-r--r--   0        0        0     2793 2024-03-19 10:50:05.872614 authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_request.py
--rw-r--r--   0        0        0     1014 2024-03-19 10:50:05.875645 authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_type_enum.py
--rw-r--r--   0        0        0      745 2024-03-19 10:50:05.877899 authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_mode.py
--rw-r--r--   0        0        0     7014 2024-03-19 10:50:05.881428 authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_outpost_config.py
--rw-r--r--   0        0        0     8614 2024-03-19 10:50:05.884652 authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_provider.py
--rw-r--r--   0        0        0     6139 2024-03-19 10:50:05.888006 authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_provider_request.py
--rw-r--r--   0        0        0     3726 2024-03-19 10:50:05.893453 authentik_client-2024.2.2.post1710845398/authentik_client/models/rac_property_mapping.py
--rw-r--r--   0        0        0     2862 2024-03-19 10:50:05.896937 authentik_client-2024.2.2.post1710845398/authentik_client/models/rac_property_mapping_request.py
--rw-r--r--   0        0        0     5954 2024-03-19 10:50:05.900818 authentik_client-2024.2.2.post1710845398/authentik_client/models/rac_provider.py
--rw-r--r--   0        0        0     3729 2024-03-19 10:50:05.904291 authentik_client-2024.2.2.post1710845398/authentik_client/models/rac_provider_request.py
--rw-r--r--   0        0        0     3262 2024-03-19 10:50:05.908286 authentik_client-2024.2.2.post1710845398/authentik_client/models/radius_outpost_config.py
--rw-r--r--   0        0        0     6068 2024-03-19 10:50:05.911603 authentik_client-2024.2.2.post1710845398/authentik_client/models/radius_provider.py
--rw-r--r--   0        0        0     3867 2024-03-19 10:50:05.916668 authentik_client-2024.2.2.post1710845398/authentik_client/models/radius_provider_request.py
--rw-r--r--   0        0        0     3656 2024-03-19 10:50:05.920064 authentik_client-2024.2.2.post1710845398/authentik_client/models/redirect_challenge.py
--rw-r--r--   0        0        0     2995 2024-03-19 10:50:05.925412 authentik_client-2024.2.2.post1710845398/authentik_client/models/reputation.py
--rw-r--r--   0        0        0     3731 2024-03-19 10:50:05.928770 authentik_client-2024.2.2.post1710845398/authentik_client/models/reputation_policy.py
--rw-r--r--   0        0        0     2640 2024-03-19 10:50:05.933387 authentik_client-2024.2.2.post1710845398/authentik_client/models/reputation_policy_request.py
--rw-r--r--   0        0        0      820 2024-03-19 10:50:05.936659 authentik_client-2024.2.2.post1710845398/authentik_client/models/resident_key_requirement_enum.py
--rw-r--r--   0        0        0     1921 2024-03-19 10:50:05.939770 authentik_client-2024.2.2.post1710845398/authentik_client/models/role.py
--rw-r--r--   0        0        0     2804 2024-03-19 10:50:05.944882 authentik_client-2024.2.2.post1710845398/authentik_client/models/role_assigned_object_permission.py
--rw-r--r--   0        0        0     2596 2024-03-19 10:50:05.948545 authentik_client-2024.2.2.post1710845398/authentik_client/models/role_object_permission.py
--rw-r--r--   0        0        0     1869 2024-03-19 10:50:05.951488 authentik_client-2024.2.2.post1710845398/authentik_client/models/role_request.py
--rw-r--r--   0        0        0     2067 2024-03-19 10:50:05.955478 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_metadata.py
--rw-r--r--   0        0        0     4039 2024-03-19 10:50:05.960374 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_property_mapping.py
--rw-r--r--   0        0        0     3223 2024-03-19 10:50:05.966720 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_property_mapping_request.py
--rw-r--r--   0        0        0     9934 2024-03-19 10:50:05.970860 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_provider.py
--rw-r--r--   0        0        0     6718 2024-03-19 10:50:05.980585 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_provider_request.py
--rw-r--r--   0        0        0     9590 2024-03-19 10:50:05.985706 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_source.py
--rw-r--r--   0        0        0     7720 2024-03-19 10:50:05.992200 authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_source_request.py
--rw-r--r--   0        0        0     3528 2024-03-19 10:50:05.995959 authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_mapping.py
--rw-r--r--   0        0        0     2677 2024-03-19 10:50:05.999154 authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_mapping_request.py
--rw-r--r--   0        0        0     4698 2024-03-19 10:50:06.004638 authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_provider.py
--rw-r--r--   0        0        0     3192 2024-03-19 10:50:06.008749 authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_provider_request.py
--rw-r--r--   0        0        0     2533 2024-03-19 10:50:06.012192 authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_sync_status.py
--rw-r--r--   0        0        0     3910 2024-03-19 10:50:06.027287 authentik_client-2024.2.2.post1710845398/authentik_client/models/scope_mapping.py
--rw-r--r--   0        0        0     3094 2024-03-19 10:50:06.031932 authentik_client-2024.2.2.post1710845398/authentik_client/models/scope_mapping_request.py
--rw-r--r--   0        0        0     2199 2024-03-19 10:50:06.037986 authentik_client-2024.2.2.post1710845398/authentik_client/models/selectable_stage.py
--rw-r--r--   0        0        0     3068 2024-03-19 10:50:06.042753 authentik_client-2024.2.2.post1710845398/authentik_client/models/service_connection.py
--rw-r--r--   0        0        0     2189 2024-03-19 10:50:06.049638 authentik_client-2024.2.2.post1710845398/authentik_client/models/service_connection_request.py
--rw-r--r--   0        0        0     2126 2024-03-19 10:50:06.052940 authentik_client-2024.2.2.post1710845398/authentik_client/models/service_connection_state.py
--rw-r--r--   0        0        0     2609 2024-03-19 10:50:06.060017 authentik_client-2024.2.2.post1710845398/authentik_client/models/session_user.py
--rw-r--r--   0        0        0     3769 2024-03-19 10:50:06.063572 authentik_client-2024.2.2.post1710845398/authentik_client/models/settings.py
--rw-r--r--   0        0        0     3863 2024-03-19 10:50:06.070025 authentik_client-2024.2.2.post1710845398/authentik_client/models/settings_request.py
--rw-r--r--   0        0        0      730 2024-03-19 10:50:06.073106 authentik_client-2024.2.2.post1710845398/authentik_client/models/severity_enum.py
--rw-r--r--   0        0        0     3635 2024-03-19 10:50:06.077259 authentik_client-2024.2.2.post1710845398/authentik_client/models/shell_challenge.py
--rw-r--r--   0        0        0     1509 2024-03-19 10:50:06.082257 authentik_client-2024.2.2.post1710845398/authentik_client/models/signature_algorithm_enum.py
--rw-r--r--   0        0        0     2200 2024-03-19 10:50:06.017262 authentik_client-2024.2.2.post1710845398/authentik_client/models/sms_device.py
--rw-r--r--   0        0        0     1983 2024-03-19 10:50:06.022594 authentik_client-2024.2.2.post1710845398/authentik_client/models/sms_device_request.py
--rw-r--r--   0        0        0     6044 2024-03-19 10:50:06.085740 authentik_client-2024.2.2.post1710845398/authentik_client/models/source.py
--rw-r--r--   0        0        0     4136 2024-03-19 10:50:06.091193 authentik_client-2024.2.2.post1710845398/authentik_client/models/source_request.py
--rw-r--r--   0        0        0     3744 2024-03-19 10:50:06.094714 authentik_client-2024.2.2.post1710845398/authentik_client/models/source_stage.py
--rw-r--r--   0        0        0     2916 2024-03-19 10:50:06.097867 authentik_client-2024.2.2.post1710845398/authentik_client/models/source_stage_request.py
--rw-r--r--   0        0        0     4650 2024-03-19 10:50:06.103953 authentik_client-2024.2.2.post1710845398/authentik_client/models/source_type.py
--rw-r--r--   0        0        0      713 2024-03-19 10:50:06.108259 authentik_client-2024.2.2.post1710845398/authentik_client/models/sp_binding_enum.py
--rw-r--r--   0        0        0     3347 2024-03-19 10:50:06.113185 authentik_client-2024.2.2.post1710845398/authentik_client/models/stage.py
--rw-r--r--   0        0        0     2978 2024-03-19 10:50:06.117498 authentik_client-2024.2.2.post1710845398/authentik_client/models/stage_prompt.py
--rw-r--r--   0        0        0     2484 2024-03-19 10:50:06.123027 authentik_client-2024.2.2.post1710845398/authentik_client/models/stage_request.py
--rw-r--r--   0        0        0     2730 2024-03-19 10:50:06.127544 authentik_client-2024.2.2.post1710845398/authentik_client/models/static_device.py
--rw-r--r--   0        0        0     2007 2024-03-19 10:50:06.130422 authentik_client-2024.2.2.post1710845398/authentik_client/models/static_device_request.py
--rw-r--r--   0        0        0     1922 2024-03-19 10:50:06.134073 authentik_client-2024.2.2.post1710845398/authentik_client/models/static_device_token.py
--rw-r--r--   0        0        0     1985 2024-03-19 10:50:06.139214 authentik_client-2024.2.2.post1710845398/authentik_client/models/static_device_token_request.py
--rw-r--r--   0        0        0      841 2024-03-19 10:50:06.145815 authentik_client-2024.2.2.post1710845398/authentik_client/models/sub_mode_enum.py
--rw-r--r--   0        0        0     3681 2024-03-19 10:50:06.153174 authentik_client-2024.2.2.post1710845398/authentik_client/models/system_info.py
--rw-r--r--   0        0        0     2429 2024-03-19 10:50:06.159343 authentik_client-2024.2.2.post1710845398/authentik_client/models/system_info_runtime.py
--rw-r--r--   0        0        0     3196 2024-03-19 10:50:06.162544 authentik_client-2024.2.2.post1710845398/authentik_client/models/system_task.py
--rw-r--r--   0        0        0      802 2024-03-19 10:50:06.166408 authentik_client-2024.2.2.post1710845398/authentik_client/models/system_task_status_enum.py
--rw-r--r--   0        0        0     2213 2024-03-19 10:50:06.180647 authentik_client-2024.2.2.post1710845398/authentik_client/models/tenant.py
--rw-r--r--   0        0        0     2017 2024-03-19 10:50:06.184723 authentik_client-2024.2.2.post1710845398/authentik_client/models/tenant_admin_group_request_request.py
--rw-r--r--   0        0        0     2150 2024-03-19 10:50:06.190472 authentik_client-2024.2.2.post1710845398/authentik_client/models/tenant_recovery_key_request_request.py
--rw-r--r--   0        0        0     2073 2024-03-19 10:50:06.194658 authentik_client-2024.2.2.post1710845398/authentik_client/models/tenant_recovery_key_response.py
--rw-r--r--   0        0        0     2140 2024-03-19 10:50:06.202838 authentik_client-2024.2.2.post1710845398/authentik_client/models/tenant_request.py
--rw-r--r--   0        0        0     3873 2024-03-19 10:50:06.208174 authentik_client-2024.2.2.post1710845398/authentik_client/models/token.py
--rw-r--r--   0        0        0     3371 2024-03-19 10:50:06.215811 authentik_client-2024.2.2.post1710845398/authentik_client/models/token_model.py
--rw-r--r--   0        0        0     3451 2024-03-19 10:50:06.219884 authentik_client-2024.2.2.post1710845398/authentik_client/models/token_request.py
--rw-r--r--   0        0        0     1887 2024-03-19 10:50:06.224519 authentik_client-2024.2.2.post1710845398/authentik_client/models/token_set_key_request.py
--rw-r--r--   0        0        0     1858 2024-03-19 10:50:06.228112 authentik_client-2024.2.2.post1710845398/authentik_client/models/token_view.py
--rw-r--r--   0        0        0     2043 2024-03-19 10:50:06.170938 authentik_client-2024.2.2.post1710845398/authentik_client/models/totp_device.py
--rw-r--r--   0        0        0     1991 2024-03-19 10:50:06.175647 authentik_client-2024.2.2.post1710845398/authentik_client/models/totp_device_request.py
--rw-r--r--   0        0        0     2901 2024-03-19 10:50:06.231677 authentik_client-2024.2.2.post1710845398/authentik_client/models/transaction_application_request.py
--rw-r--r--   0        0        0     2125 2024-03-19 10:50:06.235316 authentik_client-2024.2.2.post1710845398/authentik_client/models/transaction_application_response.py
--rw-r--r--   0        0        0     2394 2024-03-19 10:50:06.238754 authentik_client-2024.2.2.post1710845398/authentik_client/models/type_create.py
--rw-r--r--   0        0        0      725 2024-03-19 10:50:06.242525 authentik_client-2024.2.2.post1710845398/authentik_client/models/ui_theme_enum.py
--rw-r--r--   0        0        0     2246 2024-03-19 10:50:06.245286 authentik_client-2024.2.2.post1710845398/authentik_client/models/used_by.py
--rw-r--r--   0        0        0      800 2024-03-19 10:50:06.248983 authentik_client-2024.2.2.post1710845398/authentik_client/models/used_by_action_enum.py
--rw-r--r--   0        0        0     4446 2024-03-19 10:50:06.252435 authentik_client-2024.2.2.post1710845398/authentik_client/models/user.py
--rw-r--r--   0        0        0     1892 2024-03-19 10:50:06.258584 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_account_request.py
--rw-r--r--   0        0        0     4357 2024-03-19 10:50:06.262313 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_assigned_object_permission.py
--rw-r--r--   0        0        0     3039 2024-03-19 10:50:06.265502 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_consent.py
--rw-r--r--   0        0        0      824 2024-03-19 10:50:06.267857 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_creation_mode_enum.py
--rw-r--r--   0        0        0     3427 2024-03-19 10:50:06.270906 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_delete_stage.py
--rw-r--r--   0        0        0     2564 2024-03-19 10:50:06.274935 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_delete_stage_request.py
--rw-r--r--   0        0        0      736 2024-03-19 10:50:06.277666 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_fields_enum.py
--rw-r--r--   0        0        0     2961 2024-03-19 10:50:06.280958 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_group.py
--rw-r--r--   0        0        0     2581 2024-03-19 10:50:06.285316 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_group_request.py
--rw-r--r--   0        0        0     3823 2024-03-19 10:50:06.288767 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_challenge.py
--rw-r--r--   0        0        0     2262 2024-03-19 10:50:06.292443 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_challenge_response_request.py
--rw-r--r--   0        0        0     4904 2024-03-19 10:50:06.295899 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_stage.py
--rw-r--r--   0        0        0     4089 2024-03-19 10:50:06.299948 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_stage_request.py
--rw-r--r--   0        0        0     3427 2024-03-19 10:50:06.303982 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_logout_stage.py
--rw-r--r--   0        0        0     2564 2024-03-19 10:50:06.310101 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_logout_stage_request.py
--rw-r--r--   0        0        0      866 2024-03-19 10:50:06.314338 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_matching_mode_enum.py
--rw-r--r--   0        0        0     3543 2024-03-19 10:50:06.318754 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_metrics.py
--rw-r--r--   0        0        0     2571 2024-03-19 10:50:06.322302 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_o_auth_source_connection.py
--rw-r--r--   0        0        0     2516 2024-03-19 10:50:06.326739 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_o_auth_source_connection_request.py
--rw-r--r--   0        0        0     2596 2024-03-19 10:50:06.329683 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_object_permission.py
--rw-r--r--   0        0        0     1939 2024-03-19 10:50:06.332275 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_password_set_request.py
--rw-r--r--   0        0        0     1872 2024-03-19 10:50:06.335655 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_path.py
--rw-r--r--   0        0        0     3232 2024-03-19 10:50:06.339683 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_request.py
--rw-r--r--   0        0        0     2540 2024-03-19 10:50:06.342979 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_saml_source_connection.py
--rw-r--r--   0        0        0     2113 2024-03-19 10:50:06.347749 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_saml_source_connection_request.py
--rw-r--r--   0        0        0     4628 2024-03-19 10:50:06.353266 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_self.py
--rw-r--r--   0        0        0     1978 2024-03-19 10:50:06.356824 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_self_groups.py
--rw-r--r--   0        0        0     2476 2024-03-19 10:50:06.360453 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_service_account_request.py
--rw-r--r--   0        0        0     2352 2024-03-19 10:50:06.364265 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_service_account_response.py
--rw-r--r--   0        0        0     2315 2024-03-19 10:50:06.367906 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_setting.py
--rw-r--r--   0        0        0     2593 2024-03-19 10:50:06.370726 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_source_connection.py
--rw-r--r--   0        0        0      814 2024-03-19 10:50:06.374054 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_type_enum.py
--rw-r--r--   0        0        0      790 2024-03-19 10:50:06.376964 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_verification_enum.py
--rw-r--r--   0        0        0     4675 2024-03-19 10:50:06.380337 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_write_stage.py
--rw-r--r--   0        0        0     3823 2024-03-19 10:50:06.386060 authentik_client-2024.2.2.post1710845398/authentik_client/models/user_write_stage_request.py
--rw-r--r--   0        0        0     2570 2024-03-19 10:50:06.393372 authentik_client-2024.2.2.post1710845398/authentik_client/models/validation_error.py
--rw-r--r--   0        0        0     2831 2024-03-19 10:50:06.396898 authentik_client-2024.2.2.post1710845398/authentik_client/models/version.py
--rw-r--r--   0        0        0     2193 2024-03-19 10:50:06.400300 authentik_client-2024.2.2.post1710845398/authentik_client/models/web_authn_device.py
--rw-r--r--   0        0        0     1969 2024-03-19 10:50:06.405598 authentik_client-2024.2.2.post1710845398/authentik_client/models/web_authn_device_request.py
--rw-r--r--   0        0        0     1786 2024-03-19 10:50:06.409272 authentik_client-2024.2.2.post1710845398/authentik_client/models/workers.py
--rw-r--r--   0        0        0        0 2024-03-19 10:50:07.346378 authentik_client-2024.2.2.post1710845398/authentik_client/py.typed
--rw-r--r--   0        0        0    13840 2024-03-19 10:50:07.365074 authentik_client-2024.2.2.post1710845398/authentik_client/rest.py
--rw-r--r--   0        0        0      718 2024-03-19 10:50:07.345725 authentik_client-2024.2.2.post1710845398/pyproject.toml
--rw-r--r--   0        0        0   140874 1970-01-01 00:00:00.000000 authentik_client-2024.2.2.post1710845398/PKG-INFO
+-rw-r--r--   0        0        0   139998 2024-04-04 14:00:05.091852 authentik_client-2024.2.2.post1712239192/README.md
+-rw-r--r--   0        0        0    47193 2024-04-04 14:00:05.107852 authentik_client-2024.2.2.post1712239192/authentik_client/__init__.py
+-rw-r--r--   0        0        0     1170 2024-04-04 14:00:05.107852 authentik_client-2024.2.2.post1712239192/authentik_client/api/__init__.py
+-rw-r--r--   0        0        0    97518 2024-04-04 14:00:04.771847 authentik_client-2024.2.2.post1712239192/authentik_client/api/admin_api.py
+-rw-r--r--   0        0        0   700271 2024-04-04 14:00:04.791847 authentik_client-2024.2.2.post1712239192/authentik_client/api/authenticators_api.py
+-rw-r--r--   0        0        0   699928 2024-04-04 14:00:04.819847 authentik_client-2024.2.2.post1712239192/authentik_client/api/core_api.py
+-rw-r--r--   0        0        0   116805 2024-04-04 14:00:04.831848 authentik_client-2024.2.2.post1712239192/authentik_client/api/crypto_api.py
+-rw-r--r--   0        0        0   107946 2024-04-04 14:00:04.843848 authentik_client-2024.2.2.post1712239192/authentik_client/api/enterprise_api.py
+-rw-r--r--   0        0        0   408008 2024-04-04 14:00:04.855848 authentik_client-2024.2.2.post1712239192/authentik_client/api/events_api.py
+-rw-r--r--   0        0        0   280806 2024-04-04 14:00:04.863848 authentik_client-2024.2.2.post1712239192/authentik_client/api/flows_api.py
+-rw-r--r--   0        0        0   101134 2024-04-04 14:00:04.875848 authentik_client-2024.2.2.post1712239192/authentik_client/api/managed_api.py
+-rw-r--r--   0        0        0   135649 2024-04-04 14:00:04.879848 authentik_client-2024.2.2.post1712239192/authentik_client/api/oauth2_api.py
+-rw-r--r--   0        0        0   413301 2024-04-04 14:00:04.891849 authentik_client-2024.2.2.post1712239192/authentik_client/api/outposts_api.py
+-rw-r--r--   0        0        0   725201 2024-04-04 14:00:04.915849 authentik_client-2024.2.2.post1712239192/authentik_client/api/policies_api.py
+-rw-r--r--   0        0        0   552586 2024-04-04 14:00:04.935849 authentik_client-2024.2.2.post1712239192/authentik_client/api/propertymappings_api.py
+-rw-r--r--   0        0        0   718066 2024-04-04 14:00:04.959850 authentik_client-2024.2.2.post1712239192/authentik_client/api/providers_api.py
+-rw-r--r--   0        0        0   150485 2024-04-04 14:00:04.975850 authentik_client-2024.2.2.post1712239192/authentik_client/api/rac_api.py
+-rw-r--r--   0        0        0   207550 2024-04-04 14:00:04.983850 authentik_client-2024.2.2.post1712239192/authentik_client/api/rbac_api.py
+-rw-r--r--   0        0        0    10391 2024-04-04 14:00:04.991850 authentik_client-2024.2.2.post1712239192/authentik_client/api/root_api.py
+-rw-r--r--   0        0        0    11845 2024-04-04 14:00:04.999850 authentik_client-2024.2.2.post1712239192/authentik_client/api/schema_api.py
+-rw-r--r--   0        0        0   802117 2024-04-04 14:00:05.015851 authentik_client-2024.2.2.post1712239192/authentik_client/api/sources_api.py
+-rw-r--r--   0        0        0  1919636 2024-04-04 14:00:05.063851 authentik_client-2024.2.2.post1712239192/authentik_client/api/stages_api.py
+-rw-r--r--   0        0        0   157909 2024-04-04 14:00:05.083852 authentik_client-2024.2.2.post1712239192/authentik_client/api/tenants_api.py
+-rw-r--r--   0        0        0    25779 2024-04-04 14:00:05.111852 authentik_client-2024.2.2.post1712239192/authentik_client/api_client.py
+-rw-r--r--   0        0        0      652 2024-04-04 14:00:05.111852 authentik_client-2024.2.2.post1712239192/authentik_client/api_response.py
+-rw-r--r--   0        0        0    15345 2024-04-04 14:00:05.103852 authentik_client-2024.2.2.post1712239192/authentik_client/configuration.py
+-rw-r--r--   0        0        0     5934 2024-04-04 14:00:05.111852 authentik_client-2024.2.2.post1712239192/authentik_client/exceptions.py
+-rw-r--r--   0        0        0    45495 2024-04-04 14:00:05.107852 authentik_client-2024.2.2.post1712239192/authentik_client/models/__init__.py
+-rw-r--r--   0        0        0     4513 2024-04-04 14:00:01.887801 authentik_client-2024.2.2.post1712239192/authentik_client/models/access_denied_challenge.py
+-rw-r--r--   0        0        0     2482 2024-04-04 14:00:01.903802 authentik_client-2024.2.2.post1712239192/authentik_client/models/app.py
+-rw-r--r--   0        0        0     4168 2024-04-04 14:00:01.907802 authentik_client-2024.2.2.post1712239192/authentik_client/models/app_enum.py
+-rw-r--r--   0        0        0     2702 2024-04-04 14:00:01.919802 authentik_client-2024.2.2.post1712239192/authentik_client/models/apple_challenge_response_request.py
+-rw-r--r--   0        0        0     4508 2024-04-04 14:00:01.931802 authentik_client-2024.2.2.post1712239192/authentik_client/models/apple_login_challenge.py
+-rw-r--r--   0        0        0     6686 2024-04-04 14:00:01.939802 authentik_client-2024.2.2.post1712239192/authentik_client/models/application.py
+-rw-r--r--   0        0        0     4473 2024-04-04 14:00:01.947802 authentik_client-2024.2.2.post1712239192/authentik_client/models/application_request.py
+-rw-r--r--   0        0        0      711 2024-04-04 14:00:01.955802 authentik_client-2024.2.2.post1712239192/authentik_client/models/auth_mode_enum.py
+-rw-r--r--   0        0        0      709 2024-04-04 14:00:01.959802 authentik_client-2024.2.2.post1712239192/authentik_client/models/auth_type_enum.py
+-rw-r--r--   0        0        0     6061 2024-04-04 14:00:01.963802 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticate_web_authn_stage.py
+-rw-r--r--   0        0        0     5130 2024-04-04 14:00:01.971803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticate_web_authn_stage_request.py
+-rw-r--r--   0        0        0     4984 2024-04-04 14:00:01.979803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session.py
+-rw-r--r--   0        0        0     3064 2024-04-04 14:00:01.983803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_asn.py
+-rw-r--r--   0        0        0     2826 2024-04-04 14:00:01.991803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_geo_ip.py
+-rw-r--r--   0        0        0     3865 2024-04-04 14:00:01.995803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent.py
+-rw-r--r--   0        0        0     2646 2024-04-04 14:00:02.003803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent_device.py
+-rw-r--r--   0        0        0     2792 2024-04-04 14:00:02.007803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent_os.py
+-rw-r--r--   0        0        0     2725 2024-04-04 14:00:02.015803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent_user_agent.py
+-rw-r--r--   0        0        0      895 2024-04-04 14:00:02.019803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authentication_enum.py
+-rw-r--r--   0        0        0      782 2024-04-04 14:00:02.019803 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_attachment_enum.py
+-rw-r--r--   0        0        0     4686 2024-04-04 14:00:02.027804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_challenge.py
+-rw-r--r--   0        0        0     2743 2024-04-04 14:00:02.031804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_challenge_response_request.py
+-rw-r--r--   0        0        0     5327 2024-04-04 14:00:02.047804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage.py
+-rw-r--r--   0        0        0     2768 2024-04-04 14:00:02.051804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage_device_import_response.py
+-rw-r--r--   0        0        0     2785 2024-04-04 14:00:02.055804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage_manual_device_import_request.py
+-rw-r--r--   0        0        0     4744 2024-04-04 14:00:02.063804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage_request.py
+-rw-r--r--   0        0        0     4594 2024-04-04 14:00:02.071804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_challenge.py
+-rw-r--r--   0        0        0     3022 2024-04-04 14:00:02.075804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_challenge_response_request.py
+-rw-r--r--   0        0        0     6409 2024-04-04 14:00:02.083804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_stage.py
+-rw-r--r--   0        0        0     5595 2024-04-04 14:00:02.087804 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_stage_request.py
+-rw-r--r--   0        0        0     4474 2024-04-04 14:00:02.095805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_challenge.py
+-rw-r--r--   0        0        0     2761 2024-04-04 14:00:02.099805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_challenge_response_request.py
+-rw-r--r--   0        0        0     5363 2024-04-04 14:00:02.103805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_stage.py
+-rw-r--r--   0        0        0     4392 2024-04-04 14:00:02.111805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_stage_request.py
+-rw-r--r--   0        0        0     4468 2024-04-04 14:00:02.115805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_challenge.py
+-rw-r--r--   0        0        0     2858 2024-04-04 14:00:02.119805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_challenge_response_request.py
+-rw-r--r--   0        0        0     5132 2024-04-04 14:00:02.127805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_stage.py
+-rw-r--r--   0        0        0     4201 2024-04-04 14:00:02.131805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_stage_request.py
+-rw-r--r--   0        0        0     5636 2024-04-04 14:00:02.135805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validate_stage.py
+-rw-r--r--   0        0        0     4705 2024-04-04 14:00:02.143805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validate_stage_request.py
+-rw-r--r--   0        0        0     5717 2024-04-04 14:00:02.147805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validation_challenge.py
+-rw-r--r--   0        0        0     3805 2024-04-04 14:00:02.155805 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validation_challenge_response_request.py
+-rw-r--r--   0        0        0     4499 2024-04-04 14:00:02.159806 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_web_authn_challenge.py
+-rw-r--r--   0        0        0     2852 2024-04-04 14:00:02.163806 authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_web_authn_challenge_response_request.py
+-rw-r--r--   0        0        0     2718 2024-04-04 14:00:02.167806 authentik_client-2024.2.2.post1712239192/authentik_client/models/auto_submit_challenge_response_request.py
+-rw-r--r--   0        0        0     4388 2024-04-04 14:00:02.175806 authentik_client-2024.2.2.post1712239192/authentik_client/models/autosubmit_challenge.py
+-rw-r--r--   0        0        0      950 2024-04-04 14:00:02.175806 authentik_client-2024.2.2.post1712239192/authentik_client/models/backends_enum.py
+-rw-r--r--   0        0        0      748 2024-04-04 14:00:02.179806 authentik_client-2024.2.2.post1712239192/authentik_client/models/binding_type_enum.py
+-rw-r--r--   0        0        0     2995 2024-04-04 14:00:02.183806 authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_file.py
+-rw-r--r--   0        0        0     4453 2024-04-04 14:00:02.187806 authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_instance.py
+-rw-r--r--   0        0        0     3208 2024-04-04 14:00:02.191806 authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_instance_request.py
+-rw-r--r--   0        0        0      836 2024-04-04 14:00:02.195806 authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_instance_status_enum.py
+-rw-r--r--   0        0        0     6255 2024-04-04 14:00:02.199806 authentik_client-2024.2.2.post1712239192/authentik_client/models/brand.py
+-rw-r--r--   0        0        0     6307 2024-04-04 14:00:02.203806 authentik_client-2024.2.2.post1712239192/authentik_client/models/brand_request.py
+-rw-r--r--   0        0        0     2501 2024-04-04 14:00:02.207806 authentik_client-2024.2.2.post1712239192/authentik_client/models/cache.py
+-rw-r--r--   0        0        0      875 2024-04-04 14:00:02.211806 authentik_client-2024.2.2.post1712239192/authentik_client/models/capabilities_enum.py
+-rw-r--r--   0        0        0     4476 2024-04-04 14:00:02.215807 authentik_client-2024.2.2.post1712239192/authentik_client/models/captcha_challenge.py
+-rw-r--r--   0        0        0     2797 2024-04-04 14:00:02.219807 authentik_client-2024.2.2.post1712239192/authentik_client/models/captcha_challenge_response_request.py
+-rw-r--r--   0        0        0     4438 2024-04-04 14:00:02.223807 authentik_client-2024.2.2.post1712239192/authentik_client/models/captcha_stage.py
+-rw-r--r--   0        0        0     3774 2024-04-04 14:00:02.227807 authentik_client-2024.2.2.post1712239192/authentik_client/models/captcha_stage_request.py
+-rw-r--r--   0        0        0     2522 2024-04-04 14:00:02.231807 authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_data.py
+-rw-r--r--   0        0        0     2861 2024-04-04 14:00:02.235807 authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_generation_request.py
+-rw-r--r--   0        0        0     6655 2024-04-04 14:00:02.239807 authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_key_pair.py
+-rw-r--r--   0        0        0     2989 2024-04-04 14:00:02.247807 authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_key_pair_request.py
+-rw-r--r--   0        0        0      747 2024-04-04 14:00:02.247807 authentik_client-2024.2.2.post1712239192/authentik_client/models/challenge_choices.py
+-rw-r--r--   0        0        0    24236 2024-04-04 14:00:02.255807 authentik_client-2024.2.2.post1712239192/authentik_client/models/challenge_types.py
+-rw-r--r--   0        0        0      729 2024-04-04 14:00:02.259807 authentik_client-2024.2.2.post1712239192/authentik_client/models/client_type_enum.py
+-rw-r--r--   0        0        0     3539 2024-04-04 14:00:02.263807 authentik_client-2024.2.2.post1712239192/authentik_client/models/config.py
+-rw-r--r--   0        0        0     4021 2024-04-04 14:00:02.271807 authentik_client-2024.2.2.post1712239192/authentik_client/models/connection_token.py
+-rw-r--r--   0        0        0     2662 2024-04-04 14:00:02.275807 authentik_client-2024.2.2.post1712239192/authentik_client/models/connection_token_request.py
+-rw-r--r--   0        0        0     5736 2024-04-04 14:00:02.279807 authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_challenge.py
+-rw-r--r--   0        0        0     2838 2024-04-04 14:00:02.283808 authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_challenge_response_request.py
+-rw-r--r--   0        0        0     2513 2024-04-04 14:00:02.287808 authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_permission.py
+-rw-r--r--   0        0        0     4511 2024-04-04 14:00:02.295808 authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_stage.py
+-rw-r--r--   0        0        0      783 2024-04-04 14:00:02.295808 authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_stage_mode_enum.py
+-rw-r--r--   0        0        0     3569 2024-04-04 14:00:02.299808 authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_stage_request.py
+-rw-r--r--   0        0        0     2891 2024-04-04 14:00:02.307808 authentik_client-2024.2.2.post1712239192/authentik_client/models/contextual_flow_info.py
+-rw-r--r--   0        0        0      879 2024-04-04 14:00:02.307808 authentik_client-2024.2.2.post1712239192/authentik_client/models/contextual_flow_info_layout_enum.py
+-rw-r--r--   0        0        0     2657 2024-04-04 14:00:02.311808 authentik_client-2024.2.2.post1712239192/authentik_client/models/coordinate.py
+-rw-r--r--   0        0        0     4704 2024-04-04 14:00:02.319808 authentik_client-2024.2.2.post1712239192/authentik_client/models/current_brand.py
+-rw-r--r--   0        0        0      771 2024-04-04 14:00:02.319808 authentik_client-2024.2.2.post1712239192/authentik_client/models/denied_action_enum.py
+-rw-r--r--   0        0        0     4200 2024-04-04 14:00:02.331808 authentik_client-2024.2.2.post1712239192/authentik_client/models/deny_stage.py
+-rw-r--r--   0        0        0     3230 2024-04-04 14:00:02.335808 authentik_client-2024.2.2.post1712239192/authentik_client/models/deny_stage_request.py
+-rw-r--r--   0        0        0     3522 2024-04-04 14:00:02.339809 authentik_client-2024.2.2.post1712239192/authentik_client/models/device.py
+-rw-r--r--   0        0        0     2657 2024-04-04 14:00:02.343809 authentik_client-2024.2.2.post1712239192/authentik_client/models/device_challenge.py
+-rw-r--r--   0        0        0     2792 2024-04-04 14:00:02.351809 authentik_client-2024.2.2.post1712239192/authentik_client/models/device_challenge_request.py
+-rw-r--r--   0        0        0      780 2024-04-04 14:00:02.351809 authentik_client-2024.2.2.post1712239192/authentik_client/models/device_classes_enum.py
+-rw-r--r--   0        0        0     1244 2024-04-04 14:00:02.355809 authentik_client-2024.2.2.post1712239192/authentik_client/models/digest_algorithm_enum.py
+-rw-r--r--   0        0        0      695 2024-04-04 14:00:02.359809 authentik_client-2024.2.2.post1712239192/authentik_client/models/digits_enum.py
+-rw-r--r--   0        0        0     4969 2024-04-04 14:00:02.363809 authentik_client-2024.2.2.post1712239192/authentik_client/models/docker_service_connection.py
+-rw-r--r--   0        0        0     4087 2024-04-04 14:00:02.367809 authentik_client-2024.2.2.post1712239192/authentik_client/models/docker_service_connection_request.py
+-rw-r--r--   0        0        0     2847 2024-04-04 14:00:02.371809 authentik_client-2024.2.2.post1712239192/authentik_client/models/domain.py
+-rw-r--r--   0        0        0     2746 2024-04-04 14:00:02.375809 authentik_client-2024.2.2.post1712239192/authentik_client/models/domain_request.py
+-rw-r--r--   0        0        0     4155 2024-04-04 14:00:02.379809 authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_challenge.py
+-rw-r--r--   0        0        0     2681 2024-04-04 14:00:02.383809 authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_challenge_response_request.py
+-rw-r--r--   0        0        0     4515 2024-04-04 14:00:02.387809 authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_policy.py
+-rw-r--r--   0        0        0     3237 2024-04-04 14:00:02.387809 authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_policy_request.py
+-rw-r--r--   0        0        0     4213 2024-04-04 14:00:02.395809 authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_stage.py
+-rw-r--r--   0        0        0     3232 2024-04-04 14:00:02.395809 authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_stage_request.py
+-rw-r--r--   0        0        0     2720 2024-04-04 14:00:02.399809 authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_device.py
+-rw-r--r--   0        0        0     2575 2024-04-04 14:00:02.403809 authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_device_enrollment_status.py
+-rw-r--r--   0        0        0     2619 2024-04-04 14:00:02.407810 authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_device_request.py
+-rw-r--r--   0        0        0      748 2024-04-04 14:00:02.411810 authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_response_enum.py
+-rw-r--r--   0        0        0     4090 2024-04-04 14:00:02.415810 authentik_client-2024.2.2.post1712239192/authentik_client/models/email_challenge.py
+-rw-r--r--   0        0        0     2770 2024-04-04 14:00:02.427810 authentik_client-2024.2.2.post1712239192/authentik_client/models/email_challenge_response_request.py
+-rw-r--r--   0        0        0     5902 2024-04-04 14:00:02.431810 authentik_client-2024.2.2.post1712239192/authentik_client/models/email_stage.py
+-rw-r--r--   0        0        0     5121 2024-04-04 14:00:02.439810 authentik_client-2024.2.2.post1712239192/authentik_client/models/email_stage_request.py
+-rw-r--r--   0        0        0     4707 2024-04-04 14:00:02.447810 authentik_client-2024.2.2.post1712239192/authentik_client/models/endpoint.py
+-rw-r--r--   0        0        0     3678 2024-04-04 14:00:02.455810 authentik_client-2024.2.2.post1712239192/authentik_client/models/endpoint_request.py
+-rw-r--r--   0        0        0     2530 2024-04-04 14:00:02.459810 authentik_client-2024.2.2.post1712239192/authentik_client/models/error_detail.py
+-rw-r--r--   0        0        0     3309 2024-04-04 14:00:02.463810 authentik_client-2024.2.2.post1712239192/authentik_client/models/error_reporting_config.py
+-rw-r--r--   0        0        0     4129 2024-04-04 14:00:02.471810 authentik_client-2024.2.2.post1712239192/authentik_client/models/event.py
+-rw-r--r--   0        0        0     1730 2024-04-04 14:00:02.475811 authentik_client-2024.2.2.post1712239192/authentik_client/models/event_actions.py
+-rw-r--r--   0        0        0     6006 2024-04-04 14:00:02.479811 authentik_client-2024.2.2.post1712239192/authentik_client/models/event_matcher_policy.py
+-rw-r--r--   0        0        0     4807 2024-04-04 14:00:02.487811 authentik_client-2024.2.2.post1712239192/authentik_client/models/event_matcher_policy_request.py
+-rw-r--r--   0        0        0     3990 2024-04-04 14:00:02.491811 authentik_client-2024.2.2.post1712239192/authentik_client/models/event_request.py
+-rw-r--r--   0        0        0     2697 2024-04-04 14:00:02.499811 authentik_client-2024.2.2.post1712239192/authentik_client/models/event_top_per_user.py
+-rw-r--r--   0        0        0     3715 2024-04-04 14:00:02.503811 authentik_client-2024.2.2.post1712239192/authentik_client/models/expiring_base_grant_model.py
+-rw-r--r--   0        0        0     4191 2024-04-04 14:00:02.511811 authentik_client-2024.2.2.post1712239192/authentik_client/models/expression_policy.py
+-rw-r--r--   0        0        0     2992 2024-04-04 14:00:02.515811 authentik_client-2024.2.2.post1712239192/authentik_client/models/expression_policy_request.py
+-rw-r--r--   0        0        0     4524 2024-04-04 14:00:02.523811 authentik_client-2024.2.2.post1712239192/authentik_client/models/extra_role_object_permission.py
+-rw-r--r--   0        0        0     4524 2024-04-04 14:00:02.531812 authentik_client-2024.2.2.post1712239192/authentik_client/models/extra_user_object_permission.py
+-rw-r--r--   0        0        0     2519 2024-04-04 14:00:02.535812 authentik_client-2024.2.2.post1712239192/authentik_client/models/file_path_request.py
+-rw-r--r--   0        0        0     6047 2024-04-04 14:00:02.543812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow.py
+-rw-r--r--   0        0        0    25850 2024-04-04 14:00:02.547812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_challenge_response_request.py
+-rw-r--r--   0        0        0      934 2024-04-04 14:00:02.551812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_designation_enum.py
+-rw-r--r--   0        0        0     2533 2024-04-04 14:00:02.567812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_diagram.py
+-rw-r--r--   0        0        0     4505 2024-04-04 14:00:02.575812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_error_challenge.py
+-rw-r--r--   0        0        0     3111 2024-04-04 14:00:02.583812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_import_result.py
+-rw-r--r--   0        0        0     3418 2024-04-04 14:00:02.591812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_inspection.py
+-rw-r--r--   0        0        0     3875 2024-04-04 14:00:02.595812 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_inspector_plan.py
+-rw-r--r--   0        0        0      837 2024-04-04 14:00:02.599813 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_layout_enum.py
+-rw-r--r--   0        0        0     4741 2024-04-04 14:00:02.607813 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_request.py
+-rw-r--r--   0        0        0     5223 2024-04-04 14:00:02.615813 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_set.py
+-rw-r--r--   0        0        0     4459 2024-04-04 14:00:02.623813 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_set_request.py
+-rw-r--r--   0        0        0     4763 2024-04-04 14:00:02.627813 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_stage_binding.py
+-rw-r--r--   0        0        0     3983 2024-04-04 14:00:02.635813 authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_stage_binding_request.py
+-rw-r--r--   0        0        0     2641 2024-04-04 14:00:02.639813 authentik_client-2024.2.2.post1712239192/authentik_client/models/footer_link.py
+-rw-r--r--   0        0        0     2531 2024-04-04 14:00:02.647813 authentik_client-2024.2.2.post1712239192/authentik_client/models/generic_error.py
+-rw-r--r--   0        0        0      865 2024-04-04 14:00:02.651813 authentik_client-2024.2.2.post1712239192/authentik_client/models/geoip_binding_enum.py
+-rw-r--r--   0        0        0     5216 2024-04-04 14:00:02.655813 authentik_client-2024.2.2.post1712239192/authentik_client/models/group.py
+-rw-r--r--   0        0        0     4209 2024-04-04 14:00:02.663813 authentik_client-2024.2.2.post1712239192/authentik_client/models/group_member.py
+-rw-r--r--   0        0        0     4006 2024-04-04 14:00:02.671814 authentik_client-2024.2.2.post1712239192/authentik_client/models/group_member_request.py
+-rw-r--r--   0        0        0     3347 2024-04-04 14:00:02.679814 authentik_client-2024.2.2.post1712239192/authentik_client/models/group_request.py
+-rw-r--r--   0        0        0     6080 2024-04-04 14:00:02.683814 authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_challenge.py
+-rw-r--r--   0        0        0     3174 2024-04-04 14:00:02.691814 authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_challenge_response_request.py
+-rw-r--r--   0        0        0     7503 2024-04-04 14:00:02.699814 authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_stage.py
+-rw-r--r--   0        0        0     6533 2024-04-04 14:00:02.707814 authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_stage_request.py
+-rw-r--r--   0        0        0     2438 2024-04-04 14:00:02.711814 authentik_client-2024.2.2.post1712239192/authentik_client/models/install_id.py
+-rw-r--r--   0        0        0      771 2024-04-04 14:00:02.715814 authentik_client-2024.2.2.post1712239192/authentik_client/models/intent_enum.py
+-rw-r--r--   0        0        0      800 2024-04-04 14:00:02.719814 authentik_client-2024.2.2.post1712239192/authentik_client/models/invalid_response_action_enum.py
+-rw-r--r--   0        0        0     4667 2024-04-04 14:00:02.723815 authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation.py
+-rw-r--r--   0        0        0     3684 2024-04-04 14:00:02.731815 authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation_request.py
+-rw-r--r--   0        0        0     4508 2024-04-04 14:00:02.739815 authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation_stage.py
+-rw-r--r--   0        0        0     3527 2024-04-04 14:00:02.747815 authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation_stage_request.py
+-rw-r--r--   0        0        0      729 2024-04-04 14:00:02.747815 authentik_client-2024.2.2.post1712239192/authentik_client/models/issuer_mode_enum.py
+-rw-r--r--   0        0        0     4386 2024-04-04 14:00:02.755815 authentik_client-2024.2.2.post1712239192/authentik_client/models/kubernetes_service_connection.py
+-rw-r--r--   0        0        0     3454 2024-04-04 14:00:02.759815 authentik_client-2024.2.2.post1712239192/authentik_client/models/kubernetes_service_connection_request.py
+-rw-r--r--   0        0        0     2811 2024-04-04 14:00:02.767815 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_debug.py
+-rw-r--r--   0        0        0     5765 2024-04-04 14:00:02.775815 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_outpost_config.py
+-rw-r--r--   0        0        0     4378 2024-04-04 14:00:02.779815 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_property_mapping.py
+-rw-r--r--   0        0        0     3478 2024-04-04 14:00:02.783815 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_property_mapping_request.py
+-rw-r--r--   0        0        0     8694 2024-04-04 14:00:02.787815 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_provider.py
+-rw-r--r--   0        0        0     6192 2024-04-04 14:00:02.791816 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_provider_request.py
+-rw-r--r--   0        0        0    11791 2024-04-04 14:00:02.795816 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_source.py
+-rw-r--r--   0        0        0     9542 2024-04-04 14:00:02.799816 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_source_request.py
+-rw-r--r--   0        0        0     3129 2024-04-04 14:00:02.803816 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_sync_status.py
+-rw-r--r--   0        0        0      726 2024-04-04 14:00:02.763815 authentik_client-2024.2.2.post1712239192/authentik_client/models/ldapapi_access_mode.py
+-rw-r--r--   0        0        0     3278 2024-04-04 14:00:02.807816 authentik_client-2024.2.2.post1712239192/authentik_client/models/license.py
+-rw-r--r--   0        0        0     2897 2024-04-04 14:00:02.811816 authentik_client-2024.2.2.post1712239192/authentik_client/models/license_forecast.py
+-rw-r--r--   0        0        0     2509 2024-04-04 14:00:02.815816 authentik_client-2024.2.2.post1712239192/authentik_client/models/license_request.py
+-rw-r--r--   0        0        0     3222 2024-04-04 14:00:02.819816 authentik_client-2024.2.2.post1712239192/authentik_client/models/license_summary.py
+-rw-r--r--   0        0        0     2411 2024-04-04 14:00:02.819816 authentik_client-2024.2.2.post1712239192/authentik_client/models/link.py
+-rw-r--r--   0        0        0     2882 2024-04-04 14:00:02.823816 authentik_client-2024.2.2.post1712239192/authentik_client/models/log_event.py
+-rw-r--r--   0        0        0      843 2024-04-04 14:00:02.827816 authentik_client-2024.2.2.post1712239192/authentik_client/models/log_level_enum.py
+-rw-r--r--   0        0        0     6520 2024-04-04 14:00:02.831816 authentik_client-2024.2.2.post1712239192/authentik_client/models/login_challenge_types.py
+-rw-r--r--   0        0        0     4171 2024-04-04 14:00:02.835816 authentik_client-2024.2.2.post1712239192/authentik_client/models/login_metrics.py
+-rw-r--r--   0        0        0     3192 2024-04-04 14:00:02.839816 authentik_client-2024.2.2.post1712239192/authentik_client/models/login_source.py
+-rw-r--r--   0        0        0     2513 2024-04-04 14:00:02.843816 authentik_client-2024.2.2.post1712239192/authentik_client/models/metadata.py
+-rw-r--r--   0        0        0     7522 2024-04-04 14:00:02.843816 authentik_client-2024.2.2.post1712239192/authentik_client/models/model_enum.py
+-rw-r--r--   0        0        0     9828 2024-04-04 14:00:02.847816 authentik_client-2024.2.2.post1712239192/authentik_client/models/model_request.py
+-rw-r--r--   0        0        0     1559 2024-04-04 14:00:02.851817 authentik_client-2024.2.2.post1712239192/authentik_client/models/name_id_policy_enum.py
+-rw-r--r--   0        0        0      831 2024-04-04 14:00:02.855816 authentik_client-2024.2.2.post1712239192/authentik_client/models/network_binding_enum.py
+-rw-r--r--   0        0        0      764 2024-04-04 14:00:02.855816 authentik_client-2024.2.2.post1712239192/authentik_client/models/not_configured_action_enum.py
+-rw-r--r--   0        0        0     3479 2024-04-04 14:00:02.859817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification.py
+-rw-r--r--   0        0        0     2858 2024-04-04 14:00:02.863817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_request.py
+-rw-r--r--   0        0        0     4010 2024-04-04 14:00:02.867817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_rule.py
+-rw-r--r--   0        0        0     3549 2024-04-04 14:00:02.871817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_rule_request.py
+-rw-r--r--   0        0        0     3760 2024-04-04 14:00:02.875817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport.py
+-rw-r--r--   0        0        0      818 2024-04-04 14:00:02.875817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport_mode_enum.py
+-rw-r--r--   0        0        0     3500 2024-04-04 14:00:02.879817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport_request.py
+-rw-r--r--   0        0        0     2503 2024-04-04 14:00:02.883817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport_test.py
+-rw-r--r--   0        0        0     2707 2024-04-04 14:00:02.891817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_webhook_mapping.py
+-rw-r--r--   0        0        0     2717 2024-04-04 14:00:02.895817 authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_webhook_mapping_request.py
+-rw-r--r--   0        0        0     8888 2024-04-04 14:00:02.899817 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth2_provider.py
+-rw-r--r--   0        0        0     6654 2024-04-04 14:00:02.903817 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth2_provider_request.py
+-rw-r--r--   0        0        0     3482 2024-04-04 14:00:02.907817 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth2_provider_setup_urls.py
+-rw-r--r--   0        0        0     4164 2024-04-04 14:00:02.911817 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_challenge.py
+-rw-r--r--   0        0        0     2846 2024-04-04 14:00:02.911817 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_challenge_response_request.py
+-rw-r--r--   0        0        0     4213 2024-04-04 14:00:02.919818 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_finish_challenge.py
+-rw-r--r--   0        0        0     2816 2024-04-04 14:00:02.919818 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_finish_challenge_response_request.py
+-rw-r--r--   0        0        0    10563 2024-04-04 14:00:02.927818 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_source.py
+-rw-r--r--   0        0        0     8069 2024-04-04 14:00:02.931818 authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_source_request.py
+-rw-r--r--   0        0        0     3922 2024-04-04 14:00:02.935818 authentik_client-2024.2.2.post1712239192/authentik_client/models/open_id_connect_configuration.py
+-rw-r--r--   0        0        0     5545 2024-04-04 14:00:02.939818 authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost.py
+-rw-r--r--   0        0        0     2541 2024-04-04 14:00:02.939818 authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_default_config.py
+-rw-r--r--   0        0        0     3755 2024-04-04 14:00:02.943818 authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_health.py
+-rw-r--r--   0        0        0     4050 2024-04-04 14:00:02.947818 authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_request.py
+-rw-r--r--   0        0        0      752 2024-04-04 14:00:02.951818 authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_type_enum.py
+-rw-r--r--   0        0        0     3322 2024-04-04 14:00:02.951818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_application_list.py
+-rw-r--r--   0        0        0     3437 2024-04-04 14:00:02.955818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticate_web_authn_stage_list.py
+-rw-r--r--   0        0        0     3395 2024-04-04 14:00:02.959818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticated_session_list.py
+-rw-r--r--   0        0        0     3404 2024-04-04 14:00:02.959818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_duo_stage_list.py
+-rw-r--r--   0        0        0     3404 2024-04-04 14:00:02.963818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_sms_stage_list.py
+-rw-r--r--   0        0        0     3428 2024-04-04 14:00:02.967818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_static_stage_list.py
+-rw-r--r--   0        0        0     3412 2024-04-04 14:00:02.971818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_totp_stage_list.py
+-rw-r--r--   0        0        0     3444 2024-04-04 14:00:02.975818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_validate_stage_list.py
+-rw-r--r--   0        0        0     3371 2024-04-04 14:00:02.975818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_blueprint_instance_list.py
+-rw-r--r--   0        0        0     3274 2024-04-04 14:00:02.979818 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_brand_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:02.983819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_captcha_stage_list.py
+-rw-r--r--   0        0        0     3380 2024-04-04 14:00:02.987819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_certificate_key_pair_list.py
+-rw-r--r--   0        0        0     3355 2024-04-04 14:00:02.991819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_connection_token_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:02.991819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_consent_stage_list.py
+-rw-r--r--   0        0        0     3307 2024-04-04 14:00:02.995819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_deny_stage_list.py
+-rw-r--r--   0        0        0     3420 2024-04-04 14:00:02.999819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_docker_service_connection_list.py
+-rw-r--r--   0        0        0     3282 2024-04-04 14:00:03.003819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_domain_list.py
+-rw-r--r--   0        0        0     3323 2024-04-04 14:00:03.007819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_dummy_policy_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.011819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_dummy_stage_list.py
+-rw-r--r--   0        0        0     3307 2024-04-04 14:00:03.015819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_duo_device_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.015819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_email_stage_list.py
+-rw-r--r--   0        0        0     3298 2024-04-04 14:00:03.019819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_endpoint_list.py
+-rw-r--r--   0        0        0     3274 2024-04-04 14:00:03.023819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_event_list.py
+-rw-r--r--   0        0        0     3380 2024-04-04 14:00:03.023819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_event_matcher_policy_list.py
+-rw-r--r--   0        0        0     3413 2024-04-04 14:00:03.027819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_expiring_base_grant_model_list.py
+-rw-r--r--   0        0        0     3363 2024-04-04 14:00:03.031819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_expression_policy_list.py
+-rw-r--r--   0        0        0     3437 2024-04-04 14:00:03.031819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_extra_role_object_permission_list.py
+-rw-r--r--   0        0        0     3437 2024-04-04 14:00:03.035819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_extra_user_object_permission_list.py
+-rw-r--r--   0        0        0     3266 2024-04-04 14:00:03.039820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_flow_list.py
+-rw-r--r--   0        0        0     3364 2024-04-04 14:00:03.039820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_flow_stage_binding_list.py
+-rw-r--r--   0        0        0     3274 2024-04-04 14:00:03.043820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_group_list.py
+-rw-r--r--   0        0        0     3387 2024-04-04 14:00:03.047819 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_identification_stage_list.py
+-rw-r--r--   0        0        0     3314 2024-04-04 14:00:03.051820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_invitation_list.py
+-rw-r--r--   0        0        0     3355 2024-04-04 14:00:03.055820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_invitation_stage_list.py
+-rw-r--r--   0        0        0     3452 2024-04-04 14:00:03.059820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_kubernetes_service_connection_list.py
+-rw-r--r--   0        0        0     3372 2024-04-04 14:00:03.063820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_outpost_config_list.py
+-rw-r--r--   0        0        0     3388 2024-04-04 14:00:03.063820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_property_mapping_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:03.067820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_provider_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.071820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_source_list.py
+-rw-r--r--   0        0        0     3290 2024-04-04 14:00:03.075820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_license_list.py
+-rw-r--r--   0        0        0     3330 2024-04-04 14:00:03.079820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_list.py
+-rw-r--r--   0        0        0     3363 2024-04-04 14:00:03.083820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_rule_list.py
+-rw-r--r--   0        0        0     3403 2024-04-04 14:00:03.083820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_transport_list.py
+-rw-r--r--   0        0        0     3444 2024-04-04 14:00:03.087820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_webhook_mapping_list.py
+-rw-r--r--   0        0        0     3348 2024-04-04 14:00:03.091820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_o_auth2_provider_list.py
+-rw-r--r--   0        0        0     3324 2024-04-04 14:00:03.095820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_o_auth_source_list.py
+-rw-r--r--   0        0        0     3290 2024-04-04 14:00:03.099820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_outpost_list.py
+-rw-r--r--   0        0        0     3396 2024-04-04 14:00:03.103820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_password_expiry_policy_list.py
+-rw-r--r--   0        0        0     3347 2024-04-04 14:00:03.103820 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_password_policy_list.py
+-rw-r--r--   0        0        0     3339 2024-04-04 14:00:03.107821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_password_stage_list.py
+-rw-r--r--   0        0        0     3314 2024-04-04 14:00:03.111821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_permission_list.py
+-rw-r--r--   0        0        0     3396 2024-04-04 14:00:03.115821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_plex_source_connection_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.119821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_plex_source_list.py
+-rw-r--r--   0        0        0     3339 2024-04-04 14:00:03.123821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_policy_binding_list.py
+-rw-r--r--   0        0        0     3282 2024-04-04 14:00:03.127821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_policy_list.py
+-rw-r--r--   0        0        0     3282 2024-04-04 14:00:03.127821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_prompt_list.py
+-rw-r--r--   0        0        0     3323 2024-04-04 14:00:03.131821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_prompt_stage_list.py
+-rw-r--r--   0        0        0     3355 2024-04-04 14:00:03.135821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_property_mapping_list.py
+-rw-r--r--   0        0        0     3298 2024-04-04 14:00:03.139821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_provider_list.py
+-rw-r--r--   0        0        0     3380 2024-04-04 14:00:03.143821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_proxy_outpost_config_list.py
+-rw-r--r--   0        0        0     3339 2024-04-04 14:00:03.147821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_proxy_provider_list.py
+-rw-r--r--   0        0        0     3380 2024-04-04 14:00:03.147821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_rac_property_mapping_list.py
+-rw-r--r--   0        0        0     3323 2024-04-04 14:00:03.151821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_rac_provider_list.py
+-rw-r--r--   0        0        0     3388 2024-04-04 14:00:03.155821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_radius_outpost_config_list.py
+-rw-r--r--   0        0        0     3347 2024-04-04 14:00:03.159821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_radius_provider_list.py
+-rw-r--r--   0        0        0     3314 2024-04-04 14:00:03.163821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_reputation_list.py
+-rw-r--r--   0        0        0     3363 2024-04-04 14:00:03.167822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_reputation_policy_list.py
+-rw-r--r--   0        0        0     3461 2024-04-04 14:00:03.167822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_role_assigned_object_permission_list.py
+-rw-r--r--   0        0        0     3266 2024-04-04 14:00:03.171821 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_role_list.py
+-rw-r--r--   0        0        0     3388 2024-04-04 14:00:03.179822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_saml_property_mapping_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:03.183822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_saml_provider_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.187822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_saml_source_list.py
+-rw-r--r--   0        0        0     3323 2024-04-04 14:00:03.191822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_scim_mapping_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:03.195822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_scim_provider_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:03.199822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_scope_mapping_list.py
+-rw-r--r--   0        0        0     3371 2024-04-04 14:00:03.203822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_service_connection_list.py
+-rw-r--r--   0        0        0     3307 2024-04-04 14:00:03.199822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_sms_device_list.py
+-rw-r--r--   0        0        0     3282 2024-04-04 14:00:03.207822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_source_list.py
+-rw-r--r--   0        0        0     3323 2024-04-04 14:00:03.211822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_source_stage_list.py
+-rw-r--r--   0        0        0     3274 2024-04-04 14:00:03.215822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_stage_list.py
+-rw-r--r--   0        0        0     3331 2024-04-04 14:00:03.219822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_static_device_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.223822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_system_task_list.py
+-rw-r--r--   0        0        0     3282 2024-04-04 14:00:03.227822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_tenant_list.py
+-rw-r--r--   0        0        0     3274 2024-04-04 14:00:03.231823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_token_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.235823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_token_model_list.py
+-rw-r--r--   0        0        0     3315 2024-04-04 14:00:03.223822 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_totp_device_list.py
+-rw-r--r--   0        0        0     3461 2024-04-04 14:00:03.239823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_assigned_object_permission_list.py
+-rw-r--r--   0        0        0     3323 2024-04-04 14:00:03.243823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_consent_list.py
+-rw-r--r--   0        0        0     3356 2024-04-04 14:00:03.247823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_delete_stage_list.py
+-rw-r--r--   0        0        0     3266 2024-04-04 14:00:03.247823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_list.py
+-rw-r--r--   0        0        0     3348 2024-04-04 14:00:03.251823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_login_stage_list.py
+-rw-r--r--   0        0        0     3356 2024-04-04 14:00:03.255823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_logout_stage_list.py
+-rw-r--r--   0        0        0     3438 2024-04-04 14:00:03.259823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_o_auth_source_connection_list.py
+-rw-r--r--   0        0        0     3429 2024-04-04 14:00:03.263823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_saml_source_connection_list.py
+-rw-r--r--   0        0        0     3396 2024-04-04 14:00:03.263823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_source_connection_list.py
+-rw-r--r--   0        0        0     3348 2024-04-04 14:00:03.267823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_write_stage_list.py
+-rw-r--r--   0        0        0     3348 2024-04-04 14:00:03.271823 authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_web_authn_device_list.py
+-rw-r--r--   0        0        0     3076 2024-04-04 14:00:03.275823 authentik_client-2024.2.2.post1712239192/authentik_client/models/pagination.py
+-rw-r--r--   0        0        0     4454 2024-04-04 14:00:03.279823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_challenge.py
+-rw-r--r--   0        0        0     2819 2024-04-04 14:00:03.279823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_challenge_response_request.py
+-rw-r--r--   0        0        0     4377 2024-04-04 14:00:03.283823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_expiry_policy.py
+-rw-r--r--   0        0        0     3099 2024-04-04 14:00:03.287823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_expiry_policy_request.py
+-rw-r--r--   0        0        0     6428 2024-04-04 14:00:03.287823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_policy.py
+-rw-r--r--   0        0        0     5239 2024-04-04 14:00:03.291823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_policy_request.py
+-rw-r--r--   0        0        0     5274 2024-04-04 14:00:03.295823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_stage.py
+-rw-r--r--   0        0        0     4264 2024-04-04 14:00:03.295823 authentik_client-2024.2.2.post1712239192/authentik_client/models/password_stage_request.py
+-rw-r--r--   0        0        0     4594 2024-04-04 14:00:03.299824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_application_request.py
+-rw-r--r--   0        0        0     5168 2024-04-04 14:00:03.303824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticate_web_authn_stage_request.py
+-rw-r--r--   0        0        0     4833 2024-04-04 14:00:03.307824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_duo_stage_request.py
+-rw-r--r--   0        0        0     5701 2024-04-04 14:00:03.311824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_sms_stage_request.py
+-rw-r--r--   0        0        0     4430 2024-04-04 14:00:03.311824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_static_stage_request.py
+-rw-r--r--   0        0        0     4256 2024-04-04 14:00:03.315824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_totp_stage_request.py
+-rw-r--r--   0        0        0     4743 2024-04-04 14:00:03.319824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_validate_stage_request.py
+-rw-r--r--   0        0        0     3246 2024-04-04 14:00:03.323824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_blueprint_instance_request.py
+-rw-r--r--   0        0        0     6352 2024-04-04 14:00:03.323824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_brand_request.py
+-rw-r--r--   0        0        0     3860 2024-04-04 14:00:03.327824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_captcha_stage_request.py
+-rw-r--r--   0        0        0     3051 2024-04-04 14:00:03.331824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_certificate_key_pair_request.py
+-rw-r--r--   0        0        0     2717 2024-04-04 14:00:03.331824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_connection_token_request.py
+-rw-r--r--   0        0        0     3607 2024-04-04 14:00:03.335824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_consent_stage_request.py
+-rw-r--r--   0        0        0     3268 2024-04-04 14:00:03.335824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_deny_stage_request.py
+-rw-r--r--   0        0        0     4149 2024-04-04 14:00:03.339824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_docker_service_connection_request.py
+-rw-r--r--   0        0        0     2801 2024-04-04 14:00:03.339824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_domain_request.py
+-rw-r--r--   0        0        0     3275 2024-04-04 14:00:03.343824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_dummy_policy_request.py
+-rw-r--r--   0        0        0     3270 2024-04-04 14:00:03.343824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_dummy_stage_request.py
+-rw-r--r--   0        0        0     2674 2024-04-04 14:00:03.347824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_duo_device_request.py
+-rw-r--r--   0        0        0     5159 2024-04-04 14:00:03.347824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_email_stage_request.py
+-rw-r--r--   0        0        0     3784 2024-04-04 14:00:03.351824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_endpoint_request.py
+-rw-r--r--   0        0        0     4845 2024-04-04 14:00:03.355824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_event_matcher_policy_request.py
+-rw-r--r--   0        0        0     4045 2024-04-04 14:00:03.355824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_event_request.py
+-rw-r--r--   0        0        0     3047 2024-04-04 14:00:03.359825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_expression_policy_request.py
+-rw-r--r--   0        0        0     4903 2024-04-04 14:00:03.363824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_flow_request.py
+-rw-r--r--   0        0        0     4055 2024-04-04 14:00:03.363824 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_flow_stage_binding_request.py
+-rw-r--r--   0        0        0     3385 2024-04-04 14:00:03.367825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_group_request.py
+-rw-r--r--   0        0        0     6571 2024-04-04 14:00:03.371825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_identification_stage_request.py
+-rw-r--r--   0        0        0     3774 2024-04-04 14:00:03.375825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_invitation_request.py
+-rw-r--r--   0        0        0     3565 2024-04-04 14:00:03.375825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_invitation_stage_request.py
+-rw-r--r--   0        0        0     3492 2024-04-04 14:00:03.379825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_kubernetes_service_connection_request.py
+-rw-r--r--   0        0        0     3550 2024-04-04 14:00:03.383825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_ldap_property_mapping_request.py
+-rw-r--r--   0        0        0     6254 2024-04-04 14:00:03.383825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_ldap_provider_request.py
+-rw-r--r--   0        0        0     9697 2024-04-04 14:00:03.387825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_ldap_source_request.py
+-rw-r--r--   0        0        0     2557 2024-04-04 14:00:03.391825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_license_request.py
+-rw-r--r--   0        0        0     2879 2024-04-04 14:00:03.395825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_request.py
+-rw-r--r--   0        0        0     3587 2024-04-04 14:00:03.399825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_rule_request.py
+-rw-r--r--   0        0        0     3538 2024-04-04 14:00:03.399825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_transport_request.py
+-rw-r--r--   0        0        0     2782 2024-04-04 14:00:03.403825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_webhook_mapping_request.py
+-rw-r--r--   0        0        0     6716 2024-04-04 14:00:03.407825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_o_auth2_provider_request.py
+-rw-r--r--   0        0        0     8241 2024-04-04 14:00:03.407825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_o_auth_source_request.py
+-rw-r--r--   0        0        0     4139 2024-04-04 14:00:03.411825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_outpost_request.py
+-rw-r--r--   0        0        0     3154 2024-04-04 14:00:03.415825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_password_expiry_policy_request.py
+-rw-r--r--   0        0        0     5277 2024-04-04 14:00:03.415825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_password_policy_request.py
+-rw-r--r--   0        0        0     4326 2024-04-04 14:00:03.419825 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_password_stage_request.py
+-rw-r--r--   0        0        0     2922 2024-04-04 14:00:03.423826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_permission_assign_request.py
+-rw-r--r--   0        0        0     2784 2024-04-04 14:00:03.427826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_plex_source_connection_request.py
+-rw-r--r--   0        0        0     5905 2024-04-04 14:00:03.431826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_plex_source_request.py
+-rw-r--r--   0        0        0     4286 2024-04-04 14:00:03.431826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_policy_binding_request.py
+-rw-r--r--   0        0        0     5023 2024-04-04 14:00:03.435826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_prompt_request.py
+-rw-r--r--   0        0        0     3406 2024-04-04 14:00:03.439826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_prompt_stage_request.py
+-rw-r--r--   0        0        0     6907 2024-04-04 14:00:03.443826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_proxy_provider_request.py
+-rw-r--r--   0        0        0     3495 2024-04-04 14:00:03.443826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_rac_property_mapping_request.py
+-rw-r--r--   0        0        0     4413 2024-04-04 14:00:03.451826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_rac_provider_request.py
+-rw-r--r--   0        0        0     4563 2024-04-04 14:00:03.455826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_radius_provider_request.py
+-rw-r--r--   0        0        0     3276 2024-04-04 14:00:03.459826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_reputation_policy_request.py
+-rw-r--r--   0        0        0     2565 2024-04-04 14:00:03.459826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_role_request.py
+-rw-r--r--   0        0        0     3901 2024-04-04 14:00:03.463826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_saml_property_mapping_request.py
+-rw-r--r--   0        0        0     7539 2024-04-04 14:00:03.463826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_saml_provider_request.py
+-rw-r--r--   0        0        0     8676 2024-04-04 14:00:03.467826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_saml_source_request.py
+-rw-r--r--   0        0        0     3364 2024-04-04 14:00:03.467826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_scim_mapping_request.py
+-rw-r--r--   0        0        0     3888 2024-04-04 14:00:03.471826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_scim_provider_request.py
+-rw-r--r--   0        0        0     3819 2024-04-04 14:00:03.475826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_scope_mapping_request.py
+-rw-r--r--   0        0        0     4590 2024-04-04 14:00:03.479826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_settings_request.py
+-rw-r--r--   0        0        0     2674 2024-04-04 14:00:03.475826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_sms_device_request.py
+-rw-r--r--   0        0        0     3562 2024-04-04 14:00:03.483826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_source_stage_request.py
+-rw-r--r--   0        0        0     2686 2024-04-04 14:00:03.483826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_static_device_request.py
+-rw-r--r--   0        0        0     2820 2024-04-04 14:00:03.491827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_tenant_request.py
+-rw-r--r--   0        0        0     4208 2024-04-04 14:00:03.495827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_token_request.py
+-rw-r--r--   0        0        0     2678 2024-04-04 14:00:03.487826 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_totp_device_request.py
+-rw-r--r--   0        0        0     3167 2024-04-04 14:00:03.499827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_delete_stage_request.py
+-rw-r--r--   0        0        0     4766 2024-04-04 14:00:03.499827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_login_stage_request.py
+-rw-r--r--   0        0        0     3167 2024-04-04 14:00:03.503827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_logout_stage_request.py
+-rw-r--r--   0        0        0     3109 2024-04-04 14:00:03.507827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_o_auth_source_connection_request.py
+-rw-r--r--   0        0        0     3934 2024-04-04 14:00:03.511827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_request.py
+-rw-r--r--   0        0        0     2733 2024-04-04 14:00:03.515827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_saml_source_connection_request.py
+-rw-r--r--   0        0        0     4450 2024-04-04 14:00:03.519827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_write_stage_request.py
+-rw-r--r--   0        0        0     2625 2024-04-04 14:00:03.519827 authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_web_authn_device_request.py
+-rw-r--r--   0        0        0     3548 2024-04-04 14:00:03.523827 authentik_client-2024.2.2.post1712239192/authentik_client/models/permission.py
+-rw-r--r--   0        0        0     2884 2024-04-04 14:00:03.527827 authentik_client-2024.2.2.post1712239192/authentik_client/models/permission_assign_request.py
+-rw-r--r--   0        0        0     4315 2024-04-04 14:00:03.531827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_authentication_challenge.py
+-rw-r--r--   0        0        0     2726 2024-04-04 14:00:03.531827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_authentication_challenge_response_request.py
+-rw-r--r--   0        0        0     7752 2024-04-04 14:00:03.535827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source.py
+-rw-r--r--   0        0        0     3265 2024-04-04 14:00:03.539827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source_connection.py
+-rw-r--r--   0        0        0     2719 2024-04-04 14:00:03.539827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source_connection_request.py
+-rw-r--r--   0        0        0     5760 2024-04-04 14:00:03.543827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source_request.py
+-rw-r--r--   0        0        0     2576 2024-04-04 14:00:03.547827 authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_token_redeem_request.py
+-rw-r--r--   0        0        0     4055 2024-04-04 14:00:03.551828 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy.py
+-rw-r--r--   0        0        0     5643 2024-04-04 14:00:03.551828 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_binding.py
+-rw-r--r--   0        0        0     4231 2024-04-04 14:00:03.555827 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_binding_request.py
+-rw-r--r--   0        0        0      711 2024-04-04 14:00:03.555827 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_engine_mode.py
+-rw-r--r--   0        0        0     2817 2024-04-04 14:00:03.559828 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_request.py
+-rw-r--r--   0        0        0     2583 2024-04-04 14:00:03.563828 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_test_request.py
+-rw-r--r--   0        0        0     3281 2024-04-04 14:00:03.563828 authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_test_result.py
+-rw-r--r--   0        0        0     4885 2024-04-04 14:00:03.567828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt.py
+-rw-r--r--   0        0        0     4649 2024-04-04 14:00:03.571828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_challenge.py
+-rw-r--r--   0        0        0     3325 2024-04-04 14:00:03.571828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_challenge_response_request.py
+-rw-r--r--   0        0        0     4927 2024-04-04 14:00:03.575828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_request.py
+-rw-r--r--   0        0        0     4321 2024-04-04 14:00:03.575828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_stage.py
+-rw-r--r--   0        0        0     3351 2024-04-04 14:00:03.579828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_stage_request.py
+-rw-r--r--   0        0        0     1185 2024-04-04 14:00:03.579828 authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_type_enum.py
+-rw-r--r--   0        0        0     4264 2024-04-04 14:00:03.583828 authentik_client-2024.2.2.post1712239192/authentik_client/models/property_mapping.py
+-rw-r--r--   0        0        0     2610 2024-04-04 14:00:03.587828 authentik_client-2024.2.2.post1712239192/authentik_client/models/property_mapping_preview.py
+-rw-r--r--   0        0        0     2744 2024-04-04 14:00:03.587828 authentik_client-2024.2.2.post1712239192/authentik_client/models/property_mapping_test_result.py
+-rw-r--r--   0        0        0      715 2024-04-04 14:00:03.591828 authentik_client-2024.2.2.post1712239192/authentik_client/models/protocol_enum.py
+-rw-r--r--   0        0        0     5722 2024-04-04 14:00:03.591828 authentik_client-2024.2.2.post1712239192/authentik_client/models/provider.py
+-rw-r--r--   0        0        0      713 2024-04-04 14:00:03.595828 authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_enum.py
+-rw-r--r--   0        0        0     1314 2024-04-04 14:00:03.595828 authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_model_enum.py
+-rw-r--r--   0        0        0     3397 2024-04-04 14:00:03.595828 authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_request.py
+-rw-r--r--   0        0        0     1009 2024-04-04 14:00:03.599828 authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_type_enum.py
+-rw-r--r--   0        0        0      754 2024-04-04 14:00:03.599828 authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_mode.py
+-rw-r--r--   0        0        0     7819 2024-04-04 14:00:03.599828 authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_outpost_config.py
+-rw-r--r--   0        0        0     9552 2024-04-04 14:00:03.603828 authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_provider.py
+-rw-r--r--   0        0        0     6828 2024-04-04 14:00:03.603828 authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_provider_request.py
+-rw-r--r--   0        0        0     4407 2024-04-04 14:00:03.607828 authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_property_mapping.py
+-rw-r--r--   0        0        0     3440 2024-04-04 14:00:03.607828 authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_property_mapping_request.py
+-rw-r--r--   0        0        0     6813 2024-04-04 14:00:03.611828 authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_provider.py
+-rw-r--r--   0        0        0     4351 2024-04-04 14:00:03.611828 authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_provider_request.py
+-rw-r--r--   0        0        0     3833 2024-04-04 14:00:03.615829 authentik_client-2024.2.2.post1712239192/authentik_client/models/radius_outpost_config.py
+-rw-r--r--   0        0        0     6924 2024-04-04 14:00:03.615829 authentik_client-2024.2.2.post1712239192/authentik_client/models/radius_provider.py
+-rw-r--r--   0        0        0     4501 2024-04-04 14:00:03.619829 authentik_client-2024.2.2.post1712239192/authentik_client/models/radius_provider_request.py
+-rw-r--r--   0        0        0     4184 2024-04-04 14:00:03.623829 authentik_client-2024.2.2.post1712239192/authentik_client/models/redirect_challenge.py
+-rw-r--r--   0        0        0     3642 2024-04-04 14:00:03.623829 authentik_client-2024.2.2.post1712239192/authentik_client/models/reputation.py
+-rw-r--r--   0        0        0     4516 2024-04-04 14:00:03.627829 authentik_client-2024.2.2.post1712239192/authentik_client/models/reputation_policy.py
+-rw-r--r--   0        0        0     3238 2024-04-04 14:00:03.627829 authentik_client-2024.2.2.post1712239192/authentik_client/models/reputation_policy_request.py
+-rw-r--r--   0        0        0      795 2024-04-04 14:00:03.631829 authentik_client-2024.2.2.post1712239192/authentik_client/models/resident_key_requirement_enum.py
+-rw-r--r--   0        0        0     2618 2024-04-04 14:00:03.631829 authentik_client-2024.2.2.post1712239192/authentik_client/models/role.py
+-rw-r--r--   0        0        0     3333 2024-04-04 14:00:03.635829 authentik_client-2024.2.2.post1712239192/authentik_client/models/role_assigned_object_permission.py
+-rw-r--r--   0        0        0     3293 2024-04-04 14:00:03.639829 authentik_client-2024.2.2.post1712239192/authentik_client/models/role_object_permission.py
+-rw-r--r--   0        0        0     2517 2024-04-04 14:00:03.639829 authentik_client-2024.2.2.post1712239192/authentik_client/models/role_request.py
+-rw-r--r--   0        0        0     2712 2024-04-04 14:00:03.643829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_metadata.py
+-rw-r--r--   0        0        0     4718 2024-04-04 14:00:03.647829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_property_mapping.py
+-rw-r--r--   0        0        0     3829 2024-04-04 14:00:03.651829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_property_mapping_request.py
+-rw-r--r--   0        0        0    11056 2024-04-04 14:00:03.651829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_provider.py
+-rw-r--r--   0        0        0     7460 2024-04-04 14:00:03.655829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_provider_request.py
+-rw-r--r--   0        0        0    10563 2024-04-04 14:00:03.659829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_source.py
+-rw-r--r--   0        0        0     8507 2024-04-04 14:00:03.663829 authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_source_request.py
+-rw-r--r--   0        0        0     4248 2024-04-04 14:00:03.663829 authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_mapping.py
+-rw-r--r--   0        0        0     3309 2024-04-04 14:00:03.667829 authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_mapping_request.py
+-rw-r--r--   0        0        0     5454 2024-04-04 14:00:03.671829 authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_provider.py
+-rw-r--r--   0        0        0     3802 2024-04-04 14:00:03.671829 authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_provider_request.py
+-rw-r--r--   0        0        0     3131 2024-04-04 14:00:03.675830 authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_sync_status.py
+-rw-r--r--   0        0        0     4629 2024-04-04 14:00:03.683830 authentik_client-2024.2.2.post1712239192/authentik_client/models/scope_mapping.py
+-rw-r--r--   0        0        0     3740 2024-04-04 14:00:03.687830 authentik_client-2024.2.2.post1712239192/authentik_client/models/scope_mapping_request.py
+-rw-r--r--   0        0        0     2738 2024-04-04 14:00:03.687830 authentik_client-2024.2.2.post1712239192/authentik_client/models/selectable_stage.py
+-rw-r--r--   0        0        0     3773 2024-04-04 14:00:03.691830 authentik_client-2024.2.2.post1712239192/authentik_client/models/service_connection.py
+-rw-r--r--   0        0        0     2776 2024-04-04 14:00:03.695830 authentik_client-2024.2.2.post1712239192/authentik_client/models/service_connection_request.py
+-rw-r--r--   0        0        0     2731 2024-04-04 14:00:03.695830 authentik_client-2024.2.2.post1712239192/authentik_client/models/service_connection_state.py
+-rw-r--r--   0        0        0     3178 2024-04-04 14:00:03.699830 authentik_client-2024.2.2.post1712239192/authentik_client/models/session_user.py
+-rw-r--r--   0        0        0     4441 2024-04-04 14:00:03.703830 authentik_client-2024.2.2.post1712239192/authentik_client/models/settings.py
+-rw-r--r--   0        0        0     4569 2024-04-04 14:00:03.703830 authentik_client-2024.2.2.post1712239192/authentik_client/models/settings_request.py
+-rw-r--r--   0        0        0      733 2024-04-04 14:00:03.707830 authentik_client-2024.2.2.post1712239192/authentik_client/models/severity_enum.py
+-rw-r--r--   0        0        0     4175 2024-04-04 14:00:03.715830 authentik_client-2024.2.2.post1712239192/authentik_client/models/shell_challenge.py
+-rw-r--r--   0        0        0     1492 2024-04-04 14:00:03.715830 authentik_client-2024.2.2.post1712239192/authentik_client/models/signature_algorithm_enum.py
+-rw-r--r--   0        0        0     2906 2024-04-04 14:00:03.679829 authentik_client-2024.2.2.post1712239192/authentik_client/models/sms_device.py
+-rw-r--r--   0        0        0     2619 2024-04-04 14:00:03.679829 authentik_client-2024.2.2.post1712239192/authentik_client/models/sms_device_request.py
+-rw-r--r--   0        0        0     6945 2024-04-04 14:00:03.719830 authentik_client-2024.2.2.post1712239192/authentik_client/models/source.py
+-rw-r--r--   0        0        0     4836 2024-04-04 14:00:03.723830 authentik_client-2024.2.2.post1712239192/authentik_client/models/source_request.py
+-rw-r--r--   0        0        0     4438 2024-04-04 14:00:03.723830 authentik_client-2024.2.2.post1712239192/authentik_client/models/source_stage.py
+-rw-r--r--   0        0        0     3507 2024-04-04 14:00:03.727830 authentik_client-2024.2.2.post1712239192/authentik_client/models/source_stage_request.py
+-rw-r--r--   0        0        0     5355 2024-04-04 14:00:03.731830 authentik_client-2024.2.2.post1712239192/authentik_client/models/source_type.py
+-rw-r--r--   0        0        0      714 2024-04-04 14:00:03.731830 authentik_client-2024.2.2.post1712239192/authentik_client/models/sp_binding_enum.py
+-rw-r--r--   0        0        0     4070 2024-04-04 14:00:03.735830 authentik_client-2024.2.2.post1712239192/authentik_client/models/stage.py
+-rw-r--r--   0        0        0     3437 2024-04-04 14:00:03.739830 authentik_client-2024.2.2.post1712239192/authentik_client/models/stage_prompt.py
+-rw-r--r--   0        0        0     3089 2024-04-04 14:00:03.739830 authentik_client-2024.2.2.post1712239192/authentik_client/models/stage_request.py
+-rw-r--r--   0        0        0     3385 2024-04-04 14:00:03.743831 authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device.py
+-rw-r--r--   0        0        0     2631 2024-04-04 14:00:03.747830 authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device_request.py
+-rw-r--r--   0        0        0     2546 2024-04-04 14:00:03.747830 authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device_token.py
+-rw-r--r--   0        0        0     2581 2024-04-04 14:00:03.751831 authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device_token_request.py
+-rw-r--r--   0        0        0      846 2024-04-04 14:00:03.751831 authentik_client-2024.2.2.post1712239192/authentik_client/models/sub_mode_enum.py
+-rw-r--r--   0        0        0     4463 2024-04-04 14:00:03.755831 authentik_client-2024.2.2.post1712239192/authentik_client/models/system_info.py
+-rw-r--r--   0        0        0     2934 2024-04-04 14:00:03.759831 authentik_client-2024.2.2.post1712239192/authentik_client/models/system_info_runtime.py
+-rw-r--r--   0        0        0     4286 2024-04-04 14:00:03.759831 authentik_client-2024.2.2.post1712239192/authentik_client/models/system_task.py
+-rw-r--r--   0        0        0      789 2024-04-04 14:00:03.763831 authentik_client-2024.2.2.post1712239192/authentik_client/models/system_task_status_enum.py
+-rw-r--r--   0        0        0     2872 2024-04-04 14:00:03.771831 authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant.py
+-rw-r--r--   0        0        0     2589 2024-04-04 14:00:03.771831 authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_admin_group_request_request.py
+-rw-r--r--   0        0        0     2705 2024-04-04 14:00:03.775831 authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_recovery_key_request_request.py
+-rw-r--r--   0        0        0     2599 2024-04-04 14:00:03.779831 authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_recovery_key_response.py
+-rw-r--r--   0        0        0     2765 2024-04-04 14:00:03.779831 authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_request.py
+-rw-r--r--   0        0        0     4591 2024-04-04 14:00:03.783831 authentik_client-2024.2.2.post1712239192/authentik_client/models/token.py
+-rw-r--r--   0        0        0     3987 2024-04-04 14:00:03.787831 authentik_client-2024.2.2.post1712239192/authentik_client/models/token_model.py
+-rw-r--r--   0        0        0     4118 2024-04-04 14:00:03.791831 authentik_client-2024.2.2.post1712239192/authentik_client/models/token_request.py
+-rw-r--r--   0        0        0     2521 2024-04-04 14:00:03.795831 authentik_client-2024.2.2.post1712239192/authentik_client/models/token_set_key_request.py
+-rw-r--r--   0        0        0     2494 2024-04-04 14:00:03.795831 authentik_client-2024.2.2.post1712239192/authentik_client/models/token_view.py
+-rw-r--r--   0        0        0     2724 2024-04-04 14:00:03.763831 authentik_client-2024.2.2.post1712239192/authentik_client/models/totp_device.py
+-rw-r--r--   0        0        0     2623 2024-04-04 14:00:03.767831 authentik_client-2024.2.2.post1712239192/authentik_client/models/totp_device_request.py
+-rw-r--r--   0        0        0     3389 2024-04-04 14:00:03.799831 authentik_client-2024.2.2.post1712239192/authentik_client/models/transaction_application_request.py
+-rw-r--r--   0        0        0     2595 2024-04-04 14:00:03.803831 authentik_client-2024.2.2.post1712239192/authentik_client/models/transaction_application_response.py
+-rw-r--r--   0        0        0     2936 2024-04-04 14:00:03.807832 authentik_client-2024.2.2.post1712239192/authentik_client/models/type_create.py
+-rw-r--r--   0        0        0      730 2024-04-04 14:00:03.807832 authentik_client-2024.2.2.post1712239192/authentik_client/models/ui_theme_enum.py
+-rw-r--r--   0        0        0     2808 2024-04-04 14:00:03.811832 authentik_client-2024.2.2.post1712239192/authentik_client/models/used_by.py
+-rw-r--r--   0        0        0      795 2024-04-04 14:00:03.811832 authentik_client-2024.2.2.post1712239192/authentik_client/models/used_by_action_enum.py
+-rw-r--r--   0        0        0     5226 2024-04-04 14:00:03.815832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user.py
+-rw-r--r--   0        0        0     2458 2024-04-04 14:00:03.819832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_account_request.py
+-rw-r--r--   0        0        0     4946 2024-04-04 14:00:03.823832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_assigned_object_permission.py
+-rw-r--r--   0        0        0     3617 2024-04-04 14:00:03.823832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_consent.py
+-rw-r--r--   0        0        0      811 2024-04-04 14:00:03.827832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_creation_mode_enum.py
+-rw-r--r--   0        0        0     4110 2024-04-04 14:00:03.827832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_delete_stage.py
+-rw-r--r--   0        0        0     3129 2024-04-04 14:00:03.831832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_delete_stage_request.py
+-rw-r--r--   0        0        0      735 2024-04-04 14:00:03.835832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_fields_enum.py
+-rw-r--r--   0        0        0     3909 2024-04-04 14:00:03.835832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_group.py
+-rw-r--r--   0        0        0     3193 2024-04-04 14:00:03.839832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_group_request.py
+-rw-r--r--   0        0        0     4334 2024-04-04 14:00:03.843832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_login_challenge.py
+-rw-r--r--   0        0        0     2805 2024-04-04 14:00:03.847832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_login_challenge_response_request.py
+-rw-r--r--   0        0        0     5631 2024-04-04 14:00:03.847832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_login_stage.py
+-rw-r--r--   0        0        0     4728 2024-04-04 14:00:03.851832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_login_stage_request.py
+-rw-r--r--   0        0        0     4110 2024-04-04 14:00:03.855832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_logout_stage.py
+-rw-r--r--   0        0        0     3129 2024-04-04 14:00:03.859832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_logout_stage_request.py
+-rw-r--r--   0        0        0      853 2024-04-04 14:00:03.859832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_matching_mode_enum.py
+-rw-r--r--   0        0        0     4160 2024-04-04 14:00:03.863832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_metrics.py
+-rw-r--r--   0        0        0     3188 2024-04-04 14:00:03.863832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_o_auth_source_connection.py
+-rw-r--r--   0        0        0     3054 2024-04-04 14:00:03.867833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_o_auth_source_connection_request.py
+-rw-r--r--   0        0        0     3293 2024-04-04 14:00:03.871832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_object_permission.py
+-rw-r--r--   0        0        0     2557 2024-04-04 14:00:03.871832 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_password_set_request.py
+-rw-r--r--   0        0        0     2491 2024-04-04 14:00:03.875833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_path.py
+-rw-r--r--   0        0        0     3872 2024-04-04 14:00:03.879833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_request.py
+-rw-r--r--   0        0        0     3107 2024-04-04 14:00:03.879833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_saml_source_connection.py
+-rw-r--r--   0        0        0     2668 2024-04-04 14:00:03.883833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_saml_source_connection_request.py
+-rw-r--r--   0        0        0     5465 2024-04-04 14:00:03.887833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_self.py
+-rw-r--r--   0        0        0     2629 2024-04-04 14:00:03.887833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_self_groups.py
+-rw-r--r--   0        0        0     3074 2024-04-04 14:00:03.891833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_service_account_request.py
+-rw-r--r--   0        0        0     2844 2024-04-04 14:00:03.895833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_service_account_response.py
+-rw-r--r--   0        0        0     2866 2024-04-04 14:00:03.895833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_setting.py
+-rw-r--r--   0        0        0     3245 2024-04-04 14:00:03.899833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_source_connection.py
+-rw-r--r--   0        0        0      817 2024-04-04 14:00:03.899833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_type_enum.py
+-rw-r--r--   0        0        0      777 2024-04-04 14:00:03.903833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_verification_enum.py
+-rw-r--r--   0        0        0     5382 2024-04-04 14:00:03.907833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_write_stage.py
+-rw-r--r--   0        0        0     4412 2024-04-04 14:00:03.907833 authentik_client-2024.2.2.post1712239192/authentik_client/models/user_write_stage_request.py
+-rw-r--r--   0        0        0     3197 2024-04-04 14:00:03.911833 authentik_client-2024.2.2.post1712239192/authentik_client/models/validation_error.py
+-rw-r--r--   0        0        0     3589 2024-04-04 14:00:03.915833 authentik_client-2024.2.2.post1712239192/authentik_client/models/version.py
+-rw-r--r--   0        0        0     2872 2024-04-04 14:00:03.919833 authentik_client-2024.2.2.post1712239192/authentik_client/models/web_authn_device.py
+-rw-r--r--   0        0        0     2577 2024-04-04 14:00:03.919833 authentik_client-2024.2.2.post1712239192/authentik_client/models/web_authn_device_request.py
+-rw-r--r--   0        0        0     2410 2024-04-04 14:00:03.923833 authentik_client-2024.2.2.post1712239192/authentik_client/models/workers.py
+-rw-r--r--   0        0        0        0 2024-04-04 14:00:05.103852 authentik_client-2024.2.2.post1712239192/authentik_client/py.typed
+-rw-r--r--   0        0        0     9196 2024-04-04 14:00:05.111852 authentik_client-2024.2.2.post1712239192/authentik_client/rest.py
+-rw-r--r--   0        0        0     1936 2024-04-04 14:00:05.099852 authentik_client-2024.2.2.post1712239192/pyproject.toml
+-rw-r--r--   0        0        0   140950 1970-01-01 00:00:00.000000 authentik_client-2024.2.2.post1712239192/PKG-INFO
```

### Comparing `authentik_client-2024.2.2.post1710845398/README.md` & `authentik_client-2024.2.2.post1712239192/README.md`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 # authentik-client
 Making authentication simple.
 
 This Python package is automatically generated by the [OpenAPI Generator](https://openapi-generator.tech) project:
 
 - API version: 2024.2.2
-- Package version: 2024.2.2-1710845398
-- Build package: org.openapitools.codegen.languages.PythonPydanticV1ClientCodegen
+- Package version: 2024.2.2-1712239192
+- Generator version: 7.4.0
+- Build package: org.openapitools.codegen.languages.PythonClientCodegen
 
 ## Requirements.
 
 Python 3.7+
 
 ## Installation & Usage
 ### pip install
@@ -46,15 +47,14 @@
 
 ## Getting Started
 
 Please follow the [installation procedure](#installation--usage) and then run the following:
 
 ```python
 
-import time
 import authentik_client
 from authentik_client.rest import ApiException
 from pprint import pprint
 
 # Defining the host is optional and defaults to http://localhost/api/v3
 # See configuration.py for a list of all supported configuration parameters.
 configuration = authentik_client.Configuration(
@@ -985,14 +985,16 @@
  - [LDAPSourceRequest](docs/LDAPSourceRequest.md)
  - [LDAPSyncStatus](docs/LDAPSyncStatus.md)
  - [License](docs/License.md)
  - [LicenseForecast](docs/LicenseForecast.md)
  - [LicenseRequest](docs/LicenseRequest.md)
  - [LicenseSummary](docs/LicenseSummary.md)
  - [Link](docs/Link.md)
+ - [LogEvent](docs/LogEvent.md)
+ - [LogLevelEnum](docs/LogLevelEnum.md)
  - [LoginChallengeTypes](docs/LoginChallengeTypes.md)
  - [LoginMetrics](docs/LoginMetrics.md)
  - [LoginSource](docs/LoginSource.md)
  - [Metadata](docs/Metadata.md)
  - [ModelEnum](docs/ModelEnum.md)
  - [ModelRequest](docs/ModelRequest.md)
  - [NameIdPolicyEnum](docs/NameIdPolicyEnum.md)
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/__init__.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
-__version__ = "2024.2.2-1710845398"
+__version__ = "2024.2.2-1712239192"
 
 # import apis into sdk package
 from authentik_client.api.admin_api import AdminApi
 from authentik_client.api.authenticators_api import AuthenticatorsApi
 from authentik_client.api.core_api import CoreApi
 from authentik_client.api.crypto_api import CryptoApi
 from authentik_client.api.enterprise_api import EnterpriseApi
@@ -220,14 +220,16 @@
 from authentik_client.models.ldap_source_request import LDAPSourceRequest
 from authentik_client.models.ldap_sync_status import LDAPSyncStatus
 from authentik_client.models.license import License
 from authentik_client.models.license_forecast import LicenseForecast
 from authentik_client.models.license_request import LicenseRequest
 from authentik_client.models.license_summary import LicenseSummary
 from authentik_client.models.link import Link
+from authentik_client.models.log_event import LogEvent
+from authentik_client.models.log_level_enum import LogLevelEnum
 from authentik_client.models.login_challenge_types import LoginChallengeTypes
 from authentik_client.models.login_metrics import LoginMetrics
 from authentik_client.models.login_source import LoginSource
 from authentik_client.models.metadata import Metadata
 from authentik_client.models.model_enum import ModelEnum
 from authentik_client.models.model_request import ModelRequest
 from authentik_client.models.name_id_policy_enum import NameIdPolicyEnum
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/api/__init__.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/api/__init__.py`

 * *Files identical despite different names*

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/api_client.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/api_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,32 +9,41 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
-import atexit
 import datetime
 from dateutil.parser import parse
+from enum import Enum
 import json
 import mimetypes
-from multiprocessing.pool import ThreadPool
 import os
 import re
 import tempfile
 
 from urllib.parse import quote
+from typing import Tuple, Optional, List, Dict
 
 from authentik_client.configuration import Configuration
-from authentik_client.api_response import ApiResponse
+from authentik_client.api_response import ApiResponse, T as ApiResponseT
 import authentik_client.models
 from authentik_client import rest
-from authentik_client.exceptions import ApiValueError, ApiException
+from authentik_client.exceptions import (
+    ApiValueError,
+    ApiException,
+    BadRequestException,
+    UnauthorizedException,
+    ForbiddenException,
+    NotFoundException,
+    ServiceException
+)
 
+RequestSerialized = Tuple[str, str, Dict[str, str], Optional[str], List[str]]
 
 class ApiClient:
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
@@ -42,16 +51,14 @@
 
     :param configuration: .Configuration object for this client
     :param header_name: a header to pass when making calls to the API.
     :param header_value: a header value to pass when making calls to
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
-    :param pool_threads: The number of threads to use for async requests
-        to the API. More threads means more concurrent API requests.
     """
 
     PRIMITIVE_TYPES = (float, bool, bytes, str, int)
     NATIVE_TYPES_MAPPING = {
         'int': int,
         'long': int, # TODO remove as only py3 is supported?
         'float': float,
@@ -59,54 +66,40 @@
         'bool': bool,
         'date': datetime.date,
         'datetime': datetime.datetime,
         'object': object,
     }
     _pool = None
 
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None, pool_threads=1) -> None:
+    def __init__(
+        self,
+        configuration=None,
+        header_name=None,
+        header_value=None,
+        cookie=None
+    ) -> None:
         # use default configuration if none is provided
         if configuration is None:
             configuration = Configuration.get_default()
         self.configuration = configuration
-        self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/2024.2.2-1710845398/python'
+        self.user_agent = 'OpenAPI-Generator/2024.2.2-1712239192/python'
         self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
-        self.close()
-
-    def close(self):
-        if self._pool:
-            self._pool.close()
-            self._pool.join()
-            self._pool = None
-            if hasattr(atexit, 'unregister'):
-                atexit.unregister(self.close)
-
-    @property
-    def pool(self):
-        """Create thread pool on first request
-         avoids instantiating unused threadpool for blocking clients.
-        """
-        if self._pool is None:
-            atexit.register(self.close)
-            self._pool = ThreadPool(self.pool_threads)
-        return self._pool
+        pass
 
     @property
     def user_agent(self):
         """User agent for this API client"""
         return self.default_headers['User-Agent']
 
     @user_agent.setter
@@ -139,59 +132,98 @@
 
         It stores default ApiClient.
 
         :param default: object of ApiClient.
         """
         cls._default = default
 
-    def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            files=None, response_types_map=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None, _host=None,
-            _request_auth=None):
+    def param_serialize(
+        self,
+        method,
+        resource_path,
+        path_params=None,
+        query_params=None,
+        header_params=None,
+        body=None,
+        post_params=None,
+        files=None, auth_settings=None,
+        collection_formats=None,
+        _host=None,
+        _request_auth=None
+    ) -> RequestSerialized:
+
+        """Builds the HTTP request params needed by the request.
+        :param method: Method to call.
+        :param resource_path: Path to method endpoint.
+        :param path_params: Path parameters in the url.
+        :param query_params: Query parameters in the url.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param auth_settings list: Auth Settings names for the request.
+        :param files dict: key -> filename, value -> filepath,
+            for `multipart/form-data`.
+        :param collection_formats: dict of collection formats for path, query,
+            header, and post parameters.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :return: tuple of form (path, http_method, query_params, header_params,
+            body, post_params, files)
+        """
 
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
             header_params['Cookie'] = self.cookie
         if header_params:
             header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
+            header_params = dict(
+                self.parameters_to_tuples(header_params,collection_formats)
+            )
 
         # path parameters
         if path_params:
             path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
+            path_params = self.parameters_to_tuples(
+                path_params,
+                collection_formats
+            )
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
                     '{%s}' % k,
                     quote(str(v), safe=config.safe_chars_for_path_param)
                 )
 
         # post parameters
         if post_params or files:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
+            post_params = self.parameters_to_tuples(
+                post_params,
+                collection_formats
+            )
             post_params.extend(self.files_parameters(files))
 
         # auth setting
         self.update_params_for_auth(
-            header_params, query_params, auth_settings,
-            resource_path, method, body,
-            request_auth=_request_auth)
+            header_params,
+            query_params,
+            auth_settings,
+            resource_path,
+            method,
+            body,
+            request_auth=_request_auth
+        )
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
         # request url
         if _host is None:
@@ -199,67 +231,107 @@
         else:
             # use server/host defined in path or operation instead
             url = _host + resource_path
 
         # query parameters
         if query_params:
             query_params = self.sanitize_for_serialization(query_params)
-            url_query = self.parameters_to_url_query(query_params,
-                                                     collection_formats)
+            url_query = self.parameters_to_url_query(
+                query_params,
+                collection_formats
+            )
             url += "?" + url_query
 
+        return method, url, header_params, body, post_params
+
+
+    def call_api(
+        self,
+        method,
+        url,
+        header_params=None,
+        body=None,
+        post_params=None,
+        _request_timeout=None
+    ) -> rest.RESTResponse:
+        """Makes the HTTP request (synchronous)
+        :param method: Method to call.
+        :param url: Path to method endpoint.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param _request_timeout: timeout setting for this request.
+        :return: RESTResponse
+        """
+
         try:
             # perform request and return response
-            response_data = self.request(
+            response_data = self.rest_client.request(
                 method, url,
-                query_params=query_params,
                 headers=header_params,
-                post_params=post_params, body=body,
-                _preload_content=_preload_content,
-                _request_timeout=_request_timeout)
+                body=body, post_params=post_params,
+                _request_timeout=_request_timeout
+            )
+
         except ApiException as e:
-            if e.body:
-                e.body = e.body.decode('utf-8')
             raise e
 
-        self.last_response = response_data
+        return response_data
 
-        return_data = None # assuming deserialization is not needed
-        # data needs deserialization or returns HTTP data (deserialized) only
-        if _preload_content or _return_http_data_only:
-          response_type = response_types_map.get(str(response_data.status), None)
-          if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
-              # if not found, look for '1XX', '2XX', etc.
-              response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)
-
-          if response_type == "bytearray":
-              response_data.data = response_data.data
-          else:
-              match = None
-              content_type = response_data.getheader('content-type')
-              if content_type is not None:
-                  match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
-              encoding = match.group(1) if match else "utf-8"
-              response_data.data = response_data.data.decode(encoding)
-
-          # deserialize response data
-          if response_type == "bytearray":
-              return_data = response_data.data
-          elif response_type:
-              return_data = self.deserialize(response_data, response_type)
-          else:
-              return_data = None
+    def response_deserialize(
+        self,
+        response_data: rest.RESTResponse,
+        response_types_map: Optional[Dict[str, ApiResponseT]]=None
+    ) -> ApiResponse[ApiResponseT]:
+        """Deserializes response into an object.
+        :param response_data: RESTResponse object to be deserialized.
+        :param response_types_map: dict of response types.
+        :return: ApiResponse
+        """
+
+        msg = "RESTResponse.read() must be called before passing it to response_deserialize()"
+        assert response_data.data is not None, msg
+
+        response_type = response_types_map.get(str(response_data.status), None)
+        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
+            # if not found, look for '1XX', '2XX', etc.
+            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)
+
+        # deserialize response data
+        response_text = None
+        return_data = None
+        try:
+            if response_type == "bytearray":
+                return_data = response_data.data
+            elif response_type == "file":
+                return_data = self.__deserialize_file(response_data)
+            elif response_type is not None:
+                match = None
+                content_type = response_data.getheader('content-type')
+                if content_type is not None:
+                    match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+                encoding = match.group(1) if match else "utf-8"
+                response_text = response_data.data.decode(encoding)
+                return_data = self.deserialize(response_text, response_type)
+        finally:
+            if not 200 <= response_data.status <= 299:
+                raise ApiException.from_response(
+                    http_resp=response_data,
+                    body=response_text,
+                    data=return_data,
+                )
 
-        if _return_http_data_only:
-            return return_data
-        else:
-            return ApiResponse(status_code = response_data.status,
-                           data = return_data,
-                           headers = response_data.getheaders(),
-                           raw_data = response_data.data)
+        return ApiResponse(
+            status_code = response_data.status,
+            data = return_data,
+            headers = response_data.getheaders(),
+            raw_data = response_data.data
+        )
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -272,54 +344,54 @@
         :return: The serialized form of data.
         """
         if obj is None:
             return None
         elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
         elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
+            return [
+                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
+            ]
         elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
+            return tuple(
+                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
+            )
         elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
 
-        if isinstance(obj, dict):
+        elif isinstance(obj, dict):
             obj_dict = obj
         else:
             # Convert model obj to dict except
             # attributes `openapi_types`, `attribute_map`
             # and attributes which value is not None.
             # Convert attribute name to json key in
             # model definition for request.
             obj_dict = obj.to_dict()
 
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in obj_dict.items()}
+        return {
+            key: self.sanitize_for_serialization(val)
+            for key, val in obj_dict.items()
+        }
 
-    def deserialize(self, response, response_type):
+    def deserialize(self, response_text, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
 
         :return: deserialized object.
         """
-        # handle file downloading
-        # save response body into a tmp file and return the instance
-        if response_type == "file":
-            return self.__deserialize_file(response)
 
         # fetch data from response object
         try:
-            data = json.loads(response.data)
+            data = json.loads(response_text)
         except ValueError:
-            data = response.data
+            data = response_text
 
         return self.__deserialize(data, response_type)
 
     def __deserialize(self, data, klass):
         """Deserializes dict, list, str into an object.
 
         :param data: dict, list or str.
@@ -328,20 +400,24 @@
         :return: object.
         """
         if data is None:
             return None
 
         if isinstance(klass, str):
             if klass.startswith('List['):
-                sub_kls = re.match(r'List\[(.*)]', klass).group(1)
+                m = re.match(r'List\[(.*)]', klass)
+                assert m is not None, "Malformed List type definition"
+                sub_kls = m.group(1)
                 return [self.__deserialize(sub_data, sub_kls)
                         for sub_data in data]
 
             if klass.startswith('Dict['):
-                sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
+                m = re.match(r'Dict\[([^,]*), (.*)]', klass)
+                assert m is not None, "Malformed Dict type definition"
+                sub_kls = m.group(2)
                 return {k: self.__deserialize(v, sub_kls)
                         for k, v in data.items()}
 
             # convert str to class
             if klass in self.NATIVE_TYPES_MAPPING:
                 klass = self.NATIVE_TYPES_MAPPING[klass]
             else:
@@ -351,158 +427,30 @@
             return self.__deserialize_primitive(data, klass)
         elif klass == object:
             return self.__deserialize_object(data)
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datetime(data)
+        elif issubclass(klass, Enum):
+            return self.__deserialize_enum(data, klass)
         else:
             return self.__deserialize_model(data, klass)
 
-    def call_api(self, resource_path, method,
-                 path_params=None, query_params=None, header_params=None,
-                 body=None, post_params=None, files=None,
-                 response_types_map=None, auth_settings=None,
-                 async_req=None, _return_http_data_only=None,
-                 collection_formats=None, _preload_content=True,
-                 _request_timeout=None, _host=None, _request_auth=None):
-        """Makes the HTTP request (synchronous) and returns deserialized data.
-
-        To make an async_req request, set the async_req parameter.
-
-        :param resource_path: Path to method endpoint.
-        :param method: Method to call.
-        :param path_params: Path parameters in the url.
-        :param query_params: Query parameters in the url.
-        :param header_params: Header parameters to be
-            placed in the request header.
-        :param body: Request body.
-        :param post_params dict: Request post form parameters,
-            for `application/x-www-form-urlencoded`, `multipart/form-data`.
-        :param auth_settings list: Auth Settings names for the request.
-        :param response: Response data type.
-        :param files dict: key -> filename, value -> filepath,
-            for `multipart/form-data`.
-        :param async_req bool: execute request asynchronously
-        :param _return_http_data_only: response data instead of ApiResponse
-                                       object with status code, headers, etc
-        :param _preload_content: if False, the ApiResponse.data will
-                                 be set to none and raw_data will store the
-                                 HTTP response body without reading/decoding.
-                                 Default is True.
-        :param collection_formats: dict of collection formats for path, query,
-            header, and post parameters.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the authentication
-                              in the spec for a single request.
-        :type _request_token: dict, optional
-        :return:
-            If async_req parameter is True,
-            the request will be called asynchronously.
-            The method will return the request thread.
-            If parameter async_req is False or missing,
-            then the method will return the response directly.
-        """
-        args = (
-            resource_path,
-            method,
-            path_params,
-            query_params,
-            header_params,
-            body,
-            post_params,
-            files,
-            response_types_map,
-            auth_settings,
-            _return_http_data_only,
-            collection_formats,
-            _preload_content,
-            _request_timeout,
-            _host,
-            _request_auth,
-        )
-        if not async_req:
-            return self.__call_api(*args)
-
-        return self.pool.apply_async(self.__call_api, args)
-
-    def request(self, method, url, query_params=None, headers=None,
-                post_params=None, body=None, _preload_content=True,
-                _request_timeout=None):
-        """Makes the HTTP request using RESTClient."""
-        if method == "GET":
-            return self.rest_client.get_request(url,
-                                        query_params=query_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        headers=headers)
-        elif method == "HEAD":
-            return self.rest_client.head_request(url,
-                                         query_params=query_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         headers=headers)
-        elif method == "OPTIONS":
-            return self.rest_client.options_request(url,
-                                            query_params=query_params,
-                                            headers=headers,
-                                            _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout)
-        elif method == "POST":
-            return self.rest_client.post_request(url,
-                                         query_params=query_params,
-                                         headers=headers,
-                                         post_params=post_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         body=body)
-        elif method == "PUT":
-            return self.rest_client.put_request(url,
-                                        query_params=query_params,
-                                        headers=headers,
-                                        post_params=post_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        body=body)
-        elif method == "PATCH":
-            return self.rest_client.patch_request(url,
-                                          query_params=query_params,
-                                          headers=headers,
-                                          post_params=post_params,
-                                          _preload_content=_preload_content,
-                                          _request_timeout=_request_timeout,
-                                          body=body)
-        elif method == "DELETE":
-            return self.rest_client.delete_request(url,
-                                           query_params=query_params,
-                                           headers=headers,
-                                           _preload_content=_preload_content,
-                                           _request_timeout=_request_timeout,
-                                           body=body)
-        else:
-            raise ApiValueError(
-                "http method must be `GET`, `HEAD`, `OPTIONS`,"
-                " `POST`, `PATCH`, `PUT` or `DELETE`."
-            )
-
     def parameters_to_tuples(self, params, collection_formats):
         """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
-        new_params = []
+        new_params: List[Tuple[str, str]] = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
+        for k, v in params.items() if isinstance(params, dict) else params:
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
                     new_params.extend((k, value) for value in v)
                 else:
                     if collection_format == 'ssv':
                         delimiter = ' '
@@ -521,18 +469,18 @@
     def parameters_to_url_query(self, params, collection_formats):
         """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: URL query string (e.g. a=Hello%20World&b=123)
         """
-        new_params = []
+        new_params: List[Tuple[str, str]] = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
+        for k, v in params.items() if isinstance(params, dict) else params:
             if isinstance(v, bool):
                 v = str(v).lower()
             if isinstance(v, (int, float)):
                 v = str(v)
             if isinstance(v, dict):
                 v = json.dumps(v)
 
@@ -546,15 +494,16 @@
                     elif collection_format == 'tsv':
                         delimiter = '\t'
                     elif collection_format == 'pipes':
                         delimiter = '|'
                     else:  # csv is the default
                         delimiter = ','
                     new_params.append(
-                        (k, delimiter.join(quote(str(value)) for value in v)))
+                        (k, delimiter.join(quote(str(value)) for value in v))
+                    )
             else:
                 new_params.append((k, quote(str(v))))
 
         return "&".join(["=".join(map(str, item)) for item in new_params])
 
     def files_parameters(self, files=None):
         """Builds form parameters.
@@ -569,29 +518,32 @@
                 if not v:
                     continue
                 file_names = v if type(v) is list else [v]
                 for n in file_names:
                     with open(n, 'rb') as f:
                         filename = os.path.basename(f.name)
                         filedata = f.read()
-                        mimetype = (mimetypes.guess_type(filename)[0] or
-                                    'application/octet-stream')
+                        mimetype = (
+                            mimetypes.guess_type(filename)[0]
+                            or 'application/octet-stream'
+                        )
                         params.append(
-                            tuple([k, tuple([filename, filedata, mimetype])]))
+                            tuple([k, tuple([filename, filedata, mimetype])])
+                        )
 
         return params
 
-    def select_header_accept(self, accepts):
+    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
         """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
         if not accepts:
-            return
+            return None
 
         for accept in accepts:
             if re.search('json', accept, re.IGNORECASE):
                 return accept
 
         return accepts[0]
 
@@ -606,17 +558,24 @@
 
         for content_type in content_types:
             if re.search('json', content_type, re.IGNORECASE):
                 return content_type
 
         return content_types[0]
 
-    def update_params_for_auth(self, headers, queries, auth_settings,
-                               resource_path, method, body,
-                               request_auth=None):
+    def update_params_for_auth(
+        self,
+        headers,
+        queries,
+        auth_settings,
+        resource_path,
+        method,
+        body,
+        request_auth=None
+    ) -> None:
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
@@ -625,29 +584,44 @@
         :param request_auth: if set, the provided settings will
                              override the token in the configuration.
         """
         if not auth_settings:
             return
 
         if request_auth:
-            self._apply_auth_params(headers, queries,
-                                    resource_path, method, body,
-                                    request_auth)
-            return
-
-        for auth in auth_settings:
-            auth_setting = self.configuration.auth_settings().get(auth)
-            if auth_setting:
-                self._apply_auth_params(headers, queries,
-                                        resource_path, method, body,
-                                        auth_setting)
-
-    def _apply_auth_params(self, headers, queries,
-                           resource_path, method, body,
-                           auth_setting):
+            self._apply_auth_params(
+                headers,
+                queries,
+                resource_path,
+                method,
+                body,
+                request_auth
+            )
+        else:
+            for auth in auth_settings:
+                auth_setting = self.configuration.auth_settings().get(auth)
+                if auth_setting:
+                    self._apply_auth_params(
+                        headers,
+                        queries,
+                        resource_path,
+                        method,
+                        body,
+                        auth_setting
+                    )
+
+    def _apply_auth_params(
+        self,
+        headers,
+        queries,
+        resource_path,
+        method,
+        body,
+        auth_setting
+    ) -> None:
         """Updates the request parameters based on a single auth_setting
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
         :body: A object representing the body of the HTTP request.
@@ -668,25 +642,32 @@
 
     def __deserialize_file(self, response):
         """Deserializes body to file
 
         Saves response body into a file in a temporary folder,
         using the filename from the `Content-Disposition` header if provided.
 
+        handle file downloading
+        save response body into a tmp file and return the instance
+
         :param response:  RESTResponse.
         :return: file path.
         """
         fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
         os.close(fd)
         os.remove(path)
 
         content_disposition = response.getheader("Content-Disposition")
         if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
+            m = re.search(
+                r'filename=[\'"]?([^\'"\s]+)[\'"]?',
+                content_disposition
+            )
+            assert m is not None, "Unexpected 'content-disposition' header value"
+            filename = m.group(1)
             path = os.path.join(os.path.dirname(path), filename)
 
         with open(path, "wb") as f:
             f.write(response.data)
 
         return path
 
@@ -745,14 +726,32 @@
                 status=0,
                 reason=(
                     "Failed to parse `{0}` as datetime object"
                     .format(string)
                 )
             )
 
+    def __deserialize_enum(self, data, klass):
+        """Deserializes primitive type to enum.
+
+        :param data: primitive type.
+        :param klass: class literal.
+        :return: enum value.
+        """
+        try:
+            return klass(data)
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason=(
+                    "Failed to parse `{0}` as `{1}`"
+                    .format(data, klass)
+                )
+            )
+
     def __deserialize_model(self, data, klass):
         """Deserializes list or dict to model.
 
         :param data: dict, list.
         :param klass: class literal.
         :return: model object.
         """
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/configuration.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/configuration.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,16 +11,18 @@
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 import copy
 import logging
+from logging import FileHandler
 import multiprocessing
 import sys
+from typing import Optional
 import urllib3
 
 import http.client as httplib
 
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
     'multipleOf', 'maximum', 'exclusiveMaximum',
     'minimum', 'exclusiveMinimum', 'maxLength',
@@ -132,15 +134,15 @@
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         self.logger_format = '%(asctime)s %(levelname)s %(message)s'
         """Log format
         """
         self.logger_stream_handler = None
         """Log stream handler
         """
-        self.logger_file_handler = None
+        self.logger_file_handler: Optional[FileHandler] = None
         """Log file handler
         """
         self.logger_file = None
         """Debug file location
         """
         self.debug = False
         """Debug switch
@@ -172,15 +174,15 @@
         """urllib3 connection pool's maximum number of connections saved
            per pool. urllib3 uses 1 connection as default value, but this is
            not the best value when you are making a lot of possibly parallel
            requests to the same host, which is often the case here.
            cpu_count * 5 is used as default value to increase performance.
         """
 
-        self.proxy = None
+        self.proxy: Optional[str] = None
         """Proxy URL
         """
         self.proxy_headers = None
         """Proxy headers
         """
         self.safe_chars_for_path_param = ''
         """Safe chars for path_param
@@ -394,15 +396,15 @@
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
                "Version of the API: 2024.2.2\n"\
-               "SDK Package Version: 2024.2.2-1710845398".\
+               "SDK Package Version: 2024.2.2-1712239192".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/exceptions.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/exceptions.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,14 +8,16 @@
     The version of the OpenAPI document: 2024.2.2
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Optional
+from typing_extensions import Self
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
 
 
 class ApiTypeError(OpenApiException, TypeError):
     def __init__(self, msg, path_to_item=None, valid_classes=None,
@@ -98,66 +100,97 @@
         if path_to_item:
             full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
         super(ApiKeyError, self).__init__(full_msg)
 
 
 class ApiException(OpenApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    def __init__(
+        self, 
+        status=None, 
+        reason=None, 
+        http_resp=None,
+        *,
+        body: Optional[str] = None,
+        data: Optional[Any] = None,
+    ) -> None:
+        self.status = status
+        self.reason = reason
+        self.body = body
+        self.data = data
+        self.headers = None
+
         if http_resp:
-            self.status = http_resp.status
-            self.reason = http_resp.reason
-            self.body = http_resp.data
+            if self.status is None:
+                self.status = http_resp.status
+            if self.reason is None:
+                self.reason = http_resp.reason
+            if self.body is None:
+                try:
+                    self.body = http_resp.data.decode('utf-8')
+                except Exception:
+                    pass
             self.headers = http_resp.getheaders()
-        else:
-            self.status = status
-            self.reason = reason
-            self.body = None
-            self.headers = None
+
+    @classmethod
+    def from_response(
+        cls, 
+        *, 
+        http_resp, 
+        body: Optional[str], 
+        data: Optional[Any],
+    ) -> Self:
+        if http_resp.status == 400:
+            raise BadRequestException(http_resp=http_resp, body=body, data=data)
+
+        if http_resp.status == 401:
+            raise UnauthorizedException(http_resp=http_resp, body=body, data=data)
+
+        if http_resp.status == 403:
+            raise ForbiddenException(http_resp=http_resp, body=body, data=data)
+
+        if http_resp.status == 404:
+            raise NotFoundException(http_resp=http_resp, body=body, data=data)
+
+        if 500 <= http_resp.status <= 599:
+            raise ServiceException(http_resp=http_resp, body=body, data=data)
+        raise ApiException(http_resp=http_resp, body=body, data=data)
 
     def __str__(self):
         """Custom error messages for exception"""
         error_message = "({0})\n"\
                         "Reason: {1}\n".format(self.status, self.reason)
         if self.headers:
             error_message += "HTTP response headers: {0}\n".format(
                 self.headers)
 
-        if self.body:
-            error_message += "HTTP response body: {0}\n".format(self.body)
+        if self.data or self.body:
+            error_message += "HTTP response body: {0}\n".format(self.data or self.body)
 
         return error_message
 
+
 class BadRequestException(ApiException):
+    pass
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(BadRequestException, self).__init__(status, reason, http_resp)
 
 class NotFoundException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(NotFoundException, self).__init__(status, reason, http_resp)
+    pass
 
 
 class UnauthorizedException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(UnauthorizedException, self).__init__(status, reason, http_resp)
+    pass
 
 
 class ForbiddenException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(ForbiddenException, self).__init__(status, reason, http_resp)
+    pass
 
 
 class ServiceException(ApiException):
-
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(ServiceException, self).__init__(status, reason, http_resp)
+    pass
 
 
 def render_path(path_to_item):
     """Returns a string representation of a path"""
     result = ""
     for pth in path_to_item:
         if isinstance(pth, int):
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/__init__.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -184,14 +184,16 @@
 from authentik_client.models.ldap_source_request import LDAPSourceRequest
 from authentik_client.models.ldap_sync_status import LDAPSyncStatus
 from authentik_client.models.license import License
 from authentik_client.models.license_forecast import LicenseForecast
 from authentik_client.models.license_request import LicenseRequest
 from authentik_client.models.license_summary import LicenseSummary
 from authentik_client.models.link import Link
+from authentik_client.models.log_event import LogEvent
+from authentik_client.models.log_level_enum import LogLevelEnum
 from authentik_client.models.login_challenge_types import LoginChallengeTypes
 from authentik_client.models.login_metrics import LoginMetrics
 from authentik_client.models.login_source import LoginSource
 from authentik_client.models.metadata import Metadata
 from authentik_client.models.model_enum import ModelEnum
 from authentik_client.models.model_request import ModelRequest
 from authentik_client.models.name_id_policy_enum import NameIdPolicyEnum
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/access_denied_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_authentication_challenge.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,93 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AccessDeniedChallenge(BaseModel):
-    """
-    Challenge when a flow's active stage calls `stage_invalid()`.  # noqa: E501
+class PlexAuthenticationChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    Challenge shown to the user in identification stage
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-access-denied'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    error_message: Optional[StrictStr] = None
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "error_message"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-source-plex'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    client_id: StrictStr
+    slug: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "client_id", "slug"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AccessDeniedChallenge:
-        """Create an instance of AccessDeniedChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PlexAuthenticationChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AccessDeniedChallenge:
-        """Create an instance of AccessDeniedChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PlexAuthenticationChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AccessDeniedChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AccessDeniedChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-access-denied',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-source-plex',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
-            "pending_user": obj.get("pending_user"),
-            "pending_user_avatar": obj.get("pending_user_avatar"),
-            "error_message": obj.get("error_message")
+            "client_id": obj.get("client_id"),
+            "slug": obj.get("slug")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/app.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/install_id.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,61 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class App(BaseModel):
-    """
-    Serialize Application info  # noqa: E501
+class InstallID(BaseModel):
     """
-    name: StrictStr = Field(...)
-    label: StrictStr = Field(...)
-    __properties = ["name", "label"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    InstallID
+    """ # noqa: E501
+    install_id: StrictStr
+    __properties: ClassVar[List[str]] = ["install_id"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> App:
-        """Create an instance of App from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of InstallID from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> App:
-        """Create an instance of App from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of InstallID from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return App.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = App.parse_obj({
-            "name": obj.get("name"),
-            "label": obj.get("label")
+        _obj = cls.model_validate({
+            "install_id": obj.get("install_id")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/app_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/app_enum.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AppEnum(str, Enum):
     """
     AppEnum
     """
 
@@ -81,12 +78,12 @@
     AUTHENTIK_DOT_ENTERPRISE = 'authentik.enterprise'
     AUTHENTIK_DOT_ENTERPRISE_DOT_AUDIT = 'authentik.enterprise.audit'
     AUTHENTIK_DOT_ENTERPRISE_DOT_PROVIDERS_DOT_RAC = 'authentik.enterprise.providers.rac'
     AUTHENTIK_DOT_ENTERPRISE_DOT_STAGES_DOT_SOURCE = 'authentik.enterprise.stages.source'
     AUTHENTIK_DOT_EVENTS = 'authentik.events'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AppEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AppEnum from a JSON string"""
-        return AppEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/apple_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/email_challenge_response_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, constr
-
-class AppleChallengeResponseRequest(BaseModel):
-    """
-    Pseudo class for apple response  # noqa: E501
+class EmailChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-source-oauth-apple'
-    __properties = ["component"]
+    Email challenge resposen. No fields. This challenge is always declared invalid to give the user a chance to retry
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-email'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AppleChallengeResponseRequest:
-        """Create an instance of AppleChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of EmailChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AppleChallengeResponseRequest:
-        """Create an instance of AppleChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of EmailChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AppleChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AppleChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-source-oauth-apple'
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-email'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/apple_login_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/shell_challenge.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,95 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AppleLoginChallenge(BaseModel):
-    """
-    Special challenge for apple-native authentication flow, which happens on the client.  # noqa: E501
+class ShellChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    challenge type to render HTML as-is
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-source-oauth-apple'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    client_id: StrictStr = Field(...)
-    scope: StrictStr = Field(...)
-    redirect_uri: StrictStr = Field(...)
-    state: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "client_id", "scope", "redirect_uri", "state"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'xak-flow-shell'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    body: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "body"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AppleLoginChallenge:
-        """Create an instance of AppleLoginChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ShellChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AppleLoginChallenge:
-        """Create an instance of AppleLoginChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ShellChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AppleLoginChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AppleLoginChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-source-oauth-apple',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'xak-flow-shell',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
-            "client_id": obj.get("client_id"),
-            "scope": obj.get("scope"),
-            "redirect_uri": obj.get("redirect_uri"),
-            "state": obj.get("state")
+            "body": obj.get("body")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/application.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_sms_stage_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,126 +14,123 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.auth_type_enum import AuthTypeEnum
+from authentik_client.models.flow_set_request import FlowSetRequest
+from authentik_client.models.provider_enum import ProviderEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.provider import Provider
-
-class Application(BaseModel):
-    """
-    Application Serializer  # noqa: E501
+class PatchedAuthenticatorSMSStageRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(..., description="Application's display Name.")
-    slug: constr(strict=True, max_length=50) = Field(..., description="Internal application name, used in URLs.")
-    provider: Optional[StrictInt] = None
-    provider_obj: Provider = Field(...)
-    backchannel_providers: Optional[conlist(StrictInt)] = None
-    backchannel_providers_obj: conlist(Provider) = Field(...)
-    launch_url: Optional[StrictStr] = Field(..., description="Allow formatting of launch URL")
-    open_in_new_tab: Optional[StrictBool] = Field(None, description="Open launch URL in a new browser tab or window.")
-    meta_launch_url: Optional[StrictStr] = None
-    meta_icon: Optional[StrictStr] = Field(..., description="Get the URL to the App Icon image. If the name is /static or starts with http it is returned as-is")
-    meta_description: Optional[StrictStr] = None
-    meta_publisher: Optional[StrictStr] = None
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    group: Optional[StrictStr] = None
-    __properties = ["pk", "name", "slug", "provider", "provider_obj", "backchannel_providers", "backchannel_providers_obj", "launch_url", "open_in_new_tab", "meta_launch_url", "meta_icon", "meta_description", "meta_publisher", "policy_engine_mode", "group"]
-
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorSMSStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    provider: Optional[ProviderEnum] = None
+    from_number: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    account_sid: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    auth: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    auth_password: Optional[StrictStr] = None
+    auth_type: Optional[AuthTypeEnum] = None
+    verify_only: Optional[StrictBool] = Field(default=None, description="When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.")
+    mapping: Optional[StrictStr] = Field(default=None, description="Optionally modify the payload being sent to custom providers.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "provider", "from_number", "account_sid", "auth", "auth_password", "auth_type", "verify_only", "mapping"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Application:
-        """Create an instance of Application from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedAuthenticatorSMSStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "provider_obj",
-                            "backchannel_providers_obj",
-                            "launch_url",
-                            "meta_icon",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of provider_obj
-        if self.provider_obj:
-            _dict['provider_obj'] = self.provider_obj.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in backchannel_providers_obj (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
-        if self.backchannel_providers_obj:
-            for _item in self.backchannel_providers_obj:
+        if self.flow_set:
+            for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['backchannel_providers_obj'] = _items
-        # set to None if provider (nullable) is None
-        # and __fields_set__ contains the field
-        if self.provider is None and "provider" in self.__fields_set__:
-            _dict['provider'] = None
-
-        # set to None if launch_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.launch_url is None and "launch_url" in self.__fields_set__:
-            _dict['launch_url'] = None
-
-        # set to None if meta_icon (nullable) is None
-        # and __fields_set__ contains the field
-        if self.meta_icon is None and "meta_icon" in self.__fields_set__:
-            _dict['meta_icon'] = None
+            _dict['flow_set'] = _items
+        # set to None if configure_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
+            _dict['configure_flow'] = None
+
+        # set to None if friendly_name (nullable) is None
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
+            _dict['friendly_name'] = None
+
+        # set to None if mapping (nullable) is None
+        # and model_fields_set contains the field
+        if self.mapping is None and "mapping" in self.model_fields_set:
+            _dict['mapping'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Application:
-        """Create an instance of Application from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedAuthenticatorSMSStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Application.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Application.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "configure_flow": obj.get("configure_flow"),
+            "friendly_name": obj.get("friendly_name"),
             "provider": obj.get("provider"),
-            "provider_obj": Provider.from_dict(obj.get("provider_obj")) if obj.get("provider_obj") is not None else None,
-            "backchannel_providers": obj.get("backchannel_providers"),
-            "backchannel_providers_obj": [Provider.from_dict(_item) for _item in obj.get("backchannel_providers_obj")] if obj.get("backchannel_providers_obj") is not None else None,
-            "launch_url": obj.get("launch_url"),
-            "open_in_new_tab": obj.get("open_in_new_tab"),
-            "meta_launch_url": obj.get("meta_launch_url"),
-            "meta_icon": obj.get("meta_icon"),
-            "meta_description": obj.get("meta_description"),
-            "meta_publisher": obj.get("meta_publisher"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "group": obj.get("group")
+            "from_number": obj.get("from_number"),
+            "account_sid": obj.get("account_sid"),
+            "auth": obj.get("auth"),
+            "auth_password": obj.get("auth_password"),
+            "auth_type": obj.get("auth_type"),
+            "verify_only": obj.get("verify_only"),
+            "mapping": obj.get("mapping")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/application_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_application_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,83 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ApplicationRequest(BaseModel):
-    """
-    Application Serializer  # noqa: E501
+class PatchedApplicationRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(..., description="Application's display Name.")
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Internal application name, used in URLs.")
+    Application Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Application's display Name.")
+    slug: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Internal application name, used in URLs.")
     provider: Optional[StrictInt] = None
-    backchannel_providers: Optional[conlist(StrictInt)] = None
-    open_in_new_tab: Optional[StrictBool] = Field(None, description="Open launch URL in a new browser tab or window.")
+    backchannel_providers: Optional[List[StrictInt]] = None
+    open_in_new_tab: Optional[StrictBool] = Field(default=None, description="Open launch URL in a new browser tab or window.")
     meta_launch_url: Optional[StrictStr] = None
     meta_description: Optional[StrictStr] = None
     meta_publisher: Optional[StrictStr] = None
     policy_engine_mode: Optional[PolicyEngineMode] = None
     group: Optional[StrictStr] = None
-    __properties = ["name", "slug", "provider", "backchannel_providers", "open_in_new_tab", "meta_launch_url", "meta_description", "meta_publisher", "policy_engine_mode", "group"]
+    __properties: ClassVar[List[str]] = ["name", "slug", "provider", "backchannel_providers", "open_in_new_tab", "meta_launch_url", "meta_description", "meta_publisher", "policy_engine_mode", "group"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
+        if value is None:
+            return value
+
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ApplicationRequest:
-        """Create an instance of ApplicationRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedApplicationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if provider (nullable) is None
-        # and __fields_set__ contains the field
-        if self.provider is None and "provider" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.provider is None and "provider" in self.model_fields_set:
             _dict['provider'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ApplicationRequest:
-        """Create an instance of ApplicationRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedApplicationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ApplicationRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ApplicationRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "provider": obj.get("provider"),
             "backchannel_providers": obj.get("backchannel_providers"),
             "open_in_new_tab": obj.get("open_in_new_tab"),
             "meta_launch_url": obj.get("meta_launch_url"),
             "meta_description": obj.get("meta_description"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/auth_mode_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/auth_mode_enum.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,33 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AuthModeEnum(str, Enum):
     """
     AuthModeEnum
     """
 
     """
     allowed enum values
     """
     STATIC = 'static'
     PROMPT = 'prompt'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthModeEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AuthModeEnum from a JSON string"""
-        return AuthModeEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/auth_type_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ldapapi_access_mode.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,33 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class AuthTypeEnum(str, Enum):
+class LDAPAPIAccessMode(str, Enum):
     """
-    AuthTypeEnum
+    LDAPAPIAccessMode
     """
 
     """
     allowed enum values
     """
-    BASIC = 'basic'
-    BEARER = 'bearer'
+    DIRECT = 'direct'
+    CACHED = 'cached'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthTypeEnum:
-        """Create an instance of AuthTypeEnum from a JSON string"""
-        return AuthTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of LDAPAPIAccessMode from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticate_web_authn_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticate_web_authn_stage.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,110 +14,131 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.authenticator_attachment_enum import AuthenticatorAttachmentEnum
 from authentik_client.models.flow_set import FlowSet
 from authentik_client.models.resident_key_requirement_enum import ResidentKeyRequirementEnum
 from authentik_client.models.user_verification_enum import UserVerificationEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticateWebAuthnStage(BaseModel):
     """
-    AuthenticateWebAuthnStage Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    AuthenticateWebAuthnStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
     friendly_name: Optional[StrictStr] = None
     user_verification: Optional[UserVerificationEnum] = None
     authenticator_attachment: Optional[AuthenticatorAttachmentEnum] = None
     resident_key_requirement: Optional[ResidentKeyRequirementEnum] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "user_verification", "authenticator_attachment", "resident_key_requirement"]
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "user_verification", "authenticator_attachment", "resident_key_requirement"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticateWebAuthnStage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticateWebAuthnStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         # set to None if authenticator_attachment (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authenticator_attachment is None and "authenticator_attachment" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authenticator_attachment is None and "authenticator_attachment" in self.model_fields_set:
             _dict['authenticator_attachment'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticateWebAuthnStage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticateWebAuthnStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticateWebAuthnStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticateWebAuthnStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
             "user_verification": obj.get("user_verification"),
             "authenticator_attachment": obj.get("authenticator_attachment"),
             "resident_key_requirement": obj.get("resident_key_requirement")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticate_web_authn_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticate_web_authn_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,95 +14,112 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.authenticator_attachment_enum import AuthenticatorAttachmentEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
 from authentik_client.models.resident_key_requirement_enum import ResidentKeyRequirementEnum
 from authentik_client.models.user_verification_enum import UserVerificationEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticateWebAuthnStageRequest(BaseModel):
     """
-    AuthenticateWebAuthnStage Serializer  # noqa: E501
-    """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
+    AuthenticateWebAuthnStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     user_verification: Optional[UserVerificationEnum] = None
     authenticator_attachment: Optional[AuthenticatorAttachmentEnum] = None
     resident_key_requirement: Optional[ResidentKeyRequirementEnum] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "user_verification", "authenticator_attachment", "resident_key_requirement"]
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "user_verification", "authenticator_attachment", "resident_key_requirement"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticateWebAuthnStageRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticateWebAuthnStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         # set to None if authenticator_attachment (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authenticator_attachment is None and "authenticator_attachment" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authenticator_attachment is None and "authenticator_attachment" in self.model_fields_set:
             _dict['authenticator_attachment'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticateWebAuthnStageRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticateWebAuthnStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticateWebAuthnStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticateWebAuthnStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
             "user_verification": obj.get("user_verification"),
             "authenticator_attachment": obj.get("authenticator_attachment"),
             "resident_key_requirement": obj.get("resident_key_requirement")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,101 +14,110 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-from authentik_client.models.authenticated_session_asn import AuthenticatedSessionAsn
-from authentik_client.models.authenticated_session_geo_ip import AuthenticatedSessionGeoIp
-from authentik_client.models.authenticated_session_user_agent import AuthenticatedSessionUserAgent
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatedSession(BaseModel):
+class AuthenticatorDuoStageRequest(BaseModel):
     """
-    AuthenticatedSession Serializer  # noqa: E501
-    """
-    uuid: Optional[StrictStr] = None
-    current: StrictBool = Field(..., description="Check if session is currently active session")
-    user_agent: AuthenticatedSessionUserAgent = Field(...)
-    geo_ip: Optional[AuthenticatedSessionGeoIp] = Field(...)
-    asn: Optional[AuthenticatedSessionAsn] = Field(...)
-    user: StrictInt = Field(...)
-    last_ip: StrictStr = Field(...)
-    last_user_agent: Optional[StrictStr] = None
-    last_used: datetime = Field(...)
-    expires: Optional[datetime] = None
-    __properties = ["uuid", "current", "user_agent", "geo_ip", "asn", "user", "last_ip", "last_user_agent", "last_used", "expires"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorDuoStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    client_id: Annotated[str, Field(min_length=1, strict=True)]
+    client_secret: Annotated[str, Field(min_length=1, strict=True)]
+    api_hostname: Annotated[str, Field(min_length=1, strict=True)]
+    admin_integration_key: Optional[StrictStr] = None
+    admin_secret_key: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "client_id", "client_secret", "api_hostname", "admin_integration_key", "admin_secret_key"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSession:
-        """Create an instance of AuthenticatedSession from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorDuoStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "current",
-                            "last_used",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of user_agent
-        if self.user_agent:
-            _dict['user_agent'] = self.user_agent.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of geo_ip
-        if self.geo_ip:
-            _dict['geo_ip'] = self.geo_ip.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of asn
-        if self.asn:
-            _dict['asn'] = self.asn.to_dict()
-        # set to None if geo_ip (nullable) is None
-        # and __fields_set__ contains the field
-        if self.geo_ip is None and "geo_ip" in self.__fields_set__:
-            _dict['geo_ip'] = None
-
-        # set to None if asn (nullable) is None
-        # and __fields_set__ contains the field
-        if self.asn is None and "asn" in self.__fields_set__:
-            _dict['asn'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+        _items = []
+        if self.flow_set:
+            for _item in self.flow_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['flow_set'] = _items
+        # set to None if configure_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
+            _dict['configure_flow'] = None
+
+        # set to None if friendly_name (nullable) is None
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
+            _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSession:
-        """Create an instance of AuthenticatedSession from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorDuoStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSession.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSession.parse_obj({
-            "uuid": obj.get("uuid"),
-            "current": obj.get("current"),
-            "user_agent": AuthenticatedSessionUserAgent.from_dict(obj.get("user_agent")) if obj.get("user_agent") is not None else None,
-            "geo_ip": AuthenticatedSessionGeoIp.from_dict(obj.get("geo_ip")) if obj.get("geo_ip") is not None else None,
-            "asn": AuthenticatedSessionAsn.from_dict(obj.get("asn")) if obj.get("asn") is not None else None,
-            "user": obj.get("user"),
-            "last_ip": obj.get("last_ip"),
-            "last_user_agent": obj.get("last_user_agent"),
-            "last_used": obj.get("last_used"),
-            "expires": obj.get("expires")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "configure_flow": obj.get("configure_flow"),
+            "friendly_name": obj.get("friendly_name"),
+            "client_id": obj.get("client_id"),
+            "client_secret": obj.get("client_secret"),
+            "api_hostname": obj.get("api_hostname"),
+            "admin_integration_key": obj.get("admin_integration_key"),
+            "admin_secret_key": obj.get("admin_secret_key")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_asn.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_static_stage_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.authenticator_static_stage import AuthenticatorStaticStage
+from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
-
-class AuthenticatedSessionAsn(BaseModel):
-    """
-    Get ASN Data  # noqa: E501
+class PaginatedAuthenticatorStaticStageList(BaseModel):
     """
-    asn: StrictInt = Field(...)
-    as_org: Optional[StrictStr] = Field(...)
-    network: Optional[StrictStr] = Field(...)
-    __properties = ["asn", "as_org", "network"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedAuthenticatorStaticStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[AuthenticatorStaticStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSessionAsn:
-        """Create an instance of AuthenticatedSessionAsn from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorStaticStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if as_org (nullable) is None
-        # and __fields_set__ contains the field
-        if self.as_org is None and "as_org" in self.__fields_set__:
-            _dict['as_org'] = None
-
-        # set to None if network (nullable) is None
-        # and __fields_set__ contains the field
-        if self.network is None and "network" in self.__fields_set__:
-            _dict['network'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+        _items = []
+        if self.results:
+            for _item in self.results:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSessionAsn:
-        """Create an instance of AuthenticatedSessionAsn from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorStaticStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSessionAsn.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSessionAsn.parse_obj({
-            "asn": obj.get("asn"),
-            "as_org": obj.get("as_org"),
-            "network": obj.get("network")
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [AuthenticatorStaticStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_geo_ip.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_geo_ip.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
+from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Union
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatedSessionGeoIp(BaseModel):
     """
-    Get GeoIP Data  # noqa: E501
-    """
-    continent: StrictStr = Field(...)
-    country: StrictStr = Field(...)
-    lat: Union[StrictFloat, StrictInt] = Field(...)
-    long: Union[StrictFloat, StrictInt] = Field(...)
-    city: StrictStr = Field(...)
-    __properties = ["continent", "country", "lat", "long", "city"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Get GeoIP Data
+    """ # noqa: E501
+    continent: StrictStr
+    country: StrictStr
+    lat: Union[StrictFloat, StrictInt]
+    long: Union[StrictFloat, StrictInt]
+    city: StrictStr
+    __properties: ClassVar[List[str]] = ["continent", "country", "lat", "long", "city"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSessionGeoIp:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatedSessionGeoIp from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSessionGeoIp:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatedSessionGeoIp from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSessionGeoIp.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSessionGeoIp.parse_obj({
+        _obj = cls.model_validate({
             "continent": obj.get("continent"),
             "country": obj.get("country"),
             "lat": obj.get("lat"),
             "long": obj.get("long"),
             "city": obj.get("city")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/login_source.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,77 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.login_challenge_types import LoginChallengeTypes
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-from authentik_client.models.authenticated_session_user_agent_device import AuthenticatedSessionUserAgentDevice
-from authentik_client.models.authenticated_session_user_agent_os import AuthenticatedSessionUserAgentOs
-from authentik_client.models.authenticated_session_user_agent_user_agent import AuthenticatedSessionUserAgentUserAgent
-
-class AuthenticatedSessionUserAgent(BaseModel):
+class LoginSource(BaseModel):
     """
-    Get parsed user agent  # noqa: E501
-    """
-    device: AuthenticatedSessionUserAgentDevice = Field(...)
-    os: AuthenticatedSessionUserAgentOs = Field(...)
-    user_agent: AuthenticatedSessionUserAgentUserAgent = Field(...)
-    string: StrictStr = Field(...)
-    __properties = ["device", "os", "user_agent", "string"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for Login buttons of sources
+    """ # noqa: E501
+    name: StrictStr
+    icon_url: Optional[StrictStr] = None
+    challenge: LoginChallengeTypes
+    __properties: ClassVar[List[str]] = ["name", "icon_url", "challenge"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSessionUserAgent:
-        """Create an instance of AuthenticatedSessionUserAgent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LoginSource from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of device
-        if self.device:
-            _dict['device'] = self.device.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of os
-        if self.os:
-            _dict['os'] = self.os.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user_agent
-        if self.user_agent:
-            _dict['user_agent'] = self.user_agent.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of challenge
+        if self.challenge:
+            _dict['challenge'] = self.challenge.to_dict()
+        # set to None if icon_url (nullable) is None
+        # and model_fields_set contains the field
+        if self.icon_url is None and "icon_url" in self.model_fields_set:
+            _dict['icon_url'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSessionUserAgent:
-        """Create an instance of AuthenticatedSessionUserAgent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LoginSource from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSessionUserAgent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSessionUserAgent.parse_obj({
-            "device": AuthenticatedSessionUserAgentDevice.from_dict(obj.get("device")) if obj.get("device") is not None else None,
-            "os": AuthenticatedSessionUserAgentOs.from_dict(obj.get("os")) if obj.get("os") is not None else None,
-            "user_agent": AuthenticatedSessionUserAgentUserAgent.from_dict(obj.get("user_agent")) if obj.get("user_agent") is not None else None,
-            "string": obj.get("string")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "icon_url": obj.get("icon_url"),
+            "challenge": LoginChallengeTypes.from_dict(obj["challenge"]) if obj.get("challenge") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent_device.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent_os.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,63 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class AuthenticatedSessionUserAgentDevice(BaseModel):
-    """
-    User agent device  # noqa: E501
+class AuthenticatedSessionUserAgentOs(BaseModel):
     """
-    brand: StrictStr = Field(...)
-    family: StrictStr = Field(...)
-    model: StrictStr = Field(...)
-    __properties = ["brand", "family", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User agent os
+    """ # noqa: E501
+    family: StrictStr
+    major: StrictStr
+    minor: StrictStr
+    patch: StrictStr
+    patch_minor: StrictStr
+    __properties: ClassVar[List[str]] = ["family", "major", "minor", "patch", "patch_minor"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSessionUserAgentDevice:
-        """Create an instance of AuthenticatedSessionUserAgentDevice from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionUserAgentOs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSessionUserAgentDevice:
-        """Create an instance of AuthenticatedSessionUserAgentDevice from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionUserAgentOs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSessionUserAgentDevice.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSessionUserAgentDevice.parse_obj({
-            "brand": obj.get("brand"),
+        _obj = cls.model_validate({
             "family": obj.get("family"),
-            "model": obj.get("model")
+            "major": obj.get("major"),
+            "minor": obj.get("minor"),
+            "patch": obj.get("patch"),
+            "patch_minor": obj.get("patch_minor")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent_os.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent_user_agent.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class AuthenticatedSessionUserAgentOs(BaseModel):
-    """
-    User agent os  # noqa: E501
+class AuthenticatedSessionUserAgentUserAgent(BaseModel):
     """
-    family: StrictStr = Field(...)
-    major: StrictStr = Field(...)
-    minor: StrictStr = Field(...)
-    patch: StrictStr = Field(...)
-    patch_minor: StrictStr = Field(...)
-    __properties = ["family", "major", "minor", "patch", "patch_minor"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User agent browser
+    """ # noqa: E501
+    family: StrictStr
+    major: StrictStr
+    minor: StrictStr
+    patch: StrictStr
+    __properties: ClassVar[List[str]] = ["family", "major", "minor", "patch"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSessionUserAgentOs:
-        """Create an instance of AuthenticatedSessionUserAgentOs from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionUserAgentUserAgent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSessionUserAgentOs:
-        """Create an instance of AuthenticatedSessionUserAgentOs from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionUserAgentUserAgent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSessionUserAgentOs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSessionUserAgentOs.parse_obj({
+        _obj = cls.model_validate({
             "family": obj.get("family"),
             "major": obj.get("major"),
             "minor": obj.get("minor"),
-            "patch": obj.get("patch"),
-            "patch_minor": obj.get("patch_minor")
+            "patch": obj.get("patch")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticated_session_user_agent_user_agent.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_user_agent_device.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,65 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class AuthenticatedSessionUserAgentUserAgent(BaseModel):
-    """
-    User agent browser  # noqa: E501
+class AuthenticatedSessionUserAgentDevice(BaseModel):
     """
-    family: StrictStr = Field(...)
-    major: StrictStr = Field(...)
-    minor: StrictStr = Field(...)
-    patch: StrictStr = Field(...)
-    __properties = ["family", "major", "minor", "patch"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User agent device
+    """ # noqa: E501
+    brand: StrictStr
+    family: StrictStr
+    model: StrictStr
+    __properties: ClassVar[List[str]] = ["brand", "family", "model"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatedSessionUserAgentUserAgent:
-        """Create an instance of AuthenticatedSessionUserAgentUserAgent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionUserAgentDevice from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatedSessionUserAgentUserAgent:
-        """Create an instance of AuthenticatedSessionUserAgentUserAgent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionUserAgentDevice from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatedSessionUserAgentUserAgent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatedSessionUserAgentUserAgent.parse_obj({
+        _obj = cls.model_validate({
+            "brand": obj.get("brand"),
             "family": obj.get("family"),
-            "major": obj.get("major"),
-            "minor": obj.get("minor"),
-            "patch": obj.get("patch")
+            "model": obj.get("model")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authentication_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authentication_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AuthenticationEnum(str, Enum):
     """
     AuthenticationEnum
     """
 
@@ -33,12 +30,12 @@
     NONE = 'none'
     REQUIRE_AUTHENTICATED = 'require_authenticated'
     REQUIRE_UNAUTHENTICATED = 'require_unauthenticated'
     REQUIRE_SUPERUSER = 'require_superuser'
     REQUIRE_OUTPOST = 'require_outpost'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticationEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AuthenticationEnum from a JSON string"""
-        return AuthenticationEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_attachment_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_attachment_enum.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,33 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class AuthenticatorAttachmentEnum(str, Enum):
     """
     AuthenticatorAttachmentEnum
     """
 
     """
     allowed enum values
     """
     PLATFORM = 'platform'
     CROSS_MINUS_PLATFORM = 'cross-platform'
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorAttachmentEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of AuthenticatorAttachmentEnum from a JSON string"""
-        return AuthenticatorAttachmentEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_challenge.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,94 +14,110 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorDuoChallenge(BaseModel):
     """
-    Duo Challenge  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Duo Challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-stage-authenticator-duo'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    activation_barcode: StrictStr = Field(...)
-    activation_code: StrictStr = Field(...)
-    stage_uuid: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "activation_barcode", "activation_code", "stage_uuid"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    pending_user: StrictStr
+    pending_user_avatar: StrictStr
+    activation_barcode: StrictStr
+    activation_code: StrictStr
+    stage_uuid: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "activation_barcode", "activation_code", "stage_uuid"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorDuoChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorDuoChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorDuoChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorDuoChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorDuoChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorDuoChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-duo',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "pending_user": obj.get("pending_user"),
             "pending_user_avatar": obj.get("pending_user_avatar"),
             "activation_barcode": obj.get("activation_barcode"),
             "activation_code": obj.get("activation_code"),
             "stage_uuid": obj.get("stage_uuid")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_property_mapping.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,104 +14,113 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-
-class AuthenticatorDuoStage(BaseModel):
-    """
-    AuthenticatorDuoStage Serializer  # noqa: E501
+class SAMLPropertyMapping(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    SAMLPropertyMapping Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    managed: Optional[StrictStr] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: StrictStr
+    expression: StrictStr
+    component: StrictStr = Field(description="Get object's component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    saml_name: StrictStr
     friendly_name: Optional[StrictStr] = None
-    client_id: StrictStr = Field(...)
-    api_hostname: StrictStr = Field(...)
-    admin_integration_key: Optional[StrictStr] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "client_id", "api_hostname", "admin_integration_key"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    __properties: ClassVar[List[str]] = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "saml_name", "friendly_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorDuoStage:
-        """Create an instance of AuthenticatorDuoStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SAMLPropertyMapping from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if managed (nullable) is None
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
+            _dict['managed'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorDuoStage:
-        """Create an instance of AuthenticatorDuoStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SAMLPropertyMapping from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorDuoStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorDuoStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
+            "managed": obj.get("managed"),
             "name": obj.get("name"),
+            "expression": obj.get("expression"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "configure_flow": obj.get("configure_flow"),
-            "friendly_name": obj.get("friendly_name"),
-            "client_id": obj.get("client_id"),
-            "api_hostname": obj.get("api_hostname"),
-            "admin_integration_key": obj.get("admin_integration_key")
+            "saml_name": obj.get("saml_name"),
+            "friendly_name": obj.get("friendly_name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage_device_import_response.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage_device_import_response.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,63 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorDuoStageDeviceImportResponse(BaseModel):
     """
     AuthenticatorDuoStageDeviceImportResponse
-    """
-    count: StrictInt = Field(...)
-    error: StrictStr = Field(...)
-    __properties = ["count", "error"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    count: StrictInt
+    error: StrictStr
+    __properties: ClassVar[List[str]] = ["count", "error"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorDuoStageDeviceImportResponse:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorDuoStageDeviceImportResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "count",
-                            "error",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "count",
+            "error",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorDuoStageDeviceImportResponse:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorDuoStageDeviceImportResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorDuoStageDeviceImportResponse.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorDuoStageDeviceImportResponse.parse_obj({
+        _obj = cls.model_validate({
             "count": obj.get("count"),
             "error": obj.get("error")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_duo_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_totp_stage_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,93 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.digits_enum import DigitsEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorDuoStageRequest(BaseModel):
-    """
-    AuthenticatorDuoStage Serializer  # noqa: E501
+class PatchedAuthenticatorTOTPStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    client_id: constr(strict=True, min_length=1) = Field(...)
-    client_secret: constr(strict=True, min_length=1) = Field(...)
-    api_hostname: constr(strict=True, min_length=1) = Field(...)
-    admin_integration_key: Optional[StrictStr] = None
-    admin_secret_key: Optional[StrictStr] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "client_id", "client_secret", "api_hostname", "admin_integration_key", "admin_secret_key"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorTOTPStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    digits: Optional[DigitsEnum] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "digits"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorDuoStageRequest:
-        """Create an instance of AuthenticatorDuoStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedAuthenticatorTOTPStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorDuoStageRequest:
-        """Create an instance of AuthenticatorDuoStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedAuthenticatorTOTPStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorDuoStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorDuoStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
-            "client_id": obj.get("client_id"),
-            "client_secret": obj.get("client_secret"),
-            "api_hostname": obj.get("api_hostname"),
-            "admin_integration_key": obj.get("admin_integration_key"),
-            "admin_secret_key": obj.get("admin_secret_key")
+            "digits": obj.get("digits")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_login_challenge.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,93 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorSMSChallenge(BaseModel):
-    """
-    SMS Setup challenge  # noqa: E501
+class UserLoginChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    Empty challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-authenticator-sms'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    phone_number_required: Optional[StrictBool] = True
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "phone_number_required"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-stage-user-login'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    pending_user: StrictStr
+    pending_user_avatar: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorSMSChallenge:
-        """Create an instance of AuthenticatorSMSChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserLoginChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorSMSChallenge:
-        """Create an instance of AuthenticatorSMSChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserLoginChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorSMSChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorSMSChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-sms',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-user-login',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "pending_user": obj.get("pending_user"),
-            "pending_user_avatar": obj.get("pending_user_avatar"),
-            "phone_number_required": obj.get("phone_number_required") if obj.get("phone_number_required") is not None else True
+            "pending_user_avatar": obj.get("pending_user_avatar")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_challenge_response_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,63 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, StrictInt, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorSMSChallengeResponseRequest(BaseModel):
     """
-    SMS Challenge response, device is set by get_response_instance  # noqa: E501
-    """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-authenticator-sms'
+    SMS Challenge response, device is set by get_response_instance
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-authenticator-sms'
     code: Optional[StrictInt] = None
-    phone_number: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["component", "code", "phone_number"]
+    phone_number: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["component", "code", "phone_number"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorSMSChallengeResponseRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorSMSChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorSMSChallengeResponseRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorSMSChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorSMSChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorSMSChallengeResponseRequest.parse_obj({
+        _obj = cls.model_validate({
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-sms',
             "code": obj.get("code"),
             "phone_number": obj.get("phone_number")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_stage.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,114 +14,135 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.auth_type_enum import AuthTypeEnum
 from authentik_client.models.flow_set import FlowSet
 from authentik_client.models.provider_enum import ProviderEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorSMSStage(BaseModel):
     """
-    AuthenticatorSMSStage Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    AuthenticatorSMSStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
     friendly_name: Optional[StrictStr] = None
-    provider: ProviderEnum = Field(...)
-    from_number: StrictStr = Field(...)
-    account_sid: StrictStr = Field(...)
-    auth: StrictStr = Field(...)
+    provider: ProviderEnum
+    from_number: StrictStr
+    account_sid: StrictStr
+    auth: StrictStr
     auth_password: Optional[StrictStr] = None
     auth_type: Optional[AuthTypeEnum] = None
-    verify_only: Optional[StrictBool] = Field(None, description="When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.")
-    mapping: Optional[StrictStr] = Field(None, description="Optionally modify the payload being sent to custom providers.")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "provider", "from_number", "account_sid", "auth", "auth_password", "auth_type", "verify_only", "mapping"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    verify_only: Optional[StrictBool] = Field(default=None, description="When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.")
+    mapping: Optional[StrictStr] = Field(default=None, description="Optionally modify the payload being sent to custom providers.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "provider", "from_number", "account_sid", "auth", "auth_password", "auth_type", "verify_only", "mapping"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorSMSStage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorSMSStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         # set to None if mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.mapping is None and "mapping" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.mapping is None and "mapping" in self.model_fields_set:
             _dict['mapping'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorSMSStage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorSMSStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorSMSStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorSMSStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
             "provider": obj.get("provider"),
             "from_number": obj.get("from_number"),
             "account_sid": obj.get("account_sid"),
             "auth": obj.get("auth"),
             "auth_password": obj.get("auth_password"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_sms_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_duo_stage_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,106 +14,110 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from authentik_client.models.auth_type_enum import AuthTypeEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
-from authentik_client.models.provider_enum import ProviderEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorSMSStageRequest(BaseModel):
-    """
-    AuthenticatorSMSStage Serializer  # noqa: E501
+class PatchedAuthenticatorDuoStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    provider: ProviderEnum = Field(...)
-    from_number: constr(strict=True, min_length=1) = Field(...)
-    account_sid: constr(strict=True, min_length=1) = Field(...)
-    auth: constr(strict=True, min_length=1) = Field(...)
-    auth_password: Optional[StrictStr] = None
-    auth_type: Optional[AuthTypeEnum] = None
-    verify_only: Optional[StrictBool] = Field(None, description="When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.")
-    mapping: Optional[StrictStr] = Field(None, description="Optionally modify the payload being sent to custom providers.")
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "provider", "from_number", "account_sid", "auth", "auth_password", "auth_type", "verify_only", "mapping"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorDuoStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    client_id: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    client_secret: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    api_hostname: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    admin_integration_key: Optional[StrictStr] = None
+    admin_secret_key: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "client_id", "client_secret", "api_hostname", "admin_integration_key", "admin_secret_key"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorSMSStageRequest:
-        """Create an instance of AuthenticatorSMSStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedAuthenticatorDuoStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
-        # set to None if mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.mapping is None and "mapping" in self.__fields_set__:
-            _dict['mapping'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorSMSStageRequest:
-        """Create an instance of AuthenticatorSMSStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedAuthenticatorDuoStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorSMSStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorSMSStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
-            "provider": obj.get("provider"),
-            "from_number": obj.get("from_number"),
-            "account_sid": obj.get("account_sid"),
-            "auth": obj.get("auth"),
-            "auth_password": obj.get("auth_password"),
-            "auth_type": obj.get("auth_type"),
-            "verify_only": obj.get("verify_only"),
-            "mapping": obj.get("mapping")
+            "client_id": obj.get("client_id"),
+            "client_secret": obj.get("client_secret"),
+            "api_hostname": obj.get("api_hostname"),
+            "admin_integration_key": obj.get("admin_integration_key"),
+            "admin_secret_key": obj.get("admin_secret_key")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/redirect_challenge.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,93 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorStaticChallenge(BaseModel):
-    """
-    Static authenticator challenge  # noqa: E501
+class RedirectChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    Challenge type to redirect the client
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-authenticator-static'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    codes: conlist(StrictStr) = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "codes"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'xak-flow-redirect'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    to: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "to"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorStaticChallenge:
-        """Create an instance of AuthenticatorStaticChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RedirectChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorStaticChallenge:
-        """Create an instance of AuthenticatorStaticChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RedirectChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorStaticChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorStaticChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-static',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'xak-flow-redirect',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
-            "pending_user": obj.get("pending_user"),
-            "pending_user_avatar": obj.get("pending_user_avatar"),
-            "codes": obj.get("codes")
+            "to": obj.get("to")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_challenge_response_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, constr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorStaticChallengeResponseRequest(BaseModel):
     """
-    Pseudo class for static response  # noqa: E501
-    """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-authenticator-static'
-    __properties = ["component"]
+    Pseudo class for static response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-authenticator-static'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorStaticChallengeResponseRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorStaticChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorStaticChallengeResponseRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorStaticChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorStaticChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorStaticChallengeResponseRequest.parse_obj({
+        _obj = cls.model_validate({
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-static'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_stage.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,101 +14,123 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorStaticStage(BaseModel):
     """
-    AuthenticatorStaticStage Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    AuthenticatorStaticStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
     friendly_name: Optional[StrictStr] = None
-    token_count: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    token_length: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "token_count", "token_length"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    token_count: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    token_length: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "token_count", "token_length"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorStaticStage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorStaticStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorStaticStage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorStaticStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorStaticStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorStaticStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
             "token_count": obj.get("token_count"),
             "token_length": obj.get("token_length")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_static_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_stage_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,87 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.digits_enum import DigitsEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorStaticStageRequest(BaseModel):
-    """
-    AuthenticatorStaticStage Serializer  # noqa: E501
+class AuthenticatorTOTPStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    token_count: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    token_length: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "token_count", "token_length"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorTOTPStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    digits: DigitsEnum
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "digits"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorStaticStageRequest:
-        """Create an instance of AuthenticatorStaticStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorStaticStageRequest:
-        """Create an instance of AuthenticatorStaticStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorStaticStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorStaticStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
-            "token_count": obj.get("token_count"),
-            "token_length": obj.get("token_length")
+            "digits": obj.get("digits")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_rac_provider_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,93 +14,98 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class AuthenticatorTOTPChallenge(BaseModel):
-    """
-    TOTP Setup challenge  # noqa: E501
+class PatchedRACProviderRequest(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-authenticator-totp'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    config_url: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "config_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RACProvider Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: Optional[StrictStr] = Field(default=None, description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    settings: Optional[Any] = None
+    connection_expiry: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)")
+    delete_token_on_disconnect: Optional[StrictBool] = Field(default=None, description="When set to true, connection tokens will be deleted upon disconnect.")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "settings", "connection_expiry", "delete_token_on_disconnect"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorTOTPChallenge:
-        """Create an instance of AuthenticatorTOTPChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedRACProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
+
+        # set to None if settings (nullable) is None
+        # and model_fields_set contains the field
+        if self.settings is None and "settings" in self.model_fields_set:
+            _dict['settings'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorTOTPChallenge:
-        """Create an instance of AuthenticatorTOTPChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedRACProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorTOTPChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorTOTPChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-totp',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "pending_user": obj.get("pending_user"),
-            "pending_user_avatar": obj.get("pending_user_avatar"),
-            "config_url": obj.get("config_url")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "authentication_flow": obj.get("authentication_flow"),
+            "authorization_flow": obj.get("authorization_flow"),
+            "property_mappings": obj.get("property_mappings"),
+            "settings": obj.get("settings"),
+            "connection_expiry": obj.get("connection_expiry"),
+            "delete_token_on_disconnect": obj.get("delete_token_on_disconnect")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_authentication_challenge_response_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,61 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, constr
-
-class AuthenticatorTOTPChallengeResponseRequest(BaseModel):
-    """
-    TOTP Challenge response, device is set by get_response_instance  # noqa: E501
+class PlexAuthenticationChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-authenticator-totp'
-    code: StrictInt = Field(...)
-    __properties = ["component", "code"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Pseudo class for plex response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-source-plex'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorTOTPChallengeResponseRequest:
-        """Create an instance of AuthenticatorTOTPChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PlexAuthenticationChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorTOTPChallengeResponseRequest:
-        """Create an instance of AuthenticatorTOTPChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PlexAuthenticationChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorTOTPChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorTOTPChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-totp',
-            "code": obj.get("code")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-source-plex'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/scope_mapping.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,101 +14,108 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.digits_enum import DigitsEnum
-from authentik_client.models.flow_set import FlowSet
-
-class AuthenticatorTOTPStage(BaseModel):
-    """
-    AuthenticatorTOTPStage Serializer  # noqa: E501
+class ScopeMapping(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[StrictStr] = None
-    digits: DigitsEnum = Field(...)
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "digits"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ScopeMapping Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    managed: Optional[StrictStr] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: StrictStr
+    expression: StrictStr
+    component: StrictStr = Field(description="Get object's component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    scope_name: StrictStr = Field(description="Scope name requested by the client")
+    description: Optional[StrictStr] = Field(default=None, description="Description shown to the user when consenting. If left empty, the user won't be informed.")
+    __properties: ClassVar[List[str]] = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "scope_name", "description"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorTOTPStage:
-        """Create an instance of AuthenticatorTOTPStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ScopeMapping from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
-
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if managed (nullable) is None
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
+            _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorTOTPStage:
-        """Create an instance of AuthenticatorTOTPStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ScopeMapping from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorTOTPStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorTOTPStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
+            "managed": obj.get("managed"),
             "name": obj.get("name"),
+            "expression": obj.get("expression"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "configure_flow": obj.get("configure_flow"),
-            "friendly_name": obj.get("friendly_name"),
-            "digits": obj.get("digits")
+            "scope_name": obj.get("scope_name"),
+            "description": obj.get("description")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_totp_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,86 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.digits_enum import DigitsEnum
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class AuthenticatorTOTPStageRequest(BaseModel):
-    """
-    AuthenticatorTOTPStage Serializer  # noqa: E501
+class ProviderRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    digits: DigitsEnum = Field(...)
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "digits"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Provider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorTOTPStageRequest:
-        """Create an instance of AuthenticatorTOTPStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
-
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorTOTPStageRequest:
-        """Create an instance of AuthenticatorTOTPStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorTOTPStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorTOTPStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "configure_flow": obj.get("configure_flow"),
-            "friendly_name": obj.get("friendly_name"),
-            "digits": obj.get("digits")
+            "authentication_flow": obj.get("authentication_flow"),
+            "authorization_flow": obj.get("authorization_flow"),
+            "property_mappings": obj.get("property_mappings")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validate_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validate_stage_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,95 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.device_classes_enum import DeviceClassesEnum
-from authentik_client.models.flow_set import FlowSet
+from authentik_client.models.flow_set_request import FlowSetRequest
 from authentik_client.models.not_configured_action_enum import NotConfiguredActionEnum
 from authentik_client.models.user_verification_enum import UserVerificationEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorValidateStage(BaseModel):
-    """
-    AuthenticatorValidateStage Serializer  # noqa: E501
+class AuthenticatorValidateStageRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
+    AuthenticatorValidateStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
     not_configured_action: Optional[NotConfiguredActionEnum] = None
-    device_classes: Optional[conlist(DeviceClassesEnum)] = Field(None, description="Device classes which can be used to authenticate")
-    configuration_stages: Optional[conlist(StrictStr)] = Field(None, description="Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.")
-    last_auth_threshold: Optional[StrictStr] = Field(None, description="If any of the user's device has been used within this threshold, this stage will be skipped")
-    webauthn_user_verification: Optional[UserVerificationEnum] = Field(None, description="Enforce user verification for WebAuthn devices.")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "not_configured_action", "device_classes", "configuration_stages", "last_auth_threshold", "webauthn_user_verification"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    device_classes: Optional[List[DeviceClassesEnum]] = Field(default=None, description="Device classes which can be used to authenticate")
+    configuration_stages: Optional[List[StrictStr]] = Field(default=None, description="Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.")
+    last_auth_threshold: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="If any of the user's device has been used within this threshold, this stage will be skipped")
+    webauthn_user_verification: Optional[UserVerificationEnum] = Field(default=None, description="Enforce user verification for WebAuthn devices.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "not_configured_action", "device_classes", "configuration_stages", "last_auth_threshold", "webauthn_user_verification"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorValidateStage:
-        """Create an instance of AuthenticatorValidateStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorValidateStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorValidateStage:
-        """Create an instance of AuthenticatorValidateStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorValidateStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorValidateStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorValidateStage.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "not_configured_action": obj.get("not_configured_action"),
             "device_classes": obj.get("device_classes"),
             "configuration_stages": obj.get("configuration_stages"),
             "last_auth_threshold": obj.get("last_auth_threshold"),
             "webauthn_user_verification": obj.get("webauthn_user_verification")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validate_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/docker_service_connection_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,82 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.device_classes_enum import DeviceClassesEnum
-from authentik_client.models.flow_set_request import FlowSetRequest
-from authentik_client.models.not_configured_action_enum import NotConfiguredActionEnum
-from authentik_client.models.user_verification_enum import UserVerificationEnum
-
-class AuthenticatorValidateStageRequest(BaseModel):
-    """
-    AuthenticatorValidateStage Serializer  # noqa: E501
+class DockerServiceConnectionRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    not_configured_action: Optional[NotConfiguredActionEnum] = None
-    device_classes: Optional[conlist(DeviceClassesEnum)] = Field(None, description="Device classes which can be used to authenticate")
-    configuration_stages: Optional[conlist(StrictStr)] = Field(None, description="Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.")
-    last_auth_threshold: Optional[constr(strict=True, min_length=1)] = Field(None, description="If any of the user's device has been used within this threshold, this stage will be skipped")
-    webauthn_user_verification: Optional[UserVerificationEnum] = Field(None, description="Enforce user verification for WebAuthn devices.")
-    __properties = ["name", "flow_set", "not_configured_action", "device_classes", "configuration_stages", "last_auth_threshold", "webauthn_user_verification"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DockerServiceConnection Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    url: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.")
+    tls_verification: Optional[StrictStr] = Field(default=None, description="CA which the endpoint's Certificate is verified against. Can be left empty for no validation.")
+    tls_authentication: Optional[StrictStr] = Field(default=None, description="Certificate/Key used for authentication. Can be left empty for no authentication.")
+    __properties: ClassVar[List[str]] = ["name", "local", "url", "tls_verification", "tls_authentication"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorValidateStageRequest:
-        """Create an instance of AuthenticatorValidateStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DockerServiceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if tls_verification (nullable) is None
+        # and model_fields_set contains the field
+        if self.tls_verification is None and "tls_verification" in self.model_fields_set:
+            _dict['tls_verification'] = None
+
+        # set to None if tls_authentication (nullable) is None
+        # and model_fields_set contains the field
+        if self.tls_authentication is None and "tls_authentication" in self.model_fields_set:
+            _dict['tls_authentication'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorValidateStageRequest:
-        """Create an instance of AuthenticatorValidateStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DockerServiceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorValidateStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorValidateStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "not_configured_action": obj.get("not_configured_action"),
-            "device_classes": obj.get("device_classes"),
-            "configuration_stages": obj.get("configuration_stages"),
-            "last_auth_threshold": obj.get("last_auth_threshold"),
-            "webauthn_user_verification": obj.get("webauthn_user_verification")
+            "local": obj.get("local"),
+            "url": obj.get("url"),
+            "tls_verification": obj.get("tls_verification"),
+            "tls_authentication": obj.get("tls_authentication")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validation_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validation_challenge.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,69 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.device_challenge import DeviceChallenge
 from authentik_client.models.error_detail import ErrorDetail
 from authentik_client.models.selectable_stage import SelectableStage
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorValidationChallenge(BaseModel):
     """
-    Authenticator challenge  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Authenticator challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-stage-authenticator-validate'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    device_challenges: conlist(DeviceChallenge) = Field(...)
-    configuration_stages: conlist(SelectableStage) = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "device_challenges", "configuration_stages"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    pending_user: StrictStr
+    pending_user_avatar: StrictStr
+    device_challenges: List[DeviceChallenge]
+    configuration_stages: List[SelectableStage]
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "device_challenges", "configuration_stages"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorValidationChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorValidationChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         # override the default output from pydantic by calling `to_dict()` of each item in device_challenges (list)
         _items = []
         if self.device_challenges:
@@ -90,35 +106,35 @@
             for _item in self.configuration_stages:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['configuration_stages'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorValidationChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorValidationChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorValidationChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorValidationChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-validate',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "pending_user": obj.get("pending_user"),
             "pending_user_avatar": obj.get("pending_user_avatar"),
-            "device_challenges": [DeviceChallenge.from_dict(_item) for _item in obj.get("device_challenges")] if obj.get("device_challenges") is not None else None,
-            "configuration_stages": [SelectableStage.from_dict(_item) for _item in obj.get("configuration_stages")] if obj.get("configuration_stages") is not None else None
+            "device_challenges": [DeviceChallenge.from_dict(_item) for _item in obj["device_challenges"]] if obj.get("device_challenges") is not None else None,
+            "configuration_stages": [SelectableStage.from_dict(_item) for _item in obj["configuration_stages"]] if obj.get("configuration_stages") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_validation_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_validation_challenge_response_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,72 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, StrictInt, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.device_challenge_request import DeviceChallengeRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorValidationChallengeResponseRequest(BaseModel):
     """
-    Challenge used for Code-based and WebAuthn authenticators  # noqa: E501
-    """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-authenticator-validate'
+    Challenge used for Code-based and WebAuthn authenticators
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-authenticator-validate'
     selected_challenge: Optional[DeviceChallengeRequest] = None
-    selected_stage: Optional[constr(strict=True, min_length=1)] = None
-    code: Optional[constr(strict=True, min_length=1)] = None
+    selected_stage: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    code: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     webauthn: Optional[Dict[str, Any]] = None
     duo: Optional[StrictInt] = None
-    __properties = ["component", "selected_challenge", "selected_stage", "code", "webauthn", "duo"]
+    __properties: ClassVar[List[str]] = ["component", "selected_challenge", "selected_stage", "code", "webauthn", "duo"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorValidationChallengeResponseRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorValidationChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of selected_challenge
         if self.selected_challenge:
             _dict['selected_challenge'] = self.selected_challenge.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorValidationChallengeResponseRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorValidationChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorValidationChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorValidationChallengeResponseRequest.parse_obj({
+        _obj = cls.model_validate({
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-validate',
-            "selected_challenge": DeviceChallengeRequest.from_dict(obj.get("selected_challenge")) if obj.get("selected_challenge") is not None else None,
+            "selected_challenge": DeviceChallengeRequest.from_dict(obj["selected_challenge"]) if obj.get("selected_challenge") is not None else None,
             "selected_stage": obj.get("selected_stage"),
             "code": obj.get("code"),
             "webauthn": obj.get("webauthn"),
             "duo": obj.get("duo")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_web_authn_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_challenge.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,93 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class AuthenticatorWebAuthnChallenge(BaseModel):
-    """
-    WebAuthn Challenge  # noqa: E501
+class AuthenticatorStaticChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    Static authenticator challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-authenticator-webauthn'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    registration: Dict[str, Any] = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "registration"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-stage-authenticator-static'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    pending_user: StrictStr
+    pending_user_avatar: StrictStr
+    codes: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "codes"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorWebAuthnChallenge:
-        """Create an instance of AuthenticatorWebAuthnChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorStaticChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorWebAuthnChallenge:
-        """Create an instance of AuthenticatorWebAuthnChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorStaticChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorWebAuthnChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorWebAuthnChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-webauthn',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-static',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "pending_user": obj.get("pending_user"),
             "pending_user_avatar": obj.get("pending_user_avatar"),
-            "registration": obj.get("registration")
+            "codes": obj.get("codes")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/authenticator_web_authn_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_web_authn_challenge_response_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,61 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, constr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class AuthenticatorWebAuthnChallengeResponseRequest(BaseModel):
     """
-    WebAuthn Challenge response  # noqa: E501
-    """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-authenticator-webauthn'
-    response: Dict[str, Any] = Field(...)
-    __properties = ["component", "response"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    WebAuthn Challenge response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-authenticator-webauthn'
+    response: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["component", "response"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AuthenticatorWebAuthnChallengeResponseRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of AuthenticatorWebAuthnChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AuthenticatorWebAuthnChallengeResponseRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of AuthenticatorWebAuthnChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AuthenticatorWebAuthnChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AuthenticatorWebAuthnChallengeResponseRequest.parse_obj({
+        _obj = cls.model_validate({
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-webauthn',
             "response": obj.get("response")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/auto_submit_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_password_set_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, constr
-
-class AutoSubmitChallengeResponseRequest(BaseModel):
-    """
-    Pseudo class for autosubmit response  # noqa: E501
+class UserPasswordSetRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-autosubmit'
-    __properties = ["component"]
+    UserPasswordSetRequest
+    """ # noqa: E501
+    password: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["password"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AutoSubmitChallengeResponseRequest:
-        """Create an instance of AutoSubmitChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserPasswordSetRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AutoSubmitChallengeResponseRequest:
-        """Create an instance of AutoSubmitChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserPasswordSetRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AutoSubmitChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AutoSubmitChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-autosubmit'
+        _obj = cls.model_validate({
+            "password": obj.get("password")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/autosubmit_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/captcha_stage_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,93 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class AutosubmitChallenge(BaseModel):
-    """
-    Autosubmit challenge used to send and navigate a POST request  # noqa: E501
+class CaptchaStageRequest(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-autosubmit'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    url: StrictStr = Field(...)
-    attrs: Dict[str, StrictStr] = Field(...)
-    title: Optional[StrictStr] = None
-    __properties = ["type", "flow_info", "component", "response_errors", "url", "attrs", "title"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CaptchaStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    public_key: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Public key, acquired your captcha Provider.")
+    private_key: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Private key, acquired your captcha Provider.")
+    js_url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    api_url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "public_key", "private_key", "js_url", "api_url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> AutosubmitChallenge:
-        """Create an instance of AutosubmitChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CaptchaStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+        _items = []
+        if self.flow_set:
+            for _item in self.flow_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> AutosubmitChallenge:
-        """Create an instance of AutosubmitChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CaptchaStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return AutosubmitChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = AutosubmitChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-autosubmit',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "url": obj.get("url"),
-            "attrs": obj.get("attrs"),
-            "title": obj.get("title")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "public_key": obj.get("public_key"),
+            "private_key": obj.get("private_key"),
+            "js_url": obj.get("js_url"),
+            "api_url": obj.get("api_url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/backends_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/client_type_enum.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,34 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class BackendsEnum(str, Enum):
+class ClientTypeEnum(str, Enum):
     """
-    BackendsEnum
+    ClientTypeEnum
     """
 
     """
     allowed enum values
     """
-    AUTHENTIK_DOT_CORE_DOT_AUTH_DOT_INBUILT_BACKEND = 'authentik.core.auth.InbuiltBackend'
-    AUTHENTIK_DOT_CORE_DOT_AUTH_DOT_TOKEN_BACKEND = 'authentik.core.auth.TokenBackend'
-    AUTHENTIK_DOT_SOURCES_DOT_LDAP_DOT_AUTH_DOT_LDAP_BACKEND = 'authentik.sources.ldap.auth.LDAPBackend'
+    CONFIDENTIAL = 'confidential'
+    PUBLIC = 'public'
 
     @classmethod
-    def from_json(cls, json_str: str) -> BackendsEnum:
-        """Create an instance of BackendsEnum from a JSON string"""
-        return BackendsEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ClientTypeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/binding_type_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_response_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,34 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class BindingTypeEnum(str, Enum):
+class DuoResponseEnum(str, Enum):
     """
-    BindingTypeEnum
+    DuoResponseEnum
     """
 
     """
     allowed enum values
     """
-    REDIRECT = 'REDIRECT'
-    POST = 'POST'
-    POST_AUTO = 'POST_AUTO'
+    SUCCESS = 'success'
+    WAITING = 'waiting'
+    INVALID = 'invalid'
 
     @classmethod
-    def from_json(cls, json_str: str) -> BindingTypeEnum:
-        """Create an instance of BindingTypeEnum from a JSON string"""
-        return BindingTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DuoResponseEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_file.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_file.py`

 * *Files 17% similar despite different names*

```diff
@@ -15,69 +15,87 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.metadata import Metadata
+from typing import Optional, Set
+from typing_extensions import Self
 
 class BlueprintFile(BaseModel):
     """
     BlueprintFile
-    """
-    path: StrictStr = Field(...)
-    last_m: datetime = Field(...)
-    hash: StrictStr = Field(...)
-    meta: Metadata = Field(...)
-    __properties = ["path", "last_m", "hash", "meta"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    path: StrictStr
+    last_m: datetime
+    hash: StrictStr
+    meta: Metadata
+    __properties: ClassVar[List[str]] = ["path", "last_m", "hash", "meta"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BlueprintFile:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of BlueprintFile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "meta",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "meta",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
             _dict['meta'] = self.meta.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BlueprintFile:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of BlueprintFile from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BlueprintFile.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BlueprintFile.parse_obj({
+        _obj = cls.model_validate({
             "path": obj.get("path"),
             "last_m": obj.get("last_m"),
             "hash": obj.get("hash"),
-            "meta": Metadata.from_dict(obj.get("meta")) if obj.get("meta") is not None else None
+            "meta": Metadata.from_dict(obj["meta"]) if obj.get("meta") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_instance.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -15,95 +15,98 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from authentik_client.models.blueprint_instance_status_enum import BlueprintInstanceStatusEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class BlueprintInstance(BaseModel):
+class UserRequest(BaseModel):
     """
-    Info about a single blueprint instance file  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    path: Optional[StrictStr] = ''
-    context: Optional[Any] = None
-    last_applied: datetime = Field(...)
-    last_applied_hash: StrictStr = Field(...)
-    status: BlueprintInstanceStatusEnum = Field(...)
-    enabled: Optional[StrictBool] = None
-    managed_models: conlist(StrictStr) = Field(...)
-    metadata: Optional[Any] = Field(...)
-    content: Optional[StrictStr] = None
-    __properties = ["pk", "name", "path", "context", "last_applied", "last_applied_hash", "status", "enabled", "managed_models", "metadata", "content"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User Serializer
+    """ # noqa: E501
+    username: Annotated[str, Field(min_length=1, strict=True, max_length=150)]
+    name: StrictStr = Field(description="User's display name.")
+    is_active: Optional[StrictBool] = Field(default=None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
+    last_login: Optional[datetime] = None
+    groups: Optional[List[StrictStr]] = None
+    email: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
+    attributes: Optional[Dict[str, Any]] = None
+    path: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    type: Optional[UserTypeEnum] = None
+    __properties: ClassVar[List[str]] = ["username", "name", "is_active", "last_login", "groups", "email", "attributes", "path", "type"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BlueprintInstance:
-        """Create an instance of BlueprintInstance from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "last_applied",
-                            "last_applied_hash",
-                            "status",
-                            "managed_models",
-                            "metadata",
-                          },
-                          exclude_none=True)
-        # set to None if context (nullable) is None
-        # and __fields_set__ contains the field
-        if self.context is None and "context" in self.__fields_set__:
-            _dict['context'] = None
-
-        # set to None if metadata (nullable) is None
-        # and __fields_set__ contains the field
-        if self.metadata is None and "metadata" in self.__fields_set__:
-            _dict['metadata'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if last_login (nullable) is None
+        # and model_fields_set contains the field
+        if self.last_login is None and "last_login" in self.model_fields_set:
+            _dict['last_login'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BlueprintInstance:
-        """Create an instance of BlueprintInstance from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BlueprintInstance.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BlueprintInstance.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
+            "username": obj.get("username"),
             "name": obj.get("name"),
-            "path": obj.get("path") if obj.get("path") is not None else '',
-            "context": obj.get("context"),
-            "last_applied": obj.get("last_applied"),
-            "last_applied_hash": obj.get("last_applied_hash"),
-            "status": obj.get("status"),
-            "enabled": obj.get("enabled"),
-            "managed_models": obj.get("managed_models"),
-            "metadata": obj.get("metadata"),
-            "content": obj.get("content")
+            "is_active": obj.get("is_active"),
+            "last_login": obj.get("last_login"),
+            "groups": obj.get("groups"),
+            "email": obj.get("email"),
+            "attributes": obj.get("attributes"),
+            "path": obj.get("path"),
+            "type": obj.get("type")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_instance_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_blueprint_instance_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,70 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-
-class BlueprintInstanceRequest(BaseModel):
-    """
-    Info about a single blueprint instance file  # noqa: E501
+class PatchedBlueprintInstanceRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
+    Info about a single blueprint instance file
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     path: Optional[StrictStr] = ''
     context: Optional[Any] = None
     enabled: Optional[StrictBool] = None
     content: Optional[StrictStr] = None
-    __properties = ["name", "path", "context", "enabled", "content"]
+    __properties: ClassVar[List[str]] = ["name", "path", "context", "enabled", "content"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BlueprintInstanceRequest:
-        """Create an instance of BlueprintInstanceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedBlueprintInstanceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if context (nullable) is None
-        # and __fields_set__ contains the field
-        if self.context is None and "context" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.context is None and "context" in self.model_fields_set:
             _dict['context'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BlueprintInstanceRequest:
-        """Create an instance of BlueprintInstanceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedBlueprintInstanceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BlueprintInstanceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BlueprintInstanceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "path": obj.get("path") if obj.get("path") is not None else '',
             "context": obj.get("context"),
             "enabled": obj.get("enabled"),
             "content": obj.get("content")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/blueprint_instance_status_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/contextual_flow_info_layout_enum.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,36 +9,33 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class BlueprintInstanceStatusEnum(str, Enum):
+class ContextualFlowInfoLayoutEnum(str, Enum):
     """
-    BlueprintInstanceStatusEnum
+    ContextualFlowInfoLayoutEnum
     """
 
     """
     allowed enum values
     """
-    SUCCESSFUL = 'successful'
-    WARNING = 'warning'
-    ERROR = 'error'
-    ORPHANED = 'orphaned'
-    UNKNOWN = 'unknown'
+    STACKED = 'stacked'
+    CONTENT_LEFT = 'content_left'
+    CONTENT_RIGHT = 'content_right'
+    SIDEBAR_LEFT = 'sidebar_left'
+    SIDEBAR_RIGHT = 'sidebar_right'
 
     @classmethod
-    def from_json(cls, json_str: str) -> BlueprintInstanceStatusEnum:
-        """Create an instance of BlueprintInstanceStatusEnum from a JSON string"""
-        return BlueprintInstanceStatusEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ContextualFlowInfoLayoutEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/brand.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/brand.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,115 +14,132 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Brand(BaseModel):
     """
-    Brand Serializer  # noqa: E501
-    """
-    brand_uuid: StrictStr = Field(...)
-    domain: StrictStr = Field(..., description="Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`")
+    Brand Serializer
+    """ # noqa: E501
+    brand_uuid: StrictStr
+    domain: StrictStr = Field(description="Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`")
     default: Optional[StrictBool] = None
     branding_title: Optional[StrictStr] = None
     branding_logo: Optional[StrictStr] = None
     branding_favicon: Optional[StrictStr] = None
     flow_authentication: Optional[StrictStr] = None
     flow_invalidation: Optional[StrictStr] = None
     flow_recovery: Optional[StrictStr] = None
     flow_unenrollment: Optional[StrictStr] = None
     flow_user_settings: Optional[StrictStr] = None
     flow_device_code: Optional[StrictStr] = None
-    web_certificate: Optional[StrictStr] = Field(None, description="Web Certificate used by the authentik Core webserver.")
+    web_certificate: Optional[StrictStr] = Field(default=None, description="Web Certificate used by the authentik Core webserver.")
     attributes: Optional[Any] = None
-    __properties = ["brand_uuid", "domain", "default", "branding_title", "branding_logo", "branding_favicon", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "web_certificate", "attributes"]
+    __properties: ClassVar[List[str]] = ["brand_uuid", "domain", "default", "branding_title", "branding_logo", "branding_favicon", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "web_certificate", "attributes"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Brand:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Brand from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "brand_uuid",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "brand_uuid",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if flow_authentication (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_authentication is None and "flow_authentication" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_authentication is None and "flow_authentication" in self.model_fields_set:
             _dict['flow_authentication'] = None
 
         # set to None if flow_invalidation (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_invalidation is None and "flow_invalidation" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_invalidation is None and "flow_invalidation" in self.model_fields_set:
             _dict['flow_invalidation'] = None
 
         # set to None if flow_recovery (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_recovery is None and "flow_recovery" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_recovery is None and "flow_recovery" in self.model_fields_set:
             _dict['flow_recovery'] = None
 
         # set to None if flow_unenrollment (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_unenrollment is None and "flow_unenrollment" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_unenrollment is None and "flow_unenrollment" in self.model_fields_set:
             _dict['flow_unenrollment'] = None
 
         # set to None if flow_user_settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_user_settings is None and "flow_user_settings" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_user_settings is None and "flow_user_settings" in self.model_fields_set:
             _dict['flow_user_settings'] = None
 
         # set to None if flow_device_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_device_code is None and "flow_device_code" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_device_code is None and "flow_device_code" in self.model_fields_set:
             _dict['flow_device_code'] = None
 
         # set to None if web_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.web_certificate is None and "web_certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.web_certificate is None and "web_certificate" in self.model_fields_set:
             _dict['web_certificate'] = None
 
         # set to None if attributes (nullable) is None
-        # and __fields_set__ contains the field
-        if self.attributes is None and "attributes" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.attributes is None and "attributes" in self.model_fields_set:
             _dict['attributes'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Brand:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Brand from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Brand.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Brand.parse_obj({
+        _obj = cls.model_validate({
             "brand_uuid": obj.get("brand_uuid"),
             "domain": obj.get("domain"),
             "default": obj.get("default"),
             "branding_title": obj.get("branding_title"),
             "branding_logo": obj.get("branding_logo"),
             "branding_favicon": obj.get("branding_favicon"),
             "flow_authentication": obj.get("flow_authentication"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/brand_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_event_matcher_policy_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,123 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.app_enum import AppEnum
+from authentik_client.models.event_actions import EventActions
+from authentik_client.models.model_enum import ModelEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-
-class BrandRequest(BaseModel):
-    """
-    Brand Serializer  # noqa: E501
+class PatchedEventMatcherPolicyRequest(BaseModel):
     """
-    domain: constr(strict=True, min_length=1) = Field(..., description="Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`")
-    default: Optional[StrictBool] = None
-    branding_title: Optional[constr(strict=True, min_length=1)] = None
-    branding_logo: Optional[constr(strict=True, min_length=1)] = None
-    branding_favicon: Optional[constr(strict=True, min_length=1)] = None
-    flow_authentication: Optional[StrictStr] = None
-    flow_invalidation: Optional[StrictStr] = None
-    flow_recovery: Optional[StrictStr] = None
-    flow_unenrollment: Optional[StrictStr] = None
-    flow_user_settings: Optional[StrictStr] = None
-    flow_device_code: Optional[StrictStr] = None
-    web_certificate: Optional[StrictStr] = Field(None, description="Web Certificate used by the authentik Core webserver.")
-    attributes: Optional[Any] = None
-    __properties = ["domain", "default", "branding_title", "branding_logo", "branding_favicon", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "web_certificate", "attributes"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Event Matcher Policy Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    action: Optional[EventActions] = Field(default=None, description="Match created events with this action type. When left empty, all action types will be matched.")
+    client_ip: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Matches Event's Client IP (strict matching, for network matching use an Expression Policy)")
+    app: Optional[AppEnum] = Field(default=None, description="Match events created by selected application. When left empty, all applications are matched.")
+    model: Optional[ModelEnum] = Field(default=None, description="Match events created by selected model. When left empty, all models are matched. When an app is selected, all the application's models are matched.")
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "action", "client_ip", "app", "model"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> BrandRequest:
-        """Create an instance of BrandRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedEventMatcherPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if flow_authentication (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_authentication is None and "flow_authentication" in self.__fields_set__:
-            _dict['flow_authentication'] = None
-
-        # set to None if flow_invalidation (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_invalidation is None and "flow_invalidation" in self.__fields_set__:
-            _dict['flow_invalidation'] = None
-
-        # set to None if flow_recovery (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_recovery is None and "flow_recovery" in self.__fields_set__:
-            _dict['flow_recovery'] = None
-
-        # set to None if flow_unenrollment (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_unenrollment is None and "flow_unenrollment" in self.__fields_set__:
-            _dict['flow_unenrollment'] = None
-
-        # set to None if flow_user_settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_user_settings is None and "flow_user_settings" in self.__fields_set__:
-            _dict['flow_user_settings'] = None
-
-        # set to None if flow_device_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_device_code is None and "flow_device_code" in self.__fields_set__:
-            _dict['flow_device_code'] = None
-
-        # set to None if web_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.web_certificate is None and "web_certificate" in self.__fields_set__:
-            _dict['web_certificate'] = None
-
-        # set to None if attributes (nullable) is None
-        # and __fields_set__ contains the field
-        if self.attributes is None and "attributes" in self.__fields_set__:
-            _dict['attributes'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if action (nullable) is None
+        # and model_fields_set contains the field
+        if self.action is None and "action" in self.model_fields_set:
+            _dict['action'] = None
+
+        # set to None if client_ip (nullable) is None
+        # and model_fields_set contains the field
+        if self.client_ip is None and "client_ip" in self.model_fields_set:
+            _dict['client_ip'] = None
+
+        # set to None if app (nullable) is None
+        # and model_fields_set contains the field
+        if self.app is None and "app" in self.model_fields_set:
+            _dict['app'] = None
+
+        # set to None if model (nullable) is None
+        # and model_fields_set contains the field
+        if self.model is None and "model" in self.model_fields_set:
+            _dict['model'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> BrandRequest:
-        """Create an instance of BrandRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedEventMatcherPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return BrandRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = BrandRequest.parse_obj({
-            "domain": obj.get("domain"),
-            "default": obj.get("default"),
-            "branding_title": obj.get("branding_title"),
-            "branding_logo": obj.get("branding_logo"),
-            "branding_favicon": obj.get("branding_favicon"),
-            "flow_authentication": obj.get("flow_authentication"),
-            "flow_invalidation": obj.get("flow_invalidation"),
-            "flow_recovery": obj.get("flow_recovery"),
-            "flow_unenrollment": obj.get("flow_unenrollment"),
-            "flow_user_settings": obj.get("flow_user_settings"),
-            "flow_device_code": obj.get("flow_device_code"),
-            "web_certificate": obj.get("web_certificate"),
-            "attributes": obj.get("attributes")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "execution_logging": obj.get("execution_logging"),
+            "action": obj.get("action"),
+            "client_ip": obj.get("client_ip"),
+            "app": obj.get("app"),
+            "model": obj.get("model")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/cache.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/cache.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,60 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Cache(BaseModel):
     """
-    Generic cache stats for an object  # noqa: E501
-    """
-    count: StrictInt = Field(...)
-    __properties = ["count"]
+    Generic cache stats for an object
+    """ # noqa: E501
+    count: StrictInt
+    __properties: ClassVar[List[str]] = ["count"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Cache:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Cache from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "count",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "count",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Cache:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Cache from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Cache.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Cache.parse_obj({
+        _obj = cls.model_validate({
             "count": obj.get("count")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_challenge.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,95 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class CaptchaChallenge(BaseModel):
-    """
-    Site public key  # noqa: E501
+class AuthenticatorTOTPChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    TOTP Setup challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-captcha'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    site_key: StrictStr = Field(...)
-    js_url: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "site_key", "js_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-stage-authenticator-totp'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    pending_user: StrictStr
+    pending_user_avatar: StrictStr
+    config_url: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "config_url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CaptchaChallenge:
-        """Create an instance of CaptchaChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CaptchaChallenge:
-        """Create an instance of CaptchaChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CaptchaChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CaptchaChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-captcha',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-totp',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "pending_user": obj.get("pending_user"),
             "pending_user_avatar": obj.get("pending_user_avatar"),
-            "site_key": obj.get("site_key"),
-            "js_url": obj.get("js_url")
+            "config_url": obj.get("config_url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_challenge_response_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,61 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class CaptchaChallengeResponseRequest(BaseModel):
-    """
-    Validate captcha token  # noqa: E501
+class AuthenticatorTOTPChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-captcha'
-    token: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["component", "token"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TOTP Challenge response, device is set by get_response_instance
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-authenticator-totp'
+    code: StrictInt
+    __properties: ClassVar[List[str]] = ["component", "code"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CaptchaChallengeResponseRequest:
-        """Create an instance of CaptchaChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CaptchaChallengeResponseRequest:
-        """Create an instance of CaptchaChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CaptchaChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CaptchaChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-captcha',
-            "token": obj.get("token")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-totp',
+            "code": obj.get("code")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/deny_stage.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,90 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
-class CaptchaStage(BaseModel):
-    """
-    CaptchaStage Serializer  # noqa: E501
+class DenyStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    public_key: StrictStr = Field(..., description="Public key, acquired your captcha Provider.")
-    js_url: Optional[StrictStr] = None
-    api_url: Optional[StrictStr] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "public_key", "js_url", "api_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DenyStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    deny_message: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "deny_message"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CaptchaStage:
-        """Create an instance of CaptchaStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DenyStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CaptchaStage:
-        """Create an instance of CaptchaStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DenyStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CaptchaStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CaptchaStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "public_key": obj.get("public_key"),
-            "js_url": obj.get("js_url"),
-            "api_url": obj.get("api_url")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "deny_message": obj.get("deny_message")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/captcha_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_challenge_response_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,77 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class CaptchaStageRequest(BaseModel):
-    """
-    CaptchaStage Serializer  # noqa: E501
+class IdentificationChallengeResponseRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    public_key: constr(strict=True, min_length=1) = Field(..., description="Public key, acquired your captcha Provider.")
-    private_key: constr(strict=True, min_length=1) = Field(..., description="Private key, acquired your captcha Provider.")
-    js_url: Optional[constr(strict=True, min_length=1)] = None
-    api_url: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["name", "flow_set", "public_key", "private_key", "js_url", "api_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Identification challenge
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-identification'
+    uid_field: Annotated[str, Field(min_length=1, strict=True)]
+    password: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["component", "uid_field", "password"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CaptchaStageRequest:
-        """Create an instance of CaptchaStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of IdentificationChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if password (nullable) is None
+        # and model_fields_set contains the field
+        if self.password is None and "password" in self.model_fields_set:
+            _dict['password'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CaptchaStageRequest:
-        """Create an instance of CaptchaStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of IdentificationChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CaptchaStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CaptchaStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "public_key": obj.get("public_key"),
-            "private_key": obj.get("private_key"),
-            "js_url": obj.get("js_url"),
-            "api_url": obj.get("api_url")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-identification',
+            "uid_field": obj.get("uid_field"),
+            "password": obj.get("password")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_data.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/permission_assign_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,60 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.model_enum import ModelEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class CertificateData(BaseModel):
-    """
-    Get CertificateKeyPair's data  # noqa: E501
+class PermissionAssignRequest(BaseModel):
     """
-    data: StrictStr = Field(...)
-    __properties = ["data"]
+    Request to assign a new permission
+    """ # noqa: E501
+    permissions: List[Annotated[str, Field(min_length=1, strict=True)]]
+    model: Optional[ModelEnum] = None
+    object_pk: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["permissions", "model", "object_pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CertificateData:
-        """Create an instance of CertificateData from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PermissionAssignRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "data",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CertificateData:
-        """Create an instance of CertificateData from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PermissionAssignRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CertificateData.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CertificateData.parse_obj({
-            "data": obj.get("data")
+        _obj = cls.model_validate({
+            "permissions": obj.get("permissions"),
+            "model": obj.get("model"),
+            "object_pk": obj.get("object_pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_generation_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_diagram.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,63 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
-
-class CertificateGenerationRequest(BaseModel):
-    """
-    Certificate generation parameters  # noqa: E501
+class FlowDiagram(BaseModel):
     """
-    common_name: constr(strict=True, min_length=1) = Field(...)
-    subject_alt_name: Optional[StrictStr] = None
-    validity_days: StrictInt = Field(...)
-    __properties = ["common_name", "subject_alt_name", "validity_days"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    response of the flow's diagram action
+    """ # noqa: E501
+    diagram: StrictStr
+    __properties: ClassVar[List[str]] = ["diagram"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CertificateGenerationRequest:
-        """Create an instance of CertificateGenerationRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlowDiagram from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "diagram",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CertificateGenerationRequest:
-        """Create an instance of CertificateGenerationRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlowDiagram from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CertificateGenerationRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CertificateGenerationRequest.parse_obj({
-            "common_name": obj.get("common_name"),
-            "subject_alt_name": obj.get("subject_alt_name"),
-            "validity_days": obj.get("validity_days")
+        _obj = cls.model_validate({
+            "diagram": obj.get("diagram")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_key_pair.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_key_pair.py`

 * *Files 14% similar despite different names*

```diff
@@ -15,110 +15,137 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class CertificateKeyPair(BaseModel):
     """
-    CertificateKeyPair Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    fingerprint_sha256: Optional[StrictStr] = Field(..., description="Get certificate Hash (SHA256)")
-    fingerprint_sha1: Optional[StrictStr] = Field(..., description="Get certificate Hash (SHA1)")
-    cert_expiry: Optional[datetime] = Field(..., description="Get certificate expiry")
-    cert_subject: Optional[StrictStr] = Field(..., description="Get certificate subject as full rfc4514")
-    private_key_available: StrictBool = Field(..., description="Show if this keypair has a private key configured or not")
-    private_key_type: Optional[StrictStr] = Field(..., description="Get the private key's type, if set")
-    certificate_download_url: StrictStr = Field(..., description="Get URL to download certificate")
-    private_key_download_url: StrictStr = Field(..., description="Get URL to download private key")
-    managed: Optional[StrictStr] = Field(..., description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    __properties = ["pk", "name", "fingerprint_sha256", "fingerprint_sha1", "cert_expiry", "cert_subject", "private_key_available", "private_key_type", "certificate_download_url", "private_key_download_url", "managed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CertificateKeyPair Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    fingerprint_sha256: Optional[StrictStr] = Field(description="Get certificate Hash (SHA256)")
+    fingerprint_sha1: Optional[StrictStr] = Field(description="Get certificate Hash (SHA1)")
+    cert_expiry: Optional[datetime] = Field(description="Get certificate expiry")
+    cert_subject: Optional[StrictStr] = Field(description="Get certificate subject as full rfc4514")
+    private_key_available: StrictBool = Field(description="Show if this keypair has a private key configured or not")
+    private_key_type: Optional[StrictStr] = Field(description="Get the private key's type, if set")
+    certificate_download_url: StrictStr = Field(description="Get URL to download certificate")
+    private_key_download_url: StrictStr = Field(description="Get URL to download private key")
+    managed: Optional[StrictStr] = Field(description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "fingerprint_sha256", "fingerprint_sha1", "cert_expiry", "cert_subject", "private_key_available", "private_key_type", "certificate_download_url", "private_key_download_url", "managed"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CertificateKeyPair:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of CertificateKeyPair from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "fingerprint_sha256",
-                            "fingerprint_sha1",
-                            "cert_expiry",
-                            "cert_subject",
-                            "private_key_available",
-                            "private_key_type",
-                            "certificate_download_url",
-                            "private_key_download_url",
-                            "managed",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "fingerprint_sha256",
+            "fingerprint_sha1",
+            "cert_expiry",
+            "cert_subject",
+            "private_key_available",
+            "private_key_type",
+            "certificate_download_url",
+            "private_key_download_url",
+            "managed",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if fingerprint_sha256 (nullable) is None
-        # and __fields_set__ contains the field
-        if self.fingerprint_sha256 is None and "fingerprint_sha256" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.fingerprint_sha256 is None and "fingerprint_sha256" in self.model_fields_set:
             _dict['fingerprint_sha256'] = None
 
         # set to None if fingerprint_sha1 (nullable) is None
-        # and __fields_set__ contains the field
-        if self.fingerprint_sha1 is None and "fingerprint_sha1" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.fingerprint_sha1 is None and "fingerprint_sha1" in self.model_fields_set:
             _dict['fingerprint_sha1'] = None
 
         # set to None if cert_expiry (nullable) is None
-        # and __fields_set__ contains the field
-        if self.cert_expiry is None and "cert_expiry" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.cert_expiry is None and "cert_expiry" in self.model_fields_set:
             _dict['cert_expiry'] = None
 
         # set to None if cert_subject (nullable) is None
-        # and __fields_set__ contains the field
-        if self.cert_subject is None and "cert_subject" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.cert_subject is None and "cert_subject" in self.model_fields_set:
             _dict['cert_subject'] = None
 
         # set to None if private_key_type (nullable) is None
-        # and __fields_set__ contains the field
-        if self.private_key_type is None and "private_key_type" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.private_key_type is None and "private_key_type" in self.model_fields_set:
             _dict['private_key_type'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CertificateKeyPair:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of CertificateKeyPair from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CertificateKeyPair.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CertificateKeyPair.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "fingerprint_sha256": obj.get("fingerprint_sha256"),
             "fingerprint_sha1": obj.get("fingerprint_sha1"),
             "cert_expiry": obj.get("cert_expiry"),
             "cert_subject": obj.get("cert_subject"),
             "private_key_available": obj.get("private_key_available"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/certificate_key_pair_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_key_pair_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,63 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class CertificateKeyPairRequest(BaseModel):
     """
-    CertificateKeyPair Serializer  # noqa: E501
-    """
-    name: constr(strict=True, min_length=1) = Field(...)
-    certificate_data: constr(strict=True, min_length=1) = Field(..., description="PEM-encoded Certificate data")
-    key_data: Optional[StrictStr] = Field(None, description="Optional Private Key. If this is set, you can use this keypair for encryption.")
-    __properties = ["name", "certificate_data", "key_data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CertificateKeyPair Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    certificate_data: Annotated[str, Field(min_length=1, strict=True)] = Field(description="PEM-encoded Certificate data")
+    key_data: Optional[StrictStr] = Field(default=None, description="Optional Private Key. If this is set, you can use this keypair for encryption.")
+    __properties: ClassVar[List[str]] = ["name", "certificate_data", "key_data"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CertificateKeyPairRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of CertificateKeyPairRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CertificateKeyPairRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of CertificateKeyPairRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CertificateKeyPairRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CertificateKeyPairRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "certificate_data": obj.get("certificate_data"),
             "key_data": obj.get("key_data")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/challenge_choices.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ui_theme_enum.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,34 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ChallengeChoices(str, Enum):
+class UiThemeEnum(str, Enum):
     """
-    ChallengeChoices
+    UiThemeEnum
     """
 
     """
     allowed enum values
     """
-    NATIVE = 'native'
-    SHELL = 'shell'
-    REDIRECT = 'redirect'
+    AUTOMATIC = 'automatic'
+    LIGHT = 'light'
+    DARK = 'dark'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChallengeChoices:
-        """Create an instance of ChallengeChoices from a JSON string"""
-        return ChallengeChoices(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UiThemeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/challenge_types.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/challenge_types.py`

 * *Files 3% similar despite different names*

```diff
@@ -10,21 +10,18 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import json
 import pprint
-import re  # noqa: F401
-
+from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
 from authentik_client.models.access_denied_challenge import AccessDeniedChallenge
 from authentik_client.models.apple_login_challenge import AppleLoginChallenge
 from authentik_client.models.authenticator_duo_challenge import AuthenticatorDuoChallenge
 from authentik_client.models.authenticator_sms_challenge import AuthenticatorSMSChallenge
 from authentik_client.models.authenticator_static_challenge import AuthenticatorStaticChallenge
 from authentik_client.models.authenticator_totp_challenge import AuthenticatorTOTPChallenge
 from authentik_client.models.authenticator_validation_challenge import AuthenticatorValidationChallenge
@@ -40,16 +37,17 @@
 from authentik_client.models.o_auth_device_code_finish_challenge import OAuthDeviceCodeFinishChallenge
 from authentik_client.models.password_challenge import PasswordChallenge
 from authentik_client.models.plex_authentication_challenge import PlexAuthenticationChallenge
 from authentik_client.models.prompt_challenge import PromptChallenge
 from authentik_client.models.redirect_challenge import RedirectChallenge
 from authentik_client.models.shell_challenge import ShellChallenge
 from authentik_client.models.user_login_challenge import UserLoginChallenge
-from typing import Union, Any, List, TYPE_CHECKING
 from pydantic import StrictStr, Field
+from typing import Union, List, Optional, Dict
+from typing_extensions import Literal, Self
 
 CHALLENGETYPES_ONE_OF_SCHEMAS = ["AccessDeniedChallenge", "AppleLoginChallenge", "AuthenticatorDuoChallenge", "AuthenticatorSMSChallenge", "AuthenticatorStaticChallenge", "AuthenticatorTOTPChallenge", "AuthenticatorValidationChallenge", "AuthenticatorWebAuthnChallenge", "AutosubmitChallenge", "CaptchaChallenge", "ConsentChallenge", "DummyChallenge", "EmailChallenge", "FlowErrorChallenge", "IdentificationChallenge", "OAuthDeviceCodeChallenge", "OAuthDeviceCodeFinishChallenge", "PasswordChallenge", "PlexAuthenticationChallenge", "PromptChallenge", "RedirectChallenge", "ShellChallenge", "UserLoginChallenge"]
 
 class ChallengeTypes(BaseModel):
     """
     ChallengeTypes
     """
@@ -95,39 +93,39 @@
     oneof_schema_20_validator: Optional[PromptChallenge] = None
     # data type: RedirectChallenge
     oneof_schema_21_validator: Optional[RedirectChallenge] = None
     # data type: ShellChallenge
     oneof_schema_22_validator: Optional[ShellChallenge] = None
     # data type: UserLoginChallenge
     oneof_schema_23_validator: Optional[UserLoginChallenge] = None
-    if TYPE_CHECKING:
-        actual_instance: Union[AccessDeniedChallenge, AppleLoginChallenge, AuthenticatorDuoChallenge, AuthenticatorSMSChallenge, AuthenticatorStaticChallenge, AuthenticatorTOTPChallenge, AuthenticatorValidationChallenge, AuthenticatorWebAuthnChallenge, AutosubmitChallenge, CaptchaChallenge, ConsentChallenge, DummyChallenge, EmailChallenge, FlowErrorChallenge, IdentificationChallenge, OAuthDeviceCodeChallenge, OAuthDeviceCodeFinishChallenge, PasswordChallenge, PlexAuthenticationChallenge, PromptChallenge, RedirectChallenge, ShellChallenge, UserLoginChallenge]
-    else:
-        actual_instance: Any
-    one_of_schemas: List[str] = Field(CHALLENGETYPES_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[AccessDeniedChallenge, AppleLoginChallenge, AuthenticatorDuoChallenge, AuthenticatorSMSChallenge, AuthenticatorStaticChallenge, AuthenticatorTOTPChallenge, AuthenticatorValidationChallenge, AuthenticatorWebAuthnChallenge, AutosubmitChallenge, CaptchaChallenge, ConsentChallenge, DummyChallenge, EmailChallenge, FlowErrorChallenge, IdentificationChallenge, OAuthDeviceCodeChallenge, OAuthDeviceCodeFinishChallenge, PasswordChallenge, PlexAuthenticationChallenge, PromptChallenge, RedirectChallenge, ShellChallenge, UserLoginChallenge]] = None
+    one_of_schemas: List[str] = Field(default=Literal["AccessDeniedChallenge", "AppleLoginChallenge", "AuthenticatorDuoChallenge", "AuthenticatorSMSChallenge", "AuthenticatorStaticChallenge", "AuthenticatorTOTPChallenge", "AuthenticatorValidationChallenge", "AuthenticatorWebAuthnChallenge", "AutosubmitChallenge", "CaptchaChallenge", "ConsentChallenge", "DummyChallenge", "EmailChallenge", "FlowErrorChallenge", "IdentificationChallenge", "OAuthDeviceCodeChallenge", "OAuthDeviceCodeFinishChallenge", "PasswordChallenge", "PlexAuthenticationChallenge", "PromptChallenge", "RedirectChallenge", "ShellChallenge", "UserLoginChallenge"])
+
+    model_config = ConfigDict(
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
     def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = ChallengeTypes.construct()
+        instance = ChallengeTypes.model_construct()
         error_messages = []
         match = 0
         # validate data type: AccessDeniedChallenge
         if not isinstance(v, AccessDeniedChallenge):
             error_messages.append(f"Error! Input type `{type(v)}` is not `AccessDeniedChallenge`")
         else:
             match += 1
@@ -247,21 +245,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in ChallengeTypes with oneOf schemas: AccessDeniedChallenge, AppleLoginChallenge, AuthenticatorDuoChallenge, AuthenticatorSMSChallenge, AuthenticatorStaticChallenge, AuthenticatorTOTPChallenge, AuthenticatorValidationChallenge, AuthenticatorWebAuthnChallenge, AutosubmitChallenge, CaptchaChallenge, ConsentChallenge, DummyChallenge, EmailChallenge, FlowErrorChallenge, IdentificationChallenge, OAuthDeviceCodeChallenge, OAuthDeviceCodeFinishChallenge, PasswordChallenge, PlexAuthenticationChallenge, PromptChallenge, RedirectChallenge, ShellChallenge, UserLoginChallenge. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ChallengeTypes:
+    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> ChallengeTypes:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = ChallengeTypes.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into AccessDeniedChallenge
         try:
             instance.actual_instance = AccessDeniedChallenge.from_json(json_str)
             match += 1
@@ -410,30 +408,28 @@
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
+        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Optional[Union[Dict[str, Any], AccessDeniedChallenge, AppleLoginChallenge, AuthenticatorDuoChallenge, AuthenticatorSMSChallenge, AuthenticatorStaticChallenge, AuthenticatorTOTPChallenge, AuthenticatorValidationChallenge, AuthenticatorWebAuthnChallenge, AutosubmitChallenge, CaptchaChallenge, ConsentChallenge, DummyChallenge, EmailChallenge, FlowErrorChallenge, IdentificationChallenge, OAuthDeviceCodeChallenge, OAuthDeviceCodeFinishChallenge, PasswordChallenge, PlexAuthenticationChallenge, PromptChallenge, RedirectChallenge, ShellChallenge, UserLoginChallenge]]:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
-        to_dict = getattr(self.actual_instance, "to_dict", None)
-        if callable(to_dict):
+        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/client_type_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport_mode_enum.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,33 +9,32 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ClientTypeEnum(str, Enum):
+class NotificationTransportModeEnum(str, Enum):
     """
-    ClientTypeEnum
+    NotificationTransportModeEnum
     """
 
     """
     allowed enum values
     """
-    CONFIDENTIAL = 'confidential'
-    PUBLIC = 'public'
+    LOCAL = 'local'
+    WEBHOOK = 'webhook'
+    WEBHOOK_SLACK = 'webhook_slack'
+    EMAIL = 'email'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ClientTypeEnum:
-        """Create an instance of ClientTypeEnum from a JSON string"""
-        return ClientTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of NotificationTransportModeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/config.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/config.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,72 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, StrictInt, conlist
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.capabilities_enum import CapabilitiesEnum
 from authentik_client.models.error_reporting_config import ErrorReportingConfig
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Config(BaseModel):
     """
-    Serialize authentik Config into DRF Object  # noqa: E501
-    """
-    error_reporting: ErrorReportingConfig = Field(...)
-    capabilities: conlist(CapabilitiesEnum) = Field(...)
-    cache_timeout: StrictInt = Field(...)
-    cache_timeout_flows: StrictInt = Field(...)
-    cache_timeout_policies: StrictInt = Field(...)
-    cache_timeout_reputation: StrictInt = Field(...)
-    __properties = ["error_reporting", "capabilities", "cache_timeout", "cache_timeout_flows", "cache_timeout_policies", "cache_timeout_reputation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serialize authentik Config into DRF Object
+    """ # noqa: E501
+    error_reporting: ErrorReportingConfig
+    capabilities: List[CapabilitiesEnum]
+    cache_timeout: StrictInt
+    cache_timeout_flows: StrictInt
+    cache_timeout_policies: StrictInt
+    cache_timeout_reputation: StrictInt
+    __properties: ClassVar[List[str]] = ["error_reporting", "capabilities", "cache_timeout", "cache_timeout_flows", "cache_timeout_policies", "cache_timeout_reputation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Config:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Config from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of error_reporting
         if self.error_reporting:
             _dict['error_reporting'] = self.error_reporting.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Config:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Config from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Config.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Config.parse_obj({
-            "error_reporting": ErrorReportingConfig.from_dict(obj.get("error_reporting")) if obj.get("error_reporting") is not None else None,
+        _obj = cls.model_validate({
+            "error_reporting": ErrorReportingConfig.from_dict(obj["error_reporting"]) if obj.get("error_reporting") is not None else None,
             "capabilities": obj.get("capabilities"),
             "cache_timeout": obj.get("cache_timeout"),
             "cache_timeout_flows": obj.get("cache_timeout_flows"),
             "cache_timeout_policies": obj.get("cache_timeout_policies"),
             "cache_timeout_reputation": obj.get("cache_timeout_reputation")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/connection_token.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_stage_manual_device_import_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,84 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
-from authentik_client.models.endpoint import Endpoint
-from authentik_client.models.group_member import GroupMember
-from authentik_client.models.rac_provider import RACProvider
-
-class ConnectionToken(BaseModel):
-    """
-    ConnectionToken Serializer  # noqa: E501
+class AuthenticatorDuoStageManualDeviceImportRequest(BaseModel):
     """
-    pk: Optional[StrictStr] = None
-    provider: StrictInt = Field(...)
-    provider_obj: RACProvider = Field(...)
-    endpoint: StrictStr = Field(...)
-    endpoint_obj: Endpoint = Field(...)
-    user: GroupMember = Field(...)
-    __properties = ["pk", "provider", "provider_obj", "endpoint", "endpoint_obj", "user"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorDuoStageManualDeviceImportRequest
+    """ # noqa: E501
+    duo_user_id: Annotated[str, Field(min_length=1, strict=True)]
+    username: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["duo_user_id", "username"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConnectionToken:
-        """Create an instance of ConnectionToken from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorDuoStageManualDeviceImportRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "provider_obj",
-                            "endpoint_obj",
-                            "user",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of provider_obj
-        if self.provider_obj:
-            _dict['provider_obj'] = self.provider_obj.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of endpoint_obj
-        if self.endpoint_obj:
-            _dict['endpoint_obj'] = self.endpoint_obj.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConnectionToken:
-        """Create an instance of ConnectionToken from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorDuoStageManualDeviceImportRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConnectionToken.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConnectionToken.parse_obj({
-            "pk": obj.get("pk"),
-            "provider": obj.get("provider"),
-            "provider_obj": RACProvider.from_dict(obj.get("provider_obj")) if obj.get("provider_obj") is not None else None,
-            "endpoint": obj.get("endpoint"),
-            "endpoint_obj": Endpoint.from_dict(obj.get("endpoint_obj")) if obj.get("endpoint_obj") is not None else None,
-            "user": GroupMember.from_dict(obj.get("user")) if obj.get("user") is not None else None
+        _obj = cls.model_validate({
+            "duo_user_id": obj.get("duo_user_id"),
+            "username": obj.get("username")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/connection_token_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/token_set_key_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,63 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr
-
-class ConnectionTokenRequest(BaseModel):
-    """
-    ConnectionToken Serializer  # noqa: E501
+class TokenSetKeyRequest(BaseModel):
     """
-    pk: Optional[StrictStr] = None
-    provider: StrictInt = Field(...)
-    endpoint: StrictStr = Field(...)
-    __properties = ["pk", "provider", "endpoint"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    TokenSetKeyRequest
+    """ # noqa: E501
+    key: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["key"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConnectionTokenRequest:
-        """Create an instance of ConnectionTokenRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TokenSetKeyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConnectionTokenRequest:
-        """Create an instance of ConnectionTokenRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TokenSetKeyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConnectionTokenRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConnectionTokenRequest.parse_obj({
-            "pk": obj.get("pk"),
-            "provider": obj.get("provider"),
-            "endpoint": obj.get("endpoint")
+        _obj = cls.model_validate({
+            "key": obj.get("key")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_challenge.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,70 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.consent_permission import ConsentPermission
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ConsentChallenge(BaseModel):
     """
-    Challenge info for consent screens  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Challenge info for consent screens
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-stage-consent'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    pending_user: StrictStr
+    pending_user_avatar: StrictStr
     header_text: Optional[StrictStr] = None
-    permissions: conlist(ConsentPermission) = Field(...)
-    additional_permissions: conlist(ConsentPermission) = Field(...)
-    token: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "header_text", "permissions", "additional_permissions", "token"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    permissions: List[ConsentPermission]
+    additional_permissions: List[ConsentPermission]
+    token: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "header_text", "permissions", "additional_permissions", "token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConsentChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ConsentChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         # override the default output from pydantic by calling `to_dict()` of each item in permissions (list)
         _items = []
         if self.permissions:
@@ -91,37 +107,37 @@
             for _item in self.additional_permissions:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['additional_permissions'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConsentChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ConsentChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConsentChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConsentChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-consent',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "pending_user": obj.get("pending_user"),
             "pending_user_avatar": obj.get("pending_user_avatar"),
             "header_text": obj.get("header_text"),
-            "permissions": [ConsentPermission.from_dict(_item) for _item in obj.get("permissions")] if obj.get("permissions") is not None else None,
-            "additional_permissions": [ConsentPermission.from_dict(_item) for _item in obj.get("additional_permissions")] if obj.get("additional_permissions") is not None else None,
+            "permissions": [ConsentPermission.from_dict(_item) for _item in obj["permissions"]] if obj.get("permissions") is not None else None,
+            "additional_permissions": [ConsentPermission.from_dict(_item) for _item in obj["additional_permissions"]] if obj.get("additional_permissions") is not None else None,
             "token": obj.get("token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_challenge_response_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,61 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class ConsentChallengeResponseRequest(BaseModel):
-    """
-    Consent challenge response, any valid response request is valid  # noqa: E501
+class OAuthDeviceCodeChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-consent'
-    token: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["component", "token"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Response that includes the user-entered device code
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-provider-oauth2-device-code'
+    code: StrictInt
+    __properties: ClassVar[List[str]] = ["component", "code"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConsentChallengeResponseRequest:
-        """Create an instance of ConsentChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OAuthDeviceCodeChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConsentChallengeResponseRequest:
-        """Create an instance of ConsentChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OAuthDeviceCodeChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConsentChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConsentChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-consent',
-            "token": obj.get("token")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-provider-oauth2-device-code',
+            "code": obj.get("code")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_permission.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_permission_assign_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,61 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.model_enum import ModelEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class ConsentPermission(BaseModel):
-    """
-    Permission used for consent  # noqa: E501
+class PatchedPermissionAssignRequest(BaseModel):
     """
-    name: StrictStr = Field(...)
-    id: StrictStr = Field(...)
-    __properties = ["name", "id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Request to assign a new permission
+    """ # noqa: E501
+    permissions: Optional[List[Annotated[str, Field(min_length=1, strict=True)]]] = None
+    model: Optional[ModelEnum] = None
+    object_pk: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["permissions", "model", "object_pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConsentPermission:
-        """Create an instance of ConsentPermission from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPermissionAssignRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConsentPermission:
-        """Create an instance of ConsentPermission from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPermissionAssignRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConsentPermission.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConsentPermission.parse_obj({
-            "name": obj.get("name"),
-            "id": obj.get("id")
+        _obj = cls.model_validate({
+            "permissions": obj.get("permissions"),
+            "model": obj.get("model"),
+            "object_pk": obj.get("object_pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,89 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.consent_stage_mode_enum import ConsentStageModeEnum
-from authentik_client.models.flow_set import FlowSet
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ConsentStage(BaseModel):
-    """
-    ConsentStage Serializer  # noqa: E501
+class ConsentStageRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
+    ConsentStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
     mode: Optional[ConsentStageModeEnum] = None
-    consent_expire_in: Optional[StrictStr] = Field(None, description="Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "mode", "consent_expire_in"]
+    consent_expire_in: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "mode", "consent_expire_in"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConsentStage:
-        """Create an instance of ConsentStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ConsentStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConsentStage:
-        """Create an instance of ConsentStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ConsentStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConsentStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConsentStage.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "mode": obj.get("mode"),
             "consent_expire_in": obj.get("consent_expire_in")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/consent_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/stage_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,74 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from authentik_client.models.consent_stage_mode_enum import ConsentStageModeEnum
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ConsentStageRequest(BaseModel):
-    """
-    ConsentStage Serializer  # noqa: E501
+class StageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    mode: Optional[ConsentStageModeEnum] = None
-    consent_expire_in: Optional[constr(strict=True, min_length=1)] = Field(None, description="Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["name", "flow_set", "mode", "consent_expire_in"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Stage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConsentStageRequest:
-        """Create an instance of ConsentStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConsentStageRequest:
-        """Create an instance of ConsentStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ConsentStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ConsentStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "mode": obj.get("mode"),
-            "consent_expire_in": obj.get("consent_expire_in")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/contextual_flow_info_layout_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/issuer_mode_enum.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,36 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ContextualFlowInfoLayoutEnum(str, Enum):
+class IssuerModeEnum(str, Enum):
     """
-    ContextualFlowInfoLayoutEnum
+    IssuerModeEnum
     """
 
     """
     allowed enum values
     """
-    STACKED = 'stacked'
-    CONTENT_LEFT = 'content_left'
-    CONTENT_RIGHT = 'content_right'
-    SIDEBAR_LEFT = 'sidebar_left'
-    SIDEBAR_RIGHT = 'sidebar_right'
+    GLOBAL = 'global'
+    PER_PROVIDER = 'per_provider'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ContextualFlowInfoLayoutEnum:
-        """Create an instance of ContextualFlowInfoLayoutEnum from a JSON string"""
-        return ContextualFlowInfoLayoutEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of IssuerModeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/coordinate.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/coordinate.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,63 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Coordinate(BaseModel):
     """
-    Coordinates for diagrams  # noqa: E501
-    """
-    x_cord: StrictInt = Field(...)
-    y_cord: StrictInt = Field(...)
-    __properties = ["x_cord", "y_cord"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Coordinates for diagrams
+    """ # noqa: E501
+    x_cord: StrictInt
+    y_cord: StrictInt
+    __properties: ClassVar[List[str]] = ["x_cord", "y_cord"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Coordinate:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Coordinate from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "x_cord",
-                            "y_cord",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "x_cord",
+            "y_cord",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Coordinate:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Coordinate from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Coordinate.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Coordinate.parse_obj({
+        _obj = cls.model_validate({
             "x_cord": obj.get("x_cord"),
             "y_cord": obj.get("y_cord")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/current_brand.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_write_stage_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,95 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from authentik_client.models.user_creation_mode_enum import UserCreationModeEnum
+from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.footer_link import FooterLink
-from authentik_client.models.ui_theme_enum import UiThemeEnum
-
-class CurrentBrand(BaseModel):
-    """
-    Partial brand information for styling  # noqa: E501
+class PatchedUserWriteStageRequest(BaseModel):
     """
-    matched_domain: StrictStr = Field(...)
-    branding_title: StrictStr = Field(...)
-    branding_logo: StrictStr = Field(...)
-    branding_favicon: StrictStr = Field(...)
-    ui_footer_links: conlist(FooterLink) = Field(...)
-    ui_theme: UiThemeEnum = Field(...)
-    flow_authentication: Optional[StrictStr] = None
-    flow_invalidation: Optional[StrictStr] = None
-    flow_recovery: Optional[StrictStr] = None
-    flow_unenrollment: Optional[StrictStr] = None
-    flow_user_settings: Optional[StrictStr] = None
-    flow_device_code: Optional[StrictStr] = None
-    default_locale: StrictStr = Field(...)
-    __properties = ["matched_domain", "branding_title", "branding_logo", "branding_favicon", "ui_footer_links", "ui_theme", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "default_locale"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserWriteStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    user_creation_mode: Optional[UserCreationModeEnum] = None
+    create_users_as_inactive: Optional[StrictBool] = Field(default=None, description="When set, newly created users are inactive and cannot login.")
+    create_users_group: Optional[StrictStr] = Field(default=None, description="Optionally add newly created users to this group.")
+    user_type: Optional[UserTypeEnum] = None
+    user_path_template: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "user_creation_mode", "create_users_as_inactive", "create_users_group", "user_type", "user_path_template"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CurrentBrand:
-        """Create an instance of CurrentBrand from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedUserWriteStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "ui_footer_links",
-                            "ui_theme",
-                            "default_locale",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in ui_footer_links (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
-        if self.ui_footer_links:
-            for _item in self.ui_footer_links:
+        if self.flow_set:
+            for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['ui_footer_links'] = _items
+            _dict['flow_set'] = _items
+        # set to None if create_users_group (nullable) is None
+        # and model_fields_set contains the field
+        if self.create_users_group is None and "create_users_group" in self.model_fields_set:
+            _dict['create_users_group'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CurrentBrand:
-        """Create an instance of CurrentBrand from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedUserWriteStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return CurrentBrand.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = CurrentBrand.parse_obj({
-            "matched_domain": obj.get("matched_domain"),
-            "branding_title": obj.get("branding_title"),
-            "branding_logo": obj.get("branding_logo"),
-            "branding_favicon": obj.get("branding_favicon"),
-            "ui_footer_links": [FooterLink.from_dict(_item) for _item in obj.get("ui_footer_links")] if obj.get("ui_footer_links") is not None else None,
-            "ui_theme": obj.get("ui_theme"),
-            "flow_authentication": obj.get("flow_authentication"),
-            "flow_invalidation": obj.get("flow_invalidation"),
-            "flow_recovery": obj.get("flow_recovery"),
-            "flow_unenrollment": obj.get("flow_unenrollment"),
-            "flow_user_settings": obj.get("flow_user_settings"),
-            "flow_device_code": obj.get("flow_device_code"),
-            "default_locale": obj.get("default_locale")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "user_creation_mode": obj.get("user_creation_mode"),
+            "create_users_as_inactive": obj.get("create_users_as_inactive"),
+            "create_users_group": obj.get("create_users_group"),
+            "user_type": obj.get("user_type"),
+            "user_path_template": obj.get("user_path_template")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/denied_action_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/device_classes_enum.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,34 +9,33 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class DeniedActionEnum(str, Enum):
+class DeviceClassesEnum(str, Enum):
     """
-    DeniedActionEnum
+    DeviceClassesEnum
     """
 
     """
     allowed enum values
     """
-    MESSAGE_CONTINUE = 'message_continue'
-    MESSAGE = 'message'
-    CONTINUE = 'continue'
+    STATIC = 'static'
+    TOTP = 'totp'
+    WEBAUTHN = 'webauthn'
+    DUO = 'duo'
+    SMS = 'sms'
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeniedActionEnum:
-        """Create an instance of DeniedActionEnum from a JSON string"""
-        return DeniedActionEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DeviceClassesEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/deny_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/stage.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,86 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DenyStage(BaseModel):
-    """
-    DenyStage Serializer  # noqa: E501
+class Stage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    deny_message: Optional[StrictStr] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "deny_message"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Stage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DenyStage:
-        """Create an instance of DenyStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Stage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DenyStage:
-        """Create an instance of DenyStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Stage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DenyStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DenyStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "deny_message": obj.get("deny_message")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/deny_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_delete_stage_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,71 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DenyStageRequest(BaseModel):
-    """
-    DenyStage Serializer  # noqa: E501
+class UserDeleteStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    deny_message: Optional[StrictStr] = None
-    __properties = ["name", "flow_set", "deny_message"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserDeleteStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DenyStageRequest:
-        """Create an instance of DenyStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserDeleteStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DenyStageRequest:
-        """Create an instance of DenyStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserDeleteStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DenyStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DenyStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "deny_message": obj.get("deny_message")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/device.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/role_object_permission.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,75 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-
-class Device(BaseModel):
-    """
-    Serializer for Duo authenticator devices  # noqa: E501
+class RoleObjectPermission(BaseModel):
     """
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    type: StrictStr = Field(..., description="Get type of device")
-    confirmed: StrictBool = Field(...)
-    __properties = ["verbose_name", "verbose_name_plural", "meta_model_name", "pk", "name", "type", "confirmed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Role-bound object level permission
+    """ # noqa: E501
+    id: StrictInt
+    codename: StrictStr
+    model: StrictStr
+    app_label: StrictStr
+    object_pk: StrictStr
+    name: StrictStr
+    __properties: ClassVar[List[str]] = ["id", "codename", "model", "app_label", "object_pk", "name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Device:
-        """Create an instance of Device from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RoleObjectPermission from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "type",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "id",
+            "codename",
+            "model",
+            "app_label",
+            "object_pk",
+            "name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Device:
-        """Create an instance of Device from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RoleObjectPermission from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Device.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Device.parse_obj({
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "type": obj.get("type"),
-            "confirmed": obj.get("confirmed")
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
+            "codename": obj.get("codename"),
+            "model": obj.get("model"),
+            "app_label": obj.get("app_label"),
+            "object_pk": obj.get("object_pk"),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/device_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_generation_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,63 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict
-from pydantic import BaseModel, Field, StrictStr
-
-class DeviceChallenge(BaseModel):
-    """
-    Single device challenge  # noqa: E501
+class CertificateGenerationRequest(BaseModel):
     """
-    device_class: StrictStr = Field(...)
-    device_uid: StrictStr = Field(...)
-    challenge: Dict[str, Any] = Field(...)
-    __properties = ["device_class", "device_uid", "challenge"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Certificate generation parameters
+    """ # noqa: E501
+    common_name: Annotated[str, Field(min_length=1, strict=True)]
+    subject_alt_name: Optional[StrictStr] = None
+    validity_days: StrictInt
+    __properties: ClassVar[List[str]] = ["common_name", "subject_alt_name", "validity_days"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeviceChallenge:
-        """Create an instance of DeviceChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CertificateGenerationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DeviceChallenge:
-        """Create an instance of DeviceChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CertificateGenerationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DeviceChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DeviceChallenge.parse_obj({
-            "device_class": obj.get("device_class"),
-            "device_uid": obj.get("device_uid"),
-            "challenge": obj.get("challenge")
+        _obj = cls.model_validate({
+            "common_name": obj.get("common_name"),
+            "subject_alt_name": obj.get("subject_alt_name"),
+            "validity_days": obj.get("validity_days")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/device_challenge_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_setting.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,63 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict
-from pydantic import BaseModel, Field, constr
-
-class DeviceChallengeRequest(BaseModel):
-    """
-    Single device challenge  # noqa: E501
+class UserSetting(BaseModel):
     """
-    device_class: constr(strict=True, min_length=1) = Field(...)
-    device_uid: constr(strict=True, min_length=1) = Field(...)
-    challenge: Dict[str, Any] = Field(...)
-    __properties = ["device_class", "device_uid", "challenge"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for User settings for stages and sources
+    """ # noqa: E501
+    object_uid: StrictStr
+    component: StrictStr
+    title: StrictStr
+    configure_url: Optional[StrictStr] = None
+    icon_url: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["object_uid", "component", "title", "configure_url", "icon_url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeviceChallengeRequest:
-        """Create an instance of DeviceChallengeRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserSetting from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DeviceChallengeRequest:
-        """Create an instance of DeviceChallengeRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserSetting from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DeviceChallengeRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DeviceChallengeRequest.parse_obj({
-            "device_class": obj.get("device_class"),
-            "device_uid": obj.get("device_uid"),
-            "challenge": obj.get("challenge")
+        _obj = cls.model_validate({
+            "object_uid": obj.get("object_uid"),
+            "component": obj.get("component"),
+            "title": obj.get("title"),
+            "configure_url": obj.get("configure_url"),
+            "icon_url": obj.get("icon_url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/device_classes_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/intent_enum.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,36 +9,32 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class DeviceClassesEnum(str, Enum):
+class IntentEnum(str, Enum):
     """
-    DeviceClassesEnum
+    IntentEnum
     """
 
     """
     allowed enum values
     """
-    STATIC = 'static'
-    TOTP = 'totp'
-    WEBAUTHN = 'webauthn'
-    DUO = 'duo'
-    SMS = 'sms'
+    VERIFICATION = 'verification'
+    API = 'api'
+    RECOVERY = 'recovery'
+    APP_PASSWORD = 'app_password'
 
     @classmethod
-    def from_json(cls, json_str: str) -> DeviceClassesEnum:
-        """Create an instance of DeviceClassesEnum from a JSON string"""
-        return DeviceClassesEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of IntentEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/digest_algorithm_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/digest_algorithm_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class DigestAlgorithmEnum(str, Enum):
     """
     DigestAlgorithmEnum
     """
 
@@ -32,12 +29,12 @@
     """
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2000_SLASH_09_SLASH_XMLDSIG_HASH_SHA1 = 'http://www.w3.org/2000/09/xmldsig#sha1'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2001_SLASH_04_SLASH_XMLENC_HASH_SHA256 = 'http://www.w3.org/2001/04/xmlenc#sha256'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2001_SLASH_04_SLASH_XMLDSIG_MINUS_MORE_HASH_SHA384 = 'http://www.w3.org/2001/04/xmldsig-more#sha384'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2001_SLASH_04_SLASH_XMLENC_HASH_SHA512 = 'http://www.w3.org/2001/04/xmlenc#sha512'
 
     @classmethod
-    def from_json(cls, json_str: str) -> DigestAlgorithmEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of DigestAlgorithmEnum from a JSON string"""
-        return DigestAlgorithmEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/docker_service_connection.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/docker_service_connection.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,85 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class DockerServiceConnection(BaseModel):
     """
-    DockerServiceConnection Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    component: StrictStr = Field(...)
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    url: StrictStr = Field(..., description="Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.")
-    tls_verification: Optional[StrictStr] = Field(None, description="CA which the endpoint's Certificate is verified against. Can be left empty for no validation.")
-    tls_authentication: Optional[StrictStr] = Field(None, description="Certificate/Key used for authentication. Can be left empty for no authentication.")
-    __properties = ["pk", "name", "local", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "url", "tls_verification", "tls_authentication"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DockerServiceConnection Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    component: StrictStr
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    url: StrictStr = Field(description="Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.")
+    tls_verification: Optional[StrictStr] = Field(default=None, description="CA which the endpoint's Certificate is verified against. Can be left empty for no validation.")
+    tls_authentication: Optional[StrictStr] = Field(default=None, description="Certificate/Key used for authentication. Can be left empty for no authentication.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "local", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "url", "tls_verification", "tls_authentication"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DockerServiceConnection:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of DockerServiceConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if tls_verification (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tls_verification is None and "tls_verification" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.tls_verification is None and "tls_verification" in self.model_fields_set:
             _dict['tls_verification'] = None
 
         # set to None if tls_authentication (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tls_authentication is None and "tls_authentication" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.tls_authentication is None and "tls_authentication" in self.model_fields_set:
             _dict['tls_authentication'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DockerServiceConnection:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of DockerServiceConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DockerServiceConnection.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DockerServiceConnection.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "local": obj.get("local"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/docker_service_connection_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_docker_service_connection_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,75 +14,92 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-
-class DockerServiceConnectionRequest(BaseModel):
-    """
-    DockerServiceConnection Serializer  # noqa: E501
+class PatchedDockerServiceConnectionRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    url: constr(strict=True, min_length=1) = Field(..., description="Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.")
-    tls_verification: Optional[StrictStr] = Field(None, description="CA which the endpoint's Certificate is verified against. Can be left empty for no validation.")
-    tls_authentication: Optional[StrictStr] = Field(None, description="Certificate/Key used for authentication. Can be left empty for no authentication.")
-    __properties = ["name", "local", "url", "tls_verification", "tls_authentication"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DockerServiceConnection Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.")
+    tls_verification: Optional[StrictStr] = Field(default=None, description="CA which the endpoint's Certificate is verified against. Can be left empty for no validation.")
+    tls_authentication: Optional[StrictStr] = Field(default=None, description="Certificate/Key used for authentication. Can be left empty for no authentication.")
+    __properties: ClassVar[List[str]] = ["name", "local", "url", "tls_verification", "tls_authentication"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DockerServiceConnectionRequest:
-        """Create an instance of DockerServiceConnectionRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedDockerServiceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if tls_verification (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tls_verification is None and "tls_verification" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.tls_verification is None and "tls_verification" in self.model_fields_set:
             _dict['tls_verification'] = None
 
         # set to None if tls_authentication (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tls_authentication is None and "tls_authentication" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.tls_authentication is None and "tls_authentication" in self.model_fields_set:
             _dict['tls_authentication'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DockerServiceConnectionRequest:
-        """Create an instance of DockerServiceConnectionRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedDockerServiceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DockerServiceConnectionRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DockerServiceConnectionRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "local": obj.get("local"),
             "url": obj.get("url"),
             "tls_verification": obj.get("tls_verification"),
             "tls_authentication": obj.get("tls_authentication")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/domain.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/domain.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,65 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Domain(BaseModel):
     """
-    Domain Serializer  # noqa: E501
-    """
-    id: StrictInt = Field(...)
-    domain: constr(strict=True, max_length=253) = Field(...)
+    Domain Serializer
+    """ # noqa: E501
+    id: StrictInt
+    domain: Annotated[str, Field(strict=True, max_length=253)]
     is_primary: Optional[StrictBool] = None
-    tenant: StrictStr = Field(...)
-    __properties = ["id", "domain", "is_primary", "tenant"]
+    tenant: StrictStr
+    __properties: ClassVar[List[str]] = ["id", "domain", "is_primary", "tenant"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Domain:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Domain from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "id",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "id",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Domain:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Domain from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Domain.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Domain.parse_obj({
+        _obj = cls.model_validate({
             "id": obj.get("id"),
             "domain": obj.get("domain"),
             "is_primary": obj.get("is_primary"),
             "tenant": obj.get("tenant")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/domain_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,63 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.event_request import EventRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-
-class DomainRequest(BaseModel):
-    """
-    Domain Serializer  # noqa: E501
+class PatchedNotificationRequest(BaseModel):
     """
-    domain: constr(strict=True, max_length=253, min_length=1) = Field(...)
-    is_primary: Optional[StrictBool] = None
-    tenant: StrictStr = Field(...)
-    __properties = ["domain", "is_primary", "tenant"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Notification Serializer
+    """ # noqa: E501
+    event: Optional[EventRequest] = None
+    seen: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["event", "seen"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DomainRequest:
-        """Create an instance of DomainRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedNotificationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of event
+        if self.event:
+            _dict['event'] = self.event.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DomainRequest:
-        """Create an instance of DomainRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedNotificationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DomainRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DomainRequest.parse_obj({
-            "domain": obj.get("domain"),
-            "is_primary": obj.get("is_primary"),
-            "tenant": obj.get("tenant")
+        _obj = cls.model_validate({
+            "event": EventRequest.from_dict(obj["event"]) if obj.get("event") is not None else None,
+            "seen": obj.get("seen")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_duo_stage_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,89 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.authenticator_duo_stage import AuthenticatorDuoStage
+from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class DummyChallenge(BaseModel):
-    """
-    Dummy challenge  # noqa: E501
+class PaginatedAuthenticatorDuoStageList(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-dummy'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    name: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedAuthenticatorDuoStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[AuthenticatorDuoStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DummyChallenge:
-        """Create an instance of DummyChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorDuoStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+        _items = []
+        if self.results:
+            for _item in self.results:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DummyChallenge:
-        """Create an instance of DummyChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorDuoStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DummyChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DummyChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-dummy',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [AuthenticatorDuoStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_finish_challenge_response_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, constr
-
-class DummyChallengeResponseRequest(BaseModel):
-    """
-    Dummy challenge response  # noqa: E501
+class OAuthDeviceCodeFinishChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-dummy'
-    __properties = ["component"]
+    Response that device has been authenticated and tab can be closed
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-provider-oauth2-device-code-finish'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DummyChallengeResponseRequest:
-        """Create an instance of DummyChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OAuthDeviceCodeFinishChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DummyChallengeResponseRequest:
-        """Create an instance of DummyChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OAuthDeviceCodeFinishChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DummyChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DummyChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-dummy'
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-provider-oauth2-device-code-finish'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,85 +14,101 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
-
-class DummyPolicy(BaseModel):
-    """
-    Dummy Policy Serializer  # noqa: E501
+class Policy(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    result: Optional[StrictBool] = None
-    wait_min: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    wait_max: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "result", "wait_min", "wait_max"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Policy Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    bound_to: StrictInt = Field(description="Return objects policy is bound to")
+    __properties: ClassVar[List[str]] = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DummyPolicy:
-        """Create an instance of DummyPolicy from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Policy from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "bound_to",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DummyPolicy:
-        """Create an instance of DummyPolicy from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Policy from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DummyPolicy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DummyPolicy.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "execution_logging": obj.get("execution_logging"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "bound_to": obj.get("bound_to"),
-            "result": obj.get("result"),
-            "wait_min": obj.get("wait_min"),
-            "wait_max": obj.get("wait_max")
+            "bound_to": obj.get("bound_to")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/license_forecast.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, conint, constr
-
-class DummyPolicyRequest(BaseModel):
-    """
-    Dummy Policy Serializer  # noqa: E501
+class LicenseForecast(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    result: Optional[StrictBool] = None
-    wait_min: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    wait_max: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["name", "execution_logging", "result", "wait_min", "wait_max"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for license forecast
+    """ # noqa: E501
+    internal_users: StrictInt
+    external_users: StrictInt
+    forecasted_internal_users: StrictInt
+    forecasted_external_users: StrictInt
+    __properties: ClassVar[List[str]] = ["internal_users", "external_users", "forecasted_internal_users", "forecasted_external_users"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DummyPolicyRequest:
-        """Create an instance of DummyPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LicenseForecast from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DummyPolicyRequest:
-        """Create an instance of DummyPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LicenseForecast from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DummyPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DummyPolicyRequest.parse_obj({
-            "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "result": obj.get("result"),
-            "wait_min": obj.get("wait_min"),
-            "wait_max": obj.get("wait_max")
+        _obj = cls.model_validate({
+            "internal_users": obj.get("internal_users"),
+            "external_users": obj.get("external_users"),
+            "forecasted_internal_users": obj.get("forecasted_internal_users"),
+            "forecasted_external_users": obj.get("forecasted_external_users")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/device.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,86 +14,95 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-
-class DummyStage(BaseModel):
-    """
-    DummyStage Serializer  # noqa: E501
+class Device(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    throw_error: Optional[StrictBool] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "throw_error"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for Duo authenticator devices
+    """ # noqa: E501
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    pk: StrictInt
+    name: StrictStr
+    type: StrictStr = Field(description="Get type of device")
+    confirmed: StrictBool
+    __properties: ClassVar[List[str]] = ["verbose_name", "verbose_name_plural", "meta_model_name", "pk", "name", "type", "confirmed"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DummyStage:
-        """Create an instance of DummyStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Device from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "type",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DummyStage:
-        """Create an instance of DummyStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Device from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DummyStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DummyStage.parse_obj({
-            "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "component": obj.get("component"),
+        _obj = cls.model_validate({
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "throw_error": obj.get("throw_error")
+            "pk": obj.get("pk"),
+            "name": obj.get("name"),
+            "type": obj.get("type"),
+            "confirmed": obj.get("confirmed")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/dummy_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_dummy_stage_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,71 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class DummyStageRequest(BaseModel):
-    """
-    DummyStage Serializer  # noqa: E501
+class PatchedDummyStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
+    DummyStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
     throw_error: Optional[StrictBool] = None
-    __properties = ["name", "flow_set", "throw_error"]
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "throw_error"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DummyStageRequest:
-        """Create an instance of DummyStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedDummyStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DummyStageRequest:
-        """Create an instance of DummyStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedDummyStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DummyStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DummyStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "throw_error": obj.get("throw_error")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/duo_device.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/sms_device_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,62 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictInt, constr
-
-class DuoDevice(BaseModel):
-    """
-    Serializer for Duo authenticator devices  # noqa: E501
+class SMSDeviceRequest(BaseModel):
     """
-    pk: StrictInt = Field(...)
-    name: constr(strict=True, max_length=64) = Field(..., description="The human-readable name of this device.")
-    __properties = ["pk", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for sms authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DuoDevice:
-        """Create an instance of DuoDevice from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SMSDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DuoDevice:
-        """Create an instance of DuoDevice from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SMSDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DuoDevice.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DuoDevice.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/duo_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device_request.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, constr
-
-class DuoDeviceRequest(BaseModel):
-    """
-    Serializer for Duo authenticator devices  # noqa: E501
+class StaticDeviceRequest(BaseModel):
     """
-    name: constr(strict=True, max_length=64, min_length=1) = Field(..., description="The human-readable name of this device.")
-    __properties = ["name"]
+    Serializer for static authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> DuoDeviceRequest:
-        """Create an instance of DuoDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StaticDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> DuoDeviceRequest:
-        """Create an instance of DuoDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StaticDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return DuoDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = DuoDeviceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/email_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/email_challenge.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,87 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
 class EmailChallenge(BaseModel):
     """
-    Email challenge  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Email challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-stage-email'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    __properties = ["type", "flow_info", "component", "response_errors"]
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EmailChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of EmailChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EmailChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of EmailChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EmailChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EmailChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-email',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             )
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/email_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/email_stage.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,99 +14,121 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
 class EmailStage(BaseModel):
     """
-    EmailStage Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    use_global_settings: Optional[StrictBool] = Field(None, description="When enabled, global Email connection settings will be used and connection settings below will be ignored.")
+    EmailStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    use_global_settings: Optional[StrictBool] = Field(default=None, description="When enabled, global Email connection settings will be used and connection settings below will be ignored.")
     host: Optional[StrictStr] = None
-    port: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
+    port: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
     username: Optional[StrictStr] = None
     use_tls: Optional[StrictBool] = None
     use_ssl: Optional[StrictBool] = None
-    timeout: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    from_address: Optional[constr(strict=True, max_length=254)] = None
-    token_expiry: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="Time in minutes the token sent is valid.")
+    timeout: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    from_address: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
+    token_expiry: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = Field(default=None, description="Time in minutes the token sent is valid.")
     subject: Optional[StrictStr] = None
     template: Optional[StrictStr] = None
-    activate_user_on_success: Optional[StrictBool] = Field(None, description="Activate users upon completion of stage.")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "use_global_settings", "host", "port", "username", "use_tls", "use_ssl", "timeout", "from_address", "token_expiry", "subject", "template", "activate_user_on_success"]
+    activate_user_on_success: Optional[StrictBool] = Field(default=None, description="Activate users upon completion of stage.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "use_global_settings", "host", "port", "username", "use_tls", "use_ssl", "timeout", "from_address", "token_expiry", "subject", "template", "activate_user_on_success"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EmailStage:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of EmailStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EmailStage:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of EmailStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EmailStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EmailStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "use_global_settings": obj.get("use_global_settings"),
             "host": obj.get("host"),
             "port": obj.get("port"),
             "username": obj.get("username"),
             "use_tls": obj.get("use_tls"),
             "use_ssl": obj.get("use_ssl"),
             "timeout": obj.get("timeout"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/email_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_policy_binding_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,95 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class EmailStageRequest(BaseModel):
-    """
-    EmailStage Serializer  # noqa: E501
+class PatchedPolicyBindingRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    use_global_settings: Optional[StrictBool] = Field(None, description="When enabled, global Email connection settings will be used and connection settings below will be ignored.")
-    host: Optional[constr(strict=True, min_length=1)] = None
-    port: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    username: Optional[StrictStr] = None
-    password: Optional[StrictStr] = None
-    use_tls: Optional[StrictBool] = None
-    use_ssl: Optional[StrictBool] = None
-    timeout: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    from_address: Optional[constr(strict=True, max_length=254, min_length=1)] = None
-    token_expiry: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="Time in minutes the token sent is valid.")
-    subject: Optional[constr(strict=True, min_length=1)] = None
-    template: Optional[constr(strict=True, min_length=1)] = None
-    activate_user_on_success: Optional[StrictBool] = Field(None, description="Activate users upon completion of stage.")
-    __properties = ["name", "flow_set", "use_global_settings", "host", "port", "username", "password", "use_tls", "use_ssl", "timeout", "from_address", "token_expiry", "subject", "template", "activate_user_on_success"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PolicyBinding Serializer
+    """ # noqa: E501
+    policy: Optional[StrictStr] = None
+    group: Optional[StrictStr] = None
+    user: Optional[StrictInt] = None
+    target: Optional[StrictStr] = None
+    negate: Optional[StrictBool] = Field(default=None, description="Negates the outcome of the policy. Messages are unaffected.")
+    enabled: Optional[StrictBool] = None
+    order: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    timeout: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = Field(default=None, description="Timeout after which Policy execution is terminated.")
+    failure_result: Optional[StrictBool] = Field(default=None, description="Result if the Policy execution fails.")
+    __properties: ClassVar[List[str]] = ["policy", "group", "user", "target", "negate", "enabled", "order", "timeout", "failure_result"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EmailStageRequest:
-        """Create an instance of EmailStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPolicyBindingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if policy (nullable) is None
+        # and model_fields_set contains the field
+        if self.policy is None and "policy" in self.model_fields_set:
+            _dict['policy'] = None
+
+        # set to None if group (nullable) is None
+        # and model_fields_set contains the field
+        if self.group is None and "group" in self.model_fields_set:
+            _dict['group'] = None
+
+        # set to None if user (nullable) is None
+        # and model_fields_set contains the field
+        if self.user is None and "user" in self.model_fields_set:
+            _dict['user'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EmailStageRequest:
-        """Create an instance of EmailStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPolicyBindingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EmailStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EmailStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "use_global_settings": obj.get("use_global_settings"),
-            "host": obj.get("host"),
-            "port": obj.get("port"),
-            "username": obj.get("username"),
-            "password": obj.get("password"),
-            "use_tls": obj.get("use_tls"),
-            "use_ssl": obj.get("use_ssl"),
+        _obj = cls.model_validate({
+            "policy": obj.get("policy"),
+            "group": obj.get("group"),
+            "user": obj.get("user"),
+            "target": obj.get("target"),
+            "negate": obj.get("negate"),
+            "enabled": obj.get("enabled"),
+            "order": obj.get("order"),
             "timeout": obj.get("timeout"),
-            "from_address": obj.get("from_address"),
-            "token_expiry": obj.get("token_expiry"),
-            "subject": obj.get("subject"),
-            "template": obj.get("template"),
-            "activate_user_on_success": obj.get("activate_user_on_success")
+            "failure_result": obj.get("failure_result")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/endpoint.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_endpoint_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,98 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.auth_mode_enum import AuthModeEnum
 from authentik_client.models.protocol_enum import ProtocolEnum
-from authentik_client.models.rac_provider import RACProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Endpoint(BaseModel):
-    """
-    Endpoint Serializer  # noqa: E501
+class PatchedEndpointRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    provider: StrictInt = Field(...)
-    provider_obj: RACProvider = Field(...)
-    protocol: ProtocolEnum = Field(...)
-    host: StrictStr = Field(...)
+    Endpoint Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    provider: Optional[StrictInt] = None
+    protocol: Optional[ProtocolEnum] = None
+    host: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     settings: Optional[Any] = None
-    property_mappings: Optional[conlist(StrictStr)] = None
-    auth_mode: AuthModeEnum = Field(...)
-    launch_url: Optional[StrictStr] = Field(..., description="Build actual launch URL (the provider itself does not have one, just individual endpoints)")
-    maximum_connections: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["pk", "name", "provider", "provider_obj", "protocol", "host", "settings", "property_mappings", "auth_mode", "launch_url", "maximum_connections"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    property_mappings: Optional[List[StrictStr]] = None
+    auth_mode: Optional[AuthModeEnum] = None
+    maximum_connections: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    __properties: ClassVar[List[str]] = ["name", "provider", "protocol", "host", "settings", "property_mappings", "auth_mode", "maximum_connections"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Endpoint:
-        """Create an instance of Endpoint from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedEndpointRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "provider_obj",
-                            "launch_url",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of provider_obj
-        if self.provider_obj:
-            _dict['provider_obj'] = self.provider_obj.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.settings is None and "settings" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.settings is None and "settings" in self.model_fields_set:
             _dict['settings'] = None
 
-        # set to None if launch_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.launch_url is None and "launch_url" in self.__fields_set__:
-            _dict['launch_url'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Endpoint:
-        """Create an instance of Endpoint from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedEndpointRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Endpoint.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Endpoint.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "provider": obj.get("provider"),
-            "provider_obj": RACProvider.from_dict(obj.get("provider_obj")) if obj.get("provider_obj") is not None else None,
             "protocol": obj.get("protocol"),
             "host": obj.get("host"),
             "settings": obj.get("settings"),
             "property_mappings": obj.get("property_mappings"),
             "auth_mode": obj.get("auth_mode"),
-            "launch_url": obj.get("launch_url"),
             "maximum_connections": obj.get("maximum_connections")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/endpoint_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_webhook_mapping_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,80 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, conlist, constr
-from authentik_client.models.auth_mode_enum import AuthModeEnum
-from authentik_client.models.protocol_enum import ProtocolEnum
-
-class EndpointRequest(BaseModel):
-    """
-    Endpoint Serializer  # noqa: E501
+class PatchedNotificationWebhookMappingRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    provider: StrictInt = Field(...)
-    protocol: ProtocolEnum = Field(...)
-    host: constr(strict=True, min_length=1) = Field(...)
-    settings: Optional[Any] = None
-    property_mappings: Optional[conlist(StrictStr)] = None
-    auth_mode: AuthModeEnum = Field(...)
-    maximum_connections: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["name", "provider", "protocol", "host", "settings", "property_mappings", "auth_mode", "maximum_connections"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationWebhookMapping Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    expression: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["name", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EndpointRequest:
-        """Create an instance of EndpointRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedNotificationWebhookMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.settings is None and "settings" in self.__fields_set__:
-            _dict['settings'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EndpointRequest:
-        """Create an instance of EndpointRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedNotificationWebhookMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EndpointRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EndpointRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "provider": obj.get("provider"),
-            "protocol": obj.get("protocol"),
-            "host": obj.get("host"),
-            "settings": obj.get("settings"),
-            "property_mappings": obj.get("property_mappings"),
-            "auth_mode": obj.get("auth_mode"),
-            "maximum_connections": obj.get("maximum_connections")
+            "expression": obj.get("expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/error_detail.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_default_config.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class ErrorDetail(BaseModel):
-    """
-    Serializer for rest_framework's error messages  # noqa: E501
+class OutpostDefaultConfig(BaseModel):
     """
-    string: StrictStr = Field(...)
-    code: StrictStr = Field(...)
-    __properties = ["string", "code"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Global default outpost config
+    """ # noqa: E501
+    config: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["config"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ErrorDetail:
-        """Create an instance of ErrorDetail from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OutpostDefaultConfig from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "config",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ErrorDetail:
-        """Create an instance of ErrorDetail from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OutpostDefaultConfig from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ErrorDetail.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ErrorDetail.parse_obj({
-            "string": obj.get("string"),
-            "code": obj.get("code")
+        _obj = cls.model_validate({
+            "config": obj.get("config")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/error_reporting_config.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,72 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Union
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
-
-class ErrorReportingConfig(BaseModel):
-    """
-    Config for error reporting  # noqa: E501
+class Tenant(BaseModel):
     """
-    enabled: StrictBool = Field(...)
-    sentry_dsn: StrictStr = Field(...)
-    environment: StrictStr = Field(...)
-    send_pii: StrictBool = Field(...)
-    traces_sample_rate: Union[StrictFloat, StrictInt] = Field(...)
-    __properties = ["enabled", "sentry_dsn", "environment", "send_pii", "traces_sample_rate"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Tenant Serializer
+    """ # noqa: E501
+    tenant_uuid: StrictStr
+    schema_name: Annotated[str, Field(strict=True, max_length=63)]
+    name: StrictStr
+    ready: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["tenant_uuid", "schema_name", "name", "ready"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ErrorReportingConfig:
-        """Create an instance of ErrorReportingConfig from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Tenant from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "enabled",
-                            "sentry_dsn",
-                            "environment",
-                            "send_pii",
-                            "traces_sample_rate",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "tenant_uuid",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ErrorReportingConfig:
-        """Create an instance of ErrorReportingConfig from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Tenant from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ErrorReportingConfig.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ErrorReportingConfig.parse_obj({
-            "enabled": obj.get("enabled"),
-            "sentry_dsn": obj.get("sentry_dsn"),
-            "environment": obj.get("environment"),
-            "send_pii": obj.get("send_pii"),
-            "traces_sample_rate": obj.get("traces_sample_rate")
+        _obj = cls.model_validate({
+            "tenant_uuid": obj.get("tenant_uuid"),
+            "schema_name": obj.get("schema_name"),
+            "name": obj.get("name"),
+            "ready": obj.get("ready")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/event.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/event_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -15,97 +15,109 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.event_actions import EventActions
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Event(BaseModel):
+class EventRequest(BaseModel):
     """
-    Event Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
+    Event Serializer
+    """ # noqa: E501
     user: Optional[Any] = None
-    action: EventActions = Field(...)
-    app: StrictStr = Field(...)
+    action: EventActions
+    app: Annotated[str, Field(min_length=1, strict=True)]
     context: Optional[Any] = None
-    client_ip: Optional[StrictStr] = None
-    created: datetime = Field(...)
+    client_ip: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     expires: Optional[datetime] = None
     brand: Optional[Any] = None
-    __properties = ["pk", "user", "action", "app", "context", "client_ip", "created", "expires", "brand"]
+    __properties: ClassVar[List[str]] = ["user", "action", "app", "context", "client_ip", "expires", "brand"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Event:
-        """Create an instance of Event from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of EventRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "created",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if user (nullable) is None
-        # and __fields_set__ contains the field
-        if self.user is None and "user" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.user is None and "user" in self.model_fields_set:
             _dict['user'] = None
 
         # set to None if context (nullable) is None
-        # and __fields_set__ contains the field
-        if self.context is None and "context" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.context is None and "context" in self.model_fields_set:
             _dict['context'] = None
 
         # set to None if client_ip (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_ip is None and "client_ip" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.client_ip is None and "client_ip" in self.model_fields_set:
             _dict['client_ip'] = None
 
         # set to None if brand (nullable) is None
-        # and __fields_set__ contains the field
-        if self.brand is None and "brand" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.brand is None and "brand" in self.model_fields_set:
             _dict['brand'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Event:
-        """Create an instance of Event from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of EventRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Event.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Event.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "user": obj.get("user"),
             "action": obj.get("action"),
             "app": obj.get("app"),
             "context": obj.get("context"),
             "client_ip": obj.get("client_ip"),
-            "created": obj.get("created"),
             "expires": obj.get("expires"),
             "brand": obj.get("brand")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/event_actions.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/event_actions.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class EventActions(str, Enum):
     """
     EventActions
     """
 
@@ -55,12 +52,12 @@
     MODEL_UPDATED = 'model_updated'
     MODEL_DELETED = 'model_deleted'
     EMAIL_SENT = 'email_sent'
     UPDATE_AVAILABLE = 'update_available'
     CUSTOM = 'custom_'
 
     @classmethod
-    def from_json(cls, json_str: str) -> EventActions:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of EventActions from a JSON string"""
-        return EventActions(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/event_matcher_policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_stage_binding.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,110 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.invalid_response_action_enum import InvalidResponseActionEnum
+from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from authentik_client.models.stage import Stage
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-from authentik_client.models.app_enum import AppEnum
-from authentik_client.models.event_actions import EventActions
-from authentik_client.models.model_enum import ModelEnum
-
-class EventMatcherPolicy(BaseModel):
-    """
-    Event Matcher Policy Serializer  # noqa: E501
+class FlowStageBinding(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    action: Optional[EventActions] = Field(None, description="Match created events with this action type. When left empty, all action types will be matched.")
-    client_ip: Optional[StrictStr] = Field(None, description="Matches Event's Client IP (strict matching, for network matching use an Expression Policy)")
-    app: Optional[AppEnum] = Field(None, description="Match events created by selected application. When left empty, all applications are matched.")
-    model: Optional[ModelEnum] = Field(None, description="Match events created by selected model. When left empty, all models are matched. When an app is selected, all the application's models are matched.")
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "action", "client_ip", "app", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    FlowStageBinding Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    policybindingmodel_ptr_id: StrictStr
+    target: StrictStr
+    stage: StrictStr
+    stage_obj: Stage
+    evaluate_on_plan: Optional[StrictBool] = Field(default=None, description="Evaluate policies during the Flow planning process.")
+    re_evaluate_policies: Optional[StrictBool] = Field(default=None, description="Evaluate policies when the Stage is present to the user.")
+    order: Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]
+    policy_engine_mode: Optional[PolicyEngineMode] = None
+    invalid_response_action: Optional[InvalidResponseActionEnum] = Field(default=None, description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.")
+    __properties: ClassVar[List[str]] = ["pk", "policybindingmodel_ptr_id", "target", "stage", "stage_obj", "evaluate_on_plan", "re_evaluate_policies", "order", "policy_engine_mode", "invalid_response_action"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EventMatcherPolicy:
-        """Create an instance of EventMatcherPolicy from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlowStageBinding from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
-        # set to None if action (nullable) is None
-        # and __fields_set__ contains the field
-        if self.action is None and "action" in self.__fields_set__:
-            _dict['action'] = None
-
-        # set to None if client_ip (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_ip is None and "client_ip" in self.__fields_set__:
-            _dict['client_ip'] = None
-
-        # set to None if app (nullable) is None
-        # and __fields_set__ contains the field
-        if self.app is None and "app" in self.__fields_set__:
-            _dict['app'] = None
-
-        # set to None if model (nullable) is None
-        # and __fields_set__ contains the field
-        if self.model is None and "model" in self.__fields_set__:
-            _dict['model'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "policybindingmodel_ptr_id",
+            "stage_obj",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of stage_obj
+        if self.stage_obj:
+            _dict['stage_obj'] = self.stage_obj.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EventMatcherPolicy:
-        """Create an instance of EventMatcherPolicy from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlowStageBinding from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EventMatcherPolicy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EventMatcherPolicy.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "bound_to": obj.get("bound_to"),
-            "action": obj.get("action"),
-            "client_ip": obj.get("client_ip"),
-            "app": obj.get("app"),
-            "model": obj.get("model")
+            "policybindingmodel_ptr_id": obj.get("policybindingmodel_ptr_id"),
+            "target": obj.get("target"),
+            "stage": obj.get("stage"),
+            "stage_obj": Stage.from_dict(obj["stage_obj"]) if obj.get("stage_obj") is not None else None,
+            "evaluate_on_plan": obj.get("evaluate_on_plan"),
+            "re_evaluate_policies": obj.get("re_evaluate_policies"),
+            "order": obj.get("order"),
+            "policy_engine_mode": obj.get("policy_engine_mode"),
+            "invalid_response_action": obj.get("invalid_response_action")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/event_matcher_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/radius_provider_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,92 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-from authentik_client.models.app_enum import AppEnum
-from authentik_client.models.event_actions import EventActions
-from authentik_client.models.model_enum import ModelEnum
-
-class EventMatcherPolicyRequest(BaseModel):
-    """
-    Event Matcher Policy Serializer  # noqa: E501
+class RadiusProviderRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    action: Optional[EventActions] = Field(None, description="Match created events with this action type. When left empty, all action types will be matched.")
-    client_ip: Optional[constr(strict=True, min_length=1)] = Field(None, description="Matches Event's Client IP (strict matching, for network matching use an Expression Policy)")
-    app: Optional[AppEnum] = Field(None, description="Match events created by selected application. When left empty, all applications are matched.")
-    model: Optional[ModelEnum] = Field(None, description="Match events created by selected model. When left empty, all models are matched. When an app is selected, all the application's models are matched.")
-    __properties = ["name", "execution_logging", "action", "client_ip", "app", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RadiusProvider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    client_networks: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.")
+    shared_secret: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Shared secret between clients and server to hash packets.")
+    mfa_support: Optional[StrictBool] = Field(default=None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_networks", "shared_secret", "mfa_support"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EventMatcherPolicyRequest:
-        """Create an instance of EventMatcherPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RadiusProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if action (nullable) is None
-        # and __fields_set__ contains the field
-        if self.action is None and "action" in self.__fields_set__:
-            _dict['action'] = None
-
-        # set to None if client_ip (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_ip is None and "client_ip" in self.__fields_set__:
-            _dict['client_ip'] = None
-
-        # set to None if app (nullable) is None
-        # and __fields_set__ contains the field
-        if self.app is None and "app" in self.__fields_set__:
-            _dict['app'] = None
-
-        # set to None if model (nullable) is None
-        # and __fields_set__ contains the field
-        if self.model is None and "model" in self.__fields_set__:
-            _dict['model'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EventMatcherPolicyRequest:
-        """Create an instance of EventMatcherPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RadiusProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EventMatcherPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EventMatcherPolicyRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "action": obj.get("action"),
-            "client_ip": obj.get("client_ip"),
-            "app": obj.get("app"),
-            "model": obj.get("model")
+            "authentication_flow": obj.get("authentication_flow"),
+            "authorization_flow": obj.get("authorization_flow"),
+            "property_mappings": obj.get("property_mappings"),
+            "client_networks": obj.get("client_networks"),
+            "shared_secret": obj.get("shared_secret"),
+            "mfa_support": obj.get("mfa_support")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/event_top_per_user.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/certificate_data.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,63 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict
-from pydantic import BaseModel, Field, StrictInt
-
-class EventTopPerUser(BaseModel):
-    """
-    Response object of Event's top_per_user  # noqa: E501
+class CertificateData(BaseModel):
     """
-    application: Dict[str, Any] = Field(...)
-    counted_events: StrictInt = Field(...)
-    unique_users: StrictInt = Field(...)
-    __properties = ["application", "counted_events", "unique_users"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Get CertificateKeyPair's data
+    """ # noqa: E501
+    data: StrictStr
+    __properties: ClassVar[List[str]] = ["data"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> EventTopPerUser:
-        """Create an instance of EventTopPerUser from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CertificateData from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "data",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> EventTopPerUser:
-        """Create an instance of EventTopPerUser from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CertificateData from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return EventTopPerUser.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = EventTopPerUser.parse_obj({
-            "application": obj.get("application"),
-            "counted_events": obj.get("counted_events"),
-            "unique_users": obj.get("unique_users")
+        _obj = cls.model_validate({
+            "data": obj.get("data")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/expiring_base_grant_model.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/expiring_base_grant_model.py`

 * *Files 15% similar despite different names*

```diff
@@ -15,78 +15,97 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.o_auth2_provider import OAuth2Provider
 from authentik_client.models.user import User
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ExpiringBaseGrantModel(BaseModel):
     """
-    Serializer for BaseGrantModel and ExpiringBaseGrant  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    provider: OAuth2Provider = Field(...)
-    user: User = Field(...)
-    is_expired: StrictBool = Field(..., description="Check if token is expired yet.")
+    Serializer for BaseGrantModel and ExpiringBaseGrant
+    """ # noqa: E501
+    pk: StrictInt
+    provider: OAuth2Provider
+    user: User
+    is_expired: StrictBool = Field(description="Check if token is expired yet.")
     expires: Optional[datetime] = None
-    scope: conlist(StrictStr) = Field(...)
-    __properties = ["pk", "provider", "user", "is_expired", "expires", "scope"]
+    scope: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["pk", "provider", "user", "is_expired", "expires", "scope"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExpiringBaseGrantModel:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ExpiringBaseGrantModel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "is_expired",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "is_expired",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of provider
         if self.provider:
             _dict['provider'] = self.provider.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user
         if self.user:
             _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExpiringBaseGrantModel:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ExpiringBaseGrantModel from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExpiringBaseGrantModel.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExpiringBaseGrantModel.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "provider": OAuth2Provider.from_dict(obj.get("provider")) if obj.get("provider") is not None else None,
-            "user": User.from_dict(obj.get("user")) if obj.get("user") is not None else None,
+            "provider": OAuth2Provider.from_dict(obj["provider"]) if obj.get("provider") is not None else None,
+            "user": User.from_dict(obj["user"]) if obj.get("user") is not None else None,
             "is_expired": obj.get("is_expired"),
             "expires": obj.get("expires"),
             "scope": obj.get("scope")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/expression_policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/expression_policy.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,75 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ExpressionPolicy(BaseModel):
     """
-    Group Membership Policy Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    expression: StrictStr = Field(...)
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "expression"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Group Membership Policy Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    bound_to: StrictInt = Field(description="Return objects policy is bound to")
+    expression: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExpressionPolicy:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ExpressionPolicy from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "bound_to",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExpressionPolicy:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ExpressionPolicy from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExpressionPolicy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExpressionPolicy.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "execution_logging": obj.get("execution_logging"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/expression_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,63 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-
-class ExpressionPolicyRequest(BaseModel):
-    """
-    Group Membership Policy Serializer  # noqa: E501
+class PolicyRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    expression: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["name", "execution_logging", "expression"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Policy Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    __properties: ClassVar[List[str]] = ["name", "execution_logging"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ExpressionPolicyRequest:
-        """Create an instance of ExpressionPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ExpressionPolicyRequest:
-        """Create an instance of ExpressionPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ExpressionPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ExpressionPolicyRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "expression": obj.get("expression")
+            "execution_logging": obj.get("execution_logging")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/file_path_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/captcha_challenge_response_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,59 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, constr
-
-class FilePathRequest(BaseModel):
-    """
-    Serializer to upload file  # noqa: E501
+class CaptchaChallengeResponseRequest(BaseModel):
     """
-    url: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["url"]
+    Validate captcha token
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-captcha'
+    token: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["component", "token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FilePathRequest:
-        """Create an instance of FilePathRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CaptchaChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FilePathRequest:
-        """Create an instance of FilePathRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CaptchaChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FilePathRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FilePathRequest.parse_obj({
-            "url": obj.get("url")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-captcha',
+            "token": obj.get("token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_set.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,108 +14,117 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
-from authentik_client.models.authentication_enum import AuthenticationEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.denied_action_enum import DeniedActionEnum
 from authentik_client.models.flow_designation_enum import FlowDesignationEnum
 from authentik_client.models.flow_layout_enum import FlowLayoutEnum
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Flow(BaseModel):
-    """
-    Flow Serializer  # noqa: E501
+class FlowSet(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    policybindingmodel_ptr_id: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    slug: constr(strict=True, max_length=50) = Field(..., description="Visible in the URL.")
-    title: StrictStr = Field(..., description="Shown as the Title in Flow pages.")
-    designation: FlowDesignationEnum = Field(..., description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
-    background: StrictStr = Field(..., description="Get the URL to the background image. If the name is /static or starts with http it is returned as-is")
-    stages: conlist(StrictStr) = Field(...)
-    policies: conlist(StrictStr) = Field(...)
-    cache_count: StrictInt = Field(..., description="Get count of cached flows")
+    Stripped down flow serializer
+    """ # noqa: E501
+    pk: StrictStr
+    policybindingmodel_ptr_id: StrictStr
+    name: StrictStr
+    slug: Annotated[str, Field(strict=True, max_length=50)] = Field(description="Visible in the URL.")
+    title: StrictStr = Field(description="Shown as the Title in Flow pages.")
+    designation: FlowDesignationEnum = Field(description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
+    background: StrictStr = Field(description="Get the URL to the background image. If the name is /static or starts with http it is returned as-is")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    compatibility_mode: Optional[StrictBool] = Field(None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
-    export_url: StrictStr = Field(..., description="Get export URL for flow")
+    compatibility_mode: Optional[StrictBool] = Field(default=None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
+    export_url: StrictStr = Field(description="Get export URL for flow")
     layout: Optional[FlowLayoutEnum] = None
-    denied_action: Optional[DeniedActionEnum] = Field(None, description="Configure what should happen when a flow denies access to a user.")
-    authentication: Optional[AuthenticationEnum] = Field(None, description="Required level of authentication and authorization to access a flow.")
-    __properties = ["pk", "policybindingmodel_ptr_id", "name", "slug", "title", "designation", "background", "stages", "policies", "cache_count", "policy_engine_mode", "compatibility_mode", "export_url", "layout", "denied_action", "authentication"]
+    denied_action: Optional[DeniedActionEnum] = Field(default=None, description="Configure what should happen when a flow denies access to a user.")
+    __properties: ClassVar[List[str]] = ["pk", "policybindingmodel_ptr_id", "name", "slug", "title", "designation", "background", "policy_engine_mode", "compatibility_mode", "export_url", "layout", "denied_action"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Flow:
-        """Create an instance of Flow from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlowSet from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "policybindingmodel_ptr_id",
-                            "background",
-                            "stages",
-                            "policies",
-                            "cache_count",
-                            "export_url",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "policybindingmodel_ptr_id",
+            "background",
+            "export_url",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Flow:
-        """Create an instance of Flow from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlowSet from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Flow.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Flow.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "policybindingmodel_ptr_id": obj.get("policybindingmodel_ptr_id"),
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "title": obj.get("title"),
             "designation": obj.get("designation"),
             "background": obj.get("background"),
-            "stages": obj.get("stages"),
-            "policies": obj.get("policies"),
-            "cache_count": obj.get("cache_count"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "compatibility_mode": obj.get("compatibility_mode"),
             "export_url": obj.get("export_url"),
             "layout": obj.get("layout"),
-            "denied_action": obj.get("denied_action"),
-            "authentication": obj.get("authentication")
+            "denied_action": obj.get("denied_action")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_challenge_response_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,21 +10,18 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import json
 import pprint
-import re  # noqa: F401
-
+from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
 from authentik_client.models.apple_challenge_response_request import AppleChallengeResponseRequest
 from authentik_client.models.authenticator_duo_challenge_response_request import AuthenticatorDuoChallengeResponseRequest
 from authentik_client.models.authenticator_sms_challenge_response_request import AuthenticatorSMSChallengeResponseRequest
 from authentik_client.models.authenticator_static_challenge_response_request import AuthenticatorStaticChallengeResponseRequest
 from authentik_client.models.authenticator_totp_challenge_response_request import AuthenticatorTOTPChallengeResponseRequest
 from authentik_client.models.authenticator_validation_challenge_response_request import AuthenticatorValidationChallengeResponseRequest
 from authentik_client.models.authenticator_web_authn_challenge_response_request import AuthenticatorWebAuthnChallengeResponseRequest
@@ -36,16 +33,17 @@
 from authentik_client.models.identification_challenge_response_request import IdentificationChallengeResponseRequest
 from authentik_client.models.o_auth_device_code_challenge_response_request import OAuthDeviceCodeChallengeResponseRequest
 from authentik_client.models.o_auth_device_code_finish_challenge_response_request import OAuthDeviceCodeFinishChallengeResponseRequest
 from authentik_client.models.password_challenge_response_request import PasswordChallengeResponseRequest
 from authentik_client.models.plex_authentication_challenge_response_request import PlexAuthenticationChallengeResponseRequest
 from authentik_client.models.prompt_challenge_response_request import PromptChallengeResponseRequest
 from authentik_client.models.user_login_challenge_response_request import UserLoginChallengeResponseRequest
-from typing import Union, Any, List, TYPE_CHECKING
 from pydantic import StrictStr, Field
+from typing import Union, List, Optional, Dict
+from typing_extensions import Literal, Self
 
 FLOWCHALLENGERESPONSEREQUEST_ONE_OF_SCHEMAS = ["AppleChallengeResponseRequest", "AuthenticatorDuoChallengeResponseRequest", "AuthenticatorSMSChallengeResponseRequest", "AuthenticatorStaticChallengeResponseRequest", "AuthenticatorTOTPChallengeResponseRequest", "AuthenticatorValidationChallengeResponseRequest", "AuthenticatorWebAuthnChallengeResponseRequest", "AutoSubmitChallengeResponseRequest", "CaptchaChallengeResponseRequest", "ConsentChallengeResponseRequest", "DummyChallengeResponseRequest", "EmailChallengeResponseRequest", "IdentificationChallengeResponseRequest", "OAuthDeviceCodeChallengeResponseRequest", "OAuthDeviceCodeFinishChallengeResponseRequest", "PasswordChallengeResponseRequest", "PlexAuthenticationChallengeResponseRequest", "PromptChallengeResponseRequest", "UserLoginChallengeResponseRequest"]
 
 class FlowChallengeResponseRequest(BaseModel):
     """
     FlowChallengeResponseRequest
     """
@@ -83,39 +81,39 @@
     oneof_schema_16_validator: Optional[PasswordChallengeResponseRequest] = None
     # data type: PlexAuthenticationChallengeResponseRequest
     oneof_schema_17_validator: Optional[PlexAuthenticationChallengeResponseRequest] = None
     # data type: PromptChallengeResponseRequest
     oneof_schema_18_validator: Optional[PromptChallengeResponseRequest] = None
     # data type: UserLoginChallengeResponseRequest
     oneof_schema_19_validator: Optional[UserLoginChallengeResponseRequest] = None
-    if TYPE_CHECKING:
-        actual_instance: Union[AppleChallengeResponseRequest, AuthenticatorDuoChallengeResponseRequest, AuthenticatorSMSChallengeResponseRequest, AuthenticatorStaticChallengeResponseRequest, AuthenticatorTOTPChallengeResponseRequest, AuthenticatorValidationChallengeResponseRequest, AuthenticatorWebAuthnChallengeResponseRequest, AutoSubmitChallengeResponseRequest, CaptchaChallengeResponseRequest, ConsentChallengeResponseRequest, DummyChallengeResponseRequest, EmailChallengeResponseRequest, IdentificationChallengeResponseRequest, OAuthDeviceCodeChallengeResponseRequest, OAuthDeviceCodeFinishChallengeResponseRequest, PasswordChallengeResponseRequest, PlexAuthenticationChallengeResponseRequest, PromptChallengeResponseRequest, UserLoginChallengeResponseRequest]
-    else:
-        actual_instance: Any
-    one_of_schemas: List[str] = Field(FLOWCHALLENGERESPONSEREQUEST_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[AppleChallengeResponseRequest, AuthenticatorDuoChallengeResponseRequest, AuthenticatorSMSChallengeResponseRequest, AuthenticatorStaticChallengeResponseRequest, AuthenticatorTOTPChallengeResponseRequest, AuthenticatorValidationChallengeResponseRequest, AuthenticatorWebAuthnChallengeResponseRequest, AutoSubmitChallengeResponseRequest, CaptchaChallengeResponseRequest, ConsentChallengeResponseRequest, DummyChallengeResponseRequest, EmailChallengeResponseRequest, IdentificationChallengeResponseRequest, OAuthDeviceCodeChallengeResponseRequest, OAuthDeviceCodeFinishChallengeResponseRequest, PasswordChallengeResponseRequest, PlexAuthenticationChallengeResponseRequest, PromptChallengeResponseRequest, UserLoginChallengeResponseRequest]] = None
+    one_of_schemas: List[str] = Field(default=Literal["AppleChallengeResponseRequest", "AuthenticatorDuoChallengeResponseRequest", "AuthenticatorSMSChallengeResponseRequest", "AuthenticatorStaticChallengeResponseRequest", "AuthenticatorTOTPChallengeResponseRequest", "AuthenticatorValidationChallengeResponseRequest", "AuthenticatorWebAuthnChallengeResponseRequest", "AutoSubmitChallengeResponseRequest", "CaptchaChallengeResponseRequest", "ConsentChallengeResponseRequest", "DummyChallengeResponseRequest", "EmailChallengeResponseRequest", "IdentificationChallengeResponseRequest", "OAuthDeviceCodeChallengeResponseRequest", "OAuthDeviceCodeFinishChallengeResponseRequest", "PasswordChallengeResponseRequest", "PlexAuthenticationChallengeResponseRequest", "PromptChallengeResponseRequest", "UserLoginChallengeResponseRequest"])
+
+    model_config = ConfigDict(
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
     def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = FlowChallengeResponseRequest.construct()
+        instance = FlowChallengeResponseRequest.model_construct()
         error_messages = []
         match = 0
         # validate data type: AppleChallengeResponseRequest
         if not isinstance(v, AppleChallengeResponseRequest):
             error_messages.append(f"Error! Input type `{type(v)}` is not `AppleChallengeResponseRequest`")
         else:
             match += 1
@@ -215,21 +213,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in FlowChallengeResponseRequest with oneOf schemas: AppleChallengeResponseRequest, AuthenticatorDuoChallengeResponseRequest, AuthenticatorSMSChallengeResponseRequest, AuthenticatorStaticChallengeResponseRequest, AuthenticatorTOTPChallengeResponseRequest, AuthenticatorValidationChallengeResponseRequest, AuthenticatorWebAuthnChallengeResponseRequest, AutoSubmitChallengeResponseRequest, CaptchaChallengeResponseRequest, ConsentChallengeResponseRequest, DummyChallengeResponseRequest, EmailChallengeResponseRequest, IdentificationChallengeResponseRequest, OAuthDeviceCodeChallengeResponseRequest, OAuthDeviceCodeFinishChallengeResponseRequest, PasswordChallengeResponseRequest, PlexAuthenticationChallengeResponseRequest, PromptChallengeResponseRequest, UserLoginChallengeResponseRequest. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowChallengeResponseRequest:
+    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowChallengeResponseRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = FlowChallengeResponseRequest.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into AppleChallengeResponseRequest
         try:
             instance.actual_instance = AppleChallengeResponseRequest.from_json(json_str)
             match += 1
@@ -354,30 +352,28 @@
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
+        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Optional[Union[Dict[str, Any], AppleChallengeResponseRequest, AuthenticatorDuoChallengeResponseRequest, AuthenticatorSMSChallengeResponseRequest, AuthenticatorStaticChallengeResponseRequest, AuthenticatorTOTPChallengeResponseRequest, AuthenticatorValidationChallengeResponseRequest, AuthenticatorWebAuthnChallengeResponseRequest, AutoSubmitChallengeResponseRequest, CaptchaChallengeResponseRequest, ConsentChallengeResponseRequest, DummyChallengeResponseRequest, EmailChallengeResponseRequest, IdentificationChallengeResponseRequest, OAuthDeviceCodeChallengeResponseRequest, OAuthDeviceCodeFinishChallengeResponseRequest, PasswordChallengeResponseRequest, PlexAuthenticationChallengeResponseRequest, PromptChallengeResponseRequest, UserLoginChallengeResponseRequest]]:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
-        to_dict = getattr(self.actual_instance, "to_dict", None)
-        if callable(to_dict):
+        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_designation_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/not_configured_action_enum.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,38 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class FlowDesignationEnum(str, Enum):
+class NotConfiguredActionEnum(str, Enum):
     """
-    FlowDesignationEnum
+    NotConfiguredActionEnum
     """
 
     """
     allowed enum values
     """
-    AUTHENTICATION = 'authentication'
-    AUTHORIZATION = 'authorization'
-    INVALIDATION = 'invalidation'
-    ENROLLMENT = 'enrollment'
-    UNENROLLMENT = 'unenrollment'
-    RECOVERY = 'recovery'
-    STAGE_CONFIGURATION = 'stage_configuration'
+    SKIP = 'skip'
+    DENY = 'deny'
+    CONFIGURE = 'configure'
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowDesignationEnum:
-        """Create an instance of FlowDesignationEnum from a JSON string"""
-        return FlowDesignationEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of NotConfiguredActionEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_diagram.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_role_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,60 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class FlowDiagram(BaseModel):
-    """
-    response of the flow's diagram action  # noqa: E501
+class PatchedRoleRequest(BaseModel):
     """
-    diagram: StrictStr = Field(...)
-    __properties = ["diagram"]
+    Role serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=150)]] = None
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowDiagram:
-        """Create an instance of FlowDiagram from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedRoleRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "diagram",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowDiagram:
-        """Create an instance of FlowDiagram from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedRoleRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowDiagram.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowDiagram.parse_obj({
-            "diagram": obj.get("diagram")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_error_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_challenge.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,92 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlowErrorChallenge(BaseModel):
-    """
-    Challenge class when an unhandled error occurs during a stage. Normal users are shown an error message, superusers are shown a full stacktrace.  # noqa: E501
+class OAuthDeviceCodeChallenge(BaseModel):
     """
-    type: Optional[StrictStr] = 'native'
+    OAuth Device code challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-flow-error'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    request_id: StrictStr = Field(...)
-    error: Optional[StrictStr] = None
-    traceback: Optional[StrictStr] = None
-    __properties = ["type", "flow_info", "component", "response_errors", "request_id", "error", "traceback"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-provider-oauth2-device-code'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowErrorChallenge:
-        """Create an instance of FlowErrorChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OAuthDeviceCodeChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowErrorChallenge:
-        """Create an instance of FlowErrorChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OAuthDeviceCodeChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowErrorChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowErrorChallenge.parse_obj({
-            "type": obj.get("type") if obj.get("type") is not None else 'native',
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-flow-error',
+        _obj = cls.model_validate({
+            "type": obj.get("type"),
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-provider-oauth2-device-code',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "request_id": obj.get("request_id"),
-            "error": obj.get("error"),
-            "traceback": obj.get("traceback")
+                for _k, _v in obj.get("response_errors", {}).items()
+            )
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_import_result.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_import_result.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,63 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List
-from pydantic import BaseModel, Field, StrictBool, conlist
+from pydantic import BaseModel, ConfigDict, StrictBool
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.log_event import LogEvent
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlowImportResult(BaseModel):
     """
-    Logs of an attempted flow import  # noqa: E501
-    """
-    logs: conlist(Dict[str, Any]) = Field(...)
-    success: StrictBool = Field(...)
-    __properties = ["logs", "success"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Logs of an attempted flow import
+    """ # noqa: E501
+    logs: List[LogEvent]
+    success: StrictBool
+    __properties: ClassVar[List[str]] = ["logs", "success"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowImportResult:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlowImportResult from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "logs",
-                            "success",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "logs",
+            "success",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in logs (list)
+        _items = []
+        if self.logs:
+            for _item in self.logs:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['logs'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowImportResult:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlowImportResult from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowImportResult.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowImportResult.parse_obj({
-            "logs": obj.get("logs"),
+        _obj = cls.model_validate({
+            "logs": [LogEvent.from_dict(_item) for _item in obj["logs"]] if obj.get("logs") is not None else None,
             "success": obj.get("success")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_inspection.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_test_result.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,74 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.log_event import LogEvent
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, conlist
-from authentik_client.models.flow_inspector_plan import FlowInspectorPlan
-
-class FlowInspection(BaseModel):
-    """
-    Serializer for inspect endpoint  # noqa: E501
+class PolicyTestResult(BaseModel):
     """
-    plans: conlist(FlowInspectorPlan) = Field(...)
-    current_plan: Optional[FlowInspectorPlan] = None
-    is_completed: StrictBool = Field(...)
-    __properties = ["plans", "current_plan", "is_completed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    result of a policy test
+    """ # noqa: E501
+    passing: StrictBool
+    messages: List[StrictStr]
+    log_messages: List[LogEvent]
+    __properties: ClassVar[List[str]] = ["passing", "messages", "log_messages"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowInspection:
-        """Create an instance of FlowInspection from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PolicyTestResult from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in plans (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "messages",
+            "log_messages",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in log_messages (list)
         _items = []
-        if self.plans:
-            for _item in self.plans:
+        if self.log_messages:
+            for _item in self.log_messages:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['plans'] = _items
-        # override the default output from pydantic by calling `to_dict()` of current_plan
-        if self.current_plan:
-            _dict['current_plan'] = self.current_plan.to_dict()
+            _dict['log_messages'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowInspection:
-        """Create an instance of FlowInspection from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PolicyTestResult from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowInspection.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowInspection.parse_obj({
-            "plans": [FlowInspectorPlan.from_dict(_item) for _item in obj.get("plans")] if obj.get("plans") is not None else None,
-            "current_plan": FlowInspectorPlan.from_dict(obj.get("current_plan")) if obj.get("current_plan") is not None else None,
-            "is_completed": obj.get("is_completed")
+        _obj = cls.model_validate({
+            "passing": obj.get("passing"),
+            "messages": obj.get("messages"),
+            "log_messages": [LogEvent.from_dict(_item) for _item in obj["log_messages"]] if obj.get("log_messages") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_inspector_plan.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_inspector_plan.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,76 +14,96 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.flow_stage_binding import FlowStageBinding
+from typing import Optional, Set
+from typing_extensions import Self
 
 class FlowInspectorPlan(BaseModel):
     """
-    Serializer for an active FlowPlan  # noqa: E501
-    """
-    current_stage: FlowStageBinding = Field(...)
-    next_planned_stage: FlowStageBinding = Field(...)
-    plan_context: Dict[str, Any] = Field(..., description="Get the plan's context, sanitized")
-    session_id: StrictStr = Field(..., description="Get a unique session ID")
-    __properties = ["current_stage", "next_planned_stage", "plan_context", "session_id"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for an active FlowPlan
+    """ # noqa: E501
+    current_stage: FlowStageBinding
+    next_planned_stage: FlowStageBinding
+    plan_context: Dict[str, Any] = Field(description="Get the plan's context, sanitized")
+    session_id: StrictStr = Field(description="Get a unique session ID")
+    __properties: ClassVar[List[str]] = ["current_stage", "next_planned_stage", "plan_context", "session_id"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowInspectorPlan:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of FlowInspectorPlan from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "current_stage",
-                            "next_planned_stage",
-                            "plan_context",
-                            "session_id",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "current_stage",
+            "next_planned_stage",
+            "plan_context",
+            "session_id",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of current_stage
         if self.current_stage:
             _dict['current_stage'] = self.current_stage.to_dict()
         # override the default output from pydantic by calling `to_dict()` of next_planned_stage
         if self.next_planned_stage:
             _dict['next_planned_stage'] = self.next_planned_stage.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowInspectorPlan:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of FlowInspectorPlan from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowInspectorPlan.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowInspectorPlan.parse_obj({
-            "current_stage": FlowStageBinding.from_dict(obj.get("current_stage")) if obj.get("current_stage") is not None else None,
-            "next_planned_stage": FlowStageBinding.from_dict(obj.get("next_planned_stage")) if obj.get("next_planned_stage") is not None else None,
+        _obj = cls.model_validate({
+            "current_stage": FlowStageBinding.from_dict(obj["current_stage"]) if obj.get("current_stage") is not None else None,
+            "next_planned_stage": FlowStageBinding.from_dict(obj["next_planned_stage"]) if obj.get("next_planned_stage") is not None else None,
             "plan_context": obj.get("plan_context"),
             "session_id": obj.get("session_id")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_layout_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_layout_enum.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class FlowLayoutEnum(str, Enum):
     """
     FlowLayoutEnum
     """
 
@@ -33,12 +30,12 @@
     STACKED = 'stacked'
     CONTENT_LEFT = 'content_left'
     CONTENT_RIGHT = 'content_right'
     SIDEBAR_LEFT = 'sidebar_left'
     SIDEBAR_RIGHT = 'sidebar_right'
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowLayoutEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of FlowLayoutEnum from a JSON string"""
-        return FlowLayoutEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_set_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,87 +14,101 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr, validator
-from authentik_client.models.authentication_enum import AuthenticationEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.denied_action_enum import DeniedActionEnum
 from authentik_client.models.flow_designation_enum import FlowDesignationEnum
 from authentik_client.models.flow_layout_enum import FlowLayoutEnum
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlowRequest(BaseModel):
-    """
-    Flow Serializer  # noqa: E501
+class FlowSetRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Visible in the URL.")
-    title: constr(strict=True, min_length=1) = Field(..., description="Shown as the Title in Flow pages.")
-    designation: FlowDesignationEnum = Field(..., description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
+    Stripped down flow serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    slug: Annotated[str, Field(min_length=1, strict=True, max_length=50)] = Field(description="Visible in the URL.")
+    title: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Shown as the Title in Flow pages.")
+    designation: FlowDesignationEnum = Field(description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    compatibility_mode: Optional[StrictBool] = Field(None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
+    compatibility_mode: Optional[StrictBool] = Field(default=None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
     layout: Optional[FlowLayoutEnum] = None
-    denied_action: Optional[DeniedActionEnum] = Field(None, description="Configure what should happen when a flow denies access to a user.")
-    authentication: Optional[AuthenticationEnum] = Field(None, description="Required level of authentication and authorization to access a flow.")
-    __properties = ["name", "slug", "title", "designation", "policy_engine_mode", "compatibility_mode", "layout", "denied_action", "authentication"]
+    denied_action: Optional[DeniedActionEnum] = Field(default=None, description="Configure what should happen when a flow denies access to a user.")
+    __properties: ClassVar[List[str]] = ["name", "slug", "title", "designation", "policy_engine_mode", "compatibility_mode", "layout", "denied_action"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowRequest:
-        """Create an instance of FlowRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlowSetRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowRequest:
-        """Create an instance of FlowRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlowSetRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "title": obj.get("title"),
             "designation": obj.get("designation"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "compatibility_mode": obj.get("compatibility_mode"),
             "layout": obj.get("layout"),
-            "denied_action": obj.get("denied_action"),
-            "authentication": obj.get("authentication")
+            "denied_action": obj.get("denied_action")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_set.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/group_member.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,96 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
-from authentik_client.models.denied_action_enum import DeniedActionEnum
-from authentik_client.models.flow_designation_enum import FlowDesignationEnum
-from authentik_client.models.flow_layout_enum import FlowLayoutEnum
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-
-class FlowSet(BaseModel):
-    """
-    Stripped down flow serializer  # noqa: E501
+class GroupMember(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    policybindingmodel_ptr_id: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    slug: constr(strict=True, max_length=50) = Field(..., description="Visible in the URL.")
-    title: StrictStr = Field(..., description="Shown as the Title in Flow pages.")
-    designation: FlowDesignationEnum = Field(..., description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
-    background: StrictStr = Field(..., description="Get the URL to the background image. If the name is /static or starts with http it is returned as-is")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    compatibility_mode: Optional[StrictBool] = Field(None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
-    export_url: StrictStr = Field(..., description="Get export URL for flow")
-    layout: Optional[FlowLayoutEnum] = None
-    denied_action: Optional[DeniedActionEnum] = Field(None, description="Configure what should happen when a flow denies access to a user.")
-    __properties = ["pk", "policybindingmodel_ptr_id", "name", "slug", "title", "designation", "background", "policy_engine_mode", "compatibility_mode", "export_url", "layout", "denied_action"]
+    Stripped down user serializer to show relevant users for groups
+    """ # noqa: E501
+    pk: StrictInt
+    username: Annotated[str, Field(strict=True, max_length=150)] = Field(description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
+    name: StrictStr = Field(description="User's display name.")
+    is_active: Optional[StrictBool] = Field(default=None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
+    last_login: Optional[datetime] = None
+    email: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
+    attributes: Optional[Dict[str, Any]] = None
+    uid: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "username", "name", "is_active", "last_login", "email", "attributes", "uid"]
 
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
+    @field_validator('username')
+    def username_validate_regular_expression(cls, value):
         """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
+        if not re.match(r"^[\w.@+-]+$", value):
+            raise ValueError(r"must validate the regular expression /^[\w.@+-]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowSet:
-        """Create an instance of FlowSet from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GroupMember from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "policybindingmodel_ptr_id",
-                            "background",
-                            "export_url",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "uid",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if last_login (nullable) is None
+        # and model_fields_set contains the field
+        if self.last_login is None and "last_login" in self.model_fields_set:
+            _dict['last_login'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowSet:
-        """Create an instance of FlowSet from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GroupMember from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowSet.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowSet.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "policybindingmodel_ptr_id": obj.get("policybindingmodel_ptr_id"),
+            "username": obj.get("username"),
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "title": obj.get("title"),
-            "designation": obj.get("designation"),
-            "background": obj.get("background"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "compatibility_mode": obj.get("compatibility_mode"),
-            "export_url": obj.get("export_url"),
-            "layout": obj.get("layout"),
-            "denied_action": obj.get("denied_action")
+            "is_active": obj.get("is_active"),
+            "last_login": obj.get("last_login"),
+            "email": obj.get("email"),
+            "attributes": obj.get("attributes"),
+            "uid": obj.get("uid")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_set_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,84 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr, validator
-from authentik_client.models.denied_action_enum import DeniedActionEnum
-from authentik_client.models.flow_designation_enum import FlowDesignationEnum
-from authentik_client.models.flow_layout_enum import FlowLayoutEnum
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-
-class FlowSetRequest(BaseModel):
-    """
-    Stripped down flow serializer  # noqa: E501
+class PatchedUserRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Visible in the URL.")
-    title: constr(strict=True, min_length=1) = Field(..., description="Shown as the Title in Flow pages.")
-    designation: FlowDesignationEnum = Field(..., description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    compatibility_mode: Optional[StrictBool] = Field(None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
-    layout: Optional[FlowLayoutEnum] = None
-    denied_action: Optional[DeniedActionEnum] = Field(None, description="Configure what should happen when a flow denies access to a user.")
-    __properties = ["name", "slug", "title", "designation", "policy_engine_mode", "compatibility_mode", "layout", "denied_action"]
-
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User Serializer
+    """ # noqa: E501
+    username: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=150)]] = None
+    name: Optional[StrictStr] = Field(default=None, description="User's display name.")
+    is_active: Optional[StrictBool] = Field(default=None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
+    last_login: Optional[datetime] = None
+    groups: Optional[List[StrictStr]] = None
+    email: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
+    attributes: Optional[Dict[str, Any]] = None
+    path: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    type: Optional[UserTypeEnum] = None
+    __properties: ClassVar[List[str]] = ["username", "name", "is_active", "last_login", "groups", "email", "attributes", "path", "type"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowSetRequest:
-        """Create an instance of FlowSetRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedUserRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if last_login (nullable) is None
+        # and model_fields_set contains the field
+        if self.last_login is None and "last_login" in self.model_fields_set:
+            _dict['last_login'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowSetRequest:
-        """Create an instance of FlowSetRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedUserRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowSetRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowSetRequest.parse_obj({
+        _obj = cls.model_validate({
+            "username": obj.get("username"),
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "title": obj.get("title"),
-            "designation": obj.get("designation"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "compatibility_mode": obj.get("compatibility_mode"),
-            "layout": obj.get("layout"),
-            "denied_action": obj.get("denied_action")
+            "is_active": obj.get("is_active"),
+            "last_login": obj.get("last_login"),
+            "groups": obj.get("groups"),
+            "email": obj.get("email"),
+            "attributes": obj.get("attributes"),
+            "path": obj.get("path"),
+            "type": obj.get("type")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_stage_binding.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_flow_stage_binding_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,84 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.invalid_response_action_enum import InvalidResponseActionEnum
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.stage import Stage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class FlowStageBinding(BaseModel):
-    """
-    FlowStageBinding Serializer  # noqa: E501
+class PatchedFlowStageBindingRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    policybindingmodel_ptr_id: StrictStr = Field(...)
-    target: StrictStr = Field(...)
-    stage: StrictStr = Field(...)
-    stage_obj: Stage = Field(...)
-    evaluate_on_plan: Optional[StrictBool] = Field(None, description="Evaluate policies during the Flow planning process.")
-    re_evaluate_policies: Optional[StrictBool] = Field(None, description="Evaluate policies when the Stage is present to the user.")
-    order: conint(strict=True, le=2147483647, ge=-2147483648) = Field(...)
+    FlowStageBinding Serializer
+    """ # noqa: E501
+    target: Optional[StrictStr] = None
+    stage: Optional[StrictStr] = None
+    evaluate_on_plan: Optional[StrictBool] = Field(default=None, description="Evaluate policies during the Flow planning process.")
+    re_evaluate_policies: Optional[StrictBool] = Field(default=None, description="Evaluate policies when the Stage is present to the user.")
+    order: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    invalid_response_action: Optional[InvalidResponseActionEnum] = Field(None, description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.")
-    __properties = ["pk", "policybindingmodel_ptr_id", "target", "stage", "stage_obj", "evaluate_on_plan", "re_evaluate_policies", "order", "policy_engine_mode", "invalid_response_action"]
+    invalid_response_action: Optional[InvalidResponseActionEnum] = Field(default=None, description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.")
+    __properties: ClassVar[List[str]] = ["target", "stage", "evaluate_on_plan", "re_evaluate_policies", "order", "policy_engine_mode", "invalid_response_action"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowStageBinding:
-        """Create an instance of FlowStageBinding from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedFlowStageBindingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "policybindingmodel_ptr_id",
-                            "stage_obj",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of stage_obj
-        if self.stage_obj:
-            _dict['stage_obj'] = self.stage_obj.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowStageBinding:
-        """Create an instance of FlowStageBinding from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedFlowStageBindingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowStageBinding.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowStageBinding.parse_obj({
-            "pk": obj.get("pk"),
-            "policybindingmodel_ptr_id": obj.get("policybindingmodel_ptr_id"),
+        _obj = cls.model_validate({
             "target": obj.get("target"),
             "stage": obj.get("stage"),
-            "stage_obj": Stage.from_dict(obj.get("stage_obj")) if obj.get("stage_obj") is not None else None,
             "evaluate_on_plan": obj.get("evaluate_on_plan"),
             "re_evaluate_policies": obj.get("re_evaluate_policies"),
             "order": obj.get("order"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "invalid_response_action": obj.get("invalid_response_action")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/flow_stage_binding_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_service_connection_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.pagination import Pagination
+from authentik_client.models.service_connection import ServiceConnection
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint
-from authentik_client.models.invalid_response_action_enum import InvalidResponseActionEnum
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-
-class FlowStageBindingRequest(BaseModel):
-    """
-    FlowStageBinding Serializer  # noqa: E501
+class PaginatedServiceConnectionList(BaseModel):
     """
-    target: StrictStr = Field(...)
-    stage: StrictStr = Field(...)
-    evaluate_on_plan: Optional[StrictBool] = Field(None, description="Evaluate policies during the Flow planning process.")
-    re_evaluate_policies: Optional[StrictBool] = Field(None, description="Evaluate policies when the Stage is present to the user.")
-    order: conint(strict=True, le=2147483647, ge=-2147483648) = Field(...)
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    invalid_response_action: Optional[InvalidResponseActionEnum] = Field(None, description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.")
-    __properties = ["target", "stage", "evaluate_on_plan", "re_evaluate_policies", "order", "policy_engine_mode", "invalid_response_action"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedServiceConnectionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ServiceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FlowStageBindingRequest:
-        """Create an instance of FlowStageBindingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedServiceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+        _items = []
+        if self.results:
+            for _item in self.results:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FlowStageBindingRequest:
-        """Create an instance of FlowStageBindingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedServiceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return FlowStageBindingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = FlowStageBindingRequest.parse_obj({
-            "target": obj.get("target"),
-            "stage": obj.get("stage"),
-            "evaluate_on_plan": obj.get("evaluate_on_plan"),
-            "re_evaluate_policies": obj.get("re_evaluate_policies"),
-            "order": obj.get("order"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "invalid_response_action": obj.get("invalid_response_action")
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ServiceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/generic_error.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_static_device_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,61 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-
-class GenericError(BaseModel):
-    """
-    Generic API Error  # noqa: E501
+class PatchedStaticDeviceRequest(BaseModel):
     """
-    detail: StrictStr = Field(...)
-    code: Optional[StrictStr] = None
-    __properties = ["detail", "code"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for static authenticator devices
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GenericError:
-        """Create an instance of GenericError from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedStaticDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GenericError:
-        """Create an instance of GenericError from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedStaticDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GenericError.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GenericError.parse_obj({
-            "detail": obj.get("detail"),
-            "code": obj.get("code")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/geoip_binding_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/geoip_binding_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class GeoipBindingEnum(str, Enum):
     """
     GeoipBindingEnum
     """
 
@@ -32,12 +29,12 @@
     """
     NO_BINDING = 'no_binding'
     BIND_CONTINENT = 'bind_continent'
     BIND_CONTINENT_COUNTRY = 'bind_continent_country'
     BIND_CONTINENT_COUNTRY_CITY = 'bind_continent_country_city'
 
     @classmethod
-    def from_json(cls, json_str: str) -> GeoipBindingEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of GeoipBindingEnum from a JSON string"""
-        return GeoipBindingEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/group.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/endpoint.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,110 +14,118 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.auth_mode_enum import AuthModeEnum
+from authentik_client.models.protocol_enum import ProtocolEnum
+from authentik_client.models.rac_provider import RACProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr
-from authentik_client.models.group_member import GroupMember
-from authentik_client.models.role import Role
-
-class Group(BaseModel):
-    """
-    Group Serializer  # noqa: E501
+class Endpoint(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    num_pk: StrictInt = Field(...)
-    name: constr(strict=True, max_length=80) = Field(...)
-    is_superuser: Optional[StrictBool] = Field(None, description="Users added to this group will be superusers.")
-    parent: Optional[StrictStr] = None
-    parent_name: Optional[StrictStr] = Field(...)
-    users: Optional[conlist(StrictInt)] = None
-    users_obj: conlist(GroupMember) = Field(...)
-    attributes: Optional[Dict[str, Any]] = None
-    roles: Optional[conlist(StrictStr)] = None
-    roles_obj: conlist(Role) = Field(...)
-    __properties = ["pk", "num_pk", "name", "is_superuser", "parent", "parent_name", "users", "users_obj", "attributes", "roles", "roles_obj"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Endpoint Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    provider: StrictInt
+    provider_obj: RACProvider
+    protocol: ProtocolEnum
+    host: StrictStr
+    settings: Optional[Any] = None
+    property_mappings: Optional[List[StrictStr]] = None
+    auth_mode: AuthModeEnum
+    launch_url: Optional[StrictStr] = Field(description="Build actual launch URL (the provider itself does not have one, just individual endpoints)")
+    maximum_connections: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "provider", "provider_obj", "protocol", "host", "settings", "property_mappings", "auth_mode", "launch_url", "maximum_connections"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Group:
-        """Create an instance of Group from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Endpoint from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "num_pk",
-                            "parent_name",
-                            "users_obj",
-                            "roles_obj",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in users_obj (list)
-        _items = []
-        if self.users_obj:
-            for _item in self.users_obj:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['users_obj'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in roles_obj (list)
-        _items = []
-        if self.roles_obj:
-            for _item in self.roles_obj:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['roles_obj'] = _items
-        # set to None if parent (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parent is None and "parent" in self.__fields_set__:
-            _dict['parent'] = None
-
-        # set to None if parent_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parent_name is None and "parent_name" in self.__fields_set__:
-            _dict['parent_name'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "provider_obj",
+            "launch_url",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of provider_obj
+        if self.provider_obj:
+            _dict['provider_obj'] = self.provider_obj.to_dict()
+        # set to None if settings (nullable) is None
+        # and model_fields_set contains the field
+        if self.settings is None and "settings" in self.model_fields_set:
+            _dict['settings'] = None
+
+        # set to None if launch_url (nullable) is None
+        # and model_fields_set contains the field
+        if self.launch_url is None and "launch_url" in self.model_fields_set:
+            _dict['launch_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Group:
-        """Create an instance of Group from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Endpoint from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Group.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Group.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "num_pk": obj.get("num_pk"),
             "name": obj.get("name"),
-            "is_superuser": obj.get("is_superuser"),
-            "parent": obj.get("parent"),
-            "parent_name": obj.get("parent_name"),
-            "users": obj.get("users"),
-            "users_obj": [GroupMember.from_dict(_item) for _item in obj.get("users_obj")] if obj.get("users_obj") is not None else None,
-            "attributes": obj.get("attributes"),
-            "roles": obj.get("roles"),
-            "roles_obj": [Role.from_dict(_item) for _item in obj.get("roles_obj")] if obj.get("roles_obj") is not None else None
+            "provider": obj.get("provider"),
+            "provider_obj": RACProvider.from_dict(obj["provider_obj"]) if obj.get("provider_obj") is not None else None,
+            "protocol": obj.get("protocol"),
+            "host": obj.get("host"),
+            "settings": obj.get("settings"),
+            "property_mappings": obj.get("property_mappings"),
+            "auth_mode": obj.get("auth_mode"),
+            "launch_url": obj.get("launch_url"),
+            "maximum_connections": obj.get("maximum_connections")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/group_member.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/group_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,87 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GroupMember(BaseModel):
+class GroupRequest(BaseModel):
     """
-    Stripped down user serializer to show relevant users for groups  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    username: constr(strict=True, max_length=150) = Field(..., description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
-    name: StrictStr = Field(..., description="User's display name.")
-    is_active: Optional[StrictBool] = Field(None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
-    last_login: Optional[datetime] = None
-    email: Optional[constr(strict=True, max_length=254)] = None
+    Group Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=80)]
+    is_superuser: Optional[StrictBool] = Field(default=None, description="Users added to this group will be superusers.")
+    parent: Optional[StrictStr] = None
+    users: Optional[List[StrictInt]] = None
     attributes: Optional[Dict[str, Any]] = None
-    uid: StrictStr = Field(...)
-    __properties = ["pk", "username", "name", "is_active", "last_login", "email", "attributes", "uid"]
+    roles: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "is_superuser", "parent", "users", "attributes", "roles"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    @validator('username')
-    def username_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[\w.@+-]+$", value):
-            raise ValueError(r"must validate the regular expression /^[\w.@+-]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GroupMember:
-        """Create an instance of GroupMember from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GroupRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "uid",
-                          },
-                          exclude_none=True)
-        # set to None if last_login (nullable) is None
-        # and __fields_set__ contains the field
-        if self.last_login is None and "last_login" in self.__fields_set__:
-            _dict['last_login'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if parent (nullable) is None
+        # and model_fields_set contains the field
+        if self.parent is None and "parent" in self.model_fields_set:
+            _dict['parent'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GroupMember:
-        """Create an instance of GroupMember from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GroupRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GroupMember.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GroupMember.parse_obj({
-            "pk": obj.get("pk"),
-            "username": obj.get("username"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "is_active": obj.get("is_active"),
-            "last_login": obj.get("last_login"),
-            "email": obj.get("email"),
+            "is_superuser": obj.get("is_superuser"),
+            "parent": obj.get("parent"),
+            "users": obj.get("users"),
             "attributes": obj.get("attributes"),
-            "uid": obj.get("uid")
+            "roles": obj.get("roles")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/group_member_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_reputation_policy_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,81 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-class GroupMemberRequest(BaseModel):
+class PatchedReputationPolicyRequest(BaseModel):
     """
-    Stripped down user serializer to show relevant users for groups  # noqa: E501
-    """
-    username: constr(strict=True, max_length=150, min_length=1) = Field(..., description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
-    name: constr(strict=True, min_length=1) = Field(..., description="User's display name.")
-    is_active: Optional[StrictBool] = Field(None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
-    last_login: Optional[datetime] = None
-    email: Optional[constr(strict=True, max_length=254)] = None
-    attributes: Optional[Dict[str, Any]] = None
-    __properties = ["username", "name", "is_active", "last_login", "email", "attributes"]
-
-    @validator('username')
-    def username_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[\w.@+-]+$", value):
-            raise ValueError(r"must validate the regular expression /^[\w.@+-]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Reputation Policy Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    check_ip: Optional[StrictBool] = None
+    check_username: Optional[StrictBool] = None
+    threshold: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "check_ip", "check_username", "threshold"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GroupMemberRequest:
-        """Create an instance of GroupMemberRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedReputationPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if last_login (nullable) is None
-        # and __fields_set__ contains the field
-        if self.last_login is None and "last_login" in self.__fields_set__:
-            _dict['last_login'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GroupMemberRequest:
-        """Create an instance of GroupMemberRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedReputationPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GroupMemberRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GroupMemberRequest.parse_obj({
-            "username": obj.get("username"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "is_active": obj.get("is_active"),
-            "last_login": obj.get("last_login"),
-            "email": obj.get("email"),
-            "attributes": obj.get("attributes")
+            "execution_logging": obj.get("execution_logging"),
+            "check_ip": obj.get("check_ip"),
+            "check_username": obj.get("check_username"),
+            "threshold": obj.get("threshold")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/group_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/app.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,74 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr
-
-class GroupRequest(BaseModel):
-    """
-    Group Serializer  # noqa: E501
+class App(BaseModel):
     """
-    name: constr(strict=True, max_length=80, min_length=1) = Field(...)
-    is_superuser: Optional[StrictBool] = Field(None, description="Users added to this group will be superusers.")
-    parent: Optional[StrictStr] = None
-    users: Optional[conlist(StrictInt)] = None
-    attributes: Optional[Dict[str, Any]] = None
-    roles: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "is_superuser", "parent", "users", "attributes", "roles"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serialize Application info
+    """ # noqa: E501
+    name: StrictStr
+    label: StrictStr
+    __properties: ClassVar[List[str]] = ["name", "label"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> GroupRequest:
-        """Create an instance of GroupRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of App from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if parent (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parent is None and "parent" in self.__fields_set__:
-            _dict['parent'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> GroupRequest:
-        """Create an instance of GroupRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of App from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return GroupRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = GroupRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "is_superuser": obj.get("is_superuser"),
-            "parent": obj.get("parent"),
-            "users": obj.get("users"),
-            "attributes": obj.get("attributes"),
-            "roles": obj.get("roles")
+            "label": obj.get("label")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_challenge.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,118 +14,137 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from authentik_client.models.flow_designation_enum import FlowDesignationEnum
 from authentik_client.models.login_source import LoginSource
+from typing import Optional, Set
+from typing_extensions import Self
 
 class IdentificationChallenge(BaseModel):
     """
-    Identification challenges with all UI elements  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Identification challenges with all UI elements
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-stage-identification'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    user_fields: Optional[conlist(StrictStr)] = Field(...)
-    password_fields: StrictBool = Field(...)
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    user_fields: Optional[List[StrictStr]]
+    password_fields: StrictBool
     application_pre: Optional[StrictStr] = None
+    flow_designation: FlowDesignationEnum
     enroll_url: Optional[StrictStr] = None
     recovery_url: Optional[StrictStr] = None
     passwordless_url: Optional[StrictStr] = None
-    primary_action: StrictStr = Field(...)
-    sources: Optional[conlist(LoginSource)] = None
-    show_source_labels: StrictBool = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "user_fields", "password_fields", "application_pre", "enroll_url", "recovery_url", "passwordless_url", "primary_action", "sources", "show_source_labels"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    primary_action: StrictStr
+    sources: Optional[List[LoginSource]] = None
+    show_source_labels: StrictBool
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "user_fields", "password_fields", "application_pre", "flow_designation", "enroll_url", "recovery_url", "passwordless_url", "primary_action", "sources", "show_source_labels"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> IdentificationChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of IdentificationChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         # override the default output from pydantic by calling `to_dict()` of each item in sources (list)
         _items = []
         if self.sources:
             for _item in self.sources:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['sources'] = _items
         # set to None if user_fields (nullable) is None
-        # and __fields_set__ contains the field
-        if self.user_fields is None and "user_fields" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.user_fields is None and "user_fields" in self.model_fields_set:
             _dict['user_fields'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> IdentificationChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of IdentificationChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return IdentificationChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = IdentificationChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-identification',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
             "user_fields": obj.get("user_fields"),
             "password_fields": obj.get("password_fields"),
             "application_pre": obj.get("application_pre"),
+            "flow_designation": obj.get("flow_designation"),
             "enroll_url": obj.get("enroll_url"),
             "recovery_url": obj.get("recovery_url"),
             "passwordless_url": obj.get("passwordless_url"),
             "primary_action": obj.get("primary_action"),
-            "sources": [LoginSource.from_dict(_item) for _item in obj.get("sources")] if obj.get("sources") is not None else None,
+            "sources": [LoginSource.from_dict(_item) for _item in obj["sources"]] if obj.get("sources") is not None else None,
             "show_source_labels": obj.get("show_source_labels")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_duo_challenge_response_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,68 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class IdentificationChallengeResponseRequest(BaseModel):
-    """
-    Identification challenge  # noqa: E501
+class AuthenticatorDuoChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-identification'
-    uid_field: constr(strict=True, min_length=1) = Field(...)
-    password: Optional[StrictStr] = None
-    __properties = ["component", "uid_field", "password"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Pseudo class for duo response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-authenticator-duo'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> IdentificationChallengeResponseRequest:
-        """Create an instance of IdentificationChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorDuoChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if password (nullable) is None
-        # and __fields_set__ contains the field
-        if self.password is None and "password" in self.__fields_set__:
-            _dict['password'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> IdentificationChallengeResponseRequest:
-        """Create an instance of IdentificationChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorDuoChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return IdentificationChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = IdentificationChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-identification',
-            "uid_field": obj.get("uid_field"),
-            "password": obj.get("password")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-authenticator-duo'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/source.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,125 +14,147 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-from authentik_client.models.user_fields_enum import UserFieldsEnum
-
-class IdentificationStage(BaseModel):
-    """
-    IdentificationStage Serializer  # noqa: E501
+class Source(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    user_fields: Optional[conlist(UserFieldsEnum)] = Field(None, description="Fields of the user object to match against. (Hold shift to select multiple options)")
-    password_stage: Optional[StrictStr] = Field(None, description="When set, shows a password field, instead of showing the password field as seaprate step.")
-    case_insensitive_matching: Optional[StrictBool] = Field(None, description="When enabled, user fields are matched regardless of their casing.")
-    show_matched_user: Optional[StrictBool] = Field(None, description="When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Optional enrollment flow, which is linked at the bottom of the page.")
-    recovery_flow: Optional[StrictStr] = Field(None, description="Optional recovery flow, which is linked at the bottom of the page.")
-    passwordless_flow: Optional[StrictStr] = Field(None, description="Optional passwordless flow, which is linked at the bottom of the page.")
-    sources: Optional[conlist(StrictStr)] = Field(None, description="Specify which sources should be shown.")
-    show_source_labels: Optional[StrictBool] = None
-    pretend_user_exists: Optional[StrictBool] = Field(None, description="When enabled, the stage will succeed and continue even when incorrect user info is entered.")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "user_fields", "password_stage", "case_insensitive_matching", "show_matched_user", "enrollment_flow", "recovery_flow", "passwordless_flow", "sources", "show_source_labels", "pretend_user_exists"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Source Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
+    enabled: Optional[StrictBool] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    policy_engine_mode: Optional[PolicyEngineMode] = None
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    managed: Optional[StrictStr] = Field(description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    user_path_template: Optional[StrictStr] = None
+    icon: Optional[StrictStr] = Field(description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
+    __properties: ClassVar[List[str]] = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon"]
+
+    @field_validator('slug')
+    def slug_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
+            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
+        return value
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> IdentificationStage:
-        """Create an instance of IdentificationStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Source from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if password_stage (nullable) is None
-        # and __fields_set__ contains the field
-        if self.password_stage is None and "password_stage" in self.__fields_set__:
-            _dict['password_stage'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "managed",
+            "icon",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
-        # set to None if recovery_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.recovery_flow is None and "recovery_flow" in self.__fields_set__:
-            _dict['recovery_flow'] = None
-
-        # set to None if passwordless_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.passwordless_flow is None and "passwordless_flow" in self.__fields_set__:
-            _dict['passwordless_flow'] = None
+        # set to None if managed (nullable) is None
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
+            _dict['managed'] = None
+
+        # set to None if icon (nullable) is None
+        # and model_fields_set contains the field
+        if self.icon is None and "icon" in self.model_fields_set:
+            _dict['icon'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> IdentificationStage:
-        """Create an instance of IdentificationStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Source from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return IdentificationStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = IdentificationStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
+            "slug": obj.get("slug"),
+            "enabled": obj.get("enabled"),
+            "authentication_flow": obj.get("authentication_flow"),
+            "enrollment_flow": obj.get("enrollment_flow"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "user_fields": obj.get("user_fields"),
-            "password_stage": obj.get("password_stage"),
-            "case_insensitive_matching": obj.get("case_insensitive_matching"),
-            "show_matched_user": obj.get("show_matched_user"),
-            "enrollment_flow": obj.get("enrollment_flow"),
-            "recovery_flow": obj.get("recovery_flow"),
-            "passwordless_flow": obj.get("passwordless_flow"),
-            "sources": obj.get("sources"),
-            "show_source_labels": obj.get("show_source_labels"),
-            "pretend_user_exists": obj.get("pretend_user_exists")
+            "policy_engine_mode": obj.get("policy_engine_mode"),
+            "user_matching_mode": obj.get("user_matching_mode"),
+            "managed": obj.get("managed"),
+            "user_path_template": obj.get("user_path_template"),
+            "icon": obj.get("icon")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/identification_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,110 +14,117 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-from authentik_client.models.user_fields_enum import UserFieldsEnum
-
-class IdentificationStageRequest(BaseModel):
-    """
-    IdentificationStage Serializer  # noqa: E501
+class PlexSourceRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    user_fields: Optional[conlist(UserFieldsEnum)] = Field(None, description="Fields of the user object to match against. (Hold shift to select multiple options)")
-    password_stage: Optional[StrictStr] = Field(None, description="When set, shows a password field, instead of showing the password field as seaprate step.")
-    case_insensitive_matching: Optional[StrictBool] = Field(None, description="When enabled, user fields are matched regardless of their casing.")
-    show_matched_user: Optional[StrictBool] = Field(None, description="When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Optional enrollment flow, which is linked at the bottom of the page.")
-    recovery_flow: Optional[StrictStr] = Field(None, description="Optional recovery flow, which is linked at the bottom of the page.")
-    passwordless_flow: Optional[StrictStr] = Field(None, description="Optional passwordless flow, which is linked at the bottom of the page.")
-    sources: Optional[conlist(StrictStr)] = Field(None, description="Specify which sources should be shown.")
-    show_source_labels: Optional[StrictBool] = None
-    pretend_user_exists: Optional[StrictBool] = Field(None, description="When enabled, the stage will succeed and continue even when incorrect user info is entered.")
-    __properties = ["name", "flow_set", "user_fields", "password_stage", "case_insensitive_matching", "show_matched_user", "enrollment_flow", "recovery_flow", "passwordless_flow", "sources", "show_source_labels", "pretend_user_exists"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Plex Source Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(min_length=1, strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
+    enabled: Optional[StrictBool] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    policy_engine_mode: Optional[PolicyEngineMode] = None
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    client_id: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Client identifier used to talk to Plex.")
+    allowed_servers: Optional[List[Annotated[str, Field(min_length=1, strict=True)]]] = Field(default=None, description="Which servers a user has to be a member of to be granted access. Empty list allows every server.")
+    allow_friends: Optional[StrictBool] = Field(default=None, description="Allow friends to authenticate, even if you don't share a server.")
+    plex_token: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Plex token used to check friends")
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "client_id", "allowed_servers", "allow_friends", "plex_token"]
+
+    @field_validator('slug')
+    def slug_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
+            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
+        return value
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> IdentificationStageRequest:
-        """Create an instance of IdentificationStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PlexSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if password_stage (nullable) is None
-        # and __fields_set__ contains the field
-        if self.password_stage is None and "password_stage" in self.__fields_set__:
-            _dict['password_stage'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
-        # set to None if recovery_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.recovery_flow is None and "recovery_flow" in self.__fields_set__:
-            _dict['recovery_flow'] = None
-
-        # set to None if passwordless_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.passwordless_flow is None and "passwordless_flow" in self.__fields_set__:
-            _dict['passwordless_flow'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> IdentificationStageRequest:
-        """Create an instance of IdentificationStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PlexSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return IdentificationStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = IdentificationStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "user_fields": obj.get("user_fields"),
-            "password_stage": obj.get("password_stage"),
-            "case_insensitive_matching": obj.get("case_insensitive_matching"),
-            "show_matched_user": obj.get("show_matched_user"),
+            "slug": obj.get("slug"),
+            "enabled": obj.get("enabled"),
+            "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
-            "recovery_flow": obj.get("recovery_flow"),
-            "passwordless_flow": obj.get("passwordless_flow"),
-            "sources": obj.get("sources"),
-            "show_source_labels": obj.get("show_source_labels"),
-            "pretend_user_exists": obj.get("pretend_user_exists")
+            "policy_engine_mode": obj.get("policy_engine_mode"),
+            "user_matching_mode": obj.get("user_matching_mode"),
+            "user_path_template": obj.get("user_path_template"),
+            "client_id": obj.get("client_id"),
+            "allowed_servers": obj.get("allowed_servers"),
+            "allow_friends": obj.get("allow_friends"),
+            "plex_token": obj.get("plex_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/intent_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,35 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class IntentEnum(str, Enum):
+class ProviderEnum(str, Enum):
     """
-    IntentEnum
+    ProviderEnum
     """
 
     """
     allowed enum values
     """
-    VERIFICATION = 'verification'
-    API = 'api'
-    RECOVERY = 'recovery'
-    APP_PASSWORD = 'app_password'
+    TWILIO = 'twilio'
+    GENERIC = 'generic'
 
     @classmethod
-    def from_json(cls, json_str: str) -> IntentEnum:
-        """Create an instance of IntentEnum from a JSON string"""
-        return IntentEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ProviderEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/invalid_response_action_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/invalid_response_action_enum.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class InvalidResponseActionEnum(str, Enum):
     """
     InvalidResponseActionEnum
     """
 
@@ -31,12 +28,12 @@
     allowed enum values
     """
     RETRY = 'retry'
     RESTART = 'restart'
     RESTART_WITH_CONTEXT = 'restart_with_context'
 
     @classmethod
-    def from_json(cls, json_str: str) -> InvalidResponseActionEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of InvalidResponseActionEnum from a JSON string"""
-        return InvalidResponseActionEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,95 +15,116 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow import Flow
 from authentik_client.models.group_member import GroupMember
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Invitation(BaseModel):
     """
-    Invitation Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: constr(strict=True, max_length=50) = Field(...)
+    Invitation Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: Annotated[str, Field(strict=True, max_length=50)]
     expires: Optional[datetime] = None
     fixed_data: Optional[Dict[str, Any]] = None
-    created_by: GroupMember = Field(...)
-    single_use: Optional[StrictBool] = Field(None, description="When enabled, the invitation will be deleted after usage.")
-    flow: Optional[StrictStr] = Field(None, description="When set, only the configured flow can use this invitation.")
-    flow_obj: Flow = Field(...)
-    __properties = ["pk", "name", "expires", "fixed_data", "created_by", "single_use", "flow", "flow_obj"]
+    created_by: GroupMember
+    single_use: Optional[StrictBool] = Field(default=None, description="When enabled, the invitation will be deleted after usage.")
+    flow: Optional[StrictStr] = Field(default=None, description="When set, only the configured flow can use this invitation.")
+    flow_obj: Flow
+    __properties: ClassVar[List[str]] = ["pk", "name", "expires", "fixed_data", "created_by", "single_use", "flow", "flow_obj"]
 
-    @validator('name')
+    @field_validator('name')
     def name_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Invitation:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Invitation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "created_by",
-                            "flow_obj",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "created_by",
+            "flow_obj",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of created_by
         if self.created_by:
             _dict['created_by'] = self.created_by.to_dict()
         # override the default output from pydantic by calling `to_dict()` of flow_obj
         if self.flow_obj:
             _dict['flow_obj'] = self.flow_obj.to_dict()
         # set to None if flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow is None and "flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow is None and "flow" in self.model_fields_set:
             _dict['flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Invitation:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Invitation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Invitation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Invitation.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "expires": obj.get("expires"),
             "fixed_data": obj.get("fixed_data"),
-            "created_by": GroupMember.from_dict(obj.get("created_by")) if obj.get("created_by") is not None else None,
+            "created_by": GroupMember.from_dict(obj["created_by"]) if obj.get("created_by") is not None else None,
             "single_use": obj.get("single_use"),
             "flow": obj.get("flow"),
-            "flow_obj": Flow.from_dict(obj.get("flow_obj")) if obj.get("flow_obj") is not None else None
+            "flow_obj": Flow.from_dict(obj["flow_obj"]) if obj.get("flow_obj") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -15,76 +15,94 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class InvitationRequest(BaseModel):
     """
-    Invitation Serializer  # noqa: E501
-    """
-    name: constr(strict=True, max_length=50, min_length=1) = Field(...)
+    Invitation Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=50)]
     expires: Optional[datetime] = None
     fixed_data: Optional[Dict[str, Any]] = None
-    single_use: Optional[StrictBool] = Field(None, description="When enabled, the invitation will be deleted after usage.")
-    flow: Optional[StrictStr] = Field(None, description="When set, only the configured flow can use this invitation.")
-    __properties = ["name", "expires", "fixed_data", "single_use", "flow"]
+    single_use: Optional[StrictBool] = Field(default=None, description="When enabled, the invitation will be deleted after usage.")
+    flow: Optional[StrictStr] = Field(default=None, description="When set, only the configured flow can use this invitation.")
+    __properties: ClassVar[List[str]] = ["name", "expires", "fixed_data", "single_use", "flow"]
 
-    @validator('name')
+    @field_validator('name')
     def name_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> InvitationRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of InvitationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow is None and "flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow is None and "flow" in self.model_fields_set:
             _dict['flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> InvitationRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of InvitationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return InvitationRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = InvitationRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "expires": obj.get("expires"),
             "fixed_data": obj.get("fixed_data"),
             "single_use": obj.get("single_use"),
             "flow": obj.get("flow")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation_stage_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,86 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-
-class InvitationStage(BaseModel):
-    """
-    InvitationStage Serializer  # noqa: E501
+class InvitationStageRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    continue_flow_without_invitation: Optional[StrictBool] = Field(None, description="If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "continue_flow_without_invitation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    InvitationStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    continue_flow_without_invitation: Optional[StrictBool] = Field(default=None, description="If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "continue_flow_without_invitation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> InvitationStage:
-        """Create an instance of InvitationStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of InvitationStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> InvitationStage:
-        """Create an instance of InvitationStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of InvitationStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return InvitationStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = InvitationStage.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "continue_flow_without_invitation": obj.get("continue_flow_without_invitation")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/invitation_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_invitation_stage_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,71 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class InvitationStageRequest(BaseModel):
-    """
-    InvitationStage Serializer  # noqa: E501
+class PatchedInvitationStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    continue_flow_without_invitation: Optional[StrictBool] = Field(None, description="If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.")
-    __properties = ["name", "flow_set", "continue_flow_without_invitation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    InvitationStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    continue_flow_without_invitation: Optional[StrictBool] = Field(default=None, description="If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "continue_flow_without_invitation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> InvitationStageRequest:
-        """Create an instance of InvitationStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedInvitationStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> InvitationStageRequest:
-        """Create an instance of InvitationStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedInvitationStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return InvitationStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = InvitationStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "continue_flow_without_invitation": obj.get("continue_flow_without_invitation")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/issuer_mode_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_stage_mode_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,33 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class IssuerModeEnum(str, Enum):
+class ConsentStageModeEnum(str, Enum):
     """
-    IssuerModeEnum
+    ConsentStageModeEnum
     """
 
     """
     allowed enum values
     """
-    GLOBAL = 'global'
-    PER_PROVIDER = 'per_provider'
+    ALWAYS_REQUIRE = 'always_require'
+    PERMANENT = 'permanent'
+    EXPIRING = 'expiring'
 
     @classmethod
-    def from_json(cls, json_str: str) -> IssuerModeEnum:
-        """Create an instance of IssuerModeEnum from a JSON string"""
-        return IssuerModeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ConsentStageModeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/kubernetes_service_connection.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/service_connection.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,85 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-
-class KubernetesServiceConnection(BaseModel):
-    """
-    KubernetesServiceConnection Serializer  # noqa: E501
+class ServiceConnection(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    component: StrictStr = Field(...)
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    kubeconfig: Optional[Any] = Field(None, description="Paste your kubeconfig here. authentik will automatically use the currently selected context.")
-    verify_ssl: Optional[StrictBool] = Field(None, description="Verify SSL Certificates of the Kubernetes API endpoint")
-    __properties = ["pk", "name", "local", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "kubeconfig", "verify_ssl"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ServiceConnection Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    component: StrictStr = Field(description="Return component used to edit this object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    __properties: ClassVar[List[str]] = ["pk", "name", "local", "component", "verbose_name", "verbose_name_plural", "meta_model_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> KubernetesServiceConnection:
-        """Create an instance of KubernetesServiceConnection from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ServiceConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # set to None if kubeconfig (nullable) is None
-        # and __fields_set__ contains the field
-        if self.kubeconfig is None and "kubeconfig" in self.__fields_set__:
-            _dict['kubeconfig'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> KubernetesServiceConnection:
-        """Create an instance of KubernetesServiceConnection from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ServiceConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return KubernetesServiceConnection.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = KubernetesServiceConnection.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "local": obj.get("local"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "kubeconfig": obj.get("kubeconfig"),
-            "verify_ssl": obj.get("verify_ssl")
+            "meta_model_name": obj.get("meta_model_name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/kubernetes_service_connection_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_domain_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,70 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-
-class KubernetesServiceConnectionRequest(BaseModel):
-    """
-    KubernetesServiceConnection Serializer  # noqa: E501
+class PatchedDomainRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    kubeconfig: Optional[Any] = Field(None, description="Paste your kubeconfig here. authentik will automatically use the currently selected context.")
-    verify_ssl: Optional[StrictBool] = Field(None, description="Verify SSL Certificates of the Kubernetes API endpoint")
-    __properties = ["name", "local", "kubeconfig", "verify_ssl"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Domain Serializer
+    """ # noqa: E501
+    domain: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=253)]] = None
+    is_primary: Optional[StrictBool] = None
+    tenant: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["domain", "is_primary", "tenant"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> KubernetesServiceConnectionRequest:
-        """Create an instance of KubernetesServiceConnectionRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedDomainRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if kubeconfig (nullable) is None
-        # and __fields_set__ contains the field
-        if self.kubeconfig is None and "kubeconfig" in self.__fields_set__:
-            _dict['kubeconfig'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> KubernetesServiceConnectionRequest:
-        """Create an instance of KubernetesServiceConnectionRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedDomainRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return KubernetesServiceConnectionRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = KubernetesServiceConnectionRequest.parse_obj({
-            "name": obj.get("name"),
-            "local": obj.get("local"),
-            "kubeconfig": obj.get("kubeconfig"),
-            "verify_ssl": obj.get("verify_ssl")
+        _obj = cls.model_validate({
+            "domain": obj.get("domain"),
+            "is_primary": obj.get("is_primary"),
+            "tenant": obj.get("tenant")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_outpost_config.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_outpost_config.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,86 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.ldapapi_access_mode import LDAPAPIAccessMode
+from typing import Optional, Set
+from typing_extensions import Self
 
 class LDAPOutpostConfig(BaseModel):
     """
-    LDAPProvider Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    base_dn: Optional[StrictStr] = Field(None, description="DN under which objects are accessible.")
-    bind_flow_slug: StrictStr = Field(...)
-    application_slug: StrictStr = Field(..., description="Prioritise backchannel slug over direct application slug")
-    search_group: Optional[StrictStr] = Field(None, description="Users in this group can do search queries. If not set, every user can execute search queries.")
+    LDAPProvider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    base_dn: Optional[StrictStr] = Field(default=None, description="DN under which objects are accessible.")
+    bind_flow_slug: StrictStr
+    application_slug: StrictStr = Field(description="Prioritise backchannel slug over direct application slug")
+    search_group: Optional[StrictStr] = Field(default=None, description="Users in this group can do search queries. If not set, every user can execute search queries.")
     certificate: Optional[StrictStr] = None
     tls_server_name: Optional[StrictStr] = None
-    uid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber")
-    gid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber")
+    uid_start_number: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = Field(default=None, description="The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber")
+    gid_start_number: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = Field(default=None, description="The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber")
     search_mode: Optional[LDAPAPIAccessMode] = None
     bind_mode: Optional[LDAPAPIAccessMode] = None
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["pk", "name", "base_dn", "bind_flow_slug", "application_slug", "search_group", "certificate", "tls_server_name", "uid_start_number", "gid_start_number", "search_mode", "bind_mode", "mfa_support"]
+    mfa_support: Optional[StrictBool] = Field(default=None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "base_dn", "bind_flow_slug", "application_slug", "search_group", "certificate", "tls_server_name", "uid_start_number", "gid_start_number", "search_mode", "bind_mode", "mfa_support"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPOutpostConfig:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of LDAPOutpostConfig from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "application_slug",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "application_slug",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if search_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.search_group is None and "search_group" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.search_group is None and "search_group" in self.model_fields_set:
             _dict['search_group'] = None
 
         # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.certificate is None and "certificate" in self.model_fields_set:
             _dict['certificate'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPOutpostConfig:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of LDAPOutpostConfig from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPOutpostConfig.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPOutpostConfig.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "base_dn": obj.get("base_dn"),
             "bind_flow_slug": obj.get("bind_flow_slug"),
             "application_slug": obj.get("application_slug"),
             "search_group": obj.get("search_group"),
             "certificate": obj.get("certificate"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_property_mapping.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_saml_property_mapping_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,85 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-
-class LDAPPropertyMapping(BaseModel):
-    """
-    LDAP PropertyMapping Serializer  # noqa: E501
+class PatchedSAMLPropertyMappingRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    managed: Optional[StrictStr] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: StrictStr = Field(...)
-    expression: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object's component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    object_field: StrictStr = Field(...)
-    __properties = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "object_field"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAMLPropertyMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    expression: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    saml_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    friendly_name: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression", "saml_name", "friendly_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPPropertyMapping:
-        """Create an instance of LDAPPropertyMapping from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSAMLPropertyMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
+        # set to None if friendly_name (nullable) is None
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
+            _dict['friendly_name'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPPropertyMapping:
-        """Create an instance of LDAPPropertyMapping from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSAMLPropertyMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPPropertyMapping.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPPropertyMapping.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "object_field": obj.get("object_field")
+            "saml_name": obj.get("saml_name"),
+            "friendly_name": obj.get("friendly_name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_property_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_scim_mapping_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,70 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class LDAPPropertyMappingRequest(BaseModel):
-    """
-    LDAP PropertyMapping Serializer  # noqa: E501
+class PatchedSCIMMappingRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: constr(strict=True, min_length=1) = Field(...)
-    expression: constr(strict=True, min_length=1) = Field(...)
-    object_field: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["managed", "name", "expression", "object_field"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SCIMMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    expression: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPPropertyMappingRequest:
-        """Create an instance of LDAPPropertyMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSCIMMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPPropertyMappingRequest:
-        """Create an instance of LDAPPropertyMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSCIMMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPPropertyMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPPropertyMappingRequest.parse_obj({
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "name": obj.get("name"),
-            "expression": obj.get("expression"),
-            "object_field": obj.get("object_field")
+            "expression": obj.get("expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_provider.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,129 +14,137 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist
-from authentik_client.models.ldapapi_access_mode import LDAPAPIAccessMode
-
-class LDAPProvider(BaseModel):
-    """
-    LDAPProvider Serializer  # noqa: E501
+class RACProvider(BaseModel):
     """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    base_dn: Optional[StrictStr] = Field(None, description="DN under which objects are accessible.")
-    search_group: Optional[StrictStr] = Field(None, description="Users in this group can do search queries. If not set, every user can execute search queries.")
-    certificate: Optional[StrictStr] = None
-    tls_server_name: Optional[StrictStr] = None
-    uid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber")
-    gid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber")
-    outpost_set: conlist(StrictStr) = Field(...)
-    search_mode: Optional[LDAPAPIAccessMode] = None
-    bind_mode: Optional[LDAPAPIAccessMode] = None
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "base_dn", "search_group", "certificate", "tls_server_name", "uid_start_number", "gid_start_number", "outpost_set", "search_mode", "bind_mode", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RACProvider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    assigned_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_application_name: StrictStr = Field(description="Application's display Name.")
+    assigned_backchannel_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_backchannel_application_name: StrictStr = Field(description="Application's display Name.")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    settings: Optional[Any] = None
+    outpost_set: List[StrictStr]
+    connection_expiry: Optional[StrictStr] = Field(default=None, description="Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)")
+    delete_token_on_disconnect: Optional[StrictBool] = Field(default=None, description="When set to true, connection tokens will be deleted upon disconnect.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "settings", "outpost_set", "connection_expiry", "delete_token_on_disconnect"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPProvider:
-        """Create an instance of LDAPProvider from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RACProvider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "outpost_set",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "assigned_application_slug",
+            "assigned_application_name",
+            "assigned_backchannel_application_slug",
+            "assigned_backchannel_application_name",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "outpost_set",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
-        # set to None if search_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.search_group is None and "search_group" in self.__fields_set__:
-            _dict['search_group'] = None
-
-        # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
-            _dict['certificate'] = None
+        # set to None if settings (nullable) is None
+        # and model_fields_set contains the field
+        if self.settings is None and "settings" in self.model_fields_set:
+            _dict['settings'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPProvider:
-        """Create an instance of LDAPProvider from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RACProvider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPProvider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPProvider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "component": obj.get("component"),
             "assigned_application_slug": obj.get("assigned_application_slug"),
             "assigned_application_name": obj.get("assigned_application_name"),
             "assigned_backchannel_application_slug": obj.get("assigned_backchannel_application_slug"),
             "assigned_backchannel_application_name": obj.get("assigned_backchannel_application_name"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "base_dn": obj.get("base_dn"),
-            "search_group": obj.get("search_group"),
-            "certificate": obj.get("certificate"),
-            "tls_server_name": obj.get("tls_server_name"),
-            "uid_start_number": obj.get("uid_start_number"),
-            "gid_start_number": obj.get("gid_start_number"),
+            "settings": obj.get("settings"),
             "outpost_set": obj.get("outpost_set"),
-            "search_mode": obj.get("search_mode"),
-            "bind_mode": obj.get("bind_mode"),
-            "mfa_support": obj.get("mfa_support")
+            "connection_expiry": obj.get("connection_expiry"),
+            "delete_token_on_disconnect": obj.get("delete_token_on_disconnect")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_plex_source_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,99 +14,120 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
-from authentik_client.models.ldapapi_access_mode import LDAPAPIAccessMode
-
-class LDAPProviderRequest(BaseModel):
-    """
-    LDAPProvider Serializer  # noqa: E501
+class PatchedPlexSourceRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    base_dn: Optional[constr(strict=True, min_length=1)] = Field(None, description="DN under which objects are accessible.")
-    search_group: Optional[StrictStr] = Field(None, description="Users in this group can do search queries. If not set, every user can execute search queries.")
-    certificate: Optional[StrictStr] = None
-    tls_server_name: Optional[StrictStr] = None
-    uid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber")
-    gid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber")
-    search_mode: Optional[LDAPAPIAccessMode] = None
-    bind_mode: Optional[LDAPAPIAccessMode] = None
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "base_dn", "search_group", "certificate", "tls_server_name", "uid_start_number", "gid_start_number", "search_mode", "bind_mode", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Plex Source Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Source's display Name.")
+    slug: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Internal source name, used in URLs.")
+    enabled: Optional[StrictBool] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    policy_engine_mode: Optional[PolicyEngineMode] = None
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    client_id: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Client identifier used to talk to Plex.")
+    allowed_servers: Optional[List[Annotated[str, Field(min_length=1, strict=True)]]] = Field(default=None, description="Which servers a user has to be a member of to be granted access. Empty list allows every server.")
+    allow_friends: Optional[StrictBool] = Field(default=None, description="Allow friends to authenticate, even if you don't share a server.")
+    plex_token: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Plex token used to check friends")
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "client_id", "allowed_servers", "allow_friends", "plex_token"]
+
+    @field_validator('slug')
+    def slug_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
+            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
+        return value
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPProviderRequest:
-        """Create an instance of LDAPProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPlexSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
-        # set to None if search_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.search_group is None and "search_group" in self.__fields_set__:
-            _dict['search_group'] = None
-
-        # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
-            _dict['certificate'] = None
+        # set to None if enrollment_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
+            _dict['enrollment_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPProviderRequest:
-        """Create an instance of LDAPProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPlexSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
+            "slug": obj.get("slug"),
+            "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings"),
-            "base_dn": obj.get("base_dn"),
-            "search_group": obj.get("search_group"),
-            "certificate": obj.get("certificate"),
-            "tls_server_name": obj.get("tls_server_name"),
-            "uid_start_number": obj.get("uid_start_number"),
-            "gid_start_number": obj.get("gid_start_number"),
-            "search_mode": obj.get("search_mode"),
-            "bind_mode": obj.get("bind_mode"),
-            "mfa_support": obj.get("mfa_support")
+            "enrollment_flow": obj.get("enrollment_flow"),
+            "policy_engine_mode": obj.get("policy_engine_mode"),
+            "user_matching_mode": obj.get("user_matching_mode"),
+            "user_path_template": obj.get("user_path_template"),
+            "client_id": obj.get("client_id"),
+            "allowed_servers": obj.get("allowed_servers"),
+            "allow_friends": obj.get("allow_friends"),
+            "plex_token": obj.get("plex_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_source.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_source.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,152 +14,178 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class LDAPSource(BaseModel):
     """
-    LDAP Source Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50) = Field(..., description="Internal source name, used in URLs.")
+    LDAP Source Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    managed: Optional[StrictStr] = Field(..., description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    managed: Optional[StrictStr] = Field(description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
     user_path_template: Optional[StrictStr] = None
-    icon: Optional[StrictStr] = Field(..., description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
-    server_uri: StrictStr = Field(...)
-    peer_certificate: Optional[StrictStr] = Field(None, description="Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.")
-    client_certificate: Optional[StrictStr] = Field(None, description="Client certificate to authenticate against the LDAP Server's Certificate.")
+    icon: Optional[StrictStr] = Field(description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
+    server_uri: StrictStr
+    peer_certificate: Optional[StrictStr] = Field(default=None, description="Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.")
+    client_certificate: Optional[StrictStr] = Field(default=None, description="Client certificate to authenticate against the LDAP Server's Certificate.")
     bind_cn: Optional[StrictStr] = None
     start_tls: Optional[StrictBool] = None
     sni: Optional[StrictBool] = None
-    base_dn: StrictStr = Field(...)
-    additional_user_dn: Optional[StrictStr] = Field(None, description="Prepended to Base DN for User-queries.")
-    additional_group_dn: Optional[StrictStr] = Field(None, description="Prepended to Base DN for Group-queries.")
-    user_object_filter: Optional[StrictStr] = Field(None, description="Consider Objects matching this filter to be Users.")
-    group_object_filter: Optional[StrictStr] = Field(None, description="Consider Objects matching this filter to be Groups.")
-    group_membership_field: Optional[StrictStr] = Field(None, description="Field which contains members of a group.")
-    object_uniqueness_field: Optional[StrictStr] = Field(None, description="Field which contains a unique Identifier.")
+    base_dn: StrictStr
+    additional_user_dn: Optional[StrictStr] = Field(default=None, description="Prepended to Base DN for User-queries.")
+    additional_group_dn: Optional[StrictStr] = Field(default=None, description="Prepended to Base DN for Group-queries.")
+    user_object_filter: Optional[StrictStr] = Field(default=None, description="Consider Objects matching this filter to be Users.")
+    group_object_filter: Optional[StrictStr] = Field(default=None, description="Consider Objects matching this filter to be Groups.")
+    group_membership_field: Optional[StrictStr] = Field(default=None, description="Field which contains members of a group.")
+    object_uniqueness_field: Optional[StrictStr] = Field(default=None, description="Field which contains a unique Identifier.")
+    password_login_update_internal_password: Optional[StrictBool] = Field(default=None, description="Update internal authentik password when login succeeds with LDAP")
     sync_users: Optional[StrictBool] = None
-    sync_users_password: Optional[StrictBool] = Field(None, description="When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.")
+    sync_users_password: Optional[StrictBool] = Field(default=None, description="When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.")
     sync_groups: Optional[StrictBool] = None
     sync_parent_group: Optional[StrictStr] = None
-    property_mappings: Optional[conlist(StrictStr)] = None
-    property_mappings_group: Optional[conlist(StrictStr)] = Field(None, description="Property mappings used for group creation/updating.")
-    connectivity: Optional[Dict[str, Dict[str, StrictStr]]] = Field(..., description="Get cached source connectivity")
-    __properties = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "server_uri", "peer_certificate", "client_certificate", "bind_cn", "start_tls", "sni", "base_dn", "additional_user_dn", "additional_group_dn", "user_object_filter", "group_object_filter", "group_membership_field", "object_uniqueness_field", "sync_users", "sync_users_password", "sync_groups", "sync_parent_group", "property_mappings", "property_mappings_group", "connectivity"]
+    property_mappings: Optional[List[StrictStr]] = None
+    property_mappings_group: Optional[List[StrictStr]] = Field(default=None, description="Property mappings used for group creation/updating.")
+    connectivity: Optional[Dict[str, Dict[str, StrictStr]]] = Field(description="Get cached source connectivity")
+    __properties: ClassVar[List[str]] = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "server_uri", "peer_certificate", "client_certificate", "bind_cn", "start_tls", "sni", "base_dn", "additional_user_dn", "additional_group_dn", "user_object_filter", "group_object_filter", "group_membership_field", "object_uniqueness_field", "password_login_update_internal_password", "sync_users", "sync_users_password", "sync_groups", "sync_parent_group", "property_mappings", "property_mappings_group", "connectivity"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPSource:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of LDAPSource from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "managed",
-                            "icon",
-                            "connectivity",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "managed",
+            "icon",
+            "connectivity",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         # set to None if icon (nullable) is None
-        # and __fields_set__ contains the field
-        if self.icon is None and "icon" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.icon is None and "icon" in self.model_fields_set:
             _dict['icon'] = None
 
         # set to None if peer_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.peer_certificate is None and "peer_certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.peer_certificate is None and "peer_certificate" in self.model_fields_set:
             _dict['peer_certificate'] = None
 
         # set to None if client_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_certificate is None and "client_certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.client_certificate is None and "client_certificate" in self.model_fields_set:
             _dict['client_certificate'] = None
 
         # set to None if sync_parent_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.sync_parent_group is None and "sync_parent_group" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.sync_parent_group is None and "sync_parent_group" in self.model_fields_set:
             _dict['sync_parent_group'] = None
 
         # set to None if connectivity (nullable) is None
-        # and __fields_set__ contains the field
-        if self.connectivity is None and "connectivity" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.connectivity is None and "connectivity" in self.model_fields_set:
             _dict['connectivity'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPSource:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of LDAPSource from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPSource.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPSource.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "component": obj.get("component"),
@@ -180,14 +206,15 @@
             "base_dn": obj.get("base_dn"),
             "additional_user_dn": obj.get("additional_user_dn"),
             "additional_group_dn": obj.get("additional_group_dn"),
             "user_object_filter": obj.get("user_object_filter"),
             "group_object_filter": obj.get("group_object_filter"),
             "group_membership_field": obj.get("group_membership_field"),
             "object_uniqueness_field": obj.get("object_uniqueness_field"),
+            "password_login_update_internal_password": obj.get("password_login_update_internal_password"),
             "sync_users": obj.get("sync_users"),
             "sync_users_password": obj.get("sync_users_password"),
             "sync_groups": obj.get("sync_groups"),
             "sync_parent_group": obj.get("sync_parent_group"),
             "property_mappings": obj.get("property_mappings"),
             "property_mappings_group": obj.get("property_mappings_group"),
             "connectivity": obj.get("connectivity")
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_ldap_source_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,122 +14,143 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class LDAPSourceRequest(BaseModel):
-    """
-    LDAP Source Serializer  # noqa: E501
+class PatchedLDAPSourceRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Internal source name, used in URLs.")
+    LDAP Source Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Source's display Name.")
+    slug: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    server_uri: constr(strict=True, min_length=1) = Field(...)
-    peer_certificate: Optional[StrictStr] = Field(None, description="Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.")
-    client_certificate: Optional[StrictStr] = Field(None, description="Client certificate to authenticate against the LDAP Server's Certificate.")
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    server_uri: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    peer_certificate: Optional[StrictStr] = Field(default=None, description="Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.")
+    client_certificate: Optional[StrictStr] = Field(default=None, description="Client certificate to authenticate against the LDAP Server's Certificate.")
     bind_cn: Optional[StrictStr] = None
     bind_password: Optional[StrictStr] = None
     start_tls: Optional[StrictBool] = None
     sni: Optional[StrictBool] = None
-    base_dn: constr(strict=True, min_length=1) = Field(...)
-    additional_user_dn: Optional[StrictStr] = Field(None, description="Prepended to Base DN for User-queries.")
-    additional_group_dn: Optional[StrictStr] = Field(None, description="Prepended to Base DN for Group-queries.")
-    user_object_filter: Optional[constr(strict=True, min_length=1)] = Field(None, description="Consider Objects matching this filter to be Users.")
-    group_object_filter: Optional[constr(strict=True, min_length=1)] = Field(None, description="Consider Objects matching this filter to be Groups.")
-    group_membership_field: Optional[constr(strict=True, min_length=1)] = Field(None, description="Field which contains members of a group.")
-    object_uniqueness_field: Optional[constr(strict=True, min_length=1)] = Field(None, description="Field which contains a unique Identifier.")
+    base_dn: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    additional_user_dn: Optional[StrictStr] = Field(default=None, description="Prepended to Base DN for User-queries.")
+    additional_group_dn: Optional[StrictStr] = Field(default=None, description="Prepended to Base DN for Group-queries.")
+    user_object_filter: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Consider Objects matching this filter to be Users.")
+    group_object_filter: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Consider Objects matching this filter to be Groups.")
+    group_membership_field: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Field which contains members of a group.")
+    object_uniqueness_field: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Field which contains a unique Identifier.")
+    password_login_update_internal_password: Optional[StrictBool] = Field(default=None, description="Update internal authentik password when login succeeds with LDAP")
     sync_users: Optional[StrictBool] = None
-    sync_users_password: Optional[StrictBool] = Field(None, description="When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.")
+    sync_users_password: Optional[StrictBool] = Field(default=None, description="When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.")
     sync_groups: Optional[StrictBool] = None
     sync_parent_group: Optional[StrictStr] = None
-    property_mappings: Optional[conlist(StrictStr)] = None
-    property_mappings_group: Optional[conlist(StrictStr)] = Field(None, description="Property mappings used for group creation/updating.")
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "server_uri", "peer_certificate", "client_certificate", "bind_cn", "bind_password", "start_tls", "sni", "base_dn", "additional_user_dn", "additional_group_dn", "user_object_filter", "group_object_filter", "group_membership_field", "object_uniqueness_field", "sync_users", "sync_users_password", "sync_groups", "sync_parent_group", "property_mappings", "property_mappings_group"]
+    property_mappings: Optional[List[StrictStr]] = None
+    property_mappings_group: Optional[List[StrictStr]] = Field(default=None, description="Property mappings used for group creation/updating.")
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "server_uri", "peer_certificate", "client_certificate", "bind_cn", "bind_password", "start_tls", "sni", "base_dn", "additional_user_dn", "additional_group_dn", "user_object_filter", "group_object_filter", "group_membership_field", "object_uniqueness_field", "password_login_update_internal_password", "sync_users", "sync_users_password", "sync_groups", "sync_parent_group", "property_mappings", "property_mappings_group"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
+        if value is None:
+            return value
+
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPSourceRequest:
-        """Create an instance of LDAPSourceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedLDAPSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if peer_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.peer_certificate is None and "peer_certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.peer_certificate is None and "peer_certificate" in self.model_fields_set:
             _dict['peer_certificate'] = None
 
         # set to None if client_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_certificate is None and "client_certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.client_certificate is None and "client_certificate" in self.model_fields_set:
             _dict['client_certificate'] = None
 
         # set to None if sync_parent_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.sync_parent_group is None and "sync_parent_group" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.sync_parent_group is None and "sync_parent_group" in self.model_fields_set:
             _dict['sync_parent_group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPSourceRequest:
-        """Create an instance of LDAPSourceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedLDAPSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPSourceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "user_matching_mode": obj.get("user_matching_mode"),
@@ -144,14 +165,15 @@
             "base_dn": obj.get("base_dn"),
             "additional_user_dn": obj.get("additional_user_dn"),
             "additional_group_dn": obj.get("additional_group_dn"),
             "user_object_filter": obj.get("user_object_filter"),
             "group_object_filter": obj.get("group_object_filter"),
             "group_membership_field": obj.get("group_membership_field"),
             "object_uniqueness_field": obj.get("object_uniqueness_field"),
+            "password_login_update_internal_password": obj.get("password_login_update_internal_password"),
             "sync_users": obj.get("sync_users"),
             "sync_users_password": obj.get("sync_users_password"),
             "sync_groups": obj.get("sync_groups"),
             "sync_parent_group": obj.get("sync_parent_group"),
             "property_mappings": obj.get("property_mappings"),
             "property_mappings_group": obj.get("property_mappings_group")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldap_sync_status.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/transaction_application_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,71 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.application_request import ApplicationRequest
+from authentik_client.models.model_request import ModelRequest
+from authentik_client.models.provider_model_enum import ProviderModelEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, StrictBool, conlist
-from authentik_client.models.system_task import SystemTask
-
-class LDAPSyncStatus(BaseModel):
-    """
-    LDAP Source sync status  # noqa: E501
+class TransactionApplicationRequest(BaseModel):
     """
-    is_running: StrictBool = Field(...)
-    tasks: conlist(SystemTask) = Field(...)
-    __properties = ["is_running", "tasks"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for creating a provider and an application in one transaction
+    """ # noqa: E501
+    app: ApplicationRequest
+    provider_model: ProviderModelEnum
+    provider: ModelRequest
+    __properties: ClassVar[List[str]] = ["app", "provider_model", "provider"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPSyncStatus:
-        """Create an instance of LDAPSyncStatus from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TransactionApplicationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "is_running",
-                            "tasks",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in tasks (list)
-        _items = []
-        if self.tasks:
-            for _item in self.tasks:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['tasks'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of app
+        if self.app:
+            _dict['app'] = self.app.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of provider
+        if self.provider:
+            _dict['provider'] = self.provider.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LDAPSyncStatus:
-        """Create an instance of LDAPSyncStatus from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TransactionApplicationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LDAPSyncStatus.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LDAPSyncStatus.parse_obj({
-            "is_running": obj.get("is_running"),
-            "tasks": [SystemTask.from_dict(_item) for _item in obj.get("tasks")] if obj.get("tasks") is not None else None
+        _obj = cls.model_validate({
+            "app": ApplicationRequest.from_dict(obj["app"]) if obj.get("app") is not None else None,
+            "provider_model": obj.get("provider_model"),
+            "provider": ModelRequest.from_dict(obj["provider"]) if obj.get("provider") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/ldapapi_access_mode.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/binding_type_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,33 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class LDAPAPIAccessMode(str, Enum):
+class BindingTypeEnum(str, Enum):
     """
-    LDAPAPIAccessMode
+    BindingTypeEnum
     """
 
     """
     allowed enum values
     """
-    DIRECT = 'direct'
-    CACHED = 'cached'
+    REDIRECT = 'REDIRECT'
+    POST = 'POST'
+    POST_AUTO = 'POST_AUTO'
 
     @classmethod
-    def from_json(cls, json_str: str) -> LDAPAPIAccessMode:
-        """Create an instance of LDAPAPIAccessMode from a JSON string"""
-        return LDAPAPIAccessMode(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of BindingTypeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/license.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/license.py`

 * *Files 24% similar despite different names*

```diff
@@ -15,70 +15,92 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-
-from pydantic import BaseModel, Field, StrictInt, StrictStr
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class License(BaseModel):
     """
-    License Serializer  # noqa: E501
-    """
-    license_uuid: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    key: StrictStr = Field(...)
-    expiry: datetime = Field(...)
-    internal_users: StrictInt = Field(...)
-    external_users: StrictInt = Field(...)
-    __properties = ["license_uuid", "name", "key", "expiry", "internal_users", "external_users"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    License Serializer
+    """ # noqa: E501
+    license_uuid: StrictStr
+    name: StrictStr
+    key: StrictStr
+    expiry: datetime
+    internal_users: StrictInt
+    external_users: StrictInt
+    __properties: ClassVar[List[str]] = ["license_uuid", "name", "key", "expiry", "internal_users", "external_users"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> License:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of License from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "license_uuid",
-                            "name",
-                            "expiry",
-                            "internal_users",
-                            "external_users",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "license_uuid",
+            "name",
+            "expiry",
+            "internal_users",
+            "external_users",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> License:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of License from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return License.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = License.parse_obj({
+        _obj = cls.model_validate({
             "license_uuid": obj.get("license_uuid"),
             "name": obj.get("name"),
             "key": obj.get("key"),
             "expiry": obj.get("expiry"),
             "internal_users": obj.get("internal_users"),
             "external_users": obj.get("external_users")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/license_forecast.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_device.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,65 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictInt
-
-class LicenseForecast(BaseModel):
-    """
-    Serializer for license forecast  # noqa: E501
+class DuoDevice(BaseModel):
     """
-    internal_users: StrictInt = Field(...)
-    external_users: StrictInt = Field(...)
-    forecasted_internal_users: StrictInt = Field(...)
-    forecasted_external_users: StrictInt = Field(...)
-    __properties = ["internal_users", "external_users", "forecasted_internal_users", "forecasted_external_users"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for Duo authenticator devices
+    """ # noqa: E501
+    pk: StrictInt
+    name: Annotated[str, Field(strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["pk", "name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LicenseForecast:
-        """Create an instance of LicenseForecast from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DuoDevice from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LicenseForecast:
-        """Create an instance of LicenseForecast from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DuoDevice from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LicenseForecast.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LicenseForecast.parse_obj({
-            "internal_users": obj.get("internal_users"),
-            "external_users": obj.get("external_users"),
-            "forecasted_internal_users": obj.get("forecasted_internal_users"),
-            "forecasted_external_users": obj.get("forecasted_external_users")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/license_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_totp_device_request.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, constr
-
-class LicenseRequest(BaseModel):
-    """
-    License Serializer  # noqa: E501
+class PatchedTOTPDeviceRequest(BaseModel):
     """
-    key: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["key"]
+    Serializer for totp authenticator devices
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LicenseRequest:
-        """Create an instance of LicenseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedTOTPDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LicenseRequest:
-        """Create an instance of LicenseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedTOTPDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LicenseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LicenseRequest.parse_obj({
-            "key": obj.get("key")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/license_summary.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/license_summary.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,67 +15,84 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-
-from pydantic import BaseModel, Field, StrictBool, StrictInt
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class LicenseSummary(BaseModel):
     """
-    Serializer for license status  # noqa: E501
-    """
-    internal_users: StrictInt = Field(...)
-    external_users: StrictInt = Field(...)
-    valid: StrictBool = Field(...)
-    show_admin_warning: StrictBool = Field(...)
-    show_user_warning: StrictBool = Field(...)
-    read_only: StrictBool = Field(...)
-    latest_valid: datetime = Field(...)
-    has_license: StrictBool = Field(...)
-    __properties = ["internal_users", "external_users", "valid", "show_admin_warning", "show_user_warning", "read_only", "latest_valid", "has_license"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for license status
+    """ # noqa: E501
+    internal_users: StrictInt
+    external_users: StrictInt
+    valid: StrictBool
+    show_admin_warning: StrictBool
+    show_user_warning: StrictBool
+    read_only: StrictBool
+    latest_valid: datetime
+    has_license: StrictBool
+    __properties: ClassVar[List[str]] = ["internal_users", "external_users", "valid", "show_admin_warning", "show_user_warning", "read_only", "latest_valid", "has_license"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LicenseSummary:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of LicenseSummary from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LicenseSummary:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of LicenseSummary from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LicenseSummary.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LicenseSummary.parse_obj({
+        _obj = cls.model_validate({
             "internal_users": obj.get("internal_users"),
             "external_users": obj.get("external_users"),
             "valid": obj.get("valid"),
             "show_admin_warning": obj.get("show_admin_warning"),
             "show_user_warning": obj.get("show_user_warning"),
             "read_only": obj.get("read_only"),
             "latest_valid": obj.get("latest_valid"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/link.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/link.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,59 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Link(BaseModel):
     """
-    Returns a single link  # noqa: E501
-    """
-    link: StrictStr = Field(...)
-    __properties = ["link"]
+    Returns a single link
+    """ # noqa: E501
+    link: StrictStr
+    __properties: ClassVar[List[str]] = ["link"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Link:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Link from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Link:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Link from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Link.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Link.parse_obj({
+        _obj = cls.model_validate({
             "link": obj.get("link")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/login_challenge_types.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/login_challenge_types.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,64 +10,62 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import json
 import pprint
-import re  # noqa: F401
-
+from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
 from authentik_client.models.apple_login_challenge import AppleLoginChallenge
 from authentik_client.models.plex_authentication_challenge import PlexAuthenticationChallenge
 from authentik_client.models.redirect_challenge import RedirectChallenge
-from typing import Union, Any, List, TYPE_CHECKING
 from pydantic import StrictStr, Field
+from typing import Union, List, Optional, Dict
+from typing_extensions import Literal, Self
 
 LOGINCHALLENGETYPES_ONE_OF_SCHEMAS = ["AppleLoginChallenge", "PlexAuthenticationChallenge", "RedirectChallenge"]
 
 class LoginChallengeTypes(BaseModel):
     """
     LoginChallengeTypes
     """
     # data type: RedirectChallenge
     oneof_schema_1_validator: Optional[RedirectChallenge] = None
     # data type: PlexAuthenticationChallenge
     oneof_schema_2_validator: Optional[PlexAuthenticationChallenge] = None
     # data type: AppleLoginChallenge
     oneof_schema_3_validator: Optional[AppleLoginChallenge] = None
-    if TYPE_CHECKING:
-        actual_instance: Union[AppleLoginChallenge, PlexAuthenticationChallenge, RedirectChallenge]
-    else:
-        actual_instance: Any
-    one_of_schemas: List[str] = Field(LOGINCHALLENGETYPES_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[AppleLoginChallenge, PlexAuthenticationChallenge, RedirectChallenge]] = None
+    one_of_schemas: List[str] = Field(default=Literal["AppleLoginChallenge", "PlexAuthenticationChallenge", "RedirectChallenge"])
+
+    model_config = ConfigDict(
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
     def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = LoginChallengeTypes.construct()
+        instance = LoginChallengeTypes.model_construct()
         error_messages = []
         match = 0
         # validate data type: RedirectChallenge
         if not isinstance(v, RedirectChallenge):
             error_messages.append(f"Error! Input type `{type(v)}` is not `RedirectChallenge`")
         else:
             match += 1
@@ -87,21 +85,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in LoginChallengeTypes with oneOf schemas: AppleLoginChallenge, PlexAuthenticationChallenge, RedirectChallenge. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LoginChallengeTypes:
+    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> LoginChallengeTypes:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = LoginChallengeTypes.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into RedirectChallenge
         try:
             instance.actual_instance = RedirectChallenge.from_json(json_str)
             match += 1
@@ -130,30 +128,28 @@
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
+        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Optional[Union[Dict[str, Any], AppleLoginChallenge, PlexAuthenticationChallenge, RedirectChallenge]]:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
-        to_dict = getattr(self.actual_instance, "to_dict", None)
-        if callable(to_dict):
+        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/login_metrics.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/login_metrics.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,55 +14,74 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.coordinate import Coordinate
+from typing import Optional, Set
+from typing_extensions import Self
 
 class LoginMetrics(BaseModel):
     """
-    Login Metrics per 1h  # noqa: E501
-    """
-    logins: conlist(Coordinate) = Field(...)
-    logins_failed: conlist(Coordinate) = Field(...)
-    authorizations: conlist(Coordinate) = Field(...)
-    __properties = ["logins", "logins_failed", "authorizations"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Login Metrics per 1h
+    """ # noqa: E501
+    logins: List[Coordinate]
+    logins_failed: List[Coordinate]
+    authorizations: List[Coordinate]
+    __properties: ClassVar[List[str]] = ["logins", "logins_failed", "authorizations"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LoginMetrics:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of LoginMetrics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "logins",
-                            "logins_failed",
-                            "authorizations",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "logins",
+            "logins_failed",
+            "authorizations",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in logins (list)
         _items = []
         if self.logins:
             for _item in self.logins:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['logins'] = _items
@@ -79,23 +98,23 @@
             for _item in self.authorizations:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['authorizations'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LoginMetrics:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of LoginMetrics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LoginMetrics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LoginMetrics.parse_obj({
-            "logins": [Coordinate.from_dict(_item) for _item in obj.get("logins")] if obj.get("logins") is not None else None,
-            "logins_failed": [Coordinate.from_dict(_item) for _item in obj.get("logins_failed")] if obj.get("logins_failed") is not None else None,
-            "authorizations": [Coordinate.from_dict(_item) for _item in obj.get("authorizations")] if obj.get("authorizations") is not None else None
+        _obj = cls.model_validate({
+            "logins": [Coordinate.from_dict(_item) for _item in obj["logins"]] if obj.get("logins") is not None else None,
+            "logins_failed": [Coordinate.from_dict(_item) for _item in obj["logins_failed"]] if obj.get("logins_failed") is not None else None,
+            "authorizations": [Coordinate.from_dict(_item) for _item in obj["authorizations"]] if obj.get("authorizations") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/login_source.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_source_connection.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,72 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.source import Source
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-from authentik_client.models.login_challenge_types import LoginChallengeTypes
-
-class LoginSource(BaseModel):
-    """
-    Serializer for Login buttons of sources  # noqa: E501
+class UserSourceConnection(BaseModel):
     """
-    name: StrictStr = Field(...)
-    icon_url: Optional[StrictStr] = None
-    challenge: LoginChallengeTypes = Field(...)
-    __properties = ["name", "icon_url", "challenge"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth Source Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    user: StrictInt
+    source: Source
+    created: datetime
+    __properties: ClassVar[List[str]] = ["pk", "user", "source", "created"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LoginSource:
-        """Create an instance of LoginSource from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserSourceConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of challenge
-        if self.challenge:
-            _dict['challenge'] = self.challenge.to_dict()
-        # set to None if icon_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.icon_url is None and "icon_url" in self.__fields_set__:
-            _dict['icon_url'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "user",
+            "source",
+            "created",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of source
+        if self.source:
+            _dict['source'] = self.source.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LoginSource:
-        """Create an instance of LoginSource from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserSourceConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return LoginSource.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = LoginSource.parse_obj({
-            "name": obj.get("name"),
-            "icon_url": obj.get("icon_url"),
-            "challenge": LoginChallengeTypes.from_dict(obj.get("challenge")) if obj.get("challenge") is not None else None
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "user": obj.get("user"),
+            "source": Source.from_dict(obj["source"]) if obj.get("source") is not None else None,
+            "created": obj.get("created")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/metadata.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_path.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict
-from pydantic import BaseModel, Field, StrictStr
-
-class Metadata(BaseModel):
-    """
-    Serializer for blueprint metadata  # noqa: E501
+class UserPath(BaseModel):
     """
-    name: StrictStr = Field(...)
-    labels: Dict[str, Any] = Field(...)
-    __properties = ["name", "labels"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserPath
+    """ # noqa: E501
+    paths: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["paths"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Metadata:
-        """Create an instance of Metadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserPath from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "paths",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Metadata:
-        """Create an instance of Metadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserPath from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Metadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Metadata.parse_obj({
-            "name": obj.get("name"),
-            "labels": obj.get("labels")
+        _obj = cls.model_validate({
+            "paths": obj.get("paths")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/model_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/model_enum.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ModelEnum(str, Enum):
     """
     ModelEnum
     """
 
@@ -103,12 +100,12 @@
     AUTHENTIK_EVENTS_DOT_EVENT = 'authentik_events.event'
     AUTHENTIK_EVENTS_DOT_NOTIFICATIONTRANSPORT = 'authentik_events.notificationtransport'
     AUTHENTIK_EVENTS_DOT_NOTIFICATION = 'authentik_events.notification'
     AUTHENTIK_EVENTS_DOT_NOTIFICATIONRULE = 'authentik_events.notificationrule'
     AUTHENTIK_EVENTS_DOT_NOTIFICATIONWEBHOOKMAPPING = 'authentik_events.notificationwebhookmapping'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ModelEnum from a JSON string"""
-        return ModelEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/model_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/model_request.py`

 * *Files 3% similar despite different names*

```diff
@@ -10,30 +10,28 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import json
 import pprint
-import re  # noqa: F401
-
+from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
 from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
 from authentik_client.models.ldap_provider_request import LDAPProviderRequest
 from authentik_client.models.o_auth2_provider_request import OAuth2ProviderRequest
 from authentik_client.models.proxy_provider_request import ProxyProviderRequest
 from authentik_client.models.rac_provider_request import RACProviderRequest
 from authentik_client.models.radius_provider_request import RadiusProviderRequest
 from authentik_client.models.saml_provider_request import SAMLProviderRequest
 from authentik_client.models.scim_provider_request import SCIMProviderRequest
-from typing import Union, Any, List, TYPE_CHECKING
 from pydantic import StrictStr, Field
+from typing import Union, List, Optional, Dict
+from typing_extensions import Literal, Self
 
 MODELREQUEST_ONE_OF_SCHEMAS = ["LDAPProviderRequest", "OAuth2ProviderRequest", "ProxyProviderRequest", "RACProviderRequest", "RadiusProviderRequest", "SAMLProviderRequest", "SCIMProviderRequest"]
 
 class ModelRequest(BaseModel):
     """
     ModelRequest
     """
@@ -47,39 +45,39 @@
     oneof_schema_4_validator: Optional[RACProviderRequest] = None
     # data type: RadiusProviderRequest
     oneof_schema_5_validator: Optional[RadiusProviderRequest] = None
     # data type: SAMLProviderRequest
     oneof_schema_6_validator: Optional[SAMLProviderRequest] = None
     # data type: SCIMProviderRequest
     oneof_schema_7_validator: Optional[SCIMProviderRequest] = None
-    if TYPE_CHECKING:
-        actual_instance: Union[LDAPProviderRequest, OAuth2ProviderRequest, ProxyProviderRequest, RACProviderRequest, RadiusProviderRequest, SAMLProviderRequest, SCIMProviderRequest]
-    else:
-        actual_instance: Any
-    one_of_schemas: List[str] = Field(MODELREQUEST_ONE_OF_SCHEMAS, const=True)
+    actual_instance: Optional[Union[LDAPProviderRequest, OAuth2ProviderRequest, ProxyProviderRequest, RACProviderRequest, RadiusProviderRequest, SAMLProviderRequest, SCIMProviderRequest]] = None
+    one_of_schemas: List[str] = Field(default=Literal["LDAPProviderRequest", "OAuth2ProviderRequest", "ProxyProviderRequest", "RACProviderRequest", "RadiusProviderRequest", "SAMLProviderRequest", "SCIMProviderRequest"])
+
+    model_config = ConfigDict(
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        validate_assignment = True
 
-    discriminator_value_class_map = {
+    discriminator_value_class_map: Dict[str, str] = {
     }
 
     def __init__(self, *args, **kwargs) -> None:
         if args:
             if len(args) > 1:
                 raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
             if kwargs:
                 raise ValueError("If a position argument is used, keyword arguments cannot be used.")
             super().__init__(actual_instance=args[0])
         else:
             super().__init__(**kwargs)
 
-    @validator('actual_instance')
+    @field_validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = ModelRequest.construct()
+        instance = ModelRequest.model_construct()
         error_messages = []
         match = 0
         # validate data type: LDAPProviderRequest
         if not isinstance(v, LDAPProviderRequest):
             error_messages.append(f"Error! Input type `{type(v)}` is not `LDAPProviderRequest`")
         else:
             match += 1
@@ -119,21 +117,21 @@
         elif match == 0:
             # no match
             raise ValueError("No match found when setting `actual_instance` in ModelRequest with oneOf schemas: LDAPProviderRequest, OAuth2ProviderRequest, ProxyProviderRequest, RACProviderRequest, RadiusProviderRequest, SAMLProviderRequest, SCIMProviderRequest. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ModelRequest:
+    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> ModelRequest:
+    def from_json(cls, json_str: str) -> Self:
         """Returns the object represented by the json string"""
-        instance = ModelRequest.construct()
+        instance = cls.model_construct()
         error_messages = []
         match = 0
 
         # deserialize data into LDAPProviderRequest
         try:
             instance.actual_instance = LDAPProviderRequest.from_json(json_str)
             match += 1
@@ -186,30 +184,28 @@
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
         if self.actual_instance is None:
             return "null"
 
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
+        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
             return self.actual_instance.to_json()
         else:
             return json.dumps(self.actual_instance)
 
-    def to_dict(self) -> dict:
+    def to_dict(self) -> Optional[Union[Dict[str, Any], LDAPProviderRequest, OAuth2ProviderRequest, ProxyProviderRequest, RACProviderRequest, RadiusProviderRequest, SAMLProviderRequest, SCIMProviderRequest]]:
         """Returns the dict representation of the actual instance"""
         if self.actual_instance is None:
             return None
 
-        to_dict = getattr(self.actual_instance, "to_dict", None)
-        if callable(to_dict):
+        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
             return self.actual_instance.to_dict()
         else:
             # primitive type
             return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.dict())
+        return pprint.pformat(self.model_dump())
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/name_id_policy_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/name_id_policy_enum.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class NameIdPolicyEnum(str, Enum):
     """
     NameIdPolicyEnum
     """
 
@@ -33,12 +30,12 @@
     URN_COLON_OASIS_COLON_NAMES_COLON_TC_COLON_SAML_COLON_1_DOT_1_COLON_NAMEID_MINUS_FORMAT_COLON_EMAIL_ADDRESS = 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress'
     URN_COLON_OASIS_COLON_NAMES_COLON_TC_COLON_SAML_COLON_2_DOT_0_COLON_NAMEID_MINUS_FORMAT_COLON_PERSISTENT = 'urn:oasis:names:tc:SAML:2.0:nameid-format:persistent'
     URN_COLON_OASIS_COLON_NAMES_COLON_TC_COLON_SAML_COLON_2_DOT_0_COLON_NAMEID_MINUS_FORMAT_COLON_X509_SUBJECT_NAME = 'urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName'
     URN_COLON_OASIS_COLON_NAMES_COLON_TC_COLON_SAML_COLON_2_DOT_0_COLON_NAMEID_MINUS_FORMAT_COLON_WINDOWS_DOMAIN_QUALIFIED_NAME = 'urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName'
     URN_COLON_OASIS_COLON_NAMES_COLON_TC_COLON_SAML_COLON_2_DOT_0_COLON_NAMEID_MINUS_FORMAT_COLON_TRANSIENT = 'urn:oasis:names:tc:SAML:2.0:nameid-format:transient'
 
     @classmethod
-    def from_json(cls, json_str: str) -> NameIdPolicyEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of NameIdPolicyEnum from a JSON string"""
-        return NameIdPolicyEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/network_binding_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/network_binding_enum.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class NetworkBindingEnum(str, Enum):
     """
     NetworkBindingEnum
     """
 
@@ -32,12 +29,12 @@
     """
     NO_BINDING = 'no_binding'
     BIND_ASN = 'bind_asn'
     BIND_ASN_NETWORK = 'bind_asn_network'
     BIND_ASN_NETWORK_IP = 'bind_asn_network_ip'
 
     @classmethod
-    def from_json(cls, json_str: str) -> NetworkBindingEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of NetworkBindingEnum from a JSON string"""
-        return NetworkBindingEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/not_configured_action_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_type_enum.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,34 +9,32 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class NotConfiguredActionEnum(str, Enum):
+class UserTypeEnum(str, Enum):
     """
-    NotConfiguredActionEnum
+    UserTypeEnum
     """
 
     """
     allowed enum values
     """
-    SKIP = 'skip'
-    DENY = 'deny'
-    CONFIGURE = 'configure'
+    INTERNAL = 'internal'
+    EXTERNAL = 'external'
+    SERVICE_ACCOUNT = 'service_account'
+    INTERNAL_SERVICE_ACCOUNT = 'internal_service_account'
 
     @classmethod
-    def from_json(cls, json_str: str) -> NotConfiguredActionEnum:
-        """Create an instance of NotConfiguredActionEnum from a JSON string"""
-        return NotConfiguredActionEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UserTypeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/notification.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_test_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,78 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from authentik_client.models.event import Event
-from authentik_client.models.severity_enum import SeverityEnum
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Notification(BaseModel):
+class PolicyTestRequest(BaseModel):
     """
-    Notification Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    severity: SeverityEnum = Field(...)
-    body: StrictStr = Field(...)
-    created: datetime = Field(...)
-    event: Optional[Event] = None
-    seen: Optional[StrictBool] = None
-    __properties = ["pk", "severity", "body", "created", "event", "seen"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Test policy execution for a user with context
+    """ # noqa: E501
+    user: StrictInt
+    context: Optional[Dict[str, Any]] = None
+    __properties: ClassVar[List[str]] = ["user", "context"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Notification:
-        """Create an instance of Notification from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PolicyTestRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "severity",
-                            "body",
-                            "created",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of event
-        if self.event:
-            _dict['event'] = self.event.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Notification:
-        """Create an instance of Notification from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PolicyTestRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Notification.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Notification.parse_obj({
-            "pk": obj.get("pk"),
-            "severity": obj.get("severity"),
-            "body": obj.get("body"),
-            "created": obj.get("created"),
-            "event": Event.from_dict(obj.get("event")) if obj.get("event") is not None else None,
-            "seen": obj.get("seen")
+        _obj = cls.model_validate({
+            "user": obj.get("user"),
+            "context": obj.get("context")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_rule.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_rule_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,81 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.group import Group
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.severity_enum import SeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class NotificationRule(BaseModel):
-    """
-    NotificationRule Serializer  # noqa: E501
+class NotificationRuleRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    transports: Optional[conlist(StrictStr)] = Field(None, description="Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.")
-    severity: Optional[SeverityEnum] = Field(None, description="Controls which severity level the created notifications will have.")
-    group: Optional[StrictStr] = Field(None, description="Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.")
-    group_obj: Group = Field(...)
-    __properties = ["pk", "name", "transports", "severity", "group", "group_obj"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationRule Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    transports: Optional[List[StrictStr]] = Field(default=None, description="Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.")
+    severity: Optional[SeverityEnum] = Field(default=None, description="Controls which severity level the created notifications will have.")
+    group: Optional[StrictStr] = Field(default=None, description="Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.")
+    __properties: ClassVar[List[str]] = ["name", "transports", "severity", "group"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> NotificationRule:
-        """Create an instance of NotificationRule from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationRuleRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "group_obj",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of group_obj
-        if self.group_obj:
-            _dict['group_obj'] = self.group_obj.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.group is None and "group" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.group is None and "group" in self.model_fields_set:
             _dict['group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> NotificationRule:
-        """Create an instance of NotificationRule from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationRuleRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return NotificationRule.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = NotificationRule.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "transports": obj.get("transports"),
             "severity": obj.get("severity"),
-            "group": obj.get("group"),
-            "group_obj": Group.from_dict(obj.get("group_obj")) if obj.get("group_obj") is not None else None
+            "group": obj.get("group")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_rule_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,71 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.event_request import EventRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.severity_enum import SeverityEnum
-
-class NotificationRuleRequest(BaseModel):
-    """
-    NotificationRule Serializer  # noqa: E501
+class NotificationRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    transports: Optional[conlist(StrictStr)] = Field(None, description="Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.")
-    severity: Optional[SeverityEnum] = Field(None, description="Controls which severity level the created notifications will have.")
-    group: Optional[StrictStr] = Field(None, description="Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.")
-    __properties = ["name", "transports", "severity", "group"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Notification Serializer
+    """ # noqa: E501
+    event: Optional[EventRequest] = None
+    seen: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["event", "seen"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> NotificationRuleRequest:
-        """Create an instance of NotificationRuleRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.group is None and "group" in self.__fields_set__:
-            _dict['group'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of event
+        if self.event:
+            _dict['event'] = self.event.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> NotificationRuleRequest:
-        """Create an instance of NotificationRuleRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return NotificationRuleRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = NotificationRuleRequest.parse_obj({
-            "name": obj.get("name"),
-            "transports": obj.get("transports"),
-            "severity": obj.get("severity"),
-            "group": obj.get("group")
+        _obj = cls.model_validate({
+            "event": EventRequest.from_dict(obj["event"]) if obj.get("event") is not None else None,
+            "seen": obj.get("seen")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_transport.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_transport_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,79 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.notification_transport_mode_enum import NotificationTransportModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class NotificationTransport(BaseModel):
-    """
-    NotificationTransport Serializer  # noqa: E501
+class PatchedNotificationTransportRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
+    NotificationTransport Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     mode: Optional[NotificationTransportModeEnum] = None
-    mode_verbose: StrictStr = Field(..., description="Return selected mode with a UI Label")
     webhook_url: Optional[StrictStr] = None
     webhook_mapping: Optional[StrictStr] = None
-    send_once: Optional[StrictBool] = Field(None, description="Only send notification once, for example when sending a webhook into a chat channel.")
-    __properties = ["pk", "name", "mode", "mode_verbose", "webhook_url", "webhook_mapping", "send_once"]
+    send_once: Optional[StrictBool] = Field(default=None, description="Only send notification once, for example when sending a webhook into a chat channel.")
+    __properties: ClassVar[List[str]] = ["name", "mode", "webhook_url", "webhook_mapping", "send_once"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> NotificationTransport:
-        """Create an instance of NotificationTransport from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedNotificationTransportRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "mode_verbose",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if webhook_mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.webhook_mapping is None and "webhook_mapping" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.webhook_mapping is None and "webhook_mapping" in self.model_fields_set:
             _dict['webhook_mapping'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> NotificationTransport:
-        """Create an instance of NotificationTransport from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedNotificationTransportRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return NotificationTransport.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = NotificationTransport.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "mode": obj.get("mode"),
-            "mode_verbose": obj.get("mode_verbose"),
             "webhook_url": obj.get("webhook_url"),
             "webhook_mapping": obj.get("webhook_mapping"),
             "send_once": obj.get("send_once")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/notification_transport_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_device_enrollment_status.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.duo_response_enum import DuoResponseEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-from authentik_client.models.notification_transport_mode_enum import NotificationTransportModeEnum
-
-class NotificationTransportRequest(BaseModel):
-    """
-    NotificationTransport Serializer  # noqa: E501
+class DuoDeviceEnrollmentStatus(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    mode: Optional[NotificationTransportModeEnum] = None
-    webhook_url: Optional[StrictStr] = None
-    webhook_mapping: Optional[StrictStr] = None
-    send_once: Optional[StrictBool] = Field(None, description="Only send notification once, for example when sending a webhook into a chat channel.")
-    __properties = ["name", "mode", "webhook_url", "webhook_mapping", "send_once"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DuoDeviceEnrollmentStatus
+    """ # noqa: E501
+    duo_response: DuoResponseEnum
+    __properties: ClassVar[List[str]] = ["duo_response"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> NotificationTransportRequest:
-        """Create an instance of NotificationTransportRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DuoDeviceEnrollmentStatus from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if webhook_mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.webhook_mapping is None and "webhook_mapping" in self.__fields_set__:
-            _dict['webhook_mapping'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> NotificationTransportRequest:
-        """Create an instance of NotificationTransportRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DuoDeviceEnrollmentStatus from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return NotificationTransportRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = NotificationTransportRequest.parse_obj({
-            "name": obj.get("name"),
-            "mode": obj.get("mode"),
-            "webhook_url": obj.get("webhook_url"),
-            "webhook_mapping": obj.get("webhook_mapping"),
-            "send_once": obj.get("send_once")
+        _obj = cls.model_validate({
+            "duo_response": obj.get("duo_response")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth2_provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth2_provider.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,107 +14,133 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.client_type_enum import ClientTypeEnum
 from authentik_client.models.issuer_mode_enum import IssuerModeEnum
 from authentik_client.models.sub_mode_enum import SubModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuth2Provider(BaseModel):
     """
-    OAuth2Provider Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    client_type: Optional[ClientTypeEnum] = Field(None, description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable")
-    client_id: Optional[constr(strict=True, max_length=255)] = None
-    client_secret: Optional[constr(strict=True, max_length=255)] = None
-    access_code_validity: Optional[StrictStr] = Field(None, description="Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    access_token_validity: Optional[StrictStr] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    refresh_token_validity: Optional[StrictStr] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    include_claims_in_id_token: Optional[StrictBool] = Field(None, description="Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.")
-    signing_key: Optional[StrictStr] = Field(None, description="Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.")
-    redirect_uris: Optional[StrictStr] = Field(None, description="Enter each URI on a new line.")
-    sub_mode: Optional[SubModeEnum] = Field(None, description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.")
-    issuer_mode: Optional[IssuerModeEnum] = Field(None, description="Configure how the issuer field of the ID Token should be filled.")
-    jwks_sources: Optional[conlist(StrictStr)] = None
-    __properties = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "client_type", "client_id", "client_secret", "access_code_validity", "access_token_validity", "refresh_token_validity", "include_claims_in_id_token", "signing_key", "redirect_uris", "sub_mode", "issuer_mode", "jwks_sources"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth2Provider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    assigned_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_application_name: StrictStr = Field(description="Application's display Name.")
+    assigned_backchannel_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_backchannel_application_name: StrictStr = Field(description="Application's display Name.")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    client_type: Optional[ClientTypeEnum] = Field(default=None, description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable")
+    client_id: Optional[Annotated[str, Field(strict=True, max_length=255)]] = None
+    client_secret: Optional[Annotated[str, Field(strict=True, max_length=255)]] = None
+    access_code_validity: Optional[StrictStr] = Field(default=None, description="Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    access_token_validity: Optional[StrictStr] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    refresh_token_validity: Optional[StrictStr] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    include_claims_in_id_token: Optional[StrictBool] = Field(default=None, description="Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.")
+    signing_key: Optional[StrictStr] = Field(default=None, description="Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.")
+    redirect_uris: Optional[StrictStr] = Field(default=None, description="Enter each URI on a new line.")
+    sub_mode: Optional[SubModeEnum] = Field(default=None, description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.")
+    issuer_mode: Optional[IssuerModeEnum] = Field(default=None, description="Configure how the issuer field of the ID Token should be filled.")
+    jwks_sources: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "client_type", "client_id", "client_secret", "access_code_validity", "access_token_validity", "refresh_token_validity", "include_claims_in_id_token", "signing_key", "redirect_uris", "sub_mode", "issuer_mode", "jwks_sources"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuth2Provider:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuth2Provider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "assigned_application_slug",
+            "assigned_application_name",
+            "assigned_backchannel_application_slug",
+            "assigned_backchannel_application_name",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if signing_key (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_key is None and "signing_key" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_key is None and "signing_key" in self.model_fields_set:
             _dict['signing_key'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuth2Provider:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuth2Provider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuth2Provider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuth2Provider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "component": obj.get("component"),
             "assigned_application_slug": obj.get("assigned_application_slug"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth2_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth2_provider_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,89 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.client_type_enum import ClientTypeEnum
 from authentik_client.models.issuer_mode_enum import IssuerModeEnum
 from authentik_client.models.sub_mode_enum import SubModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuth2ProviderRequest(BaseModel):
     """
-    OAuth2Provider Serializer  # noqa: E501
-    """
-    name: constr(strict=True, min_length=1) = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    client_type: Optional[ClientTypeEnum] = Field(None, description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable")
-    client_id: Optional[constr(strict=True, max_length=255, min_length=1)] = None
-    client_secret: Optional[constr(strict=True, max_length=255)] = None
-    access_code_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    access_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    refresh_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    include_claims_in_id_token: Optional[StrictBool] = Field(None, description="Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.")
-    signing_key: Optional[StrictStr] = Field(None, description="Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.")
-    redirect_uris: Optional[StrictStr] = Field(None, description="Enter each URI on a new line.")
-    sub_mode: Optional[SubModeEnum] = Field(None, description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.")
-    issuer_mode: Optional[IssuerModeEnum] = Field(None, description="Configure how the issuer field of the ID Token should be filled.")
-    jwks_sources: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_type", "client_id", "client_secret", "access_code_validity", "access_token_validity", "refresh_token_validity", "include_claims_in_id_token", "signing_key", "redirect_uris", "sub_mode", "issuer_mode", "jwks_sources"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth2Provider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    client_type: Optional[ClientTypeEnum] = Field(default=None, description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable")
+    client_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = None
+    client_secret: Optional[Annotated[str, Field(strict=True, max_length=255)]] = None
+    access_code_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    access_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    refresh_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    include_claims_in_id_token: Optional[StrictBool] = Field(default=None, description="Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.")
+    signing_key: Optional[StrictStr] = Field(default=None, description="Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.")
+    redirect_uris: Optional[StrictStr] = Field(default=None, description="Enter each URI on a new line.")
+    sub_mode: Optional[SubModeEnum] = Field(default=None, description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.")
+    issuer_mode: Optional[IssuerModeEnum] = Field(default=None, description="Configure how the issuer field of the ID Token should be filled.")
+    jwks_sources: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_type", "client_id", "client_secret", "access_code_validity", "access_token_validity", "refresh_token_validity", "include_claims_in_id_token", "signing_key", "redirect_uris", "sub_mode", "issuer_mode", "jwks_sources"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuth2ProviderRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuth2ProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if signing_key (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_key is None and "signing_key" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_key is None and "signing_key" in self.model_fields_set:
             _dict['signing_key'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuth2ProviderRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuth2ProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuth2ProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuth2ProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "client_type": obj.get("client_type"),
             "client_id": obj.get("client_id"),
             "client_secret": obj.get("client_secret"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth2_provider_setup_urls.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device_token.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,78 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class OAuth2ProviderSetupURLs(BaseModel):
-    """
-    OAuth2 Provider Metadata serializer  # noqa: E501
+class StaticDeviceToken(BaseModel):
     """
-    issuer: StrictStr = Field(...)
-    authorize: StrictStr = Field(...)
-    token: StrictStr = Field(...)
-    user_info: StrictStr = Field(...)
-    provider_info: StrictStr = Field(...)
-    logout: StrictStr = Field(...)
-    jwks: StrictStr = Field(...)
-    __properties = ["issuer", "authorize", "token", "user_info", "provider_info", "logout", "jwks"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for static device's tokens
+    """ # noqa: E501
+    token: Annotated[str, Field(strict=True, max_length=16)]
+    __properties: ClassVar[List[str]] = ["token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuth2ProviderSetupURLs:
-        """Create an instance of OAuth2ProviderSetupURLs from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StaticDeviceToken from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "issuer",
-                            "authorize",
-                            "token",
-                            "user_info",
-                            "provider_info",
-                            "logout",
-                            "jwks",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuth2ProviderSetupURLs:
-        """Create an instance of OAuth2ProviderSetupURLs from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StaticDeviceToken from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuth2ProviderSetupURLs.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuth2ProviderSetupURLs.parse_obj({
-            "issuer": obj.get("issuer"),
-            "authorize": obj.get("authorize"),
-            "token": obj.get("token"),
-            "user_info": obj.get("user_info"),
-            "provider_info": obj.get("provider_info"),
-            "logout": obj.get("logout"),
-            "jwks": obj.get("jwks")
+        _obj = cls.model_validate({
+            "token": obj.get("token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_challenge.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,87 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class OAuthDeviceCodeChallenge(BaseModel):
-    """
-    OAuth Device code challenge  # noqa: E501
+class DummyChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    Dummy challenge
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-provider-oauth2-device-code'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    __properties = ["type", "flow_info", "component", "response_errors"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-stage-dummy'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    name: StrictStr
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthDeviceCodeChallenge:
-        """Create an instance of OAuthDeviceCodeChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DummyChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthDeviceCodeChallenge:
-        """Create an instance of OAuthDeviceCodeChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DummyChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthDeviceCodeChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthDeviceCodeChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-provider-oauth2-device-code',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-dummy',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
-            )
+                for _k, _v in obj.get("response_errors", {}).items()
+            ),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/password_challenge_response_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,61 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictInt, constr
-
-class OAuthDeviceCodeChallengeResponseRequest(BaseModel):
-    """
-    Response that includes the user-entered device code  # noqa: E501
+class PasswordChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-provider-oauth2-device-code'
-    code: StrictInt = Field(...)
-    __properties = ["component", "code"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Password challenge response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-password'
+    password: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["component", "password"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthDeviceCodeChallengeResponseRequest:
-        """Create an instance of OAuthDeviceCodeChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PasswordChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthDeviceCodeChallengeResponseRequest:
-        """Create an instance of OAuthDeviceCodeChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PasswordChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthDeviceCodeChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthDeviceCodeChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-provider-oauth2-device-code',
-            "code": obj.get("code")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-password',
+            "password": obj.get("password")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_device_code_finish_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_device_code_finish_challenge.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,87 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuthDeviceCodeFinishChallenge(BaseModel):
     """
-    Final challenge after user enters their code  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Final challenge after user enters their code
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-provider-oauth2-device-code-finish'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    __properties = ["type", "flow_info", "component", "response_errors"]
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthDeviceCodeFinishChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuthDeviceCodeFinishChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthDeviceCodeFinishChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuthDeviceCodeFinishChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthDeviceCodeFinishChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthDeviceCodeFinishChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-provider-oauth2-device-code-finish',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             )
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_source.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_source.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,155 +14,181 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.provider_type_enum import ProviderTypeEnum
 from authentik_client.models.source_type import SourceType
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuthSource(BaseModel):
     """
-    OAuth Source Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50) = Field(..., description="Internal source name, used in URLs.")
+    OAuth Source Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    managed: Optional[StrictStr] = Field(..., description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    managed: Optional[StrictStr] = Field(description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
     user_path_template: Optional[StrictStr] = None
-    icon: Optional[StrictStr] = Field(..., description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
-    provider_type: ProviderTypeEnum = Field(...)
-    request_token_url: Optional[constr(strict=True, max_length=255)] = Field(None, description="URL used to request the initial token. This URL is only required for OAuth 1.")
-    authorization_url: Optional[constr(strict=True, max_length=255)] = Field(None, description="URL the user is redirect to to conest the flow.")
-    access_token_url: Optional[constr(strict=True, max_length=255)] = Field(None, description="URL used by authentik to retrieve tokens.")
-    profile_url: Optional[constr(strict=True, max_length=255)] = Field(None, description="URL used by authentik to get user information.")
-    consumer_key: StrictStr = Field(...)
-    callback_url: StrictStr = Field(..., description="Get OAuth Callback URL")
+    icon: Optional[StrictStr] = Field(description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
+    provider_type: ProviderTypeEnum
+    request_token_url: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="URL used to request the initial token. This URL is only required for OAuth 1.")
+    authorization_url: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="URL the user is redirect to to conest the flow.")
+    access_token_url: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="URL used by authentik to retrieve tokens.")
+    profile_url: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="URL used by authentik to get user information.")
+    consumer_key: StrictStr
+    callback_url: StrictStr = Field(description="Get OAuth Callback URL")
     additional_scopes: Optional[StrictStr] = None
-    type: SourceType = Field(...)
+    type: SourceType
     oidc_well_known_url: Optional[StrictStr] = None
     oidc_jwks_url: Optional[StrictStr] = None
     oidc_jwks: Optional[Any] = None
-    __properties = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "provider_type", "request_token_url", "authorization_url", "access_token_url", "profile_url", "consumer_key", "callback_url", "additional_scopes", "type", "oidc_well_known_url", "oidc_jwks_url", "oidc_jwks"]
+    __properties: ClassVar[List[str]] = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "provider_type", "request_token_url", "authorization_url", "access_token_url", "profile_url", "consumer_key", "callback_url", "additional_scopes", "type", "oidc_well_known_url", "oidc_jwks_url", "oidc_jwks"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthSource:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuthSource from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "managed",
-                            "icon",
-                            "callback_url",
-                            "type",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "managed",
+            "icon",
+            "callback_url",
+            "type",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of type
         if self.type:
             _dict['type'] = self.type.to_dict()
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         # set to None if icon (nullable) is None
-        # and __fields_set__ contains the field
-        if self.icon is None and "icon" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.icon is None and "icon" in self.model_fields_set:
             _dict['icon'] = None
 
         # set to None if request_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.request_token_url is None and "request_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.request_token_url is None and "request_token_url" in self.model_fields_set:
             _dict['request_token_url'] = None
 
         # set to None if authorization_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authorization_url is None and "authorization_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authorization_url is None and "authorization_url" in self.model_fields_set:
             _dict['authorization_url'] = None
 
         # set to None if access_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.access_token_url is None and "access_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.access_token_url is None and "access_token_url" in self.model_fields_set:
             _dict['access_token_url'] = None
 
         # set to None if profile_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.profile_url is None and "profile_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.profile_url is None and "profile_url" in self.model_fields_set:
             _dict['profile_url'] = None
 
         # set to None if oidc_jwks (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oidc_jwks is None and "oidc_jwks" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oidc_jwks is None and "oidc_jwks" in self.model_fields_set:
             _dict['oidc_jwks'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthSource:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuthSource from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthSource.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthSource.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "component": obj.get("component"),
@@ -178,15 +204,15 @@
             "request_token_url": obj.get("request_token_url"),
             "authorization_url": obj.get("authorization_url"),
             "access_token_url": obj.get("access_token_url"),
             "profile_url": obj.get("profile_url"),
             "consumer_key": obj.get("consumer_key"),
             "callback_url": obj.get("callback_url"),
             "additional_scopes": obj.get("additional_scopes"),
-            "type": SourceType.from_dict(obj.get("type")) if obj.get("type") is not None else None,
+            "type": SourceType.from_dict(obj["type"]) if obj.get("type") is not None else None,
             "oidc_well_known_url": obj.get("oidc_well_known_url"),
             "oidc_jwks_url": obj.get("oidc_jwks_url"),
             "oidc_jwks": obj.get("oidc_jwks")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/o_auth_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth_source_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,124 +14,141 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.provider_type_enum import ProviderTypeEnum
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OAuthSourceRequest(BaseModel):
     """
-    OAuth Source Serializer  # noqa: E501
-    """
-    name: constr(strict=True, min_length=1) = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Internal source name, used in URLs.")
+    OAuth Source Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(min_length=1, strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    provider_type: ProviderTypeEnum = Field(...)
-    request_token_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL used to request the initial token. This URL is only required for OAuth 1.")
-    authorization_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL the user is redirect to to conest the flow.")
-    access_token_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL used by authentik to retrieve tokens.")
-    profile_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL used by authentik to get user information.")
-    consumer_key: constr(strict=True, min_length=1) = Field(...)
-    consumer_secret: constr(strict=True, min_length=1) = Field(...)
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    provider_type: ProviderTypeEnum
+    request_token_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL used to request the initial token. This URL is only required for OAuth 1.")
+    authorization_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL the user is redirect to to conest the flow.")
+    access_token_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL used by authentik to retrieve tokens.")
+    profile_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL used by authentik to get user information.")
+    consumer_key: Annotated[str, Field(min_length=1, strict=True)]
+    consumer_secret: Annotated[str, Field(min_length=1, strict=True)]
     additional_scopes: Optional[StrictStr] = None
     oidc_well_known_url: Optional[StrictStr] = None
     oidc_jwks_url: Optional[StrictStr] = None
     oidc_jwks: Optional[Any] = None
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "provider_type", "request_token_url", "authorization_url", "access_token_url", "profile_url", "consumer_key", "consumer_secret", "additional_scopes", "oidc_well_known_url", "oidc_jwks_url", "oidc_jwks"]
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "provider_type", "request_token_url", "authorization_url", "access_token_url", "profile_url", "consumer_key", "consumer_secret", "additional_scopes", "oidc_well_known_url", "oidc_jwks_url", "oidc_jwks"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OAuthSourceRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OAuthSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if request_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.request_token_url is None and "request_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.request_token_url is None and "request_token_url" in self.model_fields_set:
             _dict['request_token_url'] = None
 
         # set to None if authorization_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authorization_url is None and "authorization_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authorization_url is None and "authorization_url" in self.model_fields_set:
             _dict['authorization_url'] = None
 
         # set to None if access_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.access_token_url is None and "access_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.access_token_url is None and "access_token_url" in self.model_fields_set:
             _dict['access_token_url'] = None
 
         # set to None if profile_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.profile_url is None and "profile_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.profile_url is None and "profile_url" in self.model_fields_set:
             _dict['profile_url'] = None
 
         # set to None if oidc_jwks (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oidc_jwks is None and "oidc_jwks" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oidc_jwks is None and "oidc_jwks" in self.model_fields_set:
             _dict['oidc_jwks'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OAuthSourceRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OAuthSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OAuthSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OAuthSourceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "user_matching_mode": obj.get("user_matching_mode"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,104 +14,124 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.outpost_type_enum import OutpostTypeEnum
 from authentik_client.models.provider import Provider
 from authentik_client.models.service_connection import ServiceConnection
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Outpost(BaseModel):
     """
-    Outpost Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    type: OutpostTypeEnum = Field(...)
-    providers: conlist(StrictInt) = Field(...)
-    providers_obj: conlist(Provider) = Field(...)
-    service_connection: Optional[StrictStr] = Field(None, description="Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.")
-    service_connection_obj: ServiceConnection = Field(...)
-    token_identifier: StrictStr = Field(..., description="Get Token identifier")
-    config: Dict[str, Any] = Field(...)
-    managed: Optional[StrictStr] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    __properties = ["pk", "name", "type", "providers", "providers_obj", "service_connection", "service_connection_obj", "token_identifier", "config", "managed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Outpost Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    type: OutpostTypeEnum
+    providers: List[StrictInt]
+    providers_obj: List[Provider]
+    service_connection: Optional[StrictStr] = Field(default=None, description="Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.")
+    service_connection_obj: ServiceConnection
+    token_identifier: StrictStr = Field(description="Get Token identifier")
+    config: Dict[str, Any]
+    managed: Optional[StrictStr] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "type", "providers", "providers_obj", "service_connection", "service_connection_obj", "token_identifier", "config", "managed"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Outpost:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Outpost from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "providers_obj",
-                            "service_connection_obj",
-                            "token_identifier",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "providers_obj",
+            "service_connection_obj",
+            "token_identifier",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in providers_obj (list)
         _items = []
         if self.providers_obj:
             for _item in self.providers_obj:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['providers_obj'] = _items
         # override the default output from pydantic by calling `to_dict()` of service_connection_obj
         if self.service_connection_obj:
             _dict['service_connection_obj'] = self.service_connection_obj.to_dict()
         # set to None if service_connection (nullable) is None
-        # and __fields_set__ contains the field
-        if self.service_connection is None and "service_connection" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.service_connection is None and "service_connection" in self.model_fields_set:
             _dict['service_connection'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Outpost:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Outpost from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Outpost.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Outpost.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "type": obj.get("type"),
             "providers": obj.get("providers"),
-            "providers_obj": [Provider.from_dict(_item) for _item in obj.get("providers_obj")] if obj.get("providers_obj") is not None else None,
+            "providers_obj": [Provider.from_dict(_item) for _item in obj["providers_obj"]] if obj.get("providers_obj") is not None else None,
             "service_connection": obj.get("service_connection"),
-            "service_connection_obj": ServiceConnection.from_dict(obj.get("service_connection_obj")) if obj.get("service_connection_obj") is not None else None,
+            "service_connection_obj": ServiceConnection.from_dict(obj["service_connection_obj"]) if obj.get("service_connection_obj") is not None else None,
             "token_identifier": obj.get("token_identifier"),
             "config": obj.get("config"),
             "managed": obj.get("managed")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_default_config.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_debug.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,60 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict
-from pydantic import BaseModel, Field
-
-class OutpostDefaultConfig(BaseModel):
-    """
-    Global default outpost config  # noqa: E501
+class LDAPDebug(BaseModel):
     """
-    config: Dict[str, Any] = Field(...)
-    __properties = ["config"]
+    LDAPDebug
+    """ # noqa: E501
+    user: List[Dict[str, Any]]
+    group: List[Dict[str, Any]]
+    membership: List[Dict[str, Any]]
+    __properties: ClassVar[List[str]] = ["user", "group", "membership"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OutpostDefaultConfig:
-        """Create an instance of OutpostDefaultConfig from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LDAPDebug from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "config",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "user",
+            "group",
+            "membership",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OutpostDefaultConfig:
-        """Create an instance of OutpostDefaultConfig from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LDAPDebug from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OutpostDefaultConfig.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OutpostDefaultConfig.parse_obj({
-            "config": obj.get("config")
+        _obj = cls.model_validate({
+            "user": obj.get("user"),
+            "group": obj.get("group"),
+            "membership": obj.get("membership")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_health.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/validation_error.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,81 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-
-class OutpostHealth(BaseModel):
-    """
-    Outpost health status  # noqa: E501
+class ValidationError(BaseModel):
     """
-    uid: StrictStr = Field(...)
-    last_seen: datetime = Field(...)
-    version: StrictStr = Field(...)
-    version_should: StrictStr = Field(...)
-    version_outdated: StrictBool = Field(...)
-    build_hash: StrictStr = Field(...)
-    build_hash_should: StrictStr = Field(...)
-    hostname: StrictStr = Field(...)
-    __properties = ["uid", "last_seen", "version", "version_should", "version_outdated", "build_hash", "build_hash_should", "hostname"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Validation Error
+    """ # noqa: E501
+    non_field_errors: Optional[List[StrictStr]] = None
+    code: Optional[StrictStr] = None
+    additional_properties: Dict[str, Any] = {}
+    __properties: ClassVar[List[str]] = ["non_field_errors", "code"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OutpostHealth:
-        """Create an instance of OutpostHealth from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ValidationError from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "uid",
-                            "last_seen",
-                            "version",
-                            "version_should",
-                            "version_outdated",
-                            "build_hash",
-                            "build_hash_should",
-                            "hostname",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * Fields in `self.additional_properties` are added to the output dict.
+        """
+        excluded_fields: Set[str] = set([
+            "additional_properties",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # puts key-value pairs in additional_properties in the top level
+        if self.additional_properties is not None:
+            for _key, _value in self.additional_properties.items():
+                _dict[_key] = _value
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OutpostHealth:
-        """Create an instance of OutpostHealth from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ValidationError from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OutpostHealth.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OutpostHealth.parse_obj({
-            "uid": obj.get("uid"),
-            "last_seen": obj.get("last_seen"),
-            "version": obj.get("version"),
-            "version_should": obj.get("version_should"),
-            "version_outdated": obj.get("version_outdated"),
-            "build_hash": obj.get("build_hash"),
-            "build_hash_should": obj.get("build_hash_should"),
-            "hostname": obj.get("hostname")
+        _obj = cls.model_validate({
+            "non_field_errors": obj.get("non_field_errors"),
+            "code": obj.get("code")
         })
+        # store additional fields in additional_properties
+        for _key in obj.keys():
+            if _key not in cls.__properties:
+                _obj.additional_properties[_key] = obj.get(_key)
+
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,77 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.outpost_type_enum import OutpostTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class OutpostRequest(BaseModel):
     """
-    Outpost Serializer  # noqa: E501
-    """
-    name: constr(strict=True, min_length=1) = Field(...)
-    type: OutpostTypeEnum = Field(...)
-    providers: conlist(StrictInt) = Field(...)
-    service_connection: Optional[StrictStr] = Field(None, description="Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.")
-    config: Dict[str, Any] = Field(...)
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    __properties = ["name", "type", "providers", "service_connection", "config", "managed"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Outpost Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    type: OutpostTypeEnum
+    providers: List[StrictInt]
+    service_connection: Optional[StrictStr] = Field(default=None, description="Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.")
+    config: Dict[str, Any]
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    __properties: ClassVar[List[str]] = ["name", "type", "providers", "service_connection", "config", "managed"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> OutpostRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of OutpostRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if service_connection (nullable) is None
-        # and __fields_set__ contains the field
-        if self.service_connection is None and "service_connection" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.service_connection is None and "service_connection" in self.model_fields_set:
             _dict['service_connection'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> OutpostRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of OutpostRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return OutpostRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = OutpostRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "type": obj.get("type"),
             "providers": obj.get("providers"),
             "service_connection": obj.get("service_connection"),
             "config": obj.get("config"),
             "managed": obj.get("managed")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/outpost_type_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_fields_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,35 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class OutpostTypeEnum(str, Enum):
+class UserFieldsEnum(str, Enum):
     """
-    OutpostTypeEnum
+    UserFieldsEnum
     """
 
     """
     allowed enum values
     """
-    PROXY = 'proxy'
-    LDAP = 'ldap'
-    RADIUS = 'radius'
-    RAC = 'rac'
+    EMAIL = 'email'
+    USERNAME = 'username'
+    UPN = 'upn'
 
     @classmethod
-    def from_json(cls, json_str: str) -> OutpostTypeEnum:
-        """Create an instance of OutpostTypeEnum from a JSON string"""
-        return OutpostTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UserFieldsEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_application_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_identification_stage_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.application import Application
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.identification_stage import IdentificationStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedApplicationList(BaseModel):
-    """
-    PaginatedApplicationList
+class PaginatedIdentificationStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Application) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedIdentificationStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[IdentificationStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedApplicationList:
-        """Create an instance of PaginatedApplicationList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedIdentificationStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedApplicationList:
-        """Create an instance of PaginatedApplicationList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedIdentificationStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedApplicationList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedApplicationList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Application.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [IdentificationStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticate_web_authn_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_login_stage_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.authenticate_web_authn_stage import AuthenticateWebAuthnStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.user_login_stage import UserLoginStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedAuthenticateWebAuthnStageList(BaseModel):
-    """
-    PaginatedAuthenticateWebAuthnStageList
+class PaginatedUserLoginStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(AuthenticateWebAuthnStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserLoginStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserLoginStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedAuthenticateWebAuthnStageList:
-        """Create an instance of PaginatedAuthenticateWebAuthnStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserLoginStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedAuthenticateWebAuthnStageList:
-        """Create an instance of PaginatedAuthenticateWebAuthnStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserLoginStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedAuthenticateWebAuthnStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedAuthenticateWebAuthnStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [AuthenticateWebAuthnStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserLoginStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticated_session_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticated_session_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.authenticated_session import AuthenticatedSession
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedAuthenticatedSessionList(BaseModel):
     """
     PaginatedAuthenticatedSessionList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(AuthenticatedSession) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[AuthenticatedSession]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedAuthenticatedSessionList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedAuthenticatedSessionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedAuthenticatedSessionList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedAuthenticatedSessionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedAuthenticatedSessionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedAuthenticatedSessionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [AuthenticatedSession.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [AuthenticatedSession.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_duo_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_totp_stage_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.authenticator_duo_stage import AuthenticatorDuoStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.authenticator_totp_stage import AuthenticatorTOTPStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedAuthenticatorDuoStageList(BaseModel):
-    """
-    PaginatedAuthenticatorDuoStageList
+class PaginatedAuthenticatorTOTPStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(AuthenticatorDuoStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedAuthenticatorTOTPStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[AuthenticatorTOTPStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedAuthenticatorDuoStageList:
-        """Create an instance of PaginatedAuthenticatorDuoStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorTOTPStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedAuthenticatorDuoStageList:
-        """Create an instance of PaginatedAuthenticatorDuoStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorTOTPStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedAuthenticatorDuoStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedAuthenticatorDuoStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [AuthenticatorDuoStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [AuthenticatorTOTPStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_static_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticate_web_authn_stage_list.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.authenticator_static_stage import AuthenticatorStaticStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.authenticate_web_authn_stage import AuthenticateWebAuthnStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedAuthenticatorStaticStageList(BaseModel):
-    """
-    PaginatedAuthenticatorStaticStageList
+class PaginatedAuthenticateWebAuthnStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(AuthenticatorStaticStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedAuthenticateWebAuthnStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[AuthenticateWebAuthnStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedAuthenticatorStaticStageList:
-        """Create an instance of PaginatedAuthenticatorStaticStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticateWebAuthnStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedAuthenticatorStaticStageList:
-        """Create an instance of PaginatedAuthenticatorStaticStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticateWebAuthnStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedAuthenticatorStaticStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedAuthenticatorStaticStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [AuthenticatorStaticStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [AuthenticateWebAuthnStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_totp_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_authenticator_sms_stage_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.authenticator_totp_stage import AuthenticatorTOTPStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.authenticator_sms_stage import AuthenticatorSMSStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedAuthenticatorTOTPStageList(BaseModel):
-    """
-    PaginatedAuthenticatorTOTPStageList
+class PaginatedAuthenticatorSMSStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(AuthenticatorTOTPStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedAuthenticatorSMSStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[AuthenticatorSMSStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedAuthenticatorTOTPStageList:
-        """Create an instance of PaginatedAuthenticatorTOTPStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorSMSStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedAuthenticatorTOTPStageList:
-        """Create an instance of PaginatedAuthenticatorTOTPStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedAuthenticatorSMSStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedAuthenticatorTOTPStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedAuthenticatorTOTPStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [AuthenticatorTOTPStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [AuthenticatorSMSStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_authenticator_validate_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_invitation_stage_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.authenticator_validate_stage import AuthenticatorValidateStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.invitation_stage import InvitationStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedAuthenticatorValidateStageList(BaseModel):
-    """
-    PaginatedAuthenticatorValidateStageList
+class PaginatedInvitationStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(AuthenticatorValidateStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedInvitationStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[InvitationStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedAuthenticatorValidateStageList:
-        """Create an instance of PaginatedAuthenticatorValidateStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedInvitationStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedAuthenticatorValidateStageList:
-        """Create an instance of PaginatedAuthenticatorValidateStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedInvitationStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedAuthenticatorValidateStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedAuthenticatorValidateStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [AuthenticatorValidateStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [InvitationStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_blueprint_instance_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_plex_source_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.blueprint_instance import BlueprintInstance
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.plex_source import PlexSource
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedBlueprintInstanceList(BaseModel):
-    """
-    PaginatedBlueprintInstanceList
+class PaginatedPlexSourceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(BlueprintInstance) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPlexSourceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PlexSource]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedBlueprintInstanceList:
-        """Create an instance of PaginatedBlueprintInstanceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPlexSourceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedBlueprintInstanceList:
-        """Create an instance of PaginatedBlueprintInstanceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPlexSourceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedBlueprintInstanceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedBlueprintInstanceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [BlueprintInstance.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PlexSource.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_brand_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_token_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.brand import Brand
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.token import Token
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedBrandList(BaseModel):
-    """
-    PaginatedBrandList
+class PaginatedTokenList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Brand) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedTokenList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Token]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedBrandList:
-        """Create an instance of PaginatedBrandList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedTokenList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedBrandList:
-        """Create an instance of PaginatedBrandList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedTokenList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedBrandList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedBrandList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Brand.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Token.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_captcha_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_expression_policy_list.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.captcha_stage import CaptchaStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.expression_policy import ExpressionPolicy
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedCaptchaStageList(BaseModel):
-    """
-    PaginatedCaptchaStageList
+class PaginatedExpressionPolicyList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(CaptchaStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedExpressionPolicyList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ExpressionPolicy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedCaptchaStageList:
-        """Create an instance of PaginatedCaptchaStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedExpressionPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedCaptchaStageList:
-        """Create an instance of PaginatedCaptchaStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedExpressionPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedCaptchaStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedCaptchaStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [CaptchaStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ExpressionPolicy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_certificate_key_pair_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_certificate_key_pair_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.certificate_key_pair import CertificateKeyPair
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedCertificateKeyPairList(BaseModel):
     """
     PaginatedCertificateKeyPairList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(CertificateKeyPair) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[CertificateKeyPair]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedCertificateKeyPairList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedCertificateKeyPairList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedCertificateKeyPairList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedCertificateKeyPairList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedCertificateKeyPairList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedCertificateKeyPairList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [CertificateKeyPair.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [CertificateKeyPair.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_connection_token_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_connection_token_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.connection_token import ConnectionToken
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedConnectionTokenList(BaseModel):
     """
     PaginatedConnectionTokenList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(ConnectionToken) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ConnectionToken]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedConnectionTokenList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedConnectionTokenList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedConnectionTokenList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedConnectionTokenList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedConnectionTokenList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedConnectionTokenList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ConnectionToken.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ConnectionToken.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_consent_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_password_stage_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.consent_stage import ConsentStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.password_stage import PasswordStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedConsentStageList(BaseModel):
-    """
-    PaginatedConsentStageList
+class PaginatedPasswordStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(ConsentStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPasswordStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PasswordStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedConsentStageList:
-        """Create an instance of PaginatedConsentStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPasswordStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedConsentStageList:
-        """Create an instance of PaginatedConsentStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPasswordStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedConsentStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedConsentStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ConsentStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PasswordStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_deny_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_deny_stage_list.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.deny_stage import DenyStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedDenyStageList(BaseModel):
     """
     PaginatedDenyStageList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(DenyStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[DenyStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedDenyStageList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedDenyStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedDenyStageList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedDenyStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedDenyStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedDenyStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [DenyStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [DenyStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_docker_service_connection_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_docker_service_connection_list.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.docker_service_connection import DockerServiceConnection
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedDockerServiceConnectionList(BaseModel):
     """
     PaginatedDockerServiceConnectionList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(DockerServiceConnection) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[DockerServiceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedDockerServiceConnectionList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedDockerServiceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedDockerServiceConnectionList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedDockerServiceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedDockerServiceConnectionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedDockerServiceConnectionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [DockerServiceConnection.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [DockerServiceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_domain_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_sms_device_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.domain import Domain
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.sms_device import SMSDevice
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedDomainList(BaseModel):
-    """
-    PaginatedDomainList
+class PaginatedSMSDeviceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Domain) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedSMSDeviceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SMSDevice]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedDomainList:
-        """Create an instance of PaginatedDomainList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedSMSDeviceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedDomainList:
-        """Create an instance of PaginatedDomainList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedSMSDeviceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedDomainList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedDomainList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Domain.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SMSDevice.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_dummy_policy_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_reputation_policy_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.dummy_policy import DummyPolicy
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.reputation_policy import ReputationPolicy
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedDummyPolicyList(BaseModel):
-    """
-    PaginatedDummyPolicyList
+class PaginatedReputationPolicyList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(DummyPolicy) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedReputationPolicyList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ReputationPolicy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedDummyPolicyList:
-        """Create an instance of PaginatedDummyPolicyList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedReputationPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedDummyPolicyList:
-        """Create an instance of PaginatedDummyPolicyList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedReputationPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedDummyPolicyList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedDummyPolicyList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [DummyPolicy.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ReputationPolicy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_dummy_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_event_matcher_policy_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.dummy_stage import DummyStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.event_matcher_policy import EventMatcherPolicy
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedDummyStageList(BaseModel):
-    """
-    PaginatedDummyStageList
+class PaginatedEventMatcherPolicyList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(DummyStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedEventMatcherPolicyList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[EventMatcherPolicy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedDummyStageList:
-        """Create an instance of PaginatedDummyStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedEventMatcherPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedDummyStageList:
-        """Create an instance of PaginatedDummyStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedEventMatcherPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedDummyStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedDummyStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [DummyStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [EventMatcherPolicy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_duo_device_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_plex_source_connection_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.duo_device import DuoDevice
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.plex_source_connection import PlexSourceConnection
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedDuoDeviceList(BaseModel):
-    """
-    PaginatedDuoDeviceList
+class PaginatedPlexSourceConnectionList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(DuoDevice) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPlexSourceConnectionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PlexSourceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedDuoDeviceList:
-        """Create an instance of PaginatedDuoDeviceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPlexSourceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedDuoDeviceList:
-        """Create an instance of PaginatedDuoDeviceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPlexSourceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedDuoDeviceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedDuoDeviceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [DuoDevice.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PlexSourceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_email_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_role_list.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.email_stage import EmailStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.role import Role
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedEmailStageList(BaseModel):
-    """
-    PaginatedEmailStageList
+class PaginatedRoleList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(EmailStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedRoleList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Role]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedEmailStageList:
-        """Create an instance of PaginatedEmailStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedRoleList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedEmailStageList:
-        """Create an instance of PaginatedEmailStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedRoleList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedEmailStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedEmailStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [EmailStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Role.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_endpoint_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_endpoint_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.endpoint import Endpoint
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedEndpointList(BaseModel):
     """
     PaginatedEndpointList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(Endpoint) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Endpoint]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedEndpointList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedEndpointList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedEndpointList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedEndpointList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedEndpointList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedEndpointList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Endpoint.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Endpoint.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_event_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_expiring_base_grant_model_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.event import Event
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.expiring_base_grant_model import ExpiringBaseGrantModel
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedEventList(BaseModel):
-    """
-    PaginatedEventList
+class PaginatedExpiringBaseGrantModelList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Event) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedExpiringBaseGrantModelList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ExpiringBaseGrantModel]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedEventList:
-        """Create an instance of PaginatedEventList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedExpiringBaseGrantModelList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedEventList:
-        """Create an instance of PaginatedEventList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedExpiringBaseGrantModelList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedEventList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedEventList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Event.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ExpiringBaseGrantModel.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_event_matcher_policy_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_policy_list.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.event_matcher_policy import EventMatcherPolicy
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.policy import Policy
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedEventMatcherPolicyList(BaseModel):
-    """
-    PaginatedEventMatcherPolicyList
+class PaginatedPolicyList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(EventMatcherPolicy) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPolicyList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Policy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedEventMatcherPolicyList:
-        """Create an instance of PaginatedEventMatcherPolicyList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedEventMatcherPolicyList:
-        """Create an instance of PaginatedEventMatcherPolicyList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedEventMatcherPolicyList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedEventMatcherPolicyList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [EventMatcherPolicy.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Policy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_expiring_base_grant_model_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_scim_mapping_list.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.expiring_base_grant_model import ExpiringBaseGrantModel
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.scim_mapping import SCIMMapping
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedExpiringBaseGrantModelList(BaseModel):
-    """
-    PaginatedExpiringBaseGrantModelList
+class PaginatedSCIMMappingList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(ExpiringBaseGrantModel) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedSCIMMappingList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SCIMMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedExpiringBaseGrantModelList:
-        """Create an instance of PaginatedExpiringBaseGrantModelList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedSCIMMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedExpiringBaseGrantModelList:
-        """Create an instance of PaginatedExpiringBaseGrantModelList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedSCIMMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedExpiringBaseGrantModelList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedExpiringBaseGrantModelList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ExpiringBaseGrantModel.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SCIMMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_expression_policy_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_prompt_stage_list.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.expression_policy import ExpressionPolicy
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.prompt_stage import PromptStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedExpressionPolicyList(BaseModel):
-    """
-    PaginatedExpressionPolicyList
+class PaginatedPromptStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(ExpressionPolicy) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPromptStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PromptStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedExpressionPolicyList:
-        """Create an instance of PaginatedExpressionPolicyList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPromptStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedExpressionPolicyList:
-        """Create an instance of PaginatedExpressionPolicyList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPromptStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedExpressionPolicyList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedExpressionPolicyList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ExpressionPolicy.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PromptStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_extra_role_object_permission_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_extra_role_object_permission_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.extra_role_object_permission import ExtraRoleObjectPermission
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedExtraRoleObjectPermissionList(BaseModel):
     """
     PaginatedExtraRoleObjectPermissionList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(ExtraRoleObjectPermission) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ExtraRoleObjectPermission]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedExtraRoleObjectPermissionList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedExtraRoleObjectPermissionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedExtraRoleObjectPermissionList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedExtraRoleObjectPermissionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedExtraRoleObjectPermissionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedExtraRoleObjectPermissionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ExtraRoleObjectPermission.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ExtraRoleObjectPermission.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_extra_user_object_permission_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_extra_user_object_permission_list.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.extra_user_object_permission import ExtraUserObjectPermission
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedExtraUserObjectPermissionList(BaseModel):
     """
     PaginatedExtraUserObjectPermissionList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(ExtraUserObjectPermission) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ExtraUserObjectPermission]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedExtraUserObjectPermissionList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedExtraUserObjectPermissionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedExtraUserObjectPermissionList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedExtraUserObjectPermissionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedExtraUserObjectPermissionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedExtraUserObjectPermissionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ExtraUserObjectPermission.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ExtraUserObjectPermission.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_flow_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_logout_stage_list.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.flow import Flow
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.user_logout_stage import UserLogoutStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedFlowList(BaseModel):
-    """
-    PaginatedFlowList
+class PaginatedUserLogoutStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Flow) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserLogoutStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserLogoutStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedFlowList:
-        """Create an instance of PaginatedFlowList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserLogoutStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedFlowList:
-        """Create an instance of PaginatedFlowList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserLogoutStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedFlowList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedFlowList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Flow.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserLogoutStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_flow_stage_binding_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_flow_stage_binding_list.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.flow_stage_binding import FlowStageBinding
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedFlowStageBindingList(BaseModel):
     """
     PaginatedFlowStageBindingList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(FlowStageBinding) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[FlowStageBinding]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedFlowStageBindingList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedFlowStageBindingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedFlowStageBindingList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedFlowStageBindingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedFlowStageBindingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedFlowStageBindingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [FlowStageBinding.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [FlowStageBinding.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_group_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_group_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.group import Group
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedGroupList(BaseModel):
     """
     PaginatedGroupList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(Group) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Group]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedGroupList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedGroupList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedGroupList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedGroupList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedGroupList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedGroupList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Group.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Group.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_identification_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_kubernetes_service_connection_list.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.identification_stage import IdentificationStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.kubernetes_service_connection import KubernetesServiceConnection
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedIdentificationStageList(BaseModel):
-    """
-    PaginatedIdentificationStageList
+class PaginatedKubernetesServiceConnectionList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(IdentificationStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedKubernetesServiceConnectionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[KubernetesServiceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedIdentificationStageList:
-        """Create an instance of PaginatedIdentificationStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedKubernetesServiceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedIdentificationStageList:
-        """Create an instance of PaginatedIdentificationStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedKubernetesServiceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedIdentificationStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedIdentificationStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [IdentificationStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [KubernetesServiceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_invitation_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_application_list.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.invitation import Invitation
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.application import Application
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedInvitationList(BaseModel):
-    """
-    PaginatedInvitationList
+class PaginatedApplicationList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Invitation) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedApplicationList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Application]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedInvitationList:
-        """Create an instance of PaginatedInvitationList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedApplicationList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedInvitationList:
-        """Create an instance of PaginatedInvitationList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedApplicationList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedInvitationList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedInvitationList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Invitation.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Application.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_invitation_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_proxy_outpost_config_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.invitation_stage import InvitationStage
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.proxy_outpost_config import ProxyOutpostConfig
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedInvitationStageList(BaseModel):
-    """
-    PaginatedInvitationStageList
+class PaginatedProxyOutpostConfigList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(InvitationStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedProxyOutpostConfigList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ProxyOutpostConfig]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedInvitationStageList:
-        """Create an instance of PaginatedInvitationStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedProxyOutpostConfigList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedInvitationStageList:
-        """Create an instance of PaginatedInvitationStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedProxyOutpostConfigList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedInvitationStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedInvitationStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [InvitationStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ProxyOutpostConfig.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_outpost_config_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_consent_stage_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.ldap_outpost_config import LDAPOutpostConfig
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.consent_stage import ConsentStage
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedLDAPOutpostConfigList(BaseModel):
-    """
-    PaginatedLDAPOutpostConfigList
+class PaginatedConsentStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(LDAPOutpostConfig) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedConsentStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ConsentStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedLDAPOutpostConfigList:
-        """Create an instance of PaginatedLDAPOutpostConfigList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedConsentStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedLDAPOutpostConfigList:
-        """Create an instance of PaginatedLDAPOutpostConfigList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedConsentStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedLDAPOutpostConfigList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedLDAPOutpostConfigList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [LDAPOutpostConfig.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ConsentStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_property_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_property_mapping_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.ldap_property_mapping import LDAPPropertyMapping
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedLDAPPropertyMappingList(BaseModel):
     """
     PaginatedLDAPPropertyMappingList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(LDAPPropertyMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[LDAPPropertyMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedLDAPPropertyMappingList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedLDAPPropertyMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedLDAPPropertyMappingList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedLDAPPropertyMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedLDAPPropertyMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedLDAPPropertyMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [LDAPPropertyMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [LDAPPropertyMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_provider_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.ldap_provider import LDAPProvider
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedLDAPProviderList(BaseModel):
     """
     PaginatedLDAPProviderList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(LDAPProvider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[LDAPProvider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedLDAPProviderList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedLDAPProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedLDAPProviderList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedLDAPProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedLDAPProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedLDAPProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [LDAPProvider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [LDAPProvider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_ldap_source_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_o_auth_source_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.ldap_source import LDAPSource
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.o_auth_source import OAuthSource
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedLDAPSourceList(BaseModel):
-    """
-    PaginatedLDAPSourceList
+class PaginatedOAuthSourceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(LDAPSource) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedOAuthSourceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[OAuthSource]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedLDAPSourceList:
-        """Create an instance of PaginatedLDAPSourceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedOAuthSourceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedLDAPSourceList:
-        """Create an instance of PaginatedLDAPSourceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedOAuthSourceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedLDAPSourceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedLDAPSourceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [LDAPSource.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [OAuthSource.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_license_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_web_authn_device_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.license import License
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.web_authn_device import WebAuthnDevice
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedLicenseList(BaseModel):
-    """
-    PaginatedLicenseList
+class PaginatedWebAuthnDeviceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(License) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedWebAuthnDeviceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[WebAuthnDevice]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedLicenseList:
-        """Create an instance of PaginatedLicenseList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedWebAuthnDeviceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedLicenseList:
-        """Create an instance of PaginatedLicenseList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedWebAuthnDeviceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedLicenseList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedLicenseList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [License.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [WebAuthnDevice.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_webhook_mapping_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.notification import Notification
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.notification_webhook_mapping import NotificationWebhookMapping
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedNotificationList(BaseModel):
-    """
-    PaginatedNotificationList
+class PaginatedNotificationWebhookMappingList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Notification) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedNotificationWebhookMappingList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[NotificationWebhookMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedNotificationList:
-        """Create an instance of PaginatedNotificationList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedNotificationWebhookMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedNotificationList:
-        """Create an instance of PaginatedNotificationList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedNotificationWebhookMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedNotificationList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedNotificationList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Notification.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [NotificationWebhookMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_rule_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_property_mapping_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.notification_rule import NotificationRule
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.property_mapping import PropertyMapping
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedNotificationRuleList(BaseModel):
-    """
-    PaginatedNotificationRuleList
+class PaginatedPropertyMappingList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(NotificationRule) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPropertyMappingList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PropertyMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedNotificationRuleList:
-        """Create an instance of PaginatedNotificationRuleList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPropertyMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedNotificationRuleList:
-        """Create an instance of PaginatedNotificationRuleList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPropertyMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedNotificationRuleList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedNotificationRuleList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [NotificationRule.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PropertyMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_transport_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_duo_device_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.notification_transport import NotificationTransport
-from authentik_client.models.pagination import Pagination
-
-class PaginatedNotificationTransportList(BaseModel):
-    """
-    PaginatedNotificationTransportList
+class PatchedDuoDeviceRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(NotificationTransport) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for Duo authenticator devices
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedNotificationTransportList:
-        """Create an instance of PaginatedNotificationTransportList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedDuoDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedNotificationTransportList:
-        """Create an instance of PaginatedNotificationTransportList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedDuoDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedNotificationTransportList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedNotificationTransportList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [NotificationTransport.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_notification_webhook_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/file_path_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.notification_webhook_mapping import NotificationWebhookMapping
-from authentik_client.models.pagination import Pagination
-
-class PaginatedNotificationWebhookMappingList(BaseModel):
-    """
-    PaginatedNotificationWebhookMappingList
+class FilePathRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(NotificationWebhookMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer to upload file
+    """ # noqa: E501
+    url: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedNotificationWebhookMappingList:
-        """Create an instance of PaginatedNotificationWebhookMappingList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FilePathRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedNotificationWebhookMappingList:
-        """Create an instance of PaginatedNotificationWebhookMappingList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FilePathRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedNotificationWebhookMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedNotificationWebhookMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [NotificationWebhookMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "url": obj.get("url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_o_auth2_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_o_auth2_provider_list.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.o_auth2_provider import OAuth2Provider
 from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedOAuth2ProviderList(BaseModel):
     """
     PaginatedOAuth2ProviderList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(OAuth2Provider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[OAuth2Provider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedOAuth2ProviderList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedOAuth2ProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedOAuth2ProviderList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedOAuth2ProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedOAuth2ProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedOAuth2ProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [OAuth2Provider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [OAuth2Provider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_o_auth_source_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_permission_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.o_auth_source import OAuthSource
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.permission import Permission
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedOAuthSourceList(BaseModel):
-    """
-    PaginatedOAuthSourceList
+class PaginatedPermissionList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(OAuthSource) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPermissionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Permission]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedOAuthSourceList:
-        """Create an instance of PaginatedOAuthSourceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPermissionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedOAuthSourceList:
-        """Create an instance of PaginatedOAuthSourceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPermissionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedOAuthSourceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedOAuthSourceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [OAuthSource.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Permission.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_outpost_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_scim_provider_list.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.outpost import Outpost
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
+from authentik_client.models.scim_provider import SCIMProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedOutpostList(BaseModel):
-    """
-    PaginatedOutpostList
+class PaginatedSCIMProviderList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Outpost) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedSCIMProviderList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SCIMProvider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedOutpostList:
-        """Create an instance of PaginatedOutpostList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedSCIMProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedOutpostList:
-        """Create an instance of PaginatedOutpostList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedSCIMProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedOutpostList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedOutpostList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Outpost.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SCIMProvider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_password_policy_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_password_policy_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.password_policy import PasswordPolicy
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedPasswordPolicyList(BaseModel):
     """
     PaginatedPasswordPolicyList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(PasswordPolicy) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PasswordPolicy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPasswordPolicyList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedPasswordPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPasswordPolicyList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedPasswordPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPasswordPolicyList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPasswordPolicyList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [PasswordPolicy.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PasswordPolicy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_password_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_domain_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.domain import Domain
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.password_stage import PasswordStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedPasswordStageList(BaseModel):
-    """
-    PaginatedPasswordStageList
+class PaginatedDomainList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(PasswordStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedDomainList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Domain]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPasswordStageList:
-        """Create an instance of PaginatedPasswordStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedDomainList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPasswordStageList:
-        """Create an instance of PaginatedPasswordStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedDomainList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPasswordStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPasswordStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [PasswordStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Domain.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_permission_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/role_assigned_object_permission.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.role_object_permission import RoleObjectPermission
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.permission import Permission
-
-class PaginatedPermissionList(BaseModel):
-    """
-    PaginatedPermissionList
+class RoleAssignedObjectPermission(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Permission) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Roles assigned object permission serializer
+    """ # noqa: E501
+    role_pk: StrictStr
+    name: StrictStr
+    permissions: List[RoleObjectPermission]
+    __properties: ClassVar[List[str]] = ["role_pk", "name", "permissions"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPermissionList:
-        """Create an instance of PaginatedPermissionList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RoleAssignedObjectPermission from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "role_pk",
+            "name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in permissions (list)
         _items = []
-        if self.results:
-            for _item in self.results:
+        if self.permissions:
+            for _item in self.permissions:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['results'] = _items
+            _dict['permissions'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPermissionList:
-        """Create an instance of PaginatedPermissionList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RoleAssignedObjectPermission from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPermissionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPermissionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Permission.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "role_pk": obj.get("role_pk"),
+            "name": obj.get("name"),
+            "permissions": [RoleObjectPermission.from_dict(_item) for _item in obj["permissions"]] if obj.get("permissions") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_plex_source_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_sync_status.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.system_task import SystemTask
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.plex_source import PlexSource
-
-class PaginatedPlexSourceList(BaseModel):
-    """
-    PaginatedPlexSourceList
+class LDAPSyncStatus(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(PlexSource) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    LDAP Source sync status
+    """ # noqa: E501
+    is_running: StrictBool
+    tasks: List[SystemTask]
+    __properties: ClassVar[List[str]] = ["is_running", "tasks"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPlexSourceList:
-        """Create an instance of PaginatedPlexSourceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LDAPSyncStatus from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "is_running",
+            "tasks",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in tasks (list)
         _items = []
-        if self.results:
-            for _item in self.results:
+        if self.tasks:
+            for _item in self.tasks:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['results'] = _items
+            _dict['tasks'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPlexSourceList:
-        """Create an instance of PaginatedPlexSourceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LDAPSyncStatus from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPlexSourceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPlexSourceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [PlexSource.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "is_running": obj.get("is_running"),
+            "tasks": [SystemTask.from_dict(_item) for _item in obj["tasks"]] if obj.get("tasks") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_policy_binding_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_policy_binding_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.policy_binding import PolicyBinding
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedPolicyBindingList(BaseModel):
     """
     PaginatedPolicyBindingList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(PolicyBinding) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PolicyBinding]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPolicyBindingList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedPolicyBindingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPolicyBindingList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedPolicyBindingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPolicyBindingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPolicyBindingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [PolicyBinding.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PolicyBinding.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_policy_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_radius_provider_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.policy import Policy
+from authentik_client.models.radius_provider import RadiusProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedPolicyList(BaseModel):
-    """
-    PaginatedPolicyList
+class PaginatedRadiusProviderList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Policy) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedRadiusProviderList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[RadiusProvider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPolicyList:
-        """Create an instance of PaginatedPolicyList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedRadiusProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPolicyList:
-        """Create an instance of PaginatedPolicyList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedRadiusProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPolicyList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPolicyList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Policy.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [RadiusProvider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_prompt_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_transport_list.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.notification_transport import NotificationTransport
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.prompt import Prompt
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedPromptList(BaseModel):
-    """
-    PaginatedPromptList
+class PaginatedNotificationTransportList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Prompt) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedNotificationTransportList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[NotificationTransport]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPromptList:
-        """Create an instance of PaginatedPromptList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedNotificationTransportList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPromptList:
-        """Create an instance of PaginatedPromptList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedNotificationTransportList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPromptList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPromptList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Prompt.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [NotificationTransport.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_prompt_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_token_redeem_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.prompt_stage import PromptStage
-
-class PaginatedPromptStageList(BaseModel):
-    """
-    PaginatedPromptStageList
+class PlexTokenRedeemRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(PromptStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer to redeem a plex token
+    """ # noqa: E501
+    plex_token: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["plex_token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPromptStageList:
-        """Create an instance of PaginatedPromptStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PlexTokenRedeemRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPromptStageList:
-        """Create an instance of PaginatedPromptStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PlexTokenRedeemRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPromptStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPromptStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [PromptStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "plex_token": obj.get("plex_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_property_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_rac_property_mapping_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.property_mapping import PropertyMapping
+from authentik_client.models.rac_property_mapping import RACPropertyMapping
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedPropertyMappingList(BaseModel):
-    """
-    PaginatedPropertyMappingList
+class PaginatedRACPropertyMappingList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(PropertyMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedRACPropertyMappingList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[RACPropertyMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedPropertyMappingList:
-        """Create an instance of PaginatedPropertyMappingList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedRACPropertyMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedPropertyMappingList:
-        """Create an instance of PaginatedPropertyMappingList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedRACPropertyMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedPropertyMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedPropertyMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [PropertyMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [RACPropertyMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_proxy_provider_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.provider import Provider
+from authentik_client.models.proxy_provider import ProxyProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedProviderList(BaseModel):
-    """
-    PaginatedProviderList
+class PaginatedProxyProviderList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Provider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedProxyProviderList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ProxyProvider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedProviderList:
-        """Create an instance of PaginatedProviderList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedProxyProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedProviderList:
-        """Create an instance of PaginatedProviderList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedProxyProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Provider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ProxyProvider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_proxy_outpost_config_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_dummy_stage_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.dummy_stage import DummyStage
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.proxy_outpost_config import ProxyOutpostConfig
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedProxyOutpostConfigList(BaseModel):
-    """
-    PaginatedProxyOutpostConfigList
+class PaginatedDummyStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(ProxyOutpostConfig) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedDummyStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[DummyStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedProxyOutpostConfigList:
-        """Create an instance of PaginatedProxyOutpostConfigList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedDummyStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedProxyOutpostConfigList:
-        """Create an instance of PaginatedProxyOutpostConfigList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedDummyStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedProxyOutpostConfigList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedProxyOutpostConfigList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ProxyOutpostConfig.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [DummyStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_proxy_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_provider_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.proxy_provider import ProxyProvider
+from authentik_client.models.provider import Provider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedProxyProviderList(BaseModel):
-    """
-    PaginatedProxyProviderList
+class PaginatedProviderList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(ProxyProvider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedProviderList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Provider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedProxyProviderList:
-        """Create an instance of PaginatedProxyProviderList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedProxyProviderList:
-        """Create an instance of PaginatedProxyProviderList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedProxyProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedProxyProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ProxyProvider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Provider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_rac_property_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/expression_policy_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.rac_property_mapping import RACPropertyMapping
-
-class PaginatedRACPropertyMappingList(BaseModel):
-    """
-    PaginatedRACPropertyMappingList
+class ExpressionPolicyRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(RACPropertyMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Group Membership Policy Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    expression: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedRACPropertyMappingList:
-        """Create an instance of PaginatedRACPropertyMappingList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ExpressionPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedRACPropertyMappingList:
-        """Create an instance of PaginatedRACPropertyMappingList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ExpressionPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedRACPropertyMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedRACPropertyMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [RACPropertyMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "execution_logging": obj.get("execution_logging"),
+            "expression": obj.get("expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_rac_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_rac_provider_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.rac_provider import RACProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedRACProviderList(BaseModel):
     """
     PaginatedRACProviderList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(RACProvider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[RACProvider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedRACProviderList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedRACProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedRACProviderList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedRACProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedRACProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedRACProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [RACProvider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [RACProvider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_radius_outpost_config_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_static_device_list.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.radius_outpost_config import RadiusOutpostConfig
+from authentik_client.models.static_device import StaticDevice
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedRadiusOutpostConfigList(BaseModel):
-    """
-    PaginatedRadiusOutpostConfigList
+class PaginatedStaticDeviceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(RadiusOutpostConfig) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedStaticDeviceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[StaticDevice]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedRadiusOutpostConfigList:
-        """Create an instance of PaginatedRadiusOutpostConfigList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedStaticDeviceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedRadiusOutpostConfigList:
-        """Create an instance of PaginatedRadiusOutpostConfigList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedStaticDeviceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedRadiusOutpostConfigList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedRadiusOutpostConfigList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [RadiusOutpostConfig.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [StaticDevice.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_radius_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_saml_provider_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.radius_provider import RadiusProvider
+from authentik_client.models.saml_provider import SAMLProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedRadiusProviderList(BaseModel):
-    """
-    PaginatedRadiusProviderList
+class PaginatedSAMLProviderList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(RadiusProvider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedSAMLProviderList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SAMLProvider]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedRadiusProviderList:
-        """Create an instance of PaginatedRadiusProviderList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedSAMLProviderList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedRadiusProviderList:
-        """Create an instance of PaginatedRadiusProviderList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedSAMLProviderList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedRadiusProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedRadiusProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [RadiusProvider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SAMLProvider.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_role_assigned_object_permission_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_assigned_object_permission_list.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.role_assigned_object_permission import RoleAssignedObjectPermission
+from authentik_client.models.user_assigned_object_permission import UserAssignedObjectPermission
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedRoleAssignedObjectPermissionList(BaseModel):
-    """
-    PaginatedRoleAssignedObjectPermissionList
+class PaginatedUserAssignedObjectPermissionList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(RoleAssignedObjectPermission) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserAssignedObjectPermissionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserAssignedObjectPermission]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedRoleAssignedObjectPermissionList:
-        """Create an instance of PaginatedRoleAssignedObjectPermissionList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserAssignedObjectPermissionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedRoleAssignedObjectPermissionList:
-        """Create an instance of PaginatedRoleAssignedObjectPermissionList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserAssignedObjectPermissionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedRoleAssignedObjectPermissionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedRoleAssignedObjectPermissionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [RoleAssignedObjectPermission.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserAssignedObjectPermission.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_role_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_duo_device_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.duo_device import DuoDevice
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.role import Role
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedRoleList(BaseModel):
-    """
-    PaginatedRoleList
+class PaginatedDuoDeviceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Role) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedDuoDeviceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[DuoDevice]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedRoleList:
-        """Create an instance of PaginatedRoleList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedDuoDeviceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedRoleList:
-        """Create an instance of PaginatedRoleList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedDuoDeviceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedRoleList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedRoleList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Role.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [DuoDevice.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_saml_property_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_saml_property_mapping_list.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.saml_property_mapping import SAMLPropertyMapping
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedSAMLPropertyMappingList(BaseModel):
     """
     PaginatedSAMLPropertyMappingList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(SAMLPropertyMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SAMLPropertyMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSAMLPropertyMappingList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedSAMLPropertyMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSAMLPropertyMappingList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedSAMLPropertyMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSAMLPropertyMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSAMLPropertyMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SAMLPropertyMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SAMLPropertyMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_saml_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_captcha_stage_list.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.captcha_stage import CaptchaStage
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.saml_provider import SAMLProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedSAMLProviderList(BaseModel):
-    """
-    PaginatedSAMLProviderList
+class PaginatedCaptchaStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SAMLProvider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedCaptchaStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[CaptchaStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSAMLProviderList:
-        """Create an instance of PaginatedSAMLProviderList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedCaptchaStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSAMLProviderList:
-        """Create an instance of PaginatedSAMLProviderList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedCaptchaStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSAMLProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSAMLProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SAMLProvider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [CaptchaStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_saml_source_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_tenant_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.saml_source import SAMLSource
+from authentik_client.models.tenant import Tenant
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedSAMLSourceList(BaseModel):
-    """
-    PaginatedSAMLSourceList
+class PaginatedTenantList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SAMLSource) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedTenantList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Tenant]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSAMLSourceList:
-        """Create an instance of PaginatedSAMLSourceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedTenantList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSAMLSourceList:
-        """Create an instance of PaginatedSAMLSourceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedTenantList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSAMLSourceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSAMLSourceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SAMLSource.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Tenant.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_scim_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/session_user.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.user_self import UserSelf
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.scim_mapping import SCIMMapping
-
-class PaginatedSCIMMappingList(BaseModel):
-    """
-    PaginatedSCIMMappingList
+class SessionUser(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SCIMMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Response for the /user/me endpoint, returns the currently active user (as `user` property) and, if this user is being impersonated, the original user in the `original` property.
+    """ # noqa: E501
+    user: UserSelf
+    original: Optional[UserSelf] = None
+    __properties: ClassVar[List[str]] = ["user", "original"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSCIMMappingList:
-        """Create an instance of PaginatedSCIMMappingList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SessionUser from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of user
+        if self.user:
+            _dict['user'] = self.user.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of original
+        if self.original:
+            _dict['original'] = self.original.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSCIMMappingList:
-        """Create an instance of PaginatedSCIMMappingList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SessionUser from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSCIMMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSCIMMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SCIMMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "user": UserSelf.from_dict(obj["user"]) if obj.get("user") is not None else None,
+            "original": UserSelf.from_dict(obj["original"]) if obj.get("original") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_scim_provider_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_password_expiry_policy_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.scim_provider import SCIMProvider
+from authentik_client.models.password_expiry_policy import PasswordExpiryPolicy
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedSCIMProviderList(BaseModel):
-    """
-    PaginatedSCIMProviderList
+class PaginatedPasswordExpiryPolicyList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SCIMProvider) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedPasswordExpiryPolicyList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[PasswordExpiryPolicy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSCIMProviderList:
-        """Create an instance of PaginatedSCIMProviderList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedPasswordExpiryPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSCIMProviderList:
-        """Create an instance of PaginatedSCIMProviderList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedPasswordExpiryPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSCIMProviderList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSCIMProviderList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SCIMProvider.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [PasswordExpiryPolicy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_scope_mapping_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_scope_mapping_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.scope_mapping import ScopeMapping
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedScopeMappingList(BaseModel):
     """
     PaginatedScopeMappingList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(ScopeMapping) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[ScopeMapping]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedScopeMappingList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedScopeMappingList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedScopeMappingList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedScopeMappingList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedScopeMappingList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedScopeMappingList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ScopeMapping.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [ScopeMapping.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_service_connection_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/totp_device_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.service_connection import ServiceConnection
-
-class PaginatedServiceConnectionList(BaseModel):
-    """
-    PaginatedServiceConnectionList
+class TOTPDeviceRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(ServiceConnection) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for totp authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedServiceConnectionList:
-        """Create an instance of PaginatedServiceConnectionList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TOTPDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedServiceConnectionList:
-        """Create an instance of PaginatedServiceConnectionList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TOTPDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedServiceConnectionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedServiceConnectionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [ServiceConnection.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_sms_device_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_sms_device_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.sms_device import SMSDevice
-
-class PaginatedSMSDeviceList(BaseModel):
-    """
-    PaginatedSMSDeviceList
+class PatchedSMSDeviceRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SMSDevice) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for sms authenticator devices
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSMSDeviceList:
-        """Create an instance of PaginatedSMSDeviceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSMSDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSMSDeviceList:
-        """Create an instance of PaginatedSMSDeviceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSMSDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSMSDeviceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSMSDeviceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SMSDevice.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_source_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_source_stage_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.source import Source
+from authentik_client.models.source_stage import SourceStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedSourceList(BaseModel):
-    """
-    PaginatedSourceList
+class PaginatedSourceStageList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Source) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedSourceStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SourceStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSourceList:
-        """Create an instance of PaginatedSourceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedSourceStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSourceList:
-        """Create an instance of PaginatedSourceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedSourceStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSourceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSourceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Source.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SourceStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_source_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_ldap_outpost_config_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.ldap_outpost_config import LDAPOutpostConfig
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.source_stage import SourceStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedSourceStageList(BaseModel):
-    """
-    PaginatedSourceStageList
+class PaginatedLDAPOutpostConfigList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SourceStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedLDAPOutpostConfigList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[LDAPOutpostConfig]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSourceStageList:
-        """Create an instance of PaginatedSourceStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedLDAPOutpostConfigList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSourceStageList:
-        """Create an instance of PaginatedSourceStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedLDAPOutpostConfigList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSourceStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSourceStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SourceStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [LDAPOutpostConfig.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_stage_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.stage import Stage
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedStageList(BaseModel):
     """
     PaginatedStageList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(Stage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Stage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedStageList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedStageList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Stage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Stage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_static_device_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_totp_device_list.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.static_device import StaticDevice
+from authentik_client.models.totp_device import TOTPDevice
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedStaticDeviceList(BaseModel):
-    """
-    PaginatedStaticDeviceList
+class PaginatedTOTPDeviceList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(StaticDevice) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedTOTPDeviceList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[TOTPDevice]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedStaticDeviceList:
-        """Create an instance of PaginatedStaticDeviceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedTOTPDeviceList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedStaticDeviceList:
-        """Create an instance of PaginatedStaticDeviceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedTOTPDeviceList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedStaticDeviceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedStaticDeviceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [StaticDevice.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [TOTPDevice.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_system_task_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_role_assigned_object_permission_list.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.system_task import SystemTask
+from authentik_client.models.role_assigned_object_permission import RoleAssignedObjectPermission
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedSystemTaskList(BaseModel):
-    """
-    PaginatedSystemTaskList
+class PaginatedRoleAssignedObjectPermissionList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(SystemTask) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedRoleAssignedObjectPermissionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[RoleAssignedObjectPermission]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedSystemTaskList:
-        """Create an instance of PaginatedSystemTaskList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedRoleAssignedObjectPermissionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedSystemTaskList:
-        """Create an instance of PaginatedSystemTaskList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedRoleAssignedObjectPermissionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedSystemTaskList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedSystemTaskList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [SystemTask.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [RoleAssignedObjectPermission.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_tenant_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_recovery_key_request_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.tenant import Tenant
-
-class PaginatedTenantList(BaseModel):
-    """
-    PaginatedTenantList
+class TenantRecoveryKeyRequestRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Tenant) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Tenant recovery key creation request serializer
+    """ # noqa: E501
+    user: Annotated[str, Field(min_length=1, strict=True)]
+    duration_days: StrictInt
+    __properties: ClassVar[List[str]] = ["user", "duration_days"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedTenantList:
-        """Create an instance of PaginatedTenantList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TenantRecoveryKeyRequestRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedTenantList:
-        """Create an instance of PaginatedTenantList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TenantRecoveryKeyRequestRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedTenantList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedTenantList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Tenant.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "user": obj.get("user"),
+            "duration_days": obj.get("duration_days")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_token_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/license_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.token import Token
-
-class PaginatedTokenList(BaseModel):
-    """
-    PaginatedTokenList
+class LicenseRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(Token) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    License Serializer
+    """ # noqa: E501
+    key: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["key"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedTokenList:
-        """Create an instance of PaginatedTokenList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LicenseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedTokenList:
-        """Create an instance of PaginatedTokenList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LicenseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedTokenList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedTokenList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [Token.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "key": obj.get("key")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_token_model_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_notification_list.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.notification import Notification
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.token_model import TokenModel
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedTokenModelList(BaseModel):
-    """
-    PaginatedTokenModelList
+class PaginatedNotificationList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(TokenModel) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedNotificationList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Notification]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedTokenModelList:
-        """Create an instance of PaginatedTokenModelList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedNotificationList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedTokenModelList:
-        """Create an instance of PaginatedTokenModelList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedNotificationList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedTokenModelList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedTokenModelList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [TokenModel.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Notification.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_totp_device_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_event_list.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.event import Event
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.totp_device import TOTPDevice
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedTOTPDeviceList(BaseModel):
-    """
-    PaginatedTOTPDeviceList
+class PaginatedEventList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(TOTPDevice) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedEventList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Event]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedTOTPDeviceList:
-        """Create an instance of PaginatedTOTPDeviceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedEventList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedTOTPDeviceList:
-        """Create an instance of PaginatedTOTPDeviceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedEventList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedTOTPDeviceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedTOTPDeviceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [TOTPDevice.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Event.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_assigned_object_permission_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_system_task_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_assigned_object_permission import UserAssignedObjectPermission
+from authentik_client.models.system_task import SystemTask
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserAssignedObjectPermissionList(BaseModel):
-    """
-    PaginatedUserAssignedObjectPermissionList
+class PaginatedSystemTaskList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserAssignedObjectPermission) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedSystemTaskList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[SystemTask]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserAssignedObjectPermissionList:
-        """Create an instance of PaginatedUserAssignedObjectPermissionList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedSystemTaskList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserAssignedObjectPermissionList:
-        """Create an instance of PaginatedUserAssignedObjectPermissionList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedSystemTaskList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserAssignedObjectPermissionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserAssignedObjectPermissionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserAssignedObjectPermission.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [SystemTask.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_consent_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_reputation_list.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_consent import UserConsent
+from authentik_client.models.reputation import Reputation
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserConsentList(BaseModel):
-    """
-    PaginatedUserConsentList
+class PaginatedReputationList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserConsent) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedReputationList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Reputation]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserConsentList:
-        """Create an instance of PaginatedUserConsentList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedReputationList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserConsentList:
-        """Create an instance of PaginatedUserConsentList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedReputationList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserConsentList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserConsentList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserConsent.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Reputation.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_delete_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_consent_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_delete_stage import UserDeleteStage
+from authentik_client.models.user_consent import UserConsent
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserDeleteStageList(BaseModel):
-    """
-    PaginatedUserDeleteStageList
+class PaginatedUserConsentList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserDeleteStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserConsentList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserConsent]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserDeleteStageList:
-        """Create an instance of PaginatedUserDeleteStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserConsentList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserDeleteStageList:
-        """Create an instance of PaginatedUserDeleteStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserConsentList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserDeleteStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserDeleteStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserDeleteStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserConsent.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_brand_list.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.brand import Brand
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user import User
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserList(BaseModel):
-    """
-    PaginatedUserList
+class PaginatedBrandList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(User) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedBrandList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Brand]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserList:
-        """Create an instance of PaginatedUserList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedBrandList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserList:
-        """Create an instance of PaginatedUserList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedBrandList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [User.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Brand.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_login_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_token_model_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_login_stage import UserLoginStage
+from authentik_client.models.token_model import TokenModel
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserLoginStageList(BaseModel):
-    """
-    PaginatedUserLoginStageList
+class PaginatedTokenModelList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserLoginStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedTokenModelList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[TokenModel]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserLoginStageList:
-        """Create an instance of PaginatedUserLoginStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedTokenModelList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserLoginStageList:
-        """Create an instance of PaginatedUserLoginStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedTokenModelList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserLoginStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserLoginStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserLoginStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [TokenModel.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_logout_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/used_by.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.used_by_action_enum import UsedByActionEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_logout_stage import UserLogoutStage
-
-class PaginatedUserLogoutStageList(BaseModel):
-    """
-    PaginatedUserLogoutStageList
+class UsedBy(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserLogoutStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    A list of all objects referencing the queried object
+    """ # noqa: E501
+    app: StrictStr
+    model_name: StrictStr
+    pk: StrictStr
+    name: StrictStr
+    action: UsedByActionEnum
+    __properties: ClassVar[List[str]] = ["app", "model_name", "pk", "name", "action"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserLogoutStageList:
-        """Create an instance of PaginatedUserLogoutStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UsedBy from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
-        _items = []
-        if self.results:
-            for _item in self.results:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['results'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserLogoutStageList:
-        """Create an instance of PaginatedUserLogoutStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UsedBy from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserLogoutStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserLogoutStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserLogoutStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "app": obj.get("app"),
+            "model_name": obj.get("model_name"),
+            "pk": obj.get("pk"),
+            "name": obj.get("name"),
+            "action": obj.get("action")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_o_auth_source_connection_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_o_auth_source_connection_list.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
 from authentik_client.models.user_o_auth_source_connection import UserOAuthSourceConnection
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PaginatedUserOAuthSourceConnectionList(BaseModel):
     """
     PaginatedUserOAuthSourceConnectionList
-    """
-    pagination: Pagination = Field(...)
-    results: conlist(UserOAuthSourceConnection) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserOAuthSourceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserOAuthSourceConnectionList:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PaginatedUserOAuthSourceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserOAuthSourceConnectionList:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PaginatedUserOAuthSourceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserOAuthSourceConnectionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserOAuthSourceConnectionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserOAuthSourceConnection.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserOAuthSourceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_saml_source_connection_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_source_connection_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_saml_source_connection import UserSAMLSourceConnection
+from authentik_client.models.user_source_connection import UserSourceConnection
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserSAMLSourceConnectionList(BaseModel):
-    """
-    PaginatedUserSAMLSourceConnectionList
+class PaginatedUserSourceConnectionList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserSAMLSourceConnection) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserSourceConnectionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserSourceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserSAMLSourceConnectionList:
-        """Create an instance of PaginatedUserSAMLSourceConnectionList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserSourceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserSAMLSourceConnectionList:
-        """Create an instance of PaginatedUserSAMLSourceConnectionList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserSourceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserSAMLSourceConnectionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserSAMLSourceConnectionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserSAMLSourceConnection.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserSourceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_source_connection_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_logout_stage_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,73 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_source_connection import UserSourceConnection
-
-class PaginatedUserSourceConnectionList(BaseModel):
-    """
-    PaginatedUserSourceConnectionList
+class UserLogoutStageRequest(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserSourceConnection) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserLogoutStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserSourceConnectionList:
-        """Create an instance of PaginatedUserSourceConnectionList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserLogoutStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
-        if self.results:
-            for _item in self.results:
+        if self.flow_set:
+            for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['results'] = _items
+            _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserSourceConnectionList:
-        """Create an instance of PaginatedUserSourceConnectionList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserLogoutStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserSourceConnectionList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserSourceConnectionList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserSourceConnection.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_user_write_stage_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_outpost_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.outpost import Outpost
 from authentik_client.models.pagination import Pagination
-from authentik_client.models.user_write_stage import UserWriteStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PaginatedUserWriteStageList(BaseModel):
-    """
-    PaginatedUserWriteStageList
+class PaginatedOutpostList(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(UserWriteStage) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedOutpostList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Outpost]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedUserWriteStageList:
-        """Create an instance of PaginatedUserWriteStageList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedOutpostList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of pagination
         if self.pagination:
             _dict['pagination'] = self.pagination.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
         if self.results:
             for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedUserWriteStageList:
-        """Create an instance of PaginatedUserWriteStageList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedOutpostList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedUserWriteStageList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedUserWriteStageList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [UserWriteStage.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Outpost.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/paginated_web_authn_device_list.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_sync_status.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.system_task import SystemTask
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, conlist
-from authentik_client.models.pagination import Pagination
-from authentik_client.models.web_authn_device import WebAuthnDevice
-
-class PaginatedWebAuthnDeviceList(BaseModel):
-    """
-    PaginatedWebAuthnDeviceList
+class SCIMSyncStatus(BaseModel):
     """
-    pagination: Pagination = Field(...)
-    results: conlist(WebAuthnDevice) = Field(...)
-    __properties = ["pagination", "results"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SCIM Provider sync status
+    """ # noqa: E501
+    is_running: StrictBool
+    tasks: List[SystemTask]
+    __properties: ClassVar[List[str]] = ["is_running", "tasks"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PaginatedWebAuthnDeviceList:
-        """Create an instance of PaginatedWebAuthnDeviceList from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SCIMSyncStatus from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of pagination
-        if self.pagination:
-            _dict['pagination'] = self.pagination.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "is_running",
+            "tasks",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in tasks (list)
         _items = []
-        if self.results:
-            for _item in self.results:
+        if self.tasks:
+            for _item in self.tasks:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['results'] = _items
+            _dict['tasks'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PaginatedWebAuthnDeviceList:
-        """Create an instance of PaginatedWebAuthnDeviceList from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SCIMSyncStatus from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PaginatedWebAuthnDeviceList.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PaginatedWebAuthnDeviceList.parse_obj({
-            "pagination": Pagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
-            "results": [WebAuthnDevice.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None
+        _obj = cls.model_validate({
+            "is_running": obj.get("is_running"),
+            "tasks": [SystemTask.from_dict(_item) for _item in obj["tasks"]] if obj.get("tasks") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/pagination.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_instance_request.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,71 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt
-
-class Pagination(BaseModel):
-    """
-    Pagination
+class BlueprintInstanceRequest(BaseModel):
     """
-    next: Union[StrictFloat, StrictInt] = Field(...)
-    previous: Union[StrictFloat, StrictInt] = Field(...)
-    count: Union[StrictFloat, StrictInt] = Field(...)
-    current: Union[StrictFloat, StrictInt] = Field(...)
-    total_pages: Union[StrictFloat, StrictInt] = Field(...)
-    start_index: Union[StrictFloat, StrictInt] = Field(...)
-    end_index: Union[StrictFloat, StrictInt] = Field(...)
-    __properties = ["next", "previous", "count", "current", "total_pages", "start_index", "end_index"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Info about a single blueprint instance file
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    path: Optional[StrictStr] = ''
+    context: Optional[Any] = None
+    enabled: Optional[StrictBool] = None
+    content: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "path", "context", "enabled", "content"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Pagination:
-        """Create an instance of Pagination from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of BlueprintInstanceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if context (nullable) is None
+        # and model_fields_set contains the field
+        if self.context is None and "context" in self.model_fields_set:
+            _dict['context'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Pagination:
-        """Create an instance of Pagination from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of BlueprintInstanceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Pagination.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Pagination.parse_obj({
-            "next": obj.get("next"),
-            "previous": obj.get("previous"),
-            "count": obj.get("count"),
-            "current": obj.get("current"),
-            "total_pages": obj.get("total_pages"),
-            "start_index": obj.get("start_index"),
-            "end_index": obj.get("end_index")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "path": obj.get("path") if obj.get("path") is not None else '',
+            "context": obj.get("context"),
+            "enabled": obj.get("enabled"),
+            "content": obj.get("content")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/password_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/autosubmit_challenge.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,93 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PasswordChallenge(BaseModel):
-    """
-    Password challenge UI fields  # noqa: E501
+class AutosubmitChallenge(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
+    Autosubmit challenge used to send and navigate a POST request
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-password'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    recovery_url: Optional[StrictStr] = None
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar", "recovery_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    component: Optional[StrictStr] = 'ak-stage-autosubmit'
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    url: StrictStr
+    attrs: Dict[str, StrictStr]
+    title: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "url", "attrs", "title"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PasswordChallenge:
-        """Create an instance of PasswordChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AutosubmitChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PasswordChallenge:
-        """Create an instance of PasswordChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AutosubmitChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PasswordChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PasswordChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-password',
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-autosubmit',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
-            "pending_user": obj.get("pending_user"),
-            "pending_user_avatar": obj.get("pending_user_avatar"),
-            "recovery_url": obj.get("recovery_url")
+            "url": obj.get("url"),
+            "attrs": obj.get("attrs"),
+            "title": obj.get("title")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/password_expiry_policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/permission.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,83 +14,98 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
-
-class PasswordExpiryPolicy(BaseModel):
-    """
-    Password Expiry Policy Serializer  # noqa: E501
+class Permission(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    days: conint(strict=True, le=2147483647, ge=-2147483648) = Field(...)
-    deny_only: Optional[StrictBool] = None
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "days", "deny_only"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Global permission
+    """ # noqa: E501
+    id: StrictInt
+    name: Annotated[str, Field(strict=True, max_length=255)]
+    codename: Annotated[str, Field(strict=True, max_length=100)]
+    model: StrictStr
+    app_label: StrictStr
+    app_label_verbose: StrictStr = Field(description="Human-readable app label")
+    model_verbose: StrictStr = Field(description="Human-readable model name")
+    __properties: ClassVar[List[str]] = ["id", "name", "codename", "model", "app_label", "app_label_verbose", "model_verbose"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PasswordExpiryPolicy:
-        """Create an instance of PasswordExpiryPolicy from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Permission from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "id",
+            "model",
+            "app_label",
+            "app_label_verbose",
+            "model_verbose",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PasswordExpiryPolicy:
-        """Create an instance of PasswordExpiryPolicy from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Permission from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PasswordExpiryPolicy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PasswordExpiryPolicy.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
             "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "bound_to": obj.get("bound_to"),
-            "days": obj.get("days"),
-            "deny_only": obj.get("deny_only")
+            "codename": obj.get("codename"),
+            "model": obj.get("model"),
+            "app_label": obj.get("app_label"),
+            "app_label_verbose": obj.get("app_label_verbose"),
+            "model_verbose": obj.get("model_verbose")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/password_policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/password_policy.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,87 +14,110 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PasswordPolicy(BaseModel):
     """
-    Password Policy Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    password_field: Optional[StrictStr] = Field(None, description="Field key to check, field keys defined in Prompt stages are available.")
-    amount_digits: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_uppercase: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_lowercase: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_symbols: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    length_min: Optional[conint(strict=True, le=2147483647, ge=0)] = None
+    Password Policy Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    bound_to: StrictInt = Field(description="Return objects policy is bound to")
+    password_field: Optional[StrictStr] = Field(default=None, description="Field key to check, field keys defined in Prompt stages are available.")
+    amount_digits: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    amount_uppercase: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    amount_lowercase: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    amount_symbols: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    length_min: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
     symbol_charset: Optional[StrictStr] = None
     error_message: Optional[StrictStr] = None
     check_static_rules: Optional[StrictBool] = None
     check_have_i_been_pwned: Optional[StrictBool] = None
     check_zxcvbn: Optional[StrictBool] = None
-    hibp_allowed_count: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="How many times the password hash is allowed to be on haveibeenpwned")
-    zxcvbn_score_threshold: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="If the zxcvbn score is equal or less than this value, the policy will fail.")
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "password_field", "amount_digits", "amount_uppercase", "amount_lowercase", "amount_symbols", "length_min", "symbol_charset", "error_message", "check_static_rules", "check_have_i_been_pwned", "check_zxcvbn", "hibp_allowed_count", "zxcvbn_score_threshold"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    hibp_allowed_count: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = Field(default=None, description="How many times the password hash is allowed to be on haveibeenpwned")
+    zxcvbn_score_threshold: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = Field(default=None, description="If the zxcvbn score is equal or less than this value, the policy will fail.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "password_field", "amount_digits", "amount_uppercase", "amount_lowercase", "amount_symbols", "length_min", "symbol_charset", "error_message", "check_static_rules", "check_have_i_been_pwned", "check_zxcvbn", "hibp_allowed_count", "zxcvbn_score_threshold"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PasswordPolicy:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PasswordPolicy from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "bound_to",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PasswordPolicy:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PasswordPolicy from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PasswordPolicy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PasswordPolicy.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "execution_logging": obj.get("execution_logging"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/password_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/event_matcher_policy_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,87 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.app_enum import AppEnum
+from authentik_client.models.event_actions import EventActions
+from authentik_client.models.model_enum import ModelEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, constr
-
-class PasswordPolicyRequest(BaseModel):
-    """
-    Password Policy Serializer  # noqa: E501
+class EventMatcherPolicyRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    password_field: Optional[constr(strict=True, min_length=1)] = Field(None, description="Field key to check, field keys defined in Prompt stages are available.")
-    amount_digits: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_uppercase: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_lowercase: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_symbols: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    length_min: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    symbol_charset: Optional[constr(strict=True, min_length=1)] = None
-    error_message: Optional[StrictStr] = None
-    check_static_rules: Optional[StrictBool] = None
-    check_have_i_been_pwned: Optional[StrictBool] = None
-    check_zxcvbn: Optional[StrictBool] = None
-    hibp_allowed_count: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="How many times the password hash is allowed to be on haveibeenpwned")
-    zxcvbn_score_threshold: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="If the zxcvbn score is equal or less than this value, the policy will fail.")
-    __properties = ["name", "execution_logging", "password_field", "amount_digits", "amount_uppercase", "amount_lowercase", "amount_symbols", "length_min", "symbol_charset", "error_message", "check_static_rules", "check_have_i_been_pwned", "check_zxcvbn", "hibp_allowed_count", "zxcvbn_score_threshold"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Event Matcher Policy Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    action: Optional[EventActions] = Field(default=None, description="Match created events with this action type. When left empty, all action types will be matched.")
+    client_ip: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Matches Event's Client IP (strict matching, for network matching use an Expression Policy)")
+    app: Optional[AppEnum] = Field(default=None, description="Match events created by selected application. When left empty, all applications are matched.")
+    model: Optional[ModelEnum] = Field(default=None, description="Match events created by selected model. When left empty, all models are matched. When an app is selected, all the application's models are matched.")
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "action", "client_ip", "app", "model"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PasswordPolicyRequest:
-        """Create an instance of PasswordPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of EventMatcherPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if action (nullable) is None
+        # and model_fields_set contains the field
+        if self.action is None and "action" in self.model_fields_set:
+            _dict['action'] = None
+
+        # set to None if client_ip (nullable) is None
+        # and model_fields_set contains the field
+        if self.client_ip is None and "client_ip" in self.model_fields_set:
+            _dict['client_ip'] = None
+
+        # set to None if app (nullable) is None
+        # and model_fields_set contains the field
+        if self.app is None and "app" in self.model_fields_set:
+            _dict['app'] = None
+
+        # set to None if model (nullable) is None
+        # and model_fields_set contains the field
+        if self.model is None and "model" in self.model_fields_set:
+            _dict['model'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PasswordPolicyRequest:
-        """Create an instance of PasswordPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of EventMatcherPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PasswordPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PasswordPolicyRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "execution_logging": obj.get("execution_logging"),
-            "password_field": obj.get("password_field"),
-            "amount_digits": obj.get("amount_digits"),
-            "amount_uppercase": obj.get("amount_uppercase"),
-            "amount_lowercase": obj.get("amount_lowercase"),
-            "amount_symbols": obj.get("amount_symbols"),
-            "length_min": obj.get("length_min"),
-            "symbol_charset": obj.get("symbol_charset"),
-            "error_message": obj.get("error_message"),
-            "check_static_rules": obj.get("check_static_rules"),
-            "check_have_i_been_pwned": obj.get("check_have_i_been_pwned"),
-            "check_zxcvbn": obj.get("check_zxcvbn"),
-            "hibp_allowed_count": obj.get("hibp_allowed_count"),
-            "zxcvbn_score_threshold": obj.get("zxcvbn_score_threshold")
+            "action": obj.get("action"),
+            "client_ip": obj.get("client_ip"),
+            "app": obj.get("app"),
+            "model": obj.get("model")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/password_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/invitation_stage.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,96 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist
-from authentik_client.models.backends_enum import BackendsEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PasswordStage(BaseModel):
-    """
-    PasswordStage Serializer  # noqa: E501
+class InvitationStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    backends: conlist(BackendsEnum) = Field(..., description="Selection of backends to test the password against.")
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    failed_attempts_before_cancel: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "backends", "configure_flow", "failed_attempts_before_cancel"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    InvitationStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    continue_flow_without_invitation: Optional[StrictBool] = Field(default=None, description="If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "continue_flow_without_invitation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PasswordStage:
-        """Create an instance of PasswordStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of InvitationStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PasswordStage:
-        """Create an instance of PasswordStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of InvitationStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PasswordStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PasswordStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "backends": obj.get("backends"),
-            "configure_flow": obj.get("configure_flow"),
-            "failed_attempts_before_cancel": obj.get("failed_attempts_before_cancel")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "continue_flow_without_invitation": obj.get("continue_flow_without_invitation")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/password_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_source_stage_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,81 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
-from authentik_client.models.backends_enum import BackendsEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PasswordStageRequest(BaseModel):
-    """
-    PasswordStage Serializer  # noqa: E501
+class PatchedSourceStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    backends: conlist(BackendsEnum) = Field(..., description="Selection of backends to test the password against.")
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    failed_attempts_before_cancel: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.")
-    __properties = ["name", "flow_set", "backends", "configure_flow", "failed_attempts_before_cancel"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SourceStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    source: Optional[StrictStr] = None
+    resume_timeout: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "source", "resume_timeout"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PasswordStageRequest:
-        """Create an instance of PasswordStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSourceStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PasswordStageRequest:
-        """Create an instance of PasswordStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSourceStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PasswordStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PasswordStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "backends": obj.get("backends"),
-            "configure_flow": obj.get("configure_flow"),
-            "failed_attempts_before_cancel": obj.get("failed_attempts_before_cancel")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "source": obj.get("source"),
+            "resume_timeout": obj.get("resume_timeout")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_application_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/application_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,86 +14,100 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedApplicationRequest(BaseModel):
-    """
-    Application Serializer  # noqa: E501
+class ApplicationRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = Field(None, description="Application's display Name.")
-    slug: Optional[constr(strict=True, max_length=50, min_length=1)] = Field(None, description="Internal application name, used in URLs.")
+    Application Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Application's display Name.")
+    slug: Annotated[str, Field(min_length=1, strict=True, max_length=50)] = Field(description="Internal application name, used in URLs.")
     provider: Optional[StrictInt] = None
-    backchannel_providers: Optional[conlist(StrictInt)] = None
-    open_in_new_tab: Optional[StrictBool] = Field(None, description="Open launch URL in a new browser tab or window.")
+    backchannel_providers: Optional[List[StrictInt]] = None
+    open_in_new_tab: Optional[StrictBool] = Field(default=None, description="Open launch URL in a new browser tab or window.")
     meta_launch_url: Optional[StrictStr] = None
     meta_description: Optional[StrictStr] = None
     meta_publisher: Optional[StrictStr] = None
     policy_engine_mode: Optional[PolicyEngineMode] = None
     group: Optional[StrictStr] = None
-    __properties = ["name", "slug", "provider", "backchannel_providers", "open_in_new_tab", "meta_launch_url", "meta_description", "meta_publisher", "policy_engine_mode", "group"]
+    __properties: ClassVar[List[str]] = ["name", "slug", "provider", "backchannel_providers", "open_in_new_tab", "meta_launch_url", "meta_description", "meta_publisher", "policy_engine_mode", "group"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
-        if value is None:
-            return value
-
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedApplicationRequest:
-        """Create an instance of PatchedApplicationRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ApplicationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if provider (nullable) is None
-        # and __fields_set__ contains the field
-        if self.provider is None and "provider" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.provider is None and "provider" in self.model_fields_set:
             _dict['provider'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedApplicationRequest:
-        """Create an instance of PatchedApplicationRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ApplicationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedApplicationRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedApplicationRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "provider": obj.get("provider"),
             "backchannel_providers": obj.get("backchannel_providers"),
             "open_in_new_tab": obj.get("open_in_new_tab"),
             "meta_launch_url": obj.get("meta_launch_url"),
             "meta_description": obj.get("meta_description"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticate_web_authn_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_static_stage_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,97 +14,104 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.authenticator_attachment_enum import AuthenticatorAttachmentEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
-from authentik_client.models.resident_key_requirement_enum import ResidentKeyRequirementEnum
-from authentik_client.models.user_verification_enum import UserVerificationEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedAuthenticateWebAuthnStageRequest(BaseModel):
-    """
-    AuthenticateWebAuthnStage Serializer  # noqa: E501
+class AuthenticatorStaticStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    user_verification: Optional[UserVerificationEnum] = None
-    authenticator_attachment: Optional[AuthenticatorAttachmentEnum] = None
-    resident_key_requirement: Optional[ResidentKeyRequirementEnum] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "user_verification", "authenticator_attachment", "resident_key_requirement"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorStaticStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    token_count: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    token_length: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "token_count", "token_length"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedAuthenticateWebAuthnStageRequest:
-        """Create an instance of PatchedAuthenticateWebAuthnStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorStaticStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
-        # set to None if authenticator_attachment (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authenticator_attachment is None and "authenticator_attachment" in self.__fields_set__:
-            _dict['authenticator_attachment'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedAuthenticateWebAuthnStageRequest:
-        """Create an instance of PatchedAuthenticateWebAuthnStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorStaticStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedAuthenticateWebAuthnStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedAuthenticateWebAuthnStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
-            "user_verification": obj.get("user_verification"),
-            "authenticator_attachment": obj.get("authenticator_attachment"),
-            "resident_key_requirement": obj.get("resident_key_requirement")
+            "token_count": obj.get("token_count"),
+            "token_length": obj.get("token_length")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_duo_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_password_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,93 +14,98 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.backends_enum import BackendsEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedAuthenticatorDuoStageRequest(BaseModel):
-    """
-    AuthenticatorDuoStage Serializer  # noqa: E501
+class PatchedPasswordStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    client_id: Optional[constr(strict=True, min_length=1)] = None
-    client_secret: Optional[constr(strict=True, min_length=1)] = None
-    api_hostname: Optional[constr(strict=True, min_length=1)] = None
-    admin_integration_key: Optional[StrictStr] = None
-    admin_secret_key: Optional[StrictStr] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "client_id", "client_secret", "api_hostname", "admin_integration_key", "admin_secret_key"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PasswordStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    backends: Optional[List[BackendsEnum]] = Field(default=None, description="Selection of backends to test the password against.")
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    failed_attempts_before_cancel: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = Field(default=None, description="How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "backends", "configure_flow", "failed_attempts_before_cancel"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedAuthenticatorDuoStageRequest:
-        """Create an instance of PatchedAuthenticatorDuoStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPasswordStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedAuthenticatorDuoStageRequest:
-        """Create an instance of PatchedAuthenticatorDuoStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPasswordStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedAuthenticatorDuoStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedAuthenticatorDuoStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "backends": obj.get("backends"),
             "configure_flow": obj.get("configure_flow"),
-            "friendly_name": obj.get("friendly_name"),
-            "client_id": obj.get("client_id"),
-            "client_secret": obj.get("client_secret"),
-            "api_hostname": obj.get("api_hostname"),
-            "admin_integration_key": obj.get("admin_integration_key"),
-            "admin_secret_key": obj.get("admin_secret_key")
+            "failed_attempts_before_cancel": obj.get("failed_attempts_before_cancel")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_sms_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_provider_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,106 +14,98 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from authentik_client.models.auth_type_enum import AuthTypeEnum
-from authentik_client.models.flow_set_request import FlowSetRequest
-from authentik_client.models.provider_enum import ProviderEnum
-
-class PatchedAuthenticatorSMSStageRequest(BaseModel):
-    """
-    AuthenticatorSMSStage Serializer  # noqa: E501
+class RACProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    provider: Optional[ProviderEnum] = None
-    from_number: Optional[constr(strict=True, min_length=1)] = None
-    account_sid: Optional[constr(strict=True, min_length=1)] = None
-    auth: Optional[constr(strict=True, min_length=1)] = None
-    auth_password: Optional[StrictStr] = None
-    auth_type: Optional[AuthTypeEnum] = None
-    verify_only: Optional[StrictBool] = Field(None, description="When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.")
-    mapping: Optional[StrictStr] = Field(None, description="Optionally modify the payload being sent to custom providers.")
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "provider", "from_number", "account_sid", "auth", "auth_password", "auth_type", "verify_only", "mapping"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RACProvider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    settings: Optional[Any] = None
+    connection_expiry: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)")
+    delete_token_on_disconnect: Optional[StrictBool] = Field(default=None, description="When set to true, connection tokens will be deleted upon disconnect.")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "settings", "connection_expiry", "delete_token_on_disconnect"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedAuthenticatorSMSStageRequest:
-        """Create an instance of PatchedAuthenticatorSMSStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RACProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
-
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
-
-        # set to None if mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.mapping is None and "mapping" in self.__fields_set__:
-            _dict['mapping'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
+
+        # set to None if settings (nullable) is None
+        # and model_fields_set contains the field
+        if self.settings is None and "settings" in self.model_fields_set:
+            _dict['settings'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedAuthenticatorSMSStageRequest:
-        """Create an instance of PatchedAuthenticatorSMSStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RACProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedAuthenticatorSMSStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedAuthenticatorSMSStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "configure_flow": obj.get("configure_flow"),
-            "friendly_name": obj.get("friendly_name"),
-            "provider": obj.get("provider"),
-            "from_number": obj.get("from_number"),
-            "account_sid": obj.get("account_sid"),
-            "auth": obj.get("auth"),
-            "auth_password": obj.get("auth_password"),
-            "auth_type": obj.get("auth_type"),
-            "verify_only": obj.get("verify_only"),
-            "mapping": obj.get("mapping")
+            "authentication_flow": obj.get("authentication_flow"),
+            "authorization_flow": obj.get("authorization_flow"),
+            "property_mappings": obj.get("property_mappings"),
+            "settings": obj.get("settings"),
+            "connection_expiry": obj.get("connection_expiry"),
+            "delete_token_on_disconnect": obj.get("delete_token_on_disconnect")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_static_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_static_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,86 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedAuthenticatorStaticStageRequest(BaseModel):
     """
-    AuthenticatorStaticStage Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    token_count: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    token_length: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "token_count", "token_length"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorStaticStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    token_count: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    token_length: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "token_count", "token_length"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedAuthenticatorStaticStageRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedAuthenticatorStaticStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
             _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedAuthenticatorStaticStageRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedAuthenticatorStaticStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedAuthenticatorStaticStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedAuthenticatorStaticStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "configure_flow": obj.get("configure_flow"),
             "friendly_name": obj.get("friendly_name"),
             "token_count": obj.get("token_count"),
             "token_length": obj.get("token_length")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_totp_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_prompt_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,86 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.digits_enum import DigitsEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedAuthenticatorTOTPStageRequest(BaseModel):
-    """
-    AuthenticatorTOTPStage Serializer  # noqa: E501
+class PatchedPromptStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    friendly_name: Optional[constr(strict=True, min_length=1)] = None
-    digits: Optional[DigitsEnum] = None
-    __properties = ["name", "flow_set", "configure_flow", "friendly_name", "digits"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PromptStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    fields: Optional[List[StrictStr]] = None
+    validation_policies: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "fields", "validation_policies"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedAuthenticatorTOTPStageRequest:
-        """Create an instance of PatchedAuthenticatorTOTPStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPromptStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
-        # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
-            _dict['configure_flow'] = None
-
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedAuthenticatorTOTPStageRequest:
-        """Create an instance of PatchedAuthenticatorTOTPStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPromptStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedAuthenticatorTOTPStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedAuthenticatorTOTPStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "configure_flow": obj.get("configure_flow"),
-            "friendly_name": obj.get("friendly_name"),
-            "digits": obj.get("digits")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "fields": obj.get("fields"),
+            "validation_policies": obj.get("validation_policies")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_authenticator_validate_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_authenticator_validate_stage_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,80 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.device_classes_enum import DeviceClassesEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
 from authentik_client.models.not_configured_action_enum import NotConfiguredActionEnum
 from authentik_client.models.user_verification_enum import UserVerificationEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedAuthenticatorValidateStageRequest(BaseModel):
     """
-    AuthenticatorValidateStage Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
+    AuthenticatorValidateStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
     not_configured_action: Optional[NotConfiguredActionEnum] = None
-    device_classes: Optional[conlist(DeviceClassesEnum)] = Field(None, description="Device classes which can be used to authenticate")
-    configuration_stages: Optional[conlist(StrictStr)] = Field(None, description="Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.")
-    last_auth_threshold: Optional[constr(strict=True, min_length=1)] = Field(None, description="If any of the user's device has been used within this threshold, this stage will be skipped")
-    webauthn_user_verification: Optional[UserVerificationEnum] = Field(None, description="Enforce user verification for WebAuthn devices.")
-    __properties = ["name", "flow_set", "not_configured_action", "device_classes", "configuration_stages", "last_auth_threshold", "webauthn_user_verification"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    device_classes: Optional[List[DeviceClassesEnum]] = Field(default=None, description="Device classes which can be used to authenticate")
+    configuration_stages: Optional[List[StrictStr]] = Field(default=None, description="Stages used to configure Authenticator when user doesn't have any compatible devices. After this configuration Stage passes, the user is not prompted again.")
+    last_auth_threshold: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="If any of the user's device has been used within this threshold, this stage will be skipped")
+    webauthn_user_verification: Optional[UserVerificationEnum] = Field(default=None, description="Enforce user verification for WebAuthn devices.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "not_configured_action", "device_classes", "configuration_stages", "last_auth_threshold", "webauthn_user_verification"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedAuthenticatorValidateStageRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedAuthenticatorValidateStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedAuthenticatorValidateStageRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedAuthenticatorValidateStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedAuthenticatorValidateStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedAuthenticatorValidateStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "not_configured_action": obj.get("not_configured_action"),
             "device_classes": obj.get("device_classes"),
             "configuration_stages": obj.get("configuration_stages"),
             "last_auth_threshold": obj.get("last_auth_threshold"),
             "webauthn_user_verification": obj.get("webauthn_user_verification")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_blueprint_instance_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_web_authn_device_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,72 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Optional
-from pydantic import BaseModel, StrictBool, StrictStr, constr
-
-class PatchedBlueprintInstanceRequest(BaseModel):
-    """
-    Info about a single blueprint instance file  # noqa: E501
+class PatchedWebAuthnDeviceRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    path: Optional[StrictStr] = ''
-    context: Optional[Any] = None
-    enabled: Optional[StrictBool] = None
-    content: Optional[StrictStr] = None
-    __properties = ["name", "path", "context", "enabled", "content"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for WebAuthn authenticator devices
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = None
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedBlueprintInstanceRequest:
-        """Create an instance of PatchedBlueprintInstanceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedWebAuthnDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if context (nullable) is None
-        # and __fields_set__ contains the field
-        if self.context is None and "context" in self.__fields_set__:
-            _dict['context'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedBlueprintInstanceRequest:
-        """Create an instance of PatchedBlueprintInstanceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedWebAuthnDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedBlueprintInstanceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedBlueprintInstanceRequest.parse_obj({
-            "name": obj.get("name"),
-            "path": obj.get("path") if obj.get("path") is not None else '',
-            "context": obj.get("context"),
-            "enabled": obj.get("enabled"),
-            "content": obj.get("content")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_brand_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_brand_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,113 +14,130 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedBrandRequest(BaseModel):
     """
-    Brand Serializer  # noqa: E501
-    """
-    domain: Optional[constr(strict=True, min_length=1)] = Field(None, description="Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`")
+    Brand Serializer
+    """ # noqa: E501
+    domain: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`")
     default: Optional[StrictBool] = None
-    branding_title: Optional[constr(strict=True, min_length=1)] = None
-    branding_logo: Optional[constr(strict=True, min_length=1)] = None
-    branding_favicon: Optional[constr(strict=True, min_length=1)] = None
+    branding_title: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    branding_logo: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    branding_favicon: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     flow_authentication: Optional[StrictStr] = None
     flow_invalidation: Optional[StrictStr] = None
     flow_recovery: Optional[StrictStr] = None
     flow_unenrollment: Optional[StrictStr] = None
     flow_user_settings: Optional[StrictStr] = None
     flow_device_code: Optional[StrictStr] = None
-    web_certificate: Optional[StrictStr] = Field(None, description="Web Certificate used by the authentik Core webserver.")
+    web_certificate: Optional[StrictStr] = Field(default=None, description="Web Certificate used by the authentik Core webserver.")
     attributes: Optional[Any] = None
-    __properties = ["domain", "default", "branding_title", "branding_logo", "branding_favicon", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "web_certificate", "attributes"]
+    __properties: ClassVar[List[str]] = ["domain", "default", "branding_title", "branding_logo", "branding_favicon", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "web_certificate", "attributes"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedBrandRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedBrandRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if flow_authentication (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_authentication is None and "flow_authentication" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_authentication is None and "flow_authentication" in self.model_fields_set:
             _dict['flow_authentication'] = None
 
         # set to None if flow_invalidation (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_invalidation is None and "flow_invalidation" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_invalidation is None and "flow_invalidation" in self.model_fields_set:
             _dict['flow_invalidation'] = None
 
         # set to None if flow_recovery (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_recovery is None and "flow_recovery" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_recovery is None and "flow_recovery" in self.model_fields_set:
             _dict['flow_recovery'] = None
 
         # set to None if flow_unenrollment (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_unenrollment is None and "flow_unenrollment" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_unenrollment is None and "flow_unenrollment" in self.model_fields_set:
             _dict['flow_unenrollment'] = None
 
         # set to None if flow_user_settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_user_settings is None and "flow_user_settings" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_user_settings is None and "flow_user_settings" in self.model_fields_set:
             _dict['flow_user_settings'] = None
 
         # set to None if flow_device_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow_device_code is None and "flow_device_code" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.flow_device_code is None and "flow_device_code" in self.model_fields_set:
             _dict['flow_device_code'] = None
 
         # set to None if web_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.web_certificate is None and "web_certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.web_certificate is None and "web_certificate" in self.model_fields_set:
             _dict['web_certificate'] = None
 
         # set to None if attributes (nullable) is None
-        # and __fields_set__ contains the field
-        if self.attributes is None and "attributes" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.attributes is None and "attributes" in self.model_fields_set:
             _dict['attributes'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedBrandRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedBrandRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedBrandRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedBrandRequest.parse_obj({
+        _obj = cls.model_validate({
             "domain": obj.get("domain"),
             "default": obj.get("default"),
             "branding_title": obj.get("branding_title"),
             "branding_logo": obj.get("branding_logo"),
             "branding_favicon": obj.get("branding_favicon"),
             "flow_authentication": obj.get("flow_authentication"),
             "flow_invalidation": obj.get("flow_invalidation"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_captcha_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_consent_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,77 +14,91 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.consent_stage_mode_enum import ConsentStageModeEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedCaptchaStageRequest(BaseModel):
-    """
-    CaptchaStage Serializer  # noqa: E501
+class PatchedConsentStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    public_key: Optional[constr(strict=True, min_length=1)] = Field(None, description="Public key, acquired your captcha Provider.")
-    private_key: Optional[constr(strict=True, min_length=1)] = Field(None, description="Private key, acquired your captcha Provider.")
-    js_url: Optional[constr(strict=True, min_length=1)] = None
-    api_url: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["name", "flow_set", "public_key", "private_key", "js_url", "api_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ConsentStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    mode: Optional[ConsentStageModeEnum] = None
+    consent_expire_in: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "mode", "consent_expire_in"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedCaptchaStageRequest:
-        """Create an instance of PatchedCaptchaStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedConsentStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedCaptchaStageRequest:
-        """Create an instance of PatchedCaptchaStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedConsentStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedCaptchaStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedCaptchaStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "public_key": obj.get("public_key"),
-            "private_key": obj.get("private_key"),
-            "js_url": obj.get("js_url"),
-            "api_url": obj.get("api_url")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "mode": obj.get("mode"),
+            "consent_expire_in": obj.get("consent_expire_in")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_certificate_key_pair_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_certificate_key_pair_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,63 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedCertificateKeyPairRequest(BaseModel):
     """
-    CertificateKeyPair Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    certificate_data: Optional[constr(strict=True, min_length=1)] = Field(None, description="PEM-encoded Certificate data")
-    key_data: Optional[StrictStr] = Field(None, description="Optional Private Key. If this is set, you can use this keypair for encryption.")
-    __properties = ["name", "certificate_data", "key_data"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CertificateKeyPair Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    certificate_data: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="PEM-encoded Certificate data")
+    key_data: Optional[StrictStr] = Field(default=None, description="Optional Private Key. If this is set, you can use this keypair for encryption.")
+    __properties: ClassVar[List[str]] = ["name", "certificate_data", "key_data"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedCertificateKeyPairRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedCertificateKeyPairRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedCertificateKeyPairRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedCertificateKeyPairRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedCertificateKeyPairRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedCertificateKeyPairRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "certificate_data": obj.get("certificate_data"),
             "key_data": obj.get("key_data")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_consent_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_delete_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,74 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from authentik_client.models.consent_stage_mode_enum import ConsentStageModeEnum
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedConsentStageRequest(BaseModel):
-    """
-    ConsentStage Serializer  # noqa: E501
+class PatchedUserDeleteStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    mode: Optional[ConsentStageModeEnum] = None
-    consent_expire_in: Optional[constr(strict=True, min_length=1)] = Field(None, description="Offset after which consent expires. (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["name", "flow_set", "mode", "consent_expire_in"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserDeleteStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedConsentStageRequest:
-        """Create an instance of PatchedConsentStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedUserDeleteStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedConsentStageRequest:
-        """Create an instance of PatchedConsentStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedUserDeleteStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedConsentStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedConsentStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "mode": obj.get("mode"),
-            "consent_expire_in": obj.get("consent_expire_in")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_deny_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/workers.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,71 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, StrictStr, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class PatchedDenyStageRequest(BaseModel):
-    """
-    DenyStage Serializer  # noqa: E501
+class Workers(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    deny_message: Optional[StrictStr] = None
-    __properties = ["name", "flow_set", "deny_message"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Workers
+    """ # noqa: E501
+    count: StrictInt
+    __properties: ClassVar[List[str]] = ["count"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedDenyStageRequest:
-        """Create an instance of PatchedDenyStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Workers from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedDenyStageRequest:
-        """Create an instance of PatchedDenyStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Workers from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedDenyStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedDenyStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "deny_message": obj.get("deny_message")
+        _obj = cls.model_validate({
+            "count": obj.get("count")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_docker_service_connection_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,77 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.notification_transport_mode_enum import NotificationTransportModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-
-class PatchedDockerServiceConnectionRequest(BaseModel):
-    """
-    DockerServiceConnection Serializer  # noqa: E501
+class NotificationTransportRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    url: Optional[constr(strict=True, min_length=1)] = Field(None, description="Can be in the format of 'unix://<path>' when connecting to a local docker daemon, or 'https://<hostname>:2376' when connecting to a remote system.")
-    tls_verification: Optional[StrictStr] = Field(None, description="CA which the endpoint's Certificate is verified against. Can be left empty for no validation.")
-    tls_authentication: Optional[StrictStr] = Field(None, description="Certificate/Key used for authentication. Can be left empty for no authentication.")
-    __properties = ["name", "local", "url", "tls_verification", "tls_authentication"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationTransport Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    mode: Optional[NotificationTransportModeEnum] = None
+    webhook_url: Optional[StrictStr] = None
+    webhook_mapping: Optional[StrictStr] = None
+    send_once: Optional[StrictBool] = Field(default=None, description="Only send notification once, for example when sending a webhook into a chat channel.")
+    __properties: ClassVar[List[str]] = ["name", "mode", "webhook_url", "webhook_mapping", "send_once"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedDockerServiceConnectionRequest:
-        """Create an instance of PatchedDockerServiceConnectionRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationTransportRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if tls_verification (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tls_verification is None and "tls_verification" in self.__fields_set__:
-            _dict['tls_verification'] = None
-
-        # set to None if tls_authentication (nullable) is None
-        # and __fields_set__ contains the field
-        if self.tls_authentication is None and "tls_authentication" in self.__fields_set__:
-            _dict['tls_authentication'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if webhook_mapping (nullable) is None
+        # and model_fields_set contains the field
+        if self.webhook_mapping is None and "webhook_mapping" in self.model_fields_set:
+            _dict['webhook_mapping'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedDockerServiceConnectionRequest:
-        """Create an instance of PatchedDockerServiceConnectionRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationTransportRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedDockerServiceConnectionRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedDockerServiceConnectionRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "local": obj.get("local"),
-            "url": obj.get("url"),
-            "tls_verification": obj.get("tls_verification"),
-            "tls_authentication": obj.get("tls_authentication")
+            "mode": obj.get("mode"),
+            "webhook_url": obj.get("webhook_url"),
+            "webhook_mapping": obj.get("webhook_mapping"),
+            "send_once": obj.get("send_once")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_domain_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_connection_token_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,63 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool, StrictStr, constr
-
-class PatchedDomainRequest(BaseModel):
-    """
-    Domain Serializer  # noqa: E501
+class PatchedConnectionTokenRequest(BaseModel):
     """
-    domain: Optional[constr(strict=True, max_length=253, min_length=1)] = None
-    is_primary: Optional[StrictBool] = None
-    tenant: Optional[StrictStr] = None
-    __properties = ["domain", "is_primary", "tenant"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ConnectionToken Serializer
+    """ # noqa: E501
+    pk: Optional[StrictStr] = None
+    provider: Optional[StrictInt] = None
+    endpoint: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["pk", "provider", "endpoint"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedDomainRequest:
-        """Create an instance of PatchedDomainRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedConnectionTokenRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedDomainRequest:
-        """Create an instance of PatchedDomainRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedConnectionTokenRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedDomainRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedDomainRequest.parse_obj({
-            "domain": obj.get("domain"),
-            "is_primary": obj.get("is_primary"),
-            "tenant": obj.get("tenant")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "provider": obj.get("provider"),
+            "endpoint": obj.get("endpoint")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_dummy_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/reputation_policy_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,67 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, conint, constr
-
-class PatchedDummyPolicyRequest(BaseModel):
-    """
-    Dummy Policy Serializer  # noqa: E501
+class ReputationPolicyRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    result: Optional[StrictBool] = None
-    wait_min: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    wait_max: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["name", "execution_logging", "result", "wait_min", "wait_max"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Reputation Policy Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    check_ip: Optional[StrictBool] = None
+    check_username: Optional[StrictBool] = None
+    threshold: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "check_ip", "check_username", "threshold"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedDummyPolicyRequest:
-        """Create an instance of PatchedDummyPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ReputationPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedDummyPolicyRequest:
-        """Create an instance of PatchedDummyPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ReputationPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedDummyPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedDummyPolicyRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "execution_logging": obj.get("execution_logging"),
-            "result": obj.get("result"),
-            "wait_min": obj.get("wait_min"),
-            "wait_max": obj.get("wait_max")
+            "check_ip": obj.get("check_ip"),
+            "check_username": obj.get("check_username"),
+            "threshold": obj.get("threshold")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_dummy_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_stage_request.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,71 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, StrictBool, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedDummyStageRequest(BaseModel):
-    """
-    DummyStage Serializer  # noqa: E501
+class DummyStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
+    DummyStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
     throw_error: Optional[StrictBool] = None
-    __properties = ["name", "flow_set", "throw_error"]
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "throw_error"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedDummyStageRequest:
-        """Create an instance of PatchedDummyStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DummyStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedDummyStageRequest:
-        """Create an instance of PatchedDummyStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DummyStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedDummyStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedDummyStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "throw_error": obj.get("throw_error")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_email_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_binding_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,95 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class PatchedEmailStageRequest(BaseModel):
-    """
-    EmailStage Serializer  # noqa: E501
+class PolicyBindingRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    use_global_settings: Optional[StrictBool] = Field(None, description="When enabled, global Email connection settings will be used and connection settings below will be ignored.")
-    host: Optional[constr(strict=True, min_length=1)] = None
-    port: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    username: Optional[StrictStr] = None
-    password: Optional[StrictStr] = None
-    use_tls: Optional[StrictBool] = None
-    use_ssl: Optional[StrictBool] = None
-    timeout: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    from_address: Optional[constr(strict=True, max_length=254, min_length=1)] = None
-    token_expiry: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="Time in minutes the token sent is valid.")
-    subject: Optional[constr(strict=True, min_length=1)] = None
-    template: Optional[constr(strict=True, min_length=1)] = None
-    activate_user_on_success: Optional[StrictBool] = Field(None, description="Activate users upon completion of stage.")
-    __properties = ["name", "flow_set", "use_global_settings", "host", "port", "username", "password", "use_tls", "use_ssl", "timeout", "from_address", "token_expiry", "subject", "template", "activate_user_on_success"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PolicyBinding Serializer
+    """ # noqa: E501
+    policy: Optional[StrictStr] = None
+    group: Optional[StrictStr] = None
+    user: Optional[StrictInt] = None
+    target: StrictStr
+    negate: Optional[StrictBool] = Field(default=None, description="Negates the outcome of the policy. Messages are unaffected.")
+    enabled: Optional[StrictBool] = None
+    order: Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]
+    timeout: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = Field(default=None, description="Timeout after which Policy execution is terminated.")
+    failure_result: Optional[StrictBool] = Field(default=None, description="Result if the Policy execution fails.")
+    __properties: ClassVar[List[str]] = ["policy", "group", "user", "target", "negate", "enabled", "order", "timeout", "failure_result"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedEmailStageRequest:
-        """Create an instance of PatchedEmailStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PolicyBindingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if policy (nullable) is None
+        # and model_fields_set contains the field
+        if self.policy is None and "policy" in self.model_fields_set:
+            _dict['policy'] = None
+
+        # set to None if group (nullable) is None
+        # and model_fields_set contains the field
+        if self.group is None and "group" in self.model_fields_set:
+            _dict['group'] = None
+
+        # set to None if user (nullable) is None
+        # and model_fields_set contains the field
+        if self.user is None and "user" in self.model_fields_set:
+            _dict['user'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedEmailStageRequest:
-        """Create an instance of PatchedEmailStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PolicyBindingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedEmailStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedEmailStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "use_global_settings": obj.get("use_global_settings"),
-            "host": obj.get("host"),
-            "port": obj.get("port"),
-            "username": obj.get("username"),
-            "password": obj.get("password"),
-            "use_tls": obj.get("use_tls"),
-            "use_ssl": obj.get("use_ssl"),
+        _obj = cls.model_validate({
+            "policy": obj.get("policy"),
+            "group": obj.get("group"),
+            "user": obj.get("user"),
+            "target": obj.get("target"),
+            "negate": obj.get("negate"),
+            "enabled": obj.get("enabled"),
+            "order": obj.get("order"),
             "timeout": obj.get("timeout"),
-            "from_address": obj.get("from_address"),
-            "token_expiry": obj.get("token_expiry"),
-            "subject": obj.get("subject"),
-            "template": obj.get("template"),
-            "activate_user_on_success": obj.get("activate_user_on_success")
+            "failure_result": obj.get("failure_result")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_endpoint_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_provider_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,80 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr, conint, conlist, constr
-from authentik_client.models.auth_mode_enum import AuthModeEnum
-from authentik_client.models.protocol_enum import ProtocolEnum
-
-class PatchedEndpointRequest(BaseModel):
-    """
-    Endpoint Serializer  # noqa: E501
+class SCIMProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    provider: Optional[StrictInt] = None
-    protocol: Optional[ProtocolEnum] = None
-    host: Optional[constr(strict=True, min_length=1)] = None
-    settings: Optional[Any] = None
-    property_mappings: Optional[conlist(StrictStr)] = None
-    auth_mode: Optional[AuthModeEnum] = None
-    maximum_connections: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["name", "provider", "protocol", "host", "settings", "property_mappings", "auth_mode", "maximum_connections"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SCIMProvider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    property_mappings: Optional[List[StrictStr]] = None
+    property_mappings_group: Optional[List[StrictStr]] = Field(default=None, description="Property mappings used for group creation/updating.")
+    url: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Base URL to SCIM requests, usually ends in /v2")
+    token: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Authentication token")
+    exclude_users_service_account: Optional[StrictBool] = None
+    filter_group: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "property_mappings", "property_mappings_group", "url", "token", "exclude_users_service_account", "filter_group"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedEndpointRequest:
-        """Create an instance of PatchedEndpointRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SCIMProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.settings is None and "settings" in self.__fields_set__:
-            _dict['settings'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if filter_group (nullable) is None
+        # and model_fields_set contains the field
+        if self.filter_group is None and "filter_group" in self.model_fields_set:
+            _dict['filter_group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedEndpointRequest:
-        """Create an instance of PatchedEndpointRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SCIMProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedEndpointRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedEndpointRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "provider": obj.get("provider"),
-            "protocol": obj.get("protocol"),
-            "host": obj.get("host"),
-            "settings": obj.get("settings"),
             "property_mappings": obj.get("property_mappings"),
-            "auth_mode": obj.get("auth_mode"),
-            "maximum_connections": obj.get("maximum_connections")
+            "property_mappings_group": obj.get("property_mappings_group"),
+            "url": obj.get("url"),
+            "token": obj.get("token"),
+            "exclude_users_service_account": obj.get("exclude_users_service_account"),
+            "filter_group": obj.get("filter_group")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_event_matcher_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_radius_provider_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,92 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-from authentik_client.models.app_enum import AppEnum
-from authentik_client.models.event_actions import EventActions
-from authentik_client.models.model_enum import ModelEnum
-
-class PatchedEventMatcherPolicyRequest(BaseModel):
-    """
-    Event Matcher Policy Serializer  # noqa: E501
+class PatchedRadiusProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    action: Optional[EventActions] = Field(None, description="Match created events with this action type. When left empty, all action types will be matched.")
-    client_ip: Optional[constr(strict=True, min_length=1)] = Field(None, description="Matches Event's Client IP (strict matching, for network matching use an Expression Policy)")
-    app: Optional[AppEnum] = Field(None, description="Match events created by selected application. When left empty, all applications are matched.")
-    model: Optional[ModelEnum] = Field(None, description="Match events created by selected model. When left empty, all models are matched. When an app is selected, all the application's models are matched.")
-    __properties = ["name", "execution_logging", "action", "client_ip", "app", "model"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RadiusProvider Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: Optional[StrictStr] = Field(default=None, description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    client_networks: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.")
+    shared_secret: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Shared secret between clients and server to hash packets.")
+    mfa_support: Optional[StrictBool] = Field(default=None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_networks", "shared_secret", "mfa_support"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedEventMatcherPolicyRequest:
-        """Create an instance of PatchedEventMatcherPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedRadiusProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if action (nullable) is None
-        # and __fields_set__ contains the field
-        if self.action is None and "action" in self.__fields_set__:
-            _dict['action'] = None
-
-        # set to None if client_ip (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_ip is None and "client_ip" in self.__fields_set__:
-            _dict['client_ip'] = None
-
-        # set to None if app (nullable) is None
-        # and __fields_set__ contains the field
-        if self.app is None and "app" in self.__fields_set__:
-            _dict['app'] = None
-
-        # set to None if model (nullable) is None
-        # and __fields_set__ contains the field
-        if self.model is None and "model" in self.__fields_set__:
-            _dict['model'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if authentication_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
+            _dict['authentication_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedEventMatcherPolicyRequest:
-        """Create an instance of PatchedEventMatcherPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedRadiusProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedEventMatcherPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedEventMatcherPolicyRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "action": obj.get("action"),
-            "client_ip": obj.get("client_ip"),
-            "app": obj.get("app"),
-            "model": obj.get("model")
+            "authentication_flow": obj.get("authentication_flow"),
+            "authorization_flow": obj.get("authorization_flow"),
+            "property_mappings": obj.get("property_mappings"),
+            "client_networks": obj.get("client_networks"),
+            "shared_secret": obj.get("shared_secret"),
+            "mfa_support": obj.get("mfa_support")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_expression_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_recovery_key_response.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,63 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-
-class PatchedExpressionPolicyRequest(BaseModel):
-    """
-    Group Membership Policy Serializer  # noqa: E501
+class TenantRecoveryKeyResponse(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    expression: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["name", "execution_logging", "expression"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Tenant recovery key creation response serializer
+    """ # noqa: E501
+    expiry: datetime
+    url: StrictStr
+    __properties: ClassVar[List[str]] = ["expiry", "url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedExpressionPolicyRequest:
-        """Create an instance of PatchedExpressionPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TenantRecoveryKeyResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedExpressionPolicyRequest:
-        """Create an instance of PatchedExpressionPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TenantRecoveryKeyResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedExpressionPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedExpressionPolicyRequest.parse_obj({
-            "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "expression": obj.get("expression")
+        _obj = cls.model_validate({
+            "expiry": obj.get("expiry"),
+            "url": obj.get("url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_flow_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_flow_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,84 +14,101 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.authentication_enum import AuthenticationEnum
 from authentik_client.models.denied_action_enum import DeniedActionEnum
 from authentik_client.models.flow_designation_enum import FlowDesignationEnum
 from authentik_client.models.flow_layout_enum import FlowLayoutEnum
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedFlowRequest(BaseModel):
     """
-    Flow Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    slug: Optional[constr(strict=True, max_length=50, min_length=1)] = Field(None, description="Visible in the URL.")
-    title: Optional[constr(strict=True, min_length=1)] = Field(None, description="Shown as the Title in Flow pages.")
-    designation: Optional[FlowDesignationEnum] = Field(None, description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
+    Flow Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    slug: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Visible in the URL.")
+    title: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Shown as the Title in Flow pages.")
+    designation: Optional[FlowDesignationEnum] = Field(default=None, description="Decides what this Flow is used for. For example, the Authentication flow is redirect to when an un-authenticated user visits authentik.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    compatibility_mode: Optional[StrictBool] = Field(None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
+    compatibility_mode: Optional[StrictBool] = Field(default=None, description="Enable compatibility mode, increases compatibility with password managers on mobile devices.")
     layout: Optional[FlowLayoutEnum] = None
-    denied_action: Optional[DeniedActionEnum] = Field(None, description="Configure what should happen when a flow denies access to a user.")
-    authentication: Optional[AuthenticationEnum] = Field(None, description="Required level of authentication and authorization to access a flow.")
-    __properties = ["name", "slug", "title", "designation", "policy_engine_mode", "compatibility_mode", "layout", "denied_action", "authentication"]
+    denied_action: Optional[DeniedActionEnum] = Field(default=None, description="Configure what should happen when a flow denies access to a user.")
+    authentication: Optional[AuthenticationEnum] = Field(default=None, description="Required level of authentication and authorization to access a flow.")
+    __properties: ClassVar[List[str]] = ["name", "slug", "title", "designation", "policy_engine_mode", "compatibility_mode", "layout", "denied_action", "authentication"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if value is None:
             return value
 
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedFlowRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedFlowRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedFlowRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedFlowRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedFlowRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedFlowRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "title": obj.get("title"),
             "designation": obj.get("designation"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "compatibility_mode": obj.get("compatibility_mode"),
             "layout": obj.get("layout"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_flow_stage_binding_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_expression_policy_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint
-from authentik_client.models.invalid_response_action_enum import InvalidResponseActionEnum
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-
-class PatchedFlowStageBindingRequest(BaseModel):
-    """
-    FlowStageBinding Serializer  # noqa: E501
+class PatchedExpressionPolicyRequest(BaseModel):
     """
-    target: Optional[StrictStr] = None
-    stage: Optional[StrictStr] = None
-    evaluate_on_plan: Optional[StrictBool] = Field(None, description="Evaluate policies during the Flow planning process.")
-    re_evaluate_policies: Optional[StrictBool] = Field(None, description="Evaluate policies when the Stage is present to the user.")
-    order: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    invalid_response_action: Optional[InvalidResponseActionEnum] = Field(None, description="Configure how the flow executor should handle an invalid response to a challenge. RETRY returns the error message and a similar challenge to the executor. RESTART restarts the flow from the beginning, and RESTART_WITH_CONTEXT restarts the flow while keeping the current context.")
-    __properties = ["target", "stage", "evaluate_on_plan", "re_evaluate_policies", "order", "policy_engine_mode", "invalid_response_action"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Group Membership Policy Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    expression: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedFlowStageBindingRequest:
-        """Create an instance of PatchedFlowStageBindingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedExpressionPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedFlowStageBindingRequest:
-        """Create an instance of PatchedFlowStageBindingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedExpressionPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedFlowStageBindingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedFlowStageBindingRequest.parse_obj({
-            "target": obj.get("target"),
-            "stage": obj.get("stage"),
-            "evaluate_on_plan": obj.get("evaluate_on_plan"),
-            "re_evaluate_policies": obj.get("re_evaluate_policies"),
-            "order": obj.get("order"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "invalid_response_action": obj.get("invalid_response_action")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "execution_logging": obj.get("execution_logging"),
+            "expression": obj.get("expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_group_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_group_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,71 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedGroupRequest(BaseModel):
     """
-    Group Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, max_length=80, min_length=1)] = None
-    is_superuser: Optional[StrictBool] = Field(None, description="Users added to this group will be superusers.")
+    Group Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=80)]] = None
+    is_superuser: Optional[StrictBool] = Field(default=None, description="Users added to this group will be superusers.")
     parent: Optional[StrictStr] = None
-    users: Optional[conlist(StrictInt)] = None
+    users: Optional[List[StrictInt]] = None
     attributes: Optional[Dict[str, Any]] = None
-    roles: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "is_superuser", "parent", "users", "attributes", "roles"]
+    roles: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "is_superuser", "parent", "users", "attributes", "roles"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedGroupRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedGroupRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if parent (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parent is None and "parent" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.parent is None and "parent" in self.model_fields_set:
             _dict['parent'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedGroupRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedGroupRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedGroupRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedGroupRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "is_superuser": obj.get("is_superuser"),
             "parent": obj.get("parent"),
             "users": obj.get("users"),
             "attributes": obj.get("attributes"),
             "roles": obj.get("roles")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_identification_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/identification_stage_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,103 +14,120 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
 from authentik_client.models.user_fields_enum import UserFieldsEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedIdentificationStageRequest(BaseModel):
-    """
-    IdentificationStage Serializer  # noqa: E501
+class IdentificationStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    user_fields: Optional[conlist(UserFieldsEnum)] = Field(None, description="Fields of the user object to match against. (Hold shift to select multiple options)")
-    password_stage: Optional[StrictStr] = Field(None, description="When set, shows a password field, instead of showing the password field as seaprate step.")
-    case_insensitive_matching: Optional[StrictBool] = Field(None, description="When enabled, user fields are matched regardless of their casing.")
-    show_matched_user: Optional[StrictBool] = Field(None, description="When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Optional enrollment flow, which is linked at the bottom of the page.")
-    recovery_flow: Optional[StrictStr] = Field(None, description="Optional recovery flow, which is linked at the bottom of the page.")
-    passwordless_flow: Optional[StrictStr] = Field(None, description="Optional passwordless flow, which is linked at the bottom of the page.")
-    sources: Optional[conlist(StrictStr)] = Field(None, description="Specify which sources should be shown.")
+    IdentificationStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    user_fields: Optional[List[UserFieldsEnum]] = Field(default=None, description="Fields of the user object to match against. (Hold shift to select multiple options)")
+    password_stage: Optional[StrictStr] = Field(default=None, description="When set, shows a password field, instead of showing the password field as seaprate step.")
+    case_insensitive_matching: Optional[StrictBool] = Field(default=None, description="When enabled, user fields are matched regardless of their casing.")
+    show_matched_user: Optional[StrictBool] = Field(default=None, description="When a valid username/email has been entered, and this option is enabled, the user's username and avatar will be shown. Otherwise, the text that the user entered will be shown")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Optional enrollment flow, which is linked at the bottom of the page.")
+    recovery_flow: Optional[StrictStr] = Field(default=None, description="Optional recovery flow, which is linked at the bottom of the page.")
+    passwordless_flow: Optional[StrictStr] = Field(default=None, description="Optional passwordless flow, which is linked at the bottom of the page.")
+    sources: Optional[List[StrictStr]] = Field(default=None, description="Specify which sources should be shown.")
     show_source_labels: Optional[StrictBool] = None
-    pretend_user_exists: Optional[StrictBool] = Field(None, description="When enabled, the stage will succeed and continue even when incorrect user info is entered.")
-    __properties = ["name", "flow_set", "user_fields", "password_stage", "case_insensitive_matching", "show_matched_user", "enrollment_flow", "recovery_flow", "passwordless_flow", "sources", "show_source_labels", "pretend_user_exists"]
+    pretend_user_exists: Optional[StrictBool] = Field(default=None, description="When enabled, the stage will succeed and continue even when incorrect user info is entered.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "user_fields", "password_stage", "case_insensitive_matching", "show_matched_user", "enrollment_flow", "recovery_flow", "passwordless_flow", "sources", "show_source_labels", "pretend_user_exists"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedIdentificationStageRequest:
-        """Create an instance of PatchedIdentificationStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of IdentificationStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if password_stage (nullable) is None
-        # and __fields_set__ contains the field
-        if self.password_stage is None and "password_stage" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.password_stage is None and "password_stage" in self.model_fields_set:
             _dict['password_stage'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if recovery_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.recovery_flow is None and "recovery_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.recovery_flow is None and "recovery_flow" in self.model_fields_set:
             _dict['recovery_flow'] = None
 
         # set to None if passwordless_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.passwordless_flow is None and "passwordless_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.passwordless_flow is None and "passwordless_flow" in self.model_fields_set:
             _dict['passwordless_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedIdentificationStageRequest:
-        """Create an instance of PatchedIdentificationStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of IdentificationStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedIdentificationStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedIdentificationStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "user_fields": obj.get("user_fields"),
             "password_stage": obj.get("password_stage"),
             "case_insensitive_matching": obj.get("case_insensitive_matching"),
             "show_matched_user": obj.get("show_matched_user"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "recovery_flow": obj.get("recovery_flow"),
             "passwordless_flow": obj.get("passwordless_flow"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_invitation_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_invitation_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,82 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.invitation import Invitation
+from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedInvitationRequest(BaseModel):
+class PaginatedInvitationList(BaseModel):
     """
-    Invitation Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, max_length=50, min_length=1)] = None
-    expires: Optional[datetime] = None
-    fixed_data: Optional[Dict[str, Any]] = None
-    single_use: Optional[StrictBool] = Field(None, description="When enabled, the invitation will be deleted after usage.")
-    flow: Optional[StrictStr] = Field(None, description="When set, only the configured flow can use this invitation.")
-    __properties = ["name", "expires", "fixed_data", "single_use", "flow"]
-
-    @validator('name')
-    def name_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if value is None:
-            return value
-
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedInvitationList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[Invitation]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedInvitationRequest:
-        """Create an instance of PatchedInvitationRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedInvitationList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.flow is None and "flow" in self.__fields_set__:
-            _dict['flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
+        _items = []
+        if self.results:
+            for _item in self.results:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedInvitationRequest:
-        """Create an instance of PatchedInvitationRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedInvitationList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedInvitationRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedInvitationRequest.parse_obj({
-            "name": obj.get("name"),
-            "expires": obj.get("expires"),
-            "fixed_data": obj.get("fixed_data"),
-            "single_use": obj.get("single_use"),
-            "flow": obj.get("flow")
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [Invitation.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_invitation_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_logout_stage_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,71 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedInvitationStageRequest(BaseModel):
-    """
-    InvitationStage Serializer  # noqa: E501
+class PatchedUserLogoutStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    continue_flow_without_invitation: Optional[StrictBool] = Field(None, description="If this flag is set, this Stage will jump to the next Stage when no Invitation is given. By default this Stage will cancel the Flow when no invitation is given.")
-    __properties = ["name", "flow_set", "continue_flow_without_invitation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserLogoutStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedInvitationStageRequest:
-        """Create an instance of PatchedInvitationStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedUserLogoutStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedInvitationStageRequest:
-        """Create an instance of PatchedInvitationStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedUserLogoutStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedInvitationStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedInvitationStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "continue_flow_without_invitation": obj.get("continue_flow_without_invitation")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_kubernetes_service_connection_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source_connection_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,70 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-
-class PatchedKubernetesServiceConnectionRequest(BaseModel):
-    """
-    KubernetesServiceConnection Serializer  # noqa: E501
+class PlexSourceConnectionRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    kubeconfig: Optional[Any] = Field(None, description="Paste your kubeconfig here. authentik will automatically use the currently selected context.")
-    verify_ssl: Optional[StrictBool] = Field(None, description="Verify SSL Certificates of the Kubernetes API endpoint")
-    __properties = ["name", "local", "kubeconfig", "verify_ssl"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Plex Source connection Serializer
+    """ # noqa: E501
+    identifier: Annotated[str, Field(min_length=1, strict=True)]
+    plex_token: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["identifier", "plex_token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedKubernetesServiceConnectionRequest:
-        """Create an instance of PatchedKubernetesServiceConnectionRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PlexSourceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if kubeconfig (nullable) is None
-        # and __fields_set__ contains the field
-        if self.kubeconfig is None and "kubeconfig" in self.__fields_set__:
-            _dict['kubeconfig'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedKubernetesServiceConnectionRequest:
-        """Create an instance of PatchedKubernetesServiceConnectionRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PlexSourceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedKubernetesServiceConnectionRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedKubernetesServiceConnectionRequest.parse_obj({
-            "name": obj.get("name"),
-            "local": obj.get("local"),
-            "kubeconfig": obj.get("kubeconfig"),
-            "verify_ssl": obj.get("verify_ssl")
+        _obj = cls.model_validate({
+            "identifier": obj.get("identifier"),
+            "plex_token": obj.get("plex_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_ldap_property_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_challenge_response_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,70 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class PatchedLDAPPropertyMappingRequest(BaseModel):
-    """
-    LDAP PropertyMapping Serializer  # noqa: E501
+class ConsentChallengeResponseRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: Optional[constr(strict=True, min_length=1)] = None
-    expression: Optional[constr(strict=True, min_length=1)] = None
-    object_field: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["managed", "name", "expression", "object_field"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Consent challenge response, any valid response request is valid
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-consent'
+    token: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["component", "token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedLDAPPropertyMappingRequest:
-        """Create an instance of PatchedLDAPPropertyMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ConsentChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedLDAPPropertyMappingRequest:
-        """Create an instance of PatchedLDAPPropertyMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ConsentChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedLDAPPropertyMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedLDAPPropertyMappingRequest.parse_obj({
-            "managed": obj.get("managed"),
-            "name": obj.get("name"),
-            "expression": obj.get("expression"),
-            "object_field": obj.get("object_field")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-consent',
+            "token": obj.get("token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_ldap_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/source_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,99 +14,109 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.policy_engine_mode import PolicyEngineMode
+from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
-from authentik_client.models.ldapapi_access_mode import LDAPAPIAccessMode
-
-class PatchedLDAPProviderRequest(BaseModel):
-    """
-    LDAPProvider Serializer  # noqa: E501
+class SourceRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: Optional[StrictStr] = Field(None, description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    base_dn: Optional[constr(strict=True, min_length=1)] = Field(None, description="DN under which objects are accessible.")
-    search_group: Optional[StrictStr] = Field(None, description="Users in this group can do search queries. If not set, every user can execute search queries.")
-    certificate: Optional[StrictStr] = None
-    tls_server_name: Optional[StrictStr] = None
-    uid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for uidNumbers, this number is added to the user.pk to make sure that the numbers aren't too low for POSIX users. Default is 2000 to ensure that we don't collide with local users uidNumber")
-    gid_start_number: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="The start for gidNumbers, this number is added to a number generated from the group.pk to make sure that the numbers aren't too low for POSIX groups. Default is 4000 to ensure that we don't collide with local groups or users primary groups gidNumber")
-    search_mode: Optional[LDAPAPIAccessMode] = None
-    bind_mode: Optional[LDAPAPIAccessMode] = None
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "base_dn", "search_group", "certificate", "tls_server_name", "uid_start_number", "gid_start_number", "search_mode", "bind_mode", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Source Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(min_length=1, strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
+    enabled: Optional[StrictBool] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    policy_engine_mode: Optional[PolicyEngineMode] = None
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template"]
+
+    @field_validator('slug')
+    def slug_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
+            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
+        return value
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedLDAPProviderRequest:
-        """Create an instance of PatchedLDAPProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
-        # set to None if search_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.search_group is None and "search_group" in self.__fields_set__:
-            _dict['search_group'] = None
-
-        # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
-            _dict['certificate'] = None
+        # set to None if enrollment_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
+            _dict['enrollment_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedLDAPProviderRequest:
-        """Create an instance of PatchedLDAPProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedLDAPProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedLDAPProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
+            "slug": obj.get("slug"),
+            "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings"),
-            "base_dn": obj.get("base_dn"),
-            "search_group": obj.get("search_group"),
-            "certificate": obj.get("certificate"),
-            "tls_server_name": obj.get("tls_server_name"),
-            "uid_start_number": obj.get("uid_start_number"),
-            "gid_start_number": obj.get("gid_start_number"),
-            "search_mode": obj.get("search_mode"),
-            "bind_mode": obj.get("bind_mode"),
-            "mfa_support": obj.get("mfa_support")
+            "enrollment_flow": obj.get("enrollment_flow"),
+            "policy_engine_mode": obj.get("policy_engine_mode"),
+            "user_matching_mode": obj.get("user_matching_mode"),
+            "user_path_template": obj.get("user_path_template")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_ldap_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_saml_provider_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,150 +14,131 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.digest_algorithm_enum import DigestAlgorithmEnum
+from authentik_client.models.signature_algorithm_enum import SignatureAlgorithmEnum
+from authentik_client.models.sp_binding_enum import SpBindingEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
-
-class PatchedLDAPSourceRequest(BaseModel):
-    """
-    LDAP Source Serializer  # noqa: E501
+class PatchedSAMLProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = Field(None, description="Source's display Name.")
-    slug: Optional[constr(strict=True, max_length=50, min_length=1)] = Field(None, description="Internal source name, used in URLs.")
-    enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    server_uri: Optional[constr(strict=True, min_length=1)] = None
-    peer_certificate: Optional[StrictStr] = Field(None, description="Optionally verify the LDAP Server's Certificate against the CA Chain in this keypair.")
-    client_certificate: Optional[StrictStr] = Field(None, description="Client certificate to authenticate against the LDAP Server's Certificate.")
-    bind_cn: Optional[StrictStr] = None
-    bind_password: Optional[StrictStr] = None
-    start_tls: Optional[StrictBool] = None
-    sni: Optional[StrictBool] = None
-    base_dn: Optional[constr(strict=True, min_length=1)] = None
-    additional_user_dn: Optional[StrictStr] = Field(None, description="Prepended to Base DN for User-queries.")
-    additional_group_dn: Optional[StrictStr] = Field(None, description="Prepended to Base DN for Group-queries.")
-    user_object_filter: Optional[constr(strict=True, min_length=1)] = Field(None, description="Consider Objects matching this filter to be Users.")
-    group_object_filter: Optional[constr(strict=True, min_length=1)] = Field(None, description="Consider Objects matching this filter to be Groups.")
-    group_membership_field: Optional[constr(strict=True, min_length=1)] = Field(None, description="Field which contains members of a group.")
-    object_uniqueness_field: Optional[constr(strict=True, min_length=1)] = Field(None, description="Field which contains a unique Identifier.")
-    sync_users: Optional[StrictBool] = None
-    sync_users_password: Optional[StrictBool] = Field(None, description="When a user changes their password, sync it back to LDAP. This can only be enabled on a single LDAP source.")
-    sync_groups: Optional[StrictBool] = None
-    sync_parent_group: Optional[StrictStr] = None
-    property_mappings: Optional[conlist(StrictStr)] = None
-    property_mappings_group: Optional[conlist(StrictStr)] = Field(None, description="Property mappings used for group creation/updating.")
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "server_uri", "peer_certificate", "client_certificate", "bind_cn", "bind_password", "start_tls", "sni", "base_dn", "additional_user_dn", "additional_group_dn", "user_object_filter", "group_object_filter", "group_membership_field", "object_uniqueness_field", "sync_users", "sync_users_password", "sync_groups", "sync_parent_group", "property_mappings", "property_mappings_group"]
-
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if value is None:
-            return value
-
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAMLProvider Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: Optional[StrictStr] = Field(default=None, description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    acs_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = None
+    audience: Optional[StrictStr] = Field(default=None, description="Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.")
+    issuer: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Also known as EntityID")
+    assertion_valid_not_before: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).")
+    assertion_valid_not_on_or_after: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    session_valid_not_on_or_after: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    name_id_mapping: Optional[StrictStr] = Field(default=None, description="Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered")
+    digest_algorithm: Optional[DigestAlgorithmEnum] = None
+    signature_algorithm: Optional[SignatureAlgorithmEnum] = None
+    signing_kp: Optional[StrictStr] = Field(default=None, description="Keypair used to sign outgoing Responses going to the Service Provider.")
+    verification_kp: Optional[StrictStr] = Field(default=None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
+    sp_binding: Optional[SpBindingEnum] = Field(default=None, description="This determines how authentik sends the response back to the Service Provider.")
+    default_relay_state: Optional[StrictStr] = Field(default=None, description="Default relay_state value for IDP-initiated logins")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "acs_url", "audience", "issuer", "assertion_valid_not_before", "assertion_valid_not_on_or_after", "session_valid_not_on_or_after", "name_id_mapping", "digest_algorithm", "signature_algorithm", "signing_kp", "verification_kp", "sp_binding", "default_relay_state"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedLDAPSourceRequest:
-        """Create an instance of PatchedLDAPSourceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSAMLProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
-        # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
-            _dict['enrollment_flow'] = None
-
-        # set to None if peer_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.peer_certificate is None and "peer_certificate" in self.__fields_set__:
-            _dict['peer_certificate'] = None
-
-        # set to None if client_certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.client_certificate is None and "client_certificate" in self.__fields_set__:
-            _dict['client_certificate'] = None
-
-        # set to None if sync_parent_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.sync_parent_group is None and "sync_parent_group" in self.__fields_set__:
-            _dict['sync_parent_group'] = None
+        # set to None if name_id_mapping (nullable) is None
+        # and model_fields_set contains the field
+        if self.name_id_mapping is None and "name_id_mapping" in self.model_fields_set:
+            _dict['name_id_mapping'] = None
+
+        # set to None if signing_kp (nullable) is None
+        # and model_fields_set contains the field
+        if self.signing_kp is None and "signing_kp" in self.model_fields_set:
+            _dict['signing_kp'] = None
+
+        # set to None if verification_kp (nullable) is None
+        # and model_fields_set contains the field
+        if self.verification_kp is None and "verification_kp" in self.model_fields_set:
+            _dict['verification_kp'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedLDAPSourceRequest:
-        """Create an instance of PatchedLDAPSourceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSAMLProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedLDAPSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedLDAPSourceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
-            "enrollment_flow": obj.get("enrollment_flow"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "user_matching_mode": obj.get("user_matching_mode"),
-            "user_path_template": obj.get("user_path_template"),
-            "server_uri": obj.get("server_uri"),
-            "peer_certificate": obj.get("peer_certificate"),
-            "client_certificate": obj.get("client_certificate"),
-            "bind_cn": obj.get("bind_cn"),
-            "bind_password": obj.get("bind_password"),
-            "start_tls": obj.get("start_tls"),
-            "sni": obj.get("sni"),
-            "base_dn": obj.get("base_dn"),
-            "additional_user_dn": obj.get("additional_user_dn"),
-            "additional_group_dn": obj.get("additional_group_dn"),
-            "user_object_filter": obj.get("user_object_filter"),
-            "group_object_filter": obj.get("group_object_filter"),
-            "group_membership_field": obj.get("group_membership_field"),
-            "object_uniqueness_field": obj.get("object_uniqueness_field"),
-            "sync_users": obj.get("sync_users"),
-            "sync_users_password": obj.get("sync_users_password"),
-            "sync_groups": obj.get("sync_groups"),
-            "sync_parent_group": obj.get("sync_parent_group"),
+            "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
-            "property_mappings_group": obj.get("property_mappings_group")
+            "acs_url": obj.get("acs_url"),
+            "audience": obj.get("audience"),
+            "issuer": obj.get("issuer"),
+            "assertion_valid_not_before": obj.get("assertion_valid_not_before"),
+            "assertion_valid_not_on_or_after": obj.get("assertion_valid_not_on_or_after"),
+            "session_valid_not_on_or_after": obj.get("session_valid_not_on_or_after"),
+            "name_id_mapping": obj.get("name_id_mapping"),
+            "digest_algorithm": obj.get("digest_algorithm"),
+            "signature_algorithm": obj.get("signature_algorithm"),
+            "signing_kp": obj.get("signing_kp"),
+            "verification_kp": obj.get("verification_kp"),
+            "sp_binding": obj.get("sp_binding"),
+            "default_relay_state": obj.get("default_relay_state")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_license_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_license_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, constr
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedLicenseRequest(BaseModel):
     """
-    License Serializer  # noqa: E501
-    """
-    key: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["key"]
+    License Serializer
+    """ # noqa: E501
+    key: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["key"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedLicenseRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedLicenseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedLicenseRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedLicenseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedLicenseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedLicenseRequest.parse_obj({
+        _obj = cls.model_validate({
             "key": obj.get("key")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_notification_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_plex_source_connection_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,65 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool
-from authentik_client.models.event_request import EventRequest
-
-class PatchedNotificationRequest(BaseModel):
-    """
-    Notification Serializer  # noqa: E501
+class PatchedPlexSourceConnectionRequest(BaseModel):
     """
-    event: Optional[EventRequest] = None
-    seen: Optional[StrictBool] = None
-    __properties = ["event", "seen"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Plex Source connection Serializer
+    """ # noqa: E501
+    identifier: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    plex_token: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["identifier", "plex_token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedNotificationRequest:
-        """Create an instance of PatchedNotificationRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPlexSourceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of event
-        if self.event:
-            _dict['event'] = self.event.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedNotificationRequest:
-        """Create an instance of PatchedNotificationRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPlexSourceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedNotificationRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedNotificationRequest.parse_obj({
-            "event": EventRequest.from_dict(obj.get("event")) if obj.get("event") is not None else None,
-            "seen": obj.get("seen")
+        _obj = cls.model_validate({
+            "identifier": obj.get("identifier"),
+            "plex_token": obj.get("plex_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_notification_rule_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_tenant_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,71 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.severity_enum import SeverityEnum
-
-class PatchedNotificationRuleRequest(BaseModel):
-    """
-    NotificationRule Serializer  # noqa: E501
+class PatchedTenantRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    transports: Optional[conlist(StrictStr)] = Field(None, description="Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.")
-    severity: Optional[SeverityEnum] = Field(None, description="Controls which severity level the created notifications will have.")
-    group: Optional[StrictStr] = Field(None, description="Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.")
-    __properties = ["name", "transports", "severity", "group"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Tenant Serializer
+    """ # noqa: E501
+    schema_name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=63)]] = None
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    ready: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["schema_name", "name", "ready"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedNotificationRuleRequest:
-        """Create an instance of PatchedNotificationRuleRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedTenantRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.group is None and "group" in self.__fields_set__:
-            _dict['group'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedNotificationRuleRequest:
-        """Create an instance of PatchedNotificationRuleRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedTenantRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedNotificationRuleRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedNotificationRuleRequest.parse_obj({
+        _obj = cls.model_validate({
+            "schema_name": obj.get("schema_name"),
             "name": obj.get("name"),
-            "transports": obj.get("transports"),
-            "severity": obj.get("severity"),
-            "group": obj.get("group")
+            "ready": obj.get("ready")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_o_auth2_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_o_auth2_provider_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,89 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.client_type_enum import ClientTypeEnum
 from authentik_client.models.issuer_mode_enum import IssuerModeEnum
 from authentik_client.models.sub_mode_enum import SubModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedOAuth2ProviderRequest(BaseModel):
     """
-    OAuth2Provider Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: Optional[StrictStr] = Field(None, description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    client_type: Optional[ClientTypeEnum] = Field(None, description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable")
-    client_id: Optional[constr(strict=True, max_length=255, min_length=1)] = None
-    client_secret: Optional[constr(strict=True, max_length=255)] = None
-    access_code_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    access_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    refresh_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    include_claims_in_id_token: Optional[StrictBool] = Field(None, description="Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.")
-    signing_key: Optional[StrictStr] = Field(None, description="Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.")
-    redirect_uris: Optional[StrictStr] = Field(None, description="Enter each URI on a new line.")
-    sub_mode: Optional[SubModeEnum] = Field(None, description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.")
-    issuer_mode: Optional[IssuerModeEnum] = Field(None, description="Configure how the issuer field of the ID Token should be filled.")
-    jwks_sources: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_type", "client_id", "client_secret", "access_code_validity", "access_token_validity", "refresh_token_validity", "include_claims_in_id_token", "signing_key", "redirect_uris", "sub_mode", "issuer_mode", "jwks_sources"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth2Provider Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: Optional[StrictStr] = Field(default=None, description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    client_type: Optional[ClientTypeEnum] = Field(default=None, description="Confidential clients are capable of maintaining the confidentiality of their credentials. Public clients are incapable")
+    client_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = None
+    client_secret: Optional[Annotated[str, Field(strict=True, max_length=255)]] = None
+    access_code_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Access codes not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    access_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    refresh_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    include_claims_in_id_token: Optional[StrictBool] = Field(default=None, description="Include User claims from scopes in the id_token, for applications that don't access the userinfo endpoint.")
+    signing_key: Optional[StrictStr] = Field(default=None, description="Key used to sign the tokens. Only required when JWT Algorithm is set to RS256.")
+    redirect_uris: Optional[StrictStr] = Field(default=None, description="Enter each URI on a new line.")
+    sub_mode: Optional[SubModeEnum] = Field(default=None, description="Configure what data should be used as unique User Identifier. For most cases, the default should be fine.")
+    issuer_mode: Optional[IssuerModeEnum] = Field(default=None, description="Configure how the issuer field of the ID Token should be filled.")
+    jwks_sources: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_type", "client_id", "client_secret", "access_code_validity", "access_token_validity", "refresh_token_validity", "include_claims_in_id_token", "signing_key", "redirect_uris", "sub_mode", "issuer_mode", "jwks_sources"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedOAuth2ProviderRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedOAuth2ProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if signing_key (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_key is None and "signing_key" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_key is None and "signing_key" in self.model_fields_set:
             _dict['signing_key'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedOAuth2ProviderRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedOAuth2ProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedOAuth2ProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedOAuth2ProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "client_type": obj.get("client_type"),
             "client_id": obj.get("client_id"),
             "client_secret": obj.get("client_secret"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_o_auth_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_o_auth_source_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,127 +14,144 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.provider_type_enum import ProviderTypeEnum
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedOAuthSourceRequest(BaseModel):
     """
-    OAuth Source Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = Field(None, description="Source's display Name.")
-    slug: Optional[constr(strict=True, max_length=50, min_length=1)] = Field(None, description="Internal source name, used in URLs.")
+    OAuth Source Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Source's display Name.")
+    slug: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     provider_type: Optional[ProviderTypeEnum] = None
-    request_token_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL used to request the initial token. This URL is only required for OAuth 1.")
-    authorization_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL the user is redirect to to conest the flow.")
-    access_token_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL used by authentik to retrieve tokens.")
-    profile_url: Optional[constr(strict=True, max_length=255, min_length=1)] = Field(None, description="URL used by authentik to get user information.")
-    consumer_key: Optional[constr(strict=True, min_length=1)] = None
-    consumer_secret: Optional[constr(strict=True, min_length=1)] = None
+    request_token_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL used to request the initial token. This URL is only required for OAuth 1.")
+    authorization_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL the user is redirect to to conest the flow.")
+    access_token_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL used by authentik to retrieve tokens.")
+    profile_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="URL used by authentik to get user information.")
+    consumer_key: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    consumer_secret: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     additional_scopes: Optional[StrictStr] = None
     oidc_well_known_url: Optional[StrictStr] = None
     oidc_jwks_url: Optional[StrictStr] = None
     oidc_jwks: Optional[Any] = None
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "provider_type", "request_token_url", "authorization_url", "access_token_url", "profile_url", "consumer_key", "consumer_secret", "additional_scopes", "oidc_well_known_url", "oidc_jwks_url", "oidc_jwks"]
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "provider_type", "request_token_url", "authorization_url", "access_token_url", "profile_url", "consumer_key", "consumer_secret", "additional_scopes", "oidc_well_known_url", "oidc_jwks_url", "oidc_jwks"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if value is None:
             return value
 
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedOAuthSourceRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedOAuthSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if request_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.request_token_url is None and "request_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.request_token_url is None and "request_token_url" in self.model_fields_set:
             _dict['request_token_url'] = None
 
         # set to None if authorization_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authorization_url is None and "authorization_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authorization_url is None and "authorization_url" in self.model_fields_set:
             _dict['authorization_url'] = None
 
         # set to None if access_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.access_token_url is None and "access_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.access_token_url is None and "access_token_url" in self.model_fields_set:
             _dict['access_token_url'] = None
 
         # set to None if profile_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.profile_url is None and "profile_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.profile_url is None and "profile_url" in self.model_fields_set:
             _dict['profile_url'] = None
 
         # set to None if oidc_jwks (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oidc_jwks is None and "oidc_jwks" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oidc_jwks is None and "oidc_jwks" in self.model_fields_set:
             _dict['oidc_jwks'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedOAuthSourceRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedOAuthSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedOAuthSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedOAuthSourceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "user_matching_mode": obj.get("user_matching_mode"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_outpost_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_outpost_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,77 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.outpost_type_enum import OutpostTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedOutpostRequest(BaseModel):
     """
-    Outpost Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
+    Outpost Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     type: Optional[OutpostTypeEnum] = None
-    providers: Optional[conlist(StrictInt)] = None
-    service_connection: Optional[StrictStr] = Field(None, description="Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.")
+    providers: Optional[List[StrictInt]] = None
+    service_connection: Optional[StrictStr] = Field(default=None, description="Select Service-Connection authentik should use to manage this outpost. Leave empty if authentik should not handle the deployment.")
     config: Optional[Dict[str, Any]] = None
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    __properties = ["name", "type", "providers", "service_connection", "config", "managed"]
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    __properties: ClassVar[List[str]] = ["name", "type", "providers", "service_connection", "config", "managed"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedOutpostRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedOutpostRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if service_connection (nullable) is None
-        # and __fields_set__ contains the field
-        if self.service_connection is None and "service_connection" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.service_connection is None and "service_connection" in self.model_fields_set:
             _dict['service_connection'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedOutpostRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedOutpostRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedOutpostRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedOutpostRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "type": obj.get("type"),
             "providers": obj.get("providers"),
             "service_connection": obj.get("service_connection"),
             "config": obj.get("config"),
             "managed": obj.get("managed")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_password_expiry_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_challenge_response_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,65 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, conint, constr
-
-class PatchedPasswordExpiryPolicyRequest(BaseModel):
-    """
-    Password Expiry Policy Serializer  # noqa: E501
+class PromptChallengeResponseRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    days: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    deny_only: Optional[StrictBool] = None
-    __properties = ["name", "execution_logging", "days", "deny_only"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Validate response, fields are dynamically created based on the stage
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-prompt'
+    additional_properties: Dict[str, Any] = {}
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPasswordExpiryPolicyRequest:
-        """Create an instance of PatchedPasswordExpiryPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PromptChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * Fields in `self.additional_properties` are added to the output dict.
+        """
+        excluded_fields: Set[str] = set([
+            "additional_properties",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # puts key-value pairs in additional_properties in the top level
+        if self.additional_properties is not None:
+            for _key, _value in self.additional_properties.items():
+                _dict[_key] = _value
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPasswordExpiryPolicyRequest:
-        """Create an instance of PatchedPasswordExpiryPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PromptChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPasswordExpiryPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPasswordExpiryPolicyRequest.parse_obj({
-            "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "days": obj.get("days"),
-            "deny_only": obj.get("deny_only")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-prompt'
         })
+        # store additional fields in additional_properties
+        for _key in obj.keys():
+            if _key not in cls.__properties:
+                _obj.additional_properties[_key] = obj.get(_key)
+
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_password_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_scim_provider_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,87 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, constr
-
-class PatchedPasswordPolicyRequest(BaseModel):
-    """
-    Password Policy Serializer  # noqa: E501
+class PatchedSCIMProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    password_field: Optional[constr(strict=True, min_length=1)] = Field(None, description="Field key to check, field keys defined in Prompt stages are available.")
-    amount_digits: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_uppercase: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_lowercase: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    amount_symbols: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    length_min: Optional[conint(strict=True, le=2147483647, ge=0)] = None
-    symbol_charset: Optional[constr(strict=True, min_length=1)] = None
-    error_message: Optional[StrictStr] = None
-    check_static_rules: Optional[StrictBool] = None
-    check_have_i_been_pwned: Optional[StrictBool] = None
-    check_zxcvbn: Optional[StrictBool] = None
-    hibp_allowed_count: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="How many times the password hash is allowed to be on haveibeenpwned")
-    zxcvbn_score_threshold: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="If the zxcvbn score is equal or less than this value, the policy will fail.")
-    __properties = ["name", "execution_logging", "password_field", "amount_digits", "amount_uppercase", "amount_lowercase", "amount_symbols", "length_min", "symbol_charset", "error_message", "check_static_rules", "check_have_i_been_pwned", "check_zxcvbn", "hibp_allowed_count", "zxcvbn_score_threshold"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SCIMProvider Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    property_mappings: Optional[List[StrictStr]] = None
+    property_mappings_group: Optional[List[StrictStr]] = Field(default=None, description="Property mappings used for group creation/updating.")
+    url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Base URL to SCIM requests, usually ends in /v2")
+    token: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Authentication token")
+    exclude_users_service_account: Optional[StrictBool] = None
+    filter_group: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "property_mappings", "property_mappings_group", "url", "token", "exclude_users_service_account", "filter_group"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPasswordPolicyRequest:
-        """Create an instance of PatchedPasswordPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSCIMProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if filter_group (nullable) is None
+        # and model_fields_set contains the field
+        if self.filter_group is None and "filter_group" in self.model_fields_set:
+            _dict['filter_group'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPasswordPolicyRequest:
-        """Create an instance of PatchedPasswordPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSCIMProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPasswordPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPasswordPolicyRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "password_field": obj.get("password_field"),
-            "amount_digits": obj.get("amount_digits"),
-            "amount_uppercase": obj.get("amount_uppercase"),
-            "amount_lowercase": obj.get("amount_lowercase"),
-            "amount_symbols": obj.get("amount_symbols"),
-            "length_min": obj.get("length_min"),
-            "symbol_charset": obj.get("symbol_charset"),
-            "error_message": obj.get("error_message"),
-            "check_static_rules": obj.get("check_static_rules"),
-            "check_have_i_been_pwned": obj.get("check_have_i_been_pwned"),
-            "check_zxcvbn": obj.get("check_zxcvbn"),
-            "hibp_allowed_count": obj.get("hibp_allowed_count"),
-            "zxcvbn_score_threshold": obj.get("zxcvbn_score_threshold")
+            "property_mappings": obj.get("property_mappings"),
+            "property_mappings_group": obj.get("property_mappings_group"),
+            "url": obj.get("url"),
+            "token": obj.get("token"),
+            "exclude_users_service_account": obj.get("exclude_users_service_account"),
+            "filter_group": obj.get("filter_group")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_password_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/password_stage_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,81 +14,98 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conint, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.backends_enum import BackendsEnum
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedPasswordStageRequest(BaseModel):
-    """
-    PasswordStage Serializer  # noqa: E501
+class PasswordStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    backends: Optional[conlist(BackendsEnum)] = Field(None, description="Selection of backends to test the password against.")
-    configure_flow: Optional[StrictStr] = Field(None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
-    failed_attempts_before_cancel: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = Field(None, description="How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.")
-    __properties = ["name", "flow_set", "backends", "configure_flow", "failed_attempts_before_cancel"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PasswordStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    backends: List[BackendsEnum] = Field(description="Selection of backends to test the password against.")
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    failed_attempts_before_cancel: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = Field(default=None, description="How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "backends", "configure_flow", "failed_attempts_before_cancel"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPasswordStageRequest:
-        """Create an instance of PatchedPasswordStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PasswordStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if configure_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.configure_flow is None and "configure_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
             _dict['configure_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPasswordStageRequest:
-        """Create an instance of PatchedPasswordStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PasswordStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPasswordStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPasswordStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "backends": obj.get("backends"),
             "configure_flow": obj.get("configure_flow"),
             "failed_attempts_before_cancel": obj.get("failed_attempts_before_cancel")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_plex_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_sms_stage_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,103 +14,123 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.auth_type_enum import AuthTypeEnum
+from authentik_client.models.flow_set_request import FlowSetRequest
+from authentik_client.models.provider_enum import ProviderEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
-
-class PatchedPlexSourceRequest(BaseModel):
-    """
-    Plex Source Serializer  # noqa: E501
+class AuthenticatorSMSStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = Field(None, description="Source's display Name.")
-    slug: Optional[constr(strict=True, max_length=50, min_length=1)] = Field(None, description="Internal source name, used in URLs.")
-    enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    client_id: Optional[constr(strict=True, min_length=1)] = Field(None, description="Client identifier used to talk to Plex.")
-    allowed_servers: Optional[conlist(constr(strict=True, min_length=1))] = Field(None, description="Which servers a user has to be a member of to be granted access. Empty list allows every server.")
-    allow_friends: Optional[StrictBool] = Field(None, description="Allow friends to authenticate, even if you don't share a server.")
-    plex_token: Optional[constr(strict=True, min_length=1)] = Field(None, description="Plex token used to check friends")
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "client_id", "allowed_servers", "allow_friends", "plex_token"]
-
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if value is None:
-            return value
-
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorSMSStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    provider: ProviderEnum
+    from_number: Annotated[str, Field(min_length=1, strict=True)]
+    account_sid: Annotated[str, Field(min_length=1, strict=True)]
+    auth: Annotated[str, Field(min_length=1, strict=True)]
+    auth_password: Optional[StrictStr] = None
+    auth_type: Optional[AuthTypeEnum] = None
+    verify_only: Optional[StrictBool] = Field(default=None, description="When enabled, the Phone number is only used during enrollment to verify the users authenticity. Only a hash of the phone number is saved to ensure it is not reused in the future.")
+    mapping: Optional[StrictStr] = Field(default=None, description="Optionally modify the payload being sent to custom providers.")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "configure_flow", "friendly_name", "provider", "from_number", "account_sid", "auth", "auth_password", "auth_type", "verify_only", "mapping"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPlexSourceRequest:
-        """Create an instance of PatchedPlexSourceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorSMSStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
-
-        # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
-            _dict['enrollment_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+        _items = []
+        if self.flow_set:
+            for _item in self.flow_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['flow_set'] = _items
+        # set to None if configure_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
+            _dict['configure_flow'] = None
+
+        # set to None if friendly_name (nullable) is None
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
+            _dict['friendly_name'] = None
+
+        # set to None if mapping (nullable) is None
+        # and model_fields_set contains the field
+        if self.mapping is None and "mapping" in self.model_fields_set:
+            _dict['mapping'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPlexSourceRequest:
-        """Create an instance of PatchedPlexSourceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorSMSStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPlexSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPlexSourceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "enabled": obj.get("enabled"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "enrollment_flow": obj.get("enrollment_flow"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "user_matching_mode": obj.get("user_matching_mode"),
-            "user_path_template": obj.get("user_path_template"),
-            "client_id": obj.get("client_id"),
-            "allowed_servers": obj.get("allowed_servers"),
-            "allow_friends": obj.get("allow_friends"),
-            "plex_token": obj.get("plex_token")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "configure_flow": obj.get("configure_flow"),
+            "friendly_name": obj.get("friendly_name"),
+            "provider": obj.get("provider"),
+            "from_number": obj.get("from_number"),
+            "account_sid": obj.get("account_sid"),
+            "auth": obj.get("auth"),
+            "auth_password": obj.get("auth_password"),
+            "auth_type": obj.get("auth_type"),
+            "verify_only": obj.get("verify_only"),
+            "mapping": obj.get("mapping")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_policy_binding_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_event_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,90 +14,110 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.event_actions import EventActions
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
-
-class PatchedPolicyBindingRequest(BaseModel):
-    """
-    PolicyBinding Serializer  # noqa: E501
+class PatchedEventRequest(BaseModel):
     """
-    policy: Optional[StrictStr] = None
-    group: Optional[StrictStr] = None
-    user: Optional[StrictInt] = None
-    target: Optional[StrictStr] = None
-    negate: Optional[StrictBool] = Field(None, description="Negates the outcome of the policy. Messages are unaffected.")
-    enabled: Optional[StrictBool] = None
-    order: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    timeout: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="Timeout after which Policy execution is terminated.")
-    failure_result: Optional[StrictBool] = Field(None, description="Result if the Policy execution fails.")
-    __properties = ["policy", "group", "user", "target", "negate", "enabled", "order", "timeout", "failure_result"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Event Serializer
+    """ # noqa: E501
+    user: Optional[Any] = None
+    action: Optional[EventActions] = None
+    app: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    context: Optional[Any] = None
+    client_ip: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    expires: Optional[datetime] = None
+    brand: Optional[Any] = None
+    __properties: ClassVar[List[str]] = ["user", "action", "app", "context", "client_ip", "expires", "brand"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPolicyBindingRequest:
-        """Create an instance of PatchedPolicyBindingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedEventRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if policy (nullable) is None
-        # and __fields_set__ contains the field
-        if self.policy is None and "policy" in self.__fields_set__:
-            _dict['policy'] = None
-
-        # set to None if group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.group is None and "group" in self.__fields_set__:
-            _dict['group'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if user (nullable) is None
-        # and __fields_set__ contains the field
-        if self.user is None and "user" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.user is None and "user" in self.model_fields_set:
             _dict['user'] = None
 
+        # set to None if context (nullable) is None
+        # and model_fields_set contains the field
+        if self.context is None and "context" in self.model_fields_set:
+            _dict['context'] = None
+
+        # set to None if client_ip (nullable) is None
+        # and model_fields_set contains the field
+        if self.client_ip is None and "client_ip" in self.model_fields_set:
+            _dict['client_ip'] = None
+
+        # set to None if brand (nullable) is None
+        # and model_fields_set contains the field
+        if self.brand is None and "brand" in self.model_fields_set:
+            _dict['brand'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPolicyBindingRequest:
-        """Create an instance of PatchedPolicyBindingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedEventRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPolicyBindingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPolicyBindingRequest.parse_obj({
-            "policy": obj.get("policy"),
-            "group": obj.get("group"),
+        _obj = cls.model_validate({
             "user": obj.get("user"),
-            "target": obj.get("target"),
-            "negate": obj.get("negate"),
-            "enabled": obj.get("enabled"),
-            "order": obj.get("order"),
-            "timeout": obj.get("timeout"),
-            "failure_result": obj.get("failure_result")
+            "action": obj.get("action"),
+            "app": obj.get("app"),
+            "context": obj.get("context"),
+            "client_ip": obj.get("client_ip"),
+            "expires": obj.get("expires"),
+            "brand": obj.get("brand")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_prompt_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_prompt_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,90 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.prompt_type_enum import PromptTypeEnum
 from authentik_client.models.stage_request import StageRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedPromptRequest(BaseModel):
     """
-    Prompt Serializer  # noqa: E501
-    """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    field_key: Optional[constr(strict=True, min_length=1)] = Field(None, description="Name of the form field, also used to store the value")
-    label: Optional[constr(strict=True, min_length=1)] = None
+    Prompt Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    field_key: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Name of the form field, also used to store the value")
+    label: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     type: Optional[PromptTypeEnum] = None
     required: Optional[StrictBool] = None
-    placeholder: Optional[StrictStr] = Field(None, description="Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.")
-    initial_value: Optional[StrictStr] = Field(None, description="Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.")
-    order: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    promptstage_set: Optional[conlist(StageRequest)] = None
+    placeholder: Optional[StrictStr] = Field(default=None, description="Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.")
+    initial_value: Optional[StrictStr] = Field(default=None, description="Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.")
+    order: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    promptstage_set: Optional[List[StageRequest]] = None
     sub_text: Optional[StrictStr] = None
     placeholder_expression: Optional[StrictBool] = None
     initial_value_expression: Optional[StrictBool] = None
-    __properties = ["name", "field_key", "label", "type", "required", "placeholder", "initial_value", "order", "promptstage_set", "sub_text", "placeholder_expression", "initial_value_expression"]
+    __properties: ClassVar[List[str]] = ["name", "field_key", "label", "type", "required", "placeholder", "initial_value", "order", "promptstage_set", "sub_text", "placeholder_expression", "initial_value_expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPromptRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedPromptRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in promptstage_set (list)
         _items = []
         if self.promptstage_set:
             for _item in self.promptstage_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['promptstage_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPromptRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedPromptRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPromptRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPromptRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "field_key": obj.get("field_key"),
             "label": obj.get("label"),
             "type": obj.get("type"),
             "required": obj.get("required"),
             "placeholder": obj.get("placeholder"),
             "initial_value": obj.get("initial_value"),
             "order": obj.get("order"),
-            "promptstage_set": [StageRequest.from_dict(_item) for _item in obj.get("promptstage_set")] if obj.get("promptstage_set") is not None else None,
+            "promptstage_set": [StageRequest.from_dict(_item) for _item in obj["promptstage_set"]] if obj.get("promptstage_set") is not None else None,
             "sub_text": obj.get("sub_text"),
             "placeholder_expression": obj.get("placeholder_expression"),
             "initial_value_expression": obj.get("initial_value_expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_prompt_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_stage_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedPromptStageRequest(BaseModel):
-    """
-    PromptStage Serializer  # noqa: E501
+class PromptStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    fields: Optional[conlist(StrictStr)] = None
-    validation_policies: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "flow_set", "fields", "validation_policies"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PromptStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    fields: List[StrictStr]
+    validation_policies: Optional[List[StrictStr]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "fields", "validation_policies"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedPromptStageRequest:
-        """Create an instance of PatchedPromptStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PromptStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedPromptStageRequest:
-        """Create an instance of PatchedPromptStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PromptStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedPromptStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedPromptStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "fields": obj.get("fields"),
             "validation_policies": obj.get("validation_policies")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_proxy_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_provider_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,89 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.proxy_mode import ProxyMode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedProxyProviderRequest(BaseModel):
-    """
-    ProxyProvider Serializer  # noqa: E501
+class ProxyProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: Optional[StrictStr] = Field(None, description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
+    ProxyProvider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
     internal_host: Optional[StrictStr] = None
-    external_host: Optional[constr(strict=True, min_length=1)] = None
-    internal_host_ssl_validation: Optional[StrictBool] = Field(None, description="Validate SSL Certificates of upstream servers")
+    external_host: Annotated[str, Field(min_length=1, strict=True)]
+    internal_host_ssl_validation: Optional[StrictBool] = Field(default=None, description="Validate SSL Certificates of upstream servers")
     certificate: Optional[StrictStr] = None
-    skip_path_regex: Optional[StrictStr] = Field(None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
-    basic_auth_enabled: Optional[StrictBool] = Field(None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
-    basic_auth_password_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
-    basic_auth_user_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
-    mode: Optional[ProxyMode] = Field(None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
-    intercept_header_auth: Optional[StrictBool] = Field(None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
+    skip_path_regex: Optional[StrictStr] = Field(default=None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
+    basic_auth_enabled: Optional[StrictBool] = Field(default=None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
+    basic_auth_password_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
+    basic_auth_user_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
+    mode: Optional[ProxyMode] = Field(default=None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
+    intercept_header_auth: Optional[StrictBool] = Field(default=None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
     cookie_domain: Optional[StrictStr] = None
-    jwks_sources: Optional[conlist(StrictStr)] = None
-    access_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    refresh_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "internal_host", "external_host", "internal_host_ssl_validation", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "intercept_header_auth", "cookie_domain", "jwks_sources", "access_token_validity", "refresh_token_validity"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    jwks_sources: Optional[List[StrictStr]] = None
+    access_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    refresh_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "internal_host", "external_host", "internal_host_ssl_validation", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "intercept_header_auth", "cookie_domain", "jwks_sources", "access_token_validity", "refresh_token_validity"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedProxyProviderRequest:
-        """Create an instance of PatchedProxyProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ProxyProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.certificate is None and "certificate" in self.model_fields_set:
             _dict['certificate'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedProxyProviderRequest:
-        """Create an instance of PatchedProxyProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ProxyProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedProxyProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedProxyProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "internal_host": obj.get("internal_host"),
             "external_host": obj.get("external_host"),
             "internal_host_ssl_validation": obj.get("internal_host_ssl_validation"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_rac_property_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_rac_property_mapping_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,69 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictStr, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedRACPropertyMappingRequest(BaseModel):
     """
-    RACPropertyMapping Serializer  # noqa: E501
-    """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: Optional[constr(strict=True, min_length=1)] = None
+    RACPropertyMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
     expression: Optional[StrictStr] = None
     static_settings: Optional[Dict[str, Any]] = None
-    __properties = ["managed", "name", "expression", "static_settings"]
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression", "static_settings"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedRACPropertyMappingRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedRACPropertyMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedRACPropertyMappingRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedRACPropertyMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedRACPropertyMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedRACPropertyMappingRequest.parse_obj({
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
             "static_settings": obj.get("static_settings")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_rac_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_property_mapping_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,81 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-
-class PatchedRACProviderRequest(BaseModel):
-    """
-    RACProvider Serializer  # noqa: E501
+class SAMLPropertyMappingRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: Optional[StrictStr] = Field(None, description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    settings: Optional[Any] = None
-    connection_expiry: Optional[constr(strict=True, min_length=1)] = Field(None, description="Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)")
-    delete_token_on_disconnect: Optional[StrictBool] = Field(None, description="When set to true, connection tokens will be deleted upon disconnect.")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "settings", "connection_expiry", "delete_token_on_disconnect"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAMLPropertyMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    expression: Annotated[str, Field(min_length=1, strict=True)]
+    saml_name: Annotated[str, Field(min_length=1, strict=True)]
+    friendly_name: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression", "saml_name", "friendly_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedRACProviderRequest:
-        """Create an instance of PatchedRACProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SAMLPropertyMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
-
-        # set to None if settings (nullable) is None
-        # and __fields_set__ contains the field
-        if self.settings is None and "settings" in self.__fields_set__:
-            _dict['settings'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if managed (nullable) is None
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
+            _dict['managed'] = None
+
+        # set to None if friendly_name (nullable) is None
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
+            _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedRACProviderRequest:
-        """Create an instance of PatchedRACProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SAMLPropertyMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedRACProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedRACProviderRequest.parse_obj({
+        _obj = cls.model_validate({
+            "managed": obj.get("managed"),
             "name": obj.get("name"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings"),
-            "settings": obj.get("settings"),
-            "connection_expiry": obj.get("connection_expiry"),
-            "delete_token_on_disconnect": obj.get("delete_token_on_disconnect")
+            "expression": obj.get("expression"),
+            "saml_name": obj.get("saml_name"),
+            "friendly_name": obj.get("friendly_name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_radius_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_kubernetes_service_connection_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,76 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-
-class PatchedRadiusProviderRequest(BaseModel):
-    """
-    RadiusProvider Serializer  # noqa: E501
+class PatchedKubernetesServiceConnectionRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: Optional[StrictStr] = Field(None, description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    client_networks: Optional[constr(strict=True, min_length=1)] = Field(None, description="List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.")
-    shared_secret: Optional[constr(strict=True, min_length=1)] = Field(None, description="Shared secret between clients and server to hash packets.")
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_networks", "shared_secret", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    KubernetesServiceConnection Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    kubeconfig: Optional[Any] = Field(default=None, description="Paste your kubeconfig here. authentik will automatically use the currently selected context.")
+    verify_ssl: Optional[StrictBool] = Field(default=None, description="Verify SSL Certificates of the Kubernetes API endpoint")
+    __properties: ClassVar[List[str]] = ["name", "local", "kubeconfig", "verify_ssl"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedRadiusProviderRequest:
-        """Create an instance of PatchedRadiusProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedKubernetesServiceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if kubeconfig (nullable) is None
+        # and model_fields_set contains the field
+        if self.kubeconfig is None and "kubeconfig" in self.model_fields_set:
+            _dict['kubeconfig'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedRadiusProviderRequest:
-        """Create an instance of PatchedRadiusProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedKubernetesServiceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedRadiusProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedRadiusProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings"),
-            "client_networks": obj.get("client_networks"),
-            "shared_secret": obj.get("shared_secret"),
-            "mfa_support": obj.get("mfa_support")
+            "local": obj.get("local"),
+            "kubeconfig": obj.get("kubeconfig"),
+            "verify_ssl": obj.get("verify_ssl")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_reputation_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_saml_source_connection.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,67 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.source import Source
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, conint, constr
-
-class PatchedReputationPolicyRequest(BaseModel):
-    """
-    Reputation Policy Serializer  # noqa: E501
+class UserSAMLSourceConnection(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    check_ip: Optional[StrictBool] = None
-    check_username: Optional[StrictBool] = None
-    threshold: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["name", "execution_logging", "check_ip", "check_username", "threshold"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAML Source Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    user: StrictInt
+    source: Source
+    identifier: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "user", "source", "identifier"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedReputationPolicyRequest:
-        """Create an instance of PatchedReputationPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserSAMLSourceConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "source",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of source
+        if self.source:
+            _dict['source'] = self.source.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedReputationPolicyRequest:
-        """Create an instance of PatchedReputationPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserSAMLSourceConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedReputationPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedReputationPolicyRequest.parse_obj({
-            "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "check_ip": obj.get("check_ip"),
-            "check_username": obj.get("check_username"),
-            "threshold": obj.get("threshold")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "user": obj.get("user"),
+            "source": Source.from_dict(obj["source"]) if obj.get("source") is not None else None,
+            "identifier": obj.get("identifier")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_role_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_admin_group_request_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, constr
-
-class PatchedRoleRequest(BaseModel):
-    """
-    Role serializer  # noqa: E501
+class TenantAdminGroupRequestRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, max_length=150, min_length=1)] = None
-    __properties = ["name"]
+    Tenant admin group creation request serializer
+    """ # noqa: E501
+    user: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["user"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedRoleRequest:
-        """Create an instance of PatchedRoleRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TenantAdminGroupRequestRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedRoleRequest:
-        """Create an instance of PatchedRoleRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TenantAdminGroupRequestRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedRoleRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedRoleRequest.parse_obj({
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "user": obj.get("user")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_saml_property_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_ldap_property_mapping_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,77 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class PatchedSAMLPropertyMappingRequest(BaseModel):
-    """
-    SAMLPropertyMapping Serializer  # noqa: E501
+class PatchedLDAPPropertyMappingRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: Optional[constr(strict=True, min_length=1)] = None
-    expression: Optional[constr(strict=True, min_length=1)] = None
-    saml_name: Optional[constr(strict=True, min_length=1)] = None
-    friendly_name: Optional[StrictStr] = None
-    __properties = ["managed", "name", "expression", "saml_name", "friendly_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    LDAP PropertyMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    expression: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    object_field: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression", "object_field"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSAMLPropertyMappingRequest:
-        """Create an instance of PatchedSAMLPropertyMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedLDAPPropertyMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSAMLPropertyMappingRequest:
-        """Create an instance of PatchedSAMLPropertyMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedLDAPPropertyMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSAMLPropertyMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSAMLPropertyMappingRequest.parse_obj({
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
-            "saml_name": obj.get("saml_name"),
-            "friendly_name": obj.get("friendly_name")
+            "object_field": obj.get("object_field")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_saml_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_provider_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,100 +14,117 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.digest_algorithm_enum import DigestAlgorithmEnum
 from authentik_client.models.signature_algorithm_enum import SignatureAlgorithmEnum
 from authentik_client.models.sp_binding_enum import SpBindingEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedSAMLProviderRequest(BaseModel):
-    """
-    SAMLProvider Serializer  # noqa: E501
+class SAMLProviderRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: Optional[StrictStr] = Field(None, description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    acs_url: Optional[constr(strict=True, max_length=200, min_length=1)] = None
-    audience: Optional[StrictStr] = Field(None, description="Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.")
-    issuer: Optional[constr(strict=True, min_length=1)] = Field(None, description="Also known as EntityID")
-    assertion_valid_not_before: Optional[constr(strict=True, min_length=1)] = Field(None, description="Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).")
-    assertion_valid_not_on_or_after: Optional[constr(strict=True, min_length=1)] = Field(None, description="Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    session_valid_not_on_or_after: Optional[constr(strict=True, min_length=1)] = Field(None, description="Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    name_id_mapping: Optional[StrictStr] = Field(None, description="Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered")
+    SAMLProvider Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    acs_url: Annotated[str, Field(min_length=1, strict=True, max_length=200)]
+    audience: Optional[StrictStr] = Field(default=None, description="Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.")
+    issuer: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Also known as EntityID")
+    assertion_valid_not_before: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).")
+    assertion_valid_not_on_or_after: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    session_valid_not_on_or_after: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    name_id_mapping: Optional[StrictStr] = Field(default=None, description="Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered")
     digest_algorithm: Optional[DigestAlgorithmEnum] = None
     signature_algorithm: Optional[SignatureAlgorithmEnum] = None
-    signing_kp: Optional[StrictStr] = Field(None, description="Keypair used to sign outgoing Responses going to the Service Provider.")
-    verification_kp: Optional[StrictStr] = Field(None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
-    sp_binding: Optional[SpBindingEnum] = Field(None, description="This determines how authentik sends the response back to the Service Provider.")
-    default_relay_state: Optional[StrictStr] = Field(None, description="Default relay_state value for IDP-initiated logins")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "acs_url", "audience", "issuer", "assertion_valid_not_before", "assertion_valid_not_on_or_after", "session_valid_not_on_or_after", "name_id_mapping", "digest_algorithm", "signature_algorithm", "signing_kp", "verification_kp", "sp_binding", "default_relay_state"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    signing_kp: Optional[StrictStr] = Field(default=None, description="Keypair used to sign outgoing Responses going to the Service Provider.")
+    verification_kp: Optional[StrictStr] = Field(default=None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
+    sp_binding: Optional[SpBindingEnum] = Field(default=None, description="This determines how authentik sends the response back to the Service Provider.")
+    default_relay_state: Optional[StrictStr] = Field(default=None, description="Default relay_state value for IDP-initiated logins")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "acs_url", "audience", "issuer", "assertion_valid_not_before", "assertion_valid_not_on_or_after", "session_valid_not_on_or_after", "name_id_mapping", "digest_algorithm", "signature_algorithm", "signing_kp", "verification_kp", "sp_binding", "default_relay_state"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSAMLProviderRequest:
-        """Create an instance of PatchedSAMLProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SAMLProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if name_id_mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.name_id_mapping is None and "name_id_mapping" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.name_id_mapping is None and "name_id_mapping" in self.model_fields_set:
             _dict['name_id_mapping'] = None
 
         # set to None if signing_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_kp is None and "signing_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_kp is None and "signing_kp" in self.model_fields_set:
             _dict['signing_kp'] = None
 
         # set to None if verification_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.verification_kp is None and "verification_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.verification_kp is None and "verification_kp" in self.model_fields_set:
             _dict['verification_kp'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSAMLProviderRequest:
-        """Create an instance of PatchedSAMLProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SAMLProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSAMLProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSAMLProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "acs_url": obj.get("acs_url"),
             "audience": obj.get("audience"),
             "issuer": obj.get("issuer"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_saml_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_source_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,121 +14,135 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.binding_type_enum import BindingTypeEnum
 from authentik_client.models.digest_algorithm_enum import DigestAlgorithmEnum
 from authentik_client.models.name_id_policy_enum import NameIdPolicyEnum
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.signature_algorithm_enum import SignatureAlgorithmEnum
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedSAMLSourceRequest(BaseModel):
-    """
-    SAMLSource Serializer  # noqa: E501
+class SAMLSourceRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = Field(None, description="Source's display Name.")
-    slug: Optional[constr(strict=True, max_length=50, min_length=1)] = Field(None, description="Internal source name, used in URLs.")
+    SAMLSource Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(min_length=1, strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    pre_authentication_flow: Optional[StrictStr] = Field(None, description="Flow used before authentication.")
-    issuer: Optional[StrictStr] = Field(None, description="Also known as Entity ID. Defaults the Metadata URL.")
-    sso_url: Optional[constr(strict=True, max_length=200, min_length=1)] = Field(None, description="URL that the initial Login request is sent to.")
-    slo_url: Optional[constr(strict=True, max_length=200)] = Field(None, description="Optional URL if your IDP supports Single-Logout.")
-    allow_idp_initiated: Optional[StrictBool] = Field(None, description="Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.")
-    name_id_policy: Optional[NameIdPolicyEnum] = Field(None, description="NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.")
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    pre_authentication_flow: StrictStr = Field(description="Flow used before authentication.")
+    issuer: Optional[StrictStr] = Field(default=None, description="Also known as Entity ID. Defaults the Metadata URL.")
+    sso_url: Annotated[str, Field(min_length=1, strict=True, max_length=200)] = Field(description="URL that the initial Login request is sent to.")
+    slo_url: Optional[Annotated[str, Field(strict=True, max_length=200)]] = Field(default=None, description="Optional URL if your IDP supports Single-Logout.")
+    allow_idp_initiated: Optional[StrictBool] = Field(default=None, description="Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.")
+    name_id_policy: Optional[NameIdPolicyEnum] = Field(default=None, description="NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.")
     binding_type: Optional[BindingTypeEnum] = None
-    verification_kp: Optional[StrictStr] = Field(None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
-    signing_kp: Optional[StrictStr] = Field(None, description="Keypair used to sign outgoing Responses going to the Identity Provider.")
+    verification_kp: Optional[StrictStr] = Field(default=None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
+    signing_kp: Optional[StrictStr] = Field(default=None, description="Keypair used to sign outgoing Responses going to the Identity Provider.")
     digest_algorithm: Optional[DigestAlgorithmEnum] = None
     signature_algorithm: Optional[SignatureAlgorithmEnum] = None
-    temporary_user_delete_after: Optional[constr(strict=True, min_length=1)] = Field(None, description="Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "pre_authentication_flow", "issuer", "sso_url", "slo_url", "allow_idp_initiated", "name_id_policy", "binding_type", "verification_kp", "signing_kp", "digest_algorithm", "signature_algorithm", "temporary_user_delete_after"]
+    temporary_user_delete_after: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).")
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "pre_authentication_flow", "issuer", "sso_url", "slo_url", "allow_idp_initiated", "name_id_policy", "binding_type", "verification_kp", "signing_kp", "digest_algorithm", "signature_algorithm", "temporary_user_delete_after"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
-        if value is None:
-            return value
-
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSAMLSourceRequest:
-        """Create an instance of PatchedSAMLSourceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SAMLSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if slo_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.slo_url is None and "slo_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.slo_url is None and "slo_url" in self.model_fields_set:
             _dict['slo_url'] = None
 
         # set to None if verification_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.verification_kp is None and "verification_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.verification_kp is None and "verification_kp" in self.model_fields_set:
             _dict['verification_kp'] = None
 
         # set to None if signing_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_kp is None and "signing_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_kp is None and "signing_kp" in self.model_fields_set:
             _dict['signing_kp'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSAMLSourceRequest:
-        """Create an instance of PatchedSAMLSourceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SAMLSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSAMLSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSAMLSourceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "user_matching_mode": obj.get("user_matching_mode"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_scim_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/apple_challenge_response_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,68 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class PatchedSCIMMappingRequest(BaseModel):
-    """
-    SCIMMapping Serializer  # noqa: E501
+class AppleChallengeResponseRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: Optional[constr(strict=True, min_length=1)] = None
-    expression: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["managed", "name", "expression"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Pseudo class for apple response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-source-oauth-apple'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSCIMMappingRequest:
-        """Create an instance of PatchedSCIMMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AppleChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSCIMMappingRequest:
-        """Create an instance of PatchedSCIMMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AppleChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSCIMMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSCIMMappingRequest.parse_obj({
-            "managed": obj.get("managed"),
-            "name": obj.get("name"),
-            "expression": obj.get("expression")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-source-oauth-apple'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_scope_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_property_mapping_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,72 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class PatchedScopeMappingRequest(BaseModel):
-    """
-    ScopeMapping Serializer  # noqa: E501
+class RACPropertyMappingRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: Optional[constr(strict=True, min_length=1)] = None
-    expression: Optional[constr(strict=True, min_length=1)] = None
-    scope_name: Optional[constr(strict=True, min_length=1)] = Field(None, description="Scope name requested by the client")
-    description: Optional[StrictStr] = Field(None, description="Description shown to the user when consenting. If left empty, the user won't be informed.")
-    __properties = ["managed", "name", "expression", "scope_name", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RACPropertyMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    expression: Optional[StrictStr] = None
+    static_settings: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression", "static_settings"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedScopeMappingRequest:
-        """Create an instance of PatchedScopeMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RACPropertyMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedScopeMappingRequest:
-        """Create an instance of PatchedScopeMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RACPropertyMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedScopeMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedScopeMappingRequest.parse_obj({
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
-            "scope_name": obj.get("scope_name"),
-            "description": obj.get("description")
+            "static_settings": obj.get("static_settings")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_settings_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_settings_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,73 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PatchedSettingsRequest(BaseModel):
     """
-    Settings Serializer  # noqa: E501
-    """
-    avatars: Optional[constr(strict=True, min_length=1)] = Field(None, description="Configure how authentik should show avatars for users.")
-    default_user_change_name: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their name.")
-    default_user_change_email: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their email address.")
-    default_user_change_username: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their username.")
-    event_retention: Optional[constr(strict=True, min_length=1)] = Field(None, description="Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).")
-    footer_links: Optional[Any] = Field(None, description="The option configures the footer links on the flow executor pages.")
-    gdpr_compliance: Optional[StrictBool] = Field(None, description="When enabled, all the events caused by a user will be deleted upon the user's deletion.")
-    impersonation: Optional[StrictBool] = Field(None, description="Globally enable/disable impersonation.")
-    __properties = ["avatars", "default_user_change_name", "default_user_change_email", "default_user_change_username", "event_retention", "footer_links", "gdpr_compliance", "impersonation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Settings Serializer
+    """ # noqa: E501
+    avatars: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Configure how authentik should show avatars for users.")
+    default_user_change_name: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their name.")
+    default_user_change_email: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their email address.")
+    default_user_change_username: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their username.")
+    event_retention: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).")
+    footer_links: Optional[Any] = Field(default=None, description="The option configures the footer links on the flow executor pages.")
+    gdpr_compliance: Optional[StrictBool] = Field(default=None, description="When enabled, all the events caused by a user will be deleted upon the user's deletion.")
+    impersonation: Optional[StrictBool] = Field(default=None, description="Globally enable/disable impersonation.")
+    __properties: ClassVar[List[str]] = ["avatars", "default_user_change_name", "default_user_change_email", "default_user_change_username", "event_retention", "footer_links", "gdpr_compliance", "impersonation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSettingsRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PatchedSettingsRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if footer_links (nullable) is None
-        # and __fields_set__ contains the field
-        if self.footer_links is None and "footer_links" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.footer_links is None and "footer_links" in self.model_fields_set:
             _dict['footer_links'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSettingsRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PatchedSettingsRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSettingsRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSettingsRequest.parse_obj({
+        _obj = cls.model_validate({
             "avatars": obj.get("avatars"),
             "default_user_change_name": obj.get("default_user_change_name"),
             "default_user_change_email": obj.get("default_user_change_email"),
             "default_user_change_username": obj.get("default_user_change_username"),
             "event_retention": obj.get("event_retention"),
             "footer_links": obj.get("footer_links"),
             "gdpr_compliance": obj.get("gdpr_compliance"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_sms_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/device_challenge.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,59 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class PatchedSMSDeviceRequest(BaseModel):
-    """
-    Serializer for sms authenticator devices  # noqa: E501
+class DeviceChallenge(BaseModel):
     """
-    name: Optional[constr(strict=True, max_length=64, min_length=1)] = Field(None, description="The human-readable name of this device.")
-    __properties = ["name"]
+    Single device challenge
+    """ # noqa: E501
+    device_class: StrictStr
+    device_uid: StrictStr
+    challenge: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["device_class", "device_uid", "challenge"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSMSDeviceRequest:
-        """Create an instance of PatchedSMSDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DeviceChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSMSDeviceRequest:
-        """Create an instance of PatchedSMSDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DeviceChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSMSDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSMSDeviceRequest.parse_obj({
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "device_class": obj.get("device_class"),
+            "device_uid": obj.get("device_uid"),
+            "challenge": obj.get("challenge")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_source_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_saml_source_connection_list.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.pagination import Pagination
+from authentik_client.models.user_saml_source_connection import UserSAMLSourceConnection
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class PatchedSourceStageRequest(BaseModel):
-    """
-    SourceStage Serializer  # noqa: E501
+class PaginatedUserSAMLSourceConnectionList(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    source: Optional[StrictStr] = None
-    resume_timeout: Optional[constr(strict=True, min_length=1)] = Field(None, description="Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)")
-    __properties = ["name", "flow_set", "source", "resume_timeout"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserSAMLSourceConnectionList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserSAMLSourceConnection]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedSourceStageRequest:
-        """Create an instance of PatchedSourceStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserSAMLSourceConnectionList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
+        if self.results:
+            for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedSourceStageRequest:
-        """Create an instance of PatchedSourceStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserSAMLSourceConnectionList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedSourceStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedSourceStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "source": obj.get("source"),
-            "resume_timeout": obj.get("resume_timeout")
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserSAMLSourceConnection.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_static_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/consent_permission.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,59 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class PatchedStaticDeviceRequest(BaseModel):
-    """
-    Serializer for static authenticator devices  # noqa: E501
+class ConsentPermission(BaseModel):
     """
-    name: Optional[constr(strict=True, max_length=64, min_length=1)] = Field(None, description="The human-readable name of this device.")
-    __properties = ["name"]
+    Permission used for consent
+    """ # noqa: E501
+    name: StrictStr
+    id: StrictStr
+    __properties: ClassVar[List[str]] = ["name", "id"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedStaticDeviceRequest:
-        """Create an instance of PatchedStaticDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ConsentPermission from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedStaticDeviceRequest:
-        """Create an instance of PatchedStaticDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ConsentPermission from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedStaticDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedStaticDeviceRequest.parse_obj({
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "id": obj.get("id")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_tenant_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_account_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,63 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, StrictBool, constr
-
-class PatchedTenantRequest(BaseModel):
-    """
-    Tenant Serializer  # noqa: E501
+class UserAccountRequest(BaseModel):
     """
-    schema_name: Optional[constr(strict=True, max_length=63, min_length=1)] = None
-    name: Optional[constr(strict=True, min_length=1)] = None
-    ready: Optional[StrictBool] = None
-    __properties = ["schema_name", "name", "ready"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Account adding/removing operations
+    """ # noqa: E501
+    pk: StrictInt
+    __properties: ClassVar[List[str]] = ["pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedTenantRequest:
-        """Create an instance of PatchedTenantRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserAccountRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedTenantRequest:
-        """Create an instance of PatchedTenantRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserAccountRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedTenantRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedTenantRequest.parse_obj({
-            "schema_name": obj.get("schema_name"),
-            "name": obj.get("name"),
-            "ready": obj.get("ready")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_token_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/token_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -15,82 +15,97 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.intent_enum import IntentEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedTokenRequest(BaseModel):
+class TokenRequest(BaseModel):
     """
-    Token Serializer  # noqa: E501
-    """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    identifier: Optional[constr(strict=True, max_length=255, min_length=1)] = None
+    Token Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    identifier: Annotated[str, Field(min_length=1, strict=True, max_length=255)]
     intent: Optional[IntentEnum] = None
     user: Optional[StrictInt] = None
     description: Optional[StrictStr] = None
     expires: Optional[datetime] = None
     expiring: Optional[StrictBool] = None
-    __properties = ["managed", "identifier", "intent", "user", "description", "expires", "expiring"]
+    __properties: ClassVar[List[str]] = ["managed", "identifier", "intent", "user", "description", "expires", "expiring"]
 
-    @validator('identifier')
+    @field_validator('identifier')
     def identifier_validate_regular_expression(cls, value):
         """Validates the regular expression"""
-        if value is None:
-            return value
-
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedTokenRequest:
-        """Create an instance of PatchedTokenRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TokenRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedTokenRequest:
-        """Create an instance of PatchedTokenRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TokenRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedTokenRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedTokenRequest.parse_obj({
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "identifier": obj.get("identifier"),
             "intent": obj.get("intent"),
             "user": obj.get("user"),
             "description": obj.get("description"),
             "expires": obj.get("expires"),
             "expiring": obj.get("expiring")
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_totp_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/totp_device.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,59 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class PatchedTOTPDeviceRequest(BaseModel):
-    """
-    Serializer for totp authenticator devices  # noqa: E501
+class TOTPDevice(BaseModel):
     """
-    name: Optional[constr(strict=True, max_length=64, min_length=1)] = Field(None, description="The human-readable name of this device.")
-    __properties = ["name"]
+    Serializer for totp authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    pk: StrictInt
+    __properties: ClassVar[List[str]] = ["name", "pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedTOTPDeviceRequest:
-        """Create an instance of PatchedTOTPDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TOTPDevice from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedTOTPDeviceRequest:
-        """Create an instance of PatchedTOTPDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TOTPDevice from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedTOTPDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedTOTPDeviceRequest.parse_obj({
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "pk": obj.get("pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_delete_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/deny_stage_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,69 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedUserDeleteStageRequest(BaseModel):
-    """
-    UserDeleteStage Serializer  # noqa: E501
+class DenyStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    __properties = ["name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DenyStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    deny_message: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "deny_message"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedUserDeleteStageRequest:
-        """Create an instance of PatchedUserDeleteStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DenyStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedUserDeleteStageRequest:
-        """Create an instance of PatchedUserDeleteStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DenyStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedUserDeleteStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedUserDeleteStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "deny_message": obj.get("deny_message")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_logout_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_user_write_stage_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,69 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.pagination import Pagination
+from authentik_client.models.user_write_stage import UserWriteStage
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class PatchedUserLogoutStageRequest(BaseModel):
-    """
-    UserLogoutStage Serializer  # noqa: E501
+class PaginatedUserWriteStageList(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    __properties = ["name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedUserWriteStageList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[UserWriteStage]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedUserLogoutStageRequest:
-        """Create an instance of PatchedUserLogoutStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedUserWriteStageList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
+        if self.results:
+            for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedUserLogoutStageRequest:
-        """Create an instance of PatchedUserLogoutStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedUserWriteStageList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedUserLogoutStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedUserLogoutStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [UserWriteStage.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_notification_rule_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,81 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from authentik_client.models.user_type_enum import UserTypeEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.severity_enum import SeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedUserRequest(BaseModel):
+class PatchedNotificationRuleRequest(BaseModel):
     """
-    User Serializer  # noqa: E501
-    """
-    username: Optional[constr(strict=True, max_length=150, min_length=1)] = None
-    name: Optional[StrictStr] = Field(None, description="User's display name.")
-    is_active: Optional[StrictBool] = Field(None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
-    last_login: Optional[datetime] = None
-    groups: Optional[conlist(StrictStr)] = None
-    email: Optional[constr(strict=True, max_length=254)] = None
-    attributes: Optional[Dict[str, Any]] = None
-    path: Optional[constr(strict=True, min_length=1)] = None
-    type: Optional[UserTypeEnum] = None
-    __properties = ["username", "name", "is_active", "last_login", "groups", "email", "attributes", "path", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationRule Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    transports: Optional[List[StrictStr]] = Field(default=None, description="Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.")
+    severity: Optional[SeverityEnum] = Field(default=None, description="Controls which severity level the created notifications will have.")
+    group: Optional[StrictStr] = Field(default=None, description="Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.")
+    __properties: ClassVar[List[str]] = ["name", "transports", "severity", "group"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedUserRequest:
-        """Create an instance of PatchedUserRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedNotificationRuleRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if last_login (nullable) is None
-        # and __fields_set__ contains the field
-        if self.last_login is None and "last_login" in self.__fields_set__:
-            _dict['last_login'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if group (nullable) is None
+        # and model_fields_set contains the field
+        if self.group is None and "group" in self.model_fields_set:
+            _dict['group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedUserRequest:
-        """Create an instance of PatchedUserRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedNotificationRuleRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedUserRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedUserRequest.parse_obj({
-            "username": obj.get("username"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "is_active": obj.get("is_active"),
-            "last_login": obj.get("last_login"),
-            "groups": obj.get("groups"),
-            "email": obj.get("email"),
-            "attributes": obj.get("attributes"),
-            "path": obj.get("path"),
-            "type": obj.get("type")
+            "transports": obj.get("transports"),
+            "severity": obj.get("severity"),
+            "group": obj.get("group")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_user_write_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_write_stage_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,84 +14,101 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.flow_set_request import FlowSetRequest
 from authentik_client.models.user_creation_mode_enum import UserCreationModeEnum
 from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PatchedUserWriteStageRequest(BaseModel):
-    """
-    UserWriteStage Serializer  # noqa: E501
+class UserWriteStageRequest(BaseModel):
     """
-    name: Optional[constr(strict=True, min_length=1)] = None
-    flow_set: Optional[conlist(FlowSetRequest)] = None
+    UserWriteStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
     user_creation_mode: Optional[UserCreationModeEnum] = None
-    create_users_as_inactive: Optional[StrictBool] = Field(None, description="When set, newly created users are inactive and cannot login.")
-    create_users_group: Optional[StrictStr] = Field(None, description="Optionally add newly created users to this group.")
+    create_users_as_inactive: Optional[StrictBool] = Field(default=None, description="When set, newly created users are inactive and cannot login.")
+    create_users_group: Optional[StrictStr] = Field(default=None, description="Optionally add newly created users to this group.")
     user_type: Optional[UserTypeEnum] = None
     user_path_template: Optional[StrictStr] = None
-    __properties = ["name", "flow_set", "user_creation_mode", "create_users_as_inactive", "create_users_group", "user_type", "user_path_template"]
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "user_creation_mode", "create_users_as_inactive", "create_users_group", "user_type", "user_path_template"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedUserWriteStageRequest:
-        """Create an instance of PatchedUserWriteStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserWriteStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         # set to None if create_users_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.create_users_group is None and "create_users_group" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.create_users_group is None and "create_users_group" in self.model_fields_set:
             _dict['create_users_group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedUserWriteStageRequest:
-        """Create an instance of PatchedUserWriteStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserWriteStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedUserWriteStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedUserWriteStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
             "user_creation_mode": obj.get("user_creation_mode"),
             "create_users_as_inactive": obj.get("create_users_as_inactive"),
             "create_users_group": obj.get("create_users_group"),
             "user_type": obj.get("user_type"),
             "user_path_template": obj.get("user_path_template")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/patched_web_authn_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/contextual_flow_info.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,59 +14,82 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.contextual_flow_info_layout_enum import ContextualFlowInfoLayoutEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, constr
-
-class PatchedWebAuthnDeviceRequest(BaseModel):
-    """
-    Serializer for WebAuthn authenticator devices  # noqa: E501
+class ContextualFlowInfo(BaseModel):
     """
-    name: Optional[constr(strict=True, max_length=200, min_length=1)] = None
-    __properties = ["name"]
+    Contextual flow information for a challenge
+    """ # noqa: E501
+    title: Optional[StrictStr] = None
+    background: Optional[StrictStr] = None
+    cancel_url: StrictStr
+    layout: ContextualFlowInfoLayoutEnum
+    __properties: ClassVar[List[str]] = ["title", "background", "cancel_url", "layout"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PatchedWebAuthnDeviceRequest:
-        """Create an instance of PatchedWebAuthnDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ContextualFlowInfo from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PatchedWebAuthnDeviceRequest:
-        """Create an instance of PatchedWebAuthnDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ContextualFlowInfo from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PatchedWebAuthnDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PatchedWebAuthnDeviceRequest.parse_obj({
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "title": obj.get("title"),
+            "background": obj.get("background"),
+            "cancel_url": obj.get("cancel_url"),
+            "layout": obj.get("layout")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_authentication_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/source_stage_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,91 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class PlexAuthenticationChallenge(BaseModel):
-    """
-    Challenge shown to the user in identification stage  # noqa: E501
+class SourceStageRequest(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-source-plex'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    client_id: StrictStr = Field(...)
-    slug: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "client_id", "slug"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SourceStage Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    flow_set: Optional[List[FlowSetRequest]] = None
+    source: StrictStr
+    resume_timeout: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)")
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "source", "resume_timeout"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlexAuthenticationChallenge:
-        """Create an instance of PlexAuthenticationChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SourceStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+        _items = []
+        if self.flow_set:
+            for _item in self.flow_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlexAuthenticationChallenge:
-        """Create an instance of PlexAuthenticationChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SourceStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlexAuthenticationChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlexAuthenticationChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-source-plex',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "client_id": obj.get("client_id"),
-            "slug": obj.get("slug")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "source": obj.get("source"),
+            "resume_timeout": obj.get("resume_timeout")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_source.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,115 +14,139 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PlexSource(BaseModel):
     """
-    Plex Source Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50) = Field(..., description="Internal source name, used in URLs.")
+    Plex Source Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr = Field(description="Source's display Name.")
+    slug: Annotated[str, Field(strict=True, max_length=50)] = Field(description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    managed: Optional[StrictStr] = Field(..., description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    managed: Optional[StrictStr] = Field(description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
     user_path_template: Optional[StrictStr] = None
-    icon: Optional[StrictStr] = Field(..., description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
-    client_id: Optional[StrictStr] = Field(None, description="Client identifier used to talk to Plex.")
-    allowed_servers: Optional[conlist(StrictStr)] = Field(None, description="Which servers a user has to be a member of to be granted access. Empty list allows every server.")
-    allow_friends: Optional[StrictBool] = Field(None, description="Allow friends to authenticate, even if you don't share a server.")
-    plex_token: StrictStr = Field(..., description="Plex token used to check friends")
-    __properties = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "client_id", "allowed_servers", "allow_friends", "plex_token"]
+    icon: Optional[StrictStr] = Field(description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
+    client_id: Optional[StrictStr] = Field(default=None, description="Client identifier used to talk to Plex.")
+    allowed_servers: Optional[List[StrictStr]] = Field(default=None, description="Which servers a user has to be a member of to be granted access. Empty list allows every server.")
+    allow_friends: Optional[StrictBool] = Field(default=None, description="Allow friends to authenticate, even if you don't share a server.")
+    plex_token: StrictStr = Field(description="Plex token used to check friends")
+    __properties: ClassVar[List[str]] = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "client_id", "allowed_servers", "allow_friends", "plex_token"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlexSource:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PlexSource from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "managed",
-                            "icon",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "managed",
+            "icon",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         # set to None if icon (nullable) is None
-        # and __fields_set__ contains the field
-        if self.icon is None and "icon" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.icon is None and "icon" in self.model_fields_set:
             _dict['icon'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlexSource:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PlexSource from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlexSource.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlexSource.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
             "component": obj.get("component"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/current_brand.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,100 +14,114 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.footer_link import FooterLink
+from authentik_client.models.ui_theme_enum import UiThemeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr, validator
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
-
-class PlexSourceRequest(BaseModel):
-    """
-    Plex Source Serializer  # noqa: E501
+class CurrentBrand(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Internal source name, used in URLs.")
-    enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    client_id: Optional[constr(strict=True, min_length=1)] = Field(None, description="Client identifier used to talk to Plex.")
-    allowed_servers: Optional[conlist(constr(strict=True, min_length=1))] = Field(None, description="Which servers a user has to be a member of to be granted access. Empty list allows every server.")
-    allow_friends: Optional[StrictBool] = Field(None, description="Allow friends to authenticate, even if you don't share a server.")
-    plex_token: constr(strict=True, min_length=1) = Field(..., description="Plex token used to check friends")
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "client_id", "allowed_servers", "allow_friends", "plex_token"]
-
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Partial brand information for styling
+    """ # noqa: E501
+    matched_domain: StrictStr
+    branding_title: StrictStr
+    branding_logo: StrictStr
+    branding_favicon: StrictStr
+    ui_footer_links: List[FooterLink]
+    ui_theme: UiThemeEnum
+    flow_authentication: Optional[StrictStr] = None
+    flow_invalidation: Optional[StrictStr] = None
+    flow_recovery: Optional[StrictStr] = None
+    flow_unenrollment: Optional[StrictStr] = None
+    flow_user_settings: Optional[StrictStr] = None
+    flow_device_code: Optional[StrictStr] = None
+    default_locale: StrictStr
+    __properties: ClassVar[List[str]] = ["matched_domain", "branding_title", "branding_logo", "branding_favicon", "ui_footer_links", "ui_theme", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "default_locale"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlexSourceRequest:
-        """Create an instance of PlexSourceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of CurrentBrand from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
-
-        # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
-            _dict['enrollment_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "ui_footer_links",
+            "ui_theme",
+            "default_locale",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in ui_footer_links (list)
+        _items = []
+        if self.ui_footer_links:
+            for _item in self.ui_footer_links:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['ui_footer_links'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlexSourceRequest:
-        """Create an instance of PlexSourceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of CurrentBrand from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlexSourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlexSourceRequest.parse_obj({
-            "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "enabled": obj.get("enabled"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "enrollment_flow": obj.get("enrollment_flow"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "user_matching_mode": obj.get("user_matching_mode"),
-            "user_path_template": obj.get("user_path_template"),
-            "client_id": obj.get("client_id"),
-            "allowed_servers": obj.get("allowed_servers"),
-            "allow_friends": obj.get("allow_friends"),
-            "plex_token": obj.get("plex_token")
+        _obj = cls.model_validate({
+            "matched_domain": obj.get("matched_domain"),
+            "branding_title": obj.get("branding_title"),
+            "branding_logo": obj.get("branding_logo"),
+            "branding_favicon": obj.get("branding_favicon"),
+            "ui_footer_links": [FooterLink.from_dict(_item) for _item in obj["ui_footer_links"]] if obj.get("ui_footer_links") is not None else None,
+            "ui_theme": obj.get("ui_theme"),
+            "flow_authentication": obj.get("flow_authentication"),
+            "flow_invalidation": obj.get("flow_invalidation"),
+            "flow_recovery": obj.get("flow_recovery"),
+            "flow_unenrollment": obj.get("flow_unenrollment"),
+            "flow_user_settings": obj.get("flow_user_settings"),
+            "flow_device_code": obj.get("flow_device_code"),
+            "default_locale": obj.get("default_locale")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/plex_token_redeem_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device_token_request.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, constr
-
-class PlexTokenRedeemRequest(BaseModel):
-    """
-    Serializer to redeem a plex token  # noqa: E501
+class StaticDeviceTokenRequest(BaseModel):
     """
-    plex_token: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["plex_token"]
+    Serializer for static device's tokens
+    """ # noqa: E501
+    token: Annotated[str, Field(min_length=1, strict=True, max_length=16)]
+    __properties: ClassVar[List[str]] = ["token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PlexTokenRedeemRequest:
-        """Create an instance of PlexTokenRedeemRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StaticDeviceTokenRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PlexTokenRedeemRequest:
-        """Create an instance of PlexTokenRedeemRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StaticDeviceTokenRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PlexTokenRedeemRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PlexTokenRedeemRequest.parse_obj({
-            "plex_token": obj.get("plex_token")
+        _obj = cls.model_validate({
+            "token": obj.get("token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/selectable_stage.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,79 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-
-class Policy(BaseModel):
-    """
-    Policy Serializer  # noqa: E501
+class SelectableStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for stages which can be selected by users
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    verbose_name: StrictStr
+    meta_model_name: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "name", "verbose_name", "meta_model_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Policy:
-        """Create an instance of Policy from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SelectableStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Policy:
-        """Create an instance of Policy from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SelectableStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Policy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Policy.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "bound_to": obj.get("bound_to")
+            "meta_model_name": obj.get("meta_model_name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_binding.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_binding.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,111 +14,132 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.group import Group
 from authentik_client.models.policy import Policy
 from authentik_client.models.user import User
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PolicyBinding(BaseModel):
     """
-    PolicyBinding Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
+    PolicyBinding Serializer
+    """ # noqa: E501
+    pk: StrictStr
     policy: Optional[StrictStr] = None
     group: Optional[StrictStr] = None
     user: Optional[StrictInt] = None
-    policy_obj: Policy = Field(...)
-    group_obj: Group = Field(...)
-    user_obj: User = Field(...)
-    target: StrictStr = Field(...)
-    negate: Optional[StrictBool] = Field(None, description="Negates the outcome of the policy. Messages are unaffected.")
+    policy_obj: Policy
+    group_obj: Group
+    user_obj: User
+    target: StrictStr
+    negate: Optional[StrictBool] = Field(default=None, description="Negates the outcome of the policy. Messages are unaffected.")
     enabled: Optional[StrictBool] = None
-    order: conint(strict=True, le=2147483647, ge=-2147483648) = Field(...)
-    timeout: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="Timeout after which Policy execution is terminated.")
-    failure_result: Optional[StrictBool] = Field(None, description="Result if the Policy execution fails.")
-    __properties = ["pk", "policy", "group", "user", "policy_obj", "group_obj", "user_obj", "target", "negate", "enabled", "order", "timeout", "failure_result"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    order: Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]
+    timeout: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=0)]] = Field(default=None, description="Timeout after which Policy execution is terminated.")
+    failure_result: Optional[StrictBool] = Field(default=None, description="Result if the Policy execution fails.")
+    __properties: ClassVar[List[str]] = ["pk", "policy", "group", "user", "policy_obj", "group_obj", "user_obj", "target", "negate", "enabled", "order", "timeout", "failure_result"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PolicyBinding:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PolicyBinding from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "policy_obj",
-                            "group_obj",
-                            "user_obj",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "policy_obj",
+            "group_obj",
+            "user_obj",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of policy_obj
         if self.policy_obj:
             _dict['policy_obj'] = self.policy_obj.to_dict()
         # override the default output from pydantic by calling `to_dict()` of group_obj
         if self.group_obj:
             _dict['group_obj'] = self.group_obj.to_dict()
         # override the default output from pydantic by calling `to_dict()` of user_obj
         if self.user_obj:
             _dict['user_obj'] = self.user_obj.to_dict()
         # set to None if policy (nullable) is None
-        # and __fields_set__ contains the field
-        if self.policy is None and "policy" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.policy is None and "policy" in self.model_fields_set:
             _dict['policy'] = None
 
         # set to None if group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.group is None and "group" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.group is None and "group" in self.model_fields_set:
             _dict['group'] = None
 
         # set to None if user (nullable) is None
-        # and __fields_set__ contains the field
-        if self.user is None and "user" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.user is None and "user" in self.model_fields_set:
             _dict['user'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PolicyBinding:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PolicyBinding from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PolicyBinding.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PolicyBinding.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "policy": obj.get("policy"),
             "group": obj.get("group"),
             "user": obj.get("user"),
-            "policy_obj": Policy.from_dict(obj.get("policy_obj")) if obj.get("policy_obj") is not None else None,
-            "group_obj": Group.from_dict(obj.get("group_obj")) if obj.get("group_obj") is not None else None,
-            "user_obj": User.from_dict(obj.get("user_obj")) if obj.get("user_obj") is not None else None,
+            "policy_obj": Policy.from_dict(obj["policy_obj"]) if obj.get("policy_obj") is not None else None,
+            "group_obj": Group.from_dict(obj["group_obj"]) if obj.get("group_obj") is not None else None,
+            "user_obj": User.from_dict(obj["user_obj"]) if obj.get("user_obj") is not None else None,
             "target": obj.get("target"),
             "negate": obj.get("negate"),
             "enabled": obj.get("enabled"),
             "order": obj.get("order"),
             "timeout": obj.get("timeout"),
             "failure_result": obj.get("failure_result")
         })
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_binding_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/reputation.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,90 +14,101 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
-
-class PolicyBindingRequest(BaseModel):
-    """
-    PolicyBinding Serializer  # noqa: E501
+class Reputation(BaseModel):
     """
-    policy: Optional[StrictStr] = None
-    group: Optional[StrictStr] = None
-    user: Optional[StrictInt] = None
-    target: StrictStr = Field(...)
-    negate: Optional[StrictBool] = Field(None, description="Negates the outcome of the policy. Messages are unaffected.")
-    enabled: Optional[StrictBool] = None
-    order: conint(strict=True, le=2147483647, ge=-2147483648) = Field(...)
-    timeout: Optional[conint(strict=True, le=2147483647, ge=0)] = Field(None, description="Timeout after which Policy execution is terminated.")
-    failure_result: Optional[StrictBool] = Field(None, description="Result if the Policy execution fails.")
-    __properties = ["policy", "group", "user", "target", "negate", "enabled", "order", "timeout", "failure_result"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Reputation Serializer
+    """ # noqa: E501
+    pk: Optional[StrictStr] = None
+    identifier: StrictStr
+    ip: StrictStr
+    ip_geo_data: Optional[Any] = None
+    ip_asn_data: Optional[Any] = None
+    score: Optional[Annotated[int, Field(le=9223372036854775807, strict=True, ge=-9223372036854775808)]] = None
+    updated: datetime
+    __properties: ClassVar[List[str]] = ["pk", "identifier", "ip", "ip_geo_data", "ip_asn_data", "score", "updated"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PolicyBindingRequest:
-        """Create an instance of PolicyBindingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Reputation from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if policy (nullable) is None
-        # and __fields_set__ contains the field
-        if self.policy is None and "policy" in self.__fields_set__:
-            _dict['policy'] = None
-
-        # set to None if group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.group is None and "group" in self.__fields_set__:
-            _dict['group'] = None
-
-        # set to None if user (nullable) is None
-        # and __fields_set__ contains the field
-        if self.user is None and "user" in self.__fields_set__:
-            _dict['user'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "updated",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if ip_geo_data (nullable) is None
+        # and model_fields_set contains the field
+        if self.ip_geo_data is None and "ip_geo_data" in self.model_fields_set:
+            _dict['ip_geo_data'] = None
+
+        # set to None if ip_asn_data (nullable) is None
+        # and model_fields_set contains the field
+        if self.ip_asn_data is None and "ip_asn_data" in self.model_fields_set:
+            _dict['ip_asn_data'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PolicyBindingRequest:
-        """Create an instance of PolicyBindingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Reputation from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PolicyBindingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PolicyBindingRequest.parse_obj({
-            "policy": obj.get("policy"),
-            "group": obj.get("group"),
-            "user": obj.get("user"),
-            "target": obj.get("target"),
-            "negate": obj.get("negate"),
-            "enabled": obj.get("enabled"),
-            "order": obj.get("order"),
-            "timeout": obj.get("timeout"),
-            "failure_result": obj.get("failure_result")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "identifier": obj.get("identifier"),
+            "ip": obj.get("ip"),
+            "ip_geo_data": obj.get("ip_geo_data"),
+            "ip_asn_data": obj.get("ip_asn_data"),
+            "score": obj.get("score"),
+            "updated": obj.get("updated")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_engine_mode.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/policy_engine_mode.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,33 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class PolicyEngineMode(str, Enum):
     """
     PolicyEngineMode
     """
 
     """
     allowed enum values
     """
     ALL = 'all'
     ANY = 'any'
 
     @classmethod
-    def from_json(cls, json_str: str) -> PolicyEngineMode:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of PolicyEngineMode from a JSON string"""
-        return PolicyEngineMode(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_test_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/generic_error.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,61 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictInt
-
-class PolicyTestRequest(BaseModel):
-    """
-    Test policy execution for a user with context  # noqa: E501
+class GenericError(BaseModel):
     """
-    user: StrictInt = Field(...)
-    context: Optional[Dict[str, Any]] = None
-    __properties = ["user", "context"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Generic API Error
+    """ # noqa: E501
+    detail: StrictStr
+    code: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["detail", "code"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PolicyTestRequest:
-        """Create an instance of PolicyTestRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GenericError from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PolicyTestRequest:
-        """Create an instance of PolicyTestRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GenericError from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PolicyTestRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PolicyTestRequest.parse_obj({
-            "user": obj.get("user"),
-            "context": obj.get("context")
+        _obj = cls.model_validate({
+            "detail": obj.get("detail"),
+            "code": obj.get("code")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/policy_test_result.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_self_groups.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, List
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
-
-class PolicyTestResult(BaseModel):
-    """
-    result of a policy test  # noqa: E501
+class UserSelfGroups(BaseModel):
     """
-    passing: StrictBool = Field(...)
-    messages: conlist(StrictStr) = Field(...)
-    log_messages: conlist(Dict[str, Any]) = Field(...)
-    __properties = ["passing", "messages", "log_messages"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserSelfGroups
+    """ # noqa: E501
+    name: StrictStr
+    pk: StrictStr
+    __properties: ClassVar[List[str]] = ["name", "pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PolicyTestResult:
-        """Create an instance of PolicyTestResult from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserSelfGroups from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "messages",
-                            "log_messages",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "name",
+            "pk",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PolicyTestResult:
-        """Create an instance of PolicyTestResult from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserSelfGroups from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PolicyTestResult.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PolicyTestResult.parse_obj({
-            "passing": obj.get("passing"),
-            "messages": obj.get("messages"),
-            "log_messages": obj.get("log_messages")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "pk": obj.get("pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,93 +14,107 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.prompt_type_enum import PromptTypeEnum
-from authentik_client.models.stage import Stage
+from authentik_client.models.stage_request import StageRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Prompt(BaseModel):
-    """
-    Prompt Serializer  # noqa: E501
+class PromptRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    field_key: StrictStr = Field(..., description="Name of the form field, also used to store the value")
-    label: StrictStr = Field(...)
-    type: PromptTypeEnum = Field(...)
+    Prompt Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    field_key: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Name of the form field, also used to store the value")
+    label: Annotated[str, Field(min_length=1, strict=True)]
+    type: PromptTypeEnum
     required: Optional[StrictBool] = None
-    placeholder: Optional[StrictStr] = Field(None, description="Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.")
-    initial_value: Optional[StrictStr] = Field(None, description="Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.")
-    order: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    promptstage_set: Optional[conlist(Stage)] = None
+    placeholder: Optional[StrictStr] = Field(default=None, description="Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.")
+    initial_value: Optional[StrictStr] = Field(default=None, description="Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.")
+    order: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    promptstage_set: Optional[List[StageRequest]] = None
     sub_text: Optional[StrictStr] = None
     placeholder_expression: Optional[StrictBool] = None
     initial_value_expression: Optional[StrictBool] = None
-    __properties = ["pk", "name", "field_key", "label", "type", "required", "placeholder", "initial_value", "order", "promptstage_set", "sub_text", "placeholder_expression", "initial_value_expression"]
+    __properties: ClassVar[List[str]] = ["name", "field_key", "label", "type", "required", "placeholder", "initial_value", "order", "promptstage_set", "sub_text", "placeholder_expression", "initial_value_expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Prompt:
-        """Create an instance of Prompt from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PromptRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in promptstage_set (list)
         _items = []
         if self.promptstage_set:
             for _item in self.promptstage_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['promptstage_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Prompt:
-        """Create an instance of Prompt from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PromptRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Prompt.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Prompt.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "field_key": obj.get("field_key"),
             "label": obj.get("label"),
             "type": obj.get("type"),
             "required": obj.get("required"),
             "placeholder": obj.get("placeholder"),
             "initial_value": obj.get("initial_value"),
             "order": obj.get("order"),
-            "promptstage_set": [Stage.from_dict(_item) for _item in obj.get("promptstage_set")] if obj.get("promptstage_set") is not None else None,
+            "promptstage_set": [StageRequest.from_dict(_item) for _item in obj["promptstage_set"]] if obj.get("promptstage_set") is not None else None,
             "sub_text": obj.get("sub_text"),
             "placeholder_expression": obj.get("placeholder_expression"),
             "initial_value_expression": obj.get("initial_value_expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt_challenge.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,97 +14,113 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.challenge_choices import ChallengeChoices
 from authentik_client.models.contextual_flow_info import ContextualFlowInfo
 from authentik_client.models.error_detail import ErrorDetail
 from authentik_client.models.stage_prompt import StagePrompt
+from typing import Optional, Set
+from typing_extensions import Self
 
 class PromptChallenge(BaseModel):
     """
-    Initial challenge being sent, define fields  # noqa: E501
-    """
-    type: ChallengeChoices = Field(...)
+    Initial challenge being sent, define fields
+    """ # noqa: E501
+    type: ChallengeChoices
     flow_info: Optional[ContextualFlowInfo] = None
     component: Optional[StrictStr] = 'ak-stage-prompt'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    fields: conlist(StagePrompt) = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "fields"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    response_errors: Optional[Dict[str, List[ErrorDetail]]] = None
+    fields: List[StagePrompt]
+    __properties: ClassVar[List[str]] = ["type", "flow_info", "component", "response_errors", "fields"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PromptChallenge:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of PromptChallenge from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of flow_info
         if self.flow_info:
             _dict['flow_info'] = self.flow_info.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
         _field_dict_of_array = {}
         if self.response_errors:
             for _key in self.response_errors:
-                if self.response_errors[_key]:
+                if self.response_errors[_key] is not None:
                     _field_dict_of_array[_key] = [
                         _item.to_dict() for _item in self.response_errors[_key]
                     ]
             _dict['response_errors'] = _field_dict_of_array
         # override the default output from pydantic by calling `to_dict()` of each item in fields (list)
         _items = []
         if self.fields:
             for _item in self.fields:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['fields'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PromptChallenge:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of PromptChallenge from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PromptChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PromptChallenge.parse_obj({
+        _obj = cls.model_validate({
             "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
+            "flow_info": ContextualFlowInfo.from_dict(obj["flow_info"]) if obj.get("flow_info") is not None else None,
             "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-prompt',
             "response_errors": dict(
                 (_k,
                         [ErrorDetail.from_dict(_item) for _item in _v]
                         if _v is not None
                         else None
                 )
-                for _k, _v in obj.get("response_errors").items()
+                for _k, _v in obj.get("response_errors", {}).items()
             ),
-            "fields": [StagePrompt.from_dict(_item) for _item in obj.get("fields")] if obj.get("fields") is not None else None
+            "fields": [StagePrompt.from_dict(_item) for _item in obj["fields"]] if obj.get("fields") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/device_challenge_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,71 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, constr
-
-class PromptChallengeResponseRequest(BaseModel):
-    """
-    Validate response, fields are dynamically created based on the stage  # noqa: E501
+class DeviceChallengeRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-prompt'
-    additional_properties: Dict[str, Any] = {}
-    __properties = ["component"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Single device challenge
+    """ # noqa: E501
+    device_class: Annotated[str, Field(min_length=1, strict=True)]
+    device_uid: Annotated[str, Field(min_length=1, strict=True)]
+    challenge: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["device_class", "device_uid", "challenge"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PromptChallengeResponseRequest:
-        """Create an instance of PromptChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DeviceChallengeRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "additional_properties"
-                          },
-                          exclude_none=True)
-        # puts key-value pairs in additional_properties in the top level
-        if self.additional_properties is not None:
-            for _key, _value in self.additional_properties.items():
-                _dict[_key] = _value
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PromptChallengeResponseRequest:
-        """Create an instance of PromptChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DeviceChallengeRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PromptChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PromptChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-prompt'
+        _obj = cls.model_validate({
+            "device_class": obj.get("device_class"),
+            "device_uid": obj.get("device_uid"),
+            "challenge": obj.get("challenge")
         })
-        # store additional fields in additional_properties
-        for _key in obj.keys():
-            if _key not in cls.__properties:
-                _obj.additional_properties[_key] = obj.get(_key)
-
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/prompt.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,90 +14,111 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.prompt_type_enum import PromptTypeEnum
-from authentik_client.models.stage_request import StageRequest
+from authentik_client.models.stage import Stage
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PromptRequest(BaseModel):
-    """
-    Prompt Serializer  # noqa: E501
+class Prompt(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    field_key: constr(strict=True, min_length=1) = Field(..., description="Name of the form field, also used to store the value")
-    label: constr(strict=True, min_length=1) = Field(...)
-    type: PromptTypeEnum = Field(...)
+    Prompt Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    field_key: StrictStr = Field(description="Name of the form field, also used to store the value")
+    label: StrictStr
+    type: PromptTypeEnum
     required: Optional[StrictBool] = None
-    placeholder: Optional[StrictStr] = Field(None, description="Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.")
-    initial_value: Optional[StrictStr] = Field(None, description="Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.")
-    order: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    promptstage_set: Optional[conlist(StageRequest)] = None
+    placeholder: Optional[StrictStr] = Field(default=None, description="Optionally provide a short hint that describes the expected input value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple choices.")
+    initial_value: Optional[StrictStr] = Field(default=None, description="Optionally pre-fill the input with an initial value. When creating a fixed choice field, enable interpreting as expression and return a list to return multiple default choices.")
+    order: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    promptstage_set: Optional[List[Stage]] = None
     sub_text: Optional[StrictStr] = None
     placeholder_expression: Optional[StrictBool] = None
     initial_value_expression: Optional[StrictBool] = None
-    __properties = ["name", "field_key", "label", "type", "required", "placeholder", "initial_value", "order", "promptstage_set", "sub_text", "placeholder_expression", "initial_value_expression"]
+    __properties: ClassVar[List[str]] = ["pk", "name", "field_key", "label", "type", "required", "placeholder", "initial_value", "order", "promptstage_set", "sub_text", "placeholder_expression", "initial_value_expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PromptRequest:
-        """Create an instance of PromptRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Prompt from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in promptstage_set (list)
         _items = []
         if self.promptstage_set:
             for _item in self.promptstage_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['promptstage_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PromptRequest:
-        """Create an instance of PromptRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Prompt from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PromptRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PromptRequest.parse_obj({
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
             "name": obj.get("name"),
             "field_key": obj.get("field_key"),
             "label": obj.get("label"),
             "type": obj.get("type"),
             "required": obj.get("required"),
             "placeholder": obj.get("placeholder"),
             "initial_value": obj.get("initial_value"),
             "order": obj.get("order"),
-            "promptstage_set": [StageRequest.from_dict(_item) for _item in obj.get("promptstage_set")] if obj.get("promptstage_set") is not None else None,
+            "promptstage_set": [Stage.from_dict(_item) for _item in obj["promptstage_set"]] if obj.get("promptstage_set") is not None else None,
             "sub_text": obj.get("sub_text"),
             "placeholder_expression": obj.get("placeholder_expression"),
             "initial_value_expression": obj.get("initial_value_expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_delete_stage.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,88 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
-class PromptStage(BaseModel):
-    """
-    PromptStage Serializer  # noqa: E501
+class UserDeleteStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    fields: conlist(StrictStr) = Field(...)
-    validation_policies: Optional[conlist(StrictStr)] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "fields", "validation_policies"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserDeleteStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PromptStage:
-        """Create an instance of PromptStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserDeleteStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PromptStage:
-        """Create an instance of PromptStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserDeleteStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PromptStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PromptStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "fields": obj.get("fields"),
-            "validation_policies": obj.get("validation_policies")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/web_authn_device.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,73 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class PromptStageRequest(BaseModel):
-    """
-    PromptStage Serializer  # noqa: E501
+class WebAuthnDevice(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    fields: conlist(StrictStr) = Field(...)
-    validation_policies: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "flow_set", "fields", "validation_policies"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for WebAuthn authenticator devices
+    """ # noqa: E501
+    pk: StrictInt
+    name: Annotated[str, Field(strict=True, max_length=200)]
+    created_on: datetime
+    __properties: ClassVar[List[str]] = ["pk", "name", "created_on"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PromptStageRequest:
-        """Create an instance of PromptStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of WebAuthnDevice from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "created_on",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PromptStageRequest:
-        """Create an instance of PromptStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of WebAuthnDevice from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PromptStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PromptStageRequest.parse_obj({
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "fields": obj.get("fields"),
-            "validation_policies": obj.get("validation_policies")
+            "created_on": obj.get("created_on")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/prompt_type_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/capabilities_enum.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,49 +9,34 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class PromptTypeEnum(str, Enum):
+class CapabilitiesEnum(str, Enum):
     """
-    PromptTypeEnum
+    CapabilitiesEnum
     """
 
     """
     allowed enum values
     """
-    TEXT = 'text'
-    TEXT_AREA = 'text_area'
-    TEXT_READ_ONLY = 'text_read_only'
-    TEXT_AREA_READ_ONLY = 'text_area_read_only'
-    USERNAME = 'username'
-    EMAIL = 'email'
-    PASSWORD = 'password'
-    NUMBER = 'number'
-    CHECKBOX = 'checkbox'
-    RADIO_MINUS_BUTTON_MINUS_GROUP = 'radio-button-group'
-    DROPDOWN = 'dropdown'
-    DATE = 'date'
-    DATE_MINUS_TIME = 'date-time'
-    FILE = 'file'
-    SEPARATOR = 'separator'
-    HIDDEN = 'hidden'
-    STATIC = 'static'
-    AK_MINUS_LOCALE = 'ak-locale'
+    CAN_SAVE_MEDIA = 'can_save_media'
+    CAN_GEO_IP = 'can_geo_ip'
+    CAN_ASN = 'can_asn'
+    CAN_IMPERSONATE = 'can_impersonate'
+    CAN_DEBUG = 'can_debug'
+    IS_ENTERPRISE = 'is_enterprise'
 
     @classmethod
-    def from_json(cls, json_str: str) -> PromptTypeEnum:
-        """Create an instance of PromptTypeEnum from a JSON string"""
-        return PromptTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of CapabilitiesEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/property_mapping_preview.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_webhook_mapping_request.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,60 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict
-from pydantic import BaseModel, Field
-
-class PropertyMappingPreview(BaseModel):
-    """
-    Preview how the current user is mapped via the property mappings selected in a provider  # noqa: E501
+class NotificationWebhookMappingRequest(BaseModel):
     """
-    preview: Dict[str, Any] = Field(...)
-    __properties = ["preview"]
+    NotificationWebhookMapping Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    expression: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["name", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PropertyMappingPreview:
-        """Create an instance of PropertyMappingPreview from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationWebhookMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "preview",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PropertyMappingPreview:
-        """Create an instance of PropertyMappingPreview from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationWebhookMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PropertyMappingPreview.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PropertyMappingPreview.parse_obj({
-            "preview": obj.get("preview")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "expression": obj.get("expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/property_mapping_test_result.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/domain_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,63 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-
-class PropertyMappingTestResult(BaseModel):
-    """
-    Result of a Property-mapping test  # noqa: E501
+class DomainRequest(BaseModel):
     """
-    result: StrictStr = Field(...)
-    successful: StrictBool = Field(...)
-    __properties = ["result", "successful"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Domain Serializer
+    """ # noqa: E501
+    domain: Annotated[str, Field(min_length=1, strict=True, max_length=253)]
+    is_primary: Optional[StrictBool] = None
+    tenant: StrictStr
+    __properties: ClassVar[List[str]] = ["domain", "is_primary", "tenant"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PropertyMappingTestResult:
-        """Create an instance of PropertyMappingTestResult from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DomainRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "result",
-                            "successful",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PropertyMappingTestResult:
-        """Create an instance of PropertyMappingTestResult from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DomainRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return PropertyMappingTestResult.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = PropertyMappingTestResult.parse_obj({
-            "result": obj.get("result"),
-            "successful": obj.get("successful")
+        _obj = cls.model_validate({
+            "domain": obj.get("domain"),
+            "is_primary": obj.get("is_primary"),
+            "tenant": obj.get("tenant")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/protocol_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/protocol_enum.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ProtocolEnum(str, Enum):
     """
     ProtocolEnum
     """
 
@@ -31,12 +28,12 @@
     allowed enum values
     """
     RDP = 'rdp'
     VNC = 'vnc'
     SSH = 'ssh'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProtocolEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ProtocolEnum from a JSON string"""
-        return ProtocolEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/provider.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,87 +14,112 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Provider(BaseModel):
     """
-    Provider Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    __properties = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Provider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    assigned_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_application_name: StrictStr = Field(description="Application's display Name.")
+    assigned_backchannel_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_backchannel_application_name: StrictStr = Field(description="Application's display Name.")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    __properties: ClassVar[List[str]] = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Provider:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Provider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "assigned_application_slug",
+            "assigned_application_name",
+            "assigned_backchannel_application_slug",
+            "assigned_backchannel_application_name",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Provider:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Provider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Provider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Provider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "component": obj.get("component"),
             "assigned_application_slug": obj.get("assigned_application_slug"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_model_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/provider_model_enum.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ProviderModelEnum(str, Enum):
     """
     ProviderModelEnum
     """
 
@@ -35,12 +32,12 @@
     AUTHENTIK_PROVIDERS_PROXY_DOT_PROXYPROVIDER = 'authentik_providers_proxy.proxyprovider'
     AUTHENTIK_PROVIDERS_RAC_DOT_RACPROVIDER = 'authentik_providers_rac.racprovider'
     AUTHENTIK_PROVIDERS_RADIUS_DOT_RADIUSPROVIDER = 'authentik_providers_radius.radiusprovider'
     AUTHENTIK_PROVIDERS_SAML_DOT_SAMLPROVIDER = 'authentik_providers_saml.samlprovider'
     AUTHENTIK_PROVIDERS_SCIM_DOT_SCIMPROVIDER = 'authentik_providers_scim.scimprovider'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProviderModelEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ProviderModelEnum from a JSON string"""
-        return ProviderModelEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/flow_inspection.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,70 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.flow_inspector_plan import FlowInspectorPlan
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-
-class ProviderRequest(BaseModel):
-    """
-    Provider Serializer  # noqa: E501
+class FlowInspection(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for inspect endpoint
+    """ # noqa: E501
+    plans: List[FlowInspectorPlan]
+    current_plan: Optional[FlowInspectorPlan] = None
+    is_completed: StrictBool
+    __properties: ClassVar[List[str]] = ["plans", "current_plan", "is_completed"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProviderRequest:
-        """Create an instance of ProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FlowInspection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in plans (list)
+        _items = []
+        if self.plans:
+            for _item in self.plans:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['plans'] = _items
+        # override the default output from pydantic by calling `to_dict()` of current_plan
+        if self.current_plan:
+            _dict['current_plan'] = self.current_plan.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProviderRequest:
-        """Create an instance of ProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FlowInspection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProviderRequest.parse_obj({
-            "name": obj.get("name"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings")
+        _obj = cls.model_validate({
+            "plans": [FlowInspectorPlan.from_dict(_item) for _item in obj["plans"]] if obj.get("plans") is not None else None,
+            "current_plan": FlowInspectorPlan.from_dict(obj["current_plan"]) if obj.get("current_plan") is not None else None,
+            "is_completed": obj.get("is_completed")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/provider_type_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/digits_enum.py`

 * *Files 27% similar despite different names*

```diff
@@ -9,45 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ProviderTypeEnum(str, Enum):
+class DigitsEnum(str, Enum):
     """
-    ProviderTypeEnum
+    DigitsEnum
     """
 
     """
     allowed enum values
     """
-    APPLE = 'apple'
-    OPENIDCONNECT = 'openidconnect'
-    AZUREAD = 'azuread'
-    DISCORD = 'discord'
-    FACEBOOK = 'facebook'
-    GITHUB = 'github'
-    GITLAB = 'gitlab'
-    GOOGLE = 'google'
-    MAILCOW = 'mailcow'
-    OKTA = 'okta'
-    PATREON = 'patreon'
-    REDDIT = 'reddit'
-    TWITCH = 'twitch'
-    TWITTER = 'twitter'
+    ENUM_6 = '6'
+    ENUM_8 = '8'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProviderTypeEnum:
-        """Create an instance of ProviderTypeEnum from a JSON string"""
-        return ProviderTypeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of DigitsEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_mode.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/challenge_choices.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,34 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class ProxyMode(str, Enum):
+class ChallengeChoices(str, Enum):
     """
-    ProxyMode
+    ChallengeChoices
     """
 
     """
     allowed enum values
     """
-    PROXY = 'proxy'
-    FORWARD_SINGLE = 'forward_single'
-    FORWARD_DOMAIN = 'forward_domain'
+    NATIVE = 'native'
+    SHELL = 'shell'
+    REDIRECT = 'redirect'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProxyMode:
-        """Create an instance of ProxyMode from a JSON string"""
-        return ProxyMode(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of ChallengeChoices from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_outpost_config.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_outpost_config.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,110 +14,133 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional, Union
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional, Union
+from typing_extensions import Annotated
 from authentik_client.models.open_id_connect_configuration import OpenIDConnectConfiguration
 from authentik_client.models.proxy_mode import ProxyMode
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ProxyOutpostConfig(BaseModel):
     """
-    Proxy provider serializer for outposts  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
+    Proxy provider serializer for outposts
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
     internal_host: Optional[StrictStr] = None
-    external_host: StrictStr = Field(...)
-    internal_host_ssl_validation: Optional[StrictBool] = Field(None, description="Validate SSL Certificates of upstream servers")
-    client_id: Optional[constr(strict=True, max_length=255)] = None
-    client_secret: Optional[constr(strict=True, max_length=255)] = None
-    oidc_configuration: OpenIDConnectConfiguration = Field(...)
+    external_host: StrictStr
+    internal_host_ssl_validation: Optional[StrictBool] = Field(default=None, description="Validate SSL Certificates of upstream servers")
+    client_id: Optional[Annotated[str, Field(strict=True, max_length=255)]] = None
+    client_secret: Optional[Annotated[str, Field(strict=True, max_length=255)]] = None
+    oidc_configuration: OpenIDConnectConfiguration
     cookie_secret: Optional[StrictStr] = None
     certificate: Optional[StrictStr] = None
-    skip_path_regex: Optional[StrictStr] = Field(None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
-    basic_auth_enabled: Optional[StrictBool] = Field(None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
-    basic_auth_password_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
-    basic_auth_user_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
-    mode: Optional[ProxyMode] = Field(None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
+    skip_path_regex: Optional[StrictStr] = Field(default=None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
+    basic_auth_enabled: Optional[StrictBool] = Field(default=None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
+    basic_auth_password_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
+    basic_auth_user_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
+    mode: Optional[ProxyMode] = Field(default=None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
     cookie_domain: Optional[StrictStr] = None
-    access_token_validity: Optional[Union[StrictFloat, StrictInt]] = Field(..., description="Get token validity as second count")
-    intercept_header_auth: Optional[StrictBool] = Field(None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
-    scopes_to_request: conlist(StrictStr) = Field(..., description="Get all the scope names the outpost should request, including custom-defined ones")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    __properties = ["pk", "name", "internal_host", "external_host", "internal_host_ssl_validation", "client_id", "client_secret", "oidc_configuration", "cookie_secret", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "cookie_domain", "access_token_validity", "intercept_header_auth", "scopes_to_request", "assigned_application_slug", "assigned_application_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    access_token_validity: Optional[Union[StrictFloat, StrictInt]] = Field(description="Get token validity as second count")
+    intercept_header_auth: Optional[StrictBool] = Field(default=None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
+    scopes_to_request: List[StrictStr] = Field(description="Get all the scope names the outpost should request, including custom-defined ones")
+    assigned_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_application_name: StrictStr = Field(description="Application's display Name.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "internal_host", "external_host", "internal_host_ssl_validation", "client_id", "client_secret", "oidc_configuration", "cookie_secret", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "cookie_domain", "access_token_validity", "intercept_header_auth", "scopes_to_request", "assigned_application_slug", "assigned_application_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProxyOutpostConfig:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ProxyOutpostConfig from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "oidc_configuration",
-                            "access_token_validity",
-                            "scopes_to_request",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "oidc_configuration",
+            "access_token_validity",
+            "scopes_to_request",
+            "assigned_application_slug",
+            "assigned_application_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of oidc_configuration
         if self.oidc_configuration:
             _dict['oidc_configuration'] = self.oidc_configuration.to_dict()
         # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.certificate is None and "certificate" in self.model_fields_set:
             _dict['certificate'] = None
 
         # set to None if access_token_validity (nullable) is None
-        # and __fields_set__ contains the field
-        if self.access_token_validity is None and "access_token_validity" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.access_token_validity is None and "access_token_validity" in self.model_fields_set:
             _dict['access_token_validity'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProxyOutpostConfig:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ProxyOutpostConfig from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProxyOutpostConfig.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProxyOutpostConfig.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "internal_host": obj.get("internal_host"),
             "external_host": obj.get("external_host"),
             "internal_host_ssl_validation": obj.get("internal_host_ssl_validation"),
             "client_id": obj.get("client_id"),
             "client_secret": obj.get("client_secret"),
-            "oidc_configuration": OpenIDConnectConfiguration.from_dict(obj.get("oidc_configuration")) if obj.get("oidc_configuration") is not None else None,
+            "oidc_configuration": OpenIDConnectConfiguration.from_dict(obj["oidc_configuration"]) if obj.get("oidc_configuration") is not None else None,
             "cookie_secret": obj.get("cookie_secret"),
             "certificate": obj.get("certificate"),
             "skip_path_regex": obj.get("skip_path_regex"),
             "basic_auth_enabled": obj.get("basic_auth_enabled"),
             "basic_auth_password_attribute": obj.get("basic_auth_password_attribute"),
             "basic_auth_user_attribute": obj.get("basic_auth_user_attribute"),
             "mode": obj.get("mode"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/proxy_provider.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,113 +14,141 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.proxy_mode import ProxyMode
+from typing import Optional, Set
+from typing_extensions import Self
 
 class ProxyProvider(BaseModel):
     """
-    ProxyProvider Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    client_id: StrictStr = Field(...)
+    ProxyProvider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    assigned_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_application_name: StrictStr = Field(description="Application's display Name.")
+    assigned_backchannel_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_backchannel_application_name: StrictStr = Field(description="Application's display Name.")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    client_id: StrictStr
     internal_host: Optional[StrictStr] = None
-    external_host: StrictStr = Field(...)
-    internal_host_ssl_validation: Optional[StrictBool] = Field(None, description="Validate SSL Certificates of upstream servers")
+    external_host: StrictStr
+    internal_host_ssl_validation: Optional[StrictBool] = Field(default=None, description="Validate SSL Certificates of upstream servers")
     certificate: Optional[StrictStr] = None
-    skip_path_regex: Optional[StrictStr] = Field(None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
-    basic_auth_enabled: Optional[StrictBool] = Field(None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
-    basic_auth_password_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
-    basic_auth_user_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
-    mode: Optional[ProxyMode] = Field(None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
-    intercept_header_auth: Optional[StrictBool] = Field(None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
-    redirect_uris: StrictStr = Field(...)
+    skip_path_regex: Optional[StrictStr] = Field(default=None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
+    basic_auth_enabled: Optional[StrictBool] = Field(default=None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
+    basic_auth_password_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
+    basic_auth_user_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
+    mode: Optional[ProxyMode] = Field(default=None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
+    intercept_header_auth: Optional[StrictBool] = Field(default=None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
+    redirect_uris: StrictStr
     cookie_domain: Optional[StrictStr] = None
-    jwks_sources: Optional[conlist(StrictStr)] = None
-    access_token_validity: Optional[StrictStr] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    refresh_token_validity: Optional[StrictStr] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    outpost_set: conlist(StrictStr) = Field(...)
-    __properties = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "client_id", "internal_host", "external_host", "internal_host_ssl_validation", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "intercept_header_auth", "redirect_uris", "cookie_domain", "jwks_sources", "access_token_validity", "refresh_token_validity", "outpost_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    jwks_sources: Optional[List[StrictStr]] = None
+    access_token_validity: Optional[StrictStr] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    refresh_token_validity: Optional[StrictStr] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    outpost_set: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "client_id", "internal_host", "external_host", "internal_host_ssl_validation", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "intercept_header_auth", "redirect_uris", "cookie_domain", "jwks_sources", "access_token_validity", "refresh_token_validity", "outpost_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProxyProvider:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of ProxyProvider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "client_id",
-                            "redirect_uris",
-                            "outpost_set",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "assigned_application_slug",
+            "assigned_application_name",
+            "assigned_backchannel_application_slug",
+            "assigned_backchannel_application_name",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "client_id",
+            "redirect_uris",
+            "outpost_set",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.certificate is None and "certificate" in self.model_fields_set:
             _dict['certificate'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProxyProvider:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of ProxyProvider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProxyProvider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProxyProvider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "component": obj.get("component"),
             "assigned_application_slug": obj.get("assigned_application_slug"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/proxy_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_proxy_provider_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,89 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.proxy_mode import ProxyMode
+from typing import Optional, Set
+from typing_extensions import Self
 
-class ProxyProviderRequest(BaseModel):
-    """
-    ProxyProvider Serializer  # noqa: E501
+class PatchedProxyProviderRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
+    ProxyProvider Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: Optional[StrictStr] = Field(default=None, description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
     internal_host: Optional[StrictStr] = None
-    external_host: constr(strict=True, min_length=1) = Field(...)
-    internal_host_ssl_validation: Optional[StrictBool] = Field(None, description="Validate SSL Certificates of upstream servers")
+    external_host: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    internal_host_ssl_validation: Optional[StrictBool] = Field(default=None, description="Validate SSL Certificates of upstream servers")
     certificate: Optional[StrictStr] = None
-    skip_path_regex: Optional[StrictStr] = Field(None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
-    basic_auth_enabled: Optional[StrictBool] = Field(None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
-    basic_auth_password_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
-    basic_auth_user_attribute: Optional[StrictStr] = Field(None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
-    mode: Optional[ProxyMode] = Field(None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
-    intercept_header_auth: Optional[StrictBool] = Field(None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
+    skip_path_regex: Optional[StrictStr] = Field(default=None, description="Regular expressions for which authentication is not required. Each new line is interpreted as a new Regular Expression.")
+    basic_auth_enabled: Optional[StrictBool] = Field(default=None, description="Set a custom HTTP-Basic Authentication header based on values from authentik.")
+    basic_auth_password_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the password part of the HTTP-Basic Header.")
+    basic_auth_user_attribute: Optional[StrictStr] = Field(default=None, description="User/Group Attribute used for the user part of the HTTP-Basic Header. If not set, the user's Email address is used.")
+    mode: Optional[ProxyMode] = Field(default=None, description="Enable support for forwardAuth in traefik and nginx auth_request. Exclusive with internal_host.")
+    intercept_header_auth: Optional[StrictBool] = Field(default=None, description="When enabled, this provider will intercept the authorization header and authenticate requests based on its value.")
     cookie_domain: Optional[StrictStr] = None
-    jwks_sources: Optional[conlist(StrictStr)] = None
-    access_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    refresh_token_validity: Optional[constr(strict=True, min_length=1)] = Field(None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "internal_host", "external_host", "internal_host_ssl_validation", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "intercept_header_auth", "cookie_domain", "jwks_sources", "access_token_validity", "refresh_token_validity"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    jwks_sources: Optional[List[StrictStr]] = None
+    access_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    refresh_token_validity: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Tokens not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    __properties: ClassVar[List[str]] = ["name", "authentication_flow", "authorization_flow", "property_mappings", "internal_host", "external_host", "internal_host_ssl_validation", "certificate", "skip_path_regex", "basic_auth_enabled", "basic_auth_password_attribute", "basic_auth_user_attribute", "mode", "intercept_header_auth", "cookie_domain", "jwks_sources", "access_token_validity", "refresh_token_validity"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ProxyProviderRequest:
-        """Create an instance of ProxyProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedProxyProviderRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if certificate (nullable) is None
-        # and __fields_set__ contains the field
-        if self.certificate is None and "certificate" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.certificate is None and "certificate" in self.model_fields_set:
             _dict['certificate'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ProxyProviderRequest:
-        """Create an instance of ProxyProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedProxyProviderRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ProxyProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ProxyProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "internal_host": obj.get("internal_host"),
             "external_host": obj.get("external_host"),
             "internal_host_ssl_validation": obj.get("internal_host_ssl_validation"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/rac_property_mapping.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_object_permission.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,85 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictStr
-
-class RACPropertyMapping(BaseModel):
-    """
-    RACPropertyMapping Serializer  # noqa: E501
+class UserObjectPermission(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    managed: Optional[StrictStr] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: StrictStr = Field(...)
-    expression: Optional[StrictStr] = None
-    component: StrictStr = Field(..., description="Get object's component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    static_settings: Dict[str, Any] = Field(...)
-    __properties = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "static_settings"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User-bound object level permission
+    """ # noqa: E501
+    id: StrictInt
+    codename: StrictStr
+    model: StrictStr
+    app_label: StrictStr
+    object_pk: StrictStr
+    name: StrictStr
+    __properties: ClassVar[List[str]] = ["id", "codename", "model", "app_label", "object_pk", "name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RACPropertyMapping:
-        """Create an instance of RACPropertyMapping from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserObjectPermission from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "id",
+            "codename",
+            "model",
+            "app_label",
+            "object_pk",
+            "name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RACPropertyMapping:
-        """Create an instance of RACPropertyMapping from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserObjectPermission from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RACPropertyMapping.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RACPropertyMapping.parse_obj({
-            "pk": obj.get("pk"),
-            "managed": obj.get("managed"),
-            "name": obj.get("name"),
-            "expression": obj.get("expression"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "static_settings": obj.get("static_settings")
+        _obj = cls.model_validate({
+            "id": obj.get("id"),
+            "codename": obj.get("codename"),
+            "model": obj.get("model"),
+            "app_label": obj.get("app_label"),
+            "object_pk": obj.get("object_pk"),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/rac_property_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/tenant_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,70 +14,80 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class RACPropertyMappingRequest(BaseModel):
-    """
-    RACPropertyMapping Serializer  # noqa: E501
+class TenantRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: constr(strict=True, min_length=1) = Field(...)
-    expression: Optional[StrictStr] = None
-    static_settings: Dict[str, Any] = Field(...)
-    __properties = ["managed", "name", "expression", "static_settings"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Tenant Serializer
+    """ # noqa: E501
+    schema_name: Annotated[str, Field(min_length=1, strict=True, max_length=63)]
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    ready: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["schema_name", "name", "ready"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RACPropertyMappingRequest:
-        """Create an instance of RACPropertyMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TenantRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RACPropertyMappingRequest:
-        """Create an instance of RACPropertyMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TenantRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RACPropertyMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RACPropertyMappingRequest.parse_obj({
-            "managed": obj.get("managed"),
+        _obj = cls.model_validate({
+            "schema_name": obj.get("schema_name"),
             "name": obj.get("name"),
-            "expression": obj.get("expression"),
-            "static_settings": obj.get("static_settings")
+            "ready": obj.get("ready")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/radius_outpost_config.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_webhook_mapping.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,72 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-
-class RadiusOutpostConfig(BaseModel):
-    """
-    RadiusProvider Serializer  # noqa: E501
+class NotificationWebhookMapping(BaseModel):
     """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    application_slug: StrictStr = Field(...)
-    auth_flow_slug: StrictStr = Field(...)
-    client_networks: Optional[StrictStr] = Field(None, description="List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.")
-    shared_secret: Optional[StrictStr] = Field(None, description="Shared secret between clients and server to hash packets.")
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["pk", "name", "application_slug", "auth_flow_slug", "client_networks", "shared_secret", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationWebhookMapping Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    expression: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "name", "expression"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RadiusOutpostConfig:
-        """Create an instance of RadiusOutpostConfig from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationWebhookMapping from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RadiusOutpostConfig:
-        """Create an instance of RadiusOutpostConfig from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationWebhookMapping from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RadiusOutpostConfig.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RadiusOutpostConfig.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
-            "application_slug": obj.get("application_slug"),
-            "auth_flow_slug": obj.get("auth_flow_slug"),
-            "client_networks": obj.get("client_networks"),
-            "shared_secret": obj.get("shared_secret"),
-            "mfa_support": obj.get("mfa_support")
+            "expression": obj.get("expression")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/radius_provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/scim_provider.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,106 +14,120 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
-
-class RadiusProvider(BaseModel):
-    """
-    RadiusProvider Serializer  # noqa: E501
+class SCIMProvider(BaseModel):
     """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    client_networks: Optional[StrictStr] = Field(None, description="List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.")
-    shared_secret: Optional[StrictStr] = Field(None, description="Shared secret between clients and server to hash packets.")
-    outpost_set: conlist(StrictStr) = Field(...)
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "client_networks", "shared_secret", "outpost_set", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SCIMProvider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    property_mappings: Optional[List[StrictStr]] = None
+    property_mappings_group: Optional[List[StrictStr]] = Field(default=None, description="Property mappings used for group creation/updating.")
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    assigned_backchannel_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_backchannel_application_name: StrictStr = Field(description="Application's display Name.")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    url: StrictStr = Field(description="Base URL to SCIM requests, usually ends in /v2")
+    token: StrictStr = Field(description="Authentication token")
+    exclude_users_service_account: Optional[StrictBool] = None
+    filter_group: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "property_mappings", "property_mappings_group", "component", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "url", "token", "exclude_users_service_account", "filter_group"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RadiusProvider:
-        """Create an instance of RadiusProvider from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SCIMProvider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "outpost_set",
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "assigned_backchannel_application_slug",
+            "assigned_backchannel_application_name",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if filter_group (nullable) is None
+        # and model_fields_set contains the field
+        if self.filter_group is None and "filter_group" in self.model_fields_set:
+            _dict['filter_group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RadiusProvider:
-        """Create an instance of RadiusProvider from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SCIMProvider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RadiusProvider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RadiusProvider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
+            "property_mappings_group": obj.get("property_mappings_group"),
             "component": obj.get("component"),
-            "assigned_application_slug": obj.get("assigned_application_slug"),
-            "assigned_application_name": obj.get("assigned_application_name"),
             "assigned_backchannel_application_slug": obj.get("assigned_backchannel_application_slug"),
             "assigned_backchannel_application_name": obj.get("assigned_backchannel_application_name"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "client_networks": obj.get("client_networks"),
-            "shared_secret": obj.get("shared_secret"),
-            "outpost_set": obj.get("outpost_set"),
-            "mfa_support": obj.get("mfa_support")
+            "url": obj.get("url"),
+            "token": obj.get("token"),
+            "exclude_users_service_account": obj.get("exclude_users_service_account"),
+            "filter_group": obj.get("filter_group")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/radius_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_captcha_stage_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,76 +14,94 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-
-class RadiusProviderRequest(BaseModel):
-    """
-    RadiusProvider Serializer  # noqa: E501
+class PatchedCaptchaStageRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    client_networks: Optional[constr(strict=True, min_length=1)] = Field(None, description="List of CIDRs (comma-separated) that clients can connect from. A more specific CIDR will match before a looser one. Clients connecting from a non-specified CIDR will be dropped.")
-    shared_secret: Optional[constr(strict=True, min_length=1)] = Field(None, description="Shared secret between clients and server to hash packets.")
-    mfa_support: Optional[StrictBool] = Field(None, description="When enabled, code-based multi-factor authentication can be used by appending a semicolon and the TOTP code to the password. This should only be enabled if all users that will bind to this provider have a TOTP device configured, as otherwise a password may incorrectly be rejected if it contains a semicolon.")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "client_networks", "shared_secret", "mfa_support"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    CaptchaStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    public_key: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Public key, acquired your captcha Provider.")
+    private_key: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Private key, acquired your captcha Provider.")
+    js_url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    api_url: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "public_key", "private_key", "js_url", "api_url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RadiusProviderRequest:
-        """Create an instance of RadiusProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedCaptchaStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+        _items = []
+        if self.flow_set:
+            for _item in self.flow_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RadiusProviderRequest:
-        """Create an instance of RadiusProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedCaptchaStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RadiusProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RadiusProviderRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings"),
-            "client_networks": obj.get("client_networks"),
-            "shared_secret": obj.get("shared_secret"),
-            "mfa_support": obj.get("mfa_support")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "public_key": obj.get("public_key"),
+            "private_key": obj.get("private_key"),
+            "js_url": obj.get("js_url"),
+            "api_url": obj.get("api_url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/redirect_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/o_auth2_provider_setup_urls.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,89 +14,101 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class RedirectChallenge(BaseModel):
-    """
-    Challenge type to redirect the client  # noqa: E501
+class OAuth2ProviderSetupURLs(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'xak-flow-redirect'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    to: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "to"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth2 Provider Metadata serializer
+    """ # noqa: E501
+    issuer: StrictStr
+    authorize: StrictStr
+    token: StrictStr
+    user_info: StrictStr
+    provider_info: StrictStr
+    logout: StrictStr
+    jwks: StrictStr
+    __properties: ClassVar[List[str]] = ["issuer", "authorize", "token", "user_info", "provider_info", "logout", "jwks"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RedirectChallenge:
-        """Create an instance of RedirectChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OAuth2ProviderSetupURLs from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "issuer",
+            "authorize",
+            "token",
+            "user_info",
+            "provider_info",
+            "logout",
+            "jwks",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RedirectChallenge:
-        """Create an instance of RedirectChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OAuth2ProviderSetupURLs from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return RedirectChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = RedirectChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'xak-flow-redirect',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "to": obj.get("to")
+        _obj = cls.model_validate({
+            "issuer": obj.get("issuer"),
+            "authorize": obj.get("authorize"),
+            "token": obj.get("token"),
+            "user_info": obj.get("user_info"),
+            "provider_info": obj.get("provider_info"),
+            "logout": obj.get("logout"),
+            "jwks": obj.get("jwks")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/reputation.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_o_auth_source_connection.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,82 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictStr, conint
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from authentik_client.models.source import Source
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Reputation(BaseModel):
+class UserOAuthSourceConnection(BaseModel):
     """
-    Reputation Serializer  # noqa: E501
-    """
-    pk: Optional[StrictStr] = None
-    identifier: StrictStr = Field(...)
-    ip: StrictStr = Field(...)
-    ip_geo_data: Optional[Any] = None
-    ip_asn_data: Optional[Any] = None
-    score: Optional[conint(strict=True, le=9223372036854775807, ge=-9223372036854775808)] = None
-    updated: datetime = Field(...)
-    __properties = ["pk", "identifier", "ip", "ip_geo_data", "ip_asn_data", "score", "updated"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth Source Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    user: StrictInt
+    source: Source
+    identifier: Annotated[str, Field(strict=True, max_length=255)]
+    __properties: ClassVar[List[str]] = ["pk", "user", "source", "identifier"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Reputation:
-        """Create an instance of Reputation from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserOAuthSourceConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "updated",
-                          },
-                          exclude_none=True)
-        # set to None if ip_geo_data (nullable) is None
-        # and __fields_set__ contains the field
-        if self.ip_geo_data is None and "ip_geo_data" in self.__fields_set__:
-            _dict['ip_geo_data'] = None
-
-        # set to None if ip_asn_data (nullable) is None
-        # and __fields_set__ contains the field
-        if self.ip_asn_data is None and "ip_asn_data" in self.__fields_set__:
-            _dict['ip_asn_data'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "source",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of source
+        if self.source:
+            _dict['source'] = self.source.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Reputation:
-        """Create an instance of Reputation from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserOAuthSourceConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Reputation.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Reputation.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "identifier": obj.get("identifier"),
-            "ip": obj.get("ip"),
-            "ip_geo_data": obj.get("ip_geo_data"),
-            "ip_asn_data": obj.get("ip_asn_data"),
-            "score": obj.get("score"),
-            "updated": obj.get("updated")
+            "user": obj.get("user"),
+            "source": Source.from_dict(obj["source"]) if obj.get("source") is not None else None,
+            "identifier": obj.get("identifier")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/reputation_policy.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_policy_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,85 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint
-
-class ReputationPolicy(BaseModel):
-    """
-    Reputation Policy Serializer  # noqa: E501
+class DummyPolicyRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    bound_to: StrictInt = Field(..., description="Return objects policy is bound to")
-    check_ip: Optional[StrictBool] = None
-    check_username: Optional[StrictBool] = None
-    threshold: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["pk", "name", "execution_logging", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "bound_to", "check_ip", "check_username", "threshold"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Dummy Policy Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    result: Optional[StrictBool] = None
+    wait_min: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    wait_max: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "result", "wait_min", "wait_max"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReputationPolicy:
-        """Create an instance of ReputationPolicy from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DummyPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "bound_to",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReputationPolicy:
-        """Create an instance of ReputationPolicy from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DummyPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReputationPolicy.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReputationPolicy.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "execution_logging": obj.get("execution_logging"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "bound_to": obj.get("bound_to"),
-            "check_ip": obj.get("check_ip"),
-            "check_username": obj.get("check_username"),
-            "threshold": obj.get("threshold")
+            "result": obj.get("result"),
+            "wait_min": obj.get("wait_min"),
+            "wait_max": obj.get("wait_max")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/reputation_policy_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/connection_token_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,67 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, conint, constr
-
-class ReputationPolicyRequest(BaseModel):
-    """
-    Reputation Policy Serializer  # noqa: E501
+class ConnectionTokenRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    execution_logging: Optional[StrictBool] = Field(None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
-    check_ip: Optional[StrictBool] = None
-    check_username: Optional[StrictBool] = None
-    threshold: Optional[conint(strict=True, le=2147483647, ge=-2147483648)] = None
-    __properties = ["name", "execution_logging", "check_ip", "check_username", "threshold"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ConnectionToken Serializer
+    """ # noqa: E501
+    pk: Optional[StrictStr] = None
+    provider: StrictInt
+    endpoint: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "provider", "endpoint"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ReputationPolicyRequest:
-        """Create an instance of ReputationPolicyRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ConnectionTokenRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ReputationPolicyRequest:
-        """Create an instance of ReputationPolicyRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ConnectionTokenRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ReputationPolicyRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ReputationPolicyRequest.parse_obj({
-            "name": obj.get("name"),
-            "execution_logging": obj.get("execution_logging"),
-            "check_ip": obj.get("check_ip"),
-            "check_username": obj.get("check_username"),
-            "threshold": obj.get("threshold")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "provider": obj.get("provider"),
+            "endpoint": obj.get("endpoint")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/resident_key_requirement_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/resident_key_requirement_enum.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class ResidentKeyRequirementEnum(str, Enum):
     """
     ResidentKeyRequirementEnum
     """
 
@@ -31,12 +28,12 @@
     allowed enum values
     """
     DISCOURAGED = 'discouraged'
     PREFERRED = 'preferred'
     REQUIRED = 'required'
 
     @classmethod
-    def from_json(cls, json_str: str) -> ResidentKeyRequirementEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of ResidentKeyRequirementEnum from a JSON string"""
-        return ResidentKeyRequirementEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/role.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/system_info_runtime.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,62 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class Role(BaseModel):
-    """
-    Role serializer  # noqa: E501
+class SystemInfoRuntime(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: constr(strict=True, max_length=150) = Field(...)
-    __properties = ["pk", "name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Get versions
+    """ # noqa: E501
+    python_version: StrictStr
+    gunicorn_version: StrictStr
+    environment: StrictStr
+    architecture: StrictStr
+    platform: StrictStr
+    uname: StrictStr
+    __properties: ClassVar[List[str]] = ["python_version", "gunicorn_version", "environment", "architecture", "platform", "uname"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Role:
-        """Create an instance of Role from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SystemInfoRuntime from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Role:
-        """Create an instance of Role from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SystemInfoRuntime from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Role.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Role.parse_obj({
-            "pk": obj.get("pk"),
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "python_version": obj.get("python_version"),
+            "gunicorn_version": obj.get("gunicorn_version"),
+            "environment": obj.get("environment"),
+            "architecture": obj.get("architecture"),
+            "platform": obj.get("platform"),
+            "uname": obj.get("uname")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_metadata.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/error_detail.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,63 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class SAMLMetadata(BaseModel):
-    """
-    SAML Provider Metadata serializer  # noqa: E501
+class ErrorDetail(BaseModel):
     """
-    metadata: StrictStr = Field(...)
-    download_url: StrictStr = Field(...)
-    __properties = ["metadata", "download_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for rest_framework's error messages
+    """ # noqa: E501
+    string: StrictStr
+    code: StrictStr
+    __properties: ClassVar[List[str]] = ["string", "code"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SAMLMetadata:
-        """Create an instance of SAMLMetadata from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ErrorDetail from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "metadata",
-                            "download_url",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SAMLMetadata:
-        """Create an instance of SAMLMetadata from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ErrorDetail from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SAMLMetadata.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SAMLMetadata.parse_obj({
-            "metadata": obj.get("metadata"),
-            "download_url": obj.get("download_url")
+        _obj = cls.model_validate({
+            "string": obj.get("string"),
+            "code": obj.get("code")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_property_mapping.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/ldap_property_mapping.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,92 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-
-class SAMLPropertyMapping(BaseModel):
-    """
-    SAMLPropertyMapping Serializer  # noqa: E501
+class LDAPPropertyMapping(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    managed: Optional[StrictStr] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: StrictStr = Field(...)
-    expression: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object's component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    saml_name: StrictStr = Field(...)
-    friendly_name: Optional[StrictStr] = None
-    __properties = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "saml_name", "friendly_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    LDAP PropertyMapping Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    managed: Optional[StrictStr] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: StrictStr
+    expression: StrictStr
+    component: StrictStr = Field(description="Get object's component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    object_field: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "object_field"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SAMLPropertyMapping:
-        """Create an instance of SAMLPropertyMapping from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LDAPPropertyMapping from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SAMLPropertyMapping:
-        """Create an instance of SAMLPropertyMapping from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LDAPPropertyMapping from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SAMLPropertyMapping.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SAMLPropertyMapping.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "saml_name": obj.get("saml_name"),
-            "friendly_name": obj.get("friendly_name")
+            "object_field": obj.get("object_field")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_property_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/endpoint_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,77 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.auth_mode_enum import AuthModeEnum
+from authentik_client.models.protocol_enum import ProtocolEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class SAMLPropertyMappingRequest(BaseModel):
-    """
-    SAMLPropertyMapping Serializer  # noqa: E501
+class EndpointRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: constr(strict=True, min_length=1) = Field(...)
-    expression: constr(strict=True, min_length=1) = Field(...)
-    saml_name: constr(strict=True, min_length=1) = Field(...)
-    friendly_name: Optional[StrictStr] = None
-    __properties = ["managed", "name", "expression", "saml_name", "friendly_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Endpoint Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    provider: StrictInt
+    protocol: ProtocolEnum
+    host: Annotated[str, Field(min_length=1, strict=True)]
+    settings: Optional[Any] = None
+    property_mappings: Optional[List[StrictStr]] = None
+    auth_mode: AuthModeEnum
+    maximum_connections: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    __properties: ClassVar[List[str]] = ["name", "provider", "protocol", "host", "settings", "property_mappings", "auth_mode", "maximum_connections"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SAMLPropertyMappingRequest:
-        """Create an instance of SAMLPropertyMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of EndpointRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
-
-        # set to None if friendly_name (nullable) is None
-        # and __fields_set__ contains the field
-        if self.friendly_name is None and "friendly_name" in self.__fields_set__:
-            _dict['friendly_name'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if settings (nullable) is None
+        # and model_fields_set contains the field
+        if self.settings is None and "settings" in self.model_fields_set:
+            _dict['settings'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SAMLPropertyMappingRequest:
-        """Create an instance of SAMLPropertyMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of EndpointRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SAMLPropertyMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SAMLPropertyMappingRequest.parse_obj({
-            "managed": obj.get("managed"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "expression": obj.get("expression"),
-            "saml_name": obj.get("saml_name"),
-            "friendly_name": obj.get("friendly_name")
+            "provider": obj.get("provider"),
+            "protocol": obj.get("protocol"),
+            "host": obj.get("host"),
+            "settings": obj.get("settings"),
+            "property_mappings": obj.get("property_mappings"),
+            "auth_mode": obj.get("auth_mode"),
+            "maximum_connections": obj.get("maximum_connections")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_provider.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,130 +14,162 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.digest_algorithm_enum import DigestAlgorithmEnum
 from authentik_client.models.signature_algorithm_enum import SignatureAlgorithmEnum
 from authentik_client.models.sp_binding_enum import SpBindingEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SAMLProvider(BaseModel):
     """
-    SAMLProvider Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_application_name: StrictStr = Field(..., description="Application's display Name.")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    acs_url: constr(strict=True, max_length=200) = Field(...)
-    audience: Optional[StrictStr] = Field(None, description="Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.")
-    issuer: Optional[StrictStr] = Field(None, description="Also known as EntityID")
-    assertion_valid_not_before: Optional[StrictStr] = Field(None, description="Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).")
-    assertion_valid_not_on_or_after: Optional[StrictStr] = Field(None, description="Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    session_valid_not_on_or_after: Optional[StrictStr] = Field(None, description="Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    name_id_mapping: Optional[StrictStr] = Field(None, description="Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered")
+    SAMLProvider Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    name: StrictStr
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
+    authorization_flow: StrictStr = Field(description="Flow used when authorizing this provider.")
+    property_mappings: Optional[List[StrictStr]] = None
+    component: StrictStr = Field(description="Get object component so that we know how to edit the object")
+    assigned_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_application_name: StrictStr = Field(description="Application's display Name.")
+    assigned_backchannel_application_slug: StrictStr = Field(description="Internal application name, used in URLs.")
+    assigned_backchannel_application_name: StrictStr = Field(description="Application's display Name.")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    acs_url: Annotated[str, Field(strict=True, max_length=200)]
+    audience: Optional[StrictStr] = Field(default=None, description="Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.")
+    issuer: Optional[StrictStr] = Field(default=None, description="Also known as EntityID")
+    assertion_valid_not_before: Optional[StrictStr] = Field(default=None, description="Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).")
+    assertion_valid_not_on_or_after: Optional[StrictStr] = Field(default=None, description="Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    session_valid_not_on_or_after: Optional[StrictStr] = Field(default=None, description="Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
+    name_id_mapping: Optional[StrictStr] = Field(default=None, description="Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered")
     digest_algorithm: Optional[DigestAlgorithmEnum] = None
     signature_algorithm: Optional[SignatureAlgorithmEnum] = None
-    signing_kp: Optional[StrictStr] = Field(None, description="Keypair used to sign outgoing Responses going to the Service Provider.")
-    verification_kp: Optional[StrictStr] = Field(None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
-    sp_binding: Optional[SpBindingEnum] = Field(None, description="This determines how authentik sends the response back to the Service Provider.")
-    default_relay_state: Optional[StrictStr] = Field(None, description="Default relay_state value for IDP-initiated logins")
-    url_download_metadata: StrictStr = Field(..., description="Get metadata download URL")
-    url_sso_post: StrictStr = Field(..., description="Get SSO Post URL")
-    url_sso_redirect: StrictStr = Field(..., description="Get SSO Redirect URL")
-    url_sso_init: StrictStr = Field(..., description="Get SSO IDP-Initiated URL")
-    url_slo_post: StrictStr = Field(..., description="Get SLO POST URL")
-    url_slo_redirect: StrictStr = Field(..., description="Get SLO redirect URL")
-    __properties = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "acs_url", "audience", "issuer", "assertion_valid_not_before", "assertion_valid_not_on_or_after", "session_valid_not_on_or_after", "name_id_mapping", "digest_algorithm", "signature_algorithm", "signing_kp", "verification_kp", "sp_binding", "default_relay_state", "url_download_metadata", "url_sso_post", "url_sso_redirect", "url_sso_init", "url_slo_post", "url_slo_redirect"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    signing_kp: Optional[StrictStr] = Field(default=None, description="Keypair used to sign outgoing Responses going to the Service Provider.")
+    verification_kp: Optional[StrictStr] = Field(default=None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
+    sp_binding: Optional[SpBindingEnum] = Field(default=None, description="This determines how authentik sends the response back to the Service Provider.")
+    default_relay_state: Optional[StrictStr] = Field(default=None, description="Default relay_state value for IDP-initiated logins")
+    url_download_metadata: StrictStr = Field(description="Get metadata download URL")
+    url_sso_post: StrictStr = Field(description="Get SSO Post URL")
+    url_sso_redirect: StrictStr = Field(description="Get SSO Redirect URL")
+    url_sso_init: StrictStr = Field(description="Get SSO IDP-Initiated URL")
+    url_slo_post: StrictStr = Field(description="Get SLO POST URL")
+    url_slo_redirect: StrictStr = Field(description="Get SLO redirect URL")
+    __properties: ClassVar[List[str]] = ["pk", "name", "authentication_flow", "authorization_flow", "property_mappings", "component", "assigned_application_slug", "assigned_application_name", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "acs_url", "audience", "issuer", "assertion_valid_not_before", "assertion_valid_not_on_or_after", "session_valid_not_on_or_after", "name_id_mapping", "digest_algorithm", "signature_algorithm", "signing_kp", "verification_kp", "sp_binding", "default_relay_state", "url_download_metadata", "url_sso_post", "url_sso_redirect", "url_sso_init", "url_slo_post", "url_slo_redirect"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SAMLProvider:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SAMLProvider from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_application_slug",
-                            "assigned_application_name",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "url_download_metadata",
-                            "url_sso_post",
-                            "url_sso_redirect",
-                            "url_sso_init",
-                            "url_slo_post",
-                            "url_slo_redirect",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "assigned_application_slug",
+            "assigned_application_name",
+            "assigned_backchannel_application_slug",
+            "assigned_backchannel_application_name",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+            "url_download_metadata",
+            "url_sso_post",
+            "url_sso_redirect",
+            "url_sso_init",
+            "url_slo_post",
+            "url_slo_redirect",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if name_id_mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.name_id_mapping is None and "name_id_mapping" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.name_id_mapping is None and "name_id_mapping" in self.model_fields_set:
             _dict['name_id_mapping'] = None
 
         # set to None if signing_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_kp is None and "signing_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_kp is None and "signing_kp" in self.model_fields_set:
             _dict['signing_kp'] = None
 
         # set to None if verification_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.verification_kp is None and "verification_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.verification_kp is None and "verification_kp" in self.model_fields_set:
             _dict['verification_kp'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SAMLProvider:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SAMLProvider from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SAMLProvider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SAMLProvider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "authentication_flow": obj.get("authentication_flow"),
             "authorization_flow": obj.get("authorization_flow"),
             "property_mappings": obj.get("property_mappings"),
             "component": obj.get("component"),
             "assigned_application_slug": obj.get("assigned_application_slug"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/brand_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,114 +14,140 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.digest_algorithm_enum import DigestAlgorithmEnum
-from authentik_client.models.signature_algorithm_enum import SignatureAlgorithmEnum
-from authentik_client.models.sp_binding_enum import SpBindingEnum
-
-class SAMLProviderRequest(BaseModel):
-    """
-    SAMLProvider Serializer  # noqa: E501
+class BrandRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow used for authentication when the associated application is accessed by an un-authenticated user.")
-    authorization_flow: StrictStr = Field(..., description="Flow used when authorizing this provider.")
-    property_mappings: Optional[conlist(StrictStr)] = None
-    acs_url: constr(strict=True, max_length=200, min_length=1) = Field(...)
-    audience: Optional[StrictStr] = Field(None, description="Value of the audience restriction field of the assertion. When left empty, no audience restriction will be added.")
-    issuer: Optional[constr(strict=True, min_length=1)] = Field(None, description="Also known as EntityID")
-    assertion_valid_not_before: Optional[constr(strict=True, min_length=1)] = Field(None, description="Assertion valid not before current time + this value (Format: hours=-1;minutes=-2;seconds=-3).")
-    assertion_valid_not_on_or_after: Optional[constr(strict=True, min_length=1)] = Field(None, description="Assertion not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    session_valid_not_on_or_after: Optional[constr(strict=True, min_length=1)] = Field(None, description="Session not valid on or after current time + this value (Format: hours=1;minutes=2;seconds=3).")
-    name_id_mapping: Optional[StrictStr] = Field(None, description="Configure how the NameID value will be created. When left empty, the NameIDPolicy of the incoming request will be considered")
-    digest_algorithm: Optional[DigestAlgorithmEnum] = None
-    signature_algorithm: Optional[SignatureAlgorithmEnum] = None
-    signing_kp: Optional[StrictStr] = Field(None, description="Keypair used to sign outgoing Responses going to the Service Provider.")
-    verification_kp: Optional[StrictStr] = Field(None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
-    sp_binding: Optional[SpBindingEnum] = Field(None, description="This determines how authentik sends the response back to the Service Provider.")
-    default_relay_state: Optional[StrictStr] = Field(None, description="Default relay_state value for IDP-initiated logins")
-    __properties = ["name", "authentication_flow", "authorization_flow", "property_mappings", "acs_url", "audience", "issuer", "assertion_valid_not_before", "assertion_valid_not_on_or_after", "session_valid_not_on_or_after", "name_id_mapping", "digest_algorithm", "signature_algorithm", "signing_kp", "verification_kp", "sp_binding", "default_relay_state"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Brand Serializer
+    """ # noqa: E501
+    domain: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Domain that activates this brand. Can be a superset, i.e. `a.b` for `aa.b` and `ba.b`")
+    default: Optional[StrictBool] = None
+    branding_title: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    branding_logo: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    branding_favicon: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_authentication: Optional[StrictStr] = None
+    flow_invalidation: Optional[StrictStr] = None
+    flow_recovery: Optional[StrictStr] = None
+    flow_unenrollment: Optional[StrictStr] = None
+    flow_user_settings: Optional[StrictStr] = None
+    flow_device_code: Optional[StrictStr] = None
+    web_certificate: Optional[StrictStr] = Field(default=None, description="Web Certificate used by the authentik Core webserver.")
+    attributes: Optional[Any] = None
+    __properties: ClassVar[List[str]] = ["domain", "default", "branding_title", "branding_logo", "branding_favicon", "flow_authentication", "flow_invalidation", "flow_recovery", "flow_unenrollment", "flow_user_settings", "flow_device_code", "web_certificate", "attributes"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SAMLProviderRequest:
-        """Create an instance of SAMLProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of BrandRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
-
-        # set to None if name_id_mapping (nullable) is None
-        # and __fields_set__ contains the field
-        if self.name_id_mapping is None and "name_id_mapping" in self.__fields_set__:
-            _dict['name_id_mapping'] = None
-
-        # set to None if signing_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_kp is None and "signing_kp" in self.__fields_set__:
-            _dict['signing_kp'] = None
-
-        # set to None if verification_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.verification_kp is None and "verification_kp" in self.__fields_set__:
-            _dict['verification_kp'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if flow_authentication (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow_authentication is None and "flow_authentication" in self.model_fields_set:
+            _dict['flow_authentication'] = None
+
+        # set to None if flow_invalidation (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow_invalidation is None and "flow_invalidation" in self.model_fields_set:
+            _dict['flow_invalidation'] = None
+
+        # set to None if flow_recovery (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow_recovery is None and "flow_recovery" in self.model_fields_set:
+            _dict['flow_recovery'] = None
+
+        # set to None if flow_unenrollment (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow_unenrollment is None and "flow_unenrollment" in self.model_fields_set:
+            _dict['flow_unenrollment'] = None
+
+        # set to None if flow_user_settings (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow_user_settings is None and "flow_user_settings" in self.model_fields_set:
+            _dict['flow_user_settings'] = None
+
+        # set to None if flow_device_code (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow_device_code is None and "flow_device_code" in self.model_fields_set:
+            _dict['flow_device_code'] = None
+
+        # set to None if web_certificate (nullable) is None
+        # and model_fields_set contains the field
+        if self.web_certificate is None and "web_certificate" in self.model_fields_set:
+            _dict['web_certificate'] = None
+
+        # set to None if attributes (nullable) is None
+        # and model_fields_set contains the field
+        if self.attributes is None and "attributes" in self.model_fields_set:
+            _dict['attributes'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SAMLProviderRequest:
-        """Create an instance of SAMLProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of BrandRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SAMLProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SAMLProviderRequest.parse_obj({
-            "name": obj.get("name"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "authorization_flow": obj.get("authorization_flow"),
-            "property_mappings": obj.get("property_mappings"),
-            "acs_url": obj.get("acs_url"),
-            "audience": obj.get("audience"),
-            "issuer": obj.get("issuer"),
-            "assertion_valid_not_before": obj.get("assertion_valid_not_before"),
-            "assertion_valid_not_on_or_after": obj.get("assertion_valid_not_on_or_after"),
-            "session_valid_not_on_or_after": obj.get("session_valid_not_on_or_after"),
-            "name_id_mapping": obj.get("name_id_mapping"),
-            "digest_algorithm": obj.get("digest_algorithm"),
-            "signature_algorithm": obj.get("signature_algorithm"),
-            "signing_kp": obj.get("signing_kp"),
-            "verification_kp": obj.get("verification_kp"),
-            "sp_binding": obj.get("sp_binding"),
-            "default_relay_state": obj.get("default_relay_state")
+        _obj = cls.model_validate({
+            "domain": obj.get("domain"),
+            "default": obj.get("default"),
+            "branding_title": obj.get("branding_title"),
+            "branding_logo": obj.get("branding_logo"),
+            "branding_favicon": obj.get("branding_favicon"),
+            "flow_authentication": obj.get("flow_authentication"),
+            "flow_invalidation": obj.get("flow_invalidation"),
+            "flow_recovery": obj.get("flow_recovery"),
+            "flow_unenrollment": obj.get("flow_unenrollment"),
+            "flow_user_settings": obj.get("flow_user_settings"),
+            "flow_device_code": obj.get("flow_device_code"),
+            "web_certificate": obj.get("web_certificate"),
+            "attributes": obj.get("attributes")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/saml_source.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_saml_source_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,157 +14,146 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.binding_type_enum import BindingTypeEnum
 from authentik_client.models.digest_algorithm_enum import DigestAlgorithmEnum
 from authentik_client.models.name_id_policy_enum import NameIdPolicyEnum
 from authentik_client.models.policy_engine_mode import PolicyEngineMode
 from authentik_client.models.signature_algorithm_enum import SignatureAlgorithmEnum
 from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SAMLSource(BaseModel):
-    """
-    SAMLSource Serializer  # noqa: E501
+class PatchedSAMLSourceRequest(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50) = Field(..., description="Internal source name, used in URLs.")
+    SAMLSource Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Source's display Name.")
+    slug: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="Internal source name, used in URLs.")
     enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
+    authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when authenticating existing users.")
+    enrollment_flow: Optional[StrictStr] = Field(default=None, description="Flow to use when enrolling new users.")
     policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    managed: Optional[StrictStr] = Field(..., description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    user_path_template: Optional[StrictStr] = None
-    icon: Optional[StrictStr] = Field(..., description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
-    pre_authentication_flow: StrictStr = Field(..., description="Flow used before authentication.")
-    issuer: Optional[StrictStr] = Field(None, description="Also known as Entity ID. Defaults the Metadata URL.")
-    sso_url: constr(strict=True, max_length=200) = Field(..., description="URL that the initial Login request is sent to.")
-    slo_url: Optional[constr(strict=True, max_length=200)] = Field(None, description="Optional URL if your IDP supports Single-Logout.")
-    allow_idp_initiated: Optional[StrictBool] = Field(None, description="Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.")
-    name_id_policy: Optional[NameIdPolicyEnum] = Field(None, description="NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.")
+    user_matching_mode: Optional[UserMatchingModeEnum] = Field(default=None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
+    user_path_template: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    pre_authentication_flow: Optional[StrictStr] = Field(default=None, description="Flow used before authentication.")
+    issuer: Optional[StrictStr] = Field(default=None, description="Also known as Entity ID. Defaults the Metadata URL.")
+    sso_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(default=None, description="URL that the initial Login request is sent to.")
+    slo_url: Optional[Annotated[str, Field(strict=True, max_length=200)]] = Field(default=None, description="Optional URL if your IDP supports Single-Logout.")
+    allow_idp_initiated: Optional[StrictBool] = Field(default=None, description="Allows authentication flows initiated by the IdP. This can be a security risk, as no validation of the request ID is done.")
+    name_id_policy: Optional[NameIdPolicyEnum] = Field(default=None, description="NameID Policy sent to the IdP. Can be unset, in which case no Policy is sent.")
     binding_type: Optional[BindingTypeEnum] = None
-    verification_kp: Optional[StrictStr] = Field(None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
-    signing_kp: Optional[StrictStr] = Field(None, description="Keypair used to sign outgoing Responses going to the Identity Provider.")
+    verification_kp: Optional[StrictStr] = Field(default=None, description="When selected, incoming assertion's Signatures will be validated against this certificate. To allow unsigned Requests, leave on default.")
+    signing_kp: Optional[StrictStr] = Field(default=None, description="Keypair used to sign outgoing Responses going to the Identity Provider.")
     digest_algorithm: Optional[DigestAlgorithmEnum] = None
     signature_algorithm: Optional[SignatureAlgorithmEnum] = None
-    temporary_user_delete_after: Optional[StrictStr] = Field(None, description="Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).")
-    __properties = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon", "pre_authentication_flow", "issuer", "sso_url", "slo_url", "allow_idp_initiated", "name_id_policy", "binding_type", "verification_kp", "signing_kp", "digest_algorithm", "signature_algorithm", "temporary_user_delete_after"]
+    temporary_user_delete_after: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Time offset when temporary users should be deleted. This only applies if your IDP uses the NameID Format 'transient', and the user doesn't log out manually. (Format: hours=1;minutes=2;seconds=3).")
+    __properties: ClassVar[List[str]] = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template", "pre_authentication_flow", "issuer", "sso_url", "slo_url", "allow_idp_initiated", "name_id_policy", "binding_type", "verification_kp", "signing_kp", "digest_algorithm", "signature_algorithm", "temporary_user_delete_after"]
 
-    @validator('slug')
+    @field_validator('slug')
     def slug_validate_regular_expression(cls, value):
         """Validates the regular expression"""
+        if value is None:
+            return value
+
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SAMLSource:
-        """Create an instance of SAMLSource from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedSAMLSourceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "managed",
-                            "icon",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authentication_flow is None and "authentication_flow" in self.model_fields_set:
             _dict['authentication_flow'] = None
 
         # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.enrollment_flow is None and "enrollment_flow" in self.model_fields_set:
             _dict['enrollment_flow'] = None
 
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
-
-        # set to None if icon (nullable) is None
-        # and __fields_set__ contains the field
-        if self.icon is None and "icon" in self.__fields_set__:
-            _dict['icon'] = None
-
         # set to None if slo_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.slo_url is None and "slo_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.slo_url is None and "slo_url" in self.model_fields_set:
             _dict['slo_url'] = None
 
         # set to None if verification_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.verification_kp is None and "verification_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.verification_kp is None and "verification_kp" in self.model_fields_set:
             _dict['verification_kp'] = None
 
         # set to None if signing_kp (nullable) is None
-        # and __fields_set__ contains the field
-        if self.signing_kp is None and "signing_kp" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.signing_kp is None and "signing_kp" in self.model_fields_set:
             _dict['signing_kp'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SAMLSource:
-        """Create an instance of SAMLSource from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedSAMLSourceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SAMLSource.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SAMLSource.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "slug": obj.get("slug"),
             "enabled": obj.get("enabled"),
             "authentication_flow": obj.get("authentication_flow"),
             "enrollment_flow": obj.get("enrollment_flow"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
             "policy_engine_mode": obj.get("policy_engine_mode"),
             "user_matching_mode": obj.get("user_matching_mode"),
-            "managed": obj.get("managed"),
             "user_path_template": obj.get("user_path_template"),
-            "icon": obj.get("icon"),
             "pre_authentication_flow": obj.get("pre_authentication_flow"),
             "issuer": obj.get("issuer"),
             "sso_url": obj.get("sso_url"),
             "slo_url": obj.get("slo_url"),
             "allow_idp_initiated": obj.get("allow_idp_initiated"),
             "name_id_policy": obj.get("name_id_policy"),
             "binding_type": obj.get("binding_type"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/dummy_challenge_response_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,68 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, constr
-
-class SCIMMappingRequest(BaseModel):
-    """
-    SCIMMapping Serializer  # noqa: E501
+class DummyChallengeResponseRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: constr(strict=True, min_length=1) = Field(...)
-    expression: constr(strict=True, min_length=1) = Field(...)
-    __properties = ["managed", "name", "expression"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Dummy challenge response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-dummy'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SCIMMappingRequest:
-        """Create an instance of SCIMMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DummyChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SCIMMappingRequest:
-        """Create an instance of SCIMMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DummyChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SCIMMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SCIMMappingRequest.parse_obj({
-            "managed": obj.get("managed"),
-            "name": obj.get("name"),
-            "expression": obj.get("expression")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-dummy'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_provider.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/property_mapping.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,97 +14,104 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
-
-class SCIMProvider(BaseModel):
-    """
-    SCIMProvider Serializer  # noqa: E501
+class PropertyMapping(BaseModel):
     """
-    pk: StrictInt = Field(...)
-    name: StrictStr = Field(...)
-    property_mappings: Optional[conlist(StrictStr)] = None
-    property_mappings_group: Optional[conlist(StrictStr)] = Field(None, description="Property mappings used for group creation/updating.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    assigned_backchannel_application_slug: StrictStr = Field(..., description="Internal application name, used in URLs.")
-    assigned_backchannel_application_name: StrictStr = Field(..., description="Application's display Name.")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    url: StrictStr = Field(..., description="Base URL to SCIM requests, usually ends in /v2")
-    token: StrictStr = Field(..., description="Authentication token")
-    exclude_users_service_account: Optional[StrictBool] = None
-    filter_group: Optional[StrictStr] = None
-    __properties = ["pk", "name", "property_mappings", "property_mappings_group", "component", "assigned_backchannel_application_slug", "assigned_backchannel_application_name", "verbose_name", "verbose_name_plural", "meta_model_name", "url", "token", "exclude_users_service_account", "filter_group"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PropertyMapping Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    managed: Optional[StrictStr] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: StrictStr
+    expression: StrictStr
+    component: StrictStr = Field(description="Get object's component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    __properties: ClassVar[List[str]] = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SCIMProvider:
-        """Create an instance of SCIMProvider from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PropertyMapping from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "assigned_backchannel_application_slug",
-                            "assigned_backchannel_application_name",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # set to None if filter_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.filter_group is None and "filter_group" in self.__fields_set__:
-            _dict['filter_group'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if managed (nullable) is None
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
+            _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SCIMProvider:
-        """Create an instance of SCIMProvider from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PropertyMapping from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SCIMProvider.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SCIMProvider.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
+            "managed": obj.get("managed"),
             "name": obj.get("name"),
-            "property_mappings": obj.get("property_mappings"),
-            "property_mappings_group": obj.get("property_mappings_group"),
+            "expression": obj.get("expression"),
             "component": obj.get("component"),
-            "assigned_backchannel_application_slug": obj.get("assigned_backchannel_application_slug"),
-            "assigned_backchannel_application_name": obj.get("assigned_backchannel_application_name"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "url": obj.get("url"),
-            "token": obj.get("token"),
-            "exclude_users_service_account": obj.get("exclude_users_service_account"),
-            "filter_group": obj.get("filter_group")
+            "meta_model_name": obj.get("meta_model_name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/scim_provider_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_o_auth_source_connection_request.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,76 +14,85 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-
-class SCIMProviderRequest(BaseModel):
-    """
-    SCIMProvider Serializer  # noqa: E501
+class PatchedUserOAuthSourceConnectionRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    property_mappings: Optional[conlist(StrictStr)] = None
-    property_mappings_group: Optional[conlist(StrictStr)] = Field(None, description="Property mappings used for group creation/updating.")
-    url: constr(strict=True, min_length=1) = Field(..., description="Base URL to SCIM requests, usually ends in /v2")
-    token: constr(strict=True, min_length=1) = Field(..., description="Authentication token")
-    exclude_users_service_account: Optional[StrictBool] = None
-    filter_group: Optional[StrictStr] = None
-    __properties = ["name", "property_mappings", "property_mappings_group", "url", "token", "exclude_users_service_account", "filter_group"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    OAuth Source Serializer
+    """ # noqa: E501
+    user: Optional[StrictInt] = None
+    identifier: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = None
+    access_token: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["user", "identifier", "access_token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SCIMProviderRequest:
-        """Create an instance of SCIMProviderRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedUserOAuthSourceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if filter_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.filter_group is None and "filter_group" in self.__fields_set__:
-            _dict['filter_group'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if access_token (nullable) is None
+        # and model_fields_set contains the field
+        if self.access_token is None and "access_token" in self.model_fields_set:
+            _dict['access_token'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SCIMProviderRequest:
-        """Create an instance of SCIMProviderRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedUserOAuthSourceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SCIMProviderRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SCIMProviderRequest.parse_obj({
-            "name": obj.get("name"),
-            "property_mappings": obj.get("property_mappings"),
-            "property_mappings_group": obj.get("property_mappings_group"),
-            "url": obj.get("url"),
-            "token": obj.get("token"),
-            "exclude_users_service_account": obj.get("exclude_users_service_account"),
-            "filter_group": obj.get("filter_group")
+        _obj = cls.model_validate({
+            "user": obj.get("user"),
+            "identifier": obj.get("identifier"),
+            "access_token": obj.get("access_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/scope_mapping.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/rac_property_mapping.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,87 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
-
-class ScopeMapping(BaseModel):
-    """
-    ScopeMapping Serializer  # noqa: E501
+class RACPropertyMapping(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    managed: Optional[StrictStr] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: StrictStr = Field(...)
-    expression: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object's component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    scope_name: StrictStr = Field(..., description="Scope name requested by the client")
-    description: Optional[StrictStr] = Field(None, description="Description shown to the user when consenting. If left empty, the user won't be informed.")
-    __properties = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "scope_name", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    RACPropertyMapping Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    managed: Optional[StrictStr] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: StrictStr
+    expression: Optional[StrictStr] = None
+    component: StrictStr = Field(description="Get object's component so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    static_settings: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["pk", "managed", "name", "expression", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "static_settings"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ScopeMapping:
-        """Create an instance of ScopeMapping from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RACPropertyMapping from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ScopeMapping:
-        """Create an instance of ScopeMapping from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RACPropertyMapping from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ScopeMapping.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ScopeMapping.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "scope_name": obj.get("scope_name"),
-            "description": obj.get("description")
+            "static_settings": obj.get("static_settings")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/scope_mapping_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_scope_mapping_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,70 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr, constr
-
-class ScopeMappingRequest(BaseModel):
-    """
-    ScopeMapping Serializer  # noqa: E501
+class PatchedScopeMappingRequest(BaseModel):
     """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    name: constr(strict=True, min_length=1) = Field(...)
-    expression: constr(strict=True, min_length=1) = Field(...)
-    scope_name: constr(strict=True, min_length=1) = Field(..., description="Scope name requested by the client")
-    description: Optional[StrictStr] = Field(None, description="Description shown to the user when consenting. If left empty, the user won't be informed.")
-    __properties = ["managed", "name", "expression", "scope_name", "description"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ScopeMapping Serializer
+    """ # noqa: E501
+    managed: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    expression: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    scope_name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Scope name requested by the client")
+    description: Optional[StrictStr] = Field(default=None, description="Description shown to the user when consenting. If left empty, the user won't be informed.")
+    __properties: ClassVar[List[str]] = ["managed", "name", "expression", "scope_name", "description"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ScopeMappingRequest:
-        """Create an instance of ScopeMappingRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedScopeMappingRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.managed is None and "managed" in self.model_fields_set:
             _dict['managed'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ScopeMappingRequest:
-        """Create an instance of ScopeMappingRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedScopeMappingRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ScopeMappingRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ScopeMappingRequest.parse_obj({
+        _obj = cls.model_validate({
             "managed": obj.get("managed"),
             "name": obj.get("name"),
             "expression": obj.get("expression"),
             "scope_name": obj.get("scope_name"),
             "description": obj.get("description")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/selectable_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/service_connection_state.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,65 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class SelectableStage(BaseModel):
-    """
-    Serializer for stages which can be selected by users  # noqa: E501
+class ServiceConnectionState(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    verbose_name: StrictStr = Field(...)
-    meta_model_name: StrictStr = Field(...)
-    __properties = ["pk", "name", "verbose_name", "meta_model_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for Service connection state
+    """ # noqa: E501
+    healthy: StrictBool
+    version: StrictStr
+    __properties: ClassVar[List[str]] = ["healthy", "version"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SelectableStage:
-        """Create an instance of SelectableStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ServiceConnectionState from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "healthy",
+            "version",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SelectableStage:
-        """Create an instance of SelectableStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ServiceConnectionState from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SelectableStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SelectableStage.parse_obj({
-            "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "verbose_name": obj.get("verbose_name"),
-            "meta_model_name": obj.get("meta_model_name")
+        _obj = cls.model_validate({
+            "healthy": obj.get("healthy"),
+            "version": obj.get("version")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/service_connection.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/plex_source_connection.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,76 +14,93 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.source import Source
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-
-class ServiceConnection(BaseModel):
-    """
-    ServiceConnection Serializer  # noqa: E501
+class PlexSourceConnection(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    component: StrictStr = Field(..., description="Return component used to edit this object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    __properties = ["pk", "name", "local", "component", "verbose_name", "verbose_name_plural", "meta_model_name"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Plex Source connection Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    user: StrictInt
+    source: Source
+    identifier: StrictStr
+    plex_token: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "user", "source", "identifier", "plex_token"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ServiceConnection:
-        """Create an instance of ServiceConnection from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PlexSourceConnection from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "user",
+            "source",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of source
+        if self.source:
+            _dict['source'] = self.source.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ServiceConnection:
-        """Create an instance of ServiceConnection from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PlexSourceConnection from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ServiceConnection.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ServiceConnection.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "local": obj.get("local"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name")
+            "user": obj.get("user"),
+            "source": Source.from_dict(obj["source"]) if obj.get("source") is not None else None,
+            "identifier": obj.get("identifier"),
+            "plex_token": obj.get("plex_token")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/service_connection_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_user_saml_source_connection_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,61 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-
-class ServiceConnectionRequest(BaseModel):
-    """
-    ServiceConnection Serializer  # noqa: E501
+class PatchedUserSAMLSourceConnectionRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    local: Optional[StrictBool] = Field(None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
-    __properties = ["name", "local"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAML Source Serializer
+    """ # noqa: E501
+    user: Optional[StrictInt] = None
+    identifier: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    __properties: ClassVar[List[str]] = ["user", "identifier"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ServiceConnectionRequest:
-        """Create an instance of ServiceConnectionRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedUserSAMLSourceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ServiceConnectionRequest:
-        """Create an instance of ServiceConnectionRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedUserSAMLSourceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ServiceConnectionRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ServiceConnectionRequest.parse_obj({
-            "name": obj.get("name"),
-            "local": obj.get("local")
+        _obj = cls.model_validate({
+            "user": obj.get("user"),
+            "identifier": obj.get("identifier")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/session_user.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_saml_source_connection_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,68 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field
-from authentik_client.models.user_self import UserSelf
-
-class SessionUser(BaseModel):
-    """
-    Response for the /user/me endpoint, returns the currently active user (as `user` property) and, if this user is being impersonated, the original user in the `original` property.  # noqa: E501
+class UserSAMLSourceConnectionRequest(BaseModel):
     """
-    user: UserSelf = Field(...)
-    original: Optional[UserSelf] = None
-    __properties = ["user", "original"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAML Source Serializer
+    """ # noqa: E501
+    user: StrictInt
+    identifier: Annotated[str, Field(min_length=1, strict=True)]
+    __properties: ClassVar[List[str]] = ["user", "identifier"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SessionUser:
-        """Create an instance of SessionUser from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserSAMLSourceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of original
-        if self.original:
-            _dict['original'] = self.original.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SessionUser:
-        """Create an instance of SessionUser from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserSAMLSourceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SessionUser.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SessionUser.parse_obj({
-            "user": UserSelf.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "original": UserSelf.from_dict(obj.get("original")) if obj.get("original") is not None else None
+        _obj = cls.model_validate({
+            "user": obj.get("user"),
+            "identifier": obj.get("identifier")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/settings.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/settings.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,73 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class Settings(BaseModel):
     """
-    Settings Serializer  # noqa: E501
-    """
-    avatars: Optional[StrictStr] = Field(None, description="Configure how authentik should show avatars for users.")
-    default_user_change_name: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their name.")
-    default_user_change_email: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their email address.")
-    default_user_change_username: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their username.")
-    event_retention: Optional[StrictStr] = Field(None, description="Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).")
-    footer_links: Optional[Any] = Field(None, description="The option configures the footer links on the flow executor pages.")
-    gdpr_compliance: Optional[StrictBool] = Field(None, description="When enabled, all the events caused by a user will be deleted upon the user's deletion.")
-    impersonation: Optional[StrictBool] = Field(None, description="Globally enable/disable impersonation.")
-    __properties = ["avatars", "default_user_change_name", "default_user_change_email", "default_user_change_username", "event_retention", "footer_links", "gdpr_compliance", "impersonation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Settings Serializer
+    """ # noqa: E501
+    avatars: Optional[StrictStr] = Field(default=None, description="Configure how authentik should show avatars for users.")
+    default_user_change_name: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their name.")
+    default_user_change_email: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their email address.")
+    default_user_change_username: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their username.")
+    event_retention: Optional[StrictStr] = Field(default=None, description="Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).")
+    footer_links: Optional[Any] = Field(default=None, description="The option configures the footer links on the flow executor pages.")
+    gdpr_compliance: Optional[StrictBool] = Field(default=None, description="When enabled, all the events caused by a user will be deleted upon the user's deletion.")
+    impersonation: Optional[StrictBool] = Field(default=None, description="Globally enable/disable impersonation.")
+    __properties: ClassVar[List[str]] = ["avatars", "default_user_change_name", "default_user_change_email", "default_user_change_username", "event_retention", "footer_links", "gdpr_compliance", "impersonation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Settings:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of Settings from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if footer_links (nullable) is None
-        # and __fields_set__ contains the field
-        if self.footer_links is None and "footer_links" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.footer_links is None and "footer_links" in self.model_fields_set:
             _dict['footer_links'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Settings:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of Settings from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Settings.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Settings.parse_obj({
+        _obj = cls.model_validate({
             "avatars": obj.get("avatars"),
             "default_user_change_name": obj.get("default_user_change_name"),
             "default_user_change_email": obj.get("default_user_change_email"),
             "default_user_change_username": obj.get("default_user_change_username"),
             "event_retention": obj.get("event_retention"),
             "footer_links": obj.get("footer_links"),
             "gdpr_compliance": obj.get("gdpr_compliance"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/settings_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/settings_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,73 +14,90 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Optional
-from pydantic import BaseModel, Field, StrictBool, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SettingsRequest(BaseModel):
     """
-    Settings Serializer  # noqa: E501
-    """
-    avatars: Optional[constr(strict=True, min_length=1)] = Field(None, description="Configure how authentik should show avatars for users.")
-    default_user_change_name: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their name.")
-    default_user_change_email: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their email address.")
-    default_user_change_username: Optional[StrictBool] = Field(None, description="Enable the ability for users to change their username.")
-    event_retention: Optional[constr(strict=True, min_length=1)] = Field(None, description="Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).")
-    footer_links: Optional[Any] = Field(None, description="The option configures the footer links on the flow executor pages.")
-    gdpr_compliance: Optional[StrictBool] = Field(None, description="When enabled, all the events caused by a user will be deleted upon the user's deletion.")
-    impersonation: Optional[StrictBool] = Field(None, description="Globally enable/disable impersonation.")
-    __properties = ["avatars", "default_user_change_name", "default_user_change_email", "default_user_change_username", "event_retention", "footer_links", "gdpr_compliance", "impersonation"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Settings Serializer
+    """ # noqa: E501
+    avatars: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Configure how authentik should show avatars for users.")
+    default_user_change_name: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their name.")
+    default_user_change_email: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their email address.")
+    default_user_change_username: Optional[StrictBool] = Field(default=None, description="Enable the ability for users to change their username.")
+    event_retention: Optional[Annotated[str, Field(min_length=1, strict=True)]] = Field(default=None, description="Events will be deleted after this duration.(Format: weeks=3;days=2;hours=3,seconds=2).")
+    footer_links: Optional[Any] = Field(default=None, description="The option configures the footer links on the flow executor pages.")
+    gdpr_compliance: Optional[StrictBool] = Field(default=None, description="When enabled, all the events caused by a user will be deleted upon the user's deletion.")
+    impersonation: Optional[StrictBool] = Field(default=None, description="Globally enable/disable impersonation.")
+    __properties: ClassVar[List[str]] = ["avatars", "default_user_change_name", "default_user_change_email", "default_user_change_username", "event_retention", "footer_links", "gdpr_compliance", "impersonation"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SettingsRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SettingsRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if footer_links (nullable) is None
-        # and __fields_set__ contains the field
-        if self.footer_links is None and "footer_links" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.footer_links is None and "footer_links" in self.model_fields_set:
             _dict['footer_links'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SettingsRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SettingsRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SettingsRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SettingsRequest.parse_obj({
+        _obj = cls.model_validate({
             "avatars": obj.get("avatars"),
             "default_user_change_name": obj.get("default_user_change_name"),
             "default_user_change_email": obj.get("default_user_change_email"),
             "default_user_change_username": obj.get("default_user_change_username"),
             "event_retention": obj.get("event_retention"),
             "footer_links": obj.get("footer_links"),
             "gdpr_compliance": obj.get("gdpr_compliance"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/severity_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/severity_enum.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class SeverityEnum(str, Enum):
     """
     SeverityEnum
     """
 
@@ -31,12 +28,12 @@
     allowed enum values
     """
     NOTICE = 'notice'
     WARNING = 'warning'
     ALERT = 'alert'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeverityEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of SeverityEnum from a JSON string"""
-        return SeverityEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/shell_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/static_device.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,89 +14,92 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from authentik_client.models.static_device_token import StaticDeviceToken
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class ShellChallenge(BaseModel):
-    """
-    challenge type to render HTML as-is  # noqa: E501
+class StaticDevice(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'xak-flow-shell'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    body: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "body"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for static authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    token_set: List[StaticDeviceToken]
+    pk: StrictInt
+    __properties: ClassVar[List[str]] = ["name", "token_set", "pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ShellChallenge:
-        """Create an instance of ShellChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of StaticDevice from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "token_set",
+            "pk",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in token_set (list)
+        _items = []
+        if self.token_set:
+            for _item in self.token_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['token_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ShellChallenge:
-        """Create an instance of ShellChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of StaticDevice from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ShellChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ShellChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'xak-flow-shell',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "body": obj.get("body")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "token_set": [StaticDeviceToken.from_dict(_item) for _item in obj["token_set"]] if obj.get("token_set") is not None else None,
+            "pk": obj.get("pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/signature_algorithm_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/signature_algorithm_enum.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class SignatureAlgorithmEnum(str, Enum):
     """
     SignatureAlgorithmEnum
     """
 
@@ -33,12 +30,12 @@
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2000_SLASH_09_SLASH_XMLDSIG_HASH_RSA_MINUS_SHA1 = 'http://www.w3.org/2000/09/xmldsig#rsa-sha1'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2001_SLASH_04_SLASH_XMLDSIG_MINUS_MORE_HASH_RSA_MINUS_SHA256 = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2001_SLASH_04_SLASH_XMLDSIG_MINUS_MORE_HASH_RSA_MINUS_SHA384 = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2001_SLASH_04_SLASH_XMLDSIG_MINUS_MORE_HASH_RSA_MINUS_SHA512 = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512'
     HTTP_COLON_SLASH_SLASH_WWW_DOT_W3_DOT_ORG_SLASH_2000_SLASH_09_SLASH_XMLDSIG_HASH_DSA_MINUS_SHA1 = 'http://www.w3.org/2000/09/xmldsig#dsa-sha1'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SignatureAlgorithmEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of SignatureAlgorithmEnum from a JSON string"""
-        return SignatureAlgorithmEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/sms_device.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/web_authn_device_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,65 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
-
-class SMSDevice(BaseModel):
-    """
-    Serializer for sms authenticator devices  # noqa: E501
+class WebAuthnDeviceRequest(BaseModel):
     """
-    name: constr(strict=True, max_length=64) = Field(..., description="The human-readable name of this device.")
-    pk: StrictInt = Field(...)
-    phone_number: StrictStr = Field(...)
-    __properties = ["name", "pk", "phone_number"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for WebAuthn authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=200)]
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SMSDevice:
-        """Create an instance of SMSDevice from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of WebAuthnDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "phone_number",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SMSDevice:
-        """Create an instance of SMSDevice from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of WebAuthnDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SMSDevice.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SMSDevice.parse_obj({
-            "name": obj.get("name"),
-            "pk": obj.get("pk"),
-            "phone_number": obj.get("phone_number")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/sms_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/role_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,59 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, constr
-
-class SMSDeviceRequest(BaseModel):
-    """
-    Serializer for sms authenticator devices  # noqa: E501
+class RoleRequest(BaseModel):
     """
-    name: constr(strict=True, max_length=64, min_length=1) = Field(..., description="The human-readable name of this device.")
-    __properties = ["name"]
+    Role serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=150)]
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SMSDeviceRequest:
-        """Create an instance of SMSDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of RoleRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SMSDeviceRequest:
-        """Create an instance of SMSDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of RoleRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SMSDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SMSDeviceRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/source.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_write_stage.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,123 +14,122 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.flow_set import FlowSet
+from authentik_client.models.user_creation_mode_enum import UserCreationModeEnum
+from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
-
-class Source(BaseModel):
-    """
-    Source Serializer  # noqa: E501
+class UserWriteStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50) = Field(..., description="Internal source name, used in URLs.")
-    enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    component: StrictStr = Field(..., description="Get object component so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    managed: Optional[StrictStr] = Field(..., description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
+    UserWriteStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    user_creation_mode: Optional[UserCreationModeEnum] = None
+    create_users_as_inactive: Optional[StrictBool] = Field(default=None, description="When set, newly created users are inactive and cannot login.")
+    create_users_group: Optional[StrictStr] = Field(default=None, description="Optionally add newly created users to this group.")
+    user_type: Optional[UserTypeEnum] = None
     user_path_template: Optional[StrictStr] = None
-    icon: Optional[StrictStr] = Field(..., description="Get the URL to the Icon. If the name is /static or starts with http it is returned as-is")
-    __properties = ["pk", "name", "slug", "enabled", "authentication_flow", "enrollment_flow", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "policy_engine_mode", "user_matching_mode", "managed", "user_path_template", "icon"]
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "user_creation_mode", "create_users_as_inactive", "create_users_group", "user_type", "user_path_template"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Source:
-        """Create an instance of Source from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserWriteStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                            "managed",
-                            "icon",
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
-
-        # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
-            _dict['enrollment_flow'] = None
-
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
-
-        # set to None if icon (nullable) is None
-        # and __fields_set__ contains the field
-        if self.icon is None and "icon" in self.__fields_set__:
-            _dict['icon'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+        _items = []
+        if self.flow_set:
+            for _item in self.flow_set:
+                if _item:
+                    _items.append(_item.to_dict())
+            _dict['flow_set'] = _items
+        # set to None if create_users_group (nullable) is None
+        # and model_fields_set contains the field
+        if self.create_users_group is None and "create_users_group" in self.model_fields_set:
+            _dict['create_users_group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Source:
-        """Create an instance of Source from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserWriteStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Source.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Source.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "enabled": obj.get("enabled"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "enrollment_flow": obj.get("enrollment_flow"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "user_matching_mode": obj.get("user_matching_mode"),
-            "managed": obj.get("managed"),
-            "user_path_template": obj.get("user_path_template"),
-            "icon": obj.get("icon")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "user_creation_mode": obj.get("user_creation_mode"),
+            "create_users_as_inactive": obj.get("create_users_as_inactive"),
+            "create_users_group": obj.get("create_users_group"),
+            "user_type": obj.get("user_type"),
+            "user_path_template": obj.get("user_path_template")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/source_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_rule.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,92 +14,99 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.group import Group
+from authentik_client.models.severity_enum import SeverityEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
-from authentik_client.models.policy_engine_mode import PolicyEngineMode
-from authentik_client.models.user_matching_mode_enum import UserMatchingModeEnum
-
-class SourceRequest(BaseModel):
-    """
-    Source Serializer  # noqa: E501
+class NotificationRule(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(..., description="Source's display Name.")
-    slug: constr(strict=True, max_length=50, min_length=1) = Field(..., description="Internal source name, used in URLs.")
-    enabled: Optional[StrictBool] = None
-    authentication_flow: Optional[StrictStr] = Field(None, description="Flow to use when authenticating existing users.")
-    enrollment_flow: Optional[StrictStr] = Field(None, description="Flow to use when enrolling new users.")
-    policy_engine_mode: Optional[PolicyEngineMode] = None
-    user_matching_mode: Optional[UserMatchingModeEnum] = Field(None, description="How the source determines if an existing user should be authenticated or a new user enrolled.")
-    user_path_template: Optional[constr(strict=True, min_length=1)] = None
-    __properties = ["name", "slug", "enabled", "authentication_flow", "enrollment_flow", "policy_engine_mode", "user_matching_mode", "user_path_template"]
-
-    @validator('slug')
-    def slug_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationRule Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    transports: Optional[List[StrictStr]] = Field(default=None, description="Select which transports should be used to notify the user. If none are selected, the notification will only be shown in the authentik UI.")
+    severity: Optional[SeverityEnum] = Field(default=None, description="Controls which severity level the created notifications will have.")
+    group: Optional[StrictStr] = Field(default=None, description="Define which group of users this notification should be sent and shown to. If left empty, Notification won't ben sent.")
+    group_obj: Group
+    __properties: ClassVar[List[str]] = ["pk", "name", "transports", "severity", "group", "group_obj"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SourceRequest:
-        """Create an instance of SourceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationRule from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if authentication_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authentication_flow is None and "authentication_flow" in self.__fields_set__:
-            _dict['authentication_flow'] = None
-
-        # set to None if enrollment_flow (nullable) is None
-        # and __fields_set__ contains the field
-        if self.enrollment_flow is None and "enrollment_flow" in self.__fields_set__:
-            _dict['enrollment_flow'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "group_obj",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of group_obj
+        if self.group_obj:
+            _dict['group_obj'] = self.group_obj.to_dict()
+        # set to None if group (nullable) is None
+        # and model_fields_set contains the field
+        if self.group is None and "group" in self.model_fields_set:
+            _dict['group'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SourceRequest:
-        """Create an instance of SourceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationRule from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SourceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SourceRequest.parse_obj({
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
             "name": obj.get("name"),
-            "slug": obj.get("slug"),
-            "enabled": obj.get("enabled"),
-            "authentication_flow": obj.get("authentication_flow"),
-            "enrollment_flow": obj.get("enrollment_flow"),
-            "policy_engine_mode": obj.get("policy_engine_mode"),
-            "user_matching_mode": obj.get("user_matching_mode"),
-            "user_path_template": obj.get("user_path_template")
+            "transports": obj.get("transports"),
+            "severity": obj.get("severity"),
+            "group": obj.get("group"),
+            "group_obj": Group.from_dict(obj["group_obj"]) if obj.get("group_obj") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/source_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_logout_stage.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,88 +14,105 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
 from authentik_client.models.flow_set import FlowSet
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SourceStage(BaseModel):
-    """
-    SourceStage Serializer  # noqa: E501
+class UserLogoutStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    source: StrictStr = Field(...)
-    resume_timeout: Optional[StrictStr] = Field(None, description="Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "source", "resume_timeout"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserLogoutStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SourceStage:
-        """Create an instance of SourceStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserLogoutStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SourceStage:
-        """Create an instance of SourceStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserLogoutStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SourceStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SourceStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "source": obj.get("source"),
-            "resume_timeout": obj.get("resume_timeout")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/source_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/transaction_application_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,73 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class SourceStageRequest(BaseModel):
-    """
-    SourceStage Serializer  # noqa: E501
+class TransactionApplicationResponse(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    source: StrictStr = Field(...)
-    resume_timeout: Optional[constr(strict=True, min_length=1)] = Field(None, description="Amount of time a user can take to return from the source to continue the flow (Format: hours=-1;minutes=-2;seconds=-3)")
-    __properties = ["name", "flow_set", "source", "resume_timeout"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Transactional creation response
+    """ # noqa: E501
+    applied: StrictBool
+    logs: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["applied", "logs"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SourceStageRequest:
-        """Create an instance of SourceStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TransactionApplicationResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SourceStageRequest:
-        """Create an instance of SourceStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TransactionApplicationResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SourceStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SourceStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "source": obj.get("source"),
-            "resume_timeout": obj.get("resume_timeout")
+        _obj = cls.model_validate({
+            "applied": obj.get("applied"),
+            "logs": obj.get("logs")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/source_type.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/source_type.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,105 +14,127 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
 class SourceType(BaseModel):
     """
-    Serializer for SourceType  # noqa: E501
-    """
-    name: StrictStr = Field(...)
-    verbose_name: StrictStr = Field(...)
-    urls_customizable: StrictBool = Field(...)
-    request_token_url: Optional[StrictStr] = Field(...)
-    authorization_url: Optional[StrictStr] = Field(...)
-    access_token_url: Optional[StrictStr] = Field(...)
-    profile_url: Optional[StrictStr] = Field(...)
-    oidc_well_known_url: Optional[StrictStr] = Field(...)
-    oidc_jwks_url: Optional[StrictStr] = Field(...)
-    __properties = ["name", "verbose_name", "urls_customizable", "request_token_url", "authorization_url", "access_token_url", "profile_url", "oidc_well_known_url", "oidc_jwks_url"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for SourceType
+    """ # noqa: E501
+    name: StrictStr
+    verbose_name: StrictStr
+    urls_customizable: StrictBool
+    request_token_url: Optional[StrictStr]
+    authorization_url: Optional[StrictStr]
+    access_token_url: Optional[StrictStr]
+    profile_url: Optional[StrictStr]
+    oidc_well_known_url: Optional[StrictStr]
+    oidc_jwks_url: Optional[StrictStr]
+    __properties: ClassVar[List[str]] = ["name", "verbose_name", "urls_customizable", "request_token_url", "authorization_url", "access_token_url", "profile_url", "oidc_well_known_url", "oidc_jwks_url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SourceType:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of SourceType from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "request_token_url",
-                            "authorization_url",
-                            "access_token_url",
-                            "profile_url",
-                            "oidc_well_known_url",
-                            "oidc_jwks_url",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "request_token_url",
+            "authorization_url",
+            "access_token_url",
+            "profile_url",
+            "oidc_well_known_url",
+            "oidc_jwks_url",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if request_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.request_token_url is None and "request_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.request_token_url is None and "request_token_url" in self.model_fields_set:
             _dict['request_token_url'] = None
 
         # set to None if authorization_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.authorization_url is None and "authorization_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.authorization_url is None and "authorization_url" in self.model_fields_set:
             _dict['authorization_url'] = None
 
         # set to None if access_token_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.access_token_url is None and "access_token_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.access_token_url is None and "access_token_url" in self.model_fields_set:
             _dict['access_token_url'] = None
 
         # set to None if profile_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.profile_url is None and "profile_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.profile_url is None and "profile_url" in self.model_fields_set:
             _dict['profile_url'] = None
 
         # set to None if oidc_well_known_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oidc_well_known_url is None and "oidc_well_known_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oidc_well_known_url is None and "oidc_well_known_url" in self.model_fields_set:
             _dict['oidc_well_known_url'] = None
 
         # set to None if oidc_jwks_url (nullable) is None
-        # and __fields_set__ contains the field
-        if self.oidc_jwks_url is None and "oidc_jwks_url" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.oidc_jwks_url is None and "oidc_jwks_url" in self.model_fields_set:
             _dict['oidc_jwks_url'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SourceType:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of SourceType from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SourceType.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SourceType.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "verbose_name": obj.get("verbose_name"),
             "urls_customizable": obj.get("urls_customizable"),
             "request_token_url": obj.get("request_token_url"),
             "authorization_url": obj.get("authorization_url"),
             "access_token_url": obj.get("access_token_url"),
             "profile_url": obj.get("profile_url"),
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/sp_binding_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/sp_binding_enum.py`

 * *Files 23% similar despite different names*

```diff
@@ -9,33 +9,30 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class SpBindingEnum(str, Enum):
     """
     SpBindingEnum
     """
 
     """
     allowed enum values
     """
     REDIRECT = 'redirect'
     POST = 'post'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SpBindingEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of SpBindingEnum from a JSON string"""
-        return SpBindingEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/type_create.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,84 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-
-class Stage(BaseModel):
-    """
-    Stage Serializer  # noqa: E501
+class TypeCreate(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Types of an object that can be created
+    """ # noqa: E501
+    name: StrictStr
+    description: StrictStr
+    component: StrictStr
+    model_name: StrictStr
+    requires_enterprise: Optional[StrictBool] = False
+    __properties: ClassVar[List[str]] = ["name", "description", "component", "model_name", "requires_enterprise"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Stage:
-        """Create an instance of Stage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TypeCreate from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Stage:
-        """Create an instance of Stage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TypeCreate from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Stage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Stage.parse_obj({
-            "pk": obj.get("pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
+            "description": obj.get("description"),
             "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+            "model_name": obj.get("model_name"),
+            "requires_enterprise": obj.get("requires_enterprise") if obj.get("requires_enterprise") is not None else False
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/stage_prompt.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/sms_device.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,81 +14,84 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
-from authentik_client.models.prompt_type_enum import PromptTypeEnum
-
-class StagePrompt(BaseModel):
-    """
-    Serializer for a single Prompt field  # noqa: E501
+class SMSDevice(BaseModel):
     """
-    field_key: StrictStr = Field(...)
-    label: StrictStr = Field(...)
-    type: PromptTypeEnum = Field(...)
-    required: StrictBool = Field(...)
-    placeholder: StrictStr = Field(...)
-    initial_value: StrictStr = Field(...)
-    order: StrictInt = Field(...)
-    sub_text: StrictStr = Field(...)
-    choices: Optional[conlist(StrictStr)] = Field(...)
-    __properties = ["field_key", "label", "type", "required", "placeholder", "initial_value", "order", "sub_text", "choices"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for sms authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    pk: StrictInt
+    phone_number: StrictStr
+    __properties: ClassVar[List[str]] = ["name", "pk", "phone_number"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> StagePrompt:
-        """Create an instance of StagePrompt from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SMSDevice from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if choices (nullable) is None
-        # and __fields_set__ contains the field
-        if self.choices is None and "choices" in self.__fields_set__:
-            _dict['choices'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "phone_number",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> StagePrompt:
-        """Create an instance of StagePrompt from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SMSDevice from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return StagePrompt.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = StagePrompt.parse_obj({
-            "field_key": obj.get("field_key"),
-            "label": obj.get("label"),
-            "type": obj.get("type"),
-            "required": obj.get("required"),
-            "placeholder": obj.get("placeholder"),
-            "initial_value": obj.get("initial_value"),
-            "order": obj.get("order"),
-            "sub_text": obj.get("sub_text"),
-            "choices": obj.get("choices")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "pk": obj.get("pk"),
+            "phone_number": obj.get("phone_number")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_service_account_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,69 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class StageRequest(BaseModel):
-    """
-    Stage Serializer  # noqa: E501
+class UserServiceAccountRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    __properties = ["name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserServiceAccountRequest
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    create_group: Optional[StrictBool] = False
+    expiring: Optional[StrictBool] = True
+    expires: Optional[datetime] = Field(default=None, description="If not provided, valid for 360 days")
+    __properties: ClassVar[List[str]] = ["name", "create_group", "expiring", "expires"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> StageRequest:
-        """Create an instance of StageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserServiceAccountRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> StageRequest:
-        """Create an instance of StageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserServiceAccountRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return StageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = StageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+            "create_group": obj.get("create_group") if obj.get("create_group") is not None else False,
+            "expiring": obj.get("expiring") if obj.get("expiring") is not None else True,
+            "expires": obj.get("expires")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/static_device.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_deny_stage_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,73 +14,88 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.flow_set_request import FlowSetRequest
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List
-from pydantic import BaseModel, Field, StrictInt, conlist, constr
-from authentik_client.models.static_device_token import StaticDeviceToken
-
-class StaticDevice(BaseModel):
-    """
-    Serializer for static authenticator devices  # noqa: E501
+class PatchedDenyStageRequest(BaseModel):
     """
-    name: constr(strict=True, max_length=64) = Field(..., description="The human-readable name of this device.")
-    token_set: conlist(StaticDeviceToken) = Field(...)
-    pk: StrictInt = Field(...)
-    __properties = ["name", "token_set", "pk"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    DenyStage Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    flow_set: Optional[List[FlowSetRequest]] = None
+    deny_message: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["name", "flow_set", "deny_message"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> StaticDevice:
-        """Create an instance of StaticDevice from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedDenyStageRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "token_set",
-                            "pk",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in token_set (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
-        if self.token_set:
-            for _item in self.token_set:
+        if self.flow_set:
+            for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['token_set'] = _items
+            _dict['flow_set'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> StaticDevice:
-        """Create an instance of StaticDevice from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedDenyStageRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return StaticDevice.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = StaticDevice.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "token_set": [StaticDeviceToken.from_dict(_item) for _item in obj.get("token_set")] if obj.get("token_set") is not None else None,
-            "pk": obj.get("pk")
+            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "deny_message": obj.get("deny_message")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/sub_mode_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_creation_mode_enum.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,37 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class SubModeEnum(str, Enum):
+class UserCreationModeEnum(str, Enum):
     """
-    SubModeEnum
+    UserCreationModeEnum
     """
 
     """
     allowed enum values
     """
-    HASHED_USER_ID = 'hashed_user_id'
-    USER_ID = 'user_id'
-    USER_UUID = 'user_uuid'
-    USER_USERNAME = 'user_username'
-    USER_EMAIL = 'user_email'
-    USER_UPN = 'user_upn'
+    NEVER_CREATE = 'never_create'
+    CREATE_WHEN_REQUIRED = 'create_when_required'
+    ALWAYS_CREATE = 'always_create'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SubModeEnum:
-        """Create an instance of SubModeEnum from a JSON string"""
-        return SubModeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UserCreationModeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/system_info.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,84 +14,97 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Dict
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-from authentik_client.models.system_info_runtime import SystemInfoRuntime
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.notification_transport_mode_enum import NotificationTransportModeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SystemInfo(BaseModel):
+class NotificationTransport(BaseModel):
     """
-    Get system information.  # noqa: E501
-    """
-    http_headers: Dict[str, StrictStr] = Field(..., description="Get HTTP Request headers")
-    http_host: StrictStr = Field(..., description="Get HTTP host")
-    http_is_secure: StrictBool = Field(..., description="Get HTTP Secure flag")
-    runtime: SystemInfoRuntime = Field(...)
-    brand: StrictStr = Field(..., description="Currently active brand")
-    server_time: datetime = Field(..., description="Current server time")
-    embedded_outpost_disabled: StrictBool = Field(..., description="Whether the embedded outpost is disabled")
-    embedded_outpost_host: StrictStr = Field(..., description="Get the FQDN configured on the embedded outpost")
-    __properties = ["http_headers", "http_host", "http_is_secure", "runtime", "brand", "server_time", "embedded_outpost_disabled", "embedded_outpost_host"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    NotificationTransport Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    mode: Optional[NotificationTransportModeEnum] = None
+    mode_verbose: StrictStr = Field(description="Return selected mode with a UI Label")
+    webhook_url: Optional[StrictStr] = None
+    webhook_mapping: Optional[StrictStr] = None
+    send_once: Optional[StrictBool] = Field(default=None, description="Only send notification once, for example when sending a webhook into a chat channel.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "mode", "mode_verbose", "webhook_url", "webhook_mapping", "send_once"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SystemInfo:
-        """Create an instance of SystemInfo from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationTransport from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "http_headers",
-                            "http_host",
-                            "http_is_secure",
-                            "brand",
-                            "server_time",
-                            "embedded_outpost_disabled",
-                            "embedded_outpost_host",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of runtime
-        if self.runtime:
-            _dict['runtime'] = self.runtime.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "mode_verbose",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if webhook_mapping (nullable) is None
+        # and model_fields_set contains the field
+        if self.webhook_mapping is None and "webhook_mapping" in self.model_fields_set:
+            _dict['webhook_mapping'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SystemInfo:
-        """Create an instance of SystemInfo from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationTransport from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SystemInfo.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SystemInfo.parse_obj({
-            "http_headers": obj.get("http_headers"),
-            "http_host": obj.get("http_host"),
-            "http_is_secure": obj.get("http_is_secure"),
-            "runtime": SystemInfoRuntime.from_dict(obj.get("runtime")) if obj.get("runtime") is not None else None,
-            "brand": obj.get("brand"),
-            "server_time": obj.get("server_time"),
-            "embedded_outpost_disabled": obj.get("embedded_outpost_disabled"),
-            "embedded_outpost_host": obj.get("embedded_outpost_host")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "name": obj.get("name"),
+            "mode": obj.get("mode"),
+            "mode_verbose": obj.get("mode_verbose"),
+            "webhook_url": obj.get("webhook_url"),
+            "webhook_mapping": obj.get("webhook_mapping"),
+            "send_once": obj.get("send_once")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/system_info_runtime.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/token_view.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,69 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class SystemInfoRuntime(BaseModel):
-    """
-    Get versions  # noqa: E501
+class TokenView(BaseModel):
     """
-    python_version: StrictStr = Field(...)
-    gunicorn_version: StrictStr = Field(...)
-    environment: StrictStr = Field(...)
-    architecture: StrictStr = Field(...)
-    platform: StrictStr = Field(...)
-    uname: StrictStr = Field(...)
-    __properties = ["python_version", "gunicorn_version", "environment", "architecture", "platform", "uname"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Show token's current key
+    """ # noqa: E501
+    key: StrictStr
+    __properties: ClassVar[List[str]] = ["key"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SystemInfoRuntime:
-        """Create an instance of SystemInfoRuntime from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of TokenView from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "key",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SystemInfoRuntime:
-        """Create an instance of SystemInfoRuntime from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of TokenView from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SystemInfoRuntime.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SystemInfoRuntime.parse_obj({
-            "python_version": obj.get("python_version"),
-            "gunicorn_version": obj.get("gunicorn_version"),
-            "environment": obj.get("environment"),
-            "architecture": obj.get("architecture"),
-            "platform": obj.get("platform"),
-            "uname": obj.get("uname")
+        _obj = cls.model_validate({
+            "key": obj.get("key")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/system_task.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/log_event.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,82 +15,84 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import List, Optional, Union
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, conlist
-from authentik_client.models.system_task_status_enum import SystemTaskStatusEnum
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.log_level_enum import LogLevelEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class SystemTask(BaseModel):
+class LogEvent(BaseModel):
     """
-    Serialize TaskInfo and TaskResult  # noqa: E501
-    """
-    uuid: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    full_name: StrictStr = Field(..., description="Get full name with UID")
-    uid: Optional[StrictStr] = None
-    description: StrictStr = Field(...)
-    start_timestamp: datetime = Field(...)
-    finish_timestamp: datetime = Field(...)
-    duration: Union[StrictFloat, StrictInt] = Field(...)
-    status: SystemTaskStatusEnum = Field(...)
-    messages: conlist(StrictStr) = Field(...)
-    __properties = ["uuid", "name", "full_name", "uid", "description", "start_timestamp", "finish_timestamp", "duration", "status", "messages"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Single log message with all context logged.
+    """ # noqa: E501
+    timestamp: datetime
+    log_level: LogLevelEnum
+    logger: StrictStr
+    event: StrictStr
+    attributes: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["timestamp", "log_level", "logger", "event", "attributes"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SystemTask:
-        """Create an instance of SystemTask from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of LogEvent from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "uuid",
-                            "full_name",
-                            "start_timestamp",
-                            "finish_timestamp",
-                            "duration",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SystemTask:
-        """Create an instance of SystemTask from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of LogEvent from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return SystemTask.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = SystemTask.parse_obj({
-            "uuid": obj.get("uuid"),
-            "name": obj.get("name"),
-            "full_name": obj.get("full_name"),
-            "uid": obj.get("uid"),
-            "description": obj.get("description"),
-            "start_timestamp": obj.get("start_timestamp"),
-            "finish_timestamp": obj.get("finish_timestamp"),
-            "duration": obj.get("duration"),
-            "status": obj.get("status"),
-            "messages": obj.get("messages")
+        _obj = cls.model_validate({
+            "timestamp": obj.get("timestamp"),
+            "log_level": obj.get("log_level"),
+            "logger": obj.get("logger"),
+            "event": obj.get("event"),
+            "attributes": obj.get("attributes")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/system_task_status_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/sub_mode_enum.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,35 +9,34 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class SystemTaskStatusEnum(str, Enum):
+class SubModeEnum(str, Enum):
     """
-    SystemTaskStatusEnum
+    SubModeEnum
     """
 
     """
     allowed enum values
     """
-    UNKNOWN = 'unknown'
-    SUCCESSFUL = 'successful'
-    WARNING = 'warning'
-    ERROR = 'error'
+    HASHED_USER_ID = 'hashed_user_id'
+    USER_ID = 'user_id'
+    USER_UUID = 'user_uuid'
+    USER_USERNAME = 'user_username'
+    USER_EMAIL = 'user_email'
+    USER_UPN = 'user_upn'
 
     @classmethod
-    def from_json(cls, json_str: str) -> SystemTaskStatusEnum:
-        """Create an instance of SystemTaskStatusEnum from a JSON string"""
-        return SystemTaskStatusEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of SubModeEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/tenant.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/footer_link.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,66 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
-
-class Tenant(BaseModel):
-    """
-    Tenant Serializer  # noqa: E501
+class FooterLink(BaseModel):
     """
-    tenant_uuid: StrictStr = Field(...)
-    schema_name: constr(strict=True, max_length=63) = Field(...)
-    name: StrictStr = Field(...)
-    ready: Optional[StrictBool] = None
-    __properties = ["tenant_uuid", "schema_name", "name", "ready"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Links returned in Config API
+    """ # noqa: E501
+    href: StrictStr
+    name: StrictStr
+    __properties: ClassVar[List[str]] = ["href", "name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Tenant:
-        """Create an instance of Tenant from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of FooterLink from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "tenant_uuid",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "href",
+            "name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Tenant:
-        """Create an instance of Tenant from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of FooterLink from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Tenant.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Tenant.parse_obj({
-            "tenant_uuid": obj.get("tenant_uuid"),
-            "schema_name": obj.get("schema_name"),
-            "name": obj.get("name"),
-            "ready": obj.get("ready")
+        _obj = cls.model_validate({
+            "href": obj.get("href"),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/token.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/group_member_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -15,93 +15,98 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
-from authentik_client.models.intent_enum import IntentEnum
-from authentik_client.models.user import User
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-class Token(BaseModel):
+class GroupMemberRequest(BaseModel):
     """
-    Token Serializer  # noqa: E501
-    """
-    pk: StrictStr = Field(...)
-    managed: Optional[StrictStr] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    identifier: constr(strict=True, max_length=255) = Field(...)
-    intent: Optional[IntentEnum] = None
-    user: Optional[StrictInt] = None
-    user_obj: User = Field(...)
-    description: Optional[StrictStr] = None
-    expires: Optional[datetime] = None
-    expiring: Optional[StrictBool] = None
-    __properties = ["pk", "managed", "identifier", "intent", "user", "user_obj", "description", "expires", "expiring"]
+    Stripped down user serializer to show relevant users for groups
+    """ # noqa: E501
+    username: Annotated[str, Field(min_length=1, strict=True, max_length=150)] = Field(description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
+    name: Annotated[str, Field(min_length=1, strict=True)] = Field(description="User's display name.")
+    is_active: Optional[StrictBool] = Field(default=None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
+    last_login: Optional[datetime] = None
+    email: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
+    attributes: Optional[Dict[str, Any]] = None
+    __properties: ClassVar[List[str]] = ["username", "name", "is_active", "last_login", "email", "attributes"]
 
-    @validator('identifier')
-    def identifier_validate_regular_expression(cls, value):
+    @field_validator('username')
+    def username_validate_regular_expression(cls, value):
         """Validates the regular expression"""
-        if not re.match(r"^[-a-zA-Z0-9_]+$", value):
-            raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
+        if not re.match(r"^[\w.@+-]+$", value):
+            raise ValueError(r"must validate the regular expression /^[\w.@+-]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Token:
-        """Create an instance of Token from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of GroupMemberRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "user_obj",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of user_obj
-        if self.user_obj:
-            _dict['user_obj'] = self.user_obj.to_dict()
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if last_login (nullable) is None
+        # and model_fields_set contains the field
+        if self.last_login is None and "last_login" in self.model_fields_set:
+            _dict['last_login'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Token:
-        """Create an instance of Token from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of GroupMemberRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return Token.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = Token.parse_obj({
-            "pk": obj.get("pk"),
-            "managed": obj.get("managed"),
-            "identifier": obj.get("identifier"),
-            "intent": obj.get("intent"),
-            "user": obj.get("user"),
-            "user_obj": User.from_dict(obj.get("user_obj")) if obj.get("user_obj") is not None else None,
-            "description": obj.get("description"),
-            "expires": obj.get("expires"),
-            "expiring": obj.get("expiring")
+        _obj = cls.model_validate({
+            "username": obj.get("username"),
+            "name": obj.get("name"),
+            "is_active": obj.get("is_active"),
+            "last_login": obj.get("last_login"),
+            "email": obj.get("email"),
+            "attributes": obj.get("attributes")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/token_model.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_password_expiry_policy_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,84 +14,82 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
-from authentik_client.models.o_auth2_provider import OAuth2Provider
-from authentik_client.models.user import User
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TokenModel(BaseModel):
+class PatchedPasswordExpiryPolicyRequest(BaseModel):
     """
-    Serializer for BaseGrantModel and RefreshToken  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    provider: OAuth2Provider = Field(...)
-    user: User = Field(...)
-    is_expired: StrictBool = Field(..., description="Check if token is expired yet.")
-    expires: Optional[datetime] = None
-    scope: conlist(StrictStr) = Field(...)
-    id_token: StrictStr = Field(..., description="Get the token's id_token as JSON String")
-    revoked: Optional[StrictBool] = None
-    __properties = ["pk", "provider", "user", "is_expired", "expires", "scope", "id_token", "revoked"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Password Expiry Policy Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True)]] = None
+    execution_logging: Optional[StrictBool] = Field(default=None, description="When this option is enabled, all executions of this policy will be logged. By default, only execution errors are logged.")
+    days: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = None
+    deny_only: Optional[StrictBool] = None
+    __properties: ClassVar[List[str]] = ["name", "execution_logging", "days", "deny_only"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TokenModel:
-        """Create an instance of TokenModel from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedPasswordExpiryPolicyRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "is_expired",
-                            "id_token",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of provider
-        if self.provider:
-            _dict['provider'] = self.provider.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TokenModel:
-        """Create an instance of TokenModel from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedPasswordExpiryPolicyRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TokenModel.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TokenModel.parse_obj({
-            "pk": obj.get("pk"),
-            "provider": OAuth2Provider.from_dict(obj.get("provider")) if obj.get("provider") is not None else None,
-            "user": User.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "is_expired": obj.get("is_expired"),
-            "expires": obj.get("expires"),
-            "scope": obj.get("scope"),
-            "id_token": obj.get("id_token"),
-            "revoked": obj.get("revoked")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "execution_logging": obj.get("execution_logging"),
+            "days": obj.get("days"),
+            "deny_only": obj.get("deny_only")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/token_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/patched_invitation_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -15,83 +15,99 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
-from authentik_client.models.intent_enum import IntentEnum
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-class TokenRequest(BaseModel):
+class PatchedInvitationRequest(BaseModel):
     """
-    Token Serializer  # noqa: E501
-    """
-    managed: Optional[constr(strict=True, min_length=1)] = Field(None, description="Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.")
-    identifier: constr(strict=True, max_length=255, min_length=1) = Field(...)
-    intent: Optional[IntentEnum] = None
-    user: Optional[StrictInt] = None
-    description: Optional[StrictStr] = None
+    Invitation Serializer
+    """ # noqa: E501
+    name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = None
     expires: Optional[datetime] = None
-    expiring: Optional[StrictBool] = None
-    __properties = ["managed", "identifier", "intent", "user", "description", "expires", "expiring"]
+    fixed_data: Optional[Dict[str, Any]] = None
+    single_use: Optional[StrictBool] = Field(default=None, description="When enabled, the invitation will be deleted after usage.")
+    flow: Optional[StrictStr] = Field(default=None, description="When set, only the configured flow can use this invitation.")
+    __properties: ClassVar[List[str]] = ["name", "expires", "fixed_data", "single_use", "flow"]
 
-    @validator('identifier')
-    def identifier_validate_regular_expression(cls, value):
+    @field_validator('name')
+    def name_validate_regular_expression(cls, value):
         """Validates the regular expression"""
+        if value is None:
+            return value
+
         if not re.match(r"^[-a-zA-Z0-9_]+$", value):
             raise ValueError(r"must validate the regular expression /^[-a-zA-Z0-9_]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TokenRequest:
-        """Create an instance of TokenRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PatchedInvitationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if managed (nullable) is None
-        # and __fields_set__ contains the field
-        if self.managed is None and "managed" in self.__fields_set__:
-            _dict['managed'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.flow is None and "flow" in self.model_fields_set:
+            _dict['flow'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TokenRequest:
-        """Create an instance of TokenRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PatchedInvitationRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TokenRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TokenRequest.parse_obj({
-            "managed": obj.get("managed"),
-            "identifier": obj.get("identifier"),
-            "intent": obj.get("intent"),
-            "user": obj.get("user"),
-            "description": obj.get("description"),
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
             "expires": obj.get("expires"),
-            "expiring": obj.get("expiring")
+            "fixed_data": obj.get("fixed_data"),
+            "single_use": obj.get("single_use"),
+            "flow": obj.get("flow")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/totp_device.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/duo_device_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,62 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictInt, constr
-
-class TOTPDevice(BaseModel):
-    """
-    Serializer for totp authenticator devices  # noqa: E501
+class DuoDeviceRequest(BaseModel):
     """
-    name: constr(strict=True, max_length=64) = Field(..., description="The human-readable name of this device.")
-    pk: StrictInt = Field(...)
-    __properties = ["name", "pk"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for Duo authenticator devices
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=64)] = Field(description="The human-readable name of this device.")
+    __properties: ClassVar[List[str]] = ["name"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TOTPDevice:
-        """Create an instance of TOTPDevice from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of DuoDeviceRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TOTPDevice:
-        """Create an instance of TOTPDevice from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of DuoDeviceRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TOTPDevice.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TOTPDevice.parse_obj({
-            "name": obj.get("name"),
-            "pk": obj.get("pk")
+        _obj = cls.model_validate({
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/totp_device_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/service_connection_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,59 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, constr
-
-class TOTPDeviceRequest(BaseModel):
-    """
-    Serializer for totp authenticator devices  # noqa: E501
+class ServiceConnectionRequest(BaseModel):
     """
-    name: constr(strict=True, max_length=64, min_length=1) = Field(..., description="The human-readable name of this device.")
-    __properties = ["name"]
+    ServiceConnection Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    __properties: ClassVar[List[str]] = ["name", "local"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TOTPDeviceRequest:
-        """Create an instance of TOTPDeviceRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ServiceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TOTPDeviceRequest:
-        """Create an instance of TOTPDeviceRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ServiceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TOTPDeviceRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TOTPDeviceRequest.parse_obj({
-            "name": obj.get("name")
+        _obj = cls.model_validate({
+            "name": obj.get("name"),
+            "local": obj.get("local")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/type_create.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/saml_metadata.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,67 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr
-
-class TypeCreate(BaseModel):
-    """
-    Types of an object that can be created  # noqa: E501
+class SAMLMetadata(BaseModel):
     """
-    name: StrictStr = Field(...)
-    description: StrictStr = Field(...)
-    component: StrictStr = Field(...)
-    model_name: StrictStr = Field(...)
-    requires_enterprise: Optional[StrictBool] = False
-    __properties = ["name", "description", "component", "model_name", "requires_enterprise"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    SAML Provider Metadata serializer
+    """ # noqa: E501
+    metadata: StrictStr
+    download_url: StrictStr
+    __properties: ClassVar[List[str]] = ["metadata", "download_url"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TypeCreate:
-        """Create an instance of TypeCreate from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of SAMLMetadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "metadata",
+            "download_url",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TypeCreate:
-        """Create an instance of TypeCreate from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of SAMLMetadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return TypeCreate.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = TypeCreate.parse_obj({
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "component": obj.get("component"),
-            "model_name": obj.get("model_name"),
-            "requires_enterprise": obj.get("requires_enterprise") if obj.get("requires_enterprise") is not None else False
+        _obj = cls.model_validate({
+            "metadata": obj.get("metadata"),
+            "download_url": obj.get("download_url")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/used_by_action_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/used_by_action_enum.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class UsedByActionEnum(str, Enum):
     """
     UsedByActionEnum
     """
 
@@ -32,12 +29,12 @@
     """
     CASCADE = 'cascade'
     CASCADE_MANY = 'cascade_many'
     SET_NULL = 'set_null'
     SET_DEFAULT = 'set_default'
 
     @classmethod
-    def from_json(cls, json_str: str) -> UsedByActionEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of UsedByActionEnum from a JSON string"""
-        return UsedByActionEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/blueprint_instance.py`

 * *Files 17% similar despite different names*

```diff
@@ -15,106 +15,118 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr
-from authentik_client.models.user_group import UserGroup
-from authentik_client.models.user_type_enum import UserTypeEnum
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.blueprint_instance_status_enum import BlueprintInstanceStatusEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class User(BaseModel):
+class BlueprintInstance(BaseModel):
     """
-    User Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    username: constr(strict=True, max_length=150) = Field(...)
-    name: StrictStr = Field(..., description="User's display name.")
-    is_active: Optional[StrictBool] = Field(None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
-    last_login: Optional[datetime] = None
-    is_superuser: StrictBool = Field(...)
-    groups: Optional[conlist(StrictStr)] = None
-    groups_obj: conlist(UserGroup) = Field(...)
-    email: Optional[constr(strict=True, max_length=254)] = None
-    avatar: StrictStr = Field(..., description="User's avatar, either a http/https URL or a data URI")
-    attributes: Optional[Dict[str, Any]] = None
-    uid: StrictStr = Field(...)
-    path: Optional[StrictStr] = None
-    type: Optional[UserTypeEnum] = None
-    uuid: StrictStr = Field(...)
-    __properties = ["pk", "username", "name", "is_active", "last_login", "is_superuser", "groups", "groups_obj", "email", "avatar", "attributes", "uid", "path", "type", "uuid"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Info about a single blueprint instance file
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    path: Optional[StrictStr] = ''
+    context: Optional[Any] = None
+    last_applied: datetime
+    last_applied_hash: StrictStr
+    status: BlueprintInstanceStatusEnum
+    enabled: Optional[StrictBool] = None
+    managed_models: List[StrictStr]
+    metadata: Optional[Any]
+    content: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["pk", "name", "path", "context", "last_applied", "last_applied_hash", "status", "enabled", "managed_models", "metadata", "content"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> User:
-        """Create an instance of User from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of BlueprintInstance from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "is_superuser",
-                            "groups_obj",
-                            "avatar",
-                            "uid",
-                            "uuid",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in groups_obj (list)
-        _items = []
-        if self.groups_obj:
-            for _item in self.groups_obj:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['groups_obj'] = _items
-        # set to None if last_login (nullable) is None
-        # and __fields_set__ contains the field
-        if self.last_login is None and "last_login" in self.__fields_set__:
-            _dict['last_login'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "last_applied",
+            "last_applied_hash",
+            "status",
+            "managed_models",
+            "metadata",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if context (nullable) is None
+        # and model_fields_set contains the field
+        if self.context is None and "context" in self.model_fields_set:
+            _dict['context'] = None
+
+        # set to None if metadata (nullable) is None
+        # and model_fields_set contains the field
+        if self.metadata is None and "metadata" in self.model_fields_set:
+            _dict['metadata'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> User:
-        """Create an instance of User from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of BlueprintInstance from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return User.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = User.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
-            "username": obj.get("username"),
             "name": obj.get("name"),
-            "is_active": obj.get("is_active"),
-            "last_login": obj.get("last_login"),
-            "is_superuser": obj.get("is_superuser"),
-            "groups": obj.get("groups"),
-            "groups_obj": [UserGroup.from_dict(_item) for _item in obj.get("groups_obj")] if obj.get("groups_obj") is not None else None,
-            "email": obj.get("email"),
-            "avatar": obj.get("avatar"),
-            "attributes": obj.get("attributes"),
-            "uid": obj.get("uid"),
-            "path": obj.get("path"),
-            "type": obj.get("type"),
-            "uuid": obj.get("uuid")
+            "path": obj.get("path") if obj.get("path") is not None else '',
+            "context": obj.get("context"),
+            "last_applied": obj.get("last_applied"),
+            "last_applied_hash": obj.get("last_applied_hash"),
+            "status": obj.get("status"),
+            "enabled": obj.get("enabled"),
+            "managed_models": obj.get("managed_models"),
+            "metadata": obj.get("metadata"),
+            "content": obj.get("content")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_assigned_object_permission.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_assigned_object_permission.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,98 +15,118 @@
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
 from datetime import datetime
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
 from authentik_client.models.user_object_permission import UserObjectPermission
+from typing import Optional, Set
+from typing_extensions import Self
 
 class UserAssignedObjectPermission(BaseModel):
     """
-    Users assigned object permission serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    username: constr(strict=True, max_length=150) = Field(..., description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
-    name: StrictStr = Field(..., description="User's display name.")
-    is_active: Optional[StrictBool] = Field(None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
+    Users assigned object permission serializer
+    """ # noqa: E501
+    pk: StrictInt
+    username: Annotated[str, Field(strict=True, max_length=150)] = Field(description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
+    name: StrictStr = Field(description="User's display name.")
+    is_active: Optional[StrictBool] = Field(default=None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
     last_login: Optional[datetime] = None
-    email: Optional[constr(strict=True, max_length=254)] = None
+    email: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
     attributes: Optional[Dict[str, Any]] = None
-    uid: StrictStr = Field(...)
-    permissions: conlist(UserObjectPermission) = Field(...)
-    is_superuser: StrictBool = Field(...)
-    __properties = ["pk", "username", "name", "is_active", "last_login", "email", "attributes", "uid", "permissions", "is_superuser"]
+    uid: StrictStr
+    permissions: List[UserObjectPermission]
+    is_superuser: StrictBool
+    __properties: ClassVar[List[str]] = ["pk", "username", "name", "is_active", "last_login", "email", "attributes", "uid", "permissions", "is_superuser"]
 
-    @validator('username')
+    @field_validator('username')
     def username_validate_regular_expression(cls, value):
         """Validates the regular expression"""
         if not re.match(r"^[\w.@+-]+$", value):
             raise ValueError(r"must validate the regular expression /^[\w.@+-]+$/")
         return value
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserAssignedObjectPermission:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of UserAssignedObjectPermission from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "uid",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "uid",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in permissions (list)
         _items = []
         if self.permissions:
             for _item in self.permissions:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['permissions'] = _items
         # set to None if last_login (nullable) is None
-        # and __fields_set__ contains the field
-        if self.last_login is None and "last_login" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.last_login is None and "last_login" in self.model_fields_set:
             _dict['last_login'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserAssignedObjectPermission:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of UserAssignedObjectPermission from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserAssignedObjectPermission.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserAssignedObjectPermission.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "username": obj.get("username"),
             "name": obj.get("name"),
             "is_active": obj.get("is_active"),
             "last_login": obj.get("last_login"),
             "email": obj.get("email"),
             "attributes": obj.get("attributes"),
             "uid": obj.get("uid"),
-            "permissions": [UserObjectPermission.from_dict(_item) for _item in obj.get("permissions")] if obj.get("permissions") is not None else None,
+            "permissions": [UserObjectPermission.from_dict(_item) for _item in obj["permissions"]] if obj.get("permissions") is not None else None,
             "is_superuser": obj.get("is_superuser")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_consent.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/event_top_per_user.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,78 +14,79 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
-from authentik_client.models.application import Application
-from authentik_client.models.user import User
+from pydantic import BaseModel, ConfigDict, StrictInt
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UserConsent(BaseModel):
+class EventTopPerUser(BaseModel):
     """
-    UserConsent Serializer  # noqa: E501
-    """
-    pk: StrictInt = Field(...)
-    expires: Optional[datetime] = None
-    expiring: Optional[StrictBool] = None
-    user: User = Field(...)
-    application: Application = Field(...)
-    permissions: Optional[StrictStr] = ''
-    __properties = ["pk", "expires", "expiring", "user", "application", "permissions"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Response object of Event's top_per_user
+    """ # noqa: E501
+    application: Dict[str, Any]
+    counted_events: StrictInt
+    unique_users: StrictInt
+    __properties: ClassVar[List[str]] = ["application", "counted_events", "unique_users"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserConsent:
-        """Create an instance of UserConsent from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of EventTopPerUser from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of user
-        if self.user:
-            _dict['user'] = self.user.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of application
-        if self.application:
-            _dict['application'] = self.application.to_dict()
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserConsent:
-        """Create an instance of UserConsent from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of EventTopPerUser from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserConsent.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserConsent.parse_obj({
-            "pk": obj.get("pk"),
-            "expires": obj.get("expires"),
-            "expiring": obj.get("expiring"),
-            "user": User.from_dict(obj.get("user")) if obj.get("user") is not None else None,
-            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
-            "permissions": obj.get("permissions") if obj.get("permissions") is not None else ''
+        _obj = cls.model_validate({
+            "application": obj.get("application"),
+            "counted_events": obj.get("counted_events"),
+            "unique_users": obj.get("unique_users")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_creation_mode_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_verification_enum.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,34 +9,31 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
+from enum import Enum
+from typing_extensions import Self
 
 
-
-
-
-class UserCreationModeEnum(str, Enum):
+class UserVerificationEnum(str, Enum):
     """
-    UserCreationModeEnum
+    UserVerificationEnum
     """
 
     """
     allowed enum values
     """
-    NEVER_CREATE = 'never_create'
-    CREATE_WHEN_REQUIRED = 'create_when_required'
-    ALWAYS_CREATE = 'always_create'
+    REQUIRED = 'required'
+    PREFERRED = 'preferred'
+    DISCOURAGED = 'discouraged'
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserCreationModeEnum:
-        """Create an instance of UserCreationModeEnum from a JSON string"""
-        return UserCreationModeEnum(json.loads(json_str))
+    def from_json(cls, json_str: str) -> Self:
+        """Create an instance of UserVerificationEnum from a JSON string"""
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_delete_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_service_account_response.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,84 +14,83 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-
-class UserDeleteStage(BaseModel):
-    """
-    UserDeleteStage Serializer  # noqa: E501
+class UserServiceAccountResponse(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    UserServiceAccountResponse
+    """ # noqa: E501
+    username: StrictStr
+    token: StrictStr
+    user_uid: StrictStr
+    user_pk: StrictInt
+    group_pk: Optional[StrictStr] = None
+    __properties: ClassVar[List[str]] = ["username", "token", "user_uid", "user_pk", "group_pk"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserDeleteStage:
-        """Create an instance of UserDeleteStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserServiceAccountResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserDeleteStage:
-        """Create an instance of UserDeleteStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserServiceAccountResponse from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserDeleteStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserDeleteStage.parse_obj({
-            "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+        _obj = cls.model_validate({
+            "username": obj.get("username"),
+            "token": obj.get("token"),
+            "user_uid": obj.get("user_uid"),
+            "user_pk": obj.get("user_pk"),
+            "group_pk": obj.get("group_pk")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_delete_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/notification_transport_test.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,69 +14,75 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class UserDeleteStageRequest(BaseModel):
-    """
-    UserDeleteStage Serializer  # noqa: E501
+class NotificationTransportTest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    __properties = ["name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Notification test serializer
+    """ # noqa: E501
+    messages: List[StrictStr]
+    __properties: ClassVar[List[str]] = ["messages"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserDeleteStageRequest:
-        """Create an instance of UserDeleteStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of NotificationTransportTest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserDeleteStageRequest:
-        """Create an instance of UserDeleteStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of NotificationTransportTest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserDeleteStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserDeleteStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+        _obj = cls.model_validate({
+            "messages": obj.get("messages")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_group.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/metadata.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,79 +14,77 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr
-
-class UserGroup(BaseModel):
-    """
-    Simplified Group Serializer for user's groups  # noqa: E501
+class Metadata(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    num_pk: StrictInt = Field(..., description="Get a numerical, int32 ID for the group")
-    name: constr(strict=True, max_length=80) = Field(...)
-    is_superuser: Optional[StrictBool] = Field(None, description="Users added to this group will be superusers.")
-    parent: Optional[StrictStr] = None
-    parent_name: StrictStr = Field(...)
-    attributes: Optional[Dict[str, Any]] = None
-    __properties = ["pk", "num_pk", "name", "is_superuser", "parent", "parent_name", "attributes"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Serializer for blueprint metadata
+    """ # noqa: E501
+    name: StrictStr
+    labels: Dict[str, Any]
+    __properties: ClassVar[List[str]] = ["name", "labels"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserGroup:
-        """Create an instance of UserGroup from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of Metadata from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "num_pk",
-                            "parent_name",
-                          },
-                          exclude_none=True)
-        # set to None if parent (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parent is None and "parent" in self.__fields_set__:
-            _dict['parent'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
 
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserGroup:
-        """Create an instance of UserGroup from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of Metadata from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserGroup.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserGroup.parse_obj({
-            "pk": obj.get("pk"),
-            "num_pk": obj.get("num_pk"),
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "is_superuser": obj.get("is_superuser"),
-            "parent": obj.get("parent"),
-            "parent_name": obj.get("parent_name"),
-            "attributes": obj.get("attributes")
+            "labels": obj.get("labels")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_group_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_group_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,69 +14,86 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
 class UserGroupRequest(BaseModel):
     """
-    Simplified Group Serializer for user's groups  # noqa: E501
-    """
-    name: constr(strict=True, max_length=80, min_length=1) = Field(...)
-    is_superuser: Optional[StrictBool] = Field(None, description="Users added to this group will be superusers.")
+    Simplified Group Serializer for user's groups
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True, max_length=80)]
+    is_superuser: Optional[StrictBool] = Field(default=None, description="Users added to this group will be superusers.")
     parent: Optional[StrictStr] = None
     attributes: Optional[Dict[str, Any]] = None
-    __properties = ["name", "is_superuser", "parent", "attributes"]
+    __properties: ClassVar[List[str]] = ["name", "is_superuser", "parent", "attributes"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserGroupRequest:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of UserGroupRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # set to None if parent (nullable) is None
-        # and __fields_set__ contains the field
-        if self.parent is None and "parent" in self.__fields_set__:
+        # and model_fields_set contains the field
+        if self.parent is None and "parent" in self.model_fields_set:
             _dict['parent'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserGroupRequest:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of UserGroupRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserGroupRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserGroupRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
             "is_superuser": obj.get("is_superuser"),
             "parent": obj.get("parent"),
             "attributes": obj.get("attributes")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_challenge.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/connection_token.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,91 +14,103 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.endpoint import Endpoint
+from authentik_client.models.group_member import GroupMember
+from authentik_client.models.rac_provider import RACProvider
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Dict, List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.challenge_choices import ChallengeChoices
-from authentik_client.models.contextual_flow_info import ContextualFlowInfo
-from authentik_client.models.error_detail import ErrorDetail
-
-class UserLoginChallenge(BaseModel):
-    """
-    Empty challenge  # noqa: E501
+class ConnectionToken(BaseModel):
     """
-    type: ChallengeChoices = Field(...)
-    flow_info: Optional[ContextualFlowInfo] = None
-    component: Optional[StrictStr] = 'ak-stage-user-login'
-    response_errors: Optional[Dict[str, conlist(ErrorDetail)]] = None
-    pending_user: StrictStr = Field(...)
-    pending_user_avatar: StrictStr = Field(...)
-    __properties = ["type", "flow_info", "component", "response_errors", "pending_user", "pending_user_avatar"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    ConnectionToken Serializer
+    """ # noqa: E501
+    pk: Optional[StrictStr] = None
+    provider: StrictInt
+    provider_obj: RACProvider
+    endpoint: StrictStr
+    endpoint_obj: Endpoint
+    user: GroupMember
+    __properties: ClassVar[List[str]] = ["pk", "provider", "provider_obj", "endpoint", "endpoint_obj", "user"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserLoginChallenge:
-        """Create an instance of UserLoginChallenge from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of ConnectionToken from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of flow_info
-        if self.flow_info:
-            _dict['flow_info'] = self.flow_info.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each value in response_errors (dict of array)
-        _field_dict_of_array = {}
-        if self.response_errors:
-            for _key in self.response_errors:
-                if self.response_errors[_key]:
-                    _field_dict_of_array[_key] = [
-                        _item.to_dict() for _item in self.response_errors[_key]
-                    ]
-            _dict['response_errors'] = _field_dict_of_array
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "provider_obj",
+            "endpoint_obj",
+            "user",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of provider_obj
+        if self.provider_obj:
+            _dict['provider_obj'] = self.provider_obj.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of endpoint_obj
+        if self.endpoint_obj:
+            _dict['endpoint_obj'] = self.endpoint_obj.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of user
+        if self.user:
+            _dict['user'] = self.user.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserLoginChallenge:
-        """Create an instance of UserLoginChallenge from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of ConnectionToken from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserLoginChallenge.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserLoginChallenge.parse_obj({
-            "type": obj.get("type"),
-            "flow_info": ContextualFlowInfo.from_dict(obj.get("flow_info")) if obj.get("flow_info") is not None else None,
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-user-login',
-            "response_errors": dict(
-                (_k,
-                        [ErrorDetail.from_dict(_item) for _item in _v]
-                        if _v is not None
-                        else None
-                )
-                for _k, _v in obj.get("response_errors").items()
-            ),
-            "pending_user": obj.get("pending_user"),
-            "pending_user_avatar": obj.get("pending_user_avatar")
+        _obj = cls.model_validate({
+            "pk": obj.get("pk"),
+            "provider": obj.get("provider"),
+            "provider_obj": RACProvider.from_dict(obj["provider_obj"]) if obj.get("provider_obj") is not None else None,
+            "endpoint": obj.get("endpoint"),
+            "endpoint_obj": Endpoint.from_dict(obj["endpoint_obj"]) if obj.get("endpoint_obj") is not None else None,
+            "user": GroupMember.from_dict(obj["user"]) if obj.get("user") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_challenge_response_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/auto_submit_challenge_response_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,61 +14,76 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictBool, constr
-
-class UserLoginChallengeResponseRequest(BaseModel):
-    """
-    User login challenge  # noqa: E501
+class AutoSubmitChallengeResponseRequest(BaseModel):
     """
-    component: Optional[constr(strict=True, min_length=1)] = 'ak-stage-user-login'
-    remember_me: StrictBool = Field(...)
-    __properties = ["component", "remember_me"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Pseudo class for autosubmit response
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-autosubmit'
+    __properties: ClassVar[List[str]] = ["component"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserLoginChallengeResponseRequest:
-        """Create an instance of UserLoginChallengeResponseRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AutoSubmitChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserLoginChallengeResponseRequest:
-        """Create an instance of UserLoginChallengeResponseRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AutoSubmitChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserLoginChallengeResponseRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserLoginChallengeResponseRequest.parse_obj({
-            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-user-login',
-            "remember_me": obj.get("remember_me")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-autosubmit'
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_login_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/password_stage.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,96 +14,118 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.backends_enum import BackendsEnum
 from authentik_client.models.flow_set import FlowSet
-from authentik_client.models.geoip_binding_enum import GeoipBindingEnum
-from authentik_client.models.network_binding_enum import NetworkBindingEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UserLoginStage(BaseModel):
-    """
-    UserLoginStage Serializer  # noqa: E501
+class PasswordStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    session_duration: Optional[StrictStr] = Field(None, description="Determines how long a session lasts. Default of 0 means that the sessions lasts until the browser is closed. (Format: hours=-1;minutes=-2;seconds=-3)")
-    terminate_other_sessions: Optional[StrictBool] = Field(None, description="Terminate all other sessions of the user logging in.")
-    remember_me_offset: Optional[StrictStr] = Field(None, description="Offset the session will be extended by when the user picks the remember me option. Default of 0 means that the remember me option will not be shown. (Format: hours=-1;minutes=-2;seconds=-3)")
-    network_binding: Optional[NetworkBindingEnum] = Field(None, description="Bind sessions created by this stage to the configured network")
-    geoip_binding: Optional[GeoipBindingEnum] = Field(None, description="Bind sessions created by this stage to the configured GeoIP location")
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "session_duration", "terminate_other_sessions", "remember_me_offset", "network_binding", "geoip_binding"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PasswordStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    backends: List[BackendsEnum] = Field(description="Selection of backends to test the password against.")
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    failed_attempts_before_cancel: Optional[Annotated[int, Field(le=2147483647, strict=True, ge=-2147483648)]] = Field(default=None, description="How many attempts a user has before the flow is canceled. To lock the user out, use a reputation policy and a user_write stage.")
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "backends", "configure_flow", "failed_attempts_before_cancel"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserLoginStage:
-        """Create an instance of UserLoginStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PasswordStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
+        # set to None if configure_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
+            _dict['configure_flow'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserLoginStage:
-        """Create an instance of UserLoginStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PasswordStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserLoginStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserLoginStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "session_duration": obj.get("session_duration"),
-            "terminate_other_sessions": obj.get("terminate_other_sessions"),
-            "remember_me_offset": obj.get("remember_me_offset"),
-            "network_binding": obj.get("network_binding"),
-            "geoip_binding": obj.get("geoip_binding")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "backends": obj.get("backends"),
+            "configure_flow": obj.get("configure_flow"),
+            "failed_attempts_before_cancel": obj.get("failed_attempts_before_cancel")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_logout_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/outpost_health.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,84 +14,106 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictStr, conlist
-from authentik_client.models.flow_set import FlowSet
-
-class UserLogoutStage(BaseModel):
-    """
-    UserLogoutStage Serializer  # noqa: E501
+class OutpostHealth(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Outpost health status
+    """ # noqa: E501
+    uid: StrictStr
+    last_seen: datetime
+    version: StrictStr
+    version_should: StrictStr
+    version_outdated: StrictBool
+    build_hash: StrictStr
+    build_hash_should: StrictStr
+    hostname: StrictStr
+    __properties: ClassVar[List[str]] = ["uid", "last_seen", "version", "version_should", "version_outdated", "build_hash", "build_hash_should", "hostname"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserLogoutStage:
-        """Create an instance of UserLogoutStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of OutpostHealth from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "uid",
+            "last_seen",
+            "version",
+            "version_should",
+            "version_outdated",
+            "build_hash",
+            "build_hash_should",
+            "hostname",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserLogoutStage:
-        """Create an instance of UserLogoutStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of OutpostHealth from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserLogoutStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserLogoutStage.parse_obj({
-            "pk": obj.get("pk"),
-            "name": obj.get("name"),
-            "component": obj.get("component"),
-            "verbose_name": obj.get("verbose_name"),
-            "verbose_name_plural": obj.get("verbose_name_plural"),
-            "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+        _obj = cls.model_validate({
+            "uid": obj.get("uid"),
+            "last_seen": obj.get("last_seen"),
+            "version": obj.get("version"),
+            "version_should": obj.get("version_should"),
+            "version_outdated": obj.get("version_outdated"),
+            "build_hash": obj.get("build_hash"),
+            "build_hash_should": obj.get("build_hash_should"),
+            "hostname": obj.get("hostname")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_logout_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/paginated_dummy_policy_list.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,69 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
+from authentik_client.models.dummy_policy import DummyPolicy
+from authentik_client.models.pagination import Pagination
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-
-class UserLogoutStageRequest(BaseModel):
-    """
-    UserLogoutStage Serializer  # noqa: E501
+class PaginatedDummyPolicyList(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    __properties = ["name", "flow_set"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    PaginatedDummyPolicyList
+    """ # noqa: E501
+    pagination: Pagination
+    results: List[DummyPolicy]
+    __properties: ClassVar[List[str]] = ["pagination", "results"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserLogoutStageRequest:
-        """Create an instance of UserLogoutStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PaginatedDummyPolicyList from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of pagination
+        if self.pagination:
+            _dict['pagination'] = self.pagination.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
         _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
+        if self.results:
+            for _item in self.results:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
+            _dict['results'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserLogoutStageRequest:
-        """Create an instance of UserLogoutStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PaginatedDummyPolicyList from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserLogoutStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserLogoutStageRequest.parse_obj({
-            "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None
+        _obj = cls.model_validate({
+            "pagination": Pagination.from_dict(obj["pagination"]) if obj.get("pagination") is not None else None,
+            "results": [DummyPolicy.from_dict(_item) for _item in obj["results"]] if obj.get("results") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_matching_mode_enum.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_matching_mode_enum.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,21 +9,18 @@
     Contact: hello@goauthentik.io
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
+from __future__ import annotations
 import json
-import pprint
-import re  # noqa: F401
-from aenum import Enum, no_arg
-
-
-
+from enum import Enum
+from typing_extensions import Self
 
 
 class UserMatchingModeEnum(str, Enum):
     """
     UserMatchingModeEnum
     """
 
@@ -33,12 +30,12 @@
     IDENTIFIER = 'identifier'
     EMAIL_LINK = 'email_link'
     EMAIL_DENY = 'email_deny'
     USERNAME_LINK = 'username_link'
     USERNAME_DENY = 'username_deny'
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserMatchingModeEnum:
+    def from_json(cls, json_str: str) -> Self:
         """Create an instance of UserMatchingModeEnum from a JSON string"""
-        return UserMatchingModeEnum(json.loads(json_str))
+        return cls(json.loads(json_str))
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_metrics.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_metrics.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,55 +14,74 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List
-from pydantic import BaseModel, Field, conlist
+from pydantic import BaseModel, ConfigDict
+from typing import Any, ClassVar, Dict, List
 from authentik_client.models.coordinate import Coordinate
+from typing import Optional, Set
+from typing_extensions import Self
 
 class UserMetrics(BaseModel):
     """
-    User Metrics  # noqa: E501
-    """
-    logins: conlist(Coordinate) = Field(...)
-    logins_failed: conlist(Coordinate) = Field(...)
-    authorizations: conlist(Coordinate) = Field(...)
-    __properties = ["logins", "logins_failed", "authorizations"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User Metrics
+    """ # noqa: E501
+    logins: List[Coordinate]
+    logins_failed: List[Coordinate]
+    authorizations: List[Coordinate]
+    __properties: ClassVar[List[str]] = ["logins", "logins_failed", "authorizations"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserMetrics:
+    def from_json(cls, json_str: str) -> Optional[Self]:
         """Create an instance of UserMetrics from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "logins",
-                            "logins_failed",
-                            "authorizations",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "logins",
+            "logins_failed",
+            "authorizations",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in logins (list)
         _items = []
         if self.logins:
             for _item in self.logins:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['logins'] = _items
@@ -79,23 +98,23 @@
             for _item in self.authorizations:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['authorizations'] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserMetrics:
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
         """Create an instance of UserMetrics from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserMetrics.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserMetrics.parse_obj({
-            "logins": [Coordinate.from_dict(_item) for _item in obj.get("logins")] if obj.get("logins") is not None else None,
-            "logins_failed": [Coordinate.from_dict(_item) for _item in obj.get("logins_failed")] if obj.get("logins_failed") is not None else None,
-            "authorizations": [Coordinate.from_dict(_item) for _item in obj.get("authorizations")] if obj.get("authorizations") is not None else None
+        _obj = cls.model_validate({
+            "logins": [Coordinate.from_dict(_item) for _item in obj["logins"]] if obj.get("logins") is not None else None,
+            "logins_failed": [Coordinate.from_dict(_item) for _item in obj["logins_failed"]] if obj.get("logins_failed") is not None else None,
+            "authorizations": [Coordinate.from_dict(_item) for _item in obj["authorizations"]] if obj.get("authorizations") is not None else None
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticated_session_asn.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,81 +14,89 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-from datetime import datetime
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from authentik_client.models.user_type_enum import UserTypeEnum
+from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UserRequest(BaseModel):
+class AuthenticatedSessionAsn(BaseModel):
     """
-    User Serializer  # noqa: E501
-    """
-    username: constr(strict=True, max_length=150, min_length=1) = Field(...)
-    name: StrictStr = Field(..., description="User's display name.")
-    is_active: Optional[StrictBool] = Field(None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
-    last_login: Optional[datetime] = None
-    groups: Optional[conlist(StrictStr)] = None
-    email: Optional[constr(strict=True, max_length=254)] = None
-    attributes: Optional[Dict[str, Any]] = None
-    path: Optional[constr(strict=True, min_length=1)] = None
-    type: Optional[UserTypeEnum] = None
-    __properties = ["username", "name", "is_active", "last_login", "groups", "email", "attributes", "path", "type"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Get ASN Data
+    """ # noqa: E501
+    asn: StrictInt
+    as_org: Optional[StrictStr]
+    network: Optional[StrictStr]
+    __properties: ClassVar[List[str]] = ["asn", "as_org", "network"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserRequest:
-        """Create an instance of UserRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionAsn from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # set to None if last_login (nullable) is None
-        # and __fields_set__ contains the field
-        if self.last_login is None and "last_login" in self.__fields_set__:
-            _dict['last_login'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if as_org (nullable) is None
+        # and model_fields_set contains the field
+        if self.as_org is None and "as_org" in self.model_fields_set:
+            _dict['as_org'] = None
+
+        # set to None if network (nullable) is None
+        # and model_fields_set contains the field
+        if self.network is None and "network" in self.model_fields_set:
+            _dict['network'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserRequest:
-        """Create an instance of UserRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatedSessionAsn from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserRequest.parse_obj({
-            "username": obj.get("username"),
-            "name": obj.get("name"),
-            "is_active": obj.get("is_active"),
-            "last_login": obj.get("last_login"),
-            "groups": obj.get("groups"),
-            "email": obj.get("email"),
-            "attributes": obj.get("attributes"),
-            "path": obj.get("path"),
-            "type": obj.get("type")
+        _obj = cls.model_validate({
+            "asn": obj.get("asn"),
+            "as_org": obj.get("as_org"),
+            "network": obj.get("network")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_self.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,105 +14,131 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import Any, Dict, List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
-from authentik_client.models.user_self_groups import UserSelfGroups
+from datetime import datetime
+from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from authentik_client.models.user_group import UserGroup
 from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UserSelf(BaseModel):
-    """
-    User Serializer for information a user can retrieve about themselves  # noqa: E501
+class User(BaseModel):
     """
-    pk: StrictInt = Field(...)
-    username: constr(strict=True, max_length=150) = Field(..., description="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.")
-    name: StrictStr = Field(..., description="User's display name.")
-    is_active: StrictBool = Field(..., description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
-    is_superuser: StrictBool = Field(...)
-    groups: conlist(UserSelfGroups) = Field(...)
-    email: Optional[constr(strict=True, max_length=254)] = None
-    avatar: StrictStr = Field(..., description="User's avatar, either a http/https URL or a data URI")
-    uid: StrictStr = Field(...)
-    settings: Dict[str, Any] = Field(..., description="Get user settings with brand and group settings applied")
+    User Serializer
+    """ # noqa: E501
+    pk: StrictInt
+    username: Annotated[str, Field(strict=True, max_length=150)]
+    name: StrictStr = Field(description="User's display name.")
+    is_active: Optional[StrictBool] = Field(default=None, description="Designates whether this user should be treated as active. Unselect this instead of deleting accounts.")
+    last_login: Optional[datetime] = None
+    is_superuser: StrictBool
+    groups: Optional[List[StrictStr]] = None
+    groups_obj: List[UserGroup]
+    email: Optional[Annotated[str, Field(strict=True, max_length=254)]] = None
+    avatar: StrictStr = Field(description="User's avatar, either a http/https URL or a data URI")
+    attributes: Optional[Dict[str, Any]] = None
+    uid: StrictStr
+    path: Optional[StrictStr] = None
     type: Optional[UserTypeEnum] = None
-    system_permissions: conlist(StrictStr) = Field(..., description="Get all system permissions assigned to the user")
-    __properties = ["pk", "username", "name", "is_active", "is_superuser", "groups", "email", "avatar", "uid", "settings", "type", "system_permissions"]
+    uuid: StrictStr
+    __properties: ClassVar[List[str]] = ["pk", "username", "name", "is_active", "last_login", "is_superuser", "groups", "groups_obj", "email", "avatar", "attributes", "uid", "path", "type", "uuid"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
 
-    @validator('username')
-    def username_validate_regular_expression(cls, value):
-        """Validates the regular expression"""
-        if not re.match(r"^[\w.@+-]+$", value):
-            raise ValueError(r"must validate the regular expression /^[\w.@+-]+$/")
-        return value
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserSelf:
-        """Create an instance of UserSelf from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of User from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "is_active",
-                            "is_superuser",
-                            "groups",
-                            "avatar",
-                            "uid",
-                            "settings",
-                            "system_permissions",
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in groups (list)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "is_superuser",
+            "groups_obj",
+            "avatar",
+            "uid",
+            "uuid",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of each item in groups_obj (list)
         _items = []
-        if self.groups:
-            for _item in self.groups:
+        if self.groups_obj:
+            for _item in self.groups_obj:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict['groups'] = _items
+            _dict['groups_obj'] = _items
+        # set to None if last_login (nullable) is None
+        # and model_fields_set contains the field
+        if self.last_login is None and "last_login" in self.model_fields_set:
+            _dict['last_login'] = None
+
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserSelf:
-        """Create an instance of UserSelf from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of User from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserSelf.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserSelf.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "username": obj.get("username"),
             "name": obj.get("name"),
             "is_active": obj.get("is_active"),
+            "last_login": obj.get("last_login"),
             "is_superuser": obj.get("is_superuser"),
-            "groups": [UserSelfGroups.from_dict(_item) for _item in obj.get("groups")] if obj.get("groups") is not None else None,
+            "groups": obj.get("groups"),
+            "groups_obj": [UserGroup.from_dict(_item) for _item in obj["groups_obj"]] if obj.get("groups_obj") is not None else None,
             "email": obj.get("email"),
             "avatar": obj.get("avatar"),
+            "attributes": obj.get("attributes"),
             "uid": obj.get("uid"),
-            "settings": obj.get("settings"),
+            "path": obj.get("path"),
             "type": obj.get("type"),
-            "system_permissions": obj.get("system_permissions")
+            "uuid": obj.get("uuid")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_self_groups.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/property_mapping_test_result.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,63 +14,81 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
+from typing import Any, ClassVar, Dict, List
+from typing import Optional, Set
+from typing_extensions import Self
 
-
-from pydantic import BaseModel, Field, StrictStr
-
-class UserSelfGroups(BaseModel):
-    """
-    UserSelfGroups
+class PropertyMappingTestResult(BaseModel):
     """
-    name: StrictStr = Field(...)
-    pk: StrictStr = Field(...)
-    __properties = ["name", "pk"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    Result of a Property-mapping test
+    """ # noqa: E501
+    result: StrictStr
+    successful: StrictBool
+    __properties: ClassVar[List[str]] = ["result", "successful"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserSelfGroups:
-        """Create an instance of UserSelfGroups from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of PropertyMappingTestResult from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "name",
-                            "pk",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "result",
+            "successful",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserSelfGroups:
-        """Create an instance of UserSelfGroups from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of PropertyMappingTestResult from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserSelfGroups.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserSelfGroups.parse_obj({
-            "name": obj.get("name"),
-            "pk": obj.get("pk")
+        _obj = cls.model_validate({
+            "result": obj.get("result"),
+            "successful": obj.get("successful")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_write_stage.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/authenticator_totp_stage.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,101 +14,122 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
-
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
+from pydantic import BaseModel, ConfigDict, Field, StrictStr
+from typing import Any, ClassVar, Dict, List, Optional
+from authentik_client.models.digits_enum import DigitsEnum
 from authentik_client.models.flow_set import FlowSet
-from authentik_client.models.user_creation_mode_enum import UserCreationModeEnum
-from authentik_client.models.user_type_enum import UserTypeEnum
+from typing import Optional, Set
+from typing_extensions import Self
 
-class UserWriteStage(BaseModel):
-    """
-    UserWriteStage Serializer  # noqa: E501
+class AuthenticatorTOTPStage(BaseModel):
     """
-    pk: StrictStr = Field(...)
-    name: StrictStr = Field(...)
-    component: StrictStr = Field(..., description="Get object type so that we know how to edit the object")
-    verbose_name: StrictStr = Field(..., description="Return object's verbose_name")
-    verbose_name_plural: StrictStr = Field(..., description="Return object's plural verbose_name")
-    meta_model_name: StrictStr = Field(..., description="Return internal model name")
-    flow_set: Optional[conlist(FlowSet)] = None
-    user_creation_mode: Optional[UserCreationModeEnum] = None
-    create_users_as_inactive: Optional[StrictBool] = Field(None, description="When set, newly created users are inactive and cannot login.")
-    create_users_group: Optional[StrictStr] = Field(None, description="Optionally add newly created users to this group.")
-    user_type: Optional[UserTypeEnum] = None
-    user_path_template: Optional[StrictStr] = None
-    __properties = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "user_creation_mode", "create_users_as_inactive", "create_users_group", "user_type", "user_path_template"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    AuthenticatorTOTPStage Serializer
+    """ # noqa: E501
+    pk: StrictStr
+    name: StrictStr
+    component: StrictStr = Field(description="Get object type so that we know how to edit the object")
+    verbose_name: StrictStr = Field(description="Return object's verbose_name")
+    verbose_name_plural: StrictStr = Field(description="Return object's plural verbose_name")
+    meta_model_name: StrictStr = Field(description="Return internal model name")
+    flow_set: Optional[List[FlowSet]] = None
+    configure_flow: Optional[StrictStr] = Field(default=None, description="Flow used by an authenticated user to configure this Stage. If empty, user will not be able to configure this stage.")
+    friendly_name: Optional[StrictStr] = None
+    digits: DigitsEnum
+    __properties: ClassVar[List[str]] = ["pk", "name", "component", "verbose_name", "verbose_name_plural", "meta_model_name", "flow_set", "configure_flow", "friendly_name", "digits"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserWriteStage:
-        """Create an instance of UserWriteStage from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "pk",
-                            "component",
-                            "verbose_name",
-                            "verbose_name_plural",
-                            "meta_model_name",
-                          },
-                          exclude_none=True)
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        * OpenAPI `readOnly` fields are excluded.
+        """
+        excluded_fields: Set[str] = set([
+            "pk",
+            "component",
+            "verbose_name",
+            "verbose_name_plural",
+            "meta_model_name",
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
         _items = []
         if self.flow_set:
             for _item in self.flow_set:
                 if _item:
                     _items.append(_item.to_dict())
             _dict['flow_set'] = _items
-        # set to None if create_users_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.create_users_group is None and "create_users_group" in self.__fields_set__:
-            _dict['create_users_group'] = None
+        # set to None if configure_flow (nullable) is None
+        # and model_fields_set contains the field
+        if self.configure_flow is None and "configure_flow" in self.model_fields_set:
+            _dict['configure_flow'] = None
+
+        # set to None if friendly_name (nullable) is None
+        # and model_fields_set contains the field
+        if self.friendly_name is None and "friendly_name" in self.model_fields_set:
+            _dict['friendly_name'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserWriteStage:
-        """Create an instance of UserWriteStage from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of AuthenticatorTOTPStage from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserWriteStage.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserWriteStage.parse_obj({
+        _obj = cls.model_validate({
             "pk": obj.get("pk"),
             "name": obj.get("name"),
             "component": obj.get("component"),
             "verbose_name": obj.get("verbose_name"),
             "verbose_name_plural": obj.get("verbose_name_plural"),
             "meta_model_name": obj.get("meta_model_name"),
-            "flow_set": [FlowSet.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "user_creation_mode": obj.get("user_creation_mode"),
-            "create_users_as_inactive": obj.get("create_users_as_inactive"),
-            "create_users_group": obj.get("create_users_group"),
-            "user_type": obj.get("user_type"),
-            "user_path_template": obj.get("user_path_template")
+            "flow_set": [FlowSet.from_dict(_item) for _item in obj["flow_set"]] if obj.get("flow_set") is not None else None,
+            "configure_flow": obj.get("configure_flow"),
+            "friendly_name": obj.get("friendly_name"),
+            "digits": obj.get("digits")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/user_write_stage_request.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/kubernetes_service_connection_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,86 +14,87 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, constr
-from authentik_client.models.flow_set_request import FlowSetRequest
-from authentik_client.models.user_creation_mode_enum import UserCreationModeEnum
-from authentik_client.models.user_type_enum import UserTypeEnum
-
-class UserWriteStageRequest(BaseModel):
-    """
-    UserWriteStage Serializer  # noqa: E501
+class KubernetesServiceConnectionRequest(BaseModel):
     """
-    name: constr(strict=True, min_length=1) = Field(...)
-    flow_set: Optional[conlist(FlowSetRequest)] = None
-    user_creation_mode: Optional[UserCreationModeEnum] = None
-    create_users_as_inactive: Optional[StrictBool] = Field(None, description="When set, newly created users are inactive and cannot login.")
-    create_users_group: Optional[StrictStr] = Field(None, description="Optionally add newly created users to this group.")
-    user_type: Optional[UserTypeEnum] = None
-    user_path_template: Optional[StrictStr] = None
-    __properties = ["name", "flow_set", "user_creation_mode", "create_users_as_inactive", "create_users_group", "user_type", "user_path_template"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    KubernetesServiceConnection Serializer
+    """ # noqa: E501
+    name: Annotated[str, Field(min_length=1, strict=True)]
+    local: Optional[StrictBool] = Field(default=None, description="If enabled, use the local connection. Required Docker socket/Kubernetes Integration")
+    kubeconfig: Optional[Any] = Field(default=None, description="Paste your kubeconfig here. authentik will automatically use the currently selected context.")
+    verify_ssl: Optional[StrictBool] = Field(default=None, description="Verify SSL Certificates of the Kubernetes API endpoint")
+    __properties: ClassVar[List[str]] = ["name", "local", "kubeconfig", "verify_ssl"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UserWriteStageRequest:
-        """Create an instance of UserWriteStageRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of KubernetesServiceConnectionRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                          },
-                          exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in flow_set (list)
-        _items = []
-        if self.flow_set:
-            for _item in self.flow_set:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['flow_set'] = _items
-        # set to None if create_users_group (nullable) is None
-        # and __fields_set__ contains the field
-        if self.create_users_group is None and "create_users_group" in self.__fields_set__:
-            _dict['create_users_group'] = None
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
+
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
+        # set to None if kubeconfig (nullable) is None
+        # and model_fields_set contains the field
+        if self.kubeconfig is None and "kubeconfig" in self.model_fields_set:
+            _dict['kubeconfig'] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UserWriteStageRequest:
-        """Create an instance of UserWriteStageRequest from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of KubernetesServiceConnectionRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return UserWriteStageRequest.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = UserWriteStageRequest.parse_obj({
+        _obj = cls.model_validate({
             "name": obj.get("name"),
-            "flow_set": [FlowSetRequest.from_dict(_item) for _item in obj.get("flow_set")] if obj.get("flow_set") is not None else None,
-            "user_creation_mode": obj.get("user_creation_mode"),
-            "create_users_as_inactive": obj.get("create_users_as_inactive"),
-            "create_users_group": obj.get("create_users_group"),
-            "user_type": obj.get("user_type"),
-            "user_path_template": obj.get("user_path_template")
+            "local": obj.get("local"),
+            "kubeconfig": obj.get("kubeconfig"),
+            "verify_ssl": obj.get("verify_ssl")
         })
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/authentik_client/models/validation_error.py` & `authentik_client-2024.2.2.post1712239192/authentik_client/models/user_login_challenge_response_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -14,73 +14,78 @@
 
 
 from __future__ import annotations
 import pprint
 import re  # noqa: F401
 import json
 
+from pydantic import BaseModel, ConfigDict, Field, StrictBool
+from typing import Any, ClassVar, Dict, List, Optional
+from typing_extensions import Annotated
+from typing import Optional, Set
+from typing_extensions import Self
 
-from typing import List, Optional
-from pydantic import BaseModel, StrictStr, conlist
-
-class ValidationError(BaseModel):
-    """
-    Validation Error  # noqa: E501
+class UserLoginChallengeResponseRequest(BaseModel):
     """
-    non_field_errors: Optional[conlist(StrictStr)] = None
-    code: Optional[StrictStr] = None
-    additional_properties: Dict[str, Any] = {}
-    __properties = ["non_field_errors", "code"]
-
-    class Config:
-        """Pydantic configuration"""
-        allow_population_by_field_name = True
-        validate_assignment = True
+    User login challenge
+    """ # noqa: E501
+    component: Optional[Annotated[str, Field(min_length=1, strict=True)]] = 'ak-stage-user-login'
+    remember_me: StrictBool
+    __properties: ClassVar[List[str]] = ["component", "remember_me"]
+
+    model_config = ConfigDict(
+        populate_by_name=True,
+        validate_assignment=True,
+        protected_namespaces=(),
+    )
+
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.dict(by_alias=True))
+        return pprint.pformat(self.model_dump(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
+        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ValidationError:
-        """Create an instance of ValidationError from a JSON string"""
+    def from_json(cls, json_str: str) -> Optional[Self]:
+        """Create an instance of UserLoginChallengeResponseRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self):
-        """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True,
-                          exclude={
-                            "additional_properties"
-                          },
-                          exclude_none=True)
-        # puts key-value pairs in additional_properties in the top level
-        if self.additional_properties is not None:
-            for _key, _value in self.additional_properties.items():
-                _dict[_key] = _value
+    def to_dict(self) -> Dict[str, Any]:
+        """Return the dictionary representation of the model using alias.
 
+        This has the following differences from calling pydantic's
+        `self.model_dump(by_alias=True)`:
+
+        * `None` is only added to the output dict for nullable fields that
+          were set at model initialization. Other fields with value `None`
+          are ignored.
+        """
+        excluded_fields: Set[str] = set([
+        ])
+
+        _dict = self.model_dump(
+            by_alias=True,
+            exclude=excluded_fields,
+            exclude_none=True,
+        )
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ValidationError:
-        """Create an instance of ValidationError from a dict"""
+    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
+        """Create an instance of UserLoginChallengeResponseRequest from a dict"""
         if obj is None:
             return None
 
         if not isinstance(obj, dict):
-            return ValidationError.parse_obj(obj)
+            return cls.model_validate(obj)
 
-        _obj = ValidationError.parse_obj({
-            "non_field_errors": obj.get("non_field_errors"),
-            "code": obj.get("code")
+        _obj = cls.model_validate({
+            "component": obj.get("component") if obj.get("component") is not None else 'ak-stage-user-login',
+            "remember_me": obj.get("remember_me")
         })
-        # store additional fields in additional_properties
-        for _key in obj.keys():
-            if _key not in cls.__properties:
-                _obj.additional_properties[_key] = obj.get(_key)
-
         return _obj
```

### Comparing `authentik_client-2024.2.2.post1710845398/PKG-INFO` & `authentik_client-2024.2.2.post1712239192/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: authentik_client
-Version: 2024.2.2.post1710845398
+Version: 2024.2.2.post1712239192
 Summary: authentik
 Home-page: https://github.com/goauthentik/authentik
 License: MIT
 Keywords: OpenAPI,OpenAPI-Generator,authentik
 Author: authentik Team
 Author-email: hello@goauthentik.io
 Requires-Python: >=3.7,<4.0
@@ -12,29 +12,30 @@
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
-Requires-Dist: aenum (>=3.1.11)
-Requires-Dist: pydantic (>=1.10.5,<2.0.0)
+Requires-Dist: pydantic (>=2)
 Requires-Dist: python-dateutil (>=2.8.2)
+Requires-Dist: typing-extensions (>=4.7.1)
 Requires-Dist: urllib3 (>=1.25.3)
 Project-URL: Repository, https://github.com/goauthentik/authentik
 Description-Content-Type: text/markdown
 
 # authentik-client
 Making authentication simple.
 
 This Python package is automatically generated by the [OpenAPI Generator](https://openapi-generator.tech) project:
 
 - API version: 2024.2.2
-- Package version: 2024.2.2-1710845398
-- Build package: org.openapitools.codegen.languages.PythonPydanticV1ClientCodegen
+- Package version: 2024.2.2-1712239192
+- Generator version: 7.4.0
+- Build package: org.openapitools.codegen.languages.PythonClientCodegen
 
 ## Requirements.
 
 Python 3.7+
 
 ## Installation & Usage
 ### pip install
@@ -71,15 +72,14 @@
 
 ## Getting Started
 
 Please follow the [installation procedure](#installation--usage) and then run the following:
 
 ```python
 
-import time
 import authentik_client
 from authentik_client.rest import ApiException
 from pprint import pprint
 
 # Defining the host is optional and defaults to http://localhost/api/v3
 # See configuration.py for a list of all supported configuration parameters.
 configuration = authentik_client.Configuration(
@@ -1010,14 +1010,16 @@
  - [LDAPSourceRequest](docs/LDAPSourceRequest.md)
  - [LDAPSyncStatus](docs/LDAPSyncStatus.md)
  - [License](docs/License.md)
  - [LicenseForecast](docs/LicenseForecast.md)
  - [LicenseRequest](docs/LicenseRequest.md)
  - [LicenseSummary](docs/LicenseSummary.md)
  - [Link](docs/Link.md)
+ - [LogEvent](docs/LogEvent.md)
+ - [LogLevelEnum](docs/LogLevelEnum.md)
  - [LoginChallengeTypes](docs/LoginChallengeTypes.md)
  - [LoginMetrics](docs/LoginMetrics.md)
  - [LoginSource](docs/LoginSource.md)
  - [Metadata](docs/Metadata.md)
  - [ModelEnum](docs/ModelEnum.md)
  - [ModelRequest](docs/ModelRequest.md)
  - [NameIdPolicyEnum](docs/NameIdPolicyEnum.md)
```

