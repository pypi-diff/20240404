# Comparing `tmp/dara_components-1.7.6-py3-none-any.whl.zip` & `tmp/dara_components-1.7.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,15 +1,15 @@
-Zip file size: 3043961 bytes, number of entries: 83
+Zip file size: 3085528 bytes, number of entries: 83
 -rw-r--r--  2.0 unx      808 b- defN 80-Jan-01 00:00 dara/components/__init__.py
 -rw-r--r--  2.0 unx     3866 b- defN 80-Jan-01 00:00 dara/components/common/__init__.py
 -rw-r--r--  2.0 unx     9487 b- defN 80-Jan-01 00:00 dara/components/common/accordion.py
 -rw-r--r--  2.0 unx     2869 b- defN 80-Jan-01 00:00 dara/components/common/anchor.py
 -rw-r--r--  2.0 unx     4707 b- defN 80-Jan-01 00:00 dara/components/common/base_component.py
 -rw-r--r--  2.0 unx     1433 b- defN 80-Jan-01 00:00 dara/components/common/bullet_list.py
--rw-r--r--  2.0 unx     4548 b- defN 80-Jan-01 00:00 dara/components/common/button.py
+-rw-r--r--  2.0 unx     4549 b- defN 80-Jan-01 00:00 dara/components/common/button.py
 -rw-r--r--  2.0 unx     3600 b- defN 80-Jan-01 00:00 dara/components/common/button_bar.py
 -rw-r--r--  2.0 unx     1999 b- defN 80-Jan-01 00:00 dara/components/common/card.py
 -rw-r--r--  2.0 unx     5369 b- defN 80-Jan-01 00:00 dara/components/common/carousel.py
 -rw-r--r--  2.0 unx     4156 b- defN 80-Jan-01 00:00 dara/components/common/checkbox_group.py
 -rw-r--r--  2.0 unx     2266 b- defN 80-Jan-01 00:00 dara/components/common/code.py
 -rw-r--r--  2.0 unx     2750 b- defN 80-Jan-01 00:00 dara/components/common/component_select_list.py
 -rw-r--r--  2.0 unx     3613 b- defN 80-Jan-01 00:00 dara/components/common/datepicker.py
@@ -72,14 +72,14 @@
 -rw-r--r--  2.0 unx     4120 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/data_slicer_modal.py
 -rw-r--r--  2.0 unx     1616 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/extension/data_slicer_filter.py
 -rw-r--r--  2.0 unx     1345 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/extension/filter_status_button.py
 -rw-r--r--  2.0 unx     8656 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/utils/core.py
 -rw-r--r--  2.0 unx     1722 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/utils/data_preview.py
 -rw-r--r--  2.0 unx     3313 b- defN 80-Jan-01 00:00 dara/components/smart/data_slicer/utils/plotting.py
 -rw-r--r--  2.0 unx     2877 b- defN 80-Jan-01 00:00 dara/components/smart/hierarchy.py
--rw-r--r--  2.0 unx 16835276 b- defN 80-Jan-01 00:00 dara/components/umd/dara.components.umd.js
+-rw-r--r--  2.0 unx 17065436 b- defN 80-Jan-01 00:00 dara/components/umd/dara.components.umd.js
 -rw-r--r--  2.0 unx    23576 b- defN 80-Jan-01 00:00 dara/components/umd/style.css
--rw-r--r--  2.0 unx    10944 b- defN 80-Jan-01 00:00 dara_components-1.7.6.dist-info/LICENSE
--rw-r--r--  2.0 unx     2710 b- defN 80-Jan-01 00:00 dara_components-1.7.6.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dara_components-1.7.6.dist-info/WHEEL
-?rw-r--r--  2.0 unx     7873 b- defN 16-Jan-01 00:00 dara_components-1.7.6.dist-info/RECORD
-83 files, 17161867 bytes uncompressed, 3031235 bytes compressed:  82.3%
+-rw-r--r--  2.0 unx    10944 b- defN 80-Jan-01 00:00 dara_components-1.7.7.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2710 b- defN 80-Jan-01 00:00 dara_components-1.7.7.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dara_components-1.7.7.dist-info/WHEEL
+?rw-r--r--  2.0 unx     7873 b- defN 16-Jan-01 00:00 dara_components-1.7.7.dist-info/RECORD
+83 files, 17392028 bytes uncompressed, 3072802 bytes compressed:  82.3%
```

## zipnote {}

```diff
@@ -231,20 +231,20 @@
 
 Filename: dara/components/umd/dara.components.umd.js
 Comment: 
 
 Filename: dara/components/umd/style.css
 Comment: 
 
-Filename: dara_components-1.7.6.dist-info/LICENSE
+Filename: dara_components-1.7.7.dist-info/LICENSE
 Comment: 
 
-Filename: dara_components-1.7.6.dist-info/METADATA
+Filename: dara_components-1.7.7.dist-info/METADATA
 Comment: 
 
-Filename: dara_components-1.7.6.dist-info/WHEEL
+Filename: dara_components-1.7.7.dist-info/WHEEL
 Comment: 
 
-Filename: dara_components-1.7.6.dist-info/RECORD
+Filename: dara_components-1.7.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dara/components/common/button.py

```diff
@@ -52,22 +52,22 @@
     from dara.core import NavigateTo
     from dara.components import Button, ButtonStyle
 
     Button(
         'Click',
         onclick=NavigateTo('/test'),
         icon='Pen',
-        styling='ButtonStyle.SECONDARY,
+        styling=ButtonStyle.SECONDARY,
         outline=True,
     )
 
     ```
 
     The different button styles supported are: 'error', 'ghost', 'plain', 'primary' and 'secondary'. Other styling option
-    is to choose whether to show the outline or filled version with the outline property. This defults to False.
+    is to choose whether to show the outline or filled version with the outline property. This defaults to False.
 
     A button component that is disabled but can be enabled by updating the variable disabling it:
 
     ```python
 
     from dara.core import Variable, NavigateTo
     from dara.components import Button
@@ -89,15 +89,15 @@
 
     from dara.core import NavigateTo
     from dara.components import Button, Stack, Text
 
     Button(
         Stack(
             Text(
-                'Stack passed to buton, when clicked I navigate to test page',
+                'Stack passed to button, when clicked I navigate to test page',
             ),
         ),
         onclick=NavigateTo('/test'),
     )
 
     ```
```

## dara/components/umd/dara.components.umd.js

### js-beautify {}

```diff
@@ -29,14 +29,15 @@
         n2.default = e3;
         return Object.freeze(n2);
     }
     const React__default = /* @__PURE__ */ _interopDefaultLegacy(React);
     const React__namespace = /* @__PURE__ */ _interopNamespace(React);
     const styled__default = /* @__PURE__ */ _interopDefaultLegacy(styled);
     const ReactDOM__default = /* @__PURE__ */ _interopDefaultLegacy(ReactDOM);
+    const ReactDOM__namespace = /* @__PURE__ */ _interopNamespace(ReactDOM);
     const theme$3 = {
         colors: {
             primary: "#3796F6",
             primaryHover: "#0079D4",
             primaryDown: "#0060AA",
             secondary: "#434B87",
             secondaryHover: "#4E568E",
@@ -126,45 +127,45 @@
         shadow: {
             light: "0px 2px 4px rgba(0, 0, 0, 0.1)",
             medium: "0px 2px 10px rgba(0, 0, 0, 0.1)"
         },
         themeType: "dark"
     };
 
-    function useClTheme() {
+    function useClTheme$1() {
         return styled.useTheme();
     }
-    var Key;
+    var Key$1;
     (function(Key2) {
         Key2["BACKSPACE"] = "Backspace";
         Key2["CTRL"] = "Control";
         Key2["DOWN"] = "ArrowDown";
         Key2["ENTER"] = "Enter";
         Key2["ESCAPE"] = "Escape";
         Key2["LEFT"] = "ArrowLeft";
         Key2["META"] = "Meta";
         Key2["MINUS"] = "-";
         Key2["PERIOD"] = ".";
         Key2["RIGHT"] = "ArrowRight";
         Key2["SHIFT"] = "Shift";
         Key2["TAB"] = "Tab";
         Key2["UP"] = "ArrowUp";
-    })(Key || (Key = {}));
-    const CONTROL_KEYS = [
-        Key.ESCAPE,
-        Key.TAB,
-        Key.ENTER,
-        Key.BACKSPACE,
-        Key.CTRL,
-        Key.SHIFT,
-        Key.UP,
-        Key.DOWN,
-        Key.LEFT,
-        Key.RIGHT,
-        Key.META
+    })(Key$1 || (Key$1 = {}));
+    const CONTROL_KEYS$1 = [
+        Key$1.ESCAPE,
+        Key$1.TAB,
+        Key$1.ENTER,
+        Key$1.BACKSPACE,
+        Key$1.CTRL,
+        Key$1.SHIFT,
+        Key$1.UP,
+        Key$1.DOWN,
+        Key$1.LEFT,
+        Key$1.RIGHT,
+        Key$1.META
     ];
     var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
 
     function getDefaultExportFromCjs(x2) {
         return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
     }
 
@@ -200,50 +201,50 @@
      * react-jsx-runtime.production.min.js
      *
      * Copyright (c) Facebook, Inc. and its affiliates.
      *
      * This source code is licensed under the MIT license found in the
      * LICENSE file in the root directory of this source tree.
      */
-    var f$5 = React__default.default,
-        k$5 = Symbol.for("react.element"),
-        l$5 = Symbol.for("react.fragment"),
-        m$4 = Object.prototype.hasOwnProperty,
-        n$6 = f$5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
-        p$6 = {
+    var f$4 = React__default.default,
+        k$4 = Symbol.for("react.element"),
+        l$4 = Symbol.for("react.fragment"),
+        m$3 = Object.prototype.hasOwnProperty,
+        n$5 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
+        p$5 = {
             key: true,
             ref: true,
             __self: true,
             __source: true
         };
 
-    function q$5(c2, a2, g2) {
+    function q$4(c2, a2, g2) {
         var b2, d2 = {},
             e3 = null,
             h2 = null;
         void 0 !== g2 && (e3 = "" + g2);
         void 0 !== a2.key && (e3 = "" + a2.key);
         void 0 !== a2.ref && (h2 = a2.ref);
         for (b2 in a2)
-            m$4.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
+            m$3.call(a2, b2) && !p$5.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
         if (c2 && c2.defaultProps)
             for (b2 in a2 = c2.defaultProps, a2)
                 void 0 === d2[b2] && (d2[b2] = a2[b2]);
         return {
-            $$typeof: k$5,
+            $$typeof: k$4,
             type: c2,
             key: e3,
             ref: h2,
             props: d2,
-            _owner: n$6.current
+            _owner: n$5.current
         };
     }
-    reactJsxRuntime_production_min.Fragment = l$5;
-    reactJsxRuntime_production_min.jsx = q$5;
-    reactJsxRuntime_production_min.jsxs = q$5;
+    reactJsxRuntime_production_min.Fragment = l$4;
+    reactJsxRuntime_production_min.jsx = q$4;
+    reactJsxRuntime_production_min.jsxs = q$4;
     (function(module2) {
         {
             module2.exports = reactJsxRuntime_production_min;
         }
     })(jsxRuntime);
     var Collapse$2 = {};
 
@@ -589,15 +590,15 @@
     Object.defineProperty(UnmountClosed$2, "__esModule", {
         value: true
     });
     UnmountClosed$2.UnmountClosed = void 0;
     var _react = _interopRequireDefault(React__default.default);
     var _Collapse = Collapse$2;
     var _excluded$6 = ["isOpened"],
-        _excluded2$3 = ["isOpened"];
+        _excluded2$4 = ["isOpened"];
 
     function _interopRequireDefault(obj) {
         return obj && obj.__esModule ? obj : {
             "default": obj
         };
     }
 
@@ -647,15 +648,15 @@
         }
         return target;
     }
 
     function _objectWithoutProperties$3(source, excluded) {
         if (source == null)
             return {};
-        var target = _objectWithoutPropertiesLoose$6(source, excluded);
+        var target = _objectWithoutPropertiesLoose$7(source, excluded);
         var key, i2;
         if (Object.getOwnPropertySymbols) {
             var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
             for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
                 key = sourceSymbolKeys[i2];
                 if (excluded.indexOf(key) >= 0)
                     continue;
@@ -663,15 +664,15 @@
                     continue;
                 target[key] = source[key];
             }
         }
         return target;
     }
 
-    function _objectWithoutPropertiesLoose$6(source, excluded) {
+    function _objectWithoutPropertiesLoose$7(source, excluded) {
         if (source == null)
             return {};
         var target = {};
         var sourceKeys = Object.keys(source);
         var key, i2;
         for (i2 = 0; i2 < sourceKeys.length; i2++) {
             key = sourceKeys[i2];
@@ -816,15 +817,15 @@
                     onWork(_objectSpread$6({
                         isOpened
                     }, rest));
                 }
             });
             _defineProperty$r(_assertThisInitialized$4(_this), "onRest", function(_ref2) {
                 var isOpened = _ref2.isOpened,
-                    rest = _objectWithoutProperties$3(_ref2, _excluded2$3);
+                    rest = _objectWithoutProperties$3(_ref2, _excluded2$4);
                 _this.setState({
                     isResting: true,
                     isOpened,
                     isInitialRender: false
                 });
                 var onRest = _this.props.onRest;
                 if (onRest) {
@@ -1416,15 +1417,15 @@
                 key = _ref22[1];
             var val = coerce(getAttrConfig(attr));
             if (val !== void 0 && val !== null) {
                 initial[key] = val;
             }
         });
     }
-    var _default$2 = {
+    var _default$3 = {
         styleDefault: "solid",
         familyDefault: "classic",
         cssPrefix: DEFAULT_CSS_PREFIX,
         replacementClass: DEFAULT_REPLACEMENT_CLASS,
         autoReplaceSvg: true,
         autoAddCss: true,
         autoA11y: true,
@@ -1434,19 +1435,19 @@
         keepOriginalSource: true,
         measurePerformance: false,
         showMissingIcons: true
     };
     if (initial.familyPrefix) {
         initial.cssPrefix = initial.familyPrefix;
     }
-    var _config = _objectSpread2$2(_objectSpread2$2({}, _default$2), initial);
+    var _config = _objectSpread2$2(_objectSpread2$2({}, _default$3), initial);
     if (!_config.autoReplaceSvg)
         _config.observeMutations = false;
     var config$2 = {};
-    Object.keys(_default$2).forEach(function(key) {
+    Object.keys(_default$3).forEach(function(key) {
         Object.defineProperty(config$2, key, {
             enumerable: true,
             set: function set2(val) {
                 _config[key] = val;
                 _onChangeCb.forEach(function(cb) {
                     return cb(config$2);
                 });
@@ -1473,15 +1474,15 @@
 
     function onChange(cb) {
         _onChangeCb.push(cb);
         return function() {
             _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
         };
     }
-    var d$4 = UNITS_IN_GRID;
+    var d$3 = UNITS_IN_GRID;
     var meaninglessTransform = {
         size: 16,
         x: 0,
         y: 0,
         rotate: 0,
         flipX: false,
         flipY: false
@@ -1505,17 +1506,17 @@
         }
         DOCUMENT.head.insertBefore(style2, beforeChild);
         return css2;
     }
     var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
     function nextUniqueId$1() {
-        var size = 12;
+        var size2 = 12;
         var id2 = "";
-        while (size-- > 0) {
+        while (size2-- > 0) {
             id2 += idPool[Math.random() * 62 | 0];
         }
         return id2;
     }
 
     function toArray$1(obj) {
         var array2 = [];
@@ -1584,21 +1585,21 @@
             width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width,
             _ref2$height = _ref2.height,
             height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height,
             _ref2$startCentered = _ref2.startCentered,
             startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
         var val = "";
         if (startCentered && IS_IE) {
-            val += "translate(".concat(transform.x / d$4 - width / 2, "em, ").concat(transform.y / d$4 - height / 2, "em) ");
+            val += "translate(".concat(transform.x / d$3 - width / 2, "em, ").concat(transform.y / d$3 - height / 2, "em) ");
         } else if (startCentered) {
-            val += "translate(calc(-50% + ".concat(transform.x / d$4, "em), calc(-50% + ").concat(transform.y / d$4, "em)) ");
+            val += "translate(calc(-50% + ".concat(transform.x / d$3, "em), calc(-50% + ").concat(transform.y / d$3, "em)) ");
         } else {
-            val += "translate(".concat(transform.x / d$4, "em, ").concat(transform.y / d$4, "em) ");
+            val += "translate(".concat(transform.x / d$3, "em, ").concat(transform.y / d$3, "em) ");
         }
-        val += "scale(".concat(transform.size / d$4 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$4 * (transform.flipY ? -1 : 1), ") ");
+        val += "scale(".concat(transform.size / d$3 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$3 * (transform.flipY ? -1 : 1), ") ");
         val += "rotate(".concat(transform.rotate, "deg) ");
         return val;
     }
     var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    -webkit-transition-delay: 0s;\n            transition-delay: 0s;\n    -webkit-transition-duration: 0s;\n            transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
 
     function css() {
         var dcp = DEFAULT_CSS_PREFIX;
@@ -1742,18 +1743,18 @@
 
     function toHex(unicode2) {
         var decoded = ucs2decode(unicode2);
         return decoded.length === 1 ? decoded[0].toString(16) : null;
     }
 
     function codePointAt$1(string2, index2) {
-        var size = string2.length;
+        var size2 = string2.length;
         var first = string2.charCodeAt(index2);
         var second;
-        if (first >= 55296 && first <= 56319 && size > index2 + 1) {
+        if (first >= 55296 && first <= 56319 && size2 > index2 + 1) {
             second = string2.charCodeAt(index2 + 1);
             if (second >= 56320 && second <= 57343) {
                 return (first - 55296) * 1024 + second - 56320 + 65536;
             }
         }
         return first;
     }
@@ -2011,18 +2012,18 @@
             _classCallCheck$h(this, Library2);
             this.definitions = {};
         }
         _createClass$h(Library2, [{
             key: "add",
             value: function add2() {
                 var _this = this;
-                for (var _len = arguments.length, definitions2 = new Array(_len), _key = 0; _key < _len; _key++) {
-                    definitions2[_key] = arguments[_key];
+                for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
+                    definitions[_key] = arguments[_key];
                 }
-                var additions = definitions2.reduce(this._pullDefinitions, {});
+                var additions = definitions.reduce(this._pullDefinitions, {});
                 Object.keys(additions).forEach(function(key) {
                     _this.definitions[key] = _objectSpread2$2(_objectSpread2$2({}, _this.definitions[key] || {}), additions[key]);
                     defineIcons(key, additions[key]);
                     var longPrefix = PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC][key];
                     if (longPrefix)
                         defineIcons(longPrefix, additions[key]);
                     build$2();
@@ -2173,15 +2174,15 @@
                 autoReplace({
                     autoReplaceSvgRoot
                 });
                 callHooks("watch", params);
             });
         }
     };
-    var parse$b = {
+    var parse$a = {
         icon: function icon2(_icon) {
             if (_icon === null) {
                 return null;
             }
             if (_typeof$7(_icon) === "object" && _icon.prefix && _icon.iconName) {
                 return {
                     prefix: _icon.prefix,
@@ -2214,15 +2215,15 @@
             }
         }
     };
     var api$1 = {
         noAuto,
         config: config$2,
         dom,
-        parse: parse$b,
+        parse: parse$a,
         library,
         findIconDefinition,
         toHtml
     };
     var autoReplace = function autoReplace2() {
         var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
         var _params$autoReplaceSv = params.autoReplaceSvgRoot,
@@ -2543,28 +2544,28 @@
             maybeNotifyMissing(iconName, prefix);
             resolve2(_objectSpread2$2(_objectSpread2$2({}, missingIconResolutionMixin), {}, {
                 icon: config$2.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
             }));
         });
     }
     var noop$1$1 = function noop2() {};
-    var p$5 = config$2.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
+    var p$4 = config$2.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
         mark: noop$1$1,
         measure: noop$1$1
     };
     var preamble = 'FA "6.4.2"';
     var begin = function begin2(name2) {
-        p$5.mark("".concat(preamble, " ").concat(name2, " begins"));
+        p$4.mark("".concat(preamble, " ").concat(name2, " begins"));
         return function() {
             return end$2(name2);
         };
     };
     var end$2 = function end2(name2) {
-        p$5.mark("".concat(preamble, " ").concat(name2, " ends"));
-        p$5.measure("".concat(preamble, " ").concat(name2), "".concat(preamble, " ").concat(name2, " begins"), "".concat(preamble, " ").concat(name2, " ends"));
+        p$4.mark("".concat(preamble, " ").concat(name2, " ends"));
+        p$4.measure("".concat(preamble, " ").concat(name2), "".concat(preamble, " ").concat(name2, " begins"), "".concat(preamble, " ").concat(name2, " ends"));
     };
     var perf = {
         begin,
         end: end$2
     };
     var noop$2$1 = function noop2() {};
 
@@ -3878,15 +3879,15 @@
             });
         } else {
             obj[key] = value;
         }
         return obj;
     }
 
-    function _objectWithoutPropertiesLoose$5(source, excluded) {
+    function _objectWithoutPropertiesLoose$6(source, excluded) {
         if (source == null)
             return {};
         var target = {};
         var sourceKeys = Object.keys(source);
         var key, i2;
         for (i2 = 0; i2 < sourceKeys.length; i2++) {
             key = sourceKeys[i2];
@@ -3896,15 +3897,15 @@
         }
         return target;
     }
 
     function _objectWithoutProperties$2(source, excluded) {
         if (source == null)
             return {};
-        var target = _objectWithoutPropertiesLoose$5(source, excluded);
+        var target = _objectWithoutPropertiesLoose$6(source, excluded);
         var key, i2;
         if (Object.getOwnPropertySymbols) {
             var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
             for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
                 key = sourceSymbolKeys[i2];
                 if (excluded.indexOf(key) >= 0)
                     continue;
@@ -3969,15 +3970,15 @@
             spinReverse = props.spinReverse,
             pulse = props.pulse,
             fixedWidth = props.fixedWidth,
             inverse = props.inverse,
             border = props.border,
             listItem2 = props.listItem,
             flip2 = props.flip,
-            size = props.size,
+            size2 = props.size,
             rotation2 = props.rotation,
             pull = props.pull;
         var classes = (_classes = {
             "fa-beat": beat,
             "fa-fade": fade,
             "fa-beat-fade": beatFade,
             "fa-bounce": bounce,
@@ -3990,15 +3991,15 @@
             "fa-fw": fixedWidth,
             "fa-inverse": inverse,
             "fa-border": border,
             "fa-li": listItem2,
             "fa-flip": flip2 === true,
             "fa-flip-horizontal": flip2 === "horizontal" || flip2 === "both",
             "fa-flip-vertical": flip2 === "vertical" || flip2 === "both"
-        }, _defineProperty$p(_classes, "fa-".concat(size), typeof size !== "undefined" && size !== null), _defineProperty$p(_classes, "fa-rotate-".concat(rotation2), typeof rotation2 !== "undefined" && rotation2 !== null && rotation2 !== 0), _defineProperty$p(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty$p(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
+        }, _defineProperty$p(_classes, "fa-".concat(size2), typeof size2 !== "undefined" && size2 !== null), _defineProperty$p(_classes, "fa-rotate-".concat(rotation2), typeof rotation2 !== "undefined" && rotation2 !== null && rotation2 !== 0), _defineProperty$p(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty$p(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
         return Object.keys(classes).map(function(key) {
             return classes[key] ? key : null;
         }).filter(function(key) {
             return key;
         });
     }
 
@@ -4032,21 +4033,21 @@
             var prop = camelize(pair2.slice(0, i2));
             var value = pair2.slice(i2 + 1).trim();
             prop.startsWith("webkit") ? acc[capitalize$1(prop)] = value : acc[prop] = value;
             return acc;
         }, {});
     }
 
-    function convert$1(createElement2, element2) {
+    function convert$2(createElement2, element2) {
         var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
         if (typeof element2 === "string") {
             return element2;
         }
         var children2 = (element2.children || []).map(function(child) {
-            return convert$1(createElement2, child);
+            return convert$2(createElement2, child);
         });
         var mixins = Object.keys(element2.attributes || {}).reduce(function(acc, key) {
             var val = element2.attributes[key];
             switch (key) {
                 case "class":
                     acc.attrs["className"] = val;
                     delete element2.attributes["class"];
@@ -4200,16 +4201,16 @@
         shake: false,
         symbol: false,
         title: "",
         titleId: null,
         transform: null,
         swapOpacity: false
     };
-    var convertCurry = convert$1.bind(null, React__default.default.createElement);
-    var Icon$3 = function(e3) {
+    var convertCurry = convert$2.bind(null, React__default.default.createElement);
+    var Icon$4 = function(e3) {
         var t2 = {};
 
         function r2(n2) {
             if (t2[n2])
                 return t2[n2].exports;
             var o2 = t2[n2] = {
                 i: n2,
@@ -4472,115 +4473,115 @@
             horizontal: false,
             vertical: false,
             rotate: 0,
             spin: false
         };
         t2.default = d2;
     }]);
-    const shouldForwardProp$4 = (prop) => !["asButton"].includes(prop);
-    const StyledFAIcon = styled__default.default(FontAwesomeIcon).withConfig({
-        shouldForwardProp: shouldForwardProp$4
+    const shouldForwardProp$9 = (prop) => !["asButton"].includes(prop);
+    const StyledFAIcon$1 = styled__default.default(FontAwesomeIcon).withConfig({
+        shouldForwardProp: shouldForwardProp$9
     })`
     cursor: ${(props) => props.asButton ? "pointer" : "inherit"};
     color: inherit;
     ${(props) => props.asButton ? `:hover { color: ${props.theme.colors.grey6}; }` : ""}
 `;
-    const mapFASizeToMD = {
+    const mapFASizeToMD$1 = {
         "10x": "120px",
         "1x": "12px",
         "2x": "24px",
         "3x": "36px",
         "4x": "48px",
         "5x": "60px",
         "6x": "72px",
         "7x": "84px",
         "8x": "96px",
         "9x": "108px",
         lg: "24px",
         sm: "12px",
         xs: "6px"
     };
-    const SizeMappedMDIcon = (props) => {
+    const SizeMappedMDIcon$1 = (props) => {
         if (props.size) {
-            return jsxRuntime.exports.jsx(Icon$3.Icon, Object.assign({}, props, {
-                size: mapFASizeToMD[props.size]
+            return jsxRuntime.exports.jsx(Icon$4.Icon, Object.assign({}, props, {
+                size: mapFASizeToMD$1[props.size]
             }));
         }
-        return jsxRuntime.exports.jsx(Icon$3.Icon, Object.assign({}, props));
+        return jsxRuntime.exports.jsx(Icon$4.Icon, Object.assign({}, props));
     };
-    const StyledMDIcon = styled__default.default(SizeMappedMDIcon).withConfig({
-        shouldForwardProp: shouldForwardProp$4
+    const StyledMDIcon = styled__default.default(SizeMappedMDIcon$1).withConfig({
+        shouldForwardProp: shouldForwardProp$9
     })`
     cursor: ${(props) => props.asButton ? "pointer" : "default"};
     color: inherit;
     ${(props) => props.asButton ? `:hover { color: ${props.theme.colors.grey6}; }` : ""}
 `;
     var mdiSwapHorizontal = "M21,9L17,5V8H10V10H17V13M7,11L3,15L7,19V16H14V14H7V11Z";
     const ArrowDown = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrowDown
         }, props));
     };
     const ArrowLeft = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrowLeft
         }, props));
     };
     const ArrowRight = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrowRight
         }, props));
     };
     const ArrowRightLong = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrowRightLong
         }, props));
     };
     const ArrowUp = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrowUp
         }, props));
     };
     const ArrowsHorizontal = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrowsAltH
         }, props));
     };
     const Arrows$1 = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faArrows
         }, props));
     };
     const Ban = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faBan
         }, props));
     };
     const Check = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faCheck
         }, props));
     };
-    const CheckSquare = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const CheckSquare$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faCheckSquare
         }, props));
     };
-    const ChevronLeft = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const ChevronLeft$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faChevronLeft
         }, props));
     };
-    const ChevronRight = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const ChevronRight$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faChevronRight
         }, props));
     };
-    const Circle$1 = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Circle$2 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faCircle
         }, props));
     };
     var faSquare = {
         prefix: "far",
         iconName: "square",
         icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M384 80c8.8 0 16 7.2 16 16V416c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V96c0-8.8 7.2-16 16-16H384zM64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64z"]
@@ -4591,172 +4592,152 @@
         icon: [512, 512, [62108, "question-circle"], "f059", "M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm169.8-90.7c7.9-22.3 29.1-37.3 52.8-37.3h58.3c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24V250.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1H222.6c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
     };
     var faCopy = {
         prefix: "far",
         iconName: "copy",
         icon: [448, 512, [], "f0c5", "M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z"]
     };
-    const Copy = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Copy$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faCopy
         }, props));
     };
-    const Cross$1 = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Cross$2 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faTimes
         }, props));
     };
     const Filter$1 = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faFilter
         }, props));
     };
     const Plus = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faPlus
         }, props));
     };
     const Refresh = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faRefresh
         }, props));
     };
     const Search = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faSearch
         }, props));
     };
-    const Square = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Square$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faSquare
         }, props));
     };
     const SwapHorizontal = (props) => {
         return jsxRuntime.exports.jsx(StyledMDIcon, Object.assign({
             path: mdiSwapHorizontal
         }, props));
     };
-    const ToggleOff = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const ToggleOff$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faToggleOff
         }, props));
     };
-    const ToggleOn = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const ToggleOn$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faToggleOn
         }, props));
     };
-    const Trash = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Trash$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faTrash
         }, props));
     };
-    const ChevronDown = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const ChevronDown$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faChevronDown
         }, props));
     };
-    const ChevronUp = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const ChevronUp$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faChevronUp
         }, props));
     };
-    const List$1 = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const List$2 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faList
         }, props));
     };
-    const Moon = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Moon$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faMoon
         }, props));
     };
     const TrashAlt = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faTrashAlt
         }, props));
     };
-    const PenToSquare = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const PenToSquare$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faPenToSquare
         }, props));
     };
-    const CircleCheck = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
-            icon: faCircleCheck
-        }, props));
-    };
-    const CircleInfo = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
-            icon: faCircleInfo
-        }, props));
-    };
-    const MagnifyingGlass = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const MagnifyingGlass$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faMagnifyingGlass
         }, props));
     };
-    const Xmark = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+    const Xmark$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon$1, Object.assign({
             icon: faXmark
         }, props));
     };
-    const TriangleExclamation = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
-            icon: faTriangleExclamation
-        }, props));
-    };
-    const CircleXmark = (props) => {
-        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
-            icon: faCircleXmark
-        }, props));
-    };
-    const shouldForwardProp$3 = (prop) => !["isOpen"].includes(prop);
-    const Icon$2 = styled__default.default(ChevronDown).withConfig({
-        shouldForwardProp: shouldForwardProp$3
+    const shouldForwardProp$8 = (prop) => !["isOpen"].includes(prop);
+    const Icon$3 = styled__default.default(ChevronDown$1).withConfig({
+        shouldForwardProp: shouldForwardProp$8
     })`
     cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
     transform: ${(props) => {
     const start2 = props.angles ? props.angles[0] : 0;
     const end2 = props.angles ? props.angles[1] : 180;
     return props.isOpen ? `rotate(${end2}deg)` : `rotate(${start2}deg)`;
   }};
     color: ${(props) => props.theme.colors.grey5};
     transition: transform 0.1s linear;
 `;
 
-    function Chevron$1(props, ref2) {
-        return jsxRuntime.exports.jsx(Icon$2, {
+    function Chevron$3(props, ref2) {
+        return jsxRuntime.exports.jsx(Icon$3, {
             angles: props.angles,
             className: props.className,
             disabled: props.disabled,
             isOpen: props.isOpen,
             onClick: props.onClick,
             ref: ref2,
             style: props.style
         });
     }
-    const Chevron$2 = React__namespace.forwardRef(Chevron$1);
+    const Chevron$4 = React__namespace.forwardRef(Chevron$3);
     styled__default.default.label`
     margin-bottom: 0px;
     font-size: 11px;
     color: ${(props) => props.theme.colors.grey6};
 `;
-    const List = styled__default.default.div`
+    const List$1 = styled__default.default.div`
     z-index: 5000;
 
     overflow-y: auto;
     display: ${(props) => props.isOpen ? "flex" : "none"};
     flex-direction: column;
 
     max-height: calc(${(props) => (props.maxItems || 5) * 2}em + 2px);
 
     border: 1px solid ${(props) => props.theme.colors.grey3};
 `;
-    const ListItem = styled__default.default.span`
+    const ListItem$1 = styled__default.default.span`
     cursor: pointer;
     user-select: none;
 
     overflow: hidden;
 
     width: 100%;
     min-height: 2rem;
@@ -4776,15 +4757,15 @@
         background-color: ${(props) => props.theme.colors.primary};
     }
 
     &:last-child {
         border-bottom: none;
     }
 `;
-    const sameWidthModifier = {
+    const sameWidthModifier$1 = {
         effect: ({
             state
         }) => () => {
             state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
         },
         enabled: true,
         fn: ({
@@ -4821,42 +4802,42 @@
 
             function step2(result) {
                 result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
             }
             step2((generator = generator.apply(thisArg, _arguments || [])).next());
         });
     };
-    var Status;
+    var Status$1;
     (function(Status2) {
         Status2["CANCELED"] = "CANCELED";
         Status2["CREATED"] = "CREATED";
         Status2["ERROR"] = "ERROR";
         Status2["FAILED"] = "FAILED";
         Status2["NONE"] = "";
         Status2["QUEUED"] = "QUEUED";
         Status2["RUNNING"] = "RUNNING";
         Status2["SUCCESS"] = "SUCCESS";
         Status2["WARNING"] = "WARNING";
-    })(Status || (Status = {}));
-    var HTTP_METHOD;
+    })(Status$1 || (Status$1 = {}));
+    var HTTP_METHOD$1;
     (function(HTTP_METHOD2) {
         HTTP_METHOD2["DELETE"] = "DELETE";
         HTTP_METHOD2["GET"] = "GET";
         HTTP_METHOD2["PATCH"] = "PATCH";
         HTTP_METHOD2["POST"] = "POST";
         HTTP_METHOD2["PUT"] = "PUT";
-    })(HTTP_METHOD || (HTTP_METHOD = {}));
+    })(HTTP_METHOD$1 || (HTTP_METHOD$1 = {}));
     const getStatusColor = (status2, colors2) => {
-        if ([Status.ERROR, Status.FAILED].includes(status2)) {
+        if ([Status$1.ERROR, Status$1.FAILED].includes(status2)) {
             return colors2.error;
         }
-        if ([Status.CANCELED, Status.WARNING].includes(status2)) {
+        if ([Status$1.CANCELED, Status$1.WARNING].includes(status2)) {
             return colors2.warning;
         }
-        return status2 === Status.SUCCESS ? colors2.success : colors2.primary;
+        return status2 === Status$1.SUCCESS ? colors2.success : colors2.primary;
     };
     var shortid$1 = {
         exports: {}
     };
     var lib$1 = {
         exports: {}
     };
@@ -4959,37 +4940,37 @@
         seed: setSeed,
         lookup: lookup$1,
         shuffled: getShuffled
     };
     var crypto$1 = typeof window === "object" && (window.crypto || window.msCrypto);
     var randomByte;
     if (!crypto$1 || !crypto$1.getRandomValues) {
-        randomByte = function(size) {
+        randomByte = function(size2) {
             var bytes = [];
-            for (var i2 = 0; i2 < size; i2++) {
+            for (var i2 = 0; i2 < size2; i2++) {
                 bytes.push(Math.floor(Math.random() * 256));
             }
             return bytes;
         };
     } else {
-        randomByte = function(size) {
-            return crypto$1.getRandomValues(new Uint8Array(size));
+        randomByte = function(size2) {
+            return crypto$1.getRandomValues(new Uint8Array(size2));
         };
     }
     var randomByteBrowser = randomByte;
-    var format_browser = function(random2, alphabet2, size) {
+    var format_browser = function(random2, alphabet2, size2) {
         var mask = (2 << Math.log(alphabet2.length - 1) / Math.LN2) - 1;
-        var step2 = -~(1.6 * mask * size / alphabet2.length);
+        var step2 = -~(1.6 * mask * size2 / alphabet2.length);
         var id2 = "";
         while (true) {
             var bytes = random2(step2);
             var i2 = step2;
             while (i2--) {
                 id2 += alphabet2[bytes[i2] & mask] || "";
-                if (id2.length === +size)
+                if (id2.length === +size2)
                     return id2;
             }
         }
     };
     var alphabet$1 = alphabet_1;
     var random$3 = randomByteBrowser;
     var format$3 = format_browser;
@@ -5253,18 +5234,18 @@
         return this.__data__.has(key);
     }
     var _stackHas = stackHas$1;
     var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
     var _freeGlobal = freeGlobal$1;
     var freeGlobal = _freeGlobal;
     var freeSelf = typeof self == "object" && self && self.Object === Object && self;
-    var root$d = freeGlobal || freeSelf || Function("return this")();
-    var _root = root$d;
-    var root$c = _root;
-    var Symbol$6 = root$c.Symbol;
+    var root$f = freeGlobal || freeSelf || Function("return this")();
+    var _root = root$f;
+    var root$e = _root;
+    var Symbol$6 = root$e.Symbol;
     var _Symbol = Symbol$6;
     var Symbol$5 = _Symbol;
     var objectProto$f = Object.prototype;
     var hasOwnProperty$e = objectProto$f.hasOwnProperty;
     var nativeObjectToString$1 = objectProto$f.toString;
     var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
 
@@ -5324,16 +5305,16 @@
         if (!isObject$a(value)) {
             return false;
         }
         var tag = baseGetTag$4(value);
         return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
     }
     var isFunction_1 = isFunction$3;
-    var root$b = _root;
-    var coreJsData$1 = root$b["__core-js_shared__"];
+    var root$d = _root;
+    var coreJsData$1 = root$d["__core-js_shared__"];
     var _coreJsData = coreJsData$1;
     var coreJsData = _coreJsData;
     var maskSrcKey = function() {
         var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
         return uid2 ? "Symbol(src)_1." + uid2 : "";
     }();
 
@@ -5388,16 +5369,16 @@
 
     function getNative$7(object2, key) {
         var value = getValue$1(object2, key);
         return baseIsNative(value) ? value : void 0;
     }
     var _getNative = getNative$7;
     var getNative$6 = _getNative,
-        root$a = _root;
-    var Map$5 = getNative$6(root$a, "Map");
+        root$c = _root;
+    var Map$5 = getNative$6(root$c, "Map");
     var _Map = Map$5;
     var getNative$5 = _getNative;
     var nativeCreate$4 = getNative$5(Object, "create");
     var _nativeCreate = nativeCreate$4;
     var nativeCreate$3 = _nativeCreate;
 
     function hashClear$1() {
@@ -5512,17 +5493,17 @@
         return getMapData$1(this, key).has(key);
     }
     var _mapCacheHas = mapCacheHas$1;
     var getMapData = _getMapData;
 
     function mapCacheSet$1(key, value) {
         var data2 = getMapData(this, key),
-            size = data2.size;
+            size2 = data2.size;
         data2.set(key, value);
-        this.size += data2.size == size ? 0 : 1;
+        this.size += data2.size == size2 ? 0 : 1;
         return this;
     }
     var _mapCacheSet = mapCacheSet$1;
     var mapCacheClear = _mapCacheClear,
         mapCacheDelete = _mapCacheDelete,
         mapCacheGet = _mapCacheGet,
         mapCacheHas = _mapCacheHas,
@@ -5676,16 +5657,16 @@
             }
         }
         stack["delete"](array2);
         stack["delete"](other);
         return result;
     }
     var _equalArrays = equalArrays$2;
-    var root$9 = _root;
-    var Uint8Array$3 = root$9.Uint8Array;
+    var root$b = _root;
+    var Uint8Array$3 = root$b.Uint8Array;
     var _Uint8Array = Uint8Array$3;
 
     function mapToArray$1(map2) {
         var index2 = -1,
             result = Array(map2.size);
         map2.forEach(function(value, key) {
             result[++index2] = [key, value];
@@ -5858,15 +5839,15 @@
     var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;
     var isArguments$1 = baseIsArguments(function() {
         return arguments;
     }()) ? baseIsArguments : function(value) {
         return isObjectLike$6(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
     };
     var isArguments_1 = isArguments$1;
-    var isBuffer$5 = {
+    var isBuffer$4 = {
         exports: {}
     };
 
     function stubFalse() {
         return false;
     }
     var stubFalse_1 = stubFalse;
@@ -5876,15 +5857,15 @@
         var freeExports = exports3 && !exports3.nodeType && exports3;
         var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
         var moduleExports = freeModule && freeModule.exports === freeExports;
         var Buffer2 = moduleExports ? root2.Buffer : void 0;
         var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
         var isBuffer2 = nativeIsBuffer || stubFalse2;
         module2.exports = isBuffer2;
-    })(isBuffer$5, isBuffer$5.exports);
+    })(isBuffer$4, isBuffer$4.exports);
     var MAX_SAFE_INTEGER$1 = 9007199254740991;
     var reIsUint = /^(?:0|[1-9]\d*)$/;
 
     function isIndex$2(value, length) {
         var type2 = typeof value;
         length = length == null ? MAX_SAFE_INTEGER$1 : length;
         return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
@@ -5963,24 +5944,24 @@
         nodeUtil$2 = _nodeUtil.exports;
     var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
     var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
     var isTypedArray_1 = isTypedArray$2;
     var baseTimes = _baseTimes,
         isArguments = isArguments_1,
         isArray$e = isArray_1,
-        isBuffer$4 = isBuffer$5.exports,
+        isBuffer$3 = isBuffer$4.exports,
         isIndex$1 = _isIndex,
         isTypedArray$1 = isTypedArray_1;
     var objectProto$8 = Object.prototype;
     var hasOwnProperty$9 = objectProto$8.hasOwnProperty;
 
     function arrayLikeKeys$2(value, inherited) {
         var isArr = isArray$e(value),
             isArg = !isArr && isArguments(value),
-            isBuff = !isArr && !isArg && isBuffer$4(value),
+            isBuff = !isArr && !isArg && isBuffer$3(value),
             isType2 = !isArr && !isArg && !isBuff && isTypedArray$1(value),
             skipIndexes = isArr || isArg || isBuff || isType2,
             result = skipIndexes ? baseTimes(value.length, String) : [],
             length = result.length;
         for (var key in value) {
             if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$1(key, length)))) {
                 result.push(key);
@@ -6100,28 +6081,28 @@
         }
         stack["delete"](object2);
         stack["delete"](other);
         return result;
     }
     var _equalObjects = equalObjects$1;
     var getNative$4 = _getNative,
-        root$8 = _root;
-    var DataView$2 = getNative$4(root$8, "DataView");
+        root$a = _root;
+    var DataView$2 = getNative$4(root$a, "DataView");
     var _DataView = DataView$2;
     var getNative$3 = _getNative,
-        root$7 = _root;
-    var Promise$3 = getNative$3(root$7, "Promise");
+        root$9 = _root;
+    var Promise$3 = getNative$3(root$9, "Promise");
     var _Promise = Promise$3;
     var getNative$2 = _getNative,
-        root$6 = _root;
-    var Set$3 = getNative$2(root$6, "Set");
+        root$8 = _root;
+    var Set$3 = getNative$2(root$8, "Set");
     var _Set = Set$3;
     var getNative$1 = _getNative,
-        root$5 = _root;
-    var WeakMap$3 = getNative$1(root$5, "WeakMap");
+        root$7 = _root;
+    var WeakMap$3 = getNative$1(root$7, "WeakMap");
     var _WeakMap = WeakMap$3;
     var DataView$1 = _DataView,
         Map$2 = _Map,
         Promise$2 = _Promise,
         Set$2 = _Set,
         WeakMap$2 = _WeakMap,
         baseGetTag$1 = _baseGetTag,
@@ -6163,15 +6144,15 @@
     var _getTag = getTag$4;
     var Stack$4 = _Stack,
         equalArrays = _equalArrays,
         equalByTag = _equalByTag,
         equalObjects = _equalObjects,
         getTag$3 = _getTag,
         isArray$d = isArray_1,
-        isBuffer$3 = isBuffer$5.exports,
+        isBuffer$2 = isBuffer$4.exports,
         isTypedArray = isTypedArray_1;
     var COMPARE_PARTIAL_FLAG = 1;
     var argsTag$1 = "[object Arguments]",
         arrayTag$1 = "[object Array]",
         objectTag$1 = "[object Object]";
     var objectProto$4 = Object.prototype;
     var hasOwnProperty$6 = objectProto$4.hasOwnProperty;
@@ -6182,16 +6163,16 @@
             objTag = objIsArr ? arrayTag$1 : getTag$3(object2),
             othTag = othIsArr ? arrayTag$1 : getTag$3(other);
         objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
         othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
         var objIsObj = objTag == objectTag$1,
             othIsObj = othTag == objectTag$1,
             isSameTag = objTag == othTag;
-        if (isSameTag && isBuffer$3(object2)) {
-            if (!isBuffer$3(other)) {
+        if (isSameTag && isBuffer$2(object2)) {
+            if (!isBuffer$2(other)) {
                 return false;
             }
             objIsArr = true;
             objIsObj = false;
         }
         if (isSameTag && !objIsObj) {
             stack || (stack = new Stack$4());
@@ -6230,15 +6211,15 @@
     var baseIsEqual = _baseIsEqual;
 
     function isEqual$4(value, other) {
         return baseIsEqual(value, other);
     }
     var isEqual_1 = isEqual$4;
 
-    function useDeepCompare(value) {
+    function useDeepCompare$1(value) {
         const ref2 = React.useRef();
         if (!isEqual_1(value, ref2.current)) {
             ref2.current = value;
         }
         return ref2.current;
     }
 
@@ -6260,19 +6241,19 @@
                         window.removeEventListener("scroll", measure);
                     };
                 }
             }
         }, [liveMeasure, node2]);
         return [ref2, dimensions2, node2];
     }
-    var root$4 = _root;
-    var now$3 = function() {
-        return root$4.Date.now();
+    var root$6 = _root;
+    var now$4 = function() {
+        return root$6.Date.now();
     };
-    var now_1 = now$3;
+    var now_1 = now$4;
     var reWhitespace = /\s/;
 
     function trimmedEndIndex$1(string2) {
         var index2 = string2.length;
         while (index2-- && reWhitespace.test(string2.charAt(index2))) {}
         return index2;
     }
@@ -6317,15 +6298,15 @@
         }
         value = baseTrim(value);
         var isBinary = reIsBinary.test(value);
         return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
     }
     var toNumber_1 = toNumber$4;
     var isObject$7 = isObject_1,
-        now$2 = now_1,
+        now$3 = now_1,
         toNumber$3 = toNumber_1;
     var FUNC_ERROR_TEXT$2 = "Expected a function";
     var nativeMax = Math.max,
         nativeMin$1 = Math.min;
 
     function debounce$7(func, wait, options) {
         var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
@@ -6368,15 +6349,15 @@
         function shouldInvoke(time) {
             var timeSinceLastCall = time - lastCallTime,
                 timeSinceLastInvoke = time - lastInvokeTime;
             return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
         }
 
         function timerExpired() {
-            var time = now$2();
+            var time = now$3();
             if (shouldInvoke(time)) {
                 return trailingEdge(time);
             }
             timerId = setTimeout(timerExpired, remainingWait(time));
         }
 
         function trailingEdge(time) {
@@ -6393,19 +6374,19 @@
                 clearTimeout(timerId);
             }
             lastInvokeTime = 0;
             lastArgs = lastCallTime = lastThis = timerId = void 0;
         }
 
         function flush() {
-            return timerId === void 0 ? result : trailingEdge(now$2());
+            return timerId === void 0 ? result : trailingEdge(now$3());
         }
 
         function debounced() {
-            var time = now$2(),
+            var time = now$3(),
                 isInvoking = shouldInvoke(time);
             lastArgs = arguments;
             lastThis = this;
             lastCallTime = time;
             if (isInvoking) {
                 if (timerId === void 0) {
                     return leadingEdge(lastCallTime);
@@ -6444,28 +6425,28 @@
             "leading": leading,
             "maxWait": wait,
             "trailing": trailing
         });
     }
     var throttle_1 = throttle;
 
-    function useThrottle(cb, delay, options) {
+    function useThrottle$1(cb, delay, options) {
         const cbRef = React.useRef(cb);
         React.useEffect(() => {
             cbRef.current = cb;
         });
         return React.useCallback(throttle_1((...args) => cbRef.current(...args), delay, options), [delay, options]);
     }
 
-    function useThrottledState(initialValue, delay, options = {
+    function useThrottledState$1(initialValue, delay, options = {
         leading: false,
         trailing: true
     }) {
         const [value, setValue] = React.useState(initialValue);
-        const throttledSetValue = useThrottle(setValue, delay, options);
+        const throttledSetValue = useThrottle$1(setValue, delay, options);
         return [value, throttledSetValue, setValue];
     }
     var e10 = Math.sqrt(50),
         e5 = Math.sqrt(10),
         e2 = Math.sqrt(2);
 
     function ticks(start2, stop, count2) {
@@ -6530,15 +6511,15 @@
                     observer.disconnect();
                 }
             };
         }, [ref2, rootMargin, threshold]);
         return isIntersecting;
     }
 
-    function useOnClickOutside(element2, handler) {
+    function useOnClickOutside$1(element2, handler) {
         React.useEffect(() => {
             const listener2 = (event2) => {
                 if (!element2 || element2.contains(event2.target)) {
                     return;
                 }
                 handler();
             };
@@ -6602,15 +6583,15 @@
         });
         const getItem = React.useCallback((index2) => {
             const adjustedIndex = index2 - currentStartIdx;
             if (adjustedIndex < 0 || adjustedIndex > internalData.length) {
                 return;
             }
             return internalData[adjustedIndex];
-        }, useDeepCompare([currentStartIdx, internalData]));
+        }, useDeepCompare$1([currentStartIdx, internalData]));
         const onItemsRendered = React.useCallback(({
             overscanStartIndex,
             overscanStopIndex
         }, forceRefresh) => __awaiter$3(this, void 0, void 0, function*() {
             try {
                 const isFirstItemLoaded = overscanStartIndex >= currentStartIdx && overscanStartIndex <= currentStopIdx;
                 const isLastItemLoaded = overscanStopIndex >= currentStartIdx && overscanStopIndex <= currentStopIdx;
@@ -6662,15 +6643,15 @@
         }), [batchSize, currentStartIdx, currentStopIdx, onError]);
         React.useEffect(() => {
             onLoadRef.current = onLoadData;
             onItemsRendered(currentRange, true);
         }, [onLoadData]);
         const refresh = React.useCallback(() => {
             onItemsRendered(currentRange, true);
-        }, useDeepCompare([currentRange]));
+        }, useDeepCompare$1([currentRange]));
         return {
             getItem,
             itemCount,
             onItemsRendered,
             refresh
         };
     }
@@ -6746,15 +6727,15 @@
         open
     }) {
         return jsxRuntime.exports.jsxs(AccordionItemWrapper, {
             backgroundColor,
             children: [jsxRuntime.exports.jsxs(AccordionLabel, {
                 isOpen: open,
                 onClick,
-                children: [headerRenderer2 ? headerRenderer2(item) : item.label, jsxRuntime.exports.jsx(Chevron$2, {
+                children: [headerRenderer2 ? headerRenderer2(item) : item.label, jsxRuntime.exports.jsx(Chevron$4, {
                     isOpen: open
                 })]
             }), jsxRuntime.exports.jsx(lib$2.Collapse, {
                 isOpened: open,
                 children: jsxRuntime.exports.jsx(ContentWrapper, {
                     children: jsxRuntime.exports.jsx(AccordionContent, {
                         children: innerRenderer ? innerRenderer(item) : item.content
@@ -6838,17 +6819,17 @@
                 innerRenderer,
                 item,
                 onClick: () => onClick(index2),
                 open: openItems[index2]
             }, `accordion-item-${index2}`))
         });
     }
-    const shouldForwardProp$2 = (prop) => !["color", "width"].includes(prop);
-    const Badge = styled__default.default.span.withConfig({
-        shouldForwardProp: shouldForwardProp$2
+    const shouldForwardProp$7 = (prop) => !["color", "width"].includes(prop);
+    const Badge$1 = styled__default.default.span.withConfig({
+        shouldForwardProp: shouldForwardProp$7
     })`
     display: inline-flex;
     align-items: center;
     justify-content: center;
 
     width: ${(props) => props.width || "auto"};
     height: ${(props) => props.height ? `${props.height}px` : "2rem"};
@@ -7330,30 +7311,30 @@
         var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
         var colorWithAlpha = _extends$3({}, parsedColor, {
             alpha: guard$2(0, 1, (alpha * 100 - parseFloat(amount) * 100) / 100)
         });
         return rgba$4(colorWithAlpha);
     }
     var curriedTransparentize$2 = /* @__PURE__ */ curry$2(transparentize$2);
-    const Wrapper$c = styled__default.default.div`
+    const Wrapper$i = styled__default.default.div`
     display: flex;
     gap: 1rem;
     align-items: center;
     justify-content: center;
 
     height: 100%;
 `;
-    const LoadingText = styled__default.default.span`
+    const LoadingText$1 = styled__default.default.span`
     font-size: 1.2rem;
     color: ${(props) => {
     var _a3;
     return (_a3 = props.color) !== null && _a3 !== void 0 ? _a3 : props.theme.colors.grey4;
   }};
 `;
-    const Loader$1 = styled__default.default.span`
+    const Loader$2 = styled__default.default.span`
     position: relative;
     width: ${(props) => {
     var _a3;
     return (_a3 = props.size) !== null && _a3 !== void 0 ? _a3 : "2.5rem";
   }};
     height: ${(props) => {
     var _a3;
@@ -7446,20 +7427,20 @@
         100%,
         0% {
             transform: scale(1);
         }
     }
 `;
 
-    function Spinner(props) {
+    function Spinner$1(props) {
         var _a3;
-        return jsxRuntime.exports.jsxs(Wrapper$c, {
+        return jsxRuntime.exports.jsxs(Wrapper$i, {
             className: props.className,
             style: props.style,
-            children: [jsxRuntime.exports.jsxs(Loader$1, {
+            children: [jsxRuntime.exports.jsxs(Loader$2, {
                 color: props.color,
                 size: props.size,
                 children: [jsxRuntime.exports.jsx("div", {
                     className: "sk-chase-dot"
                 }), jsxRuntime.exports.jsx("div", {
                     className: "sk-chase-dot"
                 }), jsxRuntime.exports.jsx("div", {
@@ -7467,33 +7448,33 @@
                 }), jsxRuntime.exports.jsx("div", {
                     className: "sk-chase-dot"
                 }), jsxRuntime.exports.jsx("div", {
                     className: "sk-chase-dot"
                 }), jsxRuntime.exports.jsx("div", {
                     className: "sk-chase-dot"
                 })]
-            }), (props.showText || props.text) && jsxRuntime.exports.jsx(LoadingText, {
+            }), (props.showText || props.text) && jsxRuntime.exports.jsx(LoadingText$1, {
                 color: props.color,
                 children: (_a3 = props.text) !== null && _a3 !== void 0 ? _a3 : "LOADING"
             })]
         });
     }
-    var __rest$c = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$i = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
-    const BaseButton = styled__default.default.button`
+    const BaseButton$1 = styled__default.default.button`
     cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
     user-select: none;
 
     display: flex;
     align-items: center;
     justify-content: center;
 
@@ -7504,15 +7485,15 @@
     font-size: 1rem;
     font-weight: 600;
 
     border: none;
     border-radius: 0.25rem;
 `;
 
-    function getOutlinedButtonStyle(buttonColor, disabled2, theme2) {
+    function getOutlinedButtonStyle$1(buttonColor, disabled2, theme2) {
         return `
         color: ${disabled2 ? theme2.colors.grey2 : buttonColor};
 
         background-color: transparent;
         border: 1px solid
             ${disabled2 ? theme2.colors.grey2 : buttonColor};
 
@@ -7522,15 +7503,15 @@
 
         :active:not(:disabled) {
             background-color: ${theme2.themeType === "dark" ? curriedTransparentize$2(0.7, buttonColor) : curriedTransparentize$2(0.8, buttonColor)};
         }
     `;
     }
 
-    function getFilledButtonStyle(buttonColor, hoverColor, clickColor, disabled2, theme2, textColor) {
+    function getFilledButtonStyle$1(buttonColor, hoverColor, clickColor, disabled2, theme2, textColor) {
         const color2 = textColor !== null && textColor !== void 0 ? textColor : theme2.colors.blue1;
         return `
         color: ${color2};
 
         background-color: ${disabled2 ? theme2.colors.grey2 : buttonColor};
 
         :hover:not(:disabled) {
@@ -7538,30 +7519,30 @@
         }
 
         :active:not(:disabled) {
             background-color: ${clickColor};
         }
     `;
     }
-    const PrimaryButton$1 = styled__default.default(BaseButton)`
-    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.primary, props.disabled, props.theme) : getFilledButtonStyle(props.theme.colors.primary, props.theme.colors.primaryHover, props.theme.colors.primaryDown, props.disabled, props.theme)}
+    const PrimaryButton$2 = styled__default.default(BaseButton$1)`
+    ${(props) => props.outline ? getOutlinedButtonStyle$1(props.theme.colors.primary, props.disabled, props.theme) : getFilledButtonStyle$1(props.theme.colors.primary, props.theme.colors.primaryHover, props.theme.colors.primaryDown, props.disabled, props.theme)}
 `;
-    const SecondaryButton$1 = styled__default.default(BaseButton)`
-    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.secondary, props.disabled, props.theme) : getFilledButtonStyle(props.theme.colors.secondary, props.theme.colors.secondaryHover, props.theme.colors.secondaryDown, props.disabled, props.theme)}
+    const SecondaryButton$2 = styled__default.default(BaseButton$1)`
+    ${(props) => props.outline ? getOutlinedButtonStyle$1(props.theme.colors.secondary, props.disabled, props.theme) : getFilledButtonStyle$1(props.theme.colors.secondary, props.theme.colors.secondaryHover, props.theme.colors.secondaryDown, props.disabled, props.theme)}
 `;
-    const GhostButton = styled__default.default(BaseButton)`
-    ${(props) => getFilledButtonStyle("transparent", props.theme.colors.grey2, props.theme.colors.grey2, props.disabled, props.theme, props.theme.colors.grey4)}
+    const GhostButton$1 = styled__default.default(BaseButton$1)`
+    ${(props) => getFilledButtonStyle$1("transparent", props.theme.colors.grey2, props.theme.colors.grey2, props.disabled, props.theme, props.theme.colors.grey4)}
 `;
-    const ErrorButton = styled__default.default(BaseButton)`
-    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.error, props.disabled, props.theme) : getFilledButtonStyle(props.theme.colors.error, props.theme.colors.errorHover, props.theme.colors.errorDown, props.disabled, props.theme)}
+    const ErrorButton$1 = styled__default.default(BaseButton$1)`
+    ${(props) => props.outline ? getOutlinedButtonStyle$1(props.theme.colors.error, props.disabled, props.theme) : getFilledButtonStyle$1(props.theme.colors.error, props.theme.colors.errorHover, props.theme.colors.errorDown, props.disabled, props.theme)}
 `;
-    const PlainButton = styled__default.default(BaseButton)`
-    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.grey6, props.disabled, props.theme) : getFilledButtonStyle("transparent", props.theme.colors.grey1, props.theme.colors.grey2, props.disabled, props.theme, props.theme.colors.grey6)}
+    const PlainButton$1 = styled__default.default(BaseButton$1)`
+    ${(props) => props.outline ? getOutlinedButtonStyle$1(props.theme.colors.grey6, props.disabled, props.theme) : getFilledButtonStyle$1("transparent", props.theme.colors.grey1, props.theme.colors.grey2, props.disabled, props.theme, props.theme.colors.grey6)}
 `;
-    const AnchorWrapper = styled__default.default.a`
+    const AnchorWrapper$1 = styled__default.default.a`
     display: flex;
     align-items: center;
     justify-content: center;
 
     width: 100%;
     height: 100%;
     padding: 0 1rem;
@@ -7570,47 +7551,47 @@
 
     :hover,
     :active {
         color: inherit;
         text-decoration: none;
     }
 `;
-    const StyledLoading = styled__default.default(Spinner)`
+    const StyledLoading$1 = styled__default.default(Spinner$1)`
     padding: 1rem 2rem;
 `;
-    const stylingMap = {
-        error: ErrorButton,
-        ghost: GhostButton,
-        plain: PlainButton,
-        primary: PrimaryButton$1,
-        secondary: SecondaryButton$1
+    const stylingMap$1 = {
+        error: ErrorButton$1,
+        ghost: GhostButton$1,
+        plain: PlainButton$1,
+        primary: PrimaryButton$2,
+        secondary: SecondaryButton$2
     };
 
-    function Button$2(_a3, ref2) {
+    function Button$4(_a3, ref2) {
         var {
             autoFocus,
             children: children2,
             className,
             disabled: disabled2,
             download,
             href,
             loading,
             id: id2,
             onClick,
             outline = false,
             style: style2,
             styling = "primary",
             type: type2 = "button"
-        } = _a3, props = __rest$c(_a3, ["autoFocus", "children", "className", "disabled", "download", "href", "loading", "id", "onClick", "outline", "style", "styling", "type"]);
-        const currentTheme = useClTheme();
-        const Component = stylingMap[styling];
-        const content2 = loading ? jsxRuntime.exports.jsx(StyledLoading, {
+        } = _a3, props = __rest$i(_a3, ["autoFocus", "children", "className", "disabled", "download", "href", "loading", "id", "onClick", "outline", "style", "styling", "type"]);
+        const currentTheme = useClTheme$1();
+        const Component = stylingMap$1[styling];
+        const content2 = loading ? jsxRuntime.exports.jsx(StyledLoading$1, {
             color: outline ? currentTheme.colors.grey2 : currentTheme.colors.blue1
         }) : children2;
-        const wrappedContent = href ? jsxRuntime.exports.jsx(AnchorWrapper, {
+        const wrappedContent = href ? jsxRuntime.exports.jsx(AnchorWrapper$1, {
             download,
             href,
             children: content2
         }) : content2;
         return jsxRuntime.exports.jsx(Component, Object.assign({
             "$hasAnchor": !!href,
             autoFocus,
@@ -7622,15 +7603,15 @@
             style: style2,
             type: type2
         }, props, {
             ref: ref2,
             children: wrappedContent
         }));
     }
-    const Button$3 = React.forwardRef(Button$2);
+    const Button$5 = React.forwardRef(Button$4);
     const ButtonBarWrapper = styled__default.default.div`
     overflow: hidden;
     display: flex;
     flex: 1 1 auto;
 
     height: 2.5rem;
 
@@ -7644,17 +7625,17 @@
         border-right: 1px solid
             ${(props) => {
     var _a3;
     return props.disabled ? props.theme.colors.grey2 : (_a3 = props.theme.colors) === null || _a3 === void 0 ? void 0 : _a3[props.styling];
   }};
     }
 `;
-    const shouldForwardProp$1 = (prop) => !["selected"].includes(prop);
+    const shouldForwardProp$6 = (prop) => !["selected"].includes(prop);
 
-    function getButtonStyle(buttonColor, disabled2, selected, theme2) {
+    function getButtonStyle$1(buttonColor, disabled2, selected, theme2) {
         let color2 = buttonColor;
         let backgroundColor = "transparent";
         if (selected) {
             color2 = theme2.colors.background;
             backgroundColor = buttonColor;
         }
         if (disabled2) {
@@ -7693,38 +7674,38 @@
 
         :active:not(:disabled) {
             background-color: ${curriedTransparentize$2(0.8, buttonColor)};
         }
     `)}
     `;
     }
-    const PrimaryButton = styled__default.default(BaseButton).withConfig({
-        shouldForwardProp: shouldForwardProp$1
+    const PrimaryButton$1 = styled__default.default(BaseButton$1).withConfig({
+        shouldForwardProp: shouldForwardProp$6
     })`
-    ${(props) => getButtonStyle(props.theme.colors.primary, props.disabled, props.selected, props.theme)}
+    ${(props) => getButtonStyle$1(props.theme.colors.primary, props.disabled, props.selected, props.theme)}
 `;
-    const SecondaryButton = styled__default.default(BaseButton).withConfig({
-        shouldForwardProp: shouldForwardProp$1
+    const SecondaryButton$1 = styled__default.default(BaseButton$1).withConfig({
+        shouldForwardProp: shouldForwardProp$6
     })`
-    ${(props) => getButtonStyle(props.theme.colors.secondary, props.disabled, props.selected, props.theme)}
+    ${(props) => getButtonStyle$1(props.theme.colors.secondary, props.disabled, props.selected, props.theme)}
 `;
 
     function ButtonBar$1({
         className,
         disabled: disabled2,
         id: id2,
         value,
         initialValue,
         items,
         onSelect,
         style: style2,
         styling = "primary"
     }) {
         const [selected, setSelected] = React.useState(value || initialValue || items[0]);
-        const ButtonComponent = styling === "secondary" ? SecondaryButton : PrimaryButton;
+        const ButtonComponent = styling === "secondary" ? SecondaryButton$1 : PrimaryButton$1;
         const onClick = React.useCallback((item) => {
             onSelect === null || onSelect === void 0 ? void 0 : onSelect(item);
             if (value === void 0) {
                 setSelected(item);
             }
         }, [value, onSelect]);
         React.useEffect(() => {
@@ -7775,15 +7756,15 @@
     max-height: 100%;
 `;
     const CarouselIndicators = styled__default.default.div`
     display: flex;
     gap: 0.2rem;
     justify-content: center;
 `;
-    const Button$1 = styled__default.default.button`
+    const Button$3 = styled__default.default.button`
     cursor: pointer;
     user-select: none;
 
     position: absolute;
     z-index: 3;
     top: calc(50% - 0.5rem);
     transform: translateY(-50%);
@@ -7902,52 +7883,52 @@
         );
         React.useEffect(() => {
             setActiveIndex(props.value || props.initialValue || 0);
         }, [props.value]);
         return jsxRuntime.exports.jsxs(CarouselComponent, {
             className: props.className,
             style: props.style,
-            children: [jsxRuntime.exports.jsx(Button$1, {
+            children: [jsxRuntime.exports.jsx(Button$3, {
                 "data-testid": "carousel-left-button",
                 onClick: () => {
                     updateIndex(activeIndex - 1);
                 },
                 style: {
                     left: "0.5rem"
                 },
                 type: "button",
-                children: jsxRuntime.exports.jsx(ChevronLeft, {})
+                children: jsxRuntime.exports.jsx(ChevronLeft$1, {})
             }), jsxRuntime.exports.jsx(CarouselItemsContainer, {
                 style: {
                     transform: `translateX(-${activeIndex * 100}%)`
                 },
                 children: props.items.map((item, index2) => {
                     return jsxRuntime.exports.jsx(CarouselItemContainer, {
                         item
                     }, `carousel-item-${index2}`);
                 })
-            }), jsxRuntime.exports.jsx(Button$1, {
+            }), jsxRuntime.exports.jsx(Button$3, {
                 "data-testid": "carousel-right-button",
                 onClick: () => {
                     updateIndex(activeIndex + 1);
                 },
                 style: {
                     right: "0.5rem"
                 },
                 type: "button",
-                children: jsxRuntime.exports.jsx(ChevronRight, {})
+                children: jsxRuntime.exports.jsx(ChevronRight$1, {})
             }), jsxRuntime.exports.jsx(CarouselIndicators, {
                 children: props.items.map((item, index2) => {
                     return jsxRuntime.exports.jsx(CircleSelect, {
                         onClick: () => {
                             updateIndex(index2);
                         },
                         selected: index2 === activeIndex,
                         type: "button",
-                        children: jsxRuntime.exports.jsx(Circle$1, {})
+                        children: jsxRuntime.exports.jsx(Circle$2, {})
                     }, `carousel-select-${index2}`);
                 })
             })]
         });
     }
     var lodash$1 = {
         exports: {}
@@ -9174,17 +9155,17 @@
 
                 function mapCacheHas2(key) {
                     return getMapData2(this, key).has(key);
                 }
 
                 function mapCacheSet2(key, value) {
                     var data2 = getMapData2(this, key),
-                        size2 = data2.size;
+                        size3 = data2.size;
                     data2.set(key, value);
-                    this.size += data2.size == size2 ? 0 : 1;
+                    this.size += data2.size == size3 ? 0 : 1;
                     return this;
                 }
                 MapCache2.prototype.clear = mapCacheClear2;
                 MapCache2.prototype["delete"] = mapCacheDelete2;
                 MapCache2.prototype.get = mapCacheGet2;
                 MapCache2.prototype.has = mapCacheHas2;
                 MapCache2.prototype.set = mapCacheSet2;
@@ -10384,48 +10365,48 @@
                     end2 = end2 === undefined$12 ? length : end2;
                     return !start2 && end2 >= length ? array2 : baseSlice(array2, start2, end2);
                 }
                 var clearTimeout2 = ctxClearTimeout || function(id2) {
                     return root2.clearTimeout(id2);
                 };
 
-                function cloneBuffer2(buffer2, isDeep) {
+                function cloneBuffer2(buffer, isDeep) {
                     if (isDeep) {
-                        return buffer2.slice();
+                        return buffer.slice();
                     }
-                    var length = buffer2.length,
-                        result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
-                    buffer2.copy(result2);
+                    var length = buffer.length,
+                        result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
+                    buffer.copy(result2);
                     return result2;
                 }
 
                 function cloneArrayBuffer2(arrayBuffer) {
                     var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                     new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                     return result2;
                 }
 
                 function cloneDataView2(dataView, isDeep) {
-                    var buffer2 = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
-                    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
+                    var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
+                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                 }
 
                 function cloneRegExp2(regexp) {
                     var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
                     result2.lastIndex = regexp.lastIndex;
                     return result2;
                 }
 
                 function cloneSymbol2(symbol) {
                     return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
                 }
 
                 function cloneTypedArray2(typedArray, isDeep) {
-                    var buffer2 = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
-                    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
+                    var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
+                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                 }
 
                 function compareAscending(value, other) {
                     if (value !== other) {
                         var valIsDefined = value !== undefined$12,
                             valIsNull = value === null,
                             valIsReflexive = value === value,
@@ -11328,27 +11309,27 @@
                 }
 
                 function getView(start2, end2, transforms) {
                     var index2 = -1,
                         length = transforms.length;
                     while (++index2 < length) {
                         var data2 = transforms[index2],
-                            size2 = data2.size;
+                            size3 = data2.size;
                         switch (data2.type) {
                             case "drop":
-                                start2 += size2;
+                                start2 += size3;
                                 break;
                             case "dropRight":
-                                end2 -= size2;
+                                end2 -= size3;
                                 break;
                             case "take":
-                                end2 = nativeMin2(end2, start2 + size2);
+                                end2 = nativeMin2(end2, start2 + size3);
                                 break;
                             case "takeRight":
-                                start2 = nativeMax2(start2, end2 - size2);
+                                start2 = nativeMax2(start2, end2 - size3);
                                 break;
                         }
                     }
                     return {
                         "start": start2,
                         "end": end2
                     };
@@ -11645,26 +11626,26 @@
                         } else {
                             count2 = 0;
                         }
                         return func.apply(undefined$12, arguments);
                     };
                 }
 
-                function shuffleSelf(array2, size2) {
+                function shuffleSelf(array2, size3) {
                     var index2 = -1,
                         length = array2.length,
                         lastIndex = length - 1;
-                    size2 = size2 === undefined$12 ? length : size2;
-                    while (++index2 < size2) {
+                    size3 = size3 === undefined$12 ? length : size3;
+                    while (++index2 < size3) {
                         var rand = baseRandom(index2, lastIndex),
                             value = array2[rand];
                         array2[rand] = array2[index2];
                         array2[index2] = value;
                     }
-                    array2.length = size2;
+                    array2.length = size3;
                     return array2;
                 }
                 var stringToPath2 = memoizeCapped2(function(string2) {
                     var result2 = [];
                     if (string2.charCodeAt(0) === 46) {
                         result2.push("");
                     }
@@ -11711,29 +11692,29 @@
                     var result2 = new LodashWrapper2(wrapper.__wrapped__, wrapper.__chain__);
                     result2.__actions__ = copyArray2(wrapper.__actions__);
                     result2.__index__ = wrapper.__index__;
                     result2.__values__ = wrapper.__values__;
                     return result2;
                 }
 
-                function chunk(array2, size2, guard2) {
-                    if (guard2 ? isIterateeCall(array2, size2, guard2) : size2 === undefined$12) {
-                        size2 = 1;
+                function chunk(array2, size3, guard2) {
+                    if (guard2 ? isIterateeCall(array2, size3, guard2) : size3 === undefined$12) {
+                        size3 = 1;
                     } else {
-                        size2 = nativeMax2(toInteger2(size2), 0);
+                        size3 = nativeMax2(toInteger2(size3), 0);
                     }
                     var length = array2 == null ? 0 : array2.length;
-                    if (!length || size2 < 1) {
+                    if (!length || size3 < 1) {
                         return [];
                     }
                     var index2 = 0,
                         resIndex = 0,
-                        result2 = Array2(nativeCeil(length / size2));
+                        result2 = Array2(nativeCeil(length / size3));
                     while (index2 < length) {
-                        result2[resIndex++] = baseSlice(array2, index2, index2 += size2);
+                        result2[resIndex++] = baseSlice(array2, index2, index2 += size3);
                     }
                     return result2;
                 }
 
                 function compact2(array2) {
                     var index2 = -1,
                         length = array2 == null ? 0 : array2.length,
@@ -12406,15 +12387,15 @@
                 }
 
                 function shuffle2(collection2) {
                     var func = isArray2(collection2) ? arrayShuffle : baseShuffle;
                     return func(collection2);
                 }
 
-                function size(collection2) {
+                function size2(collection2) {
                     if (collection2 == null) {
                         return 0;
                     }
                     if (isArrayLike2(collection2)) {
                         return isString2(collection2) ? stringSize(collection2) : collection2.length;
                     }
                     var tag = getTag2(collection2);
@@ -14129,15 +14110,15 @@
                 lodash2.reduceRight = reduceRight;
                 lodash2.repeat = repeat;
                 lodash2.replace = replace2;
                 lodash2.result = result;
                 lodash2.round = round2;
                 lodash2.runInContext = runInContext2;
                 lodash2.sample = sample;
-                lodash2.size = size;
+                lodash2.size = size2;
                 lodash2.snakeCase = snakeCase;
                 lodash2.some = some;
                 lodash2.sortedIndex = sortedIndex;
                 lodash2.sortedIndexBy = sortedIndexBy;
                 lodash2.sortedIndexOf = sortedIndexOf;
                 lodash2.sortedLastIndex = sortedLastIndex;
                 lodash2.sortedLastIndexBy = sortedLastIndexBy;
@@ -14364,28 +14345,28 @@
                 (freeModule.exports = _2)._ = _2;
                 freeExports._ = _2;
             } else {
                 root2._ = _2;
             }
         }).call(commonjsGlobal);
     })(lodash$1, lodash$1.exports);
-    let nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id2, byte) => {
+    let nanoid = (size2 = 21) => crypto.getRandomValues(new Uint8Array(size2)).reduce((id2, byte) => {
         byte &= 63;
         if (byte < 36) {
             id2 += byte.toString(36);
         } else if (byte < 62) {
             id2 += (byte - 26).toString(36).toUpperCase();
         } else if (byte > 62) {
             id2 += "-";
         } else {
             id2 += "_";
         }
         return id2;
     }, "");
-    const ErrorMessage$2 = styled__default.default.span`
+    const ErrorMessage$4 = styled__default.default.span`
     display: flex;
     flex-direction: column;
 
     padding-left: 1rem;
 
     font-size: 0.75rem;
     color: ${(props) => props.theme.colors.error};
@@ -14454,15 +14435,15 @@
                 onChange2(target.value, e3);
             }
         };
         const onKeyDown = (e3) => {
             if (keydownFilter && !keydownFilter(e3)) {
                 e3.preventDefault();
             }
-            if (e3.key === Key.ENTER && onComplete) {
+            if (e3.key === Key$1.ENTER && onComplete) {
                 onComplete();
             }
         };
         return jsxRuntime.exports.jsxs("div", {
             className,
             style: style2,
             children: [jsxRuntime.exports.jsx(PrimaryTextArea, {
@@ -14475,20 +14456,20 @@
                 onClick,
                 onKeyDown,
                 placeholder,
                 style: {
                     resize
                 },
                 value
-            }), errorMsg && jsxRuntime.exports.jsx(ErrorMessage$2, {
+            }), errorMsg && jsxRuntime.exports.jsx(ErrorMessage$4, {
                 children: errorMsg
             })]
         });
     }
-    const InteractiveIcons = styled__default.default.div`
+    const InteractiveIcons$1 = styled__default.default.div`
     position: absolute;
     top: 0.75rem;
     left: 236px;
 
     display: none;
     gap: 0.5rem;
 
@@ -14506,15 +14487,15 @@
     width: 100%;
     padding: 1rem;
 
     background-color: ${(props) => props.theme.colors.blue1};
     border-radius: 0.25rem;
     box-shadow: ${(props) => props.theme.shadow.medium};
 
-    :hover ${InteractiveIcons} {
+    :hover ${InteractiveIcons$1} {
         display: flex;
     }
 `;
     const MessageTop = styled__default.default.div`
     display: flex;
     justify-content: space-between;
 
@@ -14526,27 +14507,27 @@
 `;
     const MessageBody = styled__default.default.div`
     display: flex;
     width: 100%;
     color: ${(props) => props.theme.colors.text};
     overflow-wrap: break-word;
 `;
-    const DeleteIcon = styled__default.default(Trash)`
+    const DeleteIcon = styled__default.default(Trash$1)`
     height: 0.8rem;
     color: ${(props) => props.theme.colors.secondary};
 
     :hover {
         color: ${(props) => props.theme.colors.secondaryHover}CC;
     }
 
     :active {
         color: ${(props) => props.theme.colors.secondaryDown}99;
     }
 `;
-    const EditIcon = styled__default.default(PenToSquare)`
+    const EditIcon = styled__default.default(PenToSquare$1)`
     height: 0.8rem;
     color: ${(props) => props.theme.colors.secondary};
 
     :hover {
         color: ${(props) => props.theme.colors.secondaryHover}CC;
     }
 
@@ -14584,15 +14565,15 @@
                 props.onDelete(props.value.id);
             }
         };
         return jsxRuntime.exports.jsxs(MessageWrapper, {
             className: props.className,
             style: props.style,
             children: [jsxRuntime.exports.jsxs(MessageTop, {
-                children: [props.value.timestamp, !editMode && jsxRuntime.exports.jsxs(InteractiveIcons, {
+                children: [props.value.timestamp, !editMode && jsxRuntime.exports.jsxs(InteractiveIcons$1, {
                     children: [jsxRuntime.exports.jsx(EditIcon, {
                         "data-testid": "message-edit-button",
                         onClick: () => setEditMode(true),
                         role: "button"
                     }), jsxRuntime.exports.jsx(DeleteIcon, {
                         "data-testid": "message-delete-button",
                         onClick: onDelete,
@@ -14606,19 +14587,19 @@
                     gap: "1rem"
                 },
                 children: [jsxRuntime.exports.jsx(TextArea, {
                     onChange: setEditMessage,
                     resize: "vertical",
                     value: editMessage
                 }), jsxRuntime.exports.jsxs(EditButtons, {
-                    children: [jsxRuntime.exports.jsx(Button$3, {
+                    children: [jsxRuntime.exports.jsx(Button$5, {
                         onClick: () => setEditMode(false),
                         outline: true,
                         children: "Cancel"
-                    }), jsxRuntime.exports.jsx(Button$3, {
+                    }), jsxRuntime.exports.jsx(Button$5, {
                         onClick: onAccept,
                         children: "Save"
                     })]
                 })]
             }), !editMode && jsxRuntime.exports.jsx(MessageBody, {
                 children: localMessage.message
             })]
@@ -14669,15 +14650,15 @@
     justify-content: space-between;
 
     width: 100%;
     height: 1.625rem;
 
     font-size: 1.2rem;
 `;
-    const CloseIcon = styled__default.default(Xmark)`
+    const CloseIcon = styled__default.default(Xmark$1)`
     height: 1.2rem;
     color: ${(props) => props.theme.colors.grey4};
 
     :hover {
         color: ${(props) => props.theme.colors.grey5};
     }
 
@@ -14766,23 +14747,23 @@
             }), jsxRuntime.exports.jsxs(ReplyWrapper, {
                 children: [jsxRuntime.exports.jsx(TextArea, {
                     onChange: setReply,
                     placeholder: "Add a comment",
                     resize: "none",
                     value: reply
                 }), jsxRuntime.exports.jsx(ReplyButtons, {
-                    children: jsxRuntime.exports.jsx(Button$3, {
+                    children: jsxRuntime.exports.jsx(Button$5, {
                         onClick: onSubmitMessage,
                         children: "Send"
                     })
                 })]
             })]
         });
     }
-    const CheckboxWrapper$1 = styled__default.default.label`
+    const CheckboxWrapper$3 = styled__default.default.label`
     cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
     user-select: none;
 
     position: relative;
 
     display: flex;
     align-items: center;
@@ -14857,29 +14838,29 @@
       return props.theme.colors.blue1;
     }
     return props.theme.colors.grey2;
   }};
         }
     }
 `;
-    const StyledCheckbox$1 = styled__default.default.input`
+    const StyledCheckbox$2 = styled__default.default.input`
     cursor: pointer;
     /* Hide the browser's default checkbox */
     position: absolute;
 
     width: 0;
     height: 0;
 
     opacity: 0;
 
     :checked ~ span {
         background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
     }
 `;
-    const StyledCheckmark$1 = styled__default.default.span`
+    const StyledCheckmark$2 = styled__default.default.span`
     position: absolute;
     left: 0.5rem;
 
     width: 1rem;
     height: 1rem;
 
     background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
@@ -14890,15 +14871,15 @@
     :after {
         content: '';
         position: absolute;
         display: none;
     }
 `;
 
-    function Checkbox(props) {
+    function Checkbox$1(props) {
         const [checked, setChecked] = React.useState(props.selected || props.initialValue);
         React.useEffect(() => {
             if (props.selected !== void 0) {
                 setChecked(props.selected);
             }
         }, [props.selected]);
         const onClick = (e3) => {
@@ -14908,73 +14889,73 @@
             if (props.selected === void 0) {
                 setChecked(!checked);
             }
             if (props.onChange) {
                 props.onChange(!checked, e3);
             }
         };
-        return jsxRuntime.exports.jsxs(CheckboxWrapper$1, {
+        return jsxRuntime.exports.jsxs(CheckboxWrapper$3, {
             className: props.className,
             disabled: props.disabled,
             isListStyle: props.isListStyle,
-            children: [props.label, jsxRuntime.exports.jsx(StyledCheckbox$1, {
+            children: [props.label, jsxRuntime.exports.jsx(StyledCheckbox$2, {
                 "aria-disabled": props.disabled,
                 checked: props.selected,
                 disabled: props.disabled,
                 isListStyle: props.isListStyle,
                 onChange: (e3) => onClick(e3),
                 onClick: props.onClick,
                 type: "checkbox",
                 value: props.id
-            }), jsxRuntime.exports.jsx(StyledCheckmark$1, {
+            }), jsxRuntime.exports.jsx(StyledCheckmark$2, {
                 disabled: props.disabled,
                 isListStyle: props.isListStyle
             })]
         });
     }
-    const CheckboxWrapper = styled__default.default.div`
+    const CheckboxWrapper$2 = styled__default.default.div`
     user-select: none;
     display: flex;
     width: 100%;
     border: none;
 `;
-    const CheckboxGroupWrapper = styled__default.default.div`
+    const CheckboxGroupWrapper$1 = styled__default.default.div`
     color: ${(props) => props.theme.colors.text};
 `;
-    const CheckboxInfo = styled__default.default.p`
+    const CheckboxInfo$1 = styled__default.default.p`
     font-size: 0.75rem;
     color: ${(props) => props.theme.colors.grey4};
 `;
 
-    function getInitialValue$3(initialValue) {
+    function getInitialValue$4(initialValue) {
         if (Array.isArray(initialValue)) {
             return initialValue;
         }
         if (initialValue) {
             return [initialValue];
         }
         return [];
     }
 
-    function getInitialCheckedState(items, initialValues) {
+    function getInitialCheckedState$1(items, initialValues) {
         if (initialValues) {
             return items.map((item) => ({
                 state: initialValues.includes(item.value),
                 value: item.value
             }));
         }
         return items.map((item) => ({
             state: initialValues.includes(item.value),
             value: false
         }));
     }
 
-    function CheckboxGroup$1(props) {
-        const [values, setValues] = React.useState(() => getInitialValue$3(props.values || props.initialValue));
-        const [checkedState, setCheckedState] = React.useState(() => getInitialCheckedState(props.items, values));
+    function CheckboxGroup$2(props) {
+        const [values, setValues] = React.useState(() => getInitialValue$4(props.values || props.initialValue));
+        const [checkedState, setCheckedState] = React.useState(() => getInitialCheckedState$1(props.items, values));
         const isSelectPermitted = React.useMemo(() => {
             if (!props.selectMax || values.length < props.selectMax) {
                 return true;
             }
             return false;
         }, [values, props.selectMax]);
         const infoMessage = React.useMemo(() => {
@@ -15015,48 +14996,48 @@
                 setCheckedState(props.items.map((item) => ({
                     state: valuesArray.includes(item.value),
                     value: item.value
                 })));
                 setValues(valuesArray);
             }
         }, [props.values, props.items]);
-        return jsxRuntime.exports.jsxs(CheckboxGroupWrapper, {
+        return jsxRuntime.exports.jsxs(CheckboxGroupWrapper$1, {
             className: props.className,
             style: props.style,
-            children: [(props.selectMax || props.selectMin) && jsxRuntime.exports.jsx(CheckboxInfo, {
+            children: [(props.selectMax || props.selectMin) && jsxRuntime.exports.jsx(CheckboxInfo$1, {
                 children: infoMessage
             }), props.items.map((item, index2) => {
                 var _a3, _b;
-                return jsxRuntime.exports.jsx(CheckboxWrapper, {
+                return jsxRuntime.exports.jsx(CheckboxWrapper$2, {
                     "aria-disabled": props.disabled,
-                    children: jsxRuntime.exports.jsx(Checkbox, {
+                    children: jsxRuntime.exports.jsx(Checkbox$1, {
                         disabled: isSelectPermitted ? props.disabled : ((_a3 = checkedState.find((option) => option.value === item.value)) === null || _a3 === void 0 ? void 0 : _a3.state) === false,
                         id: index2,
                         isListStyle: props.isListStyle,
                         label: item.label ? item.label : item.value,
                         onChange: (checked, e3) => onChangeValue(e3),
                         selected: (_b = checkedState.find((option) => option.value === item.value)) === null || _b === void 0 ? void 0 : _b.state
                     })
                 }, `item-${index2}`);
             })]
         });
     }
-    var __rest$b = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$h = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
-    const PrimaryInput = styled__default.default.input`
+    const PrimaryInput$1 = styled__default.default.input`
     display: flex;
     align-items: center;
 
     width: 100%;
     height: 100%;
     padding: 0 1rem;
 
@@ -15084,130 +15065,130 @@
         cursor: not-allowed;
     }
 
     ::placeholder {
         font-style: italic;
     }
 `;
-    const InputWrapper$5 = styled__default.default.div`
+    const InputWrapper$9 = styled__default.default.div`
     width: 22ch;
     max-width: 100%;
     height: 2.5rem;
 `;
-    const ErrorMessage$1 = styled__default.default.span`
+    const ErrorMessage$3 = styled__default.default.span`
     margin-left: 1rem;
     font-size: 0.75rem;
     color: ${(props) => props.theme.colors.error};
 `;
-    const Input$3 = React.forwardRef((_a3, ref2) => {
+    const Input$5 = React.forwardRef((_a3, ref2) => {
         var {
             type: type2 = "text"
-        } = _a3, props = __rest$b(_a3, ["type"]);
+        } = _a3, props = __rest$h(_a3, ["type"]);
         const onChange2 = (e3) => {
             const target = e3.target;
             if (props.onChange) {
                 props.onChange(target.value, e3);
             }
         };
         const onKeyDown = (e3) => {
             if (props.onKeyDown) {
                 props.onKeyDown(e3);
             }
             if (props.keydownFilter && !props.keydownFilter(e3)) {
                 e3.preventDefault();
             }
-            if (e3.key === Key.ENTER && props.onComplete) {
+            if (e3.key === Key$1.ENTER && props.onComplete) {
                 props.onComplete();
             }
         };
         const addOptionalItems = () => {
             const result = {};
             if (props.minValue) {
                 result.minValue = props.minValue;
             }
             if (props.maxValue) {
                 result.maxValue = props.minValue;
             }
             return result;
         };
-        return jsxRuntime.exports.jsxs(InputWrapper$5, {
+        return jsxRuntime.exports.jsxs(InputWrapper$9, {
             className: props.className,
             style: props.style,
-            children: [jsxRuntime.exports.jsx(PrimaryInput, Object.assign({
+            children: [jsxRuntime.exports.jsx(PrimaryInput$1, Object.assign({
                 autoFocus: props.autoFocus,
                 defaultValue: props.initialValue,
                 disabled: props.disabled,
                 isErrored: !!props.errorMsg,
                 maxLength: props.maxLength,
                 onBlur: props.onBlur,
                 onChange: onChange2,
                 onClick: props.onClick,
                 onKeyDown,
                 placeholder: props.placeholder,
                 ref: ref2,
                 type: type2,
                 value: props.value
-            }, addOptionalItems())), props.errorMsg && jsxRuntime.exports.jsxs(ErrorMessage$1, {
+            }, addOptionalItems())), props.errorMsg && jsxRuntime.exports.jsxs(ErrorMessage$3, {
                 children: [props.errorMsg, " "]
             })]
         });
     });
-    Input$3.displayName = "Input";
-    const Wrapper$b = styled__default.default.div`
+    Input$5.displayName = "Input";
+    const Wrapper$h = styled__default.default.div`
     display: flex;
     margin: 0rem 0.5rem;
 `;
-    const SearchBarComponent = styled__default.default(Input$3)`
+    const SearchBarComponent$1 = styled__default.default(Input$5)`
     input {
         padding-right: 2.25rem;
     }
 
     :hover:not(:disabled) {
         input {
             border: 1px solid ${(props) => props.theme.colors.grey3};
         }
     }
 `;
-    const SearchBarIcon = styled__default.default(MagnifyingGlass)`
+    const SearchBarIcon$1 = styled__default.default(MagnifyingGlass$1)`
     position: relative;
     top: 0.625rem;
     right: 1.75rem;
 
     height: 1.25rem;
 
     color: ${(props) => props.theme.colors.grey4};
 `;
 
-    function SearchBar(props) {
+    function SearchBar$1(props) {
         var _a3;
-        return jsxRuntime.exports.jsxs(Wrapper$b, {
-            children: [jsxRuntime.exports.jsx(SearchBarComponent, {
+        return jsxRuntime.exports.jsxs(Wrapper$h, {
+            children: [jsxRuntime.exports.jsx(SearchBarComponent$1, {
                 className: props.className,
                 disabled: props.disabled,
                 maxLength: props.maxLength,
                 onChange: props.onChange,
                 placeholder: (_a3 = props.placeholder) !== null && _a3 !== void 0 ? _a3 : "Search",
                 style: props.style,
                 value: props.value
-            }), jsxRuntime.exports.jsx(SearchBarIcon, {})]
+            }), jsxRuntime.exports.jsx(SearchBarIcon$1, {})]
         });
     }
-    const FilterWrapper = styled__default.default.div`
+    const FilterWrapper$1 = styled__default.default.div`
     display: flex;
     flex-direction: column;
     gap: 0.5rem;
 
     width: 17.5rem;
     padding: 1.25rem 0.5rem;
 
     background-color: ${(props) => props.theme.colors.grey1};
     border-radius: 0.25rem;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
-    const StyledSearchBar = styled__default.default(SearchBar)`
+    const StyledSearchBar$1 = styled__default.default(SearchBar$1)`
     width: 15.5rem;
     background-color: ${(props) => props.theme.colors.blue1};
     border: 1px solid ${(props) => props.theme.colors.blue1};
     border-radius: 0.25rem;
 
     input {
         width: 15.5rem;
@@ -15226,15 +15207,15 @@
 
         input {
             background-color: ${(props) => props.theme.colors.blue1};
             border: none;
         }
     }
 `;
-    const FilterButtons = styled__default.default.button`
+    const FilterButtons$1 = styled__default.default.button`
     font-size: 0.75rem;
     font-weight: 400;
     color: ${(props) => props.theme.colors.primary};
 
     background-color: inherit;
     border: none;
 
@@ -15248,279 +15229,279 @@
     }
 
     :disabled {
         cursor: not-allowed;
         color: ${(props) => props.theme.colors.grey2};
     }
 `;
-    const OptionsWrapper = styled__default.default.div`
+    const OptionsWrapper$1 = styled__default.default.div`
     overflow-y: auto;
     height: 10rem;
 `;
-    const StyledCheckboxGroup = styled__default.default(CheckboxGroup$1)`
+    const StyledCheckboxGroup$1 = styled__default.default(CheckboxGroup$2)`
     div {
         height: 2rem;
         padding: 0rem 0.75rem;
     }
     label {
         font-size: 0.75rem;
         :hover {
             background: ${(props) => props.theme.colors.grey2} !important;
         }
         :active {
             background: ${(props) => props.theme.colors.grey3} !important;
         }
     }
 `;
-    const ApplyButton = styled__default.default(FilterButtons)`
+    const ApplyButton$1 = styled__default.default(FilterButtons$1)`
     align-self: center;
 
     width: fit-content;
     height: 2rem;
     padding: 0.5rem;
 
     font-size: 0.875rem;
 `;
 
-    function CategoricalFilter(props) {
+    function CategoricalFilter$1(props) {
         var _a3;
         const [inputValue, setInputValue] = React.useState("");
         const [filterValue, setFilterValue] = React.useState((_a3 = props.values) !== null && _a3 !== void 0 ? _a3 : []);
         const [previousFilter, setPreviousFilter] = React.useState(props.values);
         const filteredItems = props.items.filter((item) => {
             var _a4;
             return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
         });
-        return jsxRuntime.exports.jsxs(FilterWrapper, {
+        return jsxRuntime.exports.jsxs(FilterWrapper$1, {
             className: props.className,
-            children: [jsxRuntime.exports.jsx(StyledSearchBar, {
+            children: [jsxRuntime.exports.jsx(StyledSearchBar$1, {
                 onChange: (change) => setInputValue(change)
             }), jsxRuntime.exports.jsxs("div", {
                 style: {
                     display: "flex",
                     height: "2rem",
                     margin: "0rem 0.75rem -0.5rem 0.75rem"
                 },
-                children: [jsxRuntime.exports.jsx(FilterButtons, {
+                children: [jsxRuntime.exports.jsx(FilterButtons$1, {
                     onClick: () => setFilterValue(filteredItems),
                     children: "Select all"
-                }), jsxRuntime.exports.jsx(FilterButtons, {
+                }), jsxRuntime.exports.jsx(FilterButtons$1, {
                     onClick: () => setFilterValue([]),
                     children: "Clear"
                 })]
-            }), jsxRuntime.exports.jsx(OptionsWrapper, {
-                children: jsxRuntime.exports.jsx(StyledCheckboxGroup, {
+            }), jsxRuntime.exports.jsx(OptionsWrapper$1, {
+                children: jsxRuntime.exports.jsx(StyledCheckboxGroup$1, {
                     isListStyle: true,
                     items: filteredItems,
                     onChange: (v2) => {
                         var _a4, _b;
                         const selectedFilteredItems = Array.isArray(v2) ? v2 : [v2];
                         const unchecked = (_a4 = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => selectedFilteredItems.every((item) => !isEqual_1(value, item)) && filteredItems.some((item) => isEqual_1(value, item)))) !== null && _a4 !== void 0 ? _a4 : [];
                         const newlyChecked = selectedFilteredItems.filter((value) => filterValue === null || filterValue === void 0 ? void 0 : filterValue.every((item) => !isEqual_1(value, item)));
                         const stillChecked = (_b = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => !unchecked.some((item) => isEqual_1(value, item)))) !== null && _b !== void 0 ? _b : [];
                         setFilterValue([...stillChecked, ...newlyChecked]);
                     },
                     values: filterValue
                 })
-            }), jsxRuntime.exports.jsx(ApplyButton, {
+            }), jsxRuntime.exports.jsx(ApplyButton$1, {
                 disabled: props.disabled || previousFilter === filterValue,
                 onClick: (e3) => {
                     var _a4, _b;
                     (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, filterValue, e3);
                     (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filterValue || void 0);
                     setPreviousFilter(filterValue);
                 },
                 children: "Apply"
             })]
         });
     }
 
-    function _objectWithoutPropertiesLoose$4(source, excluded) {
+    function _objectWithoutPropertiesLoose$5(source, excluded) {
         if (source == null)
             return {};
         var target = {};
         var sourceKeys = Object.keys(source);
         var key, i2;
         for (i2 = 0; i2 < sourceKeys.length; i2++) {
             key = sourceKeys[i2];
             if (excluded.indexOf(key) >= 0)
                 continue;
             target[key] = source[key];
         }
         return target;
     }
-    var reactIs$1 = {
+    var reactIs = {
         exports: {}
     };
-    var reactIs_production_min$1 = {};
+    var reactIs_production_min = {};
     /** @license React v17.0.2
      * react-is.production.min.js
      *
      * Copyright (c) Facebook, Inc. and its affiliates.
      *
      * This source code is licensed under the MIT license found in the
      * LICENSE file in the root directory of this source tree.
      */
-    var b$5 = 60103,
-        c$6 = 60106,
-        d$3 = 60107,
-        e$3 = 60108,
-        f$4 = 60114,
-        g$4 = 60109,
-        h$4 = 60110,
-        k$4 = 60112,
-        l$4 = 60113,
-        m$3 = 60120,
-        n$5 = 60115,
-        p$4 = 60116,
-        q$4 = 60121,
+    var b$4 = 60103,
+        c$5 = 60106,
+        d$2 = 60107,
+        e$2 = 60108,
+        f$3 = 60114,
+        g$3 = 60109,
+        h$3 = 60110,
+        k$3 = 60112,
+        l$3 = 60113,
+        m$2 = 60120,
+        n$4 = 60115,
+        p$3 = 60116,
+        q$3 = 60121,
         r$3 = 60122,
-        u$3 = 60117,
-        v$4 = 60129,
+        u$2 = 60117,
+        v$3 = 60129,
         w$4 = 60131;
     if ("function" === typeof Symbol && Symbol.for) {
         var x$4 = Symbol.for;
-        b$5 = x$4("react.element");
-        c$6 = x$4("react.portal");
-        d$3 = x$4("react.fragment");
-        e$3 = x$4("react.strict_mode");
-        f$4 = x$4("react.profiler");
-        g$4 = x$4("react.provider");
-        h$4 = x$4("react.context");
-        k$4 = x$4("react.forward_ref");
-        l$4 = x$4("react.suspense");
-        m$3 = x$4("react.suspense_list");
-        n$5 = x$4("react.memo");
-        p$4 = x$4("react.lazy");
-        q$4 = x$4("react.block");
+        b$4 = x$4("react.element");
+        c$5 = x$4("react.portal");
+        d$2 = x$4("react.fragment");
+        e$2 = x$4("react.strict_mode");
+        f$3 = x$4("react.profiler");
+        g$3 = x$4("react.provider");
+        h$3 = x$4("react.context");
+        k$3 = x$4("react.forward_ref");
+        l$3 = x$4("react.suspense");
+        m$2 = x$4("react.suspense_list");
+        n$4 = x$4("react.memo");
+        p$3 = x$4("react.lazy");
+        q$3 = x$4("react.block");
         r$3 = x$4("react.server.block");
-        u$3 = x$4("react.fundamental");
-        v$4 = x$4("react.debug_trace_mode");
+        u$2 = x$4("react.fundamental");
+        v$3 = x$4("react.debug_trace_mode");
         w$4 = x$4("react.legacy_hidden");
     }
 
     function y$6(a2) {
         if ("object" === typeof a2 && null !== a2) {
             var t2 = a2.$$typeof;
             switch (t2) {
-                case b$5:
+                case b$4:
                     switch (a2 = a2.type, a2) {
-                        case d$3:
-                        case f$4:
-                        case e$3:
-                        case l$4:
-                        case m$3:
+                        case d$2:
+                        case f$3:
+                        case e$2:
+                        case l$3:
+                        case m$2:
                             return a2;
                         default:
                             switch (a2 = a2 && a2.$$typeof, a2) {
-                                case h$4:
-                                case k$4:
-                                case p$4:
-                                case n$5:
-                                case g$4:
+                                case h$3:
+                                case k$3:
+                                case p$3:
+                                case n$4:
+                                case g$3:
                                     return a2;
                                 default:
                                     return t2;
                             }
                     }
-                case c$6:
+                case c$5:
                     return t2;
             }
         }
     }
-    var z$3 = g$4,
-        A$3 = b$5,
-        B$2 = k$4,
-        C$3 = d$3,
-        D$3 = p$4,
-        E$2 = n$5,
-        F$3 = c$6,
-        G$2 = f$4,
-        H$4 = e$3,
-        I$2 = l$4;
-    reactIs_production_min$1.ContextConsumer = h$4;
-    reactIs_production_min$1.ContextProvider = z$3;
-    reactIs_production_min$1.Element = A$3;
-    reactIs_production_min$1.ForwardRef = B$2;
-    reactIs_production_min$1.Fragment = C$3;
-    reactIs_production_min$1.Lazy = D$3;
-    reactIs_production_min$1.Memo = E$2;
-    reactIs_production_min$1.Portal = F$3;
-    reactIs_production_min$1.Profiler = G$2;
-    reactIs_production_min$1.StrictMode = H$4;
-    reactIs_production_min$1.Suspense = I$2;
-    reactIs_production_min$1.isAsyncMode = function() {
+    var z$3 = g$3,
+        A$3 = b$4,
+        B$2 = k$3,
+        C$3 = d$2,
+        D$3 = p$3,
+        E$2 = n$4,
+        F$3 = c$5,
+        G$2 = f$3,
+        H$4 = e$2,
+        I$2 = l$3;
+    reactIs_production_min.ContextConsumer = h$3;
+    reactIs_production_min.ContextProvider = z$3;
+    reactIs_production_min.Element = A$3;
+    reactIs_production_min.ForwardRef = B$2;
+    reactIs_production_min.Fragment = C$3;
+    reactIs_production_min.Lazy = D$3;
+    reactIs_production_min.Memo = E$2;
+    reactIs_production_min.Portal = F$3;
+    reactIs_production_min.Profiler = G$2;
+    reactIs_production_min.StrictMode = H$4;
+    reactIs_production_min.Suspense = I$2;
+    reactIs_production_min.isAsyncMode = function() {
         return false;
     };
-    reactIs_production_min$1.isConcurrentMode = function() {
+    reactIs_production_min.isConcurrentMode = function() {
         return false;
     };
-    reactIs_production_min$1.isContextConsumer = function(a2) {
-        return y$6(a2) === h$4;
+    reactIs_production_min.isContextConsumer = function(a2) {
+        return y$6(a2) === h$3;
     };
-    reactIs_production_min$1.isContextProvider = function(a2) {
-        return y$6(a2) === g$4;
+    reactIs_production_min.isContextProvider = function(a2) {
+        return y$6(a2) === g$3;
     };
-    reactIs_production_min$1.isElement = function(a2) {
-        return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$5;
+    reactIs_production_min.isElement = function(a2) {
+        return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$4;
     };
-    reactIs_production_min$1.isForwardRef = function(a2) {
-        return y$6(a2) === k$4;
+    reactIs_production_min.isForwardRef = function(a2) {
+        return y$6(a2) === k$3;
     };
-    reactIs_production_min$1.isFragment = function(a2) {
-        return y$6(a2) === d$3;
+    reactIs_production_min.isFragment = function(a2) {
+        return y$6(a2) === d$2;
     };
-    reactIs_production_min$1.isLazy = function(a2) {
-        return y$6(a2) === p$4;
+    reactIs_production_min.isLazy = function(a2) {
+        return y$6(a2) === p$3;
     };
-    reactIs_production_min$1.isMemo = function(a2) {
-        return y$6(a2) === n$5;
+    reactIs_production_min.isMemo = function(a2) {
+        return y$6(a2) === n$4;
     };
-    reactIs_production_min$1.isPortal = function(a2) {
-        return y$6(a2) === c$6;
+    reactIs_production_min.isPortal = function(a2) {
+        return y$6(a2) === c$5;
     };
-    reactIs_production_min$1.isProfiler = function(a2) {
-        return y$6(a2) === f$4;
+    reactIs_production_min.isProfiler = function(a2) {
+        return y$6(a2) === f$3;
     };
-    reactIs_production_min$1.isStrictMode = function(a2) {
-        return y$6(a2) === e$3;
+    reactIs_production_min.isStrictMode = function(a2) {
+        return y$6(a2) === e$2;
     };
-    reactIs_production_min$1.isSuspense = function(a2) {
-        return y$6(a2) === l$4;
+    reactIs_production_min.isSuspense = function(a2) {
+        return y$6(a2) === l$3;
     };
-    reactIs_production_min$1.isValidElementType = function(a2) {
-        return "string" === typeof a2 || "function" === typeof a2 || a2 === d$3 || a2 === f$4 || a2 === v$4 || a2 === e$3 || a2 === l$4 || a2 === m$3 || a2 === w$4 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p$4 || a2.$$typeof === n$5 || a2.$$typeof === g$4 || a2.$$typeof === h$4 || a2.$$typeof === k$4 || a2.$$typeof === u$3 || a2.$$typeof === q$4 || a2[0] === r$3) ? true : false;
+    reactIs_production_min.isValidElementType = function(a2) {
+        return "string" === typeof a2 || "function" === typeof a2 || a2 === d$2 || a2 === f$3 || a2 === v$3 || a2 === e$2 || a2 === l$3 || a2 === m$2 || a2 === w$4 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p$3 || a2.$$typeof === n$4 || a2.$$typeof === g$3 || a2.$$typeof === h$3 || a2.$$typeof === k$3 || a2.$$typeof === u$2 || a2.$$typeof === q$3 || a2[0] === r$3) ? true : false;
     };
-    reactIs_production_min$1.typeOf = y$6;
+    reactIs_production_min.typeOf = y$6;
     (function(module2) {
         {
-            module2.exports = reactIs_production_min$1;
+            module2.exports = reactIs_production_min;
         }
-    })(reactIs$1);
-    let e$2 = (e3) => "object" == typeof e3 && null != e3 && 1 === e3.nodeType,
-        t$4 = (e3, t2) => (!t2 || "hidden" !== e3) && ("visible" !== e3 && "clip" !== e3),
-        n$4 = (e3, n2) => {
+    })(reactIs);
+    let e$1 = (e3) => "object" == typeof e3 && null != e3 && 1 === e3.nodeType,
+        t$3 = (e3, t2) => (!t2 || "hidden" !== e3) && ("visible" !== e3 && "clip" !== e3),
+        n$3 = (e3, n2) => {
             if (e3.clientHeight < e3.scrollHeight || e3.clientWidth < e3.scrollWidth) {
                 let l2 = getComputedStyle(e3, null);
-                return t$4(l2.overflowY, n2) || t$4(l2.overflowX, n2) || ((e4) => {
+                return t$3(l2.overflowY, n2) || t$3(l2.overflowX, n2) || ((e4) => {
                     let t2 = ((e6) => {
                         if (!e6.ownerDocument || !e6.ownerDocument.defaultView)
                             return null;
                         try {
                             return e6.ownerDocument.defaultView.frameElement;
                         } catch (e7) {
                             return null;
                         }
                     })(e4);
                     return !!t2 && (t2.clientHeight < e4.scrollHeight || t2.clientWidth < e4.scrollWidth);
                 })(e3);
             }
             return false;
         },
-        l$3 = (e3, t2, n2, l2, i2, o2, r2, d2) => o2 < e3 && r2 > t2 || o2 > e3 && r2 < t2 ? 0 : o2 <= e3 && d2 <= n2 || r2 >= t2 && d2 >= n2 ? o2 - e3 - l2 : r2 > t2 && d2 < n2 || o2 < e3 && d2 > n2 ? r2 - t2 + i2 : 0,
+        l$2 = (e3, t2, n2, l2, i2, o2, r2, d2) => o2 < e3 && r2 > t2 || o2 > e3 && r2 < t2 ? 0 : o2 <= e3 && d2 <= n2 || r2 >= t2 && d2 >= n2 ? o2 - e3 - l2 : r2 > t2 && d2 < n2 || o2 < e3 && d2 > n2 ? r2 - t2 + i2 : 0,
         i$5 = (e3) => {
             let t2 = e3.parentElement;
             return null == t2 ? e3.getRootNode().host || null : t2;
         };
     var o$4 = (t2, o2) => {
         var r2, d2, h2, f2, u2, s2;
         if ("undefined" == typeof document)
@@ -15528,25 +15509,25 @@
         let {
             scrollMode: a2,
             block: c2,
             inline: g2,
             boundary: m2,
             skipOverflowHiddenElements: p2
         } = o2, w2 = "function" == typeof m2 ? m2 : (e3) => e3 !== m2;
-        if (!e$2(t2))
+        if (!e$1(t2))
             throw new TypeError("Invalid target");
         let W2 = document.scrollingElement || document.documentElement,
             H2 = [],
             b2 = t2;
-        for (; e$2(b2) && w2(b2);) {
+        for (; e$1(b2) && w2(b2);) {
             if (b2 = i$5(b2), b2 === W2) {
                 H2.push(b2);
                 break;
             }
-            null != b2 && b2 === document.body && n$4(b2) && !n$4(document.documentElement) || null != b2 && n$4(b2, p2) && H2.push(b2);
+            null != b2 && b2 === document.body && n$3(b2) && !n$3(document.documentElement) || null != b2 && n$3(b2, p2) && H2.push(b2);
         }
         let v2 = null != (d2 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d2 : innerWidth,
             y2 = null != (f2 = null == (h2 = window.visualViewport) ? void 0 : h2.height) ? f2 : innerHeight,
             E2 = null != (u2 = window.scrollX) ? u2 : pageXOffset,
             M2 = null != (s2 = window.scrollY) ? s2 : pageYOffset,
             {
                 height: x2,
@@ -15579,17 +15560,17 @@
                 w3 = 0,
                 b3 = 0,
                 O2 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - u3 - m3 : 0,
                 X2 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - s3 - p3 : 0,
                 Y2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : i2 / t3.offsetWidth : 0,
                 L2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n2 / t3.offsetHeight : 0;
             if (W2 === t3)
-                w3 = "start" === c2 ? k2 : "end" === c2 ? k2 - y2 : "nearest" === c2 ? l$3(M2, M2 + y2, y2, s3, p3, M2 + k2, M2 + k2 + x2, x2) : k2 - y2 / 2, b3 = "start" === g2 ? B2 : "center" === g2 ? B2 - v2 / 2 : "end" === g2 ? B2 - v2 : l$3(E2, E2 + v2, v2, u3, m3, E2 + B2, E2 + B2 + I2, I2), w3 = Math.max(0, w3 + M2), b3 = Math.max(0, b3 + E2);
+                w3 = "start" === c2 ? k2 : "end" === c2 ? k2 - y2 : "nearest" === c2 ? l$2(M2, M2 + y2, y2, s3, p3, M2 + k2, M2 + k2 + x2, x2) : k2 - y2 / 2, b3 = "start" === g2 ? B2 : "center" === g2 ? B2 - v2 / 2 : "end" === g2 ? B2 - v2 : l$2(E2, E2 + v2, v2, u3, m3, E2 + B2, E2 + B2 + I2, I2), w3 = Math.max(0, w3 + M2), b3 = Math.max(0, b3 + E2);
             else {
-                w3 = "start" === c2 ? k2 - o3 - s3 : "end" === c2 ? k2 - d3 + p3 + X2 : "nearest" === c2 ? l$3(o3, d3, n2, s3, p3 + X2, k2, k2 + x2, x2) : k2 - (o3 + n2 / 2) + X2 / 2, b3 = "start" === g2 ? B2 - h3 - u3 : "center" === g2 ? B2 - (h3 + i2 / 2) + O2 / 2 : "end" === g2 ? B2 - r3 + m3 + O2 : l$3(h3, r3, i2, u3, m3 + O2, B2, B2 + I2, I2);
+                w3 = "start" === c2 ? k2 - o3 - s3 : "end" === c2 ? k2 - d3 + p3 + X2 : "nearest" === c2 ? l$2(o3, d3, n2, s3, p3 + X2, k2, k2 + x2, x2) : k2 - (o3 + n2 / 2) + X2 / 2, b3 = "start" === g2 ? B2 - h3 - u3 : "center" === g2 ? B2 - (h3 + i2 / 2) + O2 / 2 : "end" === g2 ? B2 - r3 + m3 + O2 : l$2(h3, r3, i2, u3, m3 + O2, B2, B2 + I2, I2);
                 let {
                     scrollLeft: e4,
                     scrollTop: f4
                 } = t3;
                 w3 = Math.max(0, Math.min(f4 + w3 / L2, t3.scrollHeight - n2 / L2 + X2)), b3 = Math.max(0, Math.min(e4 + b3 / Y2, t3.scrollWidth - i2 / Y2 + O2)), k2 += f4 - w3, B2 += e4 - b3;
             }
             D2.push({
@@ -16033,15 +16014,15 @@
         var selectedItem = selectionParameters.selectedItem,
             itemToStringLocal = selectionParameters.itemToString;
         return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
     }
     var updateA11yStatus = debounce$5(function(getA11yMessage, document2) {
         setStatus(getA11yMessage(), document2);
     }, 200);
-    var useIsomorphicLayoutEffect$4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? React.useLayoutEffect : React.useEffect;
+    var useIsomorphicLayoutEffect$5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? React.useLayoutEffect : React.useEffect;
 
     function useElementIds(_ref2) {
         var _ref$id = _ref2.id,
             id2 = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id,
             labelId = _ref2.labelId,
             menuId = _ref2.menuId,
             getItemId = _ref2.getItemId,
@@ -16144,15 +16125,15 @@
         var defaultValue2 = props["default" + capitalizeString(propKey)];
         if (defaultValue2 !== void 0) {
             return defaultValue2;
         }
         return defaultStateValues2[propKey];
     }
 
-    function getInitialValue$1(props, propKey, defaultStateValues2) {
+    function getInitialValue$1$1(props, propKey, defaultStateValues2) {
         if (defaultStateValues2 === void 0) {
             defaultStateValues2 = dropdownDefaultStateValues;
         }
         var value = props[propKey];
         if (value !== void 0) {
             return value;
         }
@@ -16160,18 +16141,18 @@
         if (initialValue !== void 0) {
             return initialValue;
         }
         return getDefaultValue$1(props, propKey, defaultStateValues2);
     }
 
     function getInitialState$2(props) {
-        var selectedItem = getInitialValue$1(props, "selectedItem");
-        var isOpen = getInitialValue$1(props, "isOpen");
-        var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
-        var inputValue = getInitialValue$1(props, "inputValue");
+        var selectedItem = getInitialValue$1$1(props, "selectedItem");
+        var isOpen = getInitialValue$1$1(props, "isOpen");
+        var highlightedIndex = getInitialValue$1$1(props, "highlightedIndex");
+        var inputValue = getInitialValue$1$1(props, "inputValue");
         return {
             highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
             isOpen,
             selectedItem,
             inputValue
         };
     }
@@ -16253,15 +16234,15 @@
     };
 
     function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
         var isInitialMount = _ref2.isInitialMount,
             highlightedIndex = _ref2.highlightedIndex,
             items = _ref2.items,
             environment = _ref2.environment,
-            rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$3);
+            rest = _objectWithoutPropertiesLoose$5(_ref2, _excluded$3);
         React.useEffect(function() {
             if (isInitialMount || false) {
                 return;
             }
             updateA11yStatus(function() {
                 return getA11yMessage(_extends$3({
                     highlightedIndex,
@@ -16276,15 +16257,15 @@
         var highlightedIndex = _ref3.highlightedIndex,
             isOpen = _ref3.isOpen,
             itemRefs = _ref3.itemRefs,
             getItemNodeFromIndex = _ref3.getItemNodeFromIndex,
             menuElement = _ref3.menuElement,
             scrollIntoViewProp = _ref3.scrollIntoView;
         var shouldScrollRef = React.useRef(true);
-        useIsomorphicLayoutEffect$4(function() {
+        useIsomorphicLayoutEffect$5(function() {
             if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
                 return;
             }
             if (shouldScrollRef.current === false) {
                 shouldScrollRef.current = true;
             } else {
                 scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
@@ -16830,15 +16811,15 @@
             var _ref2 = _temp === void 0 ? {} : _temp,
                 onMouseLeave = _ref2.onMouseLeave,
                 _ref$refKey = _ref2.refKey,
                 refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey;
             _ref2.onKeyDown;
             _ref2.onBlur;
             var ref2 = _ref2.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$2);
+                rest = _objectWithoutPropertiesLoose$5(_ref2, _excluded$2);
             var _ref22 = _temp2 === void 0 ? {} : _temp2;
             _ref22.suppressRefError;
             var menuHandleMouseLeave = function menuHandleMouseLeave2() {
                 dispatch2({
                     type: MenuMouseLeave$1
                 });
             };
@@ -16852,15 +16833,15 @@
                 onBlur = _ref3.onBlur,
                 onClick = _ref3.onClick;
             _ref3.onPress;
             var onKeyDown = _ref3.onKeyDown,
                 _ref3$refKey = _ref3.refKey,
                 refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
                 ref2 = _ref3.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded2$2);
+                rest = _objectWithoutPropertiesLoose$5(_ref3, _excluded2$2);
             var _ref4 = _temp4 === void 0 ? {} : _temp4;
             _ref4.suppressRefError;
             var latestState = latest.current.state;
             var toggleButtonHandleClick = function toggleButtonHandleClick2() {
                 dispatch2({
                     type: ToggleButtonClick$1
                 });
@@ -16903,15 +16884,15 @@
                 onMouseMove = _ref5.onMouseMove,
                 onClick = _ref5.onClick;
             _ref5.onPress;
             var _ref5$refKey = _ref5.refKey,
                 refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey,
                 ref2 = _ref5.ref,
                 disabled2 = _ref5.disabled,
-                rest = _objectWithoutPropertiesLoose$4(_ref5, _excluded3$1);
+                rest = _objectWithoutPropertiesLoose$5(_ref5, _excluded3$1);
             var _latest$current = latest.current,
                 latestState = _latest$current.state,
                 latestProps = _latest$current.props;
             var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"),
                 item = _getItemAndIndex[0],
                 index2 = _getItemAndIndex[1];
             var itemHandleMouseMove = function itemHandleMouseMove2() {
@@ -17204,15 +17185,15 @@
                 };
                 break;
             default:
                 return downshiftCommonReducer(state, action, stateChangeTypes$1$1);
         }
         return _extends$3({}, state, changes);
     }
-    var _excluded$1 = ["onMouseLeave", "refKey", "ref"],
+    var _excluded$1$1 = ["onMouseLeave", "refKey", "ref"],
         _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"],
         _excluded3 = ["onClick", "onPress", "refKey", "ref"],
         _excluded4 = ["onKeyDown", "onChange", "onInput", "onFocus", "onBlur", "onChangeText", "refKey", "ref"];
     useCombobox.stateChangeTypes = stateChangeTypes$1$1;
 
     function useCombobox(userProps) {
         if (userProps === void 0) {
@@ -17397,15 +17378,15 @@
         var getMenuProps = React.useCallback(function(_temp, _temp2) {
             var _extends2;
             var _ref2 = _temp === void 0 ? {} : _temp,
                 onMouseLeave = _ref2.onMouseLeave,
                 _ref$refKey = _ref2.refKey,
                 refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey,
                 ref2 = _ref2.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref2, _excluded$1);
+                rest = _objectWithoutPropertiesLoose$5(_ref2, _excluded$1$1);
             var _ref22 = _temp2 === void 0 ? {} : _temp2;
             _ref22.suppressRefError;
             return _extends$3((_extends2 = {}, _extends2[refKey] = handleRefs(ref2, function(menuNode) {
                 menuRef.current = menuNode;
             }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
                 dispatch2({
                     type: MenuMouseLeave
@@ -17421,15 +17402,15 @@
                 refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
                 ref2 = _ref3.ref,
                 onMouseMove = _ref3.onMouseMove,
                 onMouseDown = _ref3.onMouseDown,
                 onClick = _ref3.onClick;
             _ref3.onPress;
             var disabled2 = _ref3.disabled,
-                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded2$1);
+                rest = _objectWithoutPropertiesLoose$5(_ref3, _excluded2$1);
             var _latest$current = latest.current,
                 latestProps = _latest$current.props,
                 latestState = _latest$current.state;
             var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"),
                 index2 = _getItemAndIndex[1];
             var onSelectKey = "onClick";
             var customClickHandler = onClick;
@@ -17466,15 +17447,15 @@
             var _extends4;
             var _ref5 = _temp4 === void 0 ? {} : _temp4,
                 onClick = _ref5.onClick;
             _ref5.onPress;
             var _ref5$refKey = _ref5.refKey,
                 refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey,
                 ref2 = _ref5.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref5, _excluded3);
+                rest = _objectWithoutPropertiesLoose$5(_ref5, _excluded3);
             var latestState = latest.current.state;
             var toggleButtonHandleClick = function toggleButtonHandleClick2() {
                 dispatch2({
                     type: ToggleButtonClick
                 });
             };
             return _extends$3((_extends4 = {}, _extends4[refKey] = handleRefs(ref2, function(toggleButtonNode) {
@@ -17491,15 +17472,15 @@
                 onInput = _ref6.onInput,
                 onFocus = _ref6.onFocus,
                 onBlur = _ref6.onBlur;
             _ref6.onChangeText;
             var _ref6$refKey = _ref6.refKey,
                 refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey,
                 ref2 = _ref6.ref,
-                rest = _objectWithoutPropertiesLoose$4(_ref6, _excluded4);
+                rest = _objectWithoutPropertiesLoose$5(_ref6, _excluded4);
             var _ref7 = _temp6 === void 0 ? {} : _temp6;
             _ref7.suppressRefError;
             var latestState = latest.current.state;
             var inputHandleKeyDown = function inputHandleKeyDown2(event2) {
                 var key = normalizeArrowKey(event2);
                 if (key && inputKeyDownHandlers[key]) {
                     inputKeyDownHandlers[key](event2);
@@ -17595,25 +17576,25 @@
         };
     }
     var defaultStateValues = {
         activeIndex: -1,
         selectedItems: []
     };
 
-    function getInitialValue$2(props, propKey) {
-        return getInitialValue$1(props, propKey, defaultStateValues);
+    function getInitialValue$3(props, propKey) {
+        return getInitialValue$1$1(props, propKey, defaultStateValues);
     }
 
     function getDefaultValue(props, propKey) {
         return getDefaultValue$1(props, propKey, defaultStateValues);
     }
 
     function getInitialState(props) {
-        var activeIndex = getInitialValue$2(props, "activeIndex");
-        var selectedItems = getInitialValue$2(props, "selectedItems");
+        var activeIndex = getInitialValue$3(props, "activeIndex");
+        var selectedItems = getInitialValue$3(props, "selectedItems");
         return {
             activeIndex,
             selectedItems
         };
     }
 
     function isKeyDownOperationPermitted(event2) {
@@ -17673,15 +17654,15 @@
     var DropdownKeyDownBackspace = 6;
     var DropdownClick = 7;
     var FunctionAddSelectedItem = 8;
     var FunctionRemoveSelectedItem = 9;
     var FunctionSetSelectedItems = 10;
     var FunctionSetActiveIndex = 11;
     var FunctionReset = 12;
-    var stateChangeTypes$4 = /* @__PURE__ */ Object.freeze({
+    var stateChangeTypes$6 = /* @__PURE__ */ Object.freeze({
         __proto__: null,
         SelectedItemClick,
         SelectedItemKeyDownDelete,
         SelectedItemKeyDownBackspace,
         SelectedItemKeyDownNavigationNext,
         SelectedItemKeyDownNavigationPrevious,
         DropdownKeyDownNavigationPrevious,
@@ -17795,16 +17776,16 @@
                 break;
             default:
                 throw new Error("Reducer called without proper action type.");
         }
         return _extends$3({}, state, changes);
     }
     var _excluded$4 = ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"],
-        _excluded2 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
-    useMultipleSelection.stateChangeTypes = stateChangeTypes$4;
+        _excluded2$3 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
+    useMultipleSelection.stateChangeTypes = stateChangeTypes$6;
 
     function useMultipleSelection(userProps) {
         if (userProps === void 0) {
             userProps = {};
         }
         var props = _extends$3({}, defaultProps$4, userProps);
         var getA11yRemovalMessage2 = props.getA11yRemovalMessage,
@@ -17908,15 +17889,15 @@
                 _ref3$refKey = _ref3.refKey,
                 refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey,
                 ref2 = _ref3.ref,
                 onClick = _ref3.onClick,
                 onKeyDown = _ref3.onKeyDown,
                 selectedItemProp = _ref3.selectedItem,
                 indexProp = _ref3.index,
-                rest = _objectWithoutPropertiesLoose$4(_ref3, _excluded$4);
+                rest = _objectWithoutPropertiesLoose$5(_ref3, _excluded$4);
             var latestState = latest.current.state;
             var _getItemAndIndex = getItemAndIndex(selectedItemProp, indexProp, latestState.selectedItems, "Pass either item or index to getSelectedItemProps!"),
                 index2 = _getItemAndIndex[1];
             var isFocusable = index2 > -1 && index2 === latestState.activeIndex;
             var selectedItemHandleClick = function selectedItemHandleClick2() {
                 dispatch2({
                     type: SelectedItemClick,
@@ -17941,15 +17922,15 @@
                 _ref4$refKey = _ref4.refKey,
                 refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey,
                 ref2 = _ref4.ref,
                 onKeyDown = _ref4.onKeyDown,
                 onClick = _ref4.onClick,
                 _ref4$preventKeyActio = _ref4.preventKeyAction,
                 preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio,
-                rest = _objectWithoutPropertiesLoose$4(_ref4, _excluded2);
+                rest = _objectWithoutPropertiesLoose$5(_ref4, _excluded2$3);
             var _ref5 = _temp3 === void 0 ? {} : _temp3;
             _ref5.suppressRefError;
             var dropdownHandleKeyDown = function dropdownHandleKeyDown2(event2) {
                 var key = normalizeArrowKey(event2);
                 if (key && dropdownKeyDownHandlers[key]) {
                     dropdownKeyDownHandlers[key](event2);
                 }
@@ -18005,23 +17986,23 @@
             setSelectedItems,
             setActiveIndex,
             reset: reset2,
             selectedItems,
             activeIndex
         };
     }
-    var fromEntries$1 = function fromEntries2(entries) {
+    var fromEntries$2 = function fromEntries2(entries) {
         return entries.reduce(function(acc, _ref2) {
             var key = _ref2[0],
                 value = _ref2[1];
             acc[key] = value;
             return acc;
         }, {});
     };
-    var useIsomorphicLayoutEffect$3 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
+    var useIsomorphicLayoutEffect$4 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
 
     function getBoundingClientRect$1(element2) {
         var rect = element2.getBoundingClientRect();
         return {
             width: rect.width,
             height: rect.height,
             top: rect.top,
@@ -19446,25 +19427,25 @@
             if ((error2.message || "").match(/stack|recursion/i)) {
                 console.warn("react-fast-compare cannot handle circular refs");
                 return false;
             }
             throw error2;
         }
     };
-    var EMPTY_MODIFIERS$2 = [];
-    var usePopper$1 = function usePopper2(referenceElement, popperElement, options) {
+    var EMPTY_MODIFIERS$3 = [];
+    var usePopper$2 = function usePopper2(referenceElement, popperElement, options) {
         if (options === void 0) {
             options = {};
         }
         var prevOptions = React__namespace.useRef(null);
         var optionsWithDefaults = {
             onFirstUpdate: options.onFirstUpdate,
             placement: options.placement || "bottom",
             strategy: options.strategy || "absolute",
-            modifiers: options.modifiers || EMPTY_MODIFIERS$2
+            modifiers: options.modifiers || EMPTY_MODIFIERS$3
         };
         var _React$useState = React__namespace.useState({
                 styles: {
                     popper: {
                         position: optionsWithDefaults.strategy,
                         left: "0",
                         top: "0"
@@ -19482,18 +19463,18 @@
                 name: "updateState",
                 enabled: true,
                 phase: "write",
                 fn: function fn2(_ref2) {
                     var state2 = _ref2.state;
                     var elements = Object.keys(state2.elements);
                     setState({
-                        styles: fromEntries$1(elements.map(function(element2) {
+                        styles: fromEntries$2(elements.map(function(element2) {
                             return [element2, state2.styles[element2] || {}];
                         })),
-                        attributes: fromEntries$1(elements.map(function(element2) {
+                        attributes: fromEntries$2(elements.map(function(element2) {
                             return [element2, state2.attributes[element2]];
                         }))
                     });
                 },
                 requires: ["computeStyles"]
             };
         }, []);
@@ -19511,20 +19492,20 @@
                 return prevOptions.current || newOptions;
             } else {
                 prevOptions.current = newOptions;
                 return newOptions;
             }
         }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
         var popperInstanceRef = React__namespace.useRef();
-        useIsomorphicLayoutEffect$3(function() {
+        useIsomorphicLayoutEffect$4(function() {
             if (popperInstanceRef.current) {
                 popperInstanceRef.current.setOptions(popperOptions);
             }
         }, [popperOptions]);
-        useIsomorphicLayoutEffect$3(function() {
+        useIsomorphicLayoutEffect$4(function() {
             if (referenceElement == null || popperElement == null) {
                 return;
             }
             var createPopper2 = options.createPopper || createPopper$1;
             var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
             popperInstanceRef.current = popperInstance;
             return function() {
@@ -22135,15 +22116,15 @@
     tippy$1.defaultProps = defaultProps$2;
     tippy$1.setDefaultProps = setDefaultProps$1;
     tippy$1.currentInput = currentInput$1;
     tippy$1.setDefaultProps({
         animation: false
     });
 
-    function _objectWithoutPropertiesLoose$3(source, excluded) {
+    function _objectWithoutPropertiesLoose$4(source, excluded) {
         if (source == null)
             return {};
         var target = {};
         var sourceKeys = Object.keys(source);
         var key, i2;
         for (i2 = 0; i2 < sourceKeys.length; i2++) {
             key = sourceKeys[i2];
@@ -22189,15 +22170,15 @@
             popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
                 modifiers: [].concat((((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || []).filter(function(modifier) {
                     return modifier.name.indexOf("tippy") >= 0;
                 }), ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || [])
             })
         });
     }
-    var useIsomorphicLayoutEffect$2 = isBrowser$2 ? React.useLayoutEffect : React.useEffect;
+    var useIsomorphicLayoutEffect$3 = isBrowser$2 ? React.useLayoutEffect : React.useEffect;
 
     function useMutableBox(initialValue) {
         var ref2 = React.useRef();
         if (!ref2.current) {
             ref2.current = typeof initialValue === "function" ? initialValue() : initialValue;
         }
         return ref2.current;
@@ -22250,15 +22231,15 @@
                 reference2 = _ref2.reference,
                 _ref$disabled = _ref2.disabled,
                 disabled2 = _ref$disabled === void 0 ? false : _ref$disabled,
                 _ref$ignoreAttributes = _ref2.ignoreAttributes,
                 ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes;
             _ref2.__source;
             _ref2.__self;
-            var restOfNativeProps = _objectWithoutPropertiesLoose$3(_ref2, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
+            var restOfNativeProps = _objectWithoutPropertiesLoose$4(_ref2, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
             var isControlledMode = visible !== void 0;
             var isSingletonMode = singleton !== void 0;
             var _useState = React.useState(false),
                 mounted = _useState[0],
                 setMounted = _useState[1];
             var _useState2 = React.useState({}),
                 attrs2 = _useState2[0],
@@ -22306,15 +22287,15 @@
                         return {
                             popper: mutableBox.container
                         };
                     }
                 });
             }
             var deps = [reference2].concat(children2 ? [children2.type] : []);
-            useIsomorphicLayoutEffect$2(function() {
+            useIsomorphicLayoutEffect$3(function() {
                 var element2 = reference2;
                 if (reference2 && reference2.hasOwnProperty("current")) {
                     element2 = reference2.current;
                 }
                 var instance2 = tippy2(element2 || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
                     plugins: [classNamePlugin].concat(props.plugins || [])
                 }));
@@ -22334,15 +22315,15 @@
                 }
                 setMounted(true);
                 return function() {
                     instance2.destroy();
                     singleton == null ? void 0 : singleton.cleanup(instance2);
                 };
             }, deps);
-            useIsomorphicLayoutEffect$2(function() {
+            useIsomorphicLayoutEffect$3(function() {
                 if (mutableBox.renders === 1) {
                     mutableBox.renders++;
                     return;
                 }
                 var instance2 = mutableBox.instance;
                 instance2.setProps(deepPreserveProps(instance2.props, computedProps));
                 if (disabled2) {
@@ -22361,15 +22342,15 @@
                     singleton.hook({
                         instance: instance2,
                         content: content2,
                         props: computedProps
                     });
                 }
             });
-            useIsomorphicLayoutEffect$2(function() {
+            useIsomorphicLayoutEffect$3(function() {
                 var _instance$props$poppe;
                 if (!render2) {
                     return;
                 }
                 var instance2 = mutableBox.instance;
                 instance2.setProps({
                     popperOptions: Object.assign({}, instance2.props.popperOptions, {
@@ -22403,15 +22384,15 @@
             }) : null, mounted && /* @__PURE__ */ ReactDOM.createPortal(render2 ? render2(toDataAttributes(attrs2), singletonContent) : content2, mutableBox.container));
         }
         return Tippy2;
     }
     var forwardRef = function(Tippy2, defaultProps2) {
         return /* @__PURE__ */ React.forwardRef(function TippyWrapper(_ref2, _ref22) {
             var children2 = _ref2.children,
-                props = _objectWithoutPropertiesLoose$3(_ref2, ["children"]);
+                props = _objectWithoutPropertiesLoose$4(_ref2, ["children"]);
             return /* @__PURE__ */ React__default.default.createElement(Tippy2, Object.assign({}, defaultProps2, props), children2 ? /* @__PURE__ */ React.cloneElement(children2, {
                 ref: function ref2(node2) {
                     preserveRef(_ref22, node2);
                     preserveRef(children2.ref, node2);
                 }
             }) : null);
         });
@@ -23782,15 +23763,15 @@
                 }
             };
         }
     };
     tippy.setDefaultProps({
         render
     });
-    const TooltipWrapper = styled__default.default.div`
+    const TooltipWrapper$1 = styled__default.default.div`
     position: relative;
 
     display: block;
 
     max-width: 15rem;
     padding: 0.75rem 1rem;
 
@@ -23808,15 +23789,15 @@
             border: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
 
             background-color: ${props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error};
             `;
     }
   }};
 `;
-    const Arrow = styled__default.default.span`
+    const Arrow$1 = styled__default.default.span`
     position: absolute;
 
     ${(props) => {
     switch (props.placement) {
       case "top":
         return "bottom: 3px; left: -3px !important;";
       case "bottom":
@@ -23874,15 +23855,15 @@
         props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
     };
     `;
   }}
     }
 `;
 
-    function Tooltip$1({
+    function Tooltip$2({
         appendTo = document.body,
         getReferenceClientRect,
         children: children2,
         className,
         content: content2,
         disabled: disabled2,
         hideOnClick = true,
@@ -23904,36 +23885,36 @@
             followCursor: followCursor$1,
             getReferenceClientRect,
             hideOnClick: visible !== void 0 ? void 0 : hideOnClick,
             interactive,
             onClickOutside,
             placement,
             plugins: [followCursor],
-            render: (attrs2) => jsxRuntime.exports.jsxs(TooltipWrapper, Object.assign({
+            render: (attrs2) => jsxRuntime.exports.jsxs(TooltipWrapper$1, Object.assign({
                 "$hidden": hidden,
                 className,
                 style: style2,
                 styling
             }, attrs2, {
-                children: [content2, jsxRuntime.exports.jsx(Arrow, {
+                children: [content2, jsxRuntime.exports.jsx(Arrow$1, {
                     "$hidden": hidden,
                     "data-popper-arrow": "",
                     placement: attrs2["data-placement"],
                     styling
                 })]
             })),
             visible,
             zIndex: 9998,
             children: children2
         });
     }
     const {
-        stateChangeTypes: stateChangeTypes$3
+        stateChangeTypes: stateChangeTypes$5
     } = useCombobox;
-    const Wrapper$a = styled__default.default.div`
+    const Wrapper$g = styled__default.default.div`
     display: inline-flex;
 
     width: 100%;
     min-width: 4rem;
     height: 2.5rem;
 
     border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
@@ -23963,15 +23944,15 @@
             props.theme.colors.grey3
         };
 
     }
     `;
   }}
 `;
-    const InputWrapper$4 = styled__default.default.div`
+    const InputWrapper$8 = styled__default.default.div`
     display: flex;
     flex: 1 1 auto;
     align-items: center;
     justify-content: space-between;
 
     width: calc(100% - 1rem);
     height: 100%;
@@ -23986,15 +23967,15 @@
     :hover {
         background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
     }
     svg {
         height: 0.8rem;
     }
 `;
-    const Input$2 = styled__default.default.input`
+    const Input$4 = styled__default.default.input`
     overflow: hidden;
     flex: 1 1 auto;
 
     height: 100%;
     margin-right: 0.5rem;
     padding: 0rem;
 
@@ -24010,33 +23991,33 @@
     outline: 0;
 
     :disabled {
         cursor: not-allowed;
         color: ${(props) => props.theme.colors.grey2};
     }
 `;
-    const NoItemsLabel$1 = styled__default.default.span`
+    const NoItemsLabel$2 = styled__default.default.span`
     display: flex;
     flex: 1 1 auto;
     align-items: center;
     justify-content: center;
 
     height: 2rem;
 
     font-size: 1rem;
     color: ${(props) => props.theme.colors.text};
 
     background-color: ${(props) => props.theme.colors.blue1};
 `;
-    const DropdownList$3 = styled__default.default(List)`
+    const DropdownList$5 = styled__default.default(List$1)`
     margin-left: -1px;
     border-radius: 0px 0px 0.25rem 0.25rem;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
-    const ChevronButton$1 = styled__default.default(Button$3).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
+    const ChevronButton$2 = styled__default.default(Button$5).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
         styling: "ghost"
     }))`
     min-width: 0;
     height: auto;
     margin: 0;
     padding: 0 0.25rem;
 
@@ -24047,16 +24028,16 @@
         var _a3, _b, _c, _d, _e2, _f, _g;
         const referenceElement = React.useRef(null);
         const popperElement = React.useRef(null);
         const {
             styles: styles2,
             attributes: attributes2,
             update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
+        } = usePopper$2(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier$1],
             placement: "bottom-start"
         });
         const [inputValue, setInputValue] = React.useState((_d = (_b = (_a3 = props.initialValue) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : (_c = props.selectedItem) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : "");
         const [pendingHighlight, setPendingHighlight] = React.useState(null);
         const filteredItems = props.items.filter((item) => {
             var _a4;
             return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
@@ -24087,26 +24068,26 @@
                 }
             },
             stateReducer: (state, {
                 changes,
                 type: type2
             }) => {
                 var _a4;
-                if (type2 === stateChangeTypes$3.InputFocus || type2 === stateChangeTypes$3.ToggleButtonClick && changes.isOpen || type2 === stateChangeTypes$3.ControlledPropUpdatedSelectedItem && changes.isOpen) {
+                if (type2 === stateChangeTypes$5.InputFocus || type2 === stateChangeTypes$5.ToggleButtonClick && changes.isOpen || type2 === stateChangeTypes$5.ControlledPropUpdatedSelectedItem && changes.isOpen) {
                     setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
                     return Object.assign(Object.assign({}, changes), {
                         inputValue: ""
                     });
                 }
                 if ([
-                        stateChangeTypes$3.InputKeyDownEnter,
-                        stateChangeTypes$3.ItemClick,
-                        stateChangeTypes$3.InputBlur,
-                        stateChangeTypes$3.InputKeyDownEscape,
-                        stateChangeTypes$3.ToggleButtonClick
+                        stateChangeTypes$5.InputKeyDownEnter,
+                        stateChangeTypes$5.ItemClick,
+                        stateChangeTypes$5.InputBlur,
+                        stateChangeTypes$5.InputKeyDownEscape,
+                        stateChangeTypes$5.ToggleButtonClick
                     ].includes(type2)) {
                     return Object.assign(Object.assign({}, changes), {
                         inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
                     });
                 }
                 return changes;
             }
@@ -24132,62 +24113,62 @@
         const menuProps = getMenuProps();
         const setMenuRef = menuProps.ref;
         delete menuProps.ref;
         const setMenuReference = (value) => {
             setMenuRef(value);
             popperElement.current = value;
         };
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: props.errorMsg,
             disabled: !props.errorMsg,
             styling: "error",
-            children: jsxRuntime.exports.jsxs(Wrapper$a, {
+            children: jsxRuntime.exports.jsxs(Wrapper$g, {
                 className: props.className,
                 isDisabled: props.disabled,
                 isErrored: !!props.errorMsg,
                 isOpen,
                 style: props.style,
-                children: [jsxRuntime.exports.jsxs(InputWrapper$4, {
+                children: [jsxRuntime.exports.jsxs(InputWrapper$8, {
                     disabled: props.disabled,
                     isOpen,
                     ref: referenceElement,
-                    children: [jsxRuntime.exports.jsx(Input$2, Object.assign({}, getInputProps({
+                    children: [jsxRuntime.exports.jsx(Input$4, Object.assign({}, getInputProps({
                         disabled: props.disabled
                     }), {
                         placeholder: (_f = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _f !== void 0 ? _f : props.placeholder,
                         size: props.size
-                    })), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
-                        children: jsxRuntime.exports.jsx(Chevron$2, {
+                    })), jsxRuntime.exports.jsx(ChevronButton$2, Object.assign({}, getToggleButtonProps(), {
+                        children: jsxRuntime.exports.jsx(Chevron$4, {
                             disabled: props.disabled,
                             isOpen
                         })
                     }))]
-                }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$3, Object.assign({}, menuProps, attributes2.popper, {
+                }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$5, Object.assign({}, menuProps, attributes2.popper, {
                     isOpen,
                     ref: setMenuReference,
                     style: Object.assign(Object.assign({}, styles2.popper), {
                         width: parseFloat((_g = styles2.popper) === null || _g === void 0 ? void 0 : _g.width) + 2,
                         zIndex: 9999
                     }),
-                    children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem, Object.assign({}, getItemProps({
+                    children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem$1, Object.assign({}, getItemProps({
                         index: index2,
                         item
                     }), {
                         hovered: index2 === highlightedIndex,
                         key: `item-${index2}`,
                         size: props.size,
                         title: item.label
-                    }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
+                    }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$2, {
                         children: "No Items"
                     })]
                 })), document.body)]
             })
         });
     }
-    styled__default.default(List)`
+    styled__default.default(List$1)`
     overflow-y: auto;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
 
     function toInteger$3(dirtyNumber) {
         if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
             return NaN;
@@ -27035,15 +27016,15 @@
     var formattingTokensRegExp$2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
     var longFormattingTokensRegExp$2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
     var escapedStringRegExp$2 = /^'([^]*?)'?$/;
     var doubleQuoteRegExp$2 = /''/g;
     var notWhitespaceRegExp$1 = /\S/;
     var unescapedLatinCharacterRegExp$2 = /[a-zA-Z]/;
 
-    function parse$a(dirtyDateString, dirtyFormatString, dirtyBackupDate, dirtyOptions) {
+    function parse$9(dirtyDateString, dirtyFormatString, dirtyBackupDate, dirtyOptions) {
         requiredArgs$1(3, arguments);
         var dateString = String(dirtyDateString);
         var formatString = String(dirtyFormatString);
         var options = dirtyOptions || {};
         var locale2 = options.locale || defaultLocale$1;
         if (!locale2.match) {
             throw new RangeError("locale must contain match property");
@@ -31683,15 +31664,15 @@
     var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
     var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
     var escapedStringRegExp = /^'([^]*?)'?$/;
     var doubleQuoteRegExp = /''/g;
     var notWhitespaceRegExp = /\S/;
     var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
 
-    function parse$9(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
+    function parse$8(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
         var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
         requiredArgs(3, arguments);
         var dateString = String(dirtyDateString);
         var formatString = String(dirtyFormatString);
         var defaultOptions2 = getDefaultOptions();
         var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
         if (!locale2.match) {
@@ -32050,15 +32031,15 @@
         _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
             o3.__proto__ = p3;
             return o3;
         };
         return _setPrototypeOf$1(o2, p2);
     }
 
-    function _objectWithoutPropertiesLoose$2(source, excluded) {
+    function _objectWithoutPropertiesLoose$3(source, excluded) {
         if (source == null)
             return {};
         var target = {};
         var sourceKeys = Object.keys(source);
         var key, i2;
         for (i2 = 0; i2 < sourceKeys.length; i2++) {
             key = sourceKeys[i2];
@@ -32259,15 +32240,15 @@
             };
             _proto.componentWillUnmount = function componentWillUnmount() {
                 this.disableOnClickOutside();
             };
             _proto.render = function render2() {
                 var _this$props = this.props;
                 _this$props.excludeScrollbar;
-                var props = _objectWithoutPropertiesLoose$2(_this$props, ["excludeScrollbar"]);
+                var props = _objectWithoutPropertiesLoose$3(_this$props, ["excludeScrollbar"]);
                 if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
                     props.ref = this.getRef;
                 } else {
                     props.wrappedRef = this.getRef;
                 }
                 props.disableOnClickOutside = this.disableOnClickOutside;
                 props.enableOnClickOutside = this.enableOnClickOutside;
@@ -32323,34 +32304,34 @@
     var setRef$1 = function setRef2(ref2, node2) {
         if (typeof ref2 === "function") {
             return safeInvoke(ref2, node2);
         } else if (ref2 != null) {
             ref2.current = node2;
         }
     };
-    var fromEntries = function fromEntries2(entries) {
+    var fromEntries$1 = function fromEntries2(entries) {
         return entries.reduce(function(acc, _ref2) {
             var key = _ref2[0],
                 value = _ref2[1];
             acc[key] = value;
             return acc;
         }, {});
     };
-    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
-    var EMPTY_MODIFIERS$1 = [];
-    var usePopper = function usePopper2(referenceElement, popperElement, options) {
+    var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
+    var EMPTY_MODIFIERS$2 = [];
+    var usePopper$1 = function usePopper2(referenceElement, popperElement, options) {
         if (options === void 0) {
             options = {};
         }
         var prevOptions = React__namespace.useRef(null);
         var optionsWithDefaults = {
             onFirstUpdate: options.onFirstUpdate,
             placement: options.placement || "bottom",
             strategy: options.strategy || "absolute",
-            modifiers: options.modifiers || EMPTY_MODIFIERS$1
+            modifiers: options.modifiers || EMPTY_MODIFIERS$2
         };
         var _React$useState = React__namespace.useState({
                 styles: {
                     popper: {
                         position: optionsWithDefaults.strategy,
                         left: "0",
                         top: "0"
@@ -32368,18 +32349,18 @@
                 name: "updateState",
                 enabled: true,
                 phase: "write",
                 fn: function fn2(_ref2) {
                     var state2 = _ref2.state;
                     var elements = Object.keys(state2.elements);
                     setState({
-                        styles: fromEntries(elements.map(function(element2) {
+                        styles: fromEntries$1(elements.map(function(element2) {
                             return [element2, state2.styles[element2] || {}];
                         })),
-                        attributes: fromEntries(elements.map(function(element2) {
+                        attributes: fromEntries$1(elements.map(function(element2) {
                             return [element2, state2.attributes[element2]];
                         }))
                     });
                 },
                 requires: ["computeStyles"]
             };
         }, []);
@@ -32397,20 +32378,20 @@
                 return prevOptions.current || newOptions;
             } else {
                 prevOptions.current = newOptions;
                 return newOptions;
             }
         }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
         var popperInstanceRef = React__namespace.useRef();
-        useIsomorphicLayoutEffect$1(function() {
+        useIsomorphicLayoutEffect$2(function() {
             if (popperInstanceRef.current) {
                 popperInstanceRef.current.setOptions(popperOptions);
             }
         }, [popperOptions]);
-        useIsomorphicLayoutEffect$1(function() {
+        useIsomorphicLayoutEffect$2(function() {
             if (referenceElement == null || popperElement == null) {
                 return;
             }
             var createPopper$12 = options.createPopper || createPopper;
             var popperInstance = createPopper$12(referenceElement, popperElement, popperOptions);
             popperInstanceRef.current = popperInstance;
             return function() {
@@ -32428,23 +32409,23 @@
     };
     var NOOP$1 = function NOOP2() {
         return void 0;
     };
     var NOOP_PROMISE = function NOOP_PROMISE2() {
         return Promise.resolve(null);
     };
-    var EMPTY_MODIFIERS = [];
+    var EMPTY_MODIFIERS$1 = [];
 
     function Popper(_ref2) {
         var _ref$placement = _ref2.placement,
             placement = _ref$placement === void 0 ? "bottom" : _ref$placement,
             _ref$strategy = _ref2.strategy,
             strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy,
             _ref$modifiers = _ref2.modifiers,
-            modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers,
+            modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS$1 : _ref$modifiers,
             referenceElement = _ref2.referenceElement,
             onFirstUpdate = _ref2.onFirstUpdate,
             innerRef = _ref2.innerRef,
             children2 = _ref2.children;
         var referenceNode = React__namespace.useContext(ManagerReferenceNodeContext);
         var _React$useState = React__namespace.useState(null),
             popperElement = _React$useState[0],
@@ -32465,15 +32446,15 @@
                     enabled: arrowElement != null,
                     options: {
                         element: arrowElement
                     }
                 }])
             };
         }, [placement, strategy, onFirstUpdate, modifiers2, arrowElement]);
-        var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options),
+        var _usePopper = usePopper$1(referenceElement || referenceNode, popperElement, options),
             state = _usePopper.state,
             styles2 = _usePopper.styles,
             forceUpdate = _usePopper.forceUpdate,
             update2 = _usePopper.update;
         var childrenProps = React__namespace.useMemo(function() {
             return {
                 ref: setPopperElement,
@@ -32760,24 +32741,24 @@
     }
 
     function Me$1(e3, t2, r2, n2, o2) {
         var a2 = null,
             s2 = Ue(r2) || Ue(qe$1()),
             i2 = true;
         return Array.isArray(t2) ? (t2.forEach(function(t3) {
-            var p2 = parse$9(e3, t3, new Date(), {
+            var p2 = parse$8(e3, t3, new Date(), {
                 locale: s2
             });
             n2 && (i2 = Pe$1(p2, o2) && e3 === Ee$1(p2, t3, r2)), Pe$1(p2, o2) && i2 && (a2 = p2);
-        }), a2) : (a2 = parse$9(e3, t2, new Date(), {
+        }), a2) : (a2 = parse$8(e3, t2, new Date(), {
             locale: s2
         }), n2 ? i2 = Pe$1(a2) && e3 === Ee$1(a2, t2, r2) : Pe$1(a2) || (t2 = t2.match(Se).map(function(e4) {
             var t3 = e4[0];
             return "p" === t3 || "P" === t3 ? s2 ? (0, Ce$1[t3])(e4, s2.formatLong) : t3 : e4;
-        }).join(""), e3.length > 0 && (a2 = parse$9(e3, t2.slice(0, e3.length), new Date())), Pe$1(a2) || (a2 = new Date(e3))), Pe$1(a2) && i2 ? a2 : null);
+        }).join(""), e3.length > 0 && (a2 = parse$8(e3, t2.slice(0, e3.length), new Date())), Pe$1(a2) || (a2 = new Date(e3))), Pe$1(a2) && i2 ? a2 : null);
     }
 
     function Pe$1(e3, t2) {
         return t2 = t2 || new Date("1/1/1000"), isValid(e3) && !isBefore(e3, t2);
     }
 
     function Ee$1(e3, t2, r2) {
@@ -35580,35 +35561,35 @@
                     };
                 }
             }]), a2;
         }(),
         jt$1 = "input",
         Ht$1 = "navigate";
     const reactDatepicker = "";
-    var __rest$a = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$g = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
     const {
-        stateChangeTypes: stateChangeTypes$2
+        stateChangeTypes: stateChangeTypes$4
     } = useSelect;
-    const SelectedItem$1 = styled__default.default.div`
+    const SelectedItem$3 = styled__default.default.div`
     width: 100%;
     font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
     font-weight: 300;
 `;
-    const Wrapper$9 = styled__default.default.div`
+    const Wrapper$f = styled__default.default.div`
     display: inline-flex;
     width: 6.25rem;
     height: 1.5rem;
     border-radius: 0.25rem;
 
     ${(props) => {
     if (props.isDisabled) {
@@ -35627,15 +35608,15 @@
     return `
     border: 1 px solid $ {
         props.theme.colors.grey1
     };
     `;
   }}
 `;
-    const SelectButton$1 = styled__default.default.button`
+    const SelectButton$3 = styled__default.default.button`
     cursor: pointer;
 
     display: inline-flex;
     flex: 1 1 auto;
     align-items: center;
     justify-content: space-between;
 
@@ -35648,15 +35629,15 @@
     border: none;
     outline: 0;
 
     :not(:enabled) {
         cursor: not-allowed;
     }
 `;
-    const SelectButtonPrimary = styled__default.default(SelectButton$1)`
+    const SelectButtonPrimary$1 = styled__default.default(SelectButton$3)`
     justify-content: start;
 
     width: 100%;
     padding: 0rem 0.25rem;
 
     font-size: 0.875rem;
     color: ${(props) => props.theme.colors.text};
@@ -35678,15 +35659,15 @@
 
     svg {
         width: 1rem !important;
         height: 0.8rem;
         margin-left: 0.5rem !important;
     }
 `;
-    const DatepickerListItem = styled__default.default.span`
+    const DatepickerListItem$1 = styled__default.default.span`
     cursor: pointer;
     user-select: none;
 
     overflow: hidden;
     display: flex;
     align-items: center;
 
@@ -35714,38 +35695,38 @@
         background-color: ${(props) => props.theme.colors.grey1};
     }
 
     &:last-child {
         border-bottom: none;
     }
 `;
-    const DropdownList$2 = styled__default.default.div`
+    const DropdownList$4 = styled__default.default.div`
     overflow-y: auto;
     display: ${(props) => props.isOpen ? "flex" : "none"};
     flex-direction: column;
     gap: 0.125rem;
 
     max-height: calc(${(props) => (props.maxItems || 5) * 2}em + 2px);
     margin-left: ${(props) => props.displacement}rem;
 
     background-color: ${(props) => props.theme.colors.grey1};
     border: None;
     outline: 0;
 `;
 
-    function DatepickerSelect(props) {
+    function DatepickerSelect$1(props) {
         var _a3, _b, _c;
         const referenceElement = React.useRef(null);
         const popperElement = React.useRef(null);
         const {
             styles: styles2,
             attributes: attributes2,
             update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
+        } = usePopper$2(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier$1],
             placement: props.placement || "bottom-start"
         });
         const [pendingHighlight, setPendingHighlight] = React.useState(null);
         const {
             isOpen,
             selectedItem,
             getToggleButtonProps,
@@ -35763,15 +35744,15 @@
                     props.onSelect(selected);
                 }
             },
             stateReducer: (state, {
                 changes,
                 type: type2
             }) => {
-                if (type2 === stateChangeTypes$2.ToggleButtonClick) {
+                if (type2 === stateChangeTypes$4.ToggleButtonClick) {
                     setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
                 }
                 return changes;
             }
         }, props.selectedItem && {
             selectedItem: props.selectedItem
         }));
@@ -35800,37 +35781,37 @@
         delete menuProps.ref;
         const setMenuReference = (value) => {
             var _a4;
             setMenuRef(value);
             popperElement.current = value;
             (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
         };
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: props.errorMsg,
             disabled: !props.errorMsg,
             styling: "error",
-            children: jsxRuntime.exports.jsxs(Wrapper$9, {
+            children: jsxRuntime.exports.jsxs(Wrapper$f, {
                 className: props.className,
                 isDisabled: props.disabled,
                 isErrored: !!props.errorMsg,
                 onClick: props.onClick,
                 style: props.style,
-                children: [jsxRuntime.exports.jsxs(SelectButtonPrimary, Object.assign({
+                children: [jsxRuntime.exports.jsxs(SelectButtonPrimary$1, Object.assign({
                     disabled: props.disabled
                 }, buttonProps, {
                     ref: setButtonReference,
                     type: "button",
-                    children: [jsxRuntime.exports.jsx(SelectedItem$1, {
+                    children: [jsxRuntime.exports.jsx(SelectedItem$3, {
                         size: props.size,
                         children: selectedItem ? selectedItem.label : "Select"
-                    }), jsxRuntime.exports.jsx(Chevron$2, {
+                    }), jsxRuntime.exports.jsx(Chevron$4, {
                         disabled: props.disabled,
                         isOpen
                     })]
-                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$2, Object.assign({}, menuProps, attributes2.popper, {
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$4, Object.assign({}, menuProps, attributes2.popper, {
                     className: `${(_a3 = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _a3 !== void 0 ? _a3 : ""} ${(_c = (_b = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _b === void 0 ? void 0 : _b.className) !== null && _c !== void 0 ? _c : ""} ${props.itemClass}`,
                     displacement: props.displacement,
                     isOpen,
                     maxItems: 7,
                     ref: setMenuReference,
                     style: Object.assign(Object.assign({}, styles2.popper), {
                         marginTop: `0.8rem`,
@@ -35841,52 +35822,52 @@
                         const _a4 = getItemProps({
                                 index: index2,
                                 item
                             }),
                             {
                                 itemClassName
                             } = _a4,
-                            itemProps = __rest$a(_a4, ["itemClassName"]);
-                        return React.createElement(DatepickerListItem, Object.assign({}, itemProps, {
+                            itemProps = __rest$g(_a4, ["itemClassName"]);
+                        return React.createElement(DatepickerListItem$1, Object.assign({}, itemProps, {
                             "aria-selected": selectedItem.label === item.label,
                             className: `${itemClassName} ${props.itemClass}`,
                             hovered: index2 === highlightedIndex,
                             isSelected: selectedItem.label === item.label,
                             key: `item-${index2}`,
                             size: props.size,
                             title: item.label
                         }), item.label);
                     })
                 })), document.body)]
             })
         });
     }
 
-    function getMonths() {
+    function getMonths$1() {
         const months = [];
         for (let i2 = 0; i2 < 12; i2++) {
             months.push({
                 label: enGB.localize.month(i2),
                 value: i2
             });
         }
         return months;
     }
 
-    function getYears(minDate, maxDate) {
+    function getYears$1(minDate, maxDate) {
         var _a3, _b;
         const minYear = (_a3 = minDate === null || minDate === void 0 ? void 0 : minDate.getFullYear()) !== null && _a3 !== void 0 ? _a3 : 1900;
         const maxYear = (_b = maxDate === null || maxDate === void 0 ? void 0 : maxDate.getFullYear()) !== null && _b !== void 0 ? _b : 2100;
         return lodash$1.exports.range(minYear, maxYear + 1, 1).map((val) => ({
             label: val.toString(),
             value: val
         }));
     }
-    const IGNORE_CLASSNAME = "react-datepicker-ignore-onclickoutside";
-    const DatepickerWrapper$1 = styled__default.default.div`
+    const IGNORE_CLASSNAME$1 = "react-datepicker-ignore-onclickoutside";
+    const DatepickerWrapper$3 = styled__default.default.div`
     display: flex;
     flex-direction: ${(props) => props.inline ? "column" : "row"};
     align-items: ${(props) => props.inline ? "baseline" : "center"};
 
     width: 8.5rem;
 
     color: ${(props) => props.theme.colors.text};
@@ -36057,35 +36038,35 @@
                         }
                     }
                 }
             }
         }
     }
 `;
-    const DatepickerInputs = styled__default.default.div`
+    const DatepickerInputs$1 = styled__default.default.div`
     display: flex;
     gap: 0.5rem;
 `;
-    const HeaderWrapper = styled__default.default.div`
+    const HeaderWrapper$1 = styled__default.default.div`
     display: flex;
     flex-direction: column;
     align-items: center;
     padding-bottom: 0.75rem;
 `;
-    const MonthNavigation = styled__default.default.div`
+    const MonthNavigation$1 = styled__default.default.div`
     display: flex;
     align-items: center;
     justify-content: space-between;
 `;
-    const DropdownsWrapper = styled__default.default.div`
+    const DropdownsWrapper$1 = styled__default.default.div`
     display: flex;
     align-items: center;
     justify-content: center;
 `;
-    const MonthButton = styled__default.default(Button$3)`
+    const MonthButton$1 = styled__default.default(Button$5)`
     min-width: 0rem;
     height: 1.5rem;
     margin: 0px;
     padding: 0.75rem 0.37rem;
 
     svg {
         width: 0.75rem;
@@ -36095,34 +36076,34 @@
 
     :hover:not(:disabled) {
         svg {
             color: ${(props) => props.theme.colors.text};
         }
     }
 `;
-    const MonthSelect = styled__default.default(DatepickerSelect)`
+    const MonthSelect$1 = styled__default.default(DatepickerSelect$1)`
     width: 6.25rem;
     margin-right: 0.55em;
     font-size: 0.875rem;
 `;
-    const YearSelect = styled__default.default(DatepickerSelect)`
+    const YearSelect$1 = styled__default.default(DatepickerSelect$1)`
     width: 3.75rem;
     margin-right: 0.8em;
 `;
-    const EndDateInputWrapper = styled__default.default.div`
+    const EndDateInputWrapper$1 = styled__default.default.div`
     display: flex;
     gap: 0.5rem;
     align-items: center;
 `;
-    const DateTimeWrapper = styled__default.default.div`
+    const DateTimeWrapper$1 = styled__default.default.div`
     display: flex;
     flex-direction: ${(props) => props.isRange ? "column" : "row"};
     gap: ${(props) => props.isRange ? "none" : "0.5rem"};
 `;
-    const DateInput = styled__default.default.input`
+    const DateInput$1 = styled__default.default.input`
     display: flex;
     align-items: center;
 
     width: 8.5rem;
     height: 2.5rem;
     padding: 0 1rem;
 
@@ -36153,15 +36134,15 @@
     }
 
     ::-webkit-calendar-picker-indicator {
         display: none;
         background: none;
     }
 `;
-    const TimeInput = styled__default.default(Input$3)`
+    const TimeInput$1 = styled__default.default(Input$5)`
     width: ${(props) => props.isRange ? "8.5rem" : "5rem"};
     input {
         position: relative;
 
         display: flex;
         justify-content: center;
 
@@ -36193,137 +36174,137 @@
             width: 6rem;
 
             border-top: ${(props) => props.isRange ? `1px solid ${props.theme.colors.grey2}` : "none"};
         }
     }
 `;
 
-    function DatePickerHeader({
+    function DatePickerHeader$1({
         date,
         changeMonth,
         changeYear,
         decreaseMonth,
         increaseMonth,
         selectItemClass,
         portalsRef,
         minDate,
         maxDate
     }) {
-        const months = React.useMemo(() => getMonths(), []);
-        const years = React.useMemo(() => getYears(minDate, maxDate), [minDate, maxDate]);
+        const months = React.useMemo(() => getMonths$1(), []);
+        const years = React.useMemo(() => getYears$1(minDate, maxDate), [minDate, maxDate]);
         const selectedMonth = React.useMemo(() => {
             return {
                 label: enGB.localize.month(date.getMonth()),
                 value: date.getMonth()
             };
         }, [date]);
         const selectedYear = React.useMemo(() => ({
             label: date.getFullYear().toString(),
             value: date.getFullYear()
         }), [date]);
-        return jsxRuntime.exports.jsx(HeaderWrapper, {
-            children: jsxRuntime.exports.jsxs(DropdownsWrapper, {
-                children: [jsxRuntime.exports.jsx(MonthSelect, {
+        return jsxRuntime.exports.jsx(HeaderWrapper$1, {
+            children: jsxRuntime.exports.jsxs(DropdownsWrapper$1, {
+                children: [jsxRuntime.exports.jsx(MonthSelect$1, {
                     displacement: -1.1,
                     dropdownRef: (element2) => {
                         if (portalsRef) {
                             portalsRef.current[0] = element2;
                         }
                     },
-                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
+                    itemClass: `${IGNORE_CLASSNAME$1} ${selectItemClass}`,
                     items: months,
                     onSelect: (item) => changeMonth(item.value),
                     selectedItem: selectedMonth,
                     size: 0.875
-                }), jsxRuntime.exports.jsx(YearSelect, {
+                }), jsxRuntime.exports.jsx(YearSelect$1, {
                     displacement: -7.8,
                     dropdownRef: (element2) => {
                         if (portalsRef) {
                             portalsRef.current[1] = element2;
                         }
                     },
-                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
+                    itemClass: `${IGNORE_CLASSNAME$1} ${selectItemClass}`,
                     items: years,
                     onSelect: (item) => changeYear(item.value),
                     selectedItem: selectedYear,
                     size: 0.875
-                }), jsxRuntime.exports.jsxs(MonthNavigation, {
-                    children: [jsxRuntime.exports.jsx(MonthButton, {
+                }), jsxRuntime.exports.jsxs(MonthNavigation$1, {
+                    children: [jsxRuntime.exports.jsx(MonthButton$1, {
                         onClick: decreaseMonth,
                         styling: "ghost",
-                        children: jsxRuntime.exports.jsx(ChevronLeft, {})
-                    }), jsxRuntime.exports.jsx(MonthButton, {
+                        children: jsxRuntime.exports.jsx(ChevronLeft$1, {})
+                    }), jsxRuntime.exports.jsx(MonthButton$1, {
                         onClick: increaseMonth,
                         styling: "ghost",
-                        children: jsxRuntime.exports.jsx(ChevronRight, {})
+                        children: jsxRuntime.exports.jsx(ChevronRight$1, {})
                     })]
                 })]
             })
         });
     }
 
-    function getTimeFormatted(time) {
+    function getTimeFormatted$1(time) {
         const timeString = String(time);
         if (timeString.length > 1) {
             return timeString;
         }
         return `0${timeString}`;
     }
 
-    function getInitialTime(initialDate, isRange) {
+    function getInitialTime$1(initialDate, isRange) {
         if (!initialDate) {
             if (isRange) {
                 return ["00:00", "00:00"];
             }
             return "00:00";
         }
         if (Array.isArray(initialDate)) {
             return [
-                `${getTimeFormatted(initialDate[0].getHours())}:${getTimeFormatted(initialDate[0].getMinutes())}`,
-                `${getTimeFormatted(initialDate[1].getHours())}:${getTimeFormatted(initialDate[1].getMinutes())}`
+                `${getTimeFormatted$1(initialDate[0].getHours())}:${getTimeFormatted$1(initialDate[0].getMinutes())}`,
+                `${getTimeFormatted$1(initialDate[1].getHours())}:${getTimeFormatted$1(initialDate[1].getMinutes())}`
             ];
         }
-        return `${getTimeFormatted(initialDate.getHours())}:${getTimeFormatted(initialDate.getMinutes())}`;
+        return `${getTimeFormatted$1(initialDate.getHours())}:${getTimeFormatted$1(initialDate.getMinutes())}`;
     }
 
-    function getInitialDate(initialDate, formatToApply, isStart) {
+    function getInitialDate$1(initialDate, formatToApply, isStart) {
         let formattedDate = "";
         if (initialDate) {
             if (Array.isArray(initialDate)) {
                 formattedDate = format$2(initialDate[isStart ? 0 : 1], formatToApply);
             } else {
                 formattedDate = format$2(initialDate, formatToApply);
             }
         }
         return formattedDate;
     }
 
-    function getNewDatetime(date, time) {
+    function getNewDatetime$1(date, time) {
         var _a3, _b, _c, _d, _e2;
         if (!Array.isArray(date) && !Array.isArray(time)) {
             const [hours, minutes] = (_a3 = time === null || time === void 0 ? void 0 : time.split(":")) !== null && _a3 !== void 0 ? _a3 : ["00", "00"];
             const newDate = date ? new Date(date.setHours(Number(hours), Number(minutes))) : null;
             return newDate;
         }
         const [startHours, startMinutes] = (_c = (_b = time[0]) === null || _b === void 0 ? void 0 : _b.split(":")) !== null && _c !== void 0 ? _c : ["00", "00"];
         const [endHours, endMinutes] = (_e2 = (_d = time[1]) === null || _d === void 0 ? void 0 : _d.split(":")) !== null && _e2 !== void 0 ? _e2 : ["00", "00"];
         const dates = date;
         const startDate = dates[0] ? new Date(dates[0].setHours(Number(startHours), Number(startMinutes))) : null;
         const endDate = dates[1] ? new Date(dates[1].setHours(Number(endHours), Number(endMinutes))) : null;
         return [startDate, endDate];
     }
 
-    function DatePicker(props) {
+    function DatePicker$1(props) {
         var _a3, _b, _c;
         const value = (_a3 = props.value) !== null && _a3 !== void 0 ? _a3 : props.initialValue;
         const [selectedDate, setSelectedDate] = React.useState(value || (props.selectsRange ? [null, null] : null));
-        const [selectedTime, setSelectedTime] = React.useState(() => getInitialTime(value, props.selectsRange));
+        const [selectedTime, setSelectedTime] = React.useState(() => getInitialTime$1(value, props.selectsRange));
         const formatToApply = (_b = props.dateFormat) !== null && _b !== void 0 ? _b : "dd/MM/yyyy";
-        const [startDate, setStartDate] = React.useState(() => getInitialDate(value, formatToApply, true));
-        const [endDate, setEndDate] = React.useState(() => getInitialDate(value, formatToApply, false));
+        const [startDate, setStartDate] = React.useState(() => getInitialDate$1(value, formatToApply, true));
+        const [endDate, setEndDate] = React.useState(() => getInitialDate$1(value, formatToApply, false));
         const [isSelectingStart, setIsSelectingStart] = React.useState(null);
         const selectedDateRef = React.useRef(selectedDate);
         selectedDateRef.current = selectedDate;
         const datepickerRef = React.useRef(null);
         const extraProps = React.useMemo(() => {
             if (props.selectsRange) {
                 const selectedDates = selectedDate !== null && selectedDate !== void 0 ? selectedDate : [null, null];
@@ -36371,15 +36352,15 @@
                 setSelectedDate(date);
                 setStartDate(format$2(date, formatToApply));
             }
         };
         const onChangeDateInput = (isStartDate, e3) => {
             var _a4;
             const target = e3.target;
-            const newDate = parse$a(target.value, formatToApply, new Date());
+            const newDate = parse$9(target.value, formatToApply, new Date());
             if (newDate instanceof Date && !Number.isNaN(newDate.valueOf()) && !(newDate < props.minDate) && !(newDate > props.maxDate)) {
                 (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setState({
                     preSelection: newDate
                 });
                 if (Array.isArray(selectedDate)) {
                     if (isStartDate) {
                         let end2 = selectedDate[1];
@@ -36425,44 +36406,44 @@
             var _a4;
             const newValue = (_a4 = props.value) !== null && _a4 !== void 0 ? _a4 : props.initialValue;
             const newDate = newValue || (props.selectsRange ? [null, null] : null);
             if (JSON.stringify(newDate) === JSON.stringify(selectedDateRef.current)) {
                 return;
             }
             setSelectedDate(newDate);
-            const newTime = getInitialTime(newValue, props.selectsRange);
+            const newTime = getInitialTime$1(newValue, props.selectsRange);
             setSelectedTime(newTime);
-            const newStartDate = getInitialDate(newValue, formatToApply, true);
+            const newStartDate = getInitialDate$1(newValue, formatToApply, true);
             setStartDate(newStartDate);
-            const newEndDate = getInitialDate(newValue, formatToApply, false);
+            const newEndDate = getInitialDate$1(newValue, formatToApply, false);
             setEndDate(newEndDate);
         }, [props.value, props.initialValue]);
         React.useEffect(() => {
             var _a4;
             let time = selectedTime;
             if (props.selectsRange && !Array.isArray(selectedTime)) {
                 time = [selectedTime, "00:00"];
                 setSelectedTime([selectedTime, "00:00"]);
             }
-            const newDateTime = getNewDatetime(selectedDate, time);
+            const newDateTime = getNewDatetime$1(selectedDate, time);
             (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, newDateTime);
         }, [selectedDate, selectedTime]);
         return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-            children: jsxRuntime.exports.jsx(Tooltip$1, {
+            children: jsxRuntime.exports.jsx(Tooltip$2, {
                 content: props.errorMsg,
                 disabled: !props.errorMsg,
                 styling: "error",
-                children: jsxRuntime.exports.jsxs(DatepickerWrapper$1, {
+                children: jsxRuntime.exports.jsxs(DatepickerWrapper$3, {
                     inline: props.inline,
                     showsRange: props.selectsRange,
                     showsTime: props.showTimeInput,
-                    children: [jsxRuntime.exports.jsxs(DatepickerInputs, {
-                        children: [jsxRuntime.exports.jsxs(DateTimeWrapper, {
+                    children: [jsxRuntime.exports.jsxs(DatepickerInputs$1, {
+                        children: [jsxRuntime.exports.jsxs(DateTimeWrapper$1, {
                             isRange: props.selectsRange,
-                            children: [jsxRuntime.exports.jsx(DateInput, {
+                            children: [jsxRuntime.exports.jsx(DateInput$1, {
                                 isTimeRange: props.selectsRange && props.showTimeInput,
                                 onChange: (e3) => {
                                     onChangeDateInput(true, e3);
                                 },
                                 onClick: () => {
                                     var _a4;
                                     setIsSelectingStart(true);
@@ -36475,26 +36456,26 @@
                                 },
                                 onKeyDown: (e3) => {
                                     var _a4;
                                     (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
                                 },
                                 placeholder: formatToApply,
                                 value: startDate
-                            }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
+                            }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput$1, {
                                 isRange: props.selectsRange,
                                 onChange: (e3) => {
                                     onChangeTime(e3, true);
                                 },
                                 type: "time",
                                 value: Array.isArray(selectedTime) ? selectedTime[0] : selectedTime
                             })]
-                        }), props.selectsRange && jsxRuntime.exports.jsxs(EndDateInputWrapper, {
-                            children: ["\u2192", jsxRuntime.exports.jsxs(DateTimeWrapper, {
+                        }), props.selectsRange && jsxRuntime.exports.jsxs(EndDateInputWrapper$1, {
+                            children: ["\u2192", jsxRuntime.exports.jsxs(DateTimeWrapper$1, {
                                 isRange: true,
-                                children: [jsxRuntime.exports.jsx(DateInput, {
+                                children: [jsxRuntime.exports.jsx(DateInput$1, {
                                     isTimeRange: props.showTimeInput,
                                     onChange: (e3) => {
                                         onChangeDateInput(false, e3);
                                     },
                                     onClick: () => {
                                         var _a4;
                                         setIsSelectingStart(false);
@@ -36507,15 +36488,15 @@
                                     },
                                     onKeyDown: (e3) => {
                                         var _a4;
                                         (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
                                     },
                                     placeholder: formatToApply,
                                     value: endDate
-                                }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
+                                }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput$1, {
                                     isRange: true,
                                     onChange: (e3) => {
                                         onChangeTime(e3, false);
                                     },
                                     type: "time",
                                     value: selectedTime[1]
                                 })]
@@ -36532,15 +36513,15 @@
                         selectsEnd: !isSelectingStart,
                         selectsStart: isSelectingStart,
                         shouldCloseOnSelect: props.shouldCloseOnSelect
                     }, extraProps, {
                         popperProps: {
                             strategy: (_c = props.popperStrategy) !== null && _c !== void 0 ? _c : "absolute"
                         },
-                        renderCustomHeader: (headerProps) => jsxRuntime.exports.jsx(DatePickerHeader, Object.assign({}, headerProps, {
+                        renderCustomHeader: (headerProps) => jsxRuntime.exports.jsx(DatePickerHeader$1, Object.assign({}, headerProps, {
                             maxDate: props.maxDate,
                             minDate: props.minDate,
                             portalsRef: props.portalsRef,
                             selectItemClass: props.selectItemClass
                         }))
                     }))]
                 })
@@ -36755,15 +36736,15 @@
                     }, function(err) {
                         reject(err);
                     });
                 })];
             });
         });
     }
-    var _default$1 = function(file, acceptedFiles) {
+    var _default$2 = function(file, acceptedFiles) {
         if (file && acceptedFiles) {
             var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
             var fileName = file.name || "";
             var mimeType = (file.type || "").toLowerCase();
             var baseMimeType = mimeType.replace(/\/.*$/, "");
             return acceptedFilesArray.some(function(type2) {
                 var validType = type2.trim().toLowerCase();
@@ -36845,15 +36826,15 @@
     };
     var TOO_MANY_FILES_REJECTION = {
         code: TOO_MANY_FILES,
         message: "Too many files"
     };
 
     function fileAccepted(file, accept) {
-        var isAcceptable = file.type === "application/x-moz-file" || _default$1(file, accept);
+        var isAcceptable = file.type === "application/x-moz-file" || _default$2(file, accept);
         return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
     }
 
     function fileMatchSize(file, minSize, maxSize) {
         if (isDefined(file.size)) {
             if (isDefined(minSize) && isDefined(maxSize)) {
                 if (file.size > maxSize)
@@ -37052,15 +37033,15 @@
         }
         return obj;
     }
 
     function _objectWithoutProperties$1(source, excluded) {
         if (source == null)
             return {};
-        var target = _objectWithoutPropertiesLoose$1(source, excluded);
+        var target = _objectWithoutPropertiesLoose$2(source, excluded);
         var key, i2;
         if (Object.getOwnPropertySymbols) {
             var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
             for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
                 key = sourceSymbolKeys[i2];
                 if (excluded.indexOf(key) >= 0)
                     continue;
@@ -37068,15 +37049,15 @@
                     continue;
                 target[key] = source[key];
             }
         }
         return target;
     }
 
-    function _objectWithoutPropertiesLoose$1(source, excluded) {
+    function _objectWithoutPropertiesLoose$2(source, excluded) {
         if (source == null)
             return {};
         var target = {};
         var sourceKeys = Object.keys(source);
         var key, i2;
         for (i2 = 0; i2 < sourceKeys.length; i2++) {
             key = sourceKeys[i2];
@@ -37621,43 +37602,43 @@
         margin-right: 0.1rem;
 
         vertical-align: top;
 
         border-bottom: thin solid ${(props) => props.theme.colors.grey6};
     }
 `;
-    const Cell$1 = styled__default.default.span`
+    const Cell$2 = styled__default.default.span`
     cursor: ${(props) => props.selectionAllowed ? "pointer" : "normal"};
     font-weight: ${(props) => props.isLeaf ? 300 : 400};
     color: ${(props) => {
     if (props.selected) {
       return props.theme.colors.primary;
     }
     return props.isLeaf ? props.theme.colors.grey6 : props.theme.colors.grey5;
   }};
 `;
-    const CircleIcon = styled__default.default(Circle$1)`
+    const CircleIcon = styled__default.default(Circle$2)`
     width: 0.5rem;
     height: 0.5rem;
     margin-right: 0.4rem;
 
     color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey6};
     vertical-align: middle;
 `;
-    const grow = styled.keyframes`
+    const grow$1 = styled.keyframes`
     0% {
         transform: scaleY(0);
         opacity: 0;
     }
     100% {
         transform: scaleY(1);
         opacity: 1;
     }
 `;
-    const contract = styled.keyframes`
+    const contract$1 = styled.keyframes`
     100% {
         transform: scaleY(1);
         opacity: 1;
     }
     0% {
         transform: scaleY(0);
         opacity: 0;
@@ -37672,22 +37653,22 @@
     margin-left: 1rem;
     padding: 0;
     padding-bottom: 1rem;
 
     list-style: none;
 
     animation: ${(props) => props.open ? styled.css`
-                  ${grow} 300ms ease-out forwards
+                  ${grow$1} 300ms ease-out forwards
               ` : styled.css`
-                  ${contract} 300ms ease-in forwards
+                  ${contract$1} 300ms ease-in forwards
               `};
 `;
 
     function Branch(props) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [open, setOpen] = React.useState(props.open || false);
         const toggle = () => {
             if (props.content) {
                 setOpen(!open);
             }
         };
         const select = () => {
@@ -37695,21 +37676,21 @@
         };
         const selectionAllowed = props.allowSelectCategory && props.content.children && props.content.children.length > 0 || props.allowSelectLeaf && (!props.content.children || props.content.children.length === 0);
         return jsxRuntime.exports.jsxs(NodeContent, {
             className: props.className,
             style: props.style,
             children: [jsxRuntime.exports.jsx(CircleIcon, {
                 selected: props.content.id === props.selectedNodeId
-            }), jsxRuntime.exports.jsx(Cell$1, {
+            }), jsxRuntime.exports.jsx(Cell$2, {
                 isLeaf: !props.content.children || props.content.children.length === 0,
                 onClick: selectionAllowed ? select : toggle,
                 selected: props.content.id === props.selectedNodeId,
                 selectionAllowed,
                 children: props.content.label
-            }), props.content.children && props.content.children.length > 0 && jsxRuntime.exports.jsx(Chevron$2, {
+            }), props.content.children && props.content.children.length > 0 && jsxRuntime.exports.jsx(Chevron$4, {
                 isOpen: open,
                 onClick: toggle,
                 style: {
                     color: theme2.colors.grey5,
                     cursor: "pointer",
                     height: "0.8rem",
                     marginLeft: "0.5rem",
@@ -37725,24 +37706,24 @@
                     selectCategory: props.selectCategory,
                     selectNode: props.selectNode,
                     selectedNodeId: props.selectedNodeId
                 }, nodeObj.id))
             })]
         });
     }
-    const Wrapper$8 = styled__default.default.div`
+    const Wrapper$e = styled__default.default.div`
     overflow: scroll;
 `;
     const Root = styled__default.default.div`
     cursor: pointer;
     margin-left: 1rem;
 `;
 
     function HierarchySelector$1(props) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [rootOpen, setRootOpen] = React.useState(props.rootOpen || false);
         const [selectedNodeId, setSelectedNodeId] = React.useState(props.selected);
         React.useEffect(() => {
             if (props.selected) {
                 setSelectedNodeId(props.selected);
             }
         }, [props.selected]);
@@ -37755,25 +37736,25 @@
             (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, nodeId);
         };
         const {
             label,
             id: id2,
             children: children2
         } = props.rootNode;
-        return jsxRuntime.exports.jsxs(Wrapper$8, {
+        return jsxRuntime.exports.jsxs(Wrapper$e, {
             className: props.className,
             style: props.style,
             children: [jsxRuntime.exports.jsxs(Root, {
                 children: [jsxRuntime.exports.jsx(CircleIcon, {
                     selected: id2 === selectedNodeId
-                }), jsxRuntime.exports.jsx(Cell$1, {
+                }), jsxRuntime.exports.jsx(Cell$2, {
                     onClick: props.allowSelectCategory || children2.length === 0 ? () => selectNode(id2) : toggle,
                     selected: id2 === selectedNodeId,
                     children: label
-                }), children2.length > 0 && jsxRuntime.exports.jsx(Chevron$2, {
+                }), children2.length > 0 && jsxRuntime.exports.jsx(Chevron$4, {
                     isOpen: rootOpen,
                     onClick: toggle,
                     style: {
                         color: theme2.colors.grey5,
                         cursor: "pointer",
                         height: "0.8rem",
                         marginLeft: "0.5rem",
@@ -37790,15 +37771,15 @@
                     open: rootOpen,
                     selectNode,
                     selectedNodeId
                 }, nodeObj.id))
             })]
         });
     }
-    const Background$1 = styled__default.default.div`
+    const Background$2 = styled__default.default.div`
     position: fixed;
     z-index: 2000;
     top: 0;
     left: 0;
 
     display: flex;
     align-items: center;
@@ -37808,15 +37789,15 @@
     height: 100%;
 
     opacity: ${(props) => props.render ? 1 : 0};
     background-color: ${(props) => props.theme.colors.modalBg};
 
     transition: opacity ease-in 0.1s;
 `;
-    const ModalWrapper = styled__default.default.div`
+    const ModalWrapper$1 = styled__default.default.div`
     overflow: hidden;
     display: inline-flex;
     flex-direction: column;
 
     min-width: 20rem;
     max-width: 80vw;
     min-height: 10rem;
@@ -37843,25 +37824,25 @@
     flex: 0 0 auto;
     flex-direction: ${(props) => props.flexDirection || "column"};
     justify-content: space-between;
 
     margin-bottom: 1rem;
 `;
 
-    function Modal$1(props) {
+    function Modal$2(props) {
         var _a3;
         const [mounted, setMounted] = React.useState(false);
         const [renderModal, setRenderModal] = React.useState(false);
         React.useEffect(() => {
             setRenderModal(props.render);
         }, [props.render]);
         React.useEffect(() => {
             if (renderModal) {
                 const keyHandler = (e3) => {
-                    if (e3.key === Key.ESCAPE && props.onAttemptClose) {
+                    if (e3.key === Key$1.ESCAPE && props.onAttemptClose) {
                         props.onAttemptClose();
                     }
                 };
                 document.addEventListener("keydown", keyHandler);
                 return () => {
                     document.removeEventListener("keydown", keyHandler);
                 };
@@ -37875,62 +37856,62 @@
             if (!props.render && props.onClosed) {
                 props.onClosed();
             }
         };
         const stopPropagation = (e3) => {
             e3.stopPropagation();
         };
-        return ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(Background$1, {
+        return ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(Background$2, {
             id: props.id,
             onClick: props.onAttemptClose,
             onTransitionEnd,
             render: renderModal,
-            children: jsxRuntime.exports.jsx(ModalWrapper, {
+            children: jsxRuntime.exports.jsx(ModalWrapper$1, {
                 className: `cl-modal-content ${(_a3 = props.className) !== null && _a3 !== void 0 ? _a3 : ""}`,
                 onClick: stopPropagation,
                 render: renderModal,
                 style: props.style,
                 children: props.children
             })
         }), document.body);
     }
-    var __rest$9 = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$f = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
     const {
-        stateChangeTypes: stateChangeTypes$1
+        stateChangeTypes: stateChangeTypes$3
     } = useCombobox;
-    const tagHeight = 2;
-    const tagTopMargin = 0.5;
-    const Wrapper$7 = styled__default.default.div`
+    const tagHeight$1 = 2;
+    const tagTopMargin$1 = 0.5;
+    const Wrapper$d = styled__default.default.div`
     display: inline-flex;
     ${(props) => {
     if (props.isDisabled) {
       return `
                 cursor: not-allowed;
             `;
     }
   }}
 
     width: 100%;
     max-width: ${(props) => props.maxWidth};
-    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin)}rem;
+    max-height: ${(props) => props.maxRows * (tagHeight$1 + tagTopMargin$1)}rem;
 
     border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
 `;
-    const InputWrapper$3 = styled__default.default.div`
+    const InputWrapper$7 = styled__default.default.div`
     display: flex;
     flex: 1 1 auto;
     align-items: center;
     justify-content: space-between;
 
     width: 100%;
     min-width: 10rem;
@@ -37978,15 +37959,15 @@
             props.theme.colors.grey3
         };
 
     }
     `;
   }}
 `;
-    const Input$1 = styled__default.default.input`
+    const Input$3 = styled__default.default.input`
     overflow: hidden;
     flex: 1 1 auto;
 
     margin-right: 0.5rem;
     padding: 0rem;
 
     font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
@@ -38009,22 +37990,22 @@
     display: flex;
     flex-wrap: wrap;
     gap: 0.5rem;
     align-items: center;
 
     width: 100%;
     height: 100%;
-    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin) - 0.25}rem;
+    max-height: ${(props) => props.maxRows * (tagHeight$1 + tagTopMargin$1) - 0.25}rem;
 `;
     const Tag$1 = styled__default.default.span`
     overflow: hidden;
     display: flex;
     align-items: center;
 
-    height: ${tagHeight}rem;
+    height: ${tagHeight$1}rem;
     padding: 0 0.75rem;
 
     font-size: 0.875rem;
     color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
 
     background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue3};
     border: 1px solid ${(props) => props.theme.colors.primary};
@@ -38042,56 +38023,56 @@
     }
 `;
     const TagText = styled__default.default.span`
     overflow: hidden;
     text-overflow: ellipsis;
     white-space: nowrap;
 `;
-    const NoItemsLabel = styled__default.default.span`
+    const NoItemsLabel$1 = styled__default.default.span`
     display: flex;
     flex: 1 1 auto;
     align-items: center;
     justify-content: center;
 
     height: 2rem;
 
     font-size: 1rem;
     color: ${(props) => props.theme.colors.grey4};
 
     background-color: ${(props) => props.theme.colors.blue1};
 `;
-    const DropdownList$1 = styled__default.default(List)`
+    const DropdownList$3 = styled__default.default(List$1)`
     border-radius: 0px 0px 0.25rem 0.25rem;
     outline: 0;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
-    const ChevronButton = styled__default.default(Button$3).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
+    const ChevronButton$1 = styled__default.default(Button$5).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
         styling: "ghost"
     }))`
     min-width: 0;
     height: auto;
     margin: 0;
     padding: 0 0.25rem;
 
     background-color: transparent !important;
 `;
 
     function MultiSelect(_a3) {
         var _b, _c;
         var {
             maxWidth = "100%", maxRows = 3
-        } = _a3, props = __rest$9(_a3, ["maxWidth", "maxRows"]);
+        } = _a3, props = __rest$f(_a3, ["maxWidth", "maxRows"]);
         const referenceElement = React.useRef(null);
         const popperElement = React.useRef(null);
         const {
             styles: styles2,
             attributes: attributes2,
             update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
+        } = usePopper$2(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier$1],
             placement: "bottom-start"
         });
         const [inputValue, setInputValue] = React.useState("");
         const {
             getSelectedItemProps,
             getDropdownProps,
             addSelectedItem,
@@ -38136,34 +38117,34 @@
             itemToString: (item) => (item === null || item === void 0 ? void 0 : item.label) || "",
             items: filteredItems,
             onStateChange: ({
                 inputValue: internalInputVal,
                 selectedItem,
                 type: type2
             }) => {
-                if (type2 === stateChangeTypes$1.InputChange) {
+                if (type2 === stateChangeTypes$3.InputChange) {
                     onTermChange(internalInputVal);
                 }
                 if ([
-                        stateChangeTypes$1.InputKeyDownEnter,
-                        stateChangeTypes$1.ItemClick,
-                        stateChangeTypes$1.InputBlur
+                        stateChangeTypes$3.InputKeyDownEnter,
+                        stateChangeTypes$3.ItemClick,
+                        stateChangeTypes$3.InputBlur
                     ].includes(type2)) {
                     if (selectedItem) {
                         onTermChange("");
                         addSelectedItem(selectedItem);
                     }
                 }
             },
             selectedItem: null,
             stateReducer: (state, {
                 changes,
                 type: type2
             }) => {
-                if (type2 === stateChangeTypes$1.ItemClick || type2 === stateChangeTypes$1.InputKeyDownEnter) {
+                if (type2 === stateChangeTypes$3.ItemClick || type2 === stateChangeTypes$3.InputKeyDownEnter) {
                     return Object.assign(Object.assign({}, changes), {
                         isOpen: true
                     });
                 }
                 return changes;
             }
         });
@@ -38175,111 +38156,111 @@
         const menuProps = getMenuProps();
         const setMenuRef = menuProps.ref;
         delete menuProps.ref;
         const setMenuReference = (value) => {
             setMenuRef(value);
             popperElement.current = value;
         };
-        return jsxRuntime.exports.jsxs(Wrapper$7, {
+        return jsxRuntime.exports.jsxs(Wrapper$d, {
             className: props.className,
             isDisabled: props.disabled,
             isOpen,
             maxRows,
             maxWidth,
             style: props.style,
-            children: [jsxRuntime.exports.jsx(Tooltip$1, {
+            children: [jsxRuntime.exports.jsx(Tooltip$2, {
                 content: props.errorMsg,
                 disabled: !props.errorMsg,
                 styling: "error",
-                children: jsxRuntime.exports.jsxs(InputWrapper$3, {
+                children: jsxRuntime.exports.jsxs(InputWrapper$7, {
                     isDisabled: props.disabled,
                     isOpen,
                     ref: referenceElement,
                     children: [jsxRuntime.exports.jsxs(TagWrapper, {
                         maxRows,
                         children: [selectedItems.map((selectedItem, index2) => jsxRuntime.exports.jsxs(Tag$1, Object.assign({
                             disabled: props.disabled
                         }, getSelectedItemProps({
                             index: index2,
                             selectedItem
                         }), {
                             children: [jsxRuntime.exports.jsx(TagText, {
                                 children: selectedItem.label
-                            }), jsxRuntime.exports.jsx(Cross$1, {
+                            }), jsxRuntime.exports.jsx(Cross$2, {
                                 asButton: true,
                                 onClick: (e3) => {
                                     e3.stopPropagation();
                                     return removeSelectedItem(selectedItem);
                                 }
                             })]
-                        }), selectedItem.value)), jsxRuntime.exports.jsx(Input$1, Object.assign({}, getInputProps(getDropdownProps({
+                        }), selectedItem.value)), jsxRuntime.exports.jsx(Input$3, Object.assign({}, getInputProps(getDropdownProps({
                             preventKeyAction: isOpen
                         })), {
                             disabled: props.disabled,
                             onFocus: openMenu,
                             placeholder: props.placeholder,
                             size: props.size,
                             style: {
                                 flex: "1 1 5ch"
                             }
                         }))]
-                    }), jsxRuntime.exports.jsx(ChevronButton, Object.assign({}, getToggleButtonProps(), {
-                        children: jsxRuntime.exports.jsx(Chevron$2, {
+                    }), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
+                        children: jsxRuntime.exports.jsx(Chevron$4, {
                             disabled: props.disabled,
                             isOpen
                         })
                     }))]
                 })
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$1, Object.assign({}, menuProps, attributes2.popper, {
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(DropdownList$3, Object.assign({}, menuProps, attributes2.popper, {
                 isOpen,
                 ref: setMenuReference,
                 style: Object.assign(Object.assign({}, styles2.popper), {
                     width: parseFloat((_c = styles2.popper) === null || _c === void 0 ? void 0 : _c.width),
                     zIndex: 9999
                 }),
-                children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem, Object.assign({}, getItemProps({
+                children: [filteredItems.length > 0 && filteredItems.map((item, index2) => React.createElement(ListItem$1, Object.assign({}, getItemProps({
                     index: index2,
                     item
                 }), {
                     hovered: index2 === highlightedIndex,
                     key: `item-${index2}`,
                     size: props.size,
                     title: item.label
-                }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel, {
+                }), item.label)), filteredItems.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
                     children: "No Items"
                 })]
             })), document.body)]
         });
     }
-    var __rest$8 = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$e = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
-    const SelectedItem = styled__default.default.div`
+    const SelectedItem$2 = styled__default.default.div`
     overflow: hidden;
 
     /* The space available is that of the wrapper minus of the chevron */
     width: calc(100% - 1rem);
     margin-right: 0.5rem;
 
     font-size: ${(props) => props.size ? `${props.size}rem` : "1rem"};
     font-weight: 300;
     text-align: left;
     text-overflow: ellipsis;
     white-space: nowrap;
 `;
-    const Wrapper$6 = styled__default.default.div`
+    const Wrapper$c = styled__default.default.div`
     display: inline-flex;
 
     width: 100%;
     min-width: 4rem;
     height: 2.5rem;
 
     border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
@@ -38306,15 +38287,15 @@
             props.theme.colors.grey3
         };
 
     }
     `;
   }}
 `;
-    const SelectButton = styled__default.default.button`
+    const SelectButton$2 = styled__default.default.button`
     display: inline-flex;
     flex: 1 1 auto;
     align-items: center;
     justify-content: space-between;
 
     width: 100%;
     height: 100%;
@@ -38346,31 +38327,31 @@
     }
 
     svg {
         width: 1rem !important;
         height: 0.8rem;
     }
 `;
-    const DropdownList = styled__default.default(List)`
+    const DropdownList$2 = styled__default.default(List$1)`
     margin-left: -1px;
     border-radius: 0px 0px 0.25rem 0.25rem;
     outline: 0;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
 
-    function Select$1(props) {
+    function Select$2(props) {
         var _a3, _b, _c, _d, _e2, _f;
         const referenceElement = React.useRef(null);
         const popperElement = React.useRef(null);
         const {
             styles: styles2,
             attributes: attributes2,
             update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: props.applySameWidthModifier === false ? [] : [sameWidthModifier],
+        } = usePopper$2(referenceElement.current, popperElement.current, {
+            modifiers: props.applySameWidthModifier === false ? [] : [sameWidthModifier$1],
             placement: props.placement || "bottom-start"
         });
         const {
             isOpen,
             selectedItem,
             getToggleButtonProps,
             getMenuProps,
@@ -38408,39 +38389,39 @@
         delete menuProps.ref;
         const setMenuReference = (value) => {
             var _a4;
             setMenuRef(value);
             popperElement.current = value;
             (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
         };
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: props.errorMsg,
             disabled: !props.errorMsg,
             styling: "error",
-            children: jsxRuntime.exports.jsxs(Wrapper$6, {
+            children: jsxRuntime.exports.jsxs(Wrapper$c, {
                 className: props.className,
                 isDisabled: props.disabled,
                 isErrored: !!props.errorMsg,
                 isOpen,
                 onClick: props.onClick,
                 style: props.style,
-                children: [jsxRuntime.exports.jsxs(SelectButton, Object.assign({
+                children: [jsxRuntime.exports.jsxs(SelectButton$2, Object.assign({
                     disabled: props.disabled,
                     isOpen
                 }, buttonProps, {
                     ref: setButtonReference,
                     type: "button",
-                    children: [jsxRuntime.exports.jsx(SelectedItem, {
+                    children: [jsxRuntime.exports.jsx(SelectedItem$2, {
                         size: props.size,
                         children: (_b = (_a3 = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _a3 !== void 0 ? _a3 : props.placeholder) !== null && _b !== void 0 ? _b : "Select"
-                    }), jsxRuntime.exports.jsx(Chevron$2, {
+                    }), jsxRuntime.exports.jsx(Chevron$4, {
                         disabled: props.disabled,
                         isOpen
                     })]
-                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList, Object.assign({}, menuProps, attributes2.popper, {
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$2, Object.assign({}, menuProps, attributes2.popper, {
                     className: `${(_c = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _c !== void 0 ? _c : ""} ${(_e2 = (_d = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _d === void 0 ? void 0 : _d.className) !== null && _e2 !== void 0 ? _e2 : ""} ${props.itemClass}`,
                     isOpen,
                     maxItems: props.maxItems,
                     ref: setMenuReference,
                     style: Object.assign(Object.assign({}, styles2.popper), {
                         width: props.applySameWidthModifier === false ? void 0 : parseFloat((_f = styles2.popper) === null || _f === void 0 ? void 0 : _f.width) + 2,
                         zIndex: 9999
@@ -38449,49 +38430,49 @@
                         const _a4 = getItemProps({
                                 index: index2,
                                 item
                             }),
                             {
                                 itemClassName
                             } = _a4,
-                            itemProps = __rest$8(_a4, ["itemClassName"]);
-                        return React.createElement(ListItem, Object.assign({}, itemProps, {
+                            itemProps = __rest$e(_a4, ["itemClassName"]);
+                        return React.createElement(ListItem$1, Object.assign({}, itemProps, {
                             className: `${itemClassName} ${props.itemClass}`,
                             hovered: index2 === highlightedIndex,
                             key: `item-${index2}`,
                             size: props.size,
                             title: item.label
                         }), item.label);
                     })
                 })), document.body)]
             })
         });
     }
-    const StyledSelect$2 = styled__default.default(Select$1)`
+    const StyledSelect$4 = styled__default.default(Select$2)`
     margin: 1px solid ${(props) => props.theme.colors.background};
     button {
         background-color: ${(props) => props.theme.colors.background};
 
         :hover:enabled {
             background-color: ${(props) => props.theme.colors.background};
         }
     }
 `;
-    const InputsWrapper = styled__default.default.div`
+    const InputsWrapper$1 = styled__default.default.div`
     display: flex;
     gap: 5px;
     align-items: center;
 `;
-    const FilterHeader = styled__default.default.div`
+    const FilterHeader$1 = styled__default.default.div`
     display: flex;
     flex-direction: column;
     gap: 0.25rem;
     padding: 0rem 0.5rem;
 `;
-    const StyledInput$3 = styled__default.default(Input$3)`
+    const StyledInput$4 = styled__default.default(Input$5)`
     width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
     input {
         width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
         background-color: ${(props) => props.theme.colors.background};
         border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.background};
 
         :hover:not(:disabled) {
@@ -38501,20 +38482,20 @@
 
         :active:not(:disabled),
         :focus:not(:disabled) {
             border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
         }
     }
 `;
-    const ErrorMessage = styled__default.default.span`
+    const ErrorMessage$2 = styled__default.default.span`
     user-select: none;
     font-size: 0.7rem;
     color: ${(props) => props.theme.colors.error};
 `;
-    const NumericFilterItems = [{
+    const NumericFilterItems$1 = [{
         label: "None",
         value: "None"
     }, {
         label: "Greater than",
         value: "Greater than"
     }, {
         label: "Less than",
@@ -38526,15 +38507,15 @@
         label: "Not equal to",
         value: "Not equal to"
     }, {
         label: "Between",
         value: "Between"
     }];
 
-    function NumericFilter(props) {
+    function NumericFilter$1(props) {
         const [selected, setSelected] = React.useState(null);
         const [firstInput, setFirstInput] = React.useState(null);
         const [secondInput, setSecondInput] = React.useState(null);
         const filteredValues = React.useMemo(() => {
             if ((selected === null || selected === void 0 ? void 0 : selected.label) === "None") {
                 return {
                     selected: selected === null || selected === void 0 ? void 0 : selected.label,
@@ -38567,72 +38548,72 @@
                 return true;
             }
             if (secondInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
                 return true;
             }
             return false;
         }, [props.disabled, firstInput, secondInput, previousFilter, filteredValues, showError, selected]);
-        return jsxRuntime.exports.jsxs(FilterWrapper, {
+        return jsxRuntime.exports.jsxs(FilterWrapper$1, {
             className: props.className,
-            children: [jsxRuntime.exports.jsxs(FilterHeader, {
-                children: [jsxRuntime.exports.jsx(StyledSelect$2, {
+            children: [jsxRuntime.exports.jsxs(FilterHeader$1, {
+                children: [jsxRuntime.exports.jsx(StyledSelect$4, {
                     dropdownRef: (element2) => {
                         if (props.portalsRef) {
                             props.portalsRef.current[0] = element2;
                         }
                     },
                     initialValue: {
                         label: "None",
                         value: "None"
                     },
-                    items: NumericFilterItems,
+                    items: NumericFilterItems$1,
                     maxItems: 6,
                     onSelect: setSelected
-                }), selected && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None" && jsxRuntime.exports.jsxs(InputsWrapper, {
-                    children: [jsxRuntime.exports.jsx(StyledInput$3, {
+                }), selected && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None" && jsxRuntime.exports.jsxs(InputsWrapper$1, {
+                    children: [jsxRuntime.exports.jsx(StyledInput$4, {
                         onChange: (v2) => setFirstInput(Number(v2)),
                         showError,
                         showTwoInputs: (selected === null || selected === void 0 ? void 0 : selected.label) === "Between",
                         type: "number"
-                    }), (selected === null || selected === void 0 ? void 0 : selected.label) === "Between" && jsxRuntime.exports.jsxs(InputsWrapper, {
-                        children: ["and", jsxRuntime.exports.jsx(StyledInput$3, {
+                    }), (selected === null || selected === void 0 ? void 0 : selected.label) === "Between" && jsxRuntime.exports.jsxs(InputsWrapper$1, {
+                        children: ["and", jsxRuntime.exports.jsx(StyledInput$4, {
                             onChange: (v2) => setSecondInput(Number(v2)),
                             showError,
                             type: "number",
                             value: String(secondInput)
                         })]
                     })]
                 })]
-            }), showError && jsxRuntime.exports.jsx(ErrorMessage, {
+            }), showError && jsxRuntime.exports.jsx(ErrorMessage$2, {
                 children: "Input range not valid"
-            }), jsxRuntime.exports.jsx(ApplyButton, {
+            }), jsxRuntime.exports.jsx(ApplyButton$1, {
                 disabled: disableApply,
                 onClick: (e3) => {
                     var _a3, _b;
                     (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
                     (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
                     setPreviousFilter(filteredValues);
                 },
                 children: "Apply"
             })]
         });
     }
-    const StepperWrapper = styled__default.default.div`
+    const StepperWrapper$1 = styled__default.default.div`
     cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
 
     display: flex;
     flex-direction: column;
     justify-content: space-around;
 
     box-sizing: border-box;
     padding: 0.25rem 0rem;
 
     border-radius: 0rem 0.25rem 0.25rem 0rem;
 `;
-    const StepperButton = styled__default.default(Button$3)`
+    const StepperButton$1 = styled__default.default(Button$5)`
     min-width: 0.75rem;
     height: max-content;
     padding: 0;
     background-color: transparent !important;
 
     svg {
         cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
@@ -38649,40 +38630,40 @@
 
     :active:not(:disabled) {
         svg {
             transform: scale(0.75);
         }
     }
 `;
-    const InputStepper = ({
+    const InputStepper$1 = ({
         disabled: disabled2,
         step: step2,
         stepSkip
     }) => {
         const amountToStep = Math.abs(stepSkip !== null && stepSkip !== void 0 ? stepSkip : 1);
         const stepUp = () => step2(amountToStep);
         const stepDown = () => step2(amountToStep * -1);
-        return jsxRuntime.exports.jsxs(StepperWrapper, {
+        return jsxRuntime.exports.jsxs(StepperWrapper$1, {
             disabled: disabled2,
-            children: [jsxRuntime.exports.jsx(StepperButton, {
+            children: [jsxRuntime.exports.jsx(StepperButton$1, {
                 disabled: disabled2,
                 onClick: stepUp,
                 styling: "ghost",
                 tabIndex: -1,
-                children: jsxRuntime.exports.jsx(ChevronUp, {})
-            }), jsxRuntime.exports.jsx(StepperButton, {
+                children: jsxRuntime.exports.jsx(ChevronUp$1, {})
+            }), jsxRuntime.exports.jsx(StepperButton$1, {
                 disabled: disabled2,
                 onClick: stepDown,
                 styling: "ghost",
                 tabIndex: -1,
-                children: jsxRuntime.exports.jsx(ChevronDown, {})
+                children: jsxRuntime.exports.jsx(ChevronDown$1, {})
             })]
         });
     };
-    const InputWrapper$2 = styled__default.default.div`
+    const InputWrapper$6 = styled__default.default.div`
     display: flex;
     flex-direction: row;
 
     width: 22ch;
     height: 2.5rem;
     padding-right: 0.5rem;
 
@@ -38749,42 +38730,42 @@
 
     // Fix: Overrides the 22ch default width of the nested regular input
     > div:first-child {
         width: 100%;
         height: auto;
     }
 `;
-    const numericFilter = (integerOnly) => (e3) => {
+    const numericFilter$1 = (integerOnly) => (e3) => {
         if (parseInt(e3.key) || parseInt(e3.key) === 0) {
             return true;
         }
-        if (CONTROL_KEYS.includes(e3.key)) {
+        if (CONTROL_KEYS$1.includes(e3.key)) {
             return true;
         }
         const target = e3.target;
-        if (!integerOnly && e3.key === Key.PERIOD && !target.value.includes(Key.PERIOD)) {
+        if (!integerOnly && e3.key === Key$1.PERIOD && !target.value.includes(Key$1.PERIOD)) {
             return true;
         }
-        if (e3.key === Key.MINUS && !e3.shiftKey && target.selectionStart === 0 && !target.value.includes(Key.MINUS)) {
+        if (e3.key === Key$1.MINUS && !e3.shiftKey && target.selectionStart === 0 && !target.value.includes(Key$1.MINUS)) {
             return true;
         }
         return false;
     };
-    const getInitialValue = (value, initialValue) => {
+    const getInitialValue$2 = (value, initialValue) => {
         if (Number.isFinite(value)) {
             return String(value);
         }
         if (Number.isFinite(initialValue)) {
             return String(initialValue);
         }
         return "";
     };
     const NumericInput = React__namespace.forwardRef((props, ref2) => {
-        const keydownFilter = React.useMemo(() => numericFilter(props.integerOnly), [props.integerOnly]);
-        const [input, setInput] = React.useState(getInitialValue(props.value, props.initialValue));
+        const keydownFilter = React.useMemo(() => numericFilter$1(props.integerOnly), [props.integerOnly]);
+        const [input, setInput] = React.useState(getInitialValue$2(props.value, props.initialValue));
         const step2 = (value) => {
             var _a3;
             if (!input || input === "-") {
                 return;
             }
             const isFloat = input.includes(".");
             const parsedValue = isFloat ? parseFloat(input) : parseInt(input);
@@ -38810,18 +38791,18 @@
         const onKeyDown = (e3) => {
             var _a3, _b;
             (_a3 = props.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(props, e3);
             if (!props.stepper) {
                 return;
             }
             const stepSkip = Math.abs((_b = props.stepSkip) !== null && _b !== void 0 ? _b : 1);
-            if (e3.key === Key.UP) {
+            if (e3.key === Key$1.UP) {
                 step2(stepSkip);
             }
-            if (e3.key === Key.DOWN) {
+            if (e3.key === Key$1.DOWN) {
                 step2(stepSkip * -1);
             }
         };
         const onChange2 = React.useCallback(
             (value, e3) => {
                 var _a3, _b;
                 const parsed = props.integerOnly ? parseInt(value) : parseFloat(value);
@@ -38843,58 +38824,58 @@
                     return;
                 }
                 (_b = props.onChange) === null || _b === void 0 ? void 0 : _b.call(props, parsed, e3);
             },
             [props.integerOnly, props.value, props.onChange]
         );
         React.useEffect(() => {
-            setInput(getInitialValue(props.value, props.initialValue));
+            setInput(getInitialValue$2(props.value, props.initialValue));
         }, [props.value]);
         return jsxRuntime.exports.jsxs("div", {
-            children: [jsxRuntime.exports.jsxs(InputWrapper$2, {
+            children: [jsxRuntime.exports.jsxs(InputWrapper$6, {
                 disabled: props.disabled,
                 errorMsg: props.errorMsg,
                 stepper: props.stepper,
                 style: props.style,
-                children: [jsxRuntime.exports.jsx(Input$3, {
+                children: [jsxRuntime.exports.jsx(Input$5, {
                     autoFocus: props.autoFocus,
                     className: props.className,
                     disabled: props.disabled,
                     keydownFilter,
                     maxValue: props.maxValue,
                     minValue: props.minValue,
                     onBlur: props.onBlur,
                     onChange: onChange2,
                     onComplete: props.onComplete,
                     onKeyDown,
                     placeholder: props.placeholder,
                     ref: ref2,
                     value: input
-                }), props.stepper && jsxRuntime.exports.jsx(InputStepper, {
+                }), props.stepper && jsxRuntime.exports.jsx(InputStepper$1, {
                     disabled: props.disabled,
                     step: step2,
                     stepSkip: props.stepSkip
                 })]
-            }), props.errorMsg && jsxRuntime.exports.jsx(ErrorMessage$1, {
+            }), props.errorMsg && jsxRuntime.exports.jsx(ErrorMessage$3, {
                 children: props.errorMsg
             })]
         });
     });
-    Input$3.displayName = "NumericInput";
+    Input$5.displayName = "NumericInput";
     var isArray$c = isArray_1;
 
     function castArray() {
         if (!arguments.length) {
             return [];
         }
         var value = arguments[0];
         return isArray$c(value) ? value : [value];
     }
     var castArray_1 = castArray;
-    const Wrapper$5 = styled__default.default.div`
+    const Wrapper$b = styled__default.default.div`
     overflow: auto;
     display: grid;
     grid-template-columns: repeat(${(props) => props.itemsPerRow}, 1fr);
 
     max-height: 100%;
     margin: 2rem;
     padding: 1rem;
@@ -38930,15 +38911,15 @@
     const CardTitle = styled__default.default.h2`
     margin-top: 1rem;
 `;
     const CardSubtitle = styled__default.default.h4`
     margin-top: 1rem;
     color: ${(props) => props.theme.colors.grey6};
 `;
-    const StyledCheckSquare = styled__default.default(CheckSquare)`
+    const StyledCheckSquare = styled__default.default(CheckSquare$1)`
     cursor: pointer;
 
     position: absolute;
     z-index: 3;
     top: 10px;
     right: 10px;
 
@@ -38975,15 +38956,15 @@
                 var _a3;
                 const updatedSelectedCards = updateSelectedItems(selectedCards, props.items[index2], props.multiSelect);
                 setSelectedCards(updatedSelectedCards);
                 (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, updatedSelectedCards);
             },
             [props.items, props.multiSelect, selectedCards, setSelectedCards]
         );
-        return jsxRuntime.exports.jsx(Wrapper$5, {
+        return jsxRuntime.exports.jsx(Wrapper$b, {
             className: props.className,
             itemsPerRow: props.itemsPerRow && props.itemsPerRow > 0 ? props.itemsPerRow : 3,
             style: props.style,
             children: props.items.map((item, index2) => jsxRuntime.exports.jsxs(Card$2, {
                 onClick: () => onClick(index2),
                 selected: getSelectedIndex(selectedCards, item) > -1,
                 children: [getSelectedIndex(selectedCards, item) > -1 && jsxRuntime.exports.jsx(StyledCheckSquare, {
@@ -39154,15 +39135,15 @@
         }
     }
 `;
     const RadioButton = styled__default.default.input`
     position: absolute;
     opacity: 0;
 `;
-    const StyledCheckmark = styled__default.default.span`
+    const StyledCheckmark$1 = styled__default.default.span`
     position: relative;
     top: 0;
     left: 0;
 
     width: 1rem;
     height: 1rem;
 
@@ -39208,99 +39189,99 @@
                     children: [jsxRuntime.exports.jsx(RadioButton, {
                         checked: isEqual_1((_a3 = props.value) === null || _a3 === void 0 ? void 0 : _a3.value, item.value) || currentSelected === index2,
                         disabled: props.disabled,
                         name: uuid2.current,
                         onChange: (e3) => onChangeValue(e3),
                         type: "radio",
                         value: index2
-                    }), jsxRuntime.exports.jsx(StyledCheckmark, {
+                    }), jsxRuntime.exports.jsx(StyledCheckmark$1, {
                         disabled: props.disabled
                     }), item.label ? item.label : item.value]
                 }, `item-${index2}`);
             })
         });
     }
     const {
-        stateChangeTypes
+        stateChangeTypes: stateChangeTypes$2
     } = useCombobox;
-    const ListWrapper = styled__default.default(List)`
+    const ListWrapper$1 = styled__default.default(List$1)`
     margin-left: -1px;
     border-radius: 0px 0px 0.25rem 0.25rem;
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
-    const getTextColor = (heading2, selected, theme2) => {
+    const getTextColor$1 = (heading2, selected, theme2) => {
         if (heading2) {
             return theme2.colors.text;
         }
         if (selected) {
             return theme2.colors.primary;
         }
         return theme2.colors.text;
     };
-    const ListItemSpan = styled__default.default(ListItem)`
+    const ListItemSpan$1 = styled__default.default(ListItem$1)`
     cursor: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "pointer"};
     user-select: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "none"};
 
     display: flex;
     align-items: center;
     justify-content: space-between;
 
     padding: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) || !props.section ? "0 0.7rem" : "0 1.5rem"};
     padding-right: 0.7rem;
 
     font-weight: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "bold" : "normal"};
-    color: ${(props) => getTextColor(props === null || props === void 0 ? void 0 : props.heading, props.selected, props.theme)};
+    color: ${(props) => getTextColor$1(props === null || props === void 0 ? void 0 : props.heading, props.selected, props.theme)};
 
     ${(props) => {
     if (props.heading) {
       return `
                 :hover {
                     background-color: ${props.theme.colors.background};
                     color: ${props.theme.colors.text};
                 }
             `;
     }
   }}
 `;
 
-    function instanceOfSectionItem(item) {
+    function instanceOfSectionItem$1(item) {
         return "items" in item;
     }
 
-    function unpackSectionedList(listItems) {
+    function unpackSectionedList$1(listItems) {
         return listItems.reduce((acc, item) => {
-            if (instanceOfSectionItem(item)) {
+            if (instanceOfSectionItem$1(item)) {
                 const sectionHeading = {
                     heading: true,
                     label: item.label,
                     value: item.label
                 };
                 const sectionItems = item.items.map((sectionItem) => Object.assign(Object.assign({}, sectionItem), {
                     section: item.label
                 }));
                 return [...acc, sectionHeading, ...sectionItems];
             }
             return [...acc, item];
         }, []);
     }
 
-    function SectionedList(props) {
+    function SectionedList$1(props) {
         var _a3, _b, _c, _d;
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const referenceElement = React.useRef(null);
         const popperElement = React.useRef(null);
         const {
             styles: styles2,
             attributes: attributes2,
             update: update2
-        } = usePopper$1(referenceElement.current, popperElement.current, {
-            modifiers: [sameWidthModifier],
+        } = usePopper$2(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier$1],
             placement: "bottom-start"
         });
-        const unpackedItems = React.useMemo(() => unpackSectionedList(props.items), [props.items]);
+        const unpackedItems = React.useMemo(() => unpackSectionedList$1(props.items), [props.items]);
         const [pendingHighlight, setPendingHighlight] = React.useState(null);
         const [items, setItems] = React.useState(unpackedItems);
         const [inputValue, setInputValue] = React.useState((_b = (_a3 = props.selectedItem) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : "");
         const {
             selectedItem,
             isOpen,
             getMenuProps,
@@ -39350,42 +39331,42 @@
                 }
             },
             stateReducer: (state, {
                 changes,
                 type: type2
             }) => {
                 var _a4, _b2, _c2;
-                if (type2 === stateChangeTypes.ControlledPropUpdatedSelectedItem) {
+                if (type2 === stateChangeTypes$2.ControlledPropUpdatedSelectedItem) {
                     return Object.assign(Object.assign({}, changes), {
                         inputValue: ""
                     });
                 }
-                if (type2 === stateChangeTypes.InputFocus || type2 === stateChangeTypes.ToggleButtonClick && changes.isOpen) {
+                if (type2 === stateChangeTypes$2.InputFocus || type2 === stateChangeTypes$2.ToggleButtonClick && changes.isOpen) {
                     setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
                     return Object.assign(Object.assign({}, changes), {
                         inputValue: ""
                     });
                 }
                 if ([
-                        stateChangeTypes.InputKeyDownEnter,
-                        stateChangeTypes.ItemClick,
-                        stateChangeTypes.InputBlur,
-                        stateChangeTypes.InputKeyDownEscape,
-                        stateChangeTypes.ToggleButtonClick
+                        stateChangeTypes$2.InputKeyDownEnter,
+                        stateChangeTypes$2.ItemClick,
+                        stateChangeTypes$2.InputBlur,
+                        stateChangeTypes$2.InputKeyDownEscape,
+                        stateChangeTypes$2.ToggleButtonClick
                     ].includes(type2)) {
                     return Object.assign(Object.assign({}, changes), {
                         inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
                     });
                 }
-                if (type2 === stateChangeTypes.InputKeyDownArrowUp && ((_b2 = items[changes.highlightedIndex]) === null || _b2 === void 0 ? void 0 : _b2.heading)) {
+                if (type2 === stateChangeTypes$2.InputKeyDownArrowUp && ((_b2 = items[changes.highlightedIndex]) === null || _b2 === void 0 ? void 0 : _b2.heading)) {
                     return Object.assign(Object.assign({}, changes), {
                         highlightedIndex: changes.highlightedIndex - 1 < 0 ? items.length - 1 : changes.highlightedIndex - 1
                     });
                 }
-                if (type2 === stateChangeTypes.InputKeyDownArrowDown && ((_c2 = items[changes.highlightedIndex]) === null || _c2 === void 0 ? void 0 : _c2.heading)) {
+                if (type2 === stateChangeTypes$2.InputKeyDownArrowDown && ((_c2 = items[changes.highlightedIndex]) === null || _c2 === void 0 ? void 0 : _c2.heading)) {
                     return Object.assign(Object.assign({}, changes), {
                         highlightedIndex: changes.highlightedIndex + 1 === items.length ? 0 : changes.highlightedIndex + 1
                     });
                 }
                 return changes;
             }
         }, "selectedItem" in props && {
@@ -39410,33 +39391,33 @@
         const menuProps = getMenuProps();
         const setMenuRef = menuProps.ref;
         delete menuProps.ref;
         const setMenuReference = (value) => {
             setMenuRef(value);
             popperElement.current = value;
         };
-        return jsxRuntime.exports.jsxs(Wrapper$a, {
+        return jsxRuntime.exports.jsxs(Wrapper$g, {
             className: props.className,
             isDisabled: props.disabled,
             isErrored: false,
             isOpen,
             style: props.style,
-            children: [jsxRuntime.exports.jsxs(InputWrapper$4, {
+            children: [jsxRuntime.exports.jsxs(InputWrapper$8, {
                 disabled: props.disabled,
                 isOpen,
                 ref: referenceElement,
-                children: [jsxRuntime.exports.jsx(Input$2, Object.assign({}, getInputProps({
+                children: [jsxRuntime.exports.jsx(Input$4, Object.assign({}, getInputProps({
                     value: inputValue
-                }))), jsxRuntime.exports.jsx(ChevronButton$1, Object.assign({}, getToggleButtonProps(), {
-                    children: jsxRuntime.exports.jsx(Chevron$2, {
+                }))), jsxRuntime.exports.jsx(ChevronButton$2, Object.assign({}, getToggleButtonProps(), {
+                    children: jsxRuntime.exports.jsx(Chevron$4, {
                         disabled: props.disabled,
                         isOpen
                     })
                 }))]
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper, Object.assign({}, menuProps, attributes2.popper, {
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper$1, Object.assign({}, menuProps, attributes2.popper, {
                 isOpen,
                 ref: setMenuReference,
                 style: Object.assign(Object.assign({}, styles2.popper), {
                     width: parseFloat((_d = styles2.popper) === null || _d === void 0 ? void 0 : _d.width) + 2,
                     zIndex: 9999
                 }),
                 children: [items.length > 0 && items.map((item, index2) => {
@@ -39444,30 +39425,30 @@
                         index: index2,
                         item
                     });
                     if (item.heading) {
                         delete itemProps.onClick;
                     }
                     return React.createElement(
-                        ListItemSpan,
+                        ListItemSpan$1,
                         Object.assign({}, itemProps, {
                             heading: item.heading,
                             hovered: index2 === highlightedIndex,
                             key: `item-${index2}`,
                             section: item.section,
                             selected: item.value === (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.value),
                             title: item.label
                         }),
                         item.label || item.section,
-                        item.badge && jsxRuntime.exports.jsx(Badge, {
+                        item.badge && jsxRuntime.exports.jsx(Badge$1, {
                             color: item.badge.color || theme2.colors.primary,
                             children: item.badge.label
                         })
                     );
-                }), items.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$1, {
+                }), items.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel$2, {
                     children: "No Items"
                 })]
             })), document.body)]
         });
     }
     var toNumber$1 = toNumber_1;
     var INFINITY$2 = 1 / 0,
@@ -39524,34 +39505,34 @@
         }
         var result = value + "";
         return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
     }
     var _baseToString = baseToString$1;
     var baseToString = _baseToString;
 
-    function toString$5(value) {
+    function toString$6(value) {
         return value == null ? "" : baseToString(value);
     }
-    var toString_1 = toString$5;
-    var root$3 = _root,
+    var toString_1 = toString$6;
+    var root$5 = _root,
         toInteger = toInteger_1,
         toNumber = toNumber_1,
-        toString$4 = toString_1;
-    var nativeIsFinite = root$3.isFinite,
+        toString$5 = toString_1;
+    var nativeIsFinite = root$5.isFinite,
         nativeMin = Math.min;
 
     function createRound$1(methodName) {
         var func = Math[methodName];
         return function(number2, precision2) {
             number2 = toNumber(number2);
             precision2 = precision2 == null ? 0 : nativeMin(toInteger(precision2), 292);
             if (precision2 && nativeIsFinite(number2)) {
-                var pair2 = (toString$4(number2) + "e").split("e"),
+                var pair2 = (toString$5(number2) + "e").split("e"),
                     value = func(pair2[0] + "e" + (+pair2[1] + precision2));
-                pair2 = (toString$4(value) + "e").split("e");
+                pair2 = (toString$5(value) + "e").split("e");
                 return +(pair2[0] + "e" + (+pair2[1] - precision2));
             }
             return func(number2);
         };
     }
     var _createRound = createRound$1;
     var createRound = _createRound;
@@ -40787,15 +40768,15 @@
                     return nextState;
                 }
                 return null;
             }
         }]);
         return Slider2;
     }(React.PureComponent);
-    const InputWrapper$1 = styled__default.default.div`
+    const InputWrapper$5 = styled__default.default.div`
     position: relative;
     display: flex;
     flex: 1 1 auto;
     height: 3rem;
     div {
         flex: 1 1 auto;
     }
@@ -40839,15 +40820,15 @@
         const onInputChange = React.useCallback((value, index2) => {
             setSliderValues((currSliderValues) => {
                 const updatedValues = [...currSliderValues];
                 updatedValues[index2] = Number.isNaN(value) ? domain2[0] : value;
                 return updatedValues;
             });
         }, [domain2, setSliderValues]);
-        return jsxRuntime.exports.jsx(InputWrapper$1, {
+        return jsxRuntime.exports.jsx(InputWrapper$5, {
             firstInputVisible,
             lastInputVisible,
             children: sliderValues.map((value, index2) => {
                 let inputRef = null;
                 if (index2 === 0) {
                     inputRef = firstInputRef;
                 }
@@ -41048,15 +41029,15 @@
                 isFirstRender.current = false;
                 return;
             }
             if (validateValues(sliderValues)) {
                 const formattedValues = sliderValues.map(getValueLabel);
                 onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(formattedValues);
             }
-        }, useDeepCompare([sliderValues]));
+        }, useDeepCompare$1([sliderValues]));
         const onSliderChange = React.useCallback((value) => {
             setSliderValues(value.map((val) => parseFloat(val.toFixed(precision2))));
         }, [precision2]);
         const tickProps = typeof ticks2 === "number" ? {
             count: ticks2
         } : {
             values: ticks2
@@ -41082,27 +41063,27 @@
                             "data-testid": "rail"
                         }))
                     }), jsxRuntime.exports.jsx(Handles, {
                         children: ({
                             handles,
                             getHandleProps
                         }) => jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-                            children: handles.map((handle, idx) => jsxRuntime.exports.jsx(Tooltip$1, {
-                                content: getValueLabel(handle.value),
+                            children: handles.map((handle2, idx) => jsxRuntime.exports.jsx(Tooltip$2, {
+                                content: getValueLabel(handle2.value),
                                 hideOnClick: false,
                                 interactive: true,
                                 placement: "top",
-                                children: jsxRuntime.exports.jsx(Handle, Object.assign({}, getHandleProps(handle.id), {
+                                children: jsxRuntime.exports.jsx(Handle, Object.assign({}, getHandleProps(handle2.id), {
                                     "data-testid": `handle-${idx}`,
                                     hasTicks: !!ticks2,
                                     style: {
-                                        left: `${handle.percent}%`
+                                        left: `${handle2.percent}%`
                                     }
                                 }))
-                            }, handle.id))
+                            }, handle2.id))
                         })
                     }), jsxRuntime.exports.jsx(Tracks, {
                         left: trackToStart,
                         right: trackToEnd,
                         children: ({
                             tracks,
                             getTrackProps
@@ -41144,15 +41125,15 @@
                                     transform: getTickTransform(idx, sliderTicks.length)
                                 },
                                 children: getValueLabel(tick.value)
                             }, tick.id))
                         })
                     }))]
                 })
-            }), !disableInputAlternative && sliderValues && jsxRuntime.exports.jsx(Tooltip$1, {
+            }), !disableInputAlternative && sliderValues && jsxRuntime.exports.jsx(Tooltip$2, {
                 content: showInputs ? "Use Slider?" : "Use Input Alternative?",
                 placement: "top",
                 children: jsxRuntime.exports.jsx(SwapButtonWrapper, {
                     children: jsxRuntime.exports.jsx(SwapHorizontal, {
                         asButton: true,
                         onClick: () => setShowInputs(!showInputs),
                         size: "2x"
@@ -41166,16 +41147,16 @@
         return jsxRuntime.exports.jsx(BaseSlider, Object.assign({
             disableInputAlternative: props.disableInputAlternative
         }, props, {
             getValueLabel: (val) => round_1(val, 4)
         }));
     }
 
-    function Sun() {
-        const theme2 = useClTheme();
+    function Sun$1() {
+        const theme2 = useClTheme$1();
         return jsxRuntime.exports.jsx("div", {
             style: {
                 display: "flex",
                 height: "1rem",
                 width: "1rem"
             },
             children: jsxRuntime.exports.jsxs("svg", {
@@ -41209,15 +41190,15 @@
                 }), jsxRuntime.exports.jsx("path", {
                     d: "M40.9209 141.192C45.9977 136.116 54.2289 136.116 59.3057 141.192C64.3825 146.269 64.3825 154.5 59.3057 159.577L46.5777 172.305C41.5009 177.382 33.2698 177.382 28.193 172.305C23.1162 167.228 23.1162 158.997 28.193 153.92L40.9209 141.192Z",
                     fill: theme2.colors.background
                 })]
             })
         });
     }
-    const SwitchWrapper = styled__default.default.div`
+    const SwitchWrapper$1 = styled__default.default.div`
     cursor: pointer;
 
     position: relative;
     display: flex;
     align-items: center;
     justify-content: ${(props) => props.enabled ? "flex-start" : "flex-end"};
 
@@ -41233,15 +41214,15 @@
     background-color: ${(props) => props.enabled ? props.theme.colors.primary : props.theme.colors.secondary};
     border-radius: 12px;
 
     svg {
         color: ${(props) => props.theme.colors.blue1};
     }
 `;
-    const SwitchHandle = styled__default.default.span`
+    const SwitchHandle$1 = styled__default.default.span`
     position: absolute;
     top: 2px;
     left: ${(props) => props.enabled ? "calc(100% - 1.375rem)" : "0.125rem"};
 
     display: inline-block;
 
     width: 1.25rem;
@@ -41249,63 +41230,63 @@
 
     background-color: ${(props) => props.theme.colors.blue1};
     border-radius: 0.625rem;
 
     transition: left 100ms linear;
 `;
 
-    function Switch$1({
+    function Switch$2({
         className,
         initialValue = false,
         labels = {
             off: "OFF",
             on: "ON"
         },
         lightDark = false,
         onChange: onChange2,
         style: style2,
         value
     }, ref2) {
         const [enabled, setEnabled] = React.useState(value || initialValue);
         const labelIconToShow = React.useMemo(() => {
             if (lightDark) {
-                return enabled ? jsxRuntime.exports.jsx(Sun, {}) : jsxRuntime.exports.jsx(Moon, {});
+                return enabled ? jsxRuntime.exports.jsx(Sun$1, {}) : jsxRuntime.exports.jsx(Moon$1, {});
             }
             return enabled ? labels.on : labels.off;
         }, [labels, lightDark, enabled]);
         React.useEffect(() => {
             if (value !== void 0) {
                 setEnabled(value);
             }
         }, [value]);
         const onClick = () => {
             if (value === void 0) {
                 setEnabled(!enabled);
             }
             onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(!enabled);
         };
-        return jsxRuntime.exports.jsxs(SwitchWrapper, {
+        return jsxRuntime.exports.jsxs(SwitchWrapper$1, {
             className,
             "data-testid": "wrapper",
             enabled,
             onClick,
             ref: ref2,
             style: style2,
-            children: [jsxRuntime.exports.jsx(SwitchHandle, {
+            children: [jsxRuntime.exports.jsx(SwitchHandle$1, {
                 "data-testid": "handle",
                 enabled
             }), jsxRuntime.exports.jsx("div", {
                 style: {
                     userSelect: "none"
                 },
                 children: labelIconToShow
             })]
         });
     }
-    const UISwitch = React.forwardRef(Switch$1);
+    const UISwitch = React.forwardRef(Switch$2);
     var safeIsNaN$1 = Number.isNaN || function ponyfill(value) {
         return typeof value === "number" && value !== value;
     };
 
     function isEqual$1(first, second) {
         if (first === second) {
             return true;
@@ -44989,80 +44970,80 @@
             calledOnce = true;
             lastThis = this;
             lastArgs = newArgs;
             return lastResult;
         }
         return memoized;
     }
-    var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
-    var now$1 = hasNativePerformanceNow ? function() {
+    var hasNativePerformanceNow$1 = typeof performance === "object" && typeof performance.now === "function";
+    var now$2 = hasNativePerformanceNow$1 ? function() {
         return performance.now();
     } : function() {
         return Date.now();
     };
 
-    function cancelTimeout(timeoutID) {
+    function cancelTimeout$1(timeoutID) {
         cancelAnimationFrame(timeoutID.id);
     }
 
-    function requestTimeout(callback, delay) {
-        var start2 = now$1();
+    function requestTimeout$1(callback, delay) {
+        var start2 = now$2();
 
         function tick() {
-            if (now$1() - start2 >= delay) {
+            if (now$2() - start2 >= delay) {
                 callback.call(null);
             } else {
                 timeoutID.id = requestAnimationFrame(tick);
             }
         }
         var timeoutID = {
             id: requestAnimationFrame(tick)
         };
         return timeoutID;
     }
-    var cachedRTLResult = null;
+    var cachedRTLResult$1 = null;
 
-    function getRTLOffsetType(recalculate) {
+    function getRTLOffsetType$1(recalculate) {
         if (recalculate === void 0) {
             recalculate = false;
         }
-        if (cachedRTLResult === null || recalculate) {
+        if (cachedRTLResult$1 === null || recalculate) {
             var outerDiv = document.createElement("div");
             var outerStyle = outerDiv.style;
             outerStyle.width = "50px";
             outerStyle.height = "50px";
             outerStyle.overflow = "scroll";
             outerStyle.direction = "rtl";
             var innerDiv = document.createElement("div");
             var innerStyle = innerDiv.style;
             innerStyle.width = "100px";
             innerStyle.height = "100px";
             outerDiv.appendChild(innerDiv);
             document.body.appendChild(outerDiv);
             if (outerDiv.scrollLeft > 0) {
-                cachedRTLResult = "positive-descending";
+                cachedRTLResult$1 = "positive-descending";
             } else {
                 outerDiv.scrollLeft = 1;
                 if (outerDiv.scrollLeft === 0) {
-                    cachedRTLResult = "negative";
+                    cachedRTLResult$1 = "negative";
                 } else {
-                    cachedRTLResult = "positive-ascending";
+                    cachedRTLResult$1 = "positive-ascending";
                 }
             }
             document.body.removeChild(outerDiv);
-            return cachedRTLResult;
+            return cachedRTLResult$1;
         }
-        return cachedRTLResult;
+        return cachedRTLResult$1;
     }
-    var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
-    var defaultItemKey$1 = function defaultItemKey(index2, data2) {
+    var IS_SCROLLING_DEBOUNCE_INTERVAL$1$1 = 150;
+    var defaultItemKey$1$1 = function defaultItemKey(index2, data2) {
         return index2;
     };
 
-    function createListComponent(_ref2) {
+    function createListComponent$1(_ref2) {
         var _class, _temp;
         var getItemOffset = _ref2.getItemOffset,
             getEstimatedTotalSize = _ref2.getEstimatedTotalSize,
             getItemSize = _ref2.getItemSize,
             getOffsetForIndexAndAlignment = _ref2.getOffsetForIndexAndAlignment,
             getStartIndexForOffset = _ref2.getStartIndexForOffset,
             getStopIndexForStartIndex = _ref2.getStopIndexForStartIndex,
@@ -45110,25 +45091,25 @@
                         layout2 = _this$props.layout;
                     var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout2, shouldResetStyleCacheOnItemSizeChange && direction);
                     var style2;
                     if (itemStyleCache.hasOwnProperty(index2)) {
                         style2 = itemStyleCache[index2];
                     } else {
                         var _offset = getItemOffset(_this.props, index2, _this._instanceProps);
-                        var size = getItemSize(_this.props, index2, _this._instanceProps);
+                        var size2 = getItemSize(_this.props, index2, _this._instanceProps);
                         var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
                         var isRtl = direction === "rtl";
                         var offsetHorizontal = isHorizontal ? _offset : 0;
                         itemStyleCache[index2] = style2 = {
                             position: "absolute",
                             left: isRtl ? void 0 : offsetHorizontal,
                             right: isRtl ? offsetHorizontal : void 0,
                             top: !isHorizontal ? _offset : 0,
-                            height: !isHorizontal ? size : "100%",
-                            width: isHorizontal ? size : "100%"
+                            height: !isHorizontal ? size2 : "100%",
+                            width: isHorizontal ? size2 : "100%"
                         };
                     }
                     return style2;
                 };
                 _this._getItemStyleCache = void 0;
                 _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
                     return {};
@@ -45141,15 +45122,15 @@
                     _this.setState(function(prevState) {
                         if (prevState.scrollOffset === scrollLeft) {
                             return null;
                         }
                         var direction = _this.props.direction;
                         var scrollOffset = scrollLeft;
                         if (direction === "rtl") {
-                            switch (getRTLOffsetType()) {
+                            switch (getRTLOffsetType$1()) {
                                 case "negative":
                                     scrollOffset = -scrollLeft;
                                     break;
                                 case "positive-descending":
                                     scrollOffset = scrollWidth - clientWidth - scrollLeft;
                                     break;
                             }
@@ -45188,30 +45169,30 @@
                         outerRef(ref2);
                     } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
                         outerRef.current = ref2;
                     }
                 };
                 _this._resetIsScrollingDebounced = function() {
                     if (_this._resetIsScrollingTimeoutId !== null) {
-                        cancelTimeout(_this._resetIsScrollingTimeoutId);
+                        cancelTimeout$1(_this._resetIsScrollingTimeoutId);
                     }
-                    _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
+                    _this._resetIsScrollingTimeoutId = requestTimeout$1(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1$1);
                 };
                 _this._resetIsScrolling = function() {
                     _this._resetIsScrollingTimeoutId = null;
                     _this.setState({
                         isScrolling: false
                     }, function() {
                         _this._getItemStyleCache(-1, null);
                     });
                 };
                 return _this;
             }
             List2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
-                validateSharedProps$1(nextProps, prevState);
+                validateSharedProps$1$1(nextProps, prevState);
                 validateProps(nextProps);
                 return null;
             };
             var _proto = List2.prototype;
             _proto.scrollTo = function scrollTo(scrollOffset) {
                 scrollOffset = Math.max(0, scrollOffset);
                 this.setState(function(prevState) {
@@ -45256,15 +45237,15 @@
                 var _this$state = this.state,
                     scrollOffset = _this$state.scrollOffset,
                     scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
                 if (scrollUpdateWasRequested && this._outerRef != null) {
                     var outerRef = this._outerRef;
                     if (direction === "horizontal" || layout2 === "horizontal") {
                         if (direction === "rtl") {
-                            switch (getRTLOffsetType()) {
+                            switch (getRTLOffsetType$1()) {
                                 case "negative":
                                     outerRef.scrollLeft = -scrollOffset;
                                     break;
                                 case "positive-ascending":
                                     outerRef.scrollLeft = scrollOffset;
                                     break;
                                 default:
@@ -45280,30 +45261,30 @@
                         outerRef.scrollTop = scrollOffset;
                     }
                 }
                 this._callPropsCallbacks();
             };
             _proto.componentWillUnmount = function componentWillUnmount() {
                 if (this._resetIsScrollingTimeoutId !== null) {
-                    cancelTimeout(this._resetIsScrollingTimeoutId);
+                    cancelTimeout$1(this._resetIsScrollingTimeoutId);
                 }
             };
             _proto.render = function render2() {
                 var _this$props4 = this.props,
                     children2 = _this$props4.children,
                     className = _this$props4.className,
                     direction = _this$props4.direction,
                     height = _this$props4.height,
                     innerRef = _this$props4.innerRef,
                     innerElementType = _this$props4.innerElementType,
                     innerTagName = _this$props4.innerTagName,
                     itemCount = _this$props4.itemCount,
                     itemData = _this$props4.itemData,
                     _this$props4$itemKey = _this$props4.itemKey,
-                    itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,
+                    itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1$1 : _this$props4$itemKey,
                     layout2 = _this$props4.layout,
                     outerElementType = _this$props4.outerElementType,
                     outerTagName = _this$props4.outerTagName,
                     style2 = _this$props4.style,
                     useIsScrolling = _this$props4.useIsScrolling,
                     width = _this$props4.width;
                 var isScrolling = this.state.isScrolling;
@@ -45390,25 +45371,25 @@
             direction: "ltr",
             itemData: void 0,
             layout: "vertical",
             overscanCount: 2,
             useIsScrolling: false
         }, _temp;
     }
-    var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
+    var validateSharedProps$1$1 = function validateSharedProps(_ref2, _ref3) {
         _ref2.children;
         _ref2.direction;
         _ref2.height;
         _ref2.layout;
         _ref2.innerTagName;
         _ref2.outerTagName;
         _ref2.width;
         _ref3.instance;
     };
-    var FixedSizeList = /* @__PURE__ */ createListComponent({
+    var FixedSizeList$1 = /* @__PURE__ */ createListComponent$1({
         getItemOffset: function getItemOffset(_ref2, index2) {
             var itemSize = _ref2.itemSize;
             return index2 * itemSize;
         },
         getItemSize: function getItemSize(_ref2, index2) {
             var itemSize = _ref2.itemSize;
             return itemSize;
@@ -45422,35 +45403,35 @@
             var direction = _ref4.direction,
                 height = _ref4.height,
                 itemCount = _ref4.itemCount,
                 itemSize = _ref4.itemSize,
                 layout2 = _ref4.layout,
                 width = _ref4.width;
             var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
-            var size = isHorizontal ? width : height;
-            var lastItemOffset = Math.max(0, itemCount * itemSize - size);
+            var size2 = isHorizontal ? width : height;
+            var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
             var maxOffset2 = Math.min(lastItemOffset, index2 * itemSize);
-            var minOffset = Math.max(0, index2 * itemSize - size + itemSize);
+            var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize);
             if (align === "smart") {
-                if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset2 + size) {
+                if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset2 + size2) {
                     align = "auto";
                 } else {
                     align = "center";
                 }
             }
             switch (align) {
                 case "start":
                     return maxOffset2;
                 case "end":
                     return minOffset;
                 case "center": {
                     var middleOffset = Math.round(minOffset + (maxOffset2 - minOffset) / 2);
-                    if (middleOffset < Math.ceil(size / 2)) {
+                    if (middleOffset < Math.ceil(size2 / 2)) {
                         return 0;
-                    } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {
+                    } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
                         return lastItemOffset;
                     } else {
                         return middleOffset;
                     }
                 }
                 case "auto":
                 default:
@@ -45473,50 +45454,50 @@
                 height = _ref6.height,
                 itemCount = _ref6.itemCount,
                 itemSize = _ref6.itemSize,
                 layout2 = _ref6.layout,
                 width = _ref6.width;
             var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
             var offset2 = startIndex * itemSize;
-            var size = isHorizontal ? width : height;
-            var numVisibleItems = Math.ceil((size + scrollOffset - offset2) / itemSize);
+            var size2 = isHorizontal ? width : height;
+            var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
             return Math.max(0, Math.min(
                 itemCount - 1,
                 startIndex + numVisibleItems - 1
             ));
         },
         initInstanceProps: function initInstanceProps(props) {},
         shouldResetStyleCacheOnItemSizeChange: true,
         validateProps: function validateProps(_ref7) {
             _ref7.itemSize;
         }
     });
 
-    function shallowDiffers(prev, next2) {
+    function shallowDiffers$1(prev, next2) {
         for (var attribute in prev) {
             if (!(attribute in next2)) {
                 return true;
             }
         }
         for (var _attribute in next2) {
             if (prev[_attribute] !== next2[_attribute]) {
                 return true;
             }
         }
         return false;
     }
 
-    function areEqual(prevProps, nextProps) {
+    function areEqual$1(prevProps, nextProps) {
         var prevStyle = prevProps.style,
-            prevRest = _objectWithoutPropertiesLoose$4(prevProps, ["style"]);
+            prevRest = _objectWithoutPropertiesLoose$5(prevProps, ["style"]);
         var nextStyle = nextProps.style,
-            nextRest = _objectWithoutPropertiesLoose$4(nextProps, ["style"]);
-        return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
+            nextRest = _objectWithoutPropertiesLoose$5(nextProps, ["style"]);
+        return !shallowDiffers$1(prevStyle, nextStyle) && !shallowDiffers$1(prevRest, nextRest);
     }
-    const GlobalStyle = styled.createGlobalStyle`
+    const GlobalStyle$1 = styled.createGlobalStyle`
     body {
         .DatetimeFilterSelect {
             background-color: ${(props) => props.theme.colors.grey1};
             span {
                 background-color: ${(props) => props.theme.colors.grey1};
                 border-bottom: 1px solid ${(props) => props.theme.colors.grey1};
 
@@ -45531,18 +45512,18 @@
                 :active {
                     background-color: ${(props) => props.theme.colors.grey4};
                 }
             }
         }
     }
 `;
-    const DatetimeFilterWrapper = styled__default.default(FilterWrapper)`
+    const DatetimeFilterWrapper$1 = styled__default.default(FilterWrapper$1)`
     gap: 0rem;
 `;
-    const DatepickerWrapper = styled__default.default.div`
+    const DatepickerWrapper$2 = styled__default.default.div`
     height: auto;
 
     div:has(input) {
         width: 6.7rem;
     }
 
     input {
@@ -45596,32 +45577,32 @@
 
             .react-datepicker__month {
                 background-color: ${(props) => props.theme.colors.grey1};
             }
         }
     }
 `;
-    const StyledSelect$1 = styled__default.default(Select$1)`
+    const StyledSelect$3 = styled__default.default(Select$2)`
     margin-bottom: 0.25rem;
     border: 1px solid ${(props) => props.theme.colors.background};
 
     button {
         background-color: ${(props) => props.theme.colors.background};
 
         :hover:enabled {
             background-color: ${(props) => props.theme.colors.background};
         }
     }
 `;
-    const StyledApply = styled__default.default(ApplyButton)`
+    const StyledApply$1 = styled__default.default(ApplyButton$1)`
     width: 4rem;
     height: 2rem;
     padding: 0px;
 `;
-    const DatetimeFilterItems = [{
+    const DatetimeFilterItems$1 = [{
         label: "None",
         value: "None"
     }, {
         label: "Before",
         value: "Before"
     }, {
         label: "After",
@@ -45630,15 +45611,15 @@
         label: "On date",
         value: "On date"
     }, {
         label: "Between",
         value: "Between"
     }];
 
-    function DatetimeFilter(props) {
+    function DatetimeFilter$1(props) {
         const [selected, setSelected] = React.useState(null);
         const [dateValues, setDateValues] = React.useState(props.values);
         const filteredValues = React.useMemo(() => {
             let filterDate = dateValues;
             if ((selected === null || selected === void 0 ? void 0 : selected.value) !== "Between" && Array.isArray(dateValues)) {
                 [filterDate] = dateValues;
             }
@@ -45653,123 +45634,123 @@
                 return true;
             }
             if (!dateValues || selected.label === "Between" && Array.isArray(dateValues) && (!dateValues[0] || !dateValues[1]) || selected.label === "Between" && !Array.isArray(dateValues)) {
                 return true;
             }
             return false;
         }, [props.disabled, previousFilter, filteredValues, dateValues, selected]);
-        return jsxRuntime.exports.jsxs(DatetimeFilterWrapper, {
+        return jsxRuntime.exports.jsxs(DatetimeFilterWrapper$1, {
             className: props.className,
-            children: [jsxRuntime.exports.jsx(GlobalStyle, {}), jsxRuntime.exports.jsxs(FilterHeader, {
-                children: [jsxRuntime.exports.jsx(StyledSelect$1, {
+            children: [jsxRuntime.exports.jsx(GlobalStyle$1, {}), jsxRuntime.exports.jsxs(FilterHeader$1, {
+                children: [jsxRuntime.exports.jsx(StyledSelect$3, {
                     dropdownRef: (element2) => {
                         if (props.portalsRef) {
                             props.portalsRef.current[2] = element2;
                         }
                     },
                     initialValue: {
                         label: "None",
                         value: "None"
                     },
-                    items: DatetimeFilterItems,
+                    items: DatetimeFilterItems$1,
                     onSelect: setSelected
-                }), jsxRuntime.exports.jsx(DatepickerWrapper, {
-                    children: selected && selected.label !== "None" && jsxRuntime.exports.jsx(DatePicker, {
+                }), jsxRuntime.exports.jsx(DatepickerWrapper$2, {
+                    children: selected && selected.label !== "None" && jsxRuntime.exports.jsx(DatePicker$1, {
                         inline: true,
                         onChange: setDateValues,
                         portalsRef: props.portalsRef,
                         selectItemClass: "DatetimeFilterSelect",
                         selectsRange: (selected === null || selected === void 0 ? void 0 : selected.value) === "Between",
                         shouldCloseOnSelect: false,
                         showTimeInput: props.showTimeInput
                     })
                 })]
-            }), jsxRuntime.exports.jsx(StyledApply, {
+            }), jsxRuntime.exports.jsx(StyledApply$1, {
                 disabled: disableApply,
                 onClick: (e3) => {
                     var _a3, _b;
                     (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
                     (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
                     setPreviousFilter(filteredValues);
                 },
                 children: "Apply"
             })]
         });
     }
-    var Action;
+    var Action$1;
     (function(Action2) {
         Action2["COPY"] = "copy";
         Action2["DELETE"] = "delete";
         Action2["SELECT"] = "select";
         Action2["SELECT_ALL"] = "select_all";
         Action2["SWITCH"] = "switch";
         Action2["UNSELECT_ALL"] = "unselect_all";
-    })(Action || (Action = {}));
-    const SelectCheck = styled__default.default(CheckSquare)`
+    })(Action$1 || (Action$1 = {}));
+    const SelectCheck$1 = styled__default.default(CheckSquare$1)`
     color: ${(props) => props.theme.colors.primary};
 `;
 
-    function getSelectIcon(row) {
-        return row.selected ? SelectCheck : Square;
+    function getSelectIcon$1(row) {
+        return row.selected ? SelectCheck$1 : Square$1;
     }
-    const SwitchOn = styled__default.default(ToggleOn)`
+    const SwitchOn$1 = styled__default.default(ToggleOn$1)`
     color: ${(props) => props.theme.colors.primary};
 `;
 
-    function getSwitchIcon(row) {
-        return row.active ? SwitchOn : ToggleOff;
+    function getSwitchIcon$1(row) {
+        return row.active ? SwitchOn$1 : ToggleOff$1;
     }
-    const Actions = {
+    const Actions$1 = {
         COPY: {
-            icon: Copy,
-            id: Action.COPY,
+            icon: Copy$1,
+            id: Action$1.COPY,
             label: "Copy"
         },
         DELETE: {
-            icon: Trash,
-            id: Action.DELETE,
+            icon: Trash$1,
+            id: Action$1.DELETE,
             label: "Delete"
         },
         SELECT: {
-            getIcon: getSelectIcon,
-            id: Action.SELECT,
+            getIcon: getSelectIcon$1,
+            id: Action$1.SELECT,
             label: "Select Row"
         },
         SELECT_ALL: {
-            id: Action.SELECT_ALL,
+            id: Action$1.SELECT_ALL,
             label: "Select All Rows"
         },
         SWITCH: {
-            getIcon: getSwitchIcon,
-            id: Action.SWITCH,
+            getIcon: getSwitchIcon$1,
+            id: Action$1.SWITCH,
             label: "Switch On/Off"
         },
         UNSELECT_ALL: {
-            id: Action.UNSELECT_ALL,
+            id: Action$1.UNSELECT_ALL,
             label: "Unselect All Rows"
         }
     };
-    const ActionWrapper = styled__default.default.div`
+    const ActionWrapper$1 = styled__default.default.div`
     display: flex;
     align-items: center;
     justify-content: flex-end;
 
     width: 100%;
     padding: 0 1rem;
 
     svg:not(:last-of-type) {
         margin-right: 0.7rem;
     }
 `;
 
-    function ActionCell(props) {
+    function ActionCell$1(props) {
         if (!props.column.actions) {
             throw new Error("Must pass an array of actions to the column def when using the ActionCell");
         }
-        return jsxRuntime.exports.jsx(ActionWrapper, {
+        return jsxRuntime.exports.jsx(ActionWrapper$1, {
             className: "table-action-cell",
             children: props.column.actions.map((action) => {
                 const Icon2 = action.getIcon ? action.getIcon(props.row.original) : action.icon;
                 if (Icon2 === void 0) {
                     return;
                 }
                 const label = action.getLabel ? action.getLabel(props.row.original) : action.label;
@@ -45783,41 +45764,41 @@
                     onClick,
                     title: label
                 }, action.label);
             })
         });
     }
 
-    function DatetimeCell(fmt = "yyyy-MM-dd HH:mm") {
+    function DatetimeCell$1(fmt = "yyyy-MM-dd HH:mm") {
         return ({
             value
         }) => {
             if (!value) {
                 return "";
             }
             const parsed = parseISO$1(value);
             if (Number.isNaN(parsed.getTime())) {
                 return "";
             }
             return format$2(parsed, fmt);
         };
     }
-    const InputWrapper = styled__default.default.div`
+    const InputWrapper$4 = styled__default.default.div`
     display: flex;
     width: calc(100% + 22px);
     margin: 0 -1rem;
 `;
-    const ValueWrapper$1 = styled__default.default.span`
+    const ValueWrapper$3 = styled__default.default.span`
     display: flex;
     flex: 1 1 auto;
     align-items: center;
     height: 100%;
 `;
 
-    function EditInputCell() {
+    function EditInputCell$1() {
         return function InputCell(props) {
             const [value, setValue] = React.useState(props.value);
             React.useEffect(() => {
                 setValue(props.value);
             }, [props.value]);
             if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
                 const onComplete = () => {
@@ -45825,80 +45806,80 @@
                         props.onChange(value, props.rowIdx, props.column.id);
                     }
                     props.onStopEdit();
                 };
                 const onChange2 = (val) => {
                     setValue(val);
                 };
-                return jsxRuntime.exports.jsx(InputWrapper, {
-                    children: jsxRuntime.exports.jsx(Input$3, {
+                return jsxRuntime.exports.jsx(InputWrapper$4, {
+                    children: jsxRuntime.exports.jsx(Input$5, {
                         autoFocus: true,
                         initialValue: props.value,
                         onBlur: onComplete,
                         onChange: onChange2,
                         onComplete,
                         style: {
                             maxWidth: "100%"
                         }
                     })
                 });
             }
-            return jsxRuntime.exports.jsx(ValueWrapper$1, {
+            return jsxRuntime.exports.jsx(ValueWrapper$3, {
                 "data-cell": [props.rowIdx, props.column.id],
                 onClick: props.onStartEdit,
                 children: props.value
             });
         };
     }
-    const SelectWrapper = styled__default.default.div`
+    const SelectWrapper$1 = styled__default.default.div`
     display: flex;
     width: calc(100% + 22px);
     margin: 0 -1rem;
 `;
-    const ValueWrapper = styled__default.default.span`
+    const ValueWrapper$2 = styled__default.default.span`
     display: flex;
     flex: 1 1 auto;
     align-items: center;
     height: 100%;
 `;
 
-    function EditSelectCell(items) {
+    function EditSelectCell$1(items) {
         return function SelectCell(props) {
             const selectedItem = items.find((item) => item.value === props.value);
             if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
                 const onSelect = (item) => {
                     if (props.onChange && item.value !== props.value) {
                         props.onChange(item.value, props.rowIdx, props.column.id);
                     }
                     props.onStopEdit();
                 };
-                return jsxRuntime.exports.jsx(SelectWrapper, {
-                    children: jsxRuntime.exports.jsx(Select$1, {
+                return jsxRuntime.exports.jsx(SelectWrapper$1, {
+                    children: jsxRuntime.exports.jsx(Select$2, {
                         initialIsOpen: true,
                         initialValue: selectedItem,
                         items,
                         onSelect,
                         style: {
                             flex: "1 1 auto"
                         }
                     })
                 });
             }
-            return jsxRuntime.exports.jsx(ValueWrapper, {
+            return jsxRuntime.exports.jsx(ValueWrapper$2, {
                 "data-cell": [props.rowIdx, props.column.id],
                 onClick: props.onStartEdit,
                 children: selectedItem ? selectedItem.label : ""
             });
         };
     }
-    const FilterIcon = styled__default.default(FontAwesomeIcon)`
+    const FilterIcon$1 = styled__default.default(FontAwesomeIcon)`
     cursor: pointer;
     color: ${(props) => props.$hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
 `;
-    const HeaderIconWrapper = styled__default.default.div`
+    const HeaderIconWrapper$1 = styled__default.default.div`
     display: flex;
     align-items: center;
     justify-content: center;
 
     width: 1.5rem;
     height: 1.5rem;
 
@@ -45911,131 +45892,131 @@
         }
     }
 
     :active {
         background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primaryDown)};
     }
 `;
-    var NumericOperator;
+    var NumericOperator$1;
     (function(NumericOperator2) {
         NumericOperator2["BT"] = "Between";
         NumericOperator2["EQ"] = "Equal to";
         NumericOperator2["GT"] = "Greater than";
         NumericOperator2["LT"] = "Less than";
         NumericOperator2["NE"] = "Not equal to";
-    })(NumericOperator || (NumericOperator = {}));
-    var DateOperator;
+    })(NumericOperator$1 || (NumericOperator$1 = {}));
+    var DateOperator$1;
     (function(DateOperator2) {
         DateOperator2["BT"] = "Between";
         DateOperator2["EQ"] = "On date";
         DateOperator2["GT"] = "After";
         DateOperator2["LT"] = "Before";
-    })(DateOperator || (DateOperator = {}));
+    })(DateOperator$1 || (DateOperator$1 = {}));
 
-    function isValidOperator(op) {
-        return Object.keys(NumericOperator).map((key) => NumericOperator[key]).includes(op);
+    function isValidOperator$1(op) {
+        return Object.keys(NumericOperator$1).map((key) => NumericOperator$1[key]).includes(op);
     }
 
-    function isValidDatetimeOperator(op) {
-        return Object.keys(DateOperator).map((key) => DateOperator[key]).includes(op);
+    function isValidDatetimeOperator$1(op) {
+        return Object.keys(DateOperator$1).map((key) => DateOperator$1[key]).includes(op);
     }
 
-    function applyNumericOperator(operator2, value, filterValue) {
+    function applyNumericOperator$1(operator2, value, filterValue) {
         switch (operator2) {
-            case NumericOperator.EQ:
+            case NumericOperator$1.EQ:
                 return value === filterValue;
-            case NumericOperator.GT:
+            case NumericOperator$1.GT:
                 if (Array.isArray(filterValue)) {
                     throw new Error("Cannot use array for GT operator");
                 }
                 return value > filterValue;
-            case NumericOperator.LT:
+            case NumericOperator$1.LT:
                 if (Array.isArray(filterValue)) {
                     throw new Error("Cannot use array for LT operator");
                 }
                 return value < filterValue;
-            case NumericOperator.NE:
+            case NumericOperator$1.NE:
                 return value !== filterValue;
-            case NumericOperator.BT:
+            case NumericOperator$1.BT:
                 if (Array.isArray(filterValue)) {
                     return value <= filterValue[1] && value >= filterValue[0];
                 }
                 break;
             default:
                 return true;
         }
     }
 
-    function applyDatetimeOperator(operator2, value, filterValue) {
+    function applyDatetimeOperator$1(operator2, value, filterValue) {
         const parsedValue = parseISO$1(value);
         if (Array.isArray(filterValue)) {
-            if (operator2 === DateOperator.BT) {
+            if (operator2 === DateOperator$1.BT) {
                 return isWithinInterval$1(parsedValue, {
                     end: filterValue[1],
                     start: filterValue[0]
                 });
             }
             return true;
         }
         switch (operator2) {
-            case DateOperator.EQ:
+            case DateOperator$1.EQ:
                 return isEqual$3(parsedValue, filterValue);
-            case DateOperator.GT:
+            case DateOperator$1.GT:
                 return isAfter$1(parsedValue, filterValue);
-            case DateOperator.LT:
+            case DateOperator$1.LT:
                 return isBefore$1(parsedValue, filterValue);
             default:
                 return true;
         }
     }
 
-    function numeric(rows, columnIds, filterValue) {
+    function numeric$1(rows, columnIds, filterValue) {
         const {
             selected,
             value
         } = filterValue;
         const [colId] = columnIds;
-        if (!isValidOperator(selected) || !value && value !== 0) {
+        if (!isValidOperator$1(selected) || !value && value !== 0) {
             return rows;
         }
-        return rows.filter((row) => applyNumericOperator(selected, row.values[colId], value));
+        return rows.filter((row) => applyNumericOperator$1(selected, row.values[colId], value));
     }
 
-    function datetime(rows, columnIds, filterValue) {
+    function datetime$1(rows, columnIds, filterValue) {
         const {
             selected,
             value
         } = filterValue;
         const [colId] = columnIds;
-        if (!isValidDatetimeOperator(selected) || !value) {
+        if (!isValidDatetimeOperator$1(selected) || !value) {
             return rows;
         }
-        return rows.filter((row) => applyDatetimeOperator(selected, row.values[colId], value));
+        return rows.filter((row) => applyDatetimeOperator$1(selected, row.values[colId], value));
     }
 
-    function categorical(rows, columnIds, filterItems) {
+    function categorical$1(rows, columnIds, filterItems) {
         const [colId] = columnIds;
         const filteredItems = filterItems.map((item) => item.value);
         if (filteredItems.length === 0) {
             return rows;
         }
         return rows.filter((row) => filteredItems.includes(row.values[colId]));
     }
 
-    function TextFilter(props) {
-        return jsxRuntime.exports.jsx(FilterWrapper, {
-            children: jsxRuntime.exports.jsx(StyledSearchBar, {
+    function TextFilter$1(props) {
+        return jsxRuntime.exports.jsx(FilterWrapper$1, {
+            children: jsxRuntime.exports.jsx(StyledSearchBar$1, {
                 onChange: (val) => props.column.setFilter(val || void 0),
                 placeholder: "Rows containing value...",
                 value: props.column.filterValue || ""
             })
         });
     }
 
-    function FilterContainer(props) {
+    function FilterContainer$1(props) {
         var _a3;
         const [visible, setVisible] = React.useState(false);
         const show = () => setVisible(true);
         const hide2 = () => setVisible(false);
         const hasFilter = !(props.col.filterValue === void 0 || ((_a3 = props.col.filterValue) === null || _a3 === void 0 ? void 0 : _a3.selected) === "None" || Array.isArray(props.col.filterValue) && props.col.filterValue.length === 0);
         const items = React.useMemo(() => {
             var _a4;
@@ -46053,45 +46034,45 @@
             for (const portal of portalsRef.current) {
                 if (portal === null || portal === void 0 ? void 0 : portal.contains(target)) {
                     return;
                 }
             }
             hide2();
         }
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: props.col.render("Filter", {
                 items,
                 onChange: hide2,
                 portalsRef
             }),
             hidden: true,
             interactive: true,
             onClickOutside,
             visible,
             children: jsxRuntime.exports.jsx("span", {
-                children: jsxRuntime.exports.jsx(HeaderIconWrapper, {
+                children: jsxRuntime.exports.jsx(HeaderIconWrapper$1, {
                     hasFilter,
-                    children: jsxRuntime.exports.jsx(FilterIcon, {
+                    children: jsxRuntime.exports.jsx(FilterIcon$1, {
                         "$hasFilter": hasFilter,
                         icon: faFilter,
                         onClick: show
                     })
                 })
             })
         });
     }
-    var CheckboxState;
+    var CheckboxState$1;
     (function(CheckboxState2) {
         CheckboxState2["CHECKED"] = "checked";
         CheckboxState2["INDETERMINATE"] = "indeterminate";
         CheckboxState2["UNCHECKED"] = "unchecked";
-    })(CheckboxState || (CheckboxState = {}));
-    const StyledTriStateCheckbox = styled__default.default.div`
+    })(CheckboxState$1 || (CheckboxState$1 = {}));
+    const StyledTriStateCheckbox$1 = styled__default.default.div`
     ${(props) => {
-    if (props.state === CheckboxState.INDETERMINATE) {
+    if (props.state === CheckboxState$1.INDETERMINATE) {
       return `
                     span:after {
                         display: block ;
                         left: 0.07rem;
                         top: 0.4rem;
                         width: 0.75rem;
                         border-radius: 0.25rem;
@@ -46101,131 +46082,131 @@
                     }
 
             `;
     }
   }}
 `;
 
-    function computeState(allSelected, noneSelected) {
+    function computeState$1(allSelected, noneSelected) {
         if (noneSelected) {
-            return CheckboxState.UNCHECKED;
+            return CheckboxState$1.UNCHECKED;
         }
-        return allSelected ? CheckboxState.CHECKED : CheckboxState.INDETERMINATE;
+        return allSelected ? CheckboxState$1.CHECKED : CheckboxState$1.INDETERMINATE;
     }
 
-    function getControlledState(allSelected, noneSelected) {
+    function getControlledState$1(allSelected, noneSelected) {
         if (allSelected) {
             return allSelected;
         }
         if (noneSelected) {
             return false;
         }
         return void 0;
     }
 
-    function TriStateCheckbox(props) {
-        const [state, setState] = React.useState(computeState(props.allSelected, props.noneSelected));
+    function TriStateCheckbox$1(props) {
+        const [state, setState] = React.useState(computeState$1(props.allSelected, props.noneSelected));
         React.useEffect(() => {
-            setState(computeState(props.allSelected, props.noneSelected));
+            setState(computeState$1(props.allSelected, props.noneSelected));
         }, [props.allSelected, props.noneSelected]);
         const onClick = (checked, e3) => {
-            setState(checked ? CheckboxState.CHECKED : CheckboxState.UNCHECKED);
+            setState(checked ? CheckboxState$1.CHECKED : CheckboxState$1.UNCHECKED);
             if (props.onChange) {
-                if (state === CheckboxState.UNCHECKED) {
-                    props.onChange(CheckboxState.CHECKED, e3);
+                if (state === CheckboxState$1.UNCHECKED) {
+                    props.onChange(CheckboxState$1.CHECKED, e3);
                 } else {
-                    props.onChange(CheckboxState.UNCHECKED, e3);
+                    props.onChange(CheckboxState$1.UNCHECKED, e3);
                 }
             }
         };
-        return jsxRuntime.exports.jsx(StyledTriStateCheckbox, {
+        return jsxRuntime.exports.jsx(StyledTriStateCheckbox$1, {
             state,
             style: props.style,
-            children: jsxRuntime.exports.jsx(Checkbox, {
+            children: jsxRuntime.exports.jsx(Checkbox$1, {
                 className: props.className,
                 disabled: props.disabled,
-                initialValue: state === CheckboxState.CHECKED,
+                initialValue: state === CheckboxState$1.CHECKED,
                 onChange: (checked, event2) => {
                     onClick(checked, event2);
                 },
-                selected: getControlledState(props.allSelected, props.noneSelected)
+                selected: getControlledState$1(props.allSelected, props.noneSelected)
             })
         });
     }
 
-    function SelectHeader(props) {
+    function SelectHeader$1(props) {
         const allValues = props.rows.map((r2) => r2.original.selected);
         const countSelected = allValues.filter(Boolean).length;
         const allSelected = countSelected > 0 && countSelected === allValues.length;
         const noneSelected = countSelected === 0;
         const onChange2 = (state) => {
-            if (state === CheckboxState.UNCHECKED) {
-                props.onAction(Action.UNSELECT_ALL);
-            } else if (state === CheckboxState.CHECKED) {
-                props.onAction(Action.SELECT_ALL, props.rows.map((r2) => r2.original));
+            if (state === CheckboxState$1.UNCHECKED) {
+                props.onAction(Action$1.UNSELECT_ALL);
+            } else if (state === CheckboxState$1.CHECKED) {
+                props.onAction(Action$1.SELECT_ALL, props.rows.map((r2) => r2.original));
             }
         };
-        return jsxRuntime.exports.jsx(TriStateCheckbox, {
+        return jsxRuntime.exports.jsx(TriStateCheckbox$1, {
             allSelected,
             noneSelected,
             onChange: onChange2,
             style: {
                 display: "flex",
                 justifyContent: "center"
             }
         });
     }
-    const HeaderOptionsIcon = styled__default.default(FontAwesomeIcon)`
+    const HeaderOptionsIcon$1 = styled__default.default(FontAwesomeIcon)`
     cursor: pointer;
     align-items: center;
     color: ${(props) => props.theme.colors.grey5};
 `;
-    const HeaderOptions = styled__default.default.div`
+    const HeaderOptions$1 = styled__default.default.div`
     display: flex;
     align-items: center;
     justify-content: center;
 
     width: 12px;
 
     background-color: ${(props) => props.theme.colors.grey3};
 `;
-    const OptionsDropdownList = styled__default.default(List)`
+    const OptionsDropdownList$1 = styled__default.default(List$1)`
     background-color: ${(props) => props.theme.colors.background};
     box-shadow: ${(props) => props.theme.shadow.light};
 `;
-    const OptionsMenu = ({
+    const OptionsMenu$1 = ({
         allColumns,
         allowColumnHiding,
         numVisibleColumns,
         resetResizing,
         setAllFilters,
         style: style2
     }) => {
         const [optionsElement, setOptionsElement] = React.useState(null);
         const [popperElement, setPopperElement] = React.useState(null);
         const [showOptions, setShowOptions] = React.useState(false);
         const {
             styles: styles2,
             attributes: attributes2,
             update: update2
-        } = usePopper$1(optionsElement, popperElement, {
+        } = usePopper$2(optionsElement, popperElement, {
             placement: "left-end"
         });
         const toggleOptions = () => {
             setShowOptions(!showOptions);
         };
         const onOptionSelect = (option) => {
             option.onClick();
         };
         const clickOutsideOptionsHandler = () => {
             if (showOptions) {
                 toggleOptions();
             }
         };
-        useOnClickOutside(popperElement, clickOutsideOptionsHandler);
+        useOnClickOutside$1(popperElement, clickOutsideOptionsHandler);
         React.useEffect(() => {
             if (showOptions) {
                 update2();
             }
         }, [showOptions, update2]);
         const resetFunctions = React.useMemo(() => {
             const functions2 = {
@@ -46261,53 +46242,53 @@
                     label: `${column.isVisible ? "Hide" : "Show"} ${String(column.Header)}`,
                     onClick: () => !(column.isVisible && numVisibleColumns === 1) ? column.toggleHidden() : null,
                     value: `${column.isVisible ? "hide" : "show"}${String(column.Header)}`
                 })),
                 label: "Columns"
             };
         }, [allColumns, allowColumnHiding, numVisibleColumns]);
-        return jsxRuntime.exports.jsxs(HeaderOptions, {
+        return jsxRuntime.exports.jsxs(HeaderOptions$1, {
             ref: setOptionsElement,
-            children: [jsxRuntime.exports.jsx(HeaderOptionsIcon, {
+            children: [jsxRuntime.exports.jsx(HeaderOptionsIcon$1, {
                 icon: faEllipsisV,
                 onClick: toggleOptions
-            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList, Object.assign({}, attributes2.popper, {
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList$1, Object.assign({}, attributes2.popper, {
                 isOpen: showOptions,
                 ref: setPopperElement,
                 style: Object.assign(Object.assign(Object.assign({}, styles2.popper), {
                     maxHeight: 800,
                     minWidth: 150,
                     zIndex: 9999
                 }), style2),
-                children: jsxRuntime.exports.jsx(SectionedList, {
+                children: jsxRuntime.exports.jsx(SectionedList$1, {
                     items: allowColumnHiding ? [resetFunctions, columnToggles] : [resetFunctions],
                     onSelect: onOptionSelect
                 })
             })), document.body)]
         });
     };
-    var __rest$7 = globalThis && globalThis.__rest || function(s2, e3) {
+    var __rest$d = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
     const {
-        fontSize
+        fontSize: fontSize$1
     } = window.getComputedStyle(document.documentElement);
-    const ROW_HEIGHT = parseFloat(fontSize) * 2.5;
-    const shouldForwardProp = (prop) => !["isSorted", "onClickRow"].includes(prop);
-    const Row$1 = styled__default.default.div.withConfig({
-        shouldForwardProp
+    const ROW_HEIGHT$1 = parseFloat(fontSize$1) * 2.5;
+    const shouldForwardProp$5 = (prop) => !["isSorted", "onClickRow"].includes(prop);
+    const Row$2 = styled__default.default.div.withConfig({
+        shouldForwardProp: shouldForwardProp$5
     })`
     cursor: ${(props) => props.onClickRow ? "pointer" : "default"};
     display: flex;
 
     :hover {
         div {
             background-color: ${(props) => props.theme.colors.grey1};
@@ -46317,23 +46298,23 @@
     :active,
     focused {
         div {
             background-color: ${(props) => props.theme.colors.grey2};
         }
     }
 `;
-    const RowPlaceholder = styled__default.default(Row$1)`
+    const RowPlaceholder$1 = styled__default.default(Row$2)`
     position: absolute;
     left: 0px;
 
     display: flex;
     align-items: center;
     justify-content: center;
 `;
-    const CellPlaceholder = styled__default.default.div`
+    const CellPlaceholder$1 = styled__default.default.div`
     min-width: 80px;
     height: 0.7rem;
     margin: 0.5rem;
 
     background: ${(props) => `linear-gradient(to right, ${props.theme.colors.grey2}, ${curriedTransparentize$2(0.2, props.theme.colors.grey3)}, ${props.theme.colors.grey2});`};
     background-size: 50%;
     border-radius: 0.5rem;
@@ -46349,44 +46330,44 @@
         }
 
         100% {
             background-position: 100% 0;
         }
     }
 `;
-    const Cell = styled__default.default.div`
+    const Cell$1 = styled__default.default.div`
     display: flex !important;
     align-items: center;
 
     min-width: 80px;
-    height: ${() => `${ROW_HEIGHT}px`};
+    height: ${() => `${ROW_HEIGHT$1}px`};
 
     color: ${(props) => props.theme.colors.grey6};
 
     background-color: ${(props) => props.theme.colors.blue1};
     border-bottom: 1px solid ${(props) => props.theme.colors.grey3};
 
     :last-child {
         border-right: 0;
     }
 `;
-    const CellContent = styled__default.default.span`
+    const CellContent$1 = styled__default.default.span`
     overflow: hidden;
 
     width: 100%;
     padding: 0 1rem;
 
     text-overflow: ellipsis;
     white-space: nowrap;
 `;
-    const arePropsEqual = (prevProps, nextProps) => {
+    const arePropsEqual$1 = (prevProps, nextProps) => {
         var _a3;
-        return areEqual(prevProps, nextProps) && !(((_a3 = nextProps.data) === null || _a3 === void 0 ? void 0 : _a3.headerGroups) || []).some((headerGroup) => ((headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers) || []).some((header) => header.isResizing));
+        return areEqual$1(prevProps, nextProps) && !(((_a3 = nextProps.data) === null || _a3 === void 0 ? void 0 : _a3.headerGroups) || []).some((headerGroup) => ((headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers) || []).some((header) => header.isResizing));
     };
-    const RenderRow = React__namespace.memo(({
+    const RenderRow$1 = React__namespace.memo(({
         data: {
             width,
             currentEditCell,
             headerGroups,
             rows,
             prepareRow,
             getItem,
@@ -46407,24 +46388,24 @@
             } else {
                 row.original = value;
                 row.values = value;
             }
         }
         if (!row) {
             return jsxRuntime.exports.jsx("div", {
-                children: headerGroups.map((headerGroup, gidx) => jsxRuntime.exports.jsx(RowPlaceholder, {
+                children: headerGroups.map((headerGroup, gidx) => jsxRuntime.exports.jsx(RowPlaceholder$1, {
                     style: {
-                        height: ROW_HEIGHT,
-                        top: (index2 + 1) * ROW_HEIGHT,
+                        height: ROW_HEIGHT$1,
+                        top: (index2 + 1) * ROW_HEIGHT$1,
                         width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
                     },
                     children: headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers.map((col, cidx) => {
                         const headerProps = col.getHeaderProps();
                         const headerWidth = headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width;
-                        return jsxRuntime.exports.jsx(CellPlaceholder, {
+                        return jsxRuntime.exports.jsx(CellPlaceholder$1, {
                             style: {
                                 maxWidth: col.maxWidth,
                                 width: headerWidth
                             }
                         }, `col-${index2}-${cidx}`);
                     })
                 }, `row-${gidx}`))
@@ -46438,60 +46419,60 @@
         };
         const _a3 = row.getRowProps({
                 style: renderRowStyle
             }),
             {
                 style: rowStyle
             } = _a3,
-            restRow = __rest$7(_a3, ["style"]);
-        return React.createElement(Row$1, Object.assign({}, restRow, {
+            restRow = __rest$d(_a3, ["style"]);
+        return React.createElement(Row$2, Object.assign({}, restRow, {
             key: `row-${index2}`,
             onClick,
             onClickRow,
             style: Object.assign(Object.assign({}, rowStyle), {
-                top: (index2 + 1) * ROW_HEIGHT,
+                top: (index2 + 1) * ROW_HEIGHT$1,
                 width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
             })
         }), row.cells.map((cell, colIdx) => {
             var _a4;
             const cellProps = cell.getCellProps();
             return React.createElement(
-                Cell,
+                Cell$1,
                 Object.assign({}, cellProps, {
                     key: `cell-${index2}-${colIdx}`,
                     style: Object.assign(Object.assign({}, cellProps.style), {
                         backgroundColor,
                         justifyContent: mappedColumns[colIdx].align,
                         maxWidth: (_a4 = cell.column) === null || _a4 === void 0 ? void 0 : _a4.maxWidth,
                         width: cellProps.style.width === "NaNpx" ? mappedColumns[colIdx].width : cellProps.style.width
                     })
                 }),
-                jsxRuntime.exports.jsx(CellContent, {
+                jsxRuntime.exports.jsx(CellContent$1, {
                     children: cell.render("Cell", {
                         colIdx,
                         currentEditCell,
                         rowIdx: index2
                     })
                 })
             );
         }));
-    }, arePropsEqual);
-    var __rest$6 = globalThis && globalThis.__rest || function(s2, e3) {
+    }, arePropsEqual$1);
+    var __rest$c = globalThis && globalThis.__rest || function(s2, e3) {
         var t2 = {};
         for (var p2 in s2)
             if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
                 t2[p2] = s2[p2];
         if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
             for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                 if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                     t2[p2[i2]] = s2[p2[i2]];
             }
         return t2;
     };
-    const Wrapper$4 = styled__default.default.div`
+    const Wrapper$a = styled__default.default.div`
     display: inline-block;
     width: 100%;
     max-width: 100%;
     padding: 1rem;
     ${(props) => !props.$hasMaxRows && `flex: 1 1 auto;`}
     &.sticky {
         [data-sticky-td] {
@@ -46501,15 +46482,15 @@
             box-shadow: 4px 0px 4px -3px ${(props) => props.theme.colors.shadowMedium};
         }
         [data-sticky-first-right-td] {
             box-shadow: -4px 0px 4px -3px ${(props) => props.theme.colors.shadowMedium};
         }
     }
 `;
-    const StyledFixedSizeList = styled__default.default(FixedSizeList)`
+    const StyledFixedSizeList$1 = styled__default.default(FixedSizeList$1)`
     /* this adds a fixed box shadow underneath the header */
     :before {
         content: '';
 
         position: sticky;
         z-index: 5;
         top: calc(2.5rem - 2px);
@@ -46520,162 +46501,162 @@
         display: block;
 
         height: 1px;
 
         box-shadow: 0px 3px 3px ${(props) => props.theme.colors.shadowLight};
     }
 `;
-    const Header = styled__default.default.div`
+    const Header$1 = styled__default.default.div`
     position: sticky;
     z-index: 4;
     top: 0;
 
     flex-direction: column;
 
     width: fit-content;
     min-width: 80px;
     /* needed as before box shadow pushes this dows by 1px */
     margin-top: -1px;
 `;
-    const HeaderRow = styled__default.default.div`
+    const HeaderRow$1 = styled__default.default.div`
     display: flex;
 `;
-    const HeaderCell = styled__default.default.div`
+    const HeaderCell$1 = styled__default.default.div`
     user-select: none;
 
     display: flex !important;
     align-items: center;
     justify-content: space-between;
 
     min-width: 80px;
-    height: ${ROW_HEIGHT}px;
+    height: ${ROW_HEIGHT$1}px;
 
     color: ${(props) => props.theme.colors.text};
 
     background-color: ${(props) => props.theme.colors.blue3};
     :not(:last-child) {
         border-right: 1px solid ${(props) => props.theme.colors.background};
     }
 
     :hover {
         .tableSortArrow {
             color: ${(props) => props.theme.colors.grey3};
         }
     }
 `;
-    const HeaderContentWrapper = styled__default.default.span`
+    const HeaderContentWrapper$1 = styled__default.default.span`
     overflow: hidden;
     flex: 1 1 auto;
 
     padding-left: ${(props) => props.isPrimitiveHeader ? "1rem" : void 0};
 
     text-overflow: ellipsis;
     white-space: nowrap;
 `;
-    const HeaderTooltipContainer = styled__default.default.div`
+    const HeaderTooltipContainer$1 = styled__default.default.div`
     display: flex;
     gap: 0.5rem;
     align-items: center;
     justify-content: center;
 
     width: ${(props) => props.isPrimitiveHeader ? void 0 : "100%"};
     max-width: ${(props) => props.isPrimitiveHeader ? "calc(100% - 3rem)" : void 0};
 `;
-    const HeaderCellButtonContainer = styled__default.default.div`
+    const HeaderCellButtonContainer$1 = styled__default.default.div`
     display: flex;
     flex-direction: row;
     height: 100%;
 `;
-    const HeaderIconsWrapper = styled__default.default.div`
+    const HeaderIconsWrapper$1 = styled__default.default.div`
     display: flex;
     align-items: center;
     justify-content: space-between;
     justify-self: flex-end;
 `;
-    const ResizeBorder = styled__default.default.div`
+    const ResizeBorder$1 = styled__default.default.div`
     /* prevents from scrolling while dragging on touch devices */
     touch-action: none;
     width: 10px;
     height: 100%;
 `;
-    const SortIcon = styled__default.default(FontAwesomeIcon).withConfig({
-        shouldForwardProp
+    const SortIcon$1 = styled__default.default(FontAwesomeIcon).withConfig({
+        shouldForwardProp: shouldForwardProp$5
     })`
     color: ${(props) => props.isSorted ? props.theme.colors.grey3 : props.theme.colors.blue3};
 `;
-    const TooltipIcon = styled__default.default(FontAwesomeIcon)`
+    const TooltipIcon$1 = styled__default.default(FontAwesomeIcon)`
     color: ${(props) => props.theme.colors.grey4};
 `;
-    const getSortIcon = (isSorted, isSortedDesc) => {
+    const getSortIcon$1 = (isSorted, isSortedDesc) => {
         if (!isSorted) {
             return faArrowUp;
         }
         return isSortedDesc ? faArrowDown : faArrowUp;
     };
-    const getSortKey = (sortBy, columns) => {
+    const getSortKey$1 = (sortBy, columns) => {
         return sortBy.map((sort) => {
             var _a3;
             return Object.assign(Object.assign({}, sort), {
                 id: ((_a3 = columns.find((col) => col.accessor === sort.id)) === null || _a3 === void 0 ? void 0 : _a3.sortKey) || sort.id
             });
         });
     };
-    const orderStickyCols = (columns) => {
+    const orderStickyCols$1 = (columns) => {
         const leftStickyCols = [];
         const nonStickyCols = [];
         const rightStickyCols = [];
         columns.forEach((col) => {
             if (col.sticky === "left") {
                 leftStickyCols.push(col);
             } else if (col.sticky === "right") {
                 rightStickyCols.push(col);
             } else {
                 nonStickyCols.push(col);
             }
         });
         return [...leftStickyCols, ...nonStickyCols, ...rightStickyCols];
     };
-    const filterComponentMap = {
-        categorical: CategoricalFilter,
-        datetime: DatetimeFilter,
-        numeric: NumericFilter,
-        text: TextFilter
+    const filterComponentMap$1 = {
+        categorical: CategoricalFilter$1,
+        datetime: DatetimeFilter$1,
+        numeric: NumericFilter$1,
+        text: TextFilter$1
     };
-    const appendFilterComponents = (columns) => {
+    const appendFilterComponents$1 = (columns) => {
         return columns.map((col) => {
             if (!col.filter) {
                 return col;
             }
-            if (!(col.filter in filterComponentMap)) {
-                throw new Error(`Invalid filter ${col.filter} encountered in column ${col.id}, only ${Object.keys(filterComponentMap).join(",")} are supported`);
+            if (!(col.filter in filterComponentMap$1)) {
+                throw new Error(`Invalid filter ${col.filter} encountered in column ${col.id}, only ${Object.keys(filterComponentMap$1).join(",")} are supported`);
             }
             return Object.assign(Object.assign({}, col), {
-                Filter: filterComponentMap[col.filter]
+                Filter: filterComponentMap$1[col.filter]
             });
         });
     };
-    const cells = {
-        DATETIME: DatetimeCell,
-        EDIT_INPUT: EditInputCell,
-        EDIT_SELECT: EditSelectCell
+    const cells$1 = {
+        DATETIME: DatetimeCell$1,
+        EDIT_INPUT: EditInputCell$1,
+        EDIT_SELECT: EditSelectCell$1
     };
-    const createItemData = memoizeOne$1((width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns) => ({
+    const createItemData$1 = memoizeOne$1((width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns) => ({
         backgroundColor,
         currentEditCell,
         getItem,
         headerGroups,
         mappedColumns,
         onClickRow,
         prepareRow,
         rows,
         throttledClickRow,
         totalColumnsWidth,
         width
     }));
-    const Table$1 = React.forwardRef(({
+    const Table$2 = React.forwardRef(({
         allowHiding,
         backgroundColor,
         className,
         columns,
         data: data2,
         getItem,
         initialSort = [],
@@ -46690,44 +46671,44 @@
         showTableOptions,
         style: style2,
         tableOptionsStyle
     }, ref2) => {
         const [currentSortBy, setCurrentSortBy] = React.useState(initialSort);
         React.useEffect(() => {
             setCurrentSortBy(initialSort);
-        }, useDeepCompare([initialSort]));
+        }, useDeepCompare$1([initialSort]));
         if (!data2 && !getItem) {
             throw new Error("One of data and getItem must be passed to the table component");
         }
         if (getItem && (!onItemsRendered || !Number.isFinite(itemCount))) {
             throw new Error("itemCount and onItemsRendered must also be passed when using the table in infinite mode");
         }
-        const [currentEditCell, throttledSetEditCell, immediateSetEditCell] = useThrottledState(void 0, 500);
-        const throttledClickRow = useThrottle(onClickRow, 500);
+        const [currentEditCell, throttledSetEditCell, immediateSetEditCell] = useThrottledState$1(void 0, 500);
+        const throttledClickRow = useThrottle$1(onClickRow, 500);
         const onStopEdit = () => {
             throttledSetEditCell(void 0);
         };
         const onStartEdit = (e3) => {
             var _a3, _b;
             const cell = (_b = (_a3 = e3 === null || e3 === void 0 ? void 0 : e3.currentTarget) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("data-cell")) === null || _b === void 0 ? void 0 : _b.split(",");
             if (!cell || (cell === null || cell === void 0 ? void 0 : cell.length) !== 2) {
                 throttledSetEditCell(void 0);
                 return;
             }
             immediateSetEditCell([Number(cell[0]), cell[1]]);
             throttledSetEditCell([Number(cell[0]), cell[1]]);
         };
         const infiniteData = React.useMemo(() => Array(itemCount).fill(0), [itemCount]);
-        const mappedColumns = React.useMemo(() => appendFilterComponents(orderStickyCols(columns)), [columns]);
+        const mappedColumns = React.useMemo(() => appendFilterComponents$1(orderStickyCols$1(columns)), [columns]);
         const hasFixedColumns = React.useMemo(() => mappedColumns.some((column) => "sticky" in column), [mappedColumns]);
         const totalColumnsWidth = React.useMemo(() => mappedColumns.reduce((acc, column) => acc + (parseInt(column.width) || 150), 0), [mappedColumns]);
         const filterTypes = React.useMemo(() => ({
-            categorical,
-            datetime,
-            numeric
+            categorical: categorical$1,
+            datetime: datetime$1,
+            numeric: numeric$1
         }), []);
         const {
             getTableProps,
             getTableBodyProps,
             headerGroups,
             rows,
             prepareRow,
@@ -46757,143 +46738,143 @@
         React.useImperativeHandle(ref2, () => ({
             resetFilters() {
                 setAllFilters([]);
             }
         }));
         React.useEffect(() => {
             if (onSort) {
-                onSort(getSortKey(sortBy, mappedColumns));
+                onSort(getSortKey$1(sortBy, mappedColumns));
             } else {
                 setCurrentSortBy(sortBy);
             }
         }, [onSort, sortBy]);
         React.useEffect(() => {
             if (onFilter) {
                 onFilter(filters2);
             }
         }, [onFilter, filters2]);
         const tableProps = getTableBodyProps();
         const renderTable = React.useCallback((_a3) => {
             var {
                 children: children2,
                 style: tableStyle
-            } = _a3, rest = __rest$6(_a3, ["children", "style"]);
+            } = _a3, rest = __rest$c(_a3, ["children", "style"]);
             return jsxRuntime.exports.jsxs("div", {
-                children: [jsxRuntime.exports.jsx(Header, {
+                children: [jsxRuntime.exports.jsx(Header$1, {
                     style: {
                         width: `max(${totalColumnsWidth}px, 100%)`
                     },
-                    children: headerGroups.map((headerGroup, gidx) => React.createElement(HeaderRow, Object.assign({}, headerGroup.getHeaderGroupProps(), {
+                    children: headerGroups.map((headerGroup, gidx) => React.createElement(HeaderRow$1, Object.assign({}, headerGroup.getHeaderGroupProps(), {
                         key: `group-${gidx}`
                     }), headerGroup.headers.map((col, cidx) => {
                         const headerProps = col.getHeaderProps();
                         const sortProps = col.getSortByToggleProps();
                         const headerContent = col.render("Header");
                         const resizerProps = col.getResizerProps();
                         const numVisibleColumns = allColumns.filter((column) => column.isVisible).length;
                         const showSort = !col.disableSortBy;
                         const showFilter = col.canFilter && col.filter;
                         const showOptions = cidx === numVisibleColumns - 1 && showTableOptions;
                         const showHeaderCellButtonContainer = showSort || showFilter || showOptions;
                         return React.createElement(
-                            HeaderCell,
+                            HeaderCell$1,
                             Object.assign({}, headerProps, {
                                 key: `col-${gidx}-${cidx}`,
                                 style: Object.assign(Object.assign({}, headerProps.style), {
                                     maxWidth: col.maxWidth,
                                     width: headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width
                                 })
                             }),
-                            jsxRuntime.exports.jsxs(HeaderTooltipContainer, {
+                            jsxRuntime.exports.jsxs(HeaderTooltipContainer$1, {
                                 isPrimitiveHeader: typeof headerContent === "string",
-                                children: [jsxRuntime.exports.jsx(HeaderContentWrapper, Object.assign({}, sortProps, {
+                                children: [jsxRuntime.exports.jsx(HeaderContentWrapper$1, Object.assign({}, sortProps, {
                                     isPrimitiveHeader: typeof headerContent === "string",
                                     title: typeof headerContent === "string" ? headerContent : "",
                                     children: headerContent
-                                })), col.tooltip && jsxRuntime.exports.jsx(Tooltip$1, {
+                                })), col.tooltip && jsxRuntime.exports.jsx(Tooltip$2, {
                                     content: col.tooltip,
-                                    children: jsxRuntime.exports.jsx(TooltipIcon, {
+                                    children: jsxRuntime.exports.jsx(TooltipIcon$1, {
                                         icon: faCircleQuestion
                                     })
                                 })]
                             }),
-                            showHeaderCellButtonContainer && jsxRuntime.exports.jsxs(HeaderCellButtonContainer, {
-                                children: [jsxRuntime.exports.jsxs(HeaderIconsWrapper, {
-                                    children: [showSort && jsxRuntime.exports.jsx(HeaderIconWrapper, {
-                                        children: jsxRuntime.exports.jsx(SortIcon, Object.assign({}, sortProps, {
+                            showHeaderCellButtonContainer && jsxRuntime.exports.jsxs(HeaderCellButtonContainer$1, {
+                                children: [jsxRuntime.exports.jsxs(HeaderIconsWrapper$1, {
+                                    children: [showSort && jsxRuntime.exports.jsx(HeaderIconWrapper$1, {
+                                        children: jsxRuntime.exports.jsx(SortIcon$1, Object.assign({}, sortProps, {
                                             className: "tableSortArrow",
-                                            icon: getSortIcon(col.isSorted, col.isSortedDesc),
+                                            icon: getSortIcon$1(col.isSorted, col.isSortedDesc),
                                             isSorted: col.isSorted
                                         }))
-                                    }), showFilter ? jsxRuntime.exports.jsx(FilterContainer, {
+                                    }), showFilter ? jsxRuntime.exports.jsx(FilterContainer$1, {
                                         col
-                                    }) : null, showOptions && jsxRuntime.exports.jsx(OptionsMenu, {
+                                    }) : null, showOptions && jsxRuntime.exports.jsx(OptionsMenu$1, {
                                         allColumns,
                                         allowColumnHiding: allowHiding,
                                         numVisibleColumns,
                                         resetResizing,
                                         setAllFilters,
                                         style: tableOptionsStyle
                                     })]
-                                }), jsxRuntime.exports.jsx(ResizeBorder, Object.assign({}, resizerProps))]
+                                }), jsxRuntime.exports.jsx(ResizeBorder$1, Object.assign({}, resizerProps))]
                             })
                         );
                     })))
                 }), React.createElement("div", Object.assign({}, tableProps, rest, {
                     key: "table-body-inner",
                     style: tableStyle
                 }), children2)]
             }, "table-inner");
-        }, useDeepCompare([tableProps, totalColumnsWidth, headerGroups]));
-        return jsxRuntime.exports.jsx(Wrapper$4, Object.assign({}, getTableProps(), {
+        }, useDeepCompare$1([tableProps, totalColumnsWidth, headerGroups]));
+        return jsxRuntime.exports.jsx(Wrapper$a, Object.assign({}, getTableProps(), {
             "$hasMaxRows": !!maxRows,
             className: `${className} ${hasFixedColumns ? "sticky" : ""}`,
             style: Object.assign({
-                height: maxRows ? (Math.min(rows.length, maxRows) + 1) * ROW_HEIGHT : "100%"
+                height: maxRows ? (Math.min(rows.length, maxRows) + 1) * ROW_HEIGHT$1 : "100%"
             }, style2),
             children: jsxRuntime.exports.jsx(AutoSizer, {
                 children: ({
                     height,
                     width
                 }) => {
-                    return jsxRuntime.exports.jsx(StyledFixedSizeList, {
+                    return jsxRuntime.exports.jsx(StyledFixedSizeList$1, {
                         height,
                         innerElementType: renderTable,
                         itemCount: itemCount || rows.length,
-                        itemData: createItemData(width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns),
-                        itemSize: ROW_HEIGHT,
+                        itemData: createItemData$1(width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns),
+                        itemSize: ROW_HEIGHT$1,
                         onItemsRendered,
                         style: {
                             overflowX: width < totalColumnsWidth ? "auto" : "hidden",
-                            overflowY: height < (rows.length + 1) * ROW_HEIGHT ? "auto" : "hidden"
+                            overflowY: height < (rows.length + 1) * ROW_HEIGHT$1 ? "auto" : "hidden"
                         },
                         width,
-                        children: RenderRow
+                        children: RenderRow$1
                     }, "table-list");
                 }
             })
         }));
     });
-    Table$1.displayName = "Table";
-    Table$1.ActionColumn = (actions, accessor, sticky, disableSelectAll = false) => {
-        const width = actions.includes(Actions.SELECT) ? 52 : actions.length * 24 + 24;
+    Table$2.displayName = "Table";
+    Table$2.ActionColumn = (actions, accessor, sticky, disableSelectAll = false) => {
+        const width = actions.includes(Actions$1.SELECT) ? 52 : actions.length * 24 + 24;
         return {
-            Cell: ActionCell,
-            Header: actions.includes(Actions.SELECT) && !disableSelectAll ? SelectHeader : "",
+            Cell: ActionCell$1,
+            Header: actions.includes(Actions$1.SELECT) && !disableSelectAll ? SelectHeader$1 : "",
             accessor: accessor || "actions",
             actions,
             disableSortBy: true,
             maxWidth: width,
-            minWidth: actions.includes(Actions.SELECT) ? 52 : 48,
+            minWidth: actions.includes(Actions$1.SELECT) ? 52 : 48,
             sticky: sticky || null,
             width
         };
     };
-    Table$1.Actions = Actions;
-    Table$1.cells = cells;
+    Table$2.Actions = Actions$1;
+    Table$2.cells = cells$1;
     const TabWrapper = styled__default.default.div`
     overflow: hidden;
     display: flex;
     /* This is needed as the content of a TabbedCard overflows for the wrapper to not shrink */
     flex-shrink: 0;
 
     width: 100%;
@@ -46978,18 +46959,18 @@
 
     width: 100%;
     padding-right: 0.5rem;
 `;
     const StyledAccordion = core$2.injectCss(Accordion$1);
 
     function headerRenderer(item) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         return /* @__PURE__ */ React__default.default.createElement(StyledHeader, null, typeof item.label === "string" ? /* @__PURE__ */ React__default.default.createElement("span", null, item.label) : /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
             component: item.label
-        }), item.badge && /* @__PURE__ */ React__default.default.createElement(Badge, {
+        }), item.badge && /* @__PURE__ */ React__default.default.createElement(Badge$1, {
             color: item.badge.color || theme2.colors.primary,
             height: 24,
             width: "10rem"
         }, item.badge.label));
     }
     const innerRender = (item) => {
         return /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
@@ -47162,19 +47143,19 @@
         if (isCondition(arg)) {
             const value = core$2.useVariable(arg.variable)[0];
             const other = core$2.useVariable(arg.other)[0];
             return isConditionTrue(arg.operator, value, other);
         }
         return core$2.useVariable(arg)[0];
     }
-    const StyledButton$1 = core$2.injectCss(styled__default.default(Button$3)`
+    const StyledButton$1 = core$2.injectCss(styled__default.default(Button$5)`
     flex: ${(props) => props.isSimpleButton ? void 0 : "1 1 100%"};
 `);
 
-    function Button(props) {
+    function Button$2(props) {
         var _a3, _b, _c, _d;
         const [style2, css2] = core$2.useComponentStyles(props);
         const [onClick, loading] = core$2.useAction(props.onclick);
         const disabled2 = useConditionOrVariable(props.disabled);
         const Icon2 = props.icon ? core$2.getIcon(props.icon) : null;
         const iconColor = Array.isArray(props.children) ? ((_c = (_b = (_a3 = props.children) == null ? void 0 : _a3[0]) == null ? void 0 : _b.props) == null ? void 0 : _c.color) || "inherit" : "inherit";
         return /* @__PURE__ */ React__default.default.createElement(
@@ -47703,46 +47684,14 @@
         return curried$1(f2, f2.length, []);
     }
 
     function guard$1(lowerBoundary, upperBoundary, value) {
         return Math.max(lowerBoundary, Math.min(upperBoundary, value));
     }
 
-    function mix$2(weight, color2, otherColor) {
-        if (color2 === "transparent")
-            return otherColor;
-        if (otherColor === "transparent")
-            return color2;
-        if (weight === 0)
-            return otherColor;
-        var parsedColor1 = parseToRgb$1(color2);
-        var color1 = _extends$1({}, parsedColor1, {
-            alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
-        });
-        var parsedColor2 = parseToRgb$1(otherColor);
-        var color22 = _extends$1({}, parsedColor2, {
-            alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
-        });
-        var alphaDelta = color1.alpha - color22.alpha;
-        var x2 = parseFloat(weight) * 2 - 1;
-        var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
-        var z2 = 1 + x2 * alphaDelta;
-        var weight1 = (y2 / z2 + 1) / 2;
-        var weight2 = 1 - weight1;
-        var mixedColor = {
-            red: Math.floor(color1.red * weight1 + color22.red * weight2),
-            green: Math.floor(color1.green * weight1 + color22.green * weight2),
-            blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
-            alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
-        };
-        return rgba$3(mixedColor);
-    }
-    var curriedMix$1 = /* @__PURE__ */ curry$1(mix$2);
-    var mix$1$1 = curriedMix$1;
-
     function transparentize$1(amount, color2) {
         if (color2 === "transparent")
             return color2;
         var parsedColor = parseToRgb$1(color2);
         var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
         var colorWithAlpha = _extends$1({}, parsedColor, {
             alpha: guard$1(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
@@ -47906,17 +47855,17 @@
                 }
             }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
                 component: child,
                 key: `cell-${idx}-${child.uid}`
             })))
         );
     }
-    const StyledCheckbox = core$2.injectCss(CheckboxGroup$1);
+    const StyledCheckbox$1 = core$2.injectCss(CheckboxGroup$2);
 
-    function CheckboxGroup(props) {
+    function CheckboxGroup$1(props) {
         const formCtx2 = useFormContext(props);
         const [items] = core$2.useVariable(props.items);
         const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue([]));
         const [style2, css2] = core$2.useComponentStyles(props);
         const [onChangeAction] = core$2.useAction(props.onchange);
         const onChange2 = React.useCallback(
             (values) => {
@@ -47929,15 +47878,15 @@
                 setValue(newValues);
                 onChangeAction(newValues);
                 formCtx2.updateForm(newValues);
             },
             [setValue]
         );
         return /* @__PURE__ */ React__default.default.createElement(
-            StyledCheckbox, {
+            StyledCheckbox$1, {
                 $rawCss: css2,
                 className: props.className,
                 isListStyle: props.list_styling,
                 items,
                 onChange: onChange2,
                 selectMax: props.select_max,
                 selectMin: props.select_min,
@@ -48098,23 +48047,23 @@
                             }
                         }
                     }
                 }
             },
             plugins: {},
             highlight: function(text2, grammar, language2) {
-                var env = {
+                var env2 = {
                     code: text2,
                     grammar,
                     language: language2
                 };
-                _2.hooks.run("before-tokenize", env);
-                env.tokens = _2.tokenize(env.code, env.grammar);
-                _2.hooks.run("after-tokenize", env);
-                return Token.stringify(_2.util.encode(env.tokens), env.language);
+                _2.hooks.run("before-tokenize", env2);
+                env2.tokens = _2.tokenize(env2.code, env2.grammar);
+                _2.hooks.run("after-tokenize", env2);
+                return Token.stringify(_2.util.encode(env2.tokens), env2.language);
             },
             tokenize: function(text2, grammar) {
                 var rest = grammar.rest;
                 if (rest) {
                     for (var token in rest) {
                         grammar[token] = rest[token];
                     }
@@ -48128,21 +48077,21 @@
             hooks: {
                 all: {},
                 add: function(name2, callback) {
                     var hooks = _2.hooks.all;
                     hooks[name2] = hooks[name2] || [];
                     hooks[name2].push(callback);
                 },
-                run: function(name2, env) {
+                run: function(name2, env2) {
                     var callbacks = _2.hooks.all[name2];
                     if (!callbacks || !callbacks.length) {
                         return;
                     }
                     for (var i2 = 0, callback; callback = callbacks[i2++];) {
-                        callback(env);
+                        callback(env2);
                     }
                 }
             },
             Token
         };
 
         function Token(type2, content2, alias, matchedStr) {
@@ -48158,36 +48107,36 @@
             if (Array.isArray(o2)) {
                 var s2 = "";
                 o2.forEach(function(e3) {
                     s2 += stringify2(e3, language2);
                 });
                 return s2;
             }
-            var env = {
+            var env2 = {
                 type: o2.type,
                 content: stringify2(o2.content, language2),
                 tag: "span",
                 classes: ["token", o2.type],
                 attributes: {},
                 language: language2
             };
             var aliases = o2.alias;
             if (aliases) {
                 if (Array.isArray(aliases)) {
-                    Array.prototype.push.apply(env.classes, aliases);
+                    Array.prototype.push.apply(env2.classes, aliases);
                 } else {
-                    env.classes.push(aliases);
+                    env2.classes.push(aliases);
                 }
             }
-            _2.hooks.run("wrap", env);
+            _2.hooks.run("wrap", env2);
             var attributes2 = "";
-            for (var name2 in env.attributes) {
-                attributes2 += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
+            for (var name2 in env2.attributes) {
+                attributes2 += " " + name2 + '="' + (env2.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
             }
-            return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes2 + ">" + env.content + "</" + env.tag + ">";
+            return "<" + env2.tag + ' class="' + env2.classes.join(" ") + '"' + attributes2 + ">" + env2.content + "</" + env2.tag + ">";
         };
 
         function matchPattern(pattern, pos, text2, lookbehind) {
             pattern.lastIndex = pos;
             var match2 = pattern.exec(text2);
             if (match2 && lookbehind && match2[1]) {
                 var lookbehindLength = match2[1].length;
@@ -48414,17 +48363,17 @@
         "entity": [{
             pattern: /&[\da-z]{1,8};/i,
             alias: "named-entity"
         }, /&#x?[\da-f]{1,8};/i]
     };
     prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = prism.languages.markup["entity"];
     prism.languages.markup["doctype"].inside["internal-subset"].inside = prism.languages.markup;
-    prism.hooks.add("wrap", function(env) {
-        if (env.type === "entity") {
-            env.attributes["title"] = env.content.replace(/&amp;/, "&");
+    prism.hooks.add("wrap", function(env2) {
+        if (env2.type === "entity") {
+            env2.attributes["title"] = env2.content.replace(/&amp;/, "&");
         }
     });
     Object.defineProperty(prism.languages.markup.tag, "addInlined", {
         value: function addInlined(tagName, lang) {
             var includedCdataInside = {};
             includedCdataInside["language-" + lang] = {
                 pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
@@ -49410,16 +49359,16 @@
         ["url", "bold", "italic", "strike"].forEach(function(token) {
             ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside2) {
                 if (token !== inside2) {
                     Prism2.languages.markdown[token].inside.content.inside[inside2] = Prism2.languages.markdown[inside2];
                 }
             });
         });
-        Prism2.hooks.add("after-tokenize", function(env) {
-            if (env.language !== "markdown" && env.language !== "md") {
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            if (env2.language !== "markdown" && env2.language !== "md") {
                 return;
             }
 
             function walkTokens(tokens2) {
                 if (!tokens2 || typeof tokens2 === "string") {
                     return;
                 }
@@ -49441,43 +49390,43 @@
                             codeBlock.alias = [codeBlock.alias, alias];
                         } else {
                             codeBlock.alias.push(alias);
                         }
                     }
                 }
             }
-            walkTokens(env.tokens);
+            walkTokens(env2.tokens);
         });
-        Prism2.hooks.add("wrap", function(env) {
-            if (env.type !== "code-block") {
+        Prism2.hooks.add("wrap", function(env2) {
+            if (env2.type !== "code-block") {
                 return;
             }
             var codeLang = "";
-            for (var i2 = 0, l2 = env.classes.length; i2 < l2; i2++) {
-                var cls = env.classes[i2];
+            for (var i2 = 0, l2 = env2.classes.length; i2 < l2; i2++) {
+                var cls = env2.classes[i2];
                 var match2 = /language-(.+)/.exec(cls);
                 if (match2) {
                     codeLang = match2[1];
                     break;
                 }
             }
             var grammar = Prism2.languages[codeLang];
             if (!grammar) {
                 if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
                     var id2 = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
-                    env.attributes["id"] = id2;
+                    env2.attributes["id"] = id2;
                     Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
                         var ele = document.getElementById(id2);
                         if (ele) {
                             ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
                         }
                     });
                 }
             } else {
-                env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
+                env2.content = Prism2.highlight(textContent(env2.content), grammar, codeLang);
             }
         });
         var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
         var KNOWN_ENTITY_NAMES = {
             "amp": "&",
             "lt": "<",
             "gt": ">",
@@ -49566,19 +49515,19 @@
         "keyword": /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
         "operator": /[!=|&]|\.{3}/,
         "property-query": /\w+(?=\s*\()/,
         "object": /\w+(?=\s*\{)/,
         "punctuation": /[!(){}\[\]:=,]/,
         "property": /\w+/
     };
-    prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env) {
-        if (env.language !== "graphql") {
+    prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env2) {
+        if (env2.language !== "graphql") {
             return;
         }
-        var validTokens = env.tokens.filter(function(token) {
+        var validTokens = env2.tokens.filter(function(token) {
             return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
         });
         var currentIndex = 0;
 
         function getToken(offset2) {
             return validTokens[currentIndex + offset2];
         }
@@ -49727,23 +49676,23 @@
         ].filter(Boolean);
 
         function getPlaceholder(counter2, language2) {
             return "___" + language2.toUpperCase() + "_" + counter2 + "___";
         }
 
         function tokenizeWithHooks(code2, grammar, language2) {
-            var env = {
+            var env2 = {
                 code: code2,
                 grammar,
                 language: language2
             };
-            Prism2.hooks.run("before-tokenize", env);
-            env.tokens = Prism2.tokenize(env.code, env.grammar);
-            Prism2.hooks.run("after-tokenize", env);
-            return env.tokens;
+            Prism2.hooks.run("before-tokenize", env2);
+            env2.tokens = Prism2.tokenize(env2.code, env2.grammar);
+            Prism2.hooks.run("after-tokenize", env2);
+            return env2.tokens;
         }
 
         function tokenizeInterpolationExpression(expression) {
             var tempGrammar = {};
             tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
             var tokens2 = Prism2.tokenize(expression, tempGrammar);
             if (tokens2.length === 3) {
@@ -49827,16 +49776,16 @@
             "javascript": true,
             "js": true,
             "typescript": true,
             "ts": true,
             "jsx": true,
             "tsx": true
         };
-        Prism2.hooks.add("after-tokenize", function(env) {
-            if (!(env.language in supportedLanguages)) {
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            if (!(env2.language in supportedLanguages)) {
                 return;
             }
 
             function findTemplateStrings(tokens2) {
                 for (var i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
                     var token = tokens2[i2];
                     if (typeof token === "string") {
@@ -49862,15 +49811,15 @@
                             content2[1] = tokenizeEmbedded(code2, grammar, language2);
                         }
                     } else {
                         findTemplateStrings(content2);
                     }
                 }
             }
-            findTemplateStrings(env.tokens);
+            findTemplateStrings(env2.tokens);
         });
 
         function stringContent2(value) {
             if (typeof value === "string") {
                 return value;
             } else if (Array.isArray(value)) {
                 return value.map(stringContent2).join("");
@@ -50121,19 +50070,19 @@
                     }
                 }
                 if (token.content && typeof token.content !== "string") {
                     walkTokens(token.content);
                 }
             }
         };
-        Prism2.hooks.add("after-tokenize", function(env) {
-            if (env.language !== "jsx" && env.language !== "tsx") {
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            if (env2.language !== "jsx" && env2.language !== "tsx") {
                 return;
             }
-            walkTokens(env.tokens);
+            walkTokens(env2.tokens);
         });
     })(prism);
     (function(Prism2) {
         Prism2.languages.diff = {
             "coord": [
                 /^(?:\*{3}|-{3}|\+{3}).*$/m,
                 /^@@.*@@$/m,
@@ -50215,59 +50164,59 @@
     delete prism.languages.go["class-name"];
     (function(Prism2) {
         function getPlaceholder(language2, index2) {
             return "___" + language2.toUpperCase() + index2 + "___";
         }
         Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
             buildPlaceholders: {
-                value: function(env, language2, placeholderPattern, replaceFilter) {
-                    if (env.language !== language2) {
+                value: function(env2, language2, placeholderPattern, replaceFilter) {
+                    if (env2.language !== language2) {
                         return;
                     }
-                    var tokenStack = env.tokenStack = [];
-                    env.code = env.code.replace(placeholderPattern, function(match2) {
+                    var tokenStack = env2.tokenStack = [];
+                    env2.code = env2.code.replace(placeholderPattern, function(match2) {
                         if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
                             return match2;
                         }
                         var i2 = tokenStack.length;
                         var placeholder;
-                        while (env.code.indexOf(placeholder = getPlaceholder(language2, i2)) !== -1) {
+                        while (env2.code.indexOf(placeholder = getPlaceholder(language2, i2)) !== -1) {
                             ++i2;
                         }
                         tokenStack[i2] = match2;
                         return placeholder;
                     });
-                    env.grammar = Prism2.languages.markup;
+                    env2.grammar = Prism2.languages.markup;
                 }
             },
             tokenizePlaceholders: {
-                value: function(env, language2) {
-                    if (env.language !== language2 || !env.tokenStack) {
+                value: function(env2, language2) {
+                    if (env2.language !== language2 || !env2.tokenStack) {
                         return;
                     }
-                    env.grammar = Prism2.languages[language2];
+                    env2.grammar = Prism2.languages[language2];
                     var j2 = 0;
-                    var keys2 = Object.keys(env.tokenStack);
+                    var keys2 = Object.keys(env2.tokenStack);
 
                     function walkTokens(tokens2) {
                         for (var i2 = 0; i2 < tokens2.length; i2++) {
                             if (j2 >= keys2.length) {
                                 break;
                             }
                             var token = tokens2[i2];
                             if (typeof token === "string" || token.content && typeof token.content === "string") {
                                 var k2 = keys2[j2];
-                                var t2 = env.tokenStack[k2];
+                                var t2 = env2.tokenStack[k2];
                                 var s2 = typeof token === "string" ? token : token.content;
                                 var placeholder = getPlaceholder(language2, k2);
                                 var index2 = s2.indexOf(placeholder);
                                 if (index2 > -1) {
                                     ++j2;
                                     var before = s2.substring(0, index2);
-                                    var middle = new Prism2.Token(language2, Prism2.tokenize(t2, env.grammar), "language-" + language2, t2);
+                                    var middle = new Prism2.Token(language2, Prism2.tokenize(t2, env2.grammar), "language-" + language2, t2);
                                     var after = s2.substring(index2 + placeholder.length);
                                     var replacement = [];
                                     if (before) {
                                         replacement.push.apply(replacement, walkTokens([before]));
                                     }
                                     replacement.push(middle);
                                     if (after) {
@@ -50281,15 +50230,15 @@
                                 }
                             } else if (token.content) {
                                 walkTokens(token.content);
                             }
                         }
                         return tokens2;
                     }
-                    walkTokens(env.tokens);
+                    walkTokens(env2.tokens);
                 }
             }
         });
     })(prism);
     (function(Prism2) {
         Prism2.languages.handlebars = {
             "comment": /\{\{![\s\S]*?\}\}/,
@@ -50311,20 +50260,20 @@
                     punctuation: /\[|\]/,
                     variable: /[\s\S]+/
                 }
             },
             "punctuation": /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
             "variable": /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
         };
-        Prism2.hooks.add("before-tokenize", function(env) {
+        Prism2.hooks.add("before-tokenize", function(env2) {
             var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
-            Prism2.languages["markup-templating"].buildPlaceholders(env, "handlebars", handlebarsPattern);
+            Prism2.languages["markup-templating"].buildPlaceholders(env2, "handlebars", handlebarsPattern);
         });
-        Prism2.hooks.add("after-tokenize", function(env) {
-            Prism2.languages["markup-templating"].tokenizePlaceholders(env, "handlebars");
+        Prism2.hooks.add("after-tokenize", function(env2) {
+            Prism2.languages["markup-templating"].tokenizePlaceholders(env2, "handlebars");
         });
         Prism2.languages.hbs = Prism2.languages.handlebars;
     })(prism);
     prism.languages.json = {
         "property": {
             pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
             lookbehind: true,
@@ -51126,23 +51075,23 @@
                 }
                 if (className) {
                     output2.className += " " + className;
                 }
                 return output2;
             });
             _defineProperty$l(this, "tokenize", function(Prism2, code2, grammar, language2) {
-                var env = {
+                var env2 = {
                     code: code2,
                     grammar,
                     language: language2,
                     tokens: []
                 };
-                Prism2.hooks.run("before-tokenize", env);
-                var tokens2 = env.tokens = Prism2.tokenize(env.code, env.grammar, env.language);
-                Prism2.hooks.run("after-tokenize", env);
+                Prism2.hooks.run("before-tokenize", env2);
+                var tokens2 = env2.tokens = Prism2.tokenize(env2.code, env2.grammar, env2.language);
+                Prism2.hooks.run("after-tokenize", env2);
                 return tokens2;
             });
         }
         if (Component)
             Highlight2.__proto__ = Component;
         Highlight2.prototype = Object.create(Component && Component.prototype);
         Highlight2.prototype.constructor = Highlight2;
@@ -51247,15 +51196,15 @@
 
     background-color: ${(props) => props.isLightTheme ? theme$3.colors.blue1 : darkTheme$1.colors.blue1} !important;
     border-radius: 0.25rem;
 `;
     const StyledCode = core$2.injectCss(StyledPre);
 
     function Code(props) {
-        const themeCtx = useClTheme();
+        const themeCtx = useClTheme$1();
         const [rootStyle, css2] = core$2.useComponentStyles(props);
         const [code2] = core$2.useVariable(props.code);
 
         function getTheme() {
             if (props.theme) {
                 if (props.theme === "light") {
                     return duotoneLight;
@@ -51388,15 +51337,15 @@
             }
             return parseDateString$1(value);
         }, [value, props.range]);
         return /* @__PURE__ */ React__default.default.createElement(StyledDatepickerDiv, {
             $rawCss: css2,
             style: style2
         }, /* @__PURE__ */ React__default.default.createElement(
-            DatePicker, {
+            DatePicker$1, {
                 dateFormat: props.date_format,
                 maxDate: parseDateString$1(props.max_date),
                 minDate: parseDateString$1(props.min_date),
                 onChange: onChange2,
                 popperStrategy: "fixed",
                 selectsRange: props.range,
                 shouldCloseOnSelect: props.select_close,
@@ -51427,29 +51376,29 @@
         const url2 = new URL("/api/core/data/upload", window.location.origin);
         if (variableId) {
             url2.searchParams.set("data_uid", variableId);
         }
         const res = await core$2.request(
             url2, {
                 body: formData,
-                method: HTTP_METHOD.POST
+                method: HTTP_METHOD$1.POST
             },
             extras
         );
         await validateResponse(res, `Failed to upload file: ${file.name}`);
         const result = await res.json();
         return {
             newStatus: result.status
         };
     }
     const StyledDropzone = core$2.injectCss(UploadDropzone$1);
     const StyledCenter = core$2.injectCss(core$2.Center);
 
     function UploadDropzone(props) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [style2, css2] = core$2.useComponentStyles(props);
         const [currentStatus, setCurrentStatus] = React.useState(status.INITIALIZED);
         const [errorMessage, setErrorMessage] = React.useState();
         const [onFileDrop] = core$2.useAction(props.on_drop);
         const extras = core$2.useRequestExtras();
         const onDrop = async (acceptedFiles) => {
             var _a3;
@@ -51482,29 +51431,29 @@
         };
         if (currentStatus === status.SUCCESS) {
             return /* @__PURE__ */ React__default.default.createElement(StyledCenter, {
                 $rawCss: css2,
                 style: style2
             }, /* @__PURE__ */ React__default.default.createElement(StyledCheck, {
                 size: "10x"
-            }), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Successful"), /* @__PURE__ */ React__default.default.createElement(Button$3, {
+            }), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Successful"), /* @__PURE__ */ React__default.default.createElement(Button$5, {
                 onClick: onReset,
                 styling: "secondary"
             }, "Upload Again"));
         }
         if (currentStatus === status.FAILED) {
             return /* @__PURE__ */ React__default.default.createElement(StyledCenter, {
                 $rawCss: css2,
                 style: style2
             }, /* @__PURE__ */ React__default.default.createElement("span", {
                 style: {
                     color: theme2.colors.error,
                     textAlign: "center"
                 }
-            }, errorMessage), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Failed"), /* @__PURE__ */ React__default.default.createElement(Button$3, {
+            }, errorMessage), /* @__PURE__ */ React__default.default.createElement(Heading$2, null, "Upload Failed"), /* @__PURE__ */ React__default.default.createElement(Button$5, {
                 onClick: onReset,
                 styling: "ghost"
             }, "Upload Again"));
         }
         if (currentStatus === status.LOADING) {
             return /* @__PURE__ */ React__default.default.createElement(core$2.DefaultFallback, null);
         }
@@ -51569,15 +51518,15 @@
             })))
         );
     }
     const StyledTag$1 = core$2.injectCss("h1");
     const anchorName = (text2) => text2.toLowerCase().replace(/\s+/g, "-");
 
     function Heading$1(props) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [style2, css2] = core$2.useComponentStyles(props);
         const [heading2] = core$2.useVariable(props.heading);
         const tag = `h${props.level}`;
         return /* @__PURE__ */ React__default.default.createElement(
             StyledTag$1, {
                 $rawCss: css2,
                 as: tag,
@@ -51593,20 +51542,20 @@
         );
     }
     const _Wrapper = styled__default.default.div`
     display: flex;
     width: 100%;
     height: 100%;
 `;
-    const Wrapper$3 = core$2.injectCss(_Wrapper);
+    const Wrapper$9 = core$2.injectCss(_Wrapper);
 
     function HtmlRaw(props) {
         const [style2, css2] = core$2.useComponentStyles(props);
         return /* @__PURE__ */ React__default.default.createElement(
-            Wrapper$3, {
+            Wrapper$9, {
                 $rawCss: css2,
                 className: props.className,
                 dangerouslySetInnerHTML: {
                     __html: props.html
                 },
                 style: style2
             }
@@ -51675,26 +51624,26 @@
             style: {
                 alignItems: props.align,
                 justifyContent: props.justify
             }
         }, props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
             component: child,
             key: `form-${idx}-${child.uid}`
-        })), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+        })), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$5, {
             onClick: () => onSubmit(formState),
             styling: "primary"
         }, "Submit"))), pages.length > 0 && /* @__PURE__ */ React__default.default.createElement(FormWrapper, null, /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
             component: props.children[currentPage]
-        }), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, currentPage < pages.length - 1 && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+        }), /* @__PURE__ */ React__default.default.createElement(ButtonWrapper, null, currentPage < pages.length - 1 && /* @__PURE__ */ React__default.default.createElement(Button$5, {
             onClick: () => setCurrentPage(currentPage + 1),
             styling: "primary"
-        }, "Next"), currentPage === pages.length - 1 && props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+        }, "Next"), currentPage === pages.length - 1 && props.onsubmit && /* @__PURE__ */ React__default.default.createElement(Button$5, {
             onClick: () => onSubmit(formState),
             styling: "primary"
-        }, "Submit"), currentPage > 0 && pages.length > 1 && /* @__PURE__ */ React__default.default.createElement(Button$3, {
+        }, "Submit"), currentPage > 0 && pages.length > 1 && /* @__PURE__ */ React__default.default.createElement(Button$5, {
             onClick: () => setCurrentPage(currentPage - 1),
             outline: true,
             styling: "primary"
         }, "Back")))));
     }
     const PageWrapper = styled__default.default.section`
     display: flex;
@@ -51714,15 +51663,15 @@
             style: style2
         }, props.title && /* @__PURE__ */ React__default.default.createElement(PageTitle, null, props.title), props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
             component: child,
             key: `form-page-${idx}-${child.uid}`
         })));
     }
 
-    function Icon$1(props) {
+    function Icon$2(props) {
         const [style2, css2] = core$2.useComponentStyles(props);
         const IconComponent = core$2.getIcon(props.icon);
         const validStyle = {
             ...style2
         };
         delete validStyle.fontWeight;
         return /* @__PURE__ */ React__default.default.createElement(
@@ -51750,22 +51699,22 @@
             style: style2
         }, /* @__PURE__ */ React__default.default.createElement("img", {
             alt: `Could not load ${source}`,
             loading: "lazy",
             src: source
         }));
     }
-    const StyledInput$2 = core$2.injectCss(Input$3);
+    const StyledInput$3 = core$2.injectCss(Input$5);
     const StyledNumericInput = core$2.injectCss(NumericInput);
 
     function getNumericValue(value) {
         return value == null || Number.isNaN(Number(value)) ? null : Number(value);
     }
 
-    function Input(props) {
+    function Input$2(props) {
         const formCtx2 = useFormContext(props);
         const [style2, css2] = core$2.useComponentStyles(props);
         const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
         const [internalValue, setInternalValue] = React.useState(value);
         const [onInputAction] = core$2.useAction(props.onchange);
         const debouncedAction = React.useMemo(() => debounce_1(onInputAction, 500), [onInputAction]);
         const debouncedSetValue = React.useMemo(() => debounce_1(setValue, 500), [setValue]);
@@ -51801,15 +51750,15 @@
                     stepper: true,
                     style: style2,
                     value: internalValue
                 }
             );
         }
         return /* @__PURE__ */ React__default.default.createElement(
-            StyledInput$2, {
+            StyledInput$3, {
                 $rawCss: css2,
                 className: props.className,
                 onChange: handleChange,
                 placeholder: props.placeholder,
                 style: style2,
                 type: props.type,
                 value: internalValue
@@ -51852,1127 +51801,2025 @@
             }),
             props.children.map((child, idx) => /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
                 component: child,
                 key: `cell-${idx}-${child.uid}`
             }))
         );
     }
-    const protocols = ["http", "https", "mailto", "tel"];
 
-    function uriTransformer(uri2) {
-        const url2 = (uri2 || "").trim();
-        const first = url2.charAt(0);
-        if (first === "#" || first === "/") {
-            return url2;
-        }
-        const colon = url2.indexOf(":");
-        if (colon === -1) {
-            return url2;
-        }
-        let index2 = -1;
-        while (++index2 < protocols.length) {
-            const protocol = protocols[index2];
-            if (colon === protocol.length && url2.slice(0, protocol.length).toLowerCase() === protocol) {
-                return url2;
+    function ok$2() {}
+
+    function unreachable() {}
+
+    function parse$7(value) {
+        const tokens2 = [];
+        const input = String(value || "");
+        let index2 = input.indexOf(",");
+        let start2 = 0;
+        let end2 = false;
+        while (!end2) {
+            if (index2 === -1) {
+                index2 = input.length;
+                end2 = true;
             }
+            const token = input.slice(start2, index2).trim();
+            if (token || !end2) {
+                tokens2.push(token);
+            }
+            start2 = index2 + 1;
+            index2 = input.indexOf(",", start2);
         }
-        index2 = url2.indexOf("?");
-        if (index2 !== -1 && colon > index2) {
-            return url2;
-        }
-        index2 = url2.indexOf("#");
-        if (index2 !== -1 && colon > index2) {
-            return url2;
-        }
-        return "javascript:void(0)";
+        return tokens2;
     }
-    /*!
-     * Determine if an object is a Buffer
-     *
-     * @author   Feross Aboukhadijeh <https://feross.org>
-     * @license  MIT
-     */
-    var isBuffer$2 = function isBuffer2(obj) {
-        return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
-    };
 
-    function stringifyPosition(value) {
-        if (!value || typeof value !== "object") {
-            return "";
-        }
-        if ("position" in value || "type" in value) {
-            return position$3(value.position);
-        }
-        if ("start" in value || "end" in value) {
-            return position$3(value);
-        }
-        if ("line" in value || "column" in value) {
-            return point$3(value);
-        }
-        return "";
+    function stringify$3(values, options) {
+        const settings2 = options || {};
+        const input = values[values.length - 1] === "" ? [...values, ""] : values;
+        return input.join(
+            (settings2.padRight ? " " : "") + "," + (settings2.padLeft === false ? "" : " ")
+        ).trim();
     }
-
-    function point$3(point2) {
-        return index$2(point2 && point2.line) + ":" + index$2(point2 && point2.column);
+    const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
+    const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
+    const emptyOptions$3 = {};
+
+    function name$2(name2, options) {
+        const settings2 = options || emptyOptions$3;
+        const re2 = settings2.jsx ? nameReJsx : nameRe;
+        return re2.test(name2);
     }
+    const re$1 = /[ \t\n\f\r]/g;
 
-    function position$3(pos) {
-        return point$3(pos && pos.start) + "-" + point$3(pos && pos.end);
+    function whitespace(thing) {
+        return typeof thing === "object" ? thing.type === "text" ? empty$4(thing.value) : false : empty$4(thing);
     }
 
-    function index$2(value) {
-        return value && typeof value === "number" ? value : 1;
+    function empty$4(value) {
+        return value.replace(re$1, "") === "";
     }
-    class VFileMessage extends Error {
-        constructor(reason, place2, origin) {
-            const parts = [null, null];
-            let position2 = {
-                start: {
-                    line: null,
-                    column: null
-                },
-                end: {
-                    line: null,
-                    column: null
-                }
-            };
-            super();
-            if (typeof place2 === "string") {
-                origin = place2;
-                place2 = void 0;
-            }
-            if (typeof origin === "string") {
-                const index2 = origin.indexOf(":");
-                if (index2 === -1) {
-                    parts[1] = origin;
-                } else {
-                    parts[0] = origin.slice(0, index2);
-                    parts[1] = origin.slice(index2 + 1);
-                }
-            }
-            if (place2) {
-                if ("type" in place2 || "position" in place2) {
-                    if (place2.position) {
-                        position2 = place2.position;
-                    }
-                } else if ("start" in place2 || "end" in place2) {
-                    position2 = place2;
-                } else if ("line" in place2 || "column" in place2) {
-                    position2.start = place2;
-                }
-            }
-            this.name = stringifyPosition(place2) || "1:1";
-            this.message = typeof reason === "object" ? reason.message : reason;
-            this.stack = "";
-            if (typeof reason === "object" && reason.stack) {
-                this.stack = reason.stack;
+    class Schema {
+        constructor(property, normal, space2) {
+            this.property = property;
+            this.normal = normal;
+            if (space2) {
+                this.space = space2;
             }
-            this.reason = this.message;
-            this.fatal;
-            this.line = position2.start.line;
-            this.column = position2.start.column;
-            this.position = position2;
-            this.source = parts[0];
-            this.ruleId = parts[1];
-            this.file;
-            this.actual;
-            this.expected;
-            this.url;
-            this.note;
         }
     }
-    VFileMessage.prototype.file = "";
-    VFileMessage.prototype.name = "";
-    VFileMessage.prototype.reason = "";
-    VFileMessage.prototype.message = "";
-    VFileMessage.prototype.stack = "";
-    VFileMessage.prototype.fatal = null;
-    VFileMessage.prototype.column = null;
-    VFileMessage.prototype.line = null;
-    VFileMessage.prototype.source = null;
-    VFileMessage.prototype.ruleId = null;
-    VFileMessage.prototype.position = null;
-    const path$2 = {
-        basename,
-        dirname,
-        extname,
-        join,
-        sep: "/"
-    };
+    Schema.prototype.property = {};
+    Schema.prototype.normal = {};
+    Schema.prototype.space = null;
 
-    function basename(path2, ext) {
-        if (ext !== void 0 && typeof ext !== "string") {
-            throw new TypeError('"ext" argument must be a string');
-        }
-        assertPath$2(path2);
-        let start2 = 0;
-        let end2 = -1;
-        let index2 = path2.length;
-        let seenNonSlash;
-        if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
-            while (index2--) {
-                if (path2.charCodeAt(index2) === 47) {
-                    if (seenNonSlash) {
-                        start2 = index2 + 1;
-                        break;
-                    }
-                } else if (end2 < 0) {
-                    seenNonSlash = true;
-                    end2 = index2 + 1;
-                }
-            }
-            return end2 < 0 ? "" : path2.slice(start2, end2);
+    function merge$1(definitions, space2) {
+        const property = {};
+        const normal = {};
+        let index2 = -1;
+        while (++index2 < definitions.length) {
+            Object.assign(property, definitions[index2].property);
+            Object.assign(normal, definitions[index2].normal);
         }
-        if (ext === path2) {
-            return "";
+        return new Schema(property, normal, space2);
+    }
+
+    function normalize$2(value) {
+        return value.toLowerCase();
+    }
+    class Info {
+        constructor(property, attribute) {
+            this.property = property;
+            this.attribute = attribute;
         }
-        let firstNonSlashEnd = -1;
-        let extIndex = ext.length - 1;
-        while (index2--) {
-            if (path2.charCodeAt(index2) === 47) {
-                if (seenNonSlash) {
-                    start2 = index2 + 1;
-                    break;
-                }
-            } else {
-                if (firstNonSlashEnd < 0) {
-                    seenNonSlash = true;
-                    firstNonSlashEnd = index2 + 1;
-                }
-                if (extIndex > -1) {
-                    if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
-                        if (extIndex < 0) {
-                            end2 = index2;
-                        }
-                    } else {
-                        extIndex = -1;
-                        end2 = firstNonSlashEnd;
-                    }
+    }
+    Info.prototype.space = null;
+    Info.prototype.boolean = false;
+    Info.prototype.booleanish = false;
+    Info.prototype.overloadedBoolean = false;
+    Info.prototype.number = false;
+    Info.prototype.commaSeparated = false;
+    Info.prototype.spaceSeparated = false;
+    Info.prototype.commaOrSpaceSeparated = false;
+    Info.prototype.mustUseProperty = false;
+    Info.prototype.defined = false;
+    let powers = 0;
+    const boolean = increment();
+    const booleanish = increment();
+    const overloadedBoolean = increment();
+    const number$3 = increment();
+    const spaceSeparated = increment();
+    const commaSeparated = increment();
+    const commaOrSpaceSeparated = increment();
+
+    function increment() {
+        return 2 ** ++powers;
+    }
+    const types$1 = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+        __proto__: null,
+        boolean,
+        booleanish,
+        overloadedBoolean,
+        number: number$3,
+        spaceSeparated,
+        commaSeparated,
+        commaOrSpaceSeparated
+    }, Symbol.toStringTag, {
+        value: "Module"
+    }));
+    const checks = Object.keys(types$1);
+    class DefinedInfo extends Info {
+        constructor(property, attribute, mask, space2) {
+            let index2 = -1;
+            super(property, attribute);
+            mark(this, "space", space2);
+            if (typeof mask === "number") {
+                while (++index2 < checks.length) {
+                    const check = checks[index2];
+                    mark(this, checks[index2], (mask & types$1[check]) === types$1[check]);
                 }
             }
         }
-        if (start2 === end2) {
-            end2 = firstNonSlashEnd;
-        } else if (end2 < 0) {
-            end2 = path2.length;
-        }
-        return path2.slice(start2, end2);
     }
+    DefinedInfo.prototype.defined = true;
 
-    function dirname(path2) {
-        assertPath$2(path2);
-        if (path2.length === 0) {
-            return ".";
-        }
-        let end2 = -1;
-        let index2 = path2.length;
-        let unmatchedSlash;
-        while (--index2) {
-            if (path2.charCodeAt(index2) === 47) {
-                if (unmatchedSlash) {
-                    end2 = index2;
-                    break;
-                }
-            } else if (!unmatchedSlash) {
-                unmatchedSlash = true;
-            }
+    function mark(values, key, value) {
+        if (value) {
+            values[key] = value;
         }
-        return end2 < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end2 === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end2);
     }
+    const own$8 = {}.hasOwnProperty;
 
-    function extname(path2) {
-        assertPath$2(path2);
-        let index2 = path2.length;
-        let end2 = -1;
-        let startPart = 0;
-        let startDot = -1;
-        let preDotState = 0;
-        let unmatchedSlash;
-        while (index2--) {
-            const code2 = path2.charCodeAt(index2);
-            if (code2 === 47) {
-                if (unmatchedSlash) {
-                    startPart = index2 + 1;
-                    break;
-                }
-                continue;
-            }
-            if (end2 < 0) {
-                unmatchedSlash = true;
-                end2 = index2 + 1;
-            }
-            if (code2 === 46) {
-                if (startDot < 0) {
-                    startDot = index2;
-                } else if (preDotState !== 1) {
-                    preDotState = 1;
+    function create$1(definition2) {
+        const property = {};
+        const normal = {};
+        let prop;
+        for (prop in definition2.properties) {
+            if (own$8.call(definition2.properties, prop)) {
+                const value = definition2.properties[prop];
+                const info = new DefinedInfo(
+                    prop,
+                    definition2.transform(definition2.attributes || {}, prop),
+                    value,
+                    definition2.space
+                );
+                if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
+                    info.mustUseProperty = true;
                 }
-            } else if (startDot > -1) {
-                preDotState = -1;
+                property[prop] = info;
+                normal[normalize$2(prop)] = prop;
+                normal[normalize$2(info.attribute)] = prop;
             }
         }
-        if (startDot < 0 || end2 < 0 || preDotState === 0 || preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
-            return "";
-        }
-        return path2.slice(startDot, end2);
+        return new Schema(property, normal, definition2.space);
     }
-
-    function join(...segments) {
-        let index2 = -1;
-        let joined;
-        while (++index2 < segments.length) {
-            assertPath$2(segments[index2]);
-            if (segments[index2]) {
-                joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
-            }
+    const xlink = create$1({
+        space: "xlink",
+        transform(_2, prop) {
+            return "xlink:" + prop.slice(5).toLowerCase();
+        },
+        properties: {
+            xLinkActuate: null,
+            xLinkArcRole: null,
+            xLinkHref: null,
+            xLinkRole: null,
+            xLinkShow: null,
+            xLinkTitle: null,
+            xLinkType: null
+        }
+    });
+    const xml = create$1({
+        space: "xml",
+        transform(_2, prop) {
+            return "xml:" + prop.slice(3).toLowerCase();
+        },
+        properties: {
+            xmlLang: null,
+            xmlBase: null,
+            xmlSpace: null
         }
-        return joined === void 0 ? "." : normalize$2(joined);
+    });
+
+    function caseSensitiveTransform(attributes2, attribute) {
+        return attribute in attributes2 ? attributes2[attribute] : attribute;
     }
 
-    function normalize$2(path2) {
-        assertPath$2(path2);
-        const absolute = path2.charCodeAt(0) === 47;
-        let value = normalizeString(path2, !absolute);
-        if (value.length === 0 && !absolute) {
-            value = ".";
+    function caseInsensitiveTransform(attributes2, property) {
+        return caseSensitiveTransform(attributes2, property.toLowerCase());
+    }
+    const xmlns = create$1({
+        space: "xmlns",
+        attributes: {
+            xmlnsxlink: "xmlns:xlink"
+        },
+        transform: caseInsensitiveTransform,
+        properties: {
+            xmlns: null,
+            xmlnsXLink: null
         }
-        if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
-            value += "/";
+    });
+    const aria = create$1({
+        transform(_2, prop) {
+            return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
+        },
+        properties: {
+            ariaActiveDescendant: null,
+            ariaAtomic: booleanish,
+            ariaAutoComplete: null,
+            ariaBusy: booleanish,
+            ariaChecked: booleanish,
+            ariaColCount: number$3,
+            ariaColIndex: number$3,
+            ariaColSpan: number$3,
+            ariaControls: spaceSeparated,
+            ariaCurrent: null,
+            ariaDescribedBy: spaceSeparated,
+            ariaDetails: null,
+            ariaDisabled: booleanish,
+            ariaDropEffect: spaceSeparated,
+            ariaErrorMessage: null,
+            ariaExpanded: booleanish,
+            ariaFlowTo: spaceSeparated,
+            ariaGrabbed: booleanish,
+            ariaHasPopup: null,
+            ariaHidden: booleanish,
+            ariaInvalid: null,
+            ariaKeyShortcuts: null,
+            ariaLabel: null,
+            ariaLabelledBy: spaceSeparated,
+            ariaLevel: number$3,
+            ariaLive: null,
+            ariaModal: booleanish,
+            ariaMultiLine: booleanish,
+            ariaMultiSelectable: booleanish,
+            ariaOrientation: null,
+            ariaOwns: spaceSeparated,
+            ariaPlaceholder: null,
+            ariaPosInSet: number$3,
+            ariaPressed: booleanish,
+            ariaReadOnly: booleanish,
+            ariaRelevant: null,
+            ariaRequired: booleanish,
+            ariaRoleDescription: spaceSeparated,
+            ariaRowCount: number$3,
+            ariaRowIndex: number$3,
+            ariaRowSpan: number$3,
+            ariaSelected: booleanish,
+            ariaSetSize: number$3,
+            ariaSort: null,
+            ariaValueMax: number$3,
+            ariaValueMin: number$3,
+            ariaValueNow: number$3,
+            ariaValueText: null,
+            role: null
         }
-        return absolute ? "/" + value : value;
-    }
+    });
+    const html$4 = create$1({
+        space: "html",
+        attributes: {
+            acceptcharset: "accept-charset",
+            classname: "class",
+            htmlfor: "for",
+            httpequiv: "http-equiv"
+        },
+        transform: caseInsensitiveTransform,
+        mustUseProperty: ["checked", "multiple", "muted", "selected"],
+        properties: {
+            abbr: null,
+            accept: commaSeparated,
+            acceptCharset: spaceSeparated,
+            accessKey: spaceSeparated,
+            action: null,
+            allow: null,
+            allowFullScreen: boolean,
+            allowPaymentRequest: boolean,
+            allowUserMedia: boolean,
+            alt: null,
+            as: null,
+            async: boolean,
+            autoCapitalize: null,
+            autoComplete: spaceSeparated,
+            autoFocus: boolean,
+            autoPlay: boolean,
+            blocking: spaceSeparated,
+            capture: boolean,
+            charSet: null,
+            checked: boolean,
+            cite: null,
+            className: spaceSeparated,
+            cols: number$3,
+            colSpan: null,
+            content: null,
+            contentEditable: booleanish,
+            controls: boolean,
+            controlsList: spaceSeparated,
+            coords: number$3 | commaSeparated,
+            crossOrigin: null,
+            data: null,
+            dateTime: null,
+            decoding: null,
+            default: boolean,
+            defer: boolean,
+            dir: null,
+            dirName: null,
+            disabled: boolean,
+            download: overloadedBoolean,
+            draggable: booleanish,
+            encType: null,
+            enterKeyHint: null,
+            fetchPriority: null,
+            form: null,
+            formAction: null,
+            formEncType: null,
+            formMethod: null,
+            formNoValidate: boolean,
+            formTarget: null,
+            headers: spaceSeparated,
+            height: number$3,
+            hidden: boolean,
+            high: number$3,
+            href: null,
+            hrefLang: null,
+            htmlFor: spaceSeparated,
+            httpEquiv: spaceSeparated,
+            id: null,
+            imageSizes: null,
+            imageSrcSet: null,
+            inert: boolean,
+            inputMode: null,
+            integrity: null,
+            is: null,
+            isMap: boolean,
+            itemId: null,
+            itemProp: spaceSeparated,
+            itemRef: spaceSeparated,
+            itemScope: boolean,
+            itemType: spaceSeparated,
+            kind: null,
+            label: null,
+            lang: null,
+            language: null,
+            list: null,
+            loading: null,
+            loop: boolean,
+            low: number$3,
+            manifest: null,
+            max: null,
+            maxLength: number$3,
+            media: null,
+            method: null,
+            min: null,
+            minLength: number$3,
+            multiple: boolean,
+            muted: boolean,
+            name: null,
+            nonce: null,
+            noModule: boolean,
+            noValidate: boolean,
+            onAbort: null,
+            onAfterPrint: null,
+            onAuxClick: null,
+            onBeforeMatch: null,
+            onBeforePrint: null,
+            onBeforeToggle: null,
+            onBeforeUnload: null,
+            onBlur: null,
+            onCancel: null,
+            onCanPlay: null,
+            onCanPlayThrough: null,
+            onChange: null,
+            onClick: null,
+            onClose: null,
+            onContextLost: null,
+            onContextMenu: null,
+            onContextRestored: null,
+            onCopy: null,
+            onCueChange: null,
+            onCut: null,
+            onDblClick: null,
+            onDrag: null,
+            onDragEnd: null,
+            onDragEnter: null,
+            onDragExit: null,
+            onDragLeave: null,
+            onDragOver: null,
+            onDragStart: null,
+            onDrop: null,
+            onDurationChange: null,
+            onEmptied: null,
+            onEnded: null,
+            onError: null,
+            onFocus: null,
+            onFormData: null,
+            onHashChange: null,
+            onInput: null,
+            onInvalid: null,
+            onKeyDown: null,
+            onKeyPress: null,
+            onKeyUp: null,
+            onLanguageChange: null,
+            onLoad: null,
+            onLoadedData: null,
+            onLoadedMetadata: null,
+            onLoadEnd: null,
+            onLoadStart: null,
+            onMessage: null,
+            onMessageError: null,
+            onMouseDown: null,
+            onMouseEnter: null,
+            onMouseLeave: null,
+            onMouseMove: null,
+            onMouseOut: null,
+            onMouseOver: null,
+            onMouseUp: null,
+            onOffline: null,
+            onOnline: null,
+            onPageHide: null,
+            onPageShow: null,
+            onPaste: null,
+            onPause: null,
+            onPlay: null,
+            onPlaying: null,
+            onPopState: null,
+            onProgress: null,
+            onRateChange: null,
+            onRejectionHandled: null,
+            onReset: null,
+            onResize: null,
+            onScroll: null,
+            onScrollEnd: null,
+            onSecurityPolicyViolation: null,
+            onSeeked: null,
+            onSeeking: null,
+            onSelect: null,
+            onSlotChange: null,
+            onStalled: null,
+            onStorage: null,
+            onSubmit: null,
+            onSuspend: null,
+            onTimeUpdate: null,
+            onToggle: null,
+            onUnhandledRejection: null,
+            onUnload: null,
+            onVolumeChange: null,
+            onWaiting: null,
+            onWheel: null,
+            open: boolean,
+            optimum: number$3,
+            pattern: null,
+            ping: spaceSeparated,
+            placeholder: null,
+            playsInline: boolean,
+            popover: null,
+            popoverTarget: null,
+            popoverTargetAction: null,
+            poster: null,
+            preload: null,
+            readOnly: boolean,
+            referrerPolicy: null,
+            rel: spaceSeparated,
+            required: boolean,
+            reversed: boolean,
+            rows: number$3,
+            rowSpan: number$3,
+            sandbox: spaceSeparated,
+            scope: null,
+            scoped: boolean,
+            seamless: boolean,
+            selected: boolean,
+            shadowRootDelegatesFocus: boolean,
+            shadowRootMode: null,
+            shape: null,
+            size: number$3,
+            sizes: null,
+            slot: null,
+            span: number$3,
+            spellCheck: booleanish,
+            src: null,
+            srcDoc: null,
+            srcLang: null,
+            srcSet: null,
+            start: number$3,
+            step: null,
+            style: null,
+            tabIndex: number$3,
+            target: null,
+            title: null,
+            translate: null,
+            type: null,
+            typeMustMatch: boolean,
+            useMap: null,
+            value: booleanish,
+            width: number$3,
+            wrap: null,
+            align: null,
+            aLink: null,
+            archive: spaceSeparated,
+            axis: null,
+            background: null,
+            bgColor: null,
+            border: number$3,
+            borderColor: null,
+            bottomMargin: number$3,
+            cellPadding: null,
+            cellSpacing: null,
+            char: null,
+            charOff: null,
+            classId: null,
+            clear: null,
+            code: null,
+            codeBase: null,
+            codeType: null,
+            color: null,
+            compact: boolean,
+            declare: boolean,
+            event: null,
+            face: null,
+            frame: null,
+            frameBorder: null,
+            hSpace: number$3,
+            leftMargin: number$3,
+            link: null,
+            longDesc: null,
+            lowSrc: null,
+            marginHeight: number$3,
+            marginWidth: number$3,
+            noResize: boolean,
+            noHref: boolean,
+            noShade: boolean,
+            noWrap: boolean,
+            object: null,
+            profile: null,
+            prompt: null,
+            rev: null,
+            rightMargin: number$3,
+            rules: null,
+            scheme: null,
+            scrolling: booleanish,
+            standby: null,
+            summary: null,
+            text: null,
+            topMargin: number$3,
+            valueType: null,
+            version: null,
+            vAlign: null,
+            vLink: null,
+            vSpace: number$3,
+            allowTransparency: null,
+            autoCorrect: null,
+            autoSave: null,
+            disablePictureInPicture: boolean,
+            disableRemotePlayback: boolean,
+            prefix: null,
+            property: null,
+            results: number$3,
+            security: null,
+            unselectable: null
+        }
+    });
+    const svg$1 = create$1({
+        space: "svg",
+        attributes: {
+            accentHeight: "accent-height",
+            alignmentBaseline: "alignment-baseline",
+            arabicForm: "arabic-form",
+            baselineShift: "baseline-shift",
+            capHeight: "cap-height",
+            className: "class",
+            clipPath: "clip-path",
+            clipRule: "clip-rule",
+            colorInterpolation: "color-interpolation",
+            colorInterpolationFilters: "color-interpolation-filters",
+            colorProfile: "color-profile",
+            colorRendering: "color-rendering",
+            crossOrigin: "crossorigin",
+            dataType: "datatype",
+            dominantBaseline: "dominant-baseline",
+            enableBackground: "enable-background",
+            fillOpacity: "fill-opacity",
+            fillRule: "fill-rule",
+            floodColor: "flood-color",
+            floodOpacity: "flood-opacity",
+            fontFamily: "font-family",
+            fontSize: "font-size",
+            fontSizeAdjust: "font-size-adjust",
+            fontStretch: "font-stretch",
+            fontStyle: "font-style",
+            fontVariant: "font-variant",
+            fontWeight: "font-weight",
+            glyphName: "glyph-name",
+            glyphOrientationHorizontal: "glyph-orientation-horizontal",
+            glyphOrientationVertical: "glyph-orientation-vertical",
+            hrefLang: "hreflang",
+            horizAdvX: "horiz-adv-x",
+            horizOriginX: "horiz-origin-x",
+            horizOriginY: "horiz-origin-y",
+            imageRendering: "image-rendering",
+            letterSpacing: "letter-spacing",
+            lightingColor: "lighting-color",
+            markerEnd: "marker-end",
+            markerMid: "marker-mid",
+            markerStart: "marker-start",
+            navDown: "nav-down",
+            navDownLeft: "nav-down-left",
+            navDownRight: "nav-down-right",
+            navLeft: "nav-left",
+            navNext: "nav-next",
+            navPrev: "nav-prev",
+            navRight: "nav-right",
+            navUp: "nav-up",
+            navUpLeft: "nav-up-left",
+            navUpRight: "nav-up-right",
+            onAbort: "onabort",
+            onActivate: "onactivate",
+            onAfterPrint: "onafterprint",
+            onBeforePrint: "onbeforeprint",
+            onBegin: "onbegin",
+            onCancel: "oncancel",
+            onCanPlay: "oncanplay",
+            onCanPlayThrough: "oncanplaythrough",
+            onChange: "onchange",
+            onClick: "onclick",
+            onClose: "onclose",
+            onCopy: "oncopy",
+            onCueChange: "oncuechange",
+            onCut: "oncut",
+            onDblClick: "ondblclick",
+            onDrag: "ondrag",
+            onDragEnd: "ondragend",
+            onDragEnter: "ondragenter",
+            onDragExit: "ondragexit",
+            onDragLeave: "ondragleave",
+            onDragOver: "ondragover",
+            onDragStart: "ondragstart",
+            onDrop: "ondrop",
+            onDurationChange: "ondurationchange",
+            onEmptied: "onemptied",
+            onEnd: "onend",
+            onEnded: "onended",
+            onError: "onerror",
+            onFocus: "onfocus",
+            onFocusIn: "onfocusin",
+            onFocusOut: "onfocusout",
+            onHashChange: "onhashchange",
+            onInput: "oninput",
+            onInvalid: "oninvalid",
+            onKeyDown: "onkeydown",
+            onKeyPress: "onkeypress",
+            onKeyUp: "onkeyup",
+            onLoad: "onload",
+            onLoadedData: "onloadeddata",
+            onLoadedMetadata: "onloadedmetadata",
+            onLoadStart: "onloadstart",
+            onMessage: "onmessage",
+            onMouseDown: "onmousedown",
+            onMouseEnter: "onmouseenter",
+            onMouseLeave: "onmouseleave",
+            onMouseMove: "onmousemove",
+            onMouseOut: "onmouseout",
+            onMouseOver: "onmouseover",
+            onMouseUp: "onmouseup",
+            onMouseWheel: "onmousewheel",
+            onOffline: "onoffline",
+            onOnline: "ononline",
+            onPageHide: "onpagehide",
+            onPageShow: "onpageshow",
+            onPaste: "onpaste",
+            onPause: "onpause",
+            onPlay: "onplay",
+            onPlaying: "onplaying",
+            onPopState: "onpopstate",
+            onProgress: "onprogress",
+            onRateChange: "onratechange",
+            onRepeat: "onrepeat",
+            onReset: "onreset",
+            onResize: "onresize",
+            onScroll: "onscroll",
+            onSeeked: "onseeked",
+            onSeeking: "onseeking",
+            onSelect: "onselect",
+            onShow: "onshow",
+            onStalled: "onstalled",
+            onStorage: "onstorage",
+            onSubmit: "onsubmit",
+            onSuspend: "onsuspend",
+            onTimeUpdate: "ontimeupdate",
+            onToggle: "ontoggle",
+            onUnload: "onunload",
+            onVolumeChange: "onvolumechange",
+            onWaiting: "onwaiting",
+            onZoom: "onzoom",
+            overlinePosition: "overline-position",
+            overlineThickness: "overline-thickness",
+            paintOrder: "paint-order",
+            panose1: "panose-1",
+            pointerEvents: "pointer-events",
+            referrerPolicy: "referrerpolicy",
+            renderingIntent: "rendering-intent",
+            shapeRendering: "shape-rendering",
+            stopColor: "stop-color",
+            stopOpacity: "stop-opacity",
+            strikethroughPosition: "strikethrough-position",
+            strikethroughThickness: "strikethrough-thickness",
+            strokeDashArray: "stroke-dasharray",
+            strokeDashOffset: "stroke-dashoffset",
+            strokeLineCap: "stroke-linecap",
+            strokeLineJoin: "stroke-linejoin",
+            strokeMiterLimit: "stroke-miterlimit",
+            strokeOpacity: "stroke-opacity",
+            strokeWidth: "stroke-width",
+            tabIndex: "tabindex",
+            textAnchor: "text-anchor",
+            textDecoration: "text-decoration",
+            textRendering: "text-rendering",
+            transformOrigin: "transform-origin",
+            typeOf: "typeof",
+            underlinePosition: "underline-position",
+            underlineThickness: "underline-thickness",
+            unicodeBidi: "unicode-bidi",
+            unicodeRange: "unicode-range",
+            unitsPerEm: "units-per-em",
+            vAlphabetic: "v-alphabetic",
+            vHanging: "v-hanging",
+            vIdeographic: "v-ideographic",
+            vMathematical: "v-mathematical",
+            vectorEffect: "vector-effect",
+            vertAdvY: "vert-adv-y",
+            vertOriginX: "vert-origin-x",
+            vertOriginY: "vert-origin-y",
+            wordSpacing: "word-spacing",
+            writingMode: "writing-mode",
+            xHeight: "x-height",
+            playbackOrder: "playbackorder",
+            timelineBegin: "timelinebegin"
+        },
+        transform: caseSensitiveTransform,
+        properties: {
+            about: commaOrSpaceSeparated,
+            accentHeight: number$3,
+            accumulate: null,
+            additive: null,
+            alignmentBaseline: null,
+            alphabetic: number$3,
+            amplitude: number$3,
+            arabicForm: null,
+            ascent: number$3,
+            attributeName: null,
+            attributeType: null,
+            azimuth: number$3,
+            bandwidth: null,
+            baselineShift: null,
+            baseFrequency: null,
+            baseProfile: null,
+            bbox: null,
+            begin: null,
+            bias: number$3,
+            by: null,
+            calcMode: null,
+            capHeight: number$3,
+            className: spaceSeparated,
+            clip: null,
+            clipPath: null,
+            clipPathUnits: null,
+            clipRule: null,
+            color: null,
+            colorInterpolation: null,
+            colorInterpolationFilters: null,
+            colorProfile: null,
+            colorRendering: null,
+            content: null,
+            contentScriptType: null,
+            contentStyleType: null,
+            crossOrigin: null,
+            cursor: null,
+            cx: null,
+            cy: null,
+            d: null,
+            dataType: null,
+            defaultAction: null,
+            descent: number$3,
+            diffuseConstant: number$3,
+            direction: null,
+            display: null,
+            dur: null,
+            divisor: number$3,
+            dominantBaseline: null,
+            download: boolean,
+            dx: null,
+            dy: null,
+            edgeMode: null,
+            editable: null,
+            elevation: number$3,
+            enableBackground: null,
+            end: null,
+            event: null,
+            exponent: number$3,
+            externalResourcesRequired: null,
+            fill: null,
+            fillOpacity: number$3,
+            fillRule: null,
+            filter: null,
+            filterRes: null,
+            filterUnits: null,
+            floodColor: null,
+            floodOpacity: null,
+            focusable: null,
+            focusHighlight: null,
+            fontFamily: null,
+            fontSize: null,
+            fontSizeAdjust: null,
+            fontStretch: null,
+            fontStyle: null,
+            fontVariant: null,
+            fontWeight: null,
+            format: null,
+            fr: null,
+            from: null,
+            fx: null,
+            fy: null,
+            g1: commaSeparated,
+            g2: commaSeparated,
+            glyphName: commaSeparated,
+            glyphOrientationHorizontal: null,
+            glyphOrientationVertical: null,
+            glyphRef: null,
+            gradientTransform: null,
+            gradientUnits: null,
+            handler: null,
+            hanging: number$3,
+            hatchContentUnits: null,
+            hatchUnits: null,
+            height: null,
+            href: null,
+            hrefLang: null,
+            horizAdvX: number$3,
+            horizOriginX: number$3,
+            horizOriginY: number$3,
+            id: null,
+            ideographic: number$3,
+            imageRendering: null,
+            initialVisibility: null,
+            in: null,
+            in2: null,
+            intercept: number$3,
+            k: number$3,
+            k1: number$3,
+            k2: number$3,
+            k3: number$3,
+            k4: number$3,
+            kernelMatrix: commaOrSpaceSeparated,
+            kernelUnitLength: null,
+            keyPoints: null,
+            keySplines: null,
+            keyTimes: null,
+            kerning: null,
+            lang: null,
+            lengthAdjust: null,
+            letterSpacing: null,
+            lightingColor: null,
+            limitingConeAngle: number$3,
+            local: null,
+            markerEnd: null,
+            markerMid: null,
+            markerStart: null,
+            markerHeight: null,
+            markerUnits: null,
+            markerWidth: null,
+            mask: null,
+            maskContentUnits: null,
+            maskUnits: null,
+            mathematical: null,
+            max: null,
+            media: null,
+            mediaCharacterEncoding: null,
+            mediaContentEncodings: null,
+            mediaSize: number$3,
+            mediaTime: null,
+            method: null,
+            min: null,
+            mode: null,
+            name: null,
+            navDown: null,
+            navDownLeft: null,
+            navDownRight: null,
+            navLeft: null,
+            navNext: null,
+            navPrev: null,
+            navRight: null,
+            navUp: null,
+            navUpLeft: null,
+            navUpRight: null,
+            numOctaves: null,
+            observer: null,
+            offset: null,
+            onAbort: null,
+            onActivate: null,
+            onAfterPrint: null,
+            onBeforePrint: null,
+            onBegin: null,
+            onCancel: null,
+            onCanPlay: null,
+            onCanPlayThrough: null,
+            onChange: null,
+            onClick: null,
+            onClose: null,
+            onCopy: null,
+            onCueChange: null,
+            onCut: null,
+            onDblClick: null,
+            onDrag: null,
+            onDragEnd: null,
+            onDragEnter: null,
+            onDragExit: null,
+            onDragLeave: null,
+            onDragOver: null,
+            onDragStart: null,
+            onDrop: null,
+            onDurationChange: null,
+            onEmptied: null,
+            onEnd: null,
+            onEnded: null,
+            onError: null,
+            onFocus: null,
+            onFocusIn: null,
+            onFocusOut: null,
+            onHashChange: null,
+            onInput: null,
+            onInvalid: null,
+            onKeyDown: null,
+            onKeyPress: null,
+            onKeyUp: null,
+            onLoad: null,
+            onLoadedData: null,
+            onLoadedMetadata: null,
+            onLoadStart: null,
+            onMessage: null,
+            onMouseDown: null,
+            onMouseEnter: null,
+            onMouseLeave: null,
+            onMouseMove: null,
+            onMouseOut: null,
+            onMouseOver: null,
+            onMouseUp: null,
+            onMouseWheel: null,
+            onOffline: null,
+            onOnline: null,
+            onPageHide: null,
+            onPageShow: null,
+            onPaste: null,
+            onPause: null,
+            onPlay: null,
+            onPlaying: null,
+            onPopState: null,
+            onProgress: null,
+            onRateChange: null,
+            onRepeat: null,
+            onReset: null,
+            onResize: null,
+            onScroll: null,
+            onSeeked: null,
+            onSeeking: null,
+            onSelect: null,
+            onShow: null,
+            onStalled: null,
+            onStorage: null,
+            onSubmit: null,
+            onSuspend: null,
+            onTimeUpdate: null,
+            onToggle: null,
+            onUnload: null,
+            onVolumeChange: null,
+            onWaiting: null,
+            onZoom: null,
+            opacity: null,
+            operator: null,
+            order: null,
+            orient: null,
+            orientation: null,
+            origin: null,
+            overflow: null,
+            overlay: null,
+            overlinePosition: number$3,
+            overlineThickness: number$3,
+            paintOrder: null,
+            panose1: null,
+            path: null,
+            pathLength: number$3,
+            patternContentUnits: null,
+            patternTransform: null,
+            patternUnits: null,
+            phase: null,
+            ping: spaceSeparated,
+            pitch: null,
+            playbackOrder: null,
+            pointerEvents: null,
+            points: null,
+            pointsAtX: number$3,
+            pointsAtY: number$3,
+            pointsAtZ: number$3,
+            preserveAlpha: null,
+            preserveAspectRatio: null,
+            primitiveUnits: null,
+            propagate: null,
+            property: commaOrSpaceSeparated,
+            r: null,
+            radius: null,
+            referrerPolicy: null,
+            refX: null,
+            refY: null,
+            rel: commaOrSpaceSeparated,
+            rev: commaOrSpaceSeparated,
+            renderingIntent: null,
+            repeatCount: null,
+            repeatDur: null,
+            requiredExtensions: commaOrSpaceSeparated,
+            requiredFeatures: commaOrSpaceSeparated,
+            requiredFonts: commaOrSpaceSeparated,
+            requiredFormats: commaOrSpaceSeparated,
+            resource: null,
+            restart: null,
+            result: null,
+            rotate: null,
+            rx: null,
+            ry: null,
+            scale: null,
+            seed: null,
+            shapeRendering: null,
+            side: null,
+            slope: null,
+            snapshotTime: null,
+            specularConstant: number$3,
+            specularExponent: number$3,
+            spreadMethod: null,
+            spacing: null,
+            startOffset: null,
+            stdDeviation: null,
+            stemh: null,
+            stemv: null,
+            stitchTiles: null,
+            stopColor: null,
+            stopOpacity: null,
+            strikethroughPosition: number$3,
+            strikethroughThickness: number$3,
+            string: null,
+            stroke: null,
+            strokeDashArray: commaOrSpaceSeparated,
+            strokeDashOffset: null,
+            strokeLineCap: null,
+            strokeLineJoin: null,
+            strokeMiterLimit: number$3,
+            strokeOpacity: number$3,
+            strokeWidth: null,
+            style: null,
+            surfaceScale: number$3,
+            syncBehavior: null,
+            syncBehaviorDefault: null,
+            syncMaster: null,
+            syncTolerance: null,
+            syncToleranceDefault: null,
+            systemLanguage: commaOrSpaceSeparated,
+            tabIndex: number$3,
+            tableValues: null,
+            target: null,
+            targetX: number$3,
+            targetY: number$3,
+            textAnchor: null,
+            textDecoration: null,
+            textRendering: null,
+            textLength: null,
+            timelineBegin: null,
+            title: null,
+            transformBehavior: null,
+            type: null,
+            typeOf: commaOrSpaceSeparated,
+            to: null,
+            transform: null,
+            transformOrigin: null,
+            u1: null,
+            u2: null,
+            underlinePosition: number$3,
+            underlineThickness: number$3,
+            unicode: null,
+            unicodeBidi: null,
+            unicodeRange: null,
+            unitsPerEm: number$3,
+            values: null,
+            vAlphabetic: number$3,
+            vMathematical: number$3,
+            vectorEffect: null,
+            vHanging: number$3,
+            vIdeographic: number$3,
+            version: null,
+            vertAdvY: number$3,
+            vertOriginX: number$3,
+            vertOriginY: number$3,
+            viewBox: null,
+            viewTarget: null,
+            visibility: null,
+            width: null,
+            widths: null,
+            wordSpacing: null,
+            writingMode: null,
+            x: null,
+            x1: null,
+            x2: null,
+            xChannelSelector: null,
+            xHeight: number$3,
+            y: null,
+            y1: null,
+            y2: null,
+            yChannelSelector: null,
+            z: null,
+            zoomAndPan: null
+        }
+    });
+    const valid$1 = /^data[-\w.:]+$/i;
+    const dash = /-[a-z]/g;
+    const cap$1 = /[A-Z]/g;
 
-    function normalizeString(path2, allowAboveRoot) {
-        let result = "";
-        let lastSegmentLength = 0;
-        let lastSlash = -1;
-        let dots = 0;
-        let index2 = -1;
-        let code2;
-        let lastSlashIndex;
-        while (++index2 <= path2.length) {
-            if (index2 < path2.length) {
-                code2 = path2.charCodeAt(index2);
-            } else if (code2 === 47) {
-                break;
+    function find$3(schema, value) {
+        const normal = normalize$2(value);
+        let prop = value;
+        let Type2 = Info;
+        if (normal in schema.normal) {
+            return schema.property[schema.normal[normal]];
+        }
+        if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
+            if (value.charAt(4) === "-") {
+                const rest = value.slice(5).replace(dash, camelcase);
+                prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
             } else {
-                code2 = 47;
-            }
-            if (code2 === 47) {
-                if (lastSlash === index2 - 1 || dots === 1)
-                ;
-                else if (lastSlash !== index2 - 1 && dots === 2) {
-                    if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
-                        if (result.length > 2) {
-                            lastSlashIndex = result.lastIndexOf("/");
-                            if (lastSlashIndex !== result.length - 1) {
-                                if (lastSlashIndex < 0) {
-                                    result = "";
-                                    lastSegmentLength = 0;
-                                } else {
-                                    result = result.slice(0, lastSlashIndex);
-                                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
-                                }
-                                lastSlash = index2;
-                                dots = 0;
-                                continue;
-                            }
-                        } else if (result.length > 0) {
-                            result = "";
-                            lastSegmentLength = 0;
-                            lastSlash = index2;
-                            dots = 0;
-                            continue;
-                        }
-                    }
-                    if (allowAboveRoot) {
-                        result = result.length > 0 ? result + "/.." : "..";
-                        lastSegmentLength = 2;
-                    }
-                } else {
-                    if (result.length > 0) {
-                        result += "/" + path2.slice(lastSlash + 1, index2);
-                    } else {
-                        result = path2.slice(lastSlash + 1, index2);
+                const rest = value.slice(4);
+                if (!dash.test(rest)) {
+                    let dashes = rest.replace(cap$1, kebab);
+                    if (dashes.charAt(0) !== "-") {
+                        dashes = "-" + dashes;
                     }
-                    lastSegmentLength = index2 - lastSlash - 1;
+                    value = "data" + dashes;
                 }
-                lastSlash = index2;
-                dots = 0;
-            } else if (code2 === 46 && dots > -1) {
-                dots++;
-            } else {
-                dots = -1;
             }
+            Type2 = DefinedInfo;
         }
-        return result;
+        return new Type2(prop, value);
     }
 
-    function assertPath$2(path2) {
-        if (typeof path2 !== "string") {
-            throw new TypeError(
-                "Path must be a string. Received " + JSON.stringify(path2)
-            );
-        }
+    function kebab($0) {
+        return "-" + $0.toLowerCase();
     }
-    const proc = {
-        cwd
+
+    function camelcase($0) {
+        return $0.charAt(1).toUpperCase();
+    }
+    const hastToReact = {
+        classId: "classID",
+        dataType: "datatype",
+        itemId: "itemID",
+        strokeDashArray: "strokeDasharray",
+        strokeDashOffset: "strokeDashoffset",
+        strokeLineCap: "strokeLinecap",
+        strokeLineJoin: "strokeLinejoin",
+        strokeMiterLimit: "strokeMiterlimit",
+        typeOf: "typeof",
+        xLinkActuate: "xlinkActuate",
+        xLinkArcRole: "xlinkArcrole",
+        xLinkHref: "xlinkHref",
+        xLinkRole: "xlinkRole",
+        xLinkShow: "xlinkShow",
+        xLinkTitle: "xlinkTitle",
+        xLinkType: "xlinkType",
+        xmlnsXLink: "xmlnsXlink"
     };
+    const html$3 = merge$1([xml, xlink, xmlns, aria, html$4], "html");
+    const svg = merge$1([xml, xlink, xmlns, aria, svg$1], "svg");
 
-    function cwd() {
-        return "/";
+    function parse$6(value) {
+        const input = String(value || "").trim();
+        return input ? input.split(/[ \t\n\r\f]+/g) : [];
     }
 
-    function isUrl(fileUrlOrPath) {
-        return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && fileUrlOrPath.href && fileUrlOrPath.origin;
+    function stringify$2(values) {
+        return values.join(" ").trim();
     }
+    var cjs = {};
+    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
+    var NEWLINE_REGEX = /\n/g;
+    var WHITESPACE_REGEX = /^\s*/;
+    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
+    var COLON_REGEX = /^:\s*/;
+    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
+    var SEMICOLON_REGEX = /^[;\s]*/;
+    var TRIM_REGEX = /^\s+|\s+$/g;
+    var NEWLINE = "\n";
+    var FORWARD_SLASH = "/";
+    var ASTERISK = "*";
+    var EMPTY_STRING = "";
+    var TYPE_COMMENT = "comment";
+    var TYPE_DECLARATION = "declaration";
+    var inlineStyleParser = function(style2, options) {
+        if (typeof style2 !== "string") {
+            throw new TypeError("First argument must be a string");
+        }
+        if (!style2)
+            return [];
+        options = options || {};
+        var lineno = 1;
+        var column = 1;
 
-    function urlToPath(path2) {
-        if (typeof path2 === "string") {
-            path2 = new URL(path2);
-        } else if (!isUrl(path2)) {
-            const error2 = new TypeError(
-                'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
-            );
-            error2.code = "ERR_INVALID_ARG_TYPE";
-            throw error2;
+        function updatePosition(str) {
+            var lines = str.match(NEWLINE_REGEX);
+            if (lines)
+                lineno += lines.length;
+            var i2 = str.lastIndexOf(NEWLINE);
+            column = ~i2 ? str.length - i2 : column + str.length;
         }
-        if (path2.protocol !== "file:") {
-            const error2 = new TypeError("The URL must be of scheme file");
-            error2.code = "ERR_INVALID_URL_SCHEME";
-            throw error2;
+
+        function position2() {
+            var start2 = {
+                line: lineno,
+                column
+            };
+            return function(node2) {
+                node2.position = new Position(start2);
+                whitespace2();
+                return node2;
+            };
         }
-        return getPathFromURLPosix(path2);
-    }
 
-    function getPathFromURLPosix(url2) {
-        if (url2.hostname !== "") {
-            const error2 = new TypeError(
-                'File URL host must be "localhost" or empty on darwin'
-            );
-            error2.code = "ERR_INVALID_FILE_URL_HOST";
-            throw error2;
+        function Position(start2) {
+            this.start = start2;
+            this.end = {
+                line: lineno,
+                column
+            };
+            this.source = options.source;
         }
-        const pathname = url2.pathname;
-        let index2 = -1;
-        while (++index2 < pathname.length) {
-            if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
-                const third = pathname.charCodeAt(index2 + 2);
-                if (third === 70 || third === 102) {
-                    const error2 = new TypeError(
-                        "File URL path must not include encoded / characters"
-                    );
-                    error2.code = "ERR_INVALID_FILE_URL_PATH";
-                    throw error2;
-                }
+        Position.prototype.content = style2;
+
+        function error2(msg) {
+            var err = new Error(
+                options.source + ":" + lineno + ":" + column + ": " + msg
+            );
+            err.reason = msg;
+            err.filename = options.source;
+            err.line = lineno;
+            err.column = column;
+            err.source = style2;
+            if (options.silent)
+            ;
+            else {
+                throw err;
             }
         }
-        return decodeURIComponent(pathname);
-    }
-    const order = ["history", "path", "basename", "stem", "extname", "dirname"];
-    class VFile {
-        constructor(value) {
-            let options;
-            if (!value) {
-                options = {};
-            } else if (typeof value === "string" || buffer(value)) {
-                options = {
-                    value
-                };
-            } else if (isUrl(value)) {
-                options = {
-                    path: value
-                };
-            } else {
-                options = value;
-            }
-            this.data = {};
-            this.messages = [];
-            this.history = [];
-            this.cwd = proc.cwd();
-            this.value;
-            this.stored;
-            this.result;
-            this.map;
-            let index2 = -1;
-            while (++index2 < order.length) {
-                const prop2 = order[index2];
-                if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
-                    this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
-                }
-            }
-            let prop;
-            for (prop in options) {
-                if (!order.includes(prop)) {
-                    this[prop] = options[prop];
+
+        function match2(re2) {
+            var m2 = re2.exec(style2);
+            if (!m2)
+                return;
+            var str = m2[0];
+            updatePosition(str);
+            style2 = style2.slice(str.length);
+            return m2;
+        }
+
+        function whitespace2() {
+            match2(WHITESPACE_REGEX);
+        }
+
+        function comments(rules) {
+            var c2;
+            rules = rules || [];
+            while (c2 = comment2()) {
+                if (c2 !== false) {
+                    rules.push(c2);
                 }
             }
+            return rules;
         }
-        get path() {
-            return this.history[this.history.length - 1];
-        }
-        set path(path2) {
-            if (isUrl(path2)) {
-                path2 = urlToPath(path2);
+
+        function comment2() {
+            var pos = position2();
+            if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
+                return;
+            var i2 = 2;
+            while (EMPTY_STRING != style2.charAt(i2) && (ASTERISK != style2.charAt(i2) || FORWARD_SLASH != style2.charAt(i2 + 1))) {
+                ++i2;
             }
-            assertNonEmpty(path2, "path");
-            if (this.path !== path2) {
-                this.history.push(path2);
+            i2 += 2;
+            if (EMPTY_STRING === style2.charAt(i2 - 1)) {
+                return error2("End of comment missing");
             }
+            var str = style2.slice(2, i2 - 2);
+            column += 2;
+            updatePosition(str);
+            style2 = style2.slice(i2);
+            column += 2;
+            return pos({
+                type: TYPE_COMMENT,
+                comment: str
+            });
         }
-        get dirname() {
-            return typeof this.path === "string" ? path$2.dirname(this.path) : void 0;
-        }
-        set dirname(dirname2) {
-            assertPath$1(this.basename, "dirname");
-            this.path = path$2.join(dirname2 || "", this.basename);
-        }
-        get basename() {
-            return typeof this.path === "string" ? path$2.basename(this.path) : void 0;
-        }
-        set basename(basename2) {
-            assertNonEmpty(basename2, "basename");
-            assertPart(basename2, "basename");
-            this.path = path$2.join(this.dirname || "", basename2);
-        }
-        get extname() {
-            return typeof this.path === "string" ? path$2.extname(this.path) : void 0;
+
+        function declaration() {
+            var pos = position2();
+            var prop = match2(PROPERTY_REGEX);
+            if (!prop)
+                return;
+            comment2();
+            if (!match2(COLON_REGEX))
+                return error2("property missing ':'");
+            var val = match2(VALUE_REGEX);
+            var ret = pos({
+                type: TYPE_DECLARATION,
+                property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
+                value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
+            });
+            match2(SEMICOLON_REGEX);
+            return ret;
         }
-        set extname(extname2) {
-            assertPart(extname2, "extname");
-            assertPath$1(this.dirname, "extname");
-            if (extname2) {
-                if (extname2.charCodeAt(0) !== 46) {
-                    throw new Error("`extname` must start with `.`");
-                }
-                if (extname2.includes(".", 1)) {
-                    throw new Error("`extname` cannot contain multiple dots");
+
+        function declarations() {
+            var decls = [];
+            comments(decls);
+            var decl;
+            while (decl = declaration()) {
+                if (decl !== false) {
+                    decls.push(decl);
+                    comments(decls);
                 }
             }
-            this.path = path$2.join(this.dirname, this.stem + (extname2 || ""));
-        }
-        get stem() {
-            return typeof this.path === "string" ? path$2.basename(this.path, this.extname) : void 0;
-        }
-        set stem(stem) {
-            assertNonEmpty(stem, "stem");
-            assertPart(stem, "stem");
-            this.path = path$2.join(this.dirname || "", stem + (this.extname || ""));
+            return decls;
         }
-        toString(encoding) {
-            return (this.value || "").toString(encoding || void 0);
+        whitespace2();
+        return declarations();
+    };
+
+    function trim(str) {
+        return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
+    }
+    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
+        return mod && mod.__esModule ? mod : {
+            "default": mod
+        };
+    };
+    Object.defineProperty(cjs, "__esModule", {
+        value: true
+    });
+    var inline_style_parser_1 = __importDefault(inlineStyleParser);
+
+    function StyleToObject(style2, iterator2) {
+        var styleObject = null;
+        if (!style2 || typeof style2 !== "string") {
+            return styleObject;
         }
-        message(reason, place2, origin) {
-            const message = new VFileMessage(reason, place2, origin);
-            if (this.path) {
-                message.name = this.path + ":" + message.name;
-                message.file = this.path;
+        var declarations = (0, inline_style_parser_1.default)(style2);
+        var hasIterator = typeof iterator2 === "function";
+        declarations.forEach(function(declaration) {
+            if (declaration.type !== "declaration") {
+                return;
             }
-            message.fatal = false;
-            this.messages.push(message);
-            return message;
-        }
-        info(reason, place2, origin) {
-            const message = this.message(reason, place2, origin);
-            message.fatal = null;
-            return message;
-        }
-        fail(reason, place2, origin) {
-            const message = this.message(reason, place2, origin);
-            message.fatal = true;
-            throw message;
-        }
+            var property = declaration.property,
+                value = declaration.value;
+            if (hasIterator) {
+                iterator2(property, value, declaration);
+            } else if (value) {
+                styleObject = styleObject || {};
+                styleObject[property] = value;
+            }
+        });
+        return styleObject;
     }
+    var _default$1 = cjs.default = StyleToObject;
+    const styleToObject = _default$1.default || _default$1;
+    const pointEnd$1 = point$4("end");
+    const pointStart$1 = point$4("start");
 
-    function assertPart(part, name2) {
-        if (part && part.includes(path$2.sep)) {
-            throw new Error(
-                "`" + name2 + "` cannot be a path: did not expect `" + path$2.sep + "`"
-            );
+    function point$4(type2) {
+        return point2;
+
+        function point2(node2) {
+            const point3 = node2 && node2.position && node2.position[type2] || {};
+            if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
+                return {
+                    line: point3.line,
+                    column: point3.column,
+                    offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
+                };
+            }
         }
     }
 
-    function assertNonEmpty(part, name2) {
-        if (!part) {
-            throw new Error("`" + name2 + "` cannot be empty");
+    function position$3(node2) {
+        const start2 = pointStart$1(node2);
+        const end2 = pointEnd$1(node2);
+        if (start2 && end2) {
+            return {
+                start: start2,
+                end: end2
+            };
         }
     }
 
-    function assertPath$1(path2, name2) {
-        if (!path2) {
-            throw new Error("Setting `" + name2 + "` requires `path` to be set too");
+    function stringifyPosition(value) {
+        if (!value || typeof value !== "object") {
+            return "";
+        }
+        if ("position" in value || "type" in value) {
+            return position$2(value.position);
+        }
+        if ("start" in value || "end" in value) {
+            return position$2(value);
+        }
+        if ("line" in value || "column" in value) {
+            return point$3(value);
         }
+        return "";
+    }
+
+    function point$3(point2) {
+        return index$2(point2 && point2.line) + ":" + index$2(point2 && point2.column);
     }
 
-    function buffer(value) {
-        return isBuffer$2(value);
+    function position$2(pos) {
+        return point$3(pos && pos.start) + "-" + point$3(pos && pos.end);
     }
 
-    function bail(error2) {
-        if (error2) {
-            throw error2;
+    function index$2(value) {
+        return value && typeof value === "number" ? value : 1;
+    }
+    class VFileMessage extends Error {
+        constructor(causeOrReason, optionsOrParentOrPlace, origin) {
+            super();
+            if (typeof optionsOrParentOrPlace === "string") {
+                origin = optionsOrParentOrPlace;
+                optionsOrParentOrPlace = void 0;
+            }
+            let reason = "";
+            let options = {};
+            let legacyCause = false;
+            if (optionsOrParentOrPlace) {
+                if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
+                    options = {
+                        place: optionsOrParentOrPlace
+                    };
+                } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
+                    options = {
+                        place: optionsOrParentOrPlace
+                    };
+                } else if ("type" in optionsOrParentOrPlace) {
+                    options = {
+                        ancestors: [optionsOrParentOrPlace],
+                        place: optionsOrParentOrPlace.position
+                    };
+                } else {
+                    options = {
+                        ...optionsOrParentOrPlace
+                    };
+                }
+            }
+            if (typeof causeOrReason === "string") {
+                reason = causeOrReason;
+            } else if (!options.cause && causeOrReason) {
+                legacyCause = true;
+                reason = causeOrReason.message;
+                options.cause = causeOrReason;
+            }
+            if (!options.ruleId && !options.source && typeof origin === "string") {
+                const index2 = origin.indexOf(":");
+                if (index2 === -1) {
+                    options.ruleId = origin;
+                } else {
+                    options.source = origin.slice(0, index2);
+                    options.ruleId = origin.slice(index2 + 1);
+                }
+            }
+            if (!options.place && options.ancestors && options.ancestors) {
+                const parent = options.ancestors[options.ancestors.length - 1];
+                if (parent) {
+                    options.place = parent.position;
+                }
+            }
+            const start2 = options.place && "start" in options.place ? options.place.start : options.place;
+            this.ancestors = options.ancestors || void 0;
+            this.cause = options.cause || void 0;
+            this.column = start2 ? start2.column : void 0;
+            this.fatal = void 0;
+            this.file;
+            this.message = reason;
+            this.line = start2 ? start2.line : void 0;
+            this.name = stringifyPosition(options.place) || "1:1";
+            this.place = options.place || void 0;
+            this.reason = this.message;
+            this.ruleId = options.ruleId || void 0;
+            this.source = options.source || void 0;
+            this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
+            this.actual;
+            this.expected;
+            this.note;
+            this.url;
         }
     }
-    var hasOwn$2 = Object.prototype.hasOwnProperty;
-    var toStr$2 = Object.prototype.toString;
-    var defineProperty$2 = Object.defineProperty;
-    var gOPD$1 = Object.getOwnPropertyDescriptor;
-    var isArray$a = function isArray2(arr) {
-        if (typeof Array.isArray === "function") {
-            return Array.isArray(arr);
+    VFileMessage.prototype.file = "";
+    VFileMessage.prototype.name = "";
+    VFileMessage.prototype.reason = "";
+    VFileMessage.prototype.message = "";
+    VFileMessage.prototype.stack = "";
+    VFileMessage.prototype.column = void 0;
+    VFileMessage.prototype.line = void 0;
+    VFileMessage.prototype.ancestors = void 0;
+    VFileMessage.prototype.cause = void 0;
+    VFileMessage.prototype.fatal = void 0;
+    VFileMessage.prototype.place = void 0;
+    VFileMessage.prototype.ruleId = void 0;
+    VFileMessage.prototype.source = void 0;
+    const own$7 = {}.hasOwnProperty;
+    const emptyMap = /* @__PURE__ */ new Map();
+    const cap = /[A-Z]/g;
+    const dashSomething = /-([a-z])/g;
+    const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
+    const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
+    const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
+
+    function toJsxRuntime(tree, options) {
+        if (!options || options.Fragment === void 0) {
+            throw new TypeError("Expected `Fragment` in options");
+        }
+        const filePath = options.filePath || void 0;
+        let create2;
+        if (options.development) {
+            if (typeof options.jsxDEV !== "function") {
+                throw new TypeError(
+                    "Expected `jsxDEV` in options when `development: true`"
+                );
+            }
+            create2 = developmentCreate(filePath, options.jsxDEV);
+        } else {
+            if (typeof options.jsx !== "function") {
+                throw new TypeError("Expected `jsx` in production options");
+            }
+            if (typeof options.jsxs !== "function") {
+                throw new TypeError("Expected `jsxs` in production options");
+            }
+            create2 = productionCreate(filePath, options.jsx, options.jsxs);
         }
-        return toStr$2.call(arr) === "[object Array]";
-    };
-    var isPlainObject$3 = function isPlainObject2(obj) {
-        if (!obj || toStr$2.call(obj) !== "[object Object]") {
-            return false;
+        const state = {
+            Fragment: options.Fragment,
+            ancestors: [],
+            components: options.components || {},
+            create: create2,
+            elementAttributeNameCase: options.elementAttributeNameCase || "react",
+            evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
+            filePath,
+            ignoreInvalidStyle: options.ignoreInvalidStyle || false,
+            passKeys: options.passKeys !== false,
+            passNode: options.passNode || false,
+            schema: options.space === "svg" ? svg : html$3,
+            stylePropertyNameCase: options.stylePropertyNameCase || "dom",
+            tableCellAlignToStyle: options.tableCellAlignToStyle !== false
+        };
+        const result = one$4(state, tree, void 0);
+        if (result && typeof result !== "string") {
+            return result;
         }
-        var hasOwnConstructor = hasOwn$2.call(obj, "constructor");
-        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$2.call(obj.constructor.prototype, "isPrototypeOf");
-        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
-            return false;
+        return state.create(
+            tree,
+            state.Fragment, {
+                children: result || void 0
+            },
+            void 0
+        );
+    }
+
+    function one$4(state, node2, key) {
+        if (node2.type === "element") {
+            return element$4(state, node2, key);
         }
-        var key;
-        for (key in obj) {}
-        return typeof key === "undefined" || hasOwn$2.call(obj, key);
-    };
-    var setProperty = function setProperty2(target, options) {
-        if (defineProperty$2 && options.name === "__proto__") {
-            defineProperty$2(target, options.name, {
-                enumerable: true,
-                configurable: true,
-                value: options.newValue,
-                writable: true
-            });
-        } else {
-            target[options.name] = options.newValue;
+        if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
+            return mdxExpression(state, node2);
         }
-    };
-    var getProperty = function getProperty2(obj, name2) {
-        if (name2 === "__proto__") {
-            if (!hasOwn$2.call(obj, name2)) {
-                return void 0;
-            } else if (gOPD$1) {
-                return gOPD$1(obj, name2).value;
-            }
+        if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
+            return mdxJsxElement(state, node2, key);
         }
-        return obj[name2];
-    };
-    var extend$3 = function extend2() {
-        var options, name2, src, copy2, copyIsArray, clone2;
-        var target = arguments[0];
-        var i2 = 1;
-        var length = arguments.length;
-        var deep = false;
-        if (typeof target === "boolean") {
-            deep = target;
-            target = arguments[1] || {};
-            i2 = 2;
+        if (node2.type === "mdxjsEsm") {
+            return mdxEsm(state, node2);
         }
-        if (target == null || typeof target !== "object" && typeof target !== "function") {
-            target = {};
+        if (node2.type === "root") {
+            return root$4(state, node2, key);
         }
-        for (; i2 < length; ++i2) {
-            options = arguments[i2];
-            if (options != null) {
-                for (name2 in options) {
-                    src = getProperty(target, name2);
-                    copy2 = getProperty(options, name2);
-                    if (target !== copy2) {
-                        if (deep && copy2 && (isPlainObject$3(copy2) || (copyIsArray = isArray$a(copy2)))) {
-                            if (copyIsArray) {
-                                copyIsArray = false;
-                                clone2 = src && isArray$a(src) ? src : [];
-                            } else {
-                                clone2 = src && isPlainObject$3(src) ? src : {};
-                            }
-                            setProperty(target, {
-                                name: name2,
-                                newValue: extend2(deep, clone2, copy2)
-                            });
-                        } else if (typeof copy2 !== "undefined") {
-                            setProperty(target, {
-                                name: name2,
-                                newValue: copy2
-                            });
-                        }
-                    }
-                }
-            }
+        if (node2.type === "text") {
+            return text$6(state, node2);
         }
-        return target;
-    };
+    }
 
-    function isPlainObject$2(value) {
-        if (typeof value !== "object" || value === null) {
-            return false;
+    function element$4(state, node2, key) {
+        const parentSchema = state.schema;
+        let schema = parentSchema;
+        if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
+            schema = svg;
+            state.schema = schema;
         }
-        const prototype = Object.getPrototypeOf(value);
-        return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
+        state.ancestors.push(node2);
+        const type2 = findComponentFromName(state, node2.tagName, false);
+        const props = createElementProps(state, node2);
+        let children2 = createChildren(state, node2);
+        if (tableElements.has(node2.tagName)) {
+            children2 = children2.filter(function(child) {
+                return typeof child === "string" ? !whitespace(child) : true;
+            });
+        }
+        addNode$1(state, props, type2, node2);
+        addChildren$1(props, children2);
+        state.ancestors.pop();
+        state.schema = parentSchema;
+        return state.create(node2, type2, props, key);
     }
 
-    function trough() {
-        const fns = [];
-        const pipeline = {
-            run,
-            use
-        };
-        return pipeline;
-
-        function run(...values) {
-            let middlewareIndex = -1;
-            const callback = values.pop();
-            if (typeof callback !== "function") {
-                throw new TypeError("Expected function as last argument, not " + callback);
-            }
-            next2(null, ...values);
+    function mdxExpression(state, node2) {
+        if (node2.data && node2.data.estree && state.evaluater) {
+            const program = node2.data.estree;
+            const expression = program.body[0];
+            ok$2(expression.type === "ExpressionStatement");
+            return state.evaluater.evaluateExpression(expression.expression);
+        }
+        crashEstree(state, node2.position);
+    }
 
-            function next2(error2, ...output2) {
-                const fn2 = fns[++middlewareIndex];
-                let index2 = -1;
-                if (error2) {
-                    callback(error2);
-                    return;
-                }
-                while (++index2 < values.length) {
-                    if (output2[index2] === null || output2[index2] === void 0) {
-                        output2[index2] = values[index2];
-                    }
-                }
-                values = output2;
-                if (fn2) {
-                    wrap$1(fn2, next2)(...output2);
-                } else {
-                    callback(null, ...output2);
-                }
-            }
+    function mdxEsm(state, node2) {
+        if (node2.data && node2.data.estree && state.evaluater) {
+            return state.evaluater.evaluateProgram(node2.data.estree);
         }
+        crashEstree(state, node2.position);
+    }
 
-        function use(middelware) {
-            if (typeof middelware !== "function") {
-                throw new TypeError(
-                    "Expected `middelware` to be a function, not " + middelware
-                );
-            }
-            fns.push(middelware);
-            return pipeline;
+    function mdxJsxElement(state, node2, key) {
+        const parentSchema = state.schema;
+        let schema = parentSchema;
+        if (node2.name === "svg" && parentSchema.space === "html") {
+            schema = svg;
+            state.schema = schema;
         }
+        state.ancestors.push(node2);
+        const type2 = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
+        const props = createJsxElementProps(state, node2);
+        const children2 = createChildren(state, node2);
+        addNode$1(state, props, type2, node2);
+        addChildren$1(props, children2);
+        state.ancestors.pop();
+        state.schema = parentSchema;
+        return state.create(node2, type2, props, key);
     }
 
-    function wrap$1(middleware, callback) {
-        let called;
-        return wrapped;
+    function root$4(state, node2, key) {
+        const props = {};
+        addChildren$1(props, createChildren(state, node2));
+        return state.create(node2, state.Fragment, props, key);
+    }
 
-        function wrapped(...parameters) {
-            const fnExpectsCallback = middleware.length > parameters.length;
-            let result;
-            if (fnExpectsCallback) {
-                parameters.push(done);
-            }
-            try {
-                result = middleware.apply(this, parameters);
-            } catch (error2) {
-                const exception = error2;
-                if (fnExpectsCallback && called) {
-                    throw exception;
-                }
-                return done(exception);
-            }
-            if (!fnExpectsCallback) {
-                if (result instanceof Promise) {
-                    result.then(then, done);
-                } else if (result instanceof Error) {
-                    done(result);
-                } else {
-                    then(result);
-                }
-            }
+    function text$6(_2, node2) {
+        return node2.value;
+    }
+
+    function addNode$1(state, props, type2, node2) {
+        if (typeof type2 !== "string" && type2 !== state.Fragment && state.passNode) {
+            props.node = node2;
         }
+    }
 
-        function done(error2, ...output2) {
-            if (!called) {
-                called = true;
-                callback(error2, ...output2);
+    function addChildren$1(props, children2) {
+        if (children2.length > 0) {
+            const value = children2.length > 1 ? children2 : children2[0];
+            if (value) {
+                props.children = value;
             }
         }
+    }
 
-        function then(value) {
-            done(null, value);
+    function productionCreate(_2, jsx, jsxs) {
+        return create2;
+
+        function create2(_3, type2, props, key) {
+            const isStaticChildren = Array.isArray(props.children);
+            const fn2 = isStaticChildren ? jsxs : jsx;
+            return key ? fn2(type2, props, key) : fn2(type2, props);
         }
     }
-    const unified = base$1().freeze();
-    const own$b = {}.hasOwnProperty;
 
-    function base$1() {
-        const transformers = trough();
-        const attachers = [];
-        let namespace2 = {};
-        let frozen;
-        let freezeIndex = -1;
-        processor.data = data2;
-        processor.Parser = void 0;
-        processor.Compiler = void 0;
-        processor.freeze = freeze;
-        processor.attachers = attachers;
-        processor.use = use;
-        processor.parse = parse2;
-        processor.stringify = stringify2;
-        processor.run = run;
-        processor.runSync = runSync;
-        processor.process = process2;
-        processor.processSync = processSync;
-        return processor;
+    function developmentCreate(filePath, jsxDEV) {
+        return create2;
 
-        function processor() {
-            const destination = base$1();
-            let index2 = -1;
-            while (++index2 < attachers.length) {
-                destination.use(...attachers[index2]);
-            }
-            destination.data(extend$3(true, {}, namespace2));
-            return destination;
+        function create2(node2, type2, props, key) {
+            const isStaticChildren = Array.isArray(props.children);
+            const point2 = pointStart$1(node2);
+            return jsxDEV(
+                type2,
+                props,
+                key,
+                isStaticChildren, {
+                    columnNumber: point2 ? point2.column - 1 : void 0,
+                    fileName: filePath,
+                    lineNumber: point2 ? point2.line : void 0
+                },
+                void 0
+            );
         }
+    }
 
-        function data2(key, value) {
-            if (typeof key === "string") {
-                if (arguments.length === 2) {
-                    assertUnfrozen("data", frozen);
-                    namespace2[key] = value;
-                    return processor;
+    function createElementProps(state, node2) {
+        const props = {};
+        let alignValue;
+        let prop;
+        for (prop in node2.properties) {
+            if (prop !== "children" && own$7.call(node2.properties, prop)) {
+                const result = createProperty$1(state, prop, node2.properties[prop]);
+                if (result) {
+                    const [key, value] = result;
+                    if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
+                        alignValue = value;
+                    } else {
+                        props[key] = value;
+                    }
                 }
-                return own$b.call(namespace2, key) && namespace2[key] || null;
-            }
-            if (key) {
-                assertUnfrozen("data", frozen);
-                namespace2 = key;
-                return processor;
             }
-            return namespace2;
         }
-
-        function freeze() {
-            if (frozen) {
-                return processor;
-            }
-            while (++freezeIndex < attachers.length) {
-                const [attacher, ...options] = attachers[freezeIndex];
-                if (options[0] === false) {
-                    continue;
-                }
-                if (options[0] === true) {
-                    options[0] = void 0;
-                }
-                const transformer = attacher.call(processor, ...options);
-                if (typeof transformer === "function") {
-                    transformers.use(transformer);
-                }
-            }
-            frozen = true;
-            freezeIndex = Number.POSITIVE_INFINITY;
-            return processor;
+        if (alignValue) {
+            const style2 = props.style || (props.style = {});
+            style2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
         }
+        return props;
+    }
 
-        function use(value, ...options) {
-            let settings2;
-            assertUnfrozen("use", frozen);
-            if (value === null || value === void 0)
-            ;
-            else if (typeof value === "function") {
-                addPlugin(value, ...options);
-            } else if (typeof value === "object") {
-                if (Array.isArray(value)) {
-                    addList(value);
+    function createJsxElementProps(state, node2) {
+        const props = {};
+        for (const attribute of node2.attributes) {
+            if (attribute.type === "mdxJsxExpressionAttribute") {
+                if (attribute.data && attribute.data.estree && state.evaluater) {
+                    const program = attribute.data.estree;
+                    const expression = program.body[0];
+                    ok$2(expression.type === "ExpressionStatement");
+                    const objectExpression = expression.expression;
+                    ok$2(objectExpression.type === "ObjectExpression");
+                    const property = objectExpression.properties[0];
+                    ok$2(property.type === "SpreadElement");
+                    Object.assign(
+                        props,
+                        state.evaluater.evaluateExpression(property.argument)
+                    );
                 } else {
-                    addPreset(value);
+                    crashEstree(state, node2.position);
                 }
             } else {
-                throw new TypeError("Expected usable value, not `" + value + "`");
-            }
-            if (settings2) {
-                namespace2.settings = Object.assign(namespace2.settings || {}, settings2);
-            }
-            return processor;
-
-            function add2(value2) {
-                if (typeof value2 === "function") {
-                    addPlugin(value2);
-                } else if (typeof value2 === "object") {
-                    if (Array.isArray(value2)) {
-                        const [plugin, ...options2] = value2;
-                        addPlugin(plugin, ...options2);
+                const name2 = attribute.name;
+                let value;
+                if (attribute.value && typeof attribute.value === "object") {
+                    if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
+                        const program = attribute.value.data.estree;
+                        const expression = program.body[0];
+                        ok$2(expression.type === "ExpressionStatement");
+                        value = state.evaluater.evaluateExpression(expression.expression);
                     } else {
-                        addPreset(value2);
-                    }
-                } else {
-                    throw new TypeError("Expected usable value, not `" + value2 + "`");
-                }
-            }
-
-            function addPreset(result) {
-                addList(result.plugins);
-                if (result.settings) {
-                    settings2 = Object.assign(settings2 || {}, result.settings);
-                }
-            }
-
-            function addList(plugins2) {
-                let index2 = -1;
-                if (plugins2 === null || plugins2 === void 0)
-                ;
-                else if (Array.isArray(plugins2)) {
-                    while (++index2 < plugins2.length) {
-                        const thing = plugins2[index2];
-                        add2(thing);
-                    }
-                } else {
-                    throw new TypeError("Expected a list of plugins, not `" + plugins2 + "`");
-                }
-            }
-
-            function addPlugin(plugin, value2) {
-                let index2 = -1;
-                let entry;
-                while (++index2 < attachers.length) {
-                    if (attachers[index2][0] === plugin) {
-                        entry = attachers[index2];
-                        break;
+                        crashEstree(state, node2.position);
                     }
-                }
-                if (entry) {
-                    if (isPlainObject$2(entry[1]) && isPlainObject$2(value2)) {
-                        value2 = extend$3(true, entry[1], value2);
-                    }
-                    entry[1] = value2;
                 } else {
-                    attachers.push([...arguments]);
+                    value = attribute.value === null ? true : attribute.value;
                 }
+                props[name2] = value;
             }
         }
+        return props;
+    }
 
-        function parse2(doc2) {
-            processor.freeze();
-            const file = vfile(doc2);
-            const Parser2 = processor.Parser;
-            assertParser("parse", Parser2);
-            if (newable(Parser2, "parse")) {
-                return new Parser2(String(file), file).parse();
+    function createChildren(state, node2) {
+        const children2 = [];
+        let index2 = -1;
+        const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
+        while (++index2 < node2.children.length) {
+            const child = node2.children[index2];
+            let key;
+            if (state.passKeys) {
+                const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
+                if (name2) {
+                    const count2 = countsByName.get(name2) || 0;
+                    key = name2 + "-" + count2;
+                    countsByName.set(name2, count2 + 1);
+                }
             }
-            return Parser2(String(file), file);
+            const result = one$4(state, child, key);
+            if (result !== void 0)
+                children2.push(result);
         }
+        return children2;
+    }
 
-        function stringify2(node2, doc2) {
-            processor.freeze();
-            const file = vfile(doc2);
-            const Compiler = processor.Compiler;
-            assertCompiler("stringify", Compiler);
-            assertNode(node2);
-            if (newable(Compiler, "compile")) {
-                return new Compiler(node2, file).compile();
-            }
-            return Compiler(node2, file);
+    function createProperty$1(state, prop, value) {
+        const info = find$3(state.schema, prop);
+        if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
+            return;
         }
-
-        function run(node2, doc2, callback) {
-            assertNode(node2);
-            processor.freeze();
-            if (!callback && typeof doc2 === "function") {
-                callback = doc2;
-                doc2 = void 0;
-            }
-            if (!callback) {
-                return new Promise(executor);
-            }
-            executor(null, callback);
-
-            function executor(resolve2, reject) {
-                transformers.run(node2, vfile(doc2), done);
-
-                function done(error2, tree, file) {
-                    tree = tree || node2;
-                    if (error2) {
-                        reject(error2);
-                    } else if (resolve2) {
-                        resolve2(tree);
-                    } else {
-                        callback(null, tree, file);
-                    }
-                }
-            }
+        if (Array.isArray(value)) {
+            value = info.commaSeparated ? stringify$3(value) : stringify$2(value);
         }
-
-        function runSync(node2, file) {
-            let result;
-            let complete;
-            processor.run(node2, file, done);
-            assertDone("runSync", "run", complete);
-            return result;
-
-            function done(error2, tree) {
-                bail(error2);
-                result = tree;
-                complete = true;
+        if (info.property === "style") {
+            let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
+            if (state.stylePropertyNameCase === "css") {
+                styleObject = transformStylesToCssCasing(styleObject);
             }
+            return ["style", styleObject];
         }
+        return [
+            state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
+            value
+        ];
+    }
 
-        function process2(doc2, callback) {
-            processor.freeze();
-            assertParser("process", processor.Parser);
-            assertCompiler("process", processor.Compiler);
-            if (!callback) {
-                return new Promise(executor);
-            }
-            executor(null, callback);
-
-            function executor(resolve2, reject) {
-                const file = vfile(doc2);
-                processor.run(processor.parse(file), file, (error2, tree, file2) => {
-                    if (error2 || !tree || !file2) {
-                        done(error2);
-                    } else {
-                        const result = processor.stringify(tree, file2);
-                        if (result === void 0 || result === null)
-                        ;
-                        else if (looksLikeAVFileValue(result)) {
-                            file2.value = result;
-                        } else {
-                            file2.result = result;
-                        }
-                        done(error2, file2);
-                    }
-                });
-
-                function done(error2, file2) {
-                    if (error2 || !file2) {
-                        reject(error2);
-                    } else if (resolve2) {
-                        resolve2(file2);
-                    } else {
-                        callback(null, file2);
-                    }
-                }
+    function parseStyle(state, value) {
+        const result = {};
+        try {
+            styleToObject(value, replacer);
+        } catch (error2) {
+            if (!state.ignoreInvalidStyle) {
+                const cause = error2;
+                const message = new VFileMessage("Cannot parse `style` attribute", {
+                    ancestors: state.ancestors,
+                    cause,
+                    ruleId: "style",
+                    source: "hast-util-to-jsx-runtime"
+                });
+                message.file = state.filePath || void 0;
+                message.url = docs + "#cannot-parse-style-attribute";
+                throw message;
             }
         }
+        return result;
 
-        function processSync(doc2) {
-            let complete;
-            processor.freeze();
-            assertParser("processSync", processor.Parser);
-            assertCompiler("processSync", processor.Compiler);
-            const file = vfile(doc2);
-            processor.process(file, done);
-            assertDone("processSync", "process", complete);
-            return file;
-
-            function done(error2) {
-                complete = true;
-                bail(error2);
+        function replacer(name2, value2) {
+            let key = name2;
+            if (key.slice(0, 2) !== "--") {
+                if (key.slice(0, 4) === "-ms-")
+                    key = "ms-" + key.slice(4);
+                key = key.replace(dashSomething, toCamel);
             }
+            result[key] = value2;
         }
     }
 
-    function newable(value, name2) {
-        return typeof value === "function" && value.prototype && (keys$2(value.prototype) || name2 in value.prototype);
-    }
-
-    function keys$2(value) {
-        let key;
-        for (key in value) {
-            if (own$b.call(value, key)) {
-                return true;
+    function findComponentFromName(state, name2, allowExpression) {
+        let result;
+        if (!allowExpression) {
+            result = {
+                type: "Literal",
+                value: name2
+            };
+        } else if (name2.includes(".")) {
+            const identifiers = name2.split(".");
+            let index2 = -1;
+            let node2;
+            while (++index2 < identifiers.length) {
+                const prop = name$2(identifiers[index2]) ? {
+                    type: "Identifier",
+                    name: identifiers[index2]
+                } : {
+                    type: "Literal",
+                    value: identifiers[index2]
+                };
+                node2 = node2 ? {
+                    type: "MemberExpression",
+                    object: node2,
+                    property: prop,
+                    computed: Boolean(index2 && prop.type === "Literal"),
+                    optional: false
+                } : prop;
             }
+            result = node2;
+        } else {
+            result = name$2(name2) && !/^[a-z]/.test(name2) ? {
+                type: "Identifier",
+                name: name2
+            } : {
+                type: "Literal",
+                value: name2
+            };
         }
-        return false;
-    }
-
-    function assertParser(name2, value) {
-        if (typeof value !== "function") {
-            throw new TypeError("Cannot `" + name2 + "` without `Parser`");
-        }
-    }
-
-    function assertCompiler(name2, value) {
-        if (typeof value !== "function") {
-            throw new TypeError("Cannot `" + name2 + "` without `Compiler`");
+        if (result.type === "Literal") {
+            const name3 = result.value;
+            return own$7.call(state.components, name3) ? state.components[name3] : name3;
         }
-    }
-
-    function assertUnfrozen(name2, frozen) {
-        if (frozen) {
-            throw new Error(
-                "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
-            );
+        if (state.evaluater) {
+            return state.evaluater.evaluateExpression(result);
         }
+        crashEstree(state);
     }
 
-    function assertNode(node2) {
-        if (!isPlainObject$2(node2) || typeof node2.type !== "string") {
-            throw new TypeError("Expected node, got `" + node2 + "`");
-        }
+    function crashEstree(state, place2) {
+        const message = new VFileMessage(
+            "Cannot handle MDX estrees without `createEvaluater`", {
+                ancestors: state.ancestors,
+                place: place2,
+                ruleId: "mdx-estree",
+                source: "hast-util-to-jsx-runtime"
+            }
+        );
+        message.file = state.filePath || void 0;
+        message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
+        throw message;
     }
 
-    function assertDone(name2, asyncName, complete) {
-        if (!complete) {
-            throw new Error(
-                "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
-            );
+    function transformStylesToCssCasing(domCasing) {
+        const cssCasing = {};
+        let from;
+        for (from in domCasing) {
+            if (own$7.call(domCasing, from)) {
+                cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
+            }
         }
+        return cssCasing;
     }
 
-    function vfile(value) {
-        return looksLikeAVFile(value) ? value : new VFile(value);
+    function transformStyleToCssCasing(from) {
+        let to2 = from.replace(cap, toDash);
+        if (to2.slice(0, 3) === "ms-")
+            to2 = "-" + to2;
+        return to2;
     }
 
-    function looksLikeAVFile(value) {
-        return Boolean(
-            value && typeof value === "object" && "message" in value && "messages" in value
-        );
+    function toCamel(_2, $1) {
+        return $1.toUpperCase();
     }
 
-    function looksLikeAVFileValue(value) {
-        return typeof value === "string" || isBuffer$2(value);
+    function toDash($0) {
+        return "-" + $0.toLowerCase();
     }
-    const emptyOptions = {};
+    const urlAttributes = {
+        action: ["form"],
+        cite: ["blockquote", "del", "ins", "q"],
+        data: ["object"],
+        formAction: ["button", "input"],
+        href: ["a", "area", "base", "link"],
+        icon: ["menuitem"],
+        itemId: null,
+        manifest: ["html"],
+        ping: ["a", "area"],
+        poster: ["video"],
+        src: [
+            "audio",
+            "embed",
+            "iframe",
+            "img",
+            "input",
+            "script",
+            "source",
+            "track",
+            "video"
+        ]
+    };
+    const emptyOptions$2 = {};
 
-    function toString$3(value, options) {
-        const settings2 = options || emptyOptions;
+    function toString$4(value, options) {
+        const settings2 = options || emptyOptions$2;
         const includeImageAlt = typeof settings2.includeImageAlt === "boolean" ? settings2.includeImageAlt : true;
         const includeHtml = typeof settings2.includeHtml === "boolean" ? settings2.includeHtml : true;
-        return one$4(value, includeImageAlt, includeHtml);
+        return one$3(value, includeImageAlt, includeHtml);
     }
 
-    function one$4(value, includeImageAlt, includeHtml) {
+    function one$3(value, includeImageAlt, includeHtml) {
         if (node(value)) {
             if ("value" in value) {
                 return value.type === "html" && !includeHtml ? "" : value.value;
             }
             if (includeImageAlt && "alt" in value && value.alt) {
                 return value.alt;
             }
             if ("children" in value) {
-                return all$3(value.children, includeImageAlt, includeHtml);
+                return all$2(value.children, includeImageAlt, includeHtml);
             }
         }
         if (Array.isArray(value)) {
-            return all$3(value, includeImageAlt, includeHtml);
+            return all$2(value, includeImageAlt, includeHtml);
         }
         return "";
     }
 
-    function all$3(values, includeImageAlt, includeHtml) {
+    function all$2(values, includeImageAlt, includeHtml) {
         const result = [];
         let index2 = -1;
         while (++index2 < values.length) {
-            result[index2] = one$4(values[index2], includeImageAlt, includeHtml);
+            result[index2] = one$3(values[index2], includeImageAlt, includeHtml);
         }
         return result.join("");
     }
 
     function node(value) {
         return Boolean(value && typeof value === "object");
     }
+    const element$3 = document.createElement("i");
+
+    function decodeNamedCharacterReference(value) {
+        const characterReference2 = "&" + value + ";";
+        element$3.innerHTML = characterReference2;
+        const char = element$3.textContent;
+        if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
+            return false;
+        }
+        return char === characterReference2 ? false : char;
+    }
 
     function splice(list2, start2, remove2, items) {
         const end2 = list2.length;
         let chunkStart = 0;
         let parameters;
         if (start2 < 0) {
             start2 = -start2 > end2 ? 0 : end2 + start2;
@@ -53040,15 +53887,26 @@
         let index2 = -1;
         const before = [];
         while (++index2 < list2.length) {
             (list2[index2].add === "after" ? existing : before).push(list2[index2]);
         }
         splice(existing, 0, 0, before);
     }
-    const unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
+
+    function decodeNumericCharacterReference(value, base2) {
+        const code2 = Number.parseInt(value, base2);
+        if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
+            return "\uFFFD";
+        }
+        return String.fromCodePoint(code2);
+    }
+
+    function normalizeIdentifier(value) {
+        return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
+    }
     const asciiAlpha = regexCheck(/[A-Za-z]/);
     const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
     const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
 
     function asciiControl(code2) {
         return code2 !== null && (code2 < 32 || code2 === 127);
     }
@@ -53063,40 +53921,78 @@
     function markdownLineEndingOrSpace(code2) {
         return code2 !== null && (code2 < 0 || code2 === 32);
     }
 
     function markdownSpace(code2) {
         return code2 === -2 || code2 === -1 || code2 === 32;
     }
-    const unicodePunctuation = regexCheck(unicodePunctuationRegex);
+    const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
     const unicodeWhitespace = regexCheck(/\s/);
 
     function regexCheck(regex) {
         return check;
 
         function check(code2) {
-            return code2 !== null && regex.test(String.fromCharCode(code2));
+            return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
+        }
+    }
+
+    function normalizeUri(value) {
+        const result = [];
+        let index2 = -1;
+        let start2 = 0;
+        let skip = 0;
+        while (++index2 < value.length) {
+            const code2 = value.charCodeAt(index2);
+            let replace2 = "";
+            if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
+                skip = 2;
+            } else if (code2 < 128) {
+                if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
+                    replace2 = String.fromCharCode(code2);
+                }
+            } else if (code2 > 55295 && code2 < 57344) {
+                const next2 = value.charCodeAt(index2 + 1);
+                if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
+                    replace2 = String.fromCharCode(code2, next2);
+                    skip = 1;
+                } else {
+                    replace2 = "\uFFFD";
+                }
+            } else {
+                replace2 = String.fromCharCode(code2);
+            }
+            if (replace2) {
+                result.push(value.slice(start2, index2), encodeURIComponent(replace2));
+                start2 = index2 + skip + 1;
+                replace2 = "";
+            }
+            if (skip) {
+                index2 += skip;
+                skip = 0;
+            }
         }
+        return result.join("") + value.slice(start2);
     }
 
     function factorySpace(effects, ok2, type2, max2) {
         const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
-        let size = 0;
+        let size2 = 0;
         return start2;
 
         function start2(code2) {
             if (markdownSpace(code2)) {
                 effects.enter(type2);
                 return prefix(code2);
             }
             return ok2(code2);
         }
 
         function prefix(code2) {
-            if (markdownSpace(code2) && size++ < limit) {
+            if (markdownSpace(code2) && size2++ < limit) {
                 effects.consume(code2);
                 return prefix;
             }
             effects.exit(type2);
             return ok2(code2);
         }
     }
@@ -53345,22 +54241,22 @@
                     0,
                     self2.events.slice(indexBeforeExits)
                 );
                 self2.events.length = index2;
             }
         }
 
-        function exitContainers(size) {
+        function exitContainers(size2) {
             let index2 = stack.length;
-            while (index2-- > size) {
+            while (index2-- > size2) {
                 const entry = stack[index2];
                 self2.containerState = entry[1];
                 entry[0].exit.call(self2, effects);
             }
-            stack.length = size;
+            stack.length = size2;
         }
 
         function closeFlow() {
             childFlow.write([null]);
             childToken = void 0;
             childFlow = void 0;
             self2.containerState._closeFlow = void 0;
@@ -53535,15 +54431,15 @@
     }
     const autolink = {
         name: "autolink",
         tokenize: tokenizeAutolink
     };
 
     function tokenizeAutolink(effects, ok2, nok) {
-        let size = 0;
+        let size2 = 0;
         return start2;
 
         function start2(code2) {
             effects.enter("autolink");
             effects.enter("autolinkMarker");
             effects.consume(code2);
             effects.exit("autolinkMarker");
@@ -53557,31 +54453,31 @@
                 return schemeOrEmailAtext;
             }
             return emailAtext(code2);
         }
 
         function schemeOrEmailAtext(code2) {
             if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
-                size = 1;
+                size2 = 1;
                 return schemeInsideOrEmailAtext(code2);
             }
             return emailAtext(code2);
         }
 
         function schemeInsideOrEmailAtext(code2) {
             if (code2 === 58) {
                 effects.consume(code2);
-                size = 0;
+                size2 = 0;
                 return urlInside;
             }
-            if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
+            if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size2++ < 32) {
                 effects.consume(code2);
                 return schemeInsideOrEmailAtext;
             }
-            size = 0;
+            size2 = 0;
             return emailAtext(code2);
         }
 
         function urlInside(code2) {
             if (code2 === 62) {
                 effects.exit("autolinkProtocol");
                 effects.enter("autolinkMarker");
@@ -53612,30 +54508,30 @@
         function emailAtSignOrDot(code2) {
             return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
         }
 
         function emailLabel(code2) {
             if (code2 === 46) {
                 effects.consume(code2);
-                size = 0;
+                size2 = 0;
                 return emailAtSignOrDot;
             }
             if (code2 === 62) {
                 effects.exit("autolinkProtocol").type = "autolinkEmail";
                 effects.enter("autolinkMarker");
                 effects.consume(code2);
                 effects.exit("autolinkMarker");
                 effects.exit("autolink");
                 return ok2;
             }
             return emailValue(code2);
         }
 
         function emailValue(code2) {
-            if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
+            if ((code2 === 45 || asciiAlphanumeric(code2)) && size2++ < 63) {
                 const next2 = code2 === 45 ? emailValue : emailLabel;
                 effects.consume(code2);
                 return next2;
             }
             return nok(code2);
         }
     }
@@ -53746,33 +54642,22 @@
                 effects.exit("characterEscapeValue");
                 effects.exit("characterEscape");
                 return ok2;
             }
             return nok(code2);
         }
     }
-    const element$3 = document.createElement("i");
-
-    function decodeNamedCharacterReference(value) {
-        const characterReference2 = "&" + value + ";";
-        element$3.innerHTML = characterReference2;
-        const char = element$3.textContent;
-        if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
-            return false;
-        }
-        return char === characterReference2 ? false : char;
-    }
     const characterReference = {
         name: "characterReference",
         tokenize: tokenizeCharacterReference
     };
 
     function tokenizeCharacterReference(effects, ok2, nok) {
         const self2 = this;
-        let size = 0;
+        let size2 = 0;
         let max2;
         let test2;
         return start2;
 
         function start2(code2) {
             effects.enter("characterReference");
             effects.enter("characterReferenceMarker");
@@ -53807,26 +54692,26 @@
             effects.enter("characterReferenceValue");
             max2 = 7;
             test2 = asciiDigit;
             return value(code2);
         }
 
         function value(code2) {
-            if (code2 === 59 && size) {
+            if (code2 === 59 && size2) {
                 const token = effects.exit("characterReferenceValue");
                 if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
                     return nok(code2);
                 }
                 effects.enter("characterReferenceMarker");
                 effects.consume(code2);
                 effects.exit("characterReferenceMarker");
                 effects.exit("characterReference");
                 return ok2;
             }
-            if (test2(code2) && size++ < max2) {
+            if (test2(code2) && size2++ < max2) {
                 effects.consume(code2);
                 return value;
             }
             return nok(code2);
         }
     }
     const nonLazyContinuation = {
@@ -53970,15 +54855,15 @@
 
         function after(code2) {
             effects.exit("codeFenced");
             return ok2(code2);
         }
 
         function tokenizeCloseStart(effects2, ok3, nok2) {
-            let size = 0;
+            let size2 = 0;
             return startBefore;
 
             function startBefore(code2) {
                 effects2.enter("lineEnding");
                 effects2.consume(code2);
                 effects2.exit("lineEnding");
                 return start3;
@@ -54000,19 +54885,19 @@
                     return sequenceClose(code2);
                 }
                 return nok2(code2);
             }
 
             function sequenceClose(code2) {
                 if (code2 === marker) {
-                    size++;
+                    size2++;
                     effects2.consume(code2);
                     return sequenceClose;
                 }
-                if (size >= sizeOpen) {
+                if (size2 >= sizeOpen) {
                     effects2.exit("codeFencedFenceSequence");
                     return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
                 }
                 return nok2(code2);
             }
 
             function sequenceCloseAfter(code2) {
@@ -54161,15 +55046,15 @@
 
     function previous$1(code2) {
         return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
     }
 
     function tokenizeCodeText(effects, ok2, nok) {
         let sizeOpen = 0;
-        let size;
+        let size2;
         let token;
         return start2;
 
         function start2(code2) {
             effects.enter("codeText");
             effects.enter("codeTextSequence");
             return sequenceOpen(code2);
@@ -54178,58 +55063,58 @@
         function sequenceOpen(code2) {
             if (code2 === 96) {
                 effects.consume(code2);
                 sizeOpen++;
                 return sequenceOpen;
             }
             effects.exit("codeTextSequence");
-            return between2(code2);
+            return between(code2);
         }
 
-        function between2(code2) {
+        function between(code2) {
             if (code2 === null) {
                 return nok(code2);
             }
             if (code2 === 32) {
                 effects.enter("space");
                 effects.consume(code2);
                 effects.exit("space");
-                return between2;
+                return between;
             }
             if (code2 === 96) {
                 token = effects.enter("codeTextSequence");
-                size = 0;
+                size2 = 0;
                 return sequenceClose(code2);
             }
             if (markdownLineEnding(code2)) {
                 effects.enter("lineEnding");
                 effects.consume(code2);
                 effects.exit("lineEnding");
-                return between2;
+                return between;
             }
             effects.enter("codeTextData");
             return data2(code2);
         }
 
         function data2(code2) {
             if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
                 effects.exit("codeTextData");
-                return between2(code2);
+                return between(code2);
             }
             effects.consume(code2);
             return data2;
         }
 
         function sequenceClose(code2) {
             if (code2 === 96) {
                 effects.consume(code2);
-                size++;
+                size2++;
                 return sequenceClose;
             }
-            if (size === sizeOpen) {
+            if (size2 === sizeOpen) {
                 effects.exit("codeTextSequence");
                 effects.exit("codeText");
                 return ok2(code2);
             }
             token.type = "codeTextData";
             return data2(code2);
         }
@@ -54549,29 +55434,29 @@
             }
             return raw2(code2);
         }
     }
 
     function factoryLabel(effects, ok2, nok, type2, markerType, stringType) {
         const self2 = this;
-        let size = 0;
+        let size2 = 0;
         let seen;
         return start2;
 
         function start2(code2) {
             effects.enter(type2);
             effects.enter(markerType);
             effects.consume(code2);
             effects.exit(markerType);
             effects.enter(stringType);
             return atBreak;
         }
 
         function atBreak(code2) {
-            if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
+            if (size2 > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || code2 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
                 return nok(code2);
             }
             if (code2 === 93) {
                 effects.exit(stringType);
                 effects.enter(markerType);
                 effects.consume(code2);
                 effects.exit(markerType);
@@ -54587,28 +55472,28 @@
             effects.enter("chunkString", {
                 contentType: "string"
             });
             return labelInside(code2);
         }
 
         function labelInside(code2) {
-            if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
+            if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size2++ > 999) {
                 effects.exit("chunkString");
                 return atBreak(code2);
             }
             effects.consume(code2);
             if (!seen)
                 seen = !markdownSpace(code2);
             return code2 === 92 ? labelEscape : labelInside;
         }
 
         function labelEscape(code2) {
             if (code2 === 91 || code2 === 92 || code2 === 93) {
                 effects.consume(code2);
-                size++;
+                size2++;
                 return labelInside;
             }
             return labelInside(code2);
         }
     }
 
     function factoryTitle(effects, ok2, nok, type2, markerType, stringType) {
@@ -54695,19 +55580,15 @@
                     start2,
                     seen ? "linePrefix" : "lineSuffix"
                 )(code2);
             }
             return ok2(code2);
         }
     }
-
-    function normalizeIdentifier(value) {
-        return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
-    }
-    const definition = {
+    const definition$1 = {
         name: "definition",
         tokenize: tokenizeDefinition
     };
     const titleBefore = {
         tokenize: tokenizeTitleBefore,
         partial: true
     };
@@ -54869,29 +55750,29 @@
                 ["exit", content2, context2]
             ]);
         }
         return events2;
     }
 
     function tokenizeHeadingAtx(effects, ok2, nok) {
-        let size = 0;
+        let size2 = 0;
         return start2;
 
         function start2(code2) {
             effects.enter("atxHeading");
             return before(code2);
         }
 
         function before(code2) {
             effects.enter("atxHeadingSequence");
             return sequenceOpen(code2);
         }
 
         function sequenceOpen(code2) {
-            if (code2 === 35 && size++ < 6) {
+            if (code2 === 35 && size2++ < 6) {
                 effects.consume(code2);
                 return sequenceOpen;
             }
             if (code2 === null || markdownLineEndingOrSpace(code2)) {
                 effects.exit("atxHeadingSequence");
                 return atBreak(code2);
             }
@@ -55027,15 +55908,15 @@
         return events2;
     }
 
     function tokenizeHtmlFlow(effects, ok2, nok) {
         const self2 = this;
         let marker;
         let closingTag;
-        let buffer2;
+        let buffer;
         let index2;
         let markerB;
         return start2;
 
         function start2(code2) {
             return before(code2);
         }
@@ -55060,15 +55941,15 @@
             if (code2 === 63) {
                 effects.consume(code2);
                 marker = 3;
                 return self2.interrupt ? ok2 : continuationDeclarationInside;
             }
             if (asciiAlpha(code2)) {
                 effects.consume(code2);
-                buffer2 = String.fromCharCode(code2);
+                buffer = String.fromCharCode(code2);
                 return tagName;
             }
             return nok(code2);
         }
 
         function declarationOpen(code2) {
             if (code2 === 45) {
@@ -55109,42 +55990,42 @@
             }
             return nok(code2);
         }
 
         function tagCloseStart(code2) {
             if (asciiAlpha(code2)) {
                 effects.consume(code2);
-                buffer2 = String.fromCharCode(code2);
+                buffer = String.fromCharCode(code2);
                 return tagName;
             }
             return nok(code2);
         }
 
         function tagName(code2) {
             if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
                 const slash = code2 === 47;
-                const name2 = buffer2.toLowerCase();
+                const name2 = buffer.toLowerCase();
                 if (!slash && !closingTag && htmlRawNames.includes(name2)) {
                     marker = 1;
                     return self2.interrupt ? ok2(code2) : continuation(code2);
                 }
-                if (htmlBlockNames.includes(buffer2.toLowerCase())) {
+                if (htmlBlockNames.includes(buffer.toLowerCase())) {
                     marker = 6;
                     if (slash) {
                         effects.consume(code2);
                         return basicSelfClosing;
                     }
                     return self2.interrupt ? ok2(code2) : continuation(code2);
                 }
                 marker = 7;
                 return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
             }
             if (code2 === 45 || asciiAlphanumeric(code2)) {
                 effects.consume(code2);
-                buffer2 += String.fromCharCode(code2);
+                buffer += String.fromCharCode(code2);
                 return tagName;
             }
             return nok(code2);
         }
 
         function basicSelfClosing(code2) {
             if (code2 === 62) {
@@ -55328,32 +56209,32 @@
             }
             return continuation(code2);
         }
 
         function continuationRawTagOpen(code2) {
             if (code2 === 47) {
                 effects.consume(code2);
-                buffer2 = "";
+                buffer = "";
                 return continuationRawEndTag;
             }
             return continuation(code2);
         }
 
         function continuationRawEndTag(code2) {
             if (code2 === 62) {
-                const name2 = buffer2.toLowerCase();
+                const name2 = buffer.toLowerCase();
                 if (htmlRawNames.includes(name2)) {
                     effects.consume(code2);
                     return continuationClose;
                 }
                 return continuation(code2);
             }
-            if (asciiAlpha(code2) && buffer2.length < 8) {
+            if (asciiAlpha(code2) && buffer.length < 8) {
                 effects.consume(code2);
-                buffer2 += String.fromCharCode(code2);
+                buffer += String.fromCharCode(code2);
                 return continuationRawEndTag;
             }
             return continuation(code2);
         }
 
         function continuationCdataInside(code2) {
             if (code2 === 93) {
@@ -56120,21 +57001,21 @@
         function start2(code2) {
             effects.enter("lineEnding");
             effects.consume(code2);
             effects.exit("lineEnding");
             return factorySpace(effects, ok2, "linePrefix");
         }
     }
-    const thematicBreak$1 = {
+    const thematicBreak$2 = {
         name: "thematicBreak",
         tokenize: tokenizeThematicBreak
     };
 
     function tokenizeThematicBreak(effects, ok2, nok) {
-        let size = 0;
+        let size2 = 0;
         let marker;
         return start2;
 
         function start2(code2) {
             effects.enter("thematicBreak");
             return before(code2);
         }
@@ -56145,32 +57026,32 @@
         }
 
         function atBreak(code2) {
             if (code2 === marker) {
                 effects.enter("thematicBreakSequence");
                 return sequence(code2);
             }
-            if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
+            if (size2 >= 3 && (code2 === null || markdownLineEnding(code2))) {
                 effects.exit("thematicBreak");
                 return ok2(code2);
             }
             return nok(code2);
         }
 
         function sequence(code2) {
             if (code2 === marker) {
                 effects.consume(code2);
-                size++;
+                size2++;
                 return sequence;
             }
             effects.exit("thematicBreakSequence");
             return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
         }
     }
-    const list$1 = {
+    const list$2 = {
         name: "list",
         tokenize: tokenizeListStart,
         continuation: {
             tokenize: tokenizeListContinuation
         },
         exit: tokenizeListEnd
     };
@@ -56183,45 +57064,45 @@
         partial: true
     };
 
     function tokenizeListStart(effects, ok2, nok) {
         const self2 = this;
         const tail = self2.events[self2.events.length - 1];
         let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
-        let size = 0;
+        let size2 = 0;
         return start2;
 
         function start2(code2) {
             const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
             if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
                 if (!self2.containerState.type) {
                     self2.containerState.type = kind;
                     effects.enter(kind, {
                         _container: true
                     });
                 }
                 if (kind === "listUnordered") {
                     effects.enter("listItemPrefix");
-                    return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
+                    return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$2, nok, atMarker)(code2) : atMarker(code2);
                 }
                 if (!self2.interrupt || code2 === 49) {
                     effects.enter("listItemPrefix");
                     effects.enter("listItemValue");
                     return inside2(code2);
                 }
             }
             return nok(code2);
         }
 
         function inside2(code2) {
-            if (asciiDigit(code2) && ++size < 10) {
+            if (asciiDigit(code2) && ++size2 < 10) {
                 effects.consume(code2);
                 return inside2;
             }
-            if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
+            if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
                 effects.exit("listItemValue");
                 return atMarker(code2);
             }
             return nok(code2);
         }
 
         function atMarker(code2) {
@@ -56289,15 +57170,15 @@
         }
 
         function notInCurrentItem(code2) {
             self2.containerState._closeFlow = true;
             self2.interrupt = void 0;
             return factorySpace(
                 effects,
-                effects.attempt(list$1, ok2, nok),
+                effects.attempt(list$2, ok2, nok),
                 "linePrefix",
                 self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
             )(code2);
         }
     }
 
     function tokenizeIndent$1(effects, ok2, nok) {
@@ -56472,15 +57353,15 @@
             return initial2;
         }
     }
     const resolver$1 = {
         resolveAll: createResolver()
     };
     const string$3 = initializeFactory("string");
-    const text$4 = initializeFactory("text");
+    const text$5 = initializeFactory("text");
 
     function initializeFactory(field) {
         return {
             tokenize: initializeText,
             resolveAll: createResolver(
                 field === "text" ? resolveAllLineSuffixes : void 0
             )
@@ -56563,44 +57444,44 @@
         let eventIndex = 0;
         while (++eventIndex <= events2.length) {
             if ((eventIndex === events2.length || events2[eventIndex][1].type === "lineEnding") && events2[eventIndex - 1][1].type === "data") {
                 const data2 = events2[eventIndex - 1][1];
                 const chunks = context2.sliceStream(data2);
                 let index2 = chunks.length;
                 let bufferIndex = -1;
-                let size = 0;
+                let size2 = 0;
                 let tabs;
                 while (index2--) {
                     const chunk = chunks[index2];
                     if (typeof chunk === "string") {
                         bufferIndex = chunk.length;
                         while (chunk.charCodeAt(bufferIndex - 1) === 32) {
-                            size++;
+                            size2++;
                             bufferIndex--;
                         }
                         if (bufferIndex)
                             break;
                         bufferIndex = -1;
                     } else if (chunk === -2) {
                         tabs = true;
-                        size++;
+                        size2++;
                     } else if (chunk === -1)
                     ;
                     else {
                         index2++;
                         break;
                     }
                 }
-                if (size) {
+                if (size2) {
                     const token = {
-                        type: eventIndex === events2.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
+                        type: eventIndex === events2.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
                         start: {
                             line: data2.end.line,
-                            column: data2.end.column - size,
-                            offset: data2.end.offset - size,
+                            column: data2.end.column - size2,
+                            offset: data2.end.offset - size2,
                             _index: data2.start._index + index2,
                             _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
                         },
                         end: Object.assign({}, data2.end)
                     };
                     data2.end = Object.assign({}, token.start);
                     if (data2.start.offset === data2.end.offset) {
@@ -56952,52 +57833,52 @@
                 }
             atTab = chunk === -2;
             result.push(value);
         }
         return result.join("");
     }
     const document$1 = {
-        [42]: list$1,
-        [43]: list$1,
-        [45]: list$1,
-        [48]: list$1,
-        [49]: list$1,
-        [50]: list$1,
-        [51]: list$1,
-        [52]: list$1,
-        [53]: list$1,
-        [54]: list$1,
-        [55]: list$1,
-        [56]: list$1,
-        [57]: list$1,
+        [42]: list$2,
+        [43]: list$2,
+        [45]: list$2,
+        [48]: list$2,
+        [49]: list$2,
+        [50]: list$2,
+        [51]: list$2,
+        [52]: list$2,
+        [53]: list$2,
+        [54]: list$2,
+        [55]: list$2,
+        [56]: list$2,
+        [57]: list$2,
         [62]: blockQuote
     };
     const contentInitial = {
-        [91]: definition
+        [91]: definition$1
     };
     const flowInitial = {
         [-2]: codeIndented,
         [-1]: codeIndented,
         [32]: codeIndented
     };
     const flow = {
         [35]: headingAtx,
-        [42]: thematicBreak$1,
-        [45]: [setextUnderline, thematicBreak$1],
+        [42]: thematicBreak$2,
+        [45]: [setextUnderline, thematicBreak$2],
         [60]: htmlFlow,
         [61]: setextUnderline,
-        [95]: thematicBreak$1,
+        [95]: thematicBreak$2,
         [96]: codeFenced,
         [126]: codeFenced
     };
     const string$2 = {
         [38]: characterReference,
         [92]: characterEscape
     };
-    const text$3 = {
+    const text$4 = {
         [-5]: lineEnding,
         [-4]: lineEnding,
         [-3]: lineEnding,
         [33]: labelStartImage,
         [38]: characterReference,
         [42]: attention,
         [60]: [autolink, htmlText],
@@ -57019,77 +57900,82 @@
     const defaultConstructs = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
         __proto__: null,
         document: document$1,
         contentInitial,
         flowInitial,
         flow,
         string: string$2,
-        text: text$3,
+        text: text$4,
         insideSpan,
         attentionMarkers,
         disable
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-    function parse$8(options) {
+    function parse$5(options) {
         const settings2 = options || {};
         const constructs2 = combineExtensions([defaultConstructs, ...settings2.extensions || []]);
         const parser2 = {
             defined: [],
             lazy: {},
             constructs: constructs2,
             content: create2(content$2),
             document: create2(document$2),
             flow: create2(flow$1),
             string: create2(string$3),
-            text: create2(text$4)
+            text: create2(text$5)
         };
         return parser2;
 
         function create2(initial2) {
             return creator2;
 
             function creator2(from) {
                 return createTokenizer(parser2, initial2, from);
             }
         }
     }
+
+    function postprocess(events2) {
+        while (!subtokenize(events2)) {}
+        return events2;
+    }
     const search$1 = /[\0\t\n\r]/g;
 
     function preprocess() {
         let column = 1;
-        let buffer2 = "";
+        let buffer = "";
         let start2 = true;
         let atCarriageReturn;
         return preprocessor2;
 
         function preprocessor2(value, encoding, end2) {
             const chunks = [];
             let match2;
             let next2;
             let startPosition;
             let endPosition;
             let code2;
-            value = buffer2 + value.toString(encoding);
+            value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
             startPosition = 0;
-            buffer2 = "";
+            buffer = "";
             if (start2) {
                 if (value.charCodeAt(0) === 65279) {
                     startPosition++;
                 }
                 start2 = void 0;
             }
             while (startPosition < value.length) {
                 search$1.lastIndex = startPosition;
                 match2 = search$1.exec(value);
                 endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
                 code2 = value.charCodeAt(endPosition);
                 if (!match2) {
-                    buffer2 = value.slice(startPosition);
+                    buffer = value.slice(startPosition);
                     break;
                 }
                 if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
                     chunks.push(-3);
                     atCarriageReturn = void 0;
                 } else {
                     if (atCarriageReturn) {
@@ -57125,34 +58011,21 @@
                     }
                 }
                 startPosition = endPosition + 1;
             }
             if (end2) {
                 if (atCarriageReturn)
                     chunks.push(-5);
-                if (buffer2)
-                    chunks.push(buffer2);
+                if (buffer)
+                    chunks.push(buffer);
                 chunks.push(null);
             }
             return chunks;
         }
     }
-
-    function postprocess(events2) {
-        while (!subtokenize(events2)) {}
-        return events2;
-    }
-
-    function decodeNumericCharacterReference(value, base2) {
-        const code2 = Number.parseInt(value, base2);
-        if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
-            return "\uFFFD";
-        }
-        return String.fromCharCode(code2);
-    }
     const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
 
     function decodeString(value) {
         return value.replace(characterEscapeOrReference, decode$1);
     }
 
     function decode$1($0, $1, $2) {
@@ -57163,70 +58036,71 @@
         if (head === 35) {
             const head2 = $2.charCodeAt(1);
             const hex2 = head2 === 120 || head2 === 88;
             return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
         }
         return decodeNamedCharacterReference($2) || $0;
     }
-    const own$a = {}.hasOwnProperty;
-    const fromMarkdown = function(value, encoding, options) {
+    const own$6 = {}.hasOwnProperty;
+
+    function fromMarkdown(value, encoding, options) {
         if (typeof encoding !== "string") {
             options = encoding;
             encoding = void 0;
         }
         return compiler(options)(
             postprocess(
-                parse$8(options).document().write(preprocess()(value, encoding, true))
+                parse$5(options).document().write(preprocess()(value, encoding, true))
             )
         );
-    };
+    }
 
     function compiler(options) {
         const config2 = {
             transforms: [],
             canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
             enter: {
                 autolink: opener(link2),
                 autolinkProtocol: onenterdata,
                 autolinkEmail: onenterdata,
                 atxHeading: opener(heading2),
                 blockQuote: opener(blockQuote2),
                 characterEscape: onenterdata,
                 characterReference: onenterdata,
                 codeFenced: opener(codeFlow),
-                codeFencedFenceInfo: buffer2,
-                codeFencedFenceMeta: buffer2,
-                codeIndented: opener(codeFlow, buffer2),
-                codeText: opener(codeText2, buffer2),
+                codeFencedFenceInfo: buffer,
+                codeFencedFenceMeta: buffer,
+                codeIndented: opener(codeFlow, buffer),
+                codeText: opener(codeText2, buffer),
                 codeTextData: onenterdata,
                 data: onenterdata,
                 codeFlowValue: onenterdata,
                 definition: opener(definition2),
-                definitionDestinationString: buffer2,
-                definitionLabelString: buffer2,
-                definitionTitleString: buffer2,
+                definitionDestinationString: buffer,
+                definitionLabelString: buffer,
+                definitionTitleString: buffer,
                 emphasis: opener(emphasis2),
                 hardBreakEscape: opener(hardBreak2),
                 hardBreakTrailing: opener(hardBreak2),
-                htmlFlow: opener(html2, buffer2),
+                htmlFlow: opener(html2, buffer),
                 htmlFlowData: onenterdata,
-                htmlText: opener(html2, buffer2),
+                htmlText: opener(html2, buffer),
                 htmlTextData: onenterdata,
                 image: opener(image2),
-                label: buffer2,
+                label: buffer,
                 link: opener(link2),
                 listItem: opener(listItem2),
                 listItemValue: onenterlistitemvalue,
                 listOrdered: opener(list2, onenterlistordered),
                 listUnordered: opener(list2),
                 paragraph: opener(paragraph2),
                 reference: onenterreference,
-                referenceString: buffer2,
-                resourceDestinationString: buffer2,
-                resourceTitleString: buffer2,
+                referenceString: buffer,
+                resourceDestinationString: buffer,
+                resourceTitleString: buffer,
                 setextHeading: opener(heading2),
                 strong: opener(strong2),
                 thematicBreak: opener(thematicBreak2)
             },
             exit: {
                 atxHeading: closer(),
                 atxHeadingSequence: onexitatxheadingsequence,
@@ -57289,18 +58163,17 @@
             };
             const context2 = {
                 stack: [tree],
                 tokenStack: [],
                 config: config2,
                 enter,
                 exit: exit2,
-                buffer: buffer2,
+                buffer,
                 resume,
-                setData,
-                getData
+                data: data2
             };
             const listStack = [];
             let index2 = -1;
             while (++index2 < events2.length) {
                 if (events2[index2][1].type === "listOrdered" || events2[index2][1].type === "listUnordered") {
                     if (events2[index2][0] === "enter") {
                         listStack.push(index2);
@@ -57309,15 +58182,15 @@
                         index2 = prepareList(events2, tail, index2);
                     }
                 }
             }
             index2 = -1;
             while (++index2 < events2.length) {
                 const handler = config2[events2[index2][0]];
-                if (own$a.call(handler, events2[index2][1].type)) {
+                if (own$6.call(handler, events2[index2][1].type)) {
                     handler[events2[index2][1].type].call(
                         Object.assign({
                                 sliceSerialize: events2[index2][2].sliceSerialize
                             },
                             context2
                         ),
                         events2[index2][1]
@@ -57358,32 +58231,45 @@
             let listSpread = false;
             let listItem3;
             let lineIndex;
             let firstBlankLineIndex;
             let atMarker;
             while (++index2 <= length) {
                 const event2 = events2[index2];
-                if (event2[1].type === "listUnordered" || event2[1].type === "listOrdered" || event2[1].type === "blockQuote") {
-                    if (event2[0] === "enter") {
-                        containerBalance++;
-                    } else {
-                        containerBalance--;
+                switch (event2[1].type) {
+                    case "listUnordered":
+                    case "listOrdered":
+                    case "blockQuote": {
+                        if (event2[0] === "enter") {
+                            containerBalance++;
+                        } else {
+                            containerBalance--;
+                        }
+                        atMarker = void 0;
+                        break;
                     }
-                    atMarker = void 0;
-                } else if (event2[1].type === "lineEndingBlank") {
-                    if (event2[0] === "enter") {
-                        if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
-                            firstBlankLineIndex = index2;
+                    case "lineEndingBlank": {
+                        if (event2[0] === "enter") {
+                            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
+                                firstBlankLineIndex = index2;
+                            }
+                            atMarker = void 0;
                         }
+                        break;
+                    }
+                    case "linePrefix":
+                    case "listItemValue":
+                    case "listItemMarker":
+                    case "listItemPrefix":
+                    case "listItemPrefixWhitespace": {
+                        break;
+                    }
+                    default: {
                         atMarker = void 0;
                     }
-                } else if (event2[1].type === "linePrefix" || event2[1].type === "listItemValue" || event2[1].type === "listItemMarker" || event2[1].type === "listItemPrefix" || event2[1].type === "listItemPrefixWhitespace")
-                ;
-                else {
-                    atMarker = void 0;
                 }
                 if (!containerBalance && event2[0] === "enter" && event2[1].type === "listItemPrefix" || containerBalance === -1 && event2[0] === "exit" && (event2[1].type === "listUnordered" || event2[1].type === "listOrdered")) {
                     if (listItem3) {
                         let tailIndex = index2;
                         lineIndex = void 0;
                         while (tailIndex--) {
                             const tailEvent = events2[tailIndex];
@@ -57409,66 +58295,60 @@
                             lineIndex ? events2[lineIndex][1].start : event2[1].end
                         );
                         events2.splice(lineIndex || index2, 0, ["exit", listItem3, event2[2]]);
                         index2++;
                         length++;
                     }
                     if (event2[1].type === "listItemPrefix") {
-                        listItem3 = {
+                        const item = {
                             type: "listItem",
                             _spread: false,
                             start: Object.assign({}, event2[1].start),
                             end: void 0
                         };
-                        events2.splice(index2, 0, ["enter", listItem3, event2[2]]);
+                        listItem3 = item;
+                        events2.splice(index2, 0, ["enter", item, event2[2]]);
                         index2++;
                         length++;
                         firstBlankLineIndex = void 0;
                         atMarker = true;
                     }
                 }
             }
             events2[start2][1]._spread = listSpread;
             return length;
         }
 
-        function setData(key, value) {
-            data2[key] = value;
-        }
-
-        function getData(key) {
-            return data2[key];
-        }
-
         function opener(create2, and) {
             return open;
 
             function open(token) {
                 enter.call(this, create2(token), token);
                 if (and)
                     and.call(this, token);
             }
         }
 
-        function buffer2() {
+        function buffer() {
             this.stack.push({
                 type: "fragment",
                 children: []
             });
         }
 
         function enter(node2, token, errorHandler) {
             const parent = this.stack[this.stack.length - 1];
-            parent.children.push(node2);
+            const siblings = parent.children;
+            siblings.push(node2);
             this.stack.push(node2);
             this.tokenStack.push([token, errorHandler]);
             node2.position = {
-                start: point$2(token.start)
+                start: point$2(token.start),
+                end: void 0
             };
-            return node2;
         }
 
         function closer(and) {
             return close;
 
             function close(token) {
                 if (and)
@@ -57492,30 +58372,29 @@
                     onExitError.call(this, token, open[0]);
                 } else {
                     const handler = open[1] || defaultOnError;
                     handler.call(this, token, open[0]);
                 }
             }
             node2.position.end = point$2(token.end);
-            return node2;
         }
 
         function resume() {
-            return toString$3(this.stack.pop());
+            return toString$4(this.stack.pop());
         }
 
         function onenterlistordered() {
-            setData("expectingFirstListItemValue", true);
+            this.data.expectingFirstListItemValue = true;
         }
 
         function onenterlistitemvalue(token) {
-            if (getData("expectingFirstListItemValue")) {
+            if (this.data.expectingFirstListItemValue) {
                 const ancestor = this.stack[this.stack.length - 2];
                 ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
-                setData("expectingFirstListItemValue");
+                this.data.expectingFirstListItemValue = void 0;
             }
         }
 
         function onexitcodefencedfenceinfo() {
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.lang = data3;
@@ -57524,25 +58403,25 @@
         function onexitcodefencedfencemeta() {
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.meta = data3;
         }
 
         function onexitcodefencedfence() {
-            if (getData("flowCodeInside"))
+            if (this.data.flowCodeInside)
                 return;
             this.buffer();
-            setData("flowCodeInside", true);
+            this.data.flowCodeInside = true;
         }
 
         function onexitcodefenced() {
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
-            setData("flowCodeInside");
+            this.data.flowCodeInside = void 0;
         }
 
         function onexitcodeindented() {
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.value = data3.replace(/(\r?\n|\r)$/g, "");
         }
@@ -57573,61 +58452,63 @@
             if (!node2.depth) {
                 const depth = this.sliceSerialize(token).length;
                 node2.depth = depth;
             }
         }
 
         function onexitsetextheadingtext() {
-            setData("setextHeadingSlurpLineEnding", true);
+            this.data.setextHeadingSlurpLineEnding = true;
         }
 
         function onexitsetextheadinglinesequence(token) {
             const node2 = this.stack[this.stack.length - 1];
-            node2.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
+            node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
         }
 
         function onexitsetextheading() {
-            setData("setextHeadingSlurpLineEnding");
+            this.data.setextHeadingSlurpLineEnding = void 0;
         }
 
         function onenterdata(token) {
             const node2 = this.stack[this.stack.length - 1];
-            let tail = node2.children[node2.children.length - 1];
+            const siblings = node2.children;
+            let tail = siblings[siblings.length - 1];
             if (!tail || tail.type !== "text") {
                 tail = text2();
                 tail.position = {
-                    start: point$2(token.start)
+                    start: point$2(token.start),
+                    end: void 0
                 };
-                node2.children.push(tail);
+                siblings.push(tail);
             }
             this.stack.push(tail);
         }
 
         function onexitdata(token) {
             const tail = this.stack.pop();
             tail.value += this.sliceSerialize(token);
             tail.position.end = point$2(token.end);
         }
 
         function onexitlineending(token) {
             const context2 = this.stack[this.stack.length - 1];
-            if (getData("atHardBreak")) {
+            if (this.data.atHardBreak) {
                 const tail = context2.children[context2.children.length - 1];
                 tail.position.end = point$2(token.end);
-                setData("atHardBreak");
+                this.data.atHardBreak = void 0;
                 return;
             }
-            if (!getData("setextHeadingSlurpLineEnding") && config2.canContainEols.includes(context2.type)) {
+            if (!this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context2.type)) {
                 onenterdata.call(this, token);
                 onexitdata.call(this, token);
             }
         }
 
         function onexithardbreak() {
-            setData("atHardBreak", true);
+            this.data.atHardBreak = true;
         }
 
         function onexithtmlflow() {
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.value = data3;
         }
@@ -57642,54 +58523,54 @@
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.value = data3;
         }
 
         function onexitlink() {
             const node2 = this.stack[this.stack.length - 1];
-            if (getData("inReference")) {
-                const referenceType = getData("referenceType") || "shortcut";
+            if (this.data.inReference) {
+                const referenceType = this.data.referenceType || "shortcut";
                 node2.type += "Reference";
                 node2.referenceType = referenceType;
                 delete node2.url;
                 delete node2.title;
             } else {
                 delete node2.identifier;
                 delete node2.label;
             }
-            setData("referenceType");
+            this.data.referenceType = void 0;
         }
 
         function onexitimage() {
             const node2 = this.stack[this.stack.length - 1];
-            if (getData("inReference")) {
-                const referenceType = getData("referenceType") || "shortcut";
+            if (this.data.inReference) {
+                const referenceType = this.data.referenceType || "shortcut";
                 node2.type += "Reference";
                 node2.referenceType = referenceType;
                 delete node2.url;
                 delete node2.title;
             } else {
                 delete node2.identifier;
                 delete node2.label;
             }
-            setData("referenceType");
+            this.data.referenceType = void 0;
         }
 
         function onexitlabeltext(token) {
             const string2 = this.sliceSerialize(token);
             const ancestor = this.stack[this.stack.length - 2];
             ancestor.label = decodeString(string2);
             ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
         }
 
         function onexitlabel() {
             const fragment2 = this.stack[this.stack.length - 1];
             const value = this.resume();
             const node2 = this.stack[this.stack.length - 1];
-            setData("inReference", true);
+            this.data.inReference = true;
             if (node2.type === "link") {
                 const children2 = fragment2.children;
                 node2.children = children2;
             } else {
                 node2.alt = value;
             }
         }
@@ -57703,45 +58584,45 @@
         function onexitresourcetitlestring() {
             const data3 = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.title = data3;
         }
 
         function onexitresource() {
-            setData("inReference");
+            this.data.inReference = void 0;
         }
 
         function onenterreference() {
-            setData("referenceType", "collapsed");
+            this.data.referenceType = "collapsed";
         }
 
         function onexitreferencestring(token) {
             const label = this.resume();
             const node2 = this.stack[this.stack.length - 1];
             node2.label = label;
             node2.identifier = normalizeIdentifier(
                 this.sliceSerialize(token)
             ).toLowerCase();
-            setData("referenceType", "full");
+            this.data.referenceType = "full";
         }
 
         function onexitcharacterreferencemarker(token) {
-            setData("characterReferenceType", token.type);
+            this.data.characterReferenceType = token.type;
         }
 
         function onexitcharacterreferencevalue(token) {
             const data3 = this.sliceSerialize(token);
-            const type2 = getData("characterReferenceType");
+            const type2 = this.data.characterReferenceType;
             let value;
             if (type2) {
                 value = decodeNumericCharacterReference(
                     data3,
                     type2 === "characterReferenceMarkerNumeric" ? 10 : 16
                 );
-                setData("characterReferenceType");
+                this.data.characterReferenceType = void 0;
             } else {
                 const result = decodeNamedCharacterReference(data3);
                 value = result;
             }
             const tail = this.stack.pop();
             tail.value += value;
             tail.position.end = point$2(token.end);
@@ -57798,15 +58679,15 @@
                 children: []
             };
         }
 
         function heading2() {
             return {
                 type: "heading",
-                depth: void 0,
+                depth: 0,
                 children: []
             };
         }
 
         function hardBreak2() {
             return {
                 type: "break"
@@ -57904,29 +58785,37 @@
             }
         }
     }
 
     function extension$1(combined, extension2) {
         let key;
         for (key in extension2) {
-            if (own$a.call(extension2, key)) {
-                if (key === "canContainEols") {
-                    const right2 = extension2[key];
-                    if (right2) {
-                        combined[key].push(...right2);
-                    }
-                } else if (key === "transforms") {
-                    const right2 = extension2[key];
-                    if (right2) {
-                        combined[key].push(...right2);
-                    }
-                } else if (key === "enter" || key === "exit") {
-                    const right2 = extension2[key];
-                    if (right2) {
-                        Object.assign(combined[key], right2);
+            if (own$6.call(extension2, key)) {
+                switch (key) {
+                    case "canContainEols": {
+                        const right2 = extension2[key];
+                        if (right2) {
+                            combined[key].push(...right2);
+                        }
+                        break;
+                    }
+                    case "transforms": {
+                        const right2 = extension2[key];
+                        if (right2) {
+                            combined[key].push(...right2);
+                        }
+                        break;
+                    }
+                    case "enter":
+                    case "exit": {
+                        const right2 = extension2[key];
+                        if (right2) {
+                            Object.assign(combined[key], right2);
+                        }
+                        break;
                     }
                 }
             }
         }
     }
 
     function defaultOnError(left2, right2) {
@@ -57947,60 +58836,57 @@
                     end: right2.end
                 }) + ") is still open"
             );
         }
     }
 
     function remarkParse(options) {
-        const parser2 = (doc2) => {
-            const settings2 = this.data("settings");
-            return fromMarkdown(
-                doc2,
-                Object.assign({}, settings2, options, {
-                    extensions: this.data("micromarkExtensions") || [],
-                    mdastExtensions: this.data("fromMarkdownExtensions") || []
-                })
-            );
-        };
-        Object.assign(this, {
-            Parser: parser2
-        });
+        const self2 = this;
+        self2.parser = parser2;
+
+        function parser2(doc2) {
+            return fromMarkdown(doc2, {
+                ...self2.data("settings"),
+                ...options,
+                extensions: self2.data("micromarkExtensions") || [],
+                mdastExtensions: self2.data("fromMarkdownExtensions") || []
+            });
+        }
     }
 
-    function blockquote(state, node2) {
+    function blockquote$1(state, node2) {
         const result = {
             type: "element",
             tagName: "blockquote",
             properties: {},
             children: state.wrap(state.all(node2), true)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function hardBreak(state, node2) {
+    function hardBreak$1(state, node2) {
         const result = {
             type: "element",
             tagName: "br",
             properties: {},
             children: []
         };
         state.patch(node2, result);
         return [state.applyData(node2, result), {
             type: "text",
             value: "\n"
         }];
     }
 
-    function code$2(state, node2) {
+    function code$3(state, node2) {
         const value = node2.value ? node2.value + "\n" : "";
-        const lang = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
         const properties = {};
-        if (lang) {
-            properties.className = ["language-" + lang];
+        if (node2.lang) {
+            properties.className = ["language-" + node2.lang];
         }
         let result = {
             type: "element",
             tagName: "code",
             properties,
             children: [{
                 type: "text",
@@ -58031,83 +58917,47 @@
             properties: {},
             children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function emphasis(state, node2) {
+    function emphasis$1(state, node2) {
         const result = {
             type: "element",
             tagName: "em",
             properties: {},
             children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function normalizeUri(value) {
-        const result = [];
-        let index2 = -1;
-        let start2 = 0;
-        let skip = 0;
-        while (++index2 < value.length) {
-            const code2 = value.charCodeAt(index2);
-            let replace2 = "";
-            if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
-                skip = 2;
-            } else if (code2 < 128) {
-                if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
-                    replace2 = String.fromCharCode(code2);
-                }
-            } else if (code2 > 55295 && code2 < 57344) {
-                const next2 = value.charCodeAt(index2 + 1);
-                if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
-                    replace2 = String.fromCharCode(code2, next2);
-                    skip = 1;
-                } else {
-                    replace2 = "\uFFFD";
-                }
-            } else {
-                replace2 = String.fromCharCode(code2);
-            }
-            if (replace2) {
-                result.push(value.slice(start2, index2), encodeURIComponent(replace2));
-                start2 = index2 + skip + 1;
-                replace2 = "";
-            }
-            if (skip) {
-                index2 += skip;
-                skip = 0;
-            }
-        }
-        return result.join("") + value.slice(start2);
-    }
-
     function footnoteReference$1(state, node2) {
+        const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
         const id2 = String(node2.identifier).toUpperCase();
         const safeId = normalizeUri(id2.toLowerCase());
         const index2 = state.footnoteOrder.indexOf(id2);
         let counter2;
-        if (index2 === -1) {
+        let reuseCounter = state.footnoteCounts.get(id2);
+        if (reuseCounter === void 0) {
+            reuseCounter = 0;
             state.footnoteOrder.push(id2);
-            state.footnoteCounts[id2] = 1;
             counter2 = state.footnoteOrder.length;
         } else {
-            state.footnoteCounts[id2]++;
             counter2 = index2 + 1;
         }
-        const reuseCounter = state.footnoteCounts[id2];
+        reuseCounter += 1;
+        state.footnoteCounts.set(id2, reuseCounter);
         const link2 = {
             type: "element",
             tagName: "a",
             properties: {
-                href: "#" + state.clobberPrefix + "fn-" + safeId,
-                id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
+                href: "#" + clobberPrefix + "fn-" + safeId,
+                id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
                 dataFootnoteRef: true,
                 ariaDescribedBy: ["footnote-label"]
             },
             children: [{
                 type: "text",
                 value: String(counter2)
             }]
@@ -58119,72 +58969,50 @@
             properties: {},
             children: [link2]
         };
         state.patch(node2, sup);
         return state.applyData(node2, sup);
     }
 
-    function footnote(state, node2) {
-        const footnoteById = state.footnoteById;
-        let no = 1;
-        while (no in footnoteById)
-            no++;
-        const identifier = String(no);
-        footnoteById[identifier] = {
-            type: "footnoteDefinition",
-            identifier,
-            children: [{
-                type: "paragraph",
-                children: node2.children
-            }],
-            position: node2.position
-        };
-        return footnoteReference$1(state, {
-            type: "footnoteReference",
-            identifier,
-            position: node2.position
-        });
-    }
-
-    function heading$1(state, node2) {
+    function heading$2(state, node2) {
         const result = {
             type: "element",
             tagName: "h" + node2.depth,
             properties: {},
             children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function html$3(state, node2) {
-        if (state.dangerous) {
+    function html$2(state, node2) {
+        if (state.options.allowDangerousHtml) {
             const result = {
                 type: "raw",
                 value: node2.value
             };
             state.patch(node2, result);
             return state.applyData(node2, result);
         }
-        return null;
+        return void 0;
     }
 
     function revert(state, node2) {
         const subtype = node2.referenceType;
         let suffix = "]";
         if (subtype === "collapsed") {
             suffix += "[]";
         } else if (subtype === "full") {
             suffix += "[" + (node2.label || node2.identifier) + "]";
         }
         if (node2.type === "imageReference") {
-            return {
+            return [{
                 type: "text",
                 value: "![" + node2.alt + suffix
-            };
+            }];
         }
         const contents = state.all(node2);
         const head = contents[0];
         if (head && head.type === "text") {
             head.value = "[" + head.value;
         } else {
             contents.unshift({
@@ -58200,16 +59028,17 @@
                 type: "text",
                 value: suffix
             });
         }
         return contents;
     }
 
-    function imageReference(state, node2) {
-        const def = state.definition(node2.identifier);
+    function imageReference$1(state, node2) {
+        const id2 = String(node2.identifier).toUpperCase();
+        const def = state.definitionById.get(id2);
         if (!def) {
             return revert(state, node2);
         }
         const properties = {
             src: normalizeUri(def.url || ""),
             alt: node2.alt
         };
@@ -58222,15 +59051,15 @@
             properties,
             children: []
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function image(state, node2) {
+    function image$1(state, node2) {
         const properties = {
             src: normalizeUri(node2.url)
         };
         if (node2.alt !== null && node2.alt !== void 0) {
             properties.alt = node2.alt;
         }
         if (node2.title !== null && node2.title !== void 0) {
@@ -58258,16 +59087,17 @@
             properties: {},
             children: [text2]
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function linkReference(state, node2) {
-        const def = state.definition(node2.identifier);
+    function linkReference$1(state, node2) {
+        const id2 = String(node2.identifier).toUpperCase();
+        const def = state.definitionById.get(id2);
         if (!def) {
             return revert(state, node2);
         }
         const properties = {
             href: normalizeUri(def.url || "")
         };
         if (def.title !== null && def.title !== void 0) {
@@ -58279,15 +59109,15 @@
             properties,
             children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function link$1(state, node2) {
+    function link$2(state, node2) {
         const properties = {
             href: normalizeUri(node2.url)
         };
         if (node2.title !== null && node2.title !== void 0) {
             properties.title = node2.title;
         }
         const result = {
@@ -58380,18 +59210,18 @@
             }
         }
         return loose;
     }
 
     function listItemLoose(node2) {
         const spread = node2.spread;
-        return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
+        return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
     }
 
-    function list(state, node2) {
+    function list$1(state, node2) {
         const properties = {};
         const results = state.all(node2);
         let index2 = -1;
         if (typeof node2.start === "number" && node2.start !== 1) {
             properties.start = node2.start;
         }
         while (++index2 < results.length) {
@@ -58407,66 +59237,44 @@
             properties,
             children: state.wrap(results, true)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function paragraph(state, node2) {
+    function paragraph$1(state, node2) {
         const result = {
             type: "element",
             tagName: "p",
             properties: {},
             children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function root$2(state, node2) {
+    function root$3(state, node2) {
         const result = {
             type: "root",
             children: state.wrap(state.all(node2))
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function strong(state, node2) {
+    function strong$1(state, node2) {
         const result = {
             type: "element",
             tagName: "strong",
             properties: {},
             children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
-    const pointStart = point$1("start");
-    const pointEnd = point$1("end");
-
-    function position$2(node2) {
-        return {
-            start: pointStart(node2),
-            end: pointEnd(node2)
-        };
-    }
-
-    function point$1(type2) {
-        return point2;
-
-        function point2(node2) {
-            const point3 = node2 && node2.position && node2.position[type2] || {};
-            return {
-                line: point3.line || null,
-                column: point3.column || null,
-                offset: point3.offset > -1 ? point3.offset : null
-            };
-        }
-    }
 
     function table(state, node2) {
         const rows = state.all(node2);
         const firstRow = rows.shift();
         const tableContent = [];
         if (firstRow) {
             const head = {
@@ -58481,17 +59289,17 @@
         if (rows.length > 0) {
             const body = {
                 type: "element",
                 tagName: "tbody",
                 properties: {},
                 children: state.wrap(rows, true)
             };
-            const start2 = pointStart(node2.children[1]);
-            const end2 = pointEnd(node2.children[node2.children.length - 1]);
-            if (start2.line && end2.line)
+            const start2 = pointStart$1(node2.children[1]);
+            const end2 = pointEnd$1(node2.children[node2.children.length - 1]);
+            if (start2 && end2)
                 body.position = {
                     start: start2,
                     end: end2
                 };
             tableContent.push(body);
         }
         const result = {
@@ -58524,15 +59332,15 @@
                 tagName,
                 properties,
                 children: []
             };
             if (cell) {
                 result2.children = state.all(cell);
                 state.patch(cell, result2);
-                result2 = state.applyData(node2, result2);
+                result2 = state.applyData(cell, result2);
             }
             cells2.push(result2);
         }
         const result = {
             type: "element",
             tagName: "tr",
             properties: {},
@@ -58589,443 +59397,725 @@
                 endIndex--;
                 code2 = value.codePointAt(endIndex - 1);
             }
         }
         return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
     }
 
-    function text$2(state, node2) {
+    function text$3(state, node2) {
         const result = {
             type: "text",
             value: trimLines(String(node2.value))
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function thematicBreak(state, node2) {
+    function thematicBreak$1(state, node2) {
         const result = {
             type: "element",
             tagName: "hr",
             properties: {},
             children: []
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
     const handlers$1 = {
-        blockquote,
-        break: hardBreak,
-        code: code$2,
+        blockquote: blockquote$1,
+        break: hardBreak$1,
+        code: code$3,
         delete: strikethrough,
-        emphasis,
+        emphasis: emphasis$1,
         footnoteReference: footnoteReference$1,
-        footnote,
-        heading: heading$1,
-        html: html$3,
-        imageReference,
-        image,
+        heading: heading$2,
+        html: html$2,
+        imageReference: imageReference$1,
+        image: image$1,
         inlineCode: inlineCode$1,
-        linkReference,
-        link: link$1,
+        linkReference: linkReference$1,
+        link: link$2,
         listItem: listItem$1,
-        list,
-        paragraph,
-        root: root$2,
-        strong,
+        list: list$1,
+        paragraph: paragraph$1,
+        root: root$3,
+        strong: strong$1,
         table,
         tableCell,
         tableRow,
-        text: text$2,
-        thematicBreak,
+        text: text$3,
+        thematicBreak: thematicBreak$1,
         toml: ignore,
         yaml: ignore,
         definition: ignore,
         footnoteDefinition: ignore
     };
 
     function ignore() {
-        return null;
+        return void 0;
     }
-    const convert = function(test2) {
-        if (test2 === void 0 || test2 === null) {
-            return ok;
+    const VOID = -1;
+    const PRIMITIVE = 0;
+    const ARRAY = 1;
+    const OBJECT = 2;
+    const DATE = 3;
+    const REGEXP = 4;
+    const MAP = 5;
+    const SET$1 = 6;
+    const ERROR = 7;
+    const BIGINT = 8;
+    const env = typeof self === "object" ? self : globalThis;
+    const deserializer = ($2, _2) => {
+        const as = (out, index2) => {
+            $2.set(index2, out);
+            return out;
+        };
+        const unpair = (index2) => {
+            if ($2.has(index2))
+                return $2.get(index2);
+            const [type2, value] = _2[index2];
+            switch (type2) {
+                case PRIMITIVE:
+                case VOID:
+                    return as(value, index2);
+                case ARRAY: {
+                    const arr = as([], index2);
+                    for (const index3 of value)
+                        arr.push(unpair(index3));
+                    return arr;
+                }
+                case OBJECT: {
+                    const object2 = as({}, index2);
+                    for (const [key, index3] of value)
+                        object2[unpair(key)] = unpair(index3);
+                    return object2;
+                }
+                case DATE:
+                    return as(new Date(value), index2);
+                case REGEXP: {
+                    const {
+                        source,
+                        flags
+                    } = value;
+                    return as(new RegExp(source, flags), index2);
+                }
+                case MAP: {
+                    const map2 = as( /* @__PURE__ */ new Map(), index2);
+                    for (const [key, index3] of value)
+                        map2.set(unpair(key), unpair(index3));
+                    return map2;
+                }
+                case SET$1: {
+                    const set2 = as( /* @__PURE__ */ new Set(), index2);
+                    for (const index3 of value)
+                        set2.add(unpair(index3));
+                    return set2;
+                }
+                case ERROR: {
+                    const {
+                        name: name2,
+                        message
+                    } = value;
+                    return as(new env[name2](message), index2);
+                }
+                case BIGINT:
+                    return as(BigInt(value), index2);
+                case "BigInt":
+                    return as(Object(BigInt(value)), index2);
+            }
+            return as(new env[type2](value), index2);
+        };
+        return unpair;
+    };
+    const deserialize = (serialized) => deserializer( /* @__PURE__ */ new Map(), serialized)(0);
+    const EMPTY = "";
+    const {
+        toString: toString$3
+    } = {};
+    const {
+        keys: keys$2
+    } = Object;
+    const typeOf = (value) => {
+        const type2 = typeof value;
+        if (type2 !== "object" || !value)
+            return [PRIMITIVE, type2];
+        const asString = toString$3.call(value).slice(8, -1);
+        switch (asString) {
+            case "Array":
+                return [ARRAY, EMPTY];
+            case "Object":
+                return [OBJECT, EMPTY];
+            case "Date":
+                return [DATE, EMPTY];
+            case "RegExp":
+                return [REGEXP, EMPTY];
+            case "Map":
+                return [MAP, EMPTY];
+            case "Set":
+                return [SET$1, EMPTY];
+        }
+        if (asString.includes("Array"))
+            return [ARRAY, asString];
+        if (asString.includes("Error"))
+            return [ERROR, asString];
+        return [OBJECT, asString];
+    };
+    const shouldSkip = ([TYPE, type2]) => TYPE === PRIMITIVE && (type2 === "function" || type2 === "symbol");
+    const serializer = (strict, json2, $2, _2) => {
+        const as = (out, value) => {
+            const index2 = _2.push(out) - 1;
+            $2.set(value, index2);
+            return index2;
+        };
+        const pair2 = (value) => {
+            if ($2.has(value))
+                return $2.get(value);
+            let [TYPE, type2] = typeOf(value);
+            switch (TYPE) {
+                case PRIMITIVE: {
+                    let entry = value;
+                    switch (type2) {
+                        case "bigint":
+                            TYPE = BIGINT;
+                            entry = value.toString();
+                            break;
+                        case "function":
+                        case "symbol":
+                            if (strict)
+                                throw new TypeError("unable to serialize " + type2);
+                            entry = null;
+                            break;
+                        case "undefined":
+                            return as([VOID], value);
+                    }
+                    return as([TYPE, entry], value);
+                }
+                case ARRAY: {
+                    if (type2)
+                        return as([type2, [...value]], value);
+                    const arr = [];
+                    const index2 = as([TYPE, arr], value);
+                    for (const entry of value)
+                        arr.push(pair2(entry));
+                    return index2;
+                }
+                case OBJECT: {
+                    if (type2) {
+                        switch (type2) {
+                            case "BigInt":
+                                return as([type2, value.toString()], value);
+                            case "Boolean":
+                            case "Number":
+                            case "String":
+                                return as([type2, value.valueOf()], value);
+                        }
+                    }
+                    if (json2 && "toJSON" in value)
+                        return pair2(value.toJSON());
+                    const entries = [];
+                    const index2 = as([TYPE, entries], value);
+                    for (const key of keys$2(value)) {
+                        if (strict || !shouldSkip(typeOf(value[key])))
+                            entries.push([pair2(key), pair2(value[key])]);
+                    }
+                    return index2;
+                }
+                case DATE:
+                    return as([TYPE, value.toISOString()], value);
+                case REGEXP: {
+                    const {
+                        source,
+                        flags
+                    } = value;
+                    return as([TYPE, {
+                        source,
+                        flags
+                    }], value);
+                }
+                case MAP: {
+                    const entries = [];
+                    const index2 = as([TYPE, entries], value);
+                    for (const [key, entry] of value) {
+                        if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
+                            entries.push([pair2(key), pair2(entry)]);
+                    }
+                    return index2;
+                }
+                case SET$1: {
+                    const entries = [];
+                    const index2 = as([TYPE, entries], value);
+                    for (const entry of value) {
+                        if (strict || !shouldSkip(typeOf(entry)))
+                            entries.push(pair2(entry));
+                    }
+                    return index2;
+                }
+            }
+            const {
+                message
+            } = value;
+            return as([TYPE, {
+                name: type2,
+                message
+            }], value);
+        };
+        return pair2;
+    };
+    const serialize$1 = (value, {
+        json: json2,
+        lossy
+    } = {}) => {
+        const _2 = [];
+        return serializer(!(json2 || lossy), !!json2, /* @__PURE__ */ new Map(), _2)(value), _2;
+    };
+    const structuredClone$1 = typeof structuredClone === "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize$1(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize$1(any, options));
+
+    function defaultFootnoteBackContent(_2, rereferenceIndex) {
+        const result = [{
+            type: "text",
+            value: "\u21A9"
+        }];
+        if (rereferenceIndex > 1) {
+            result.push({
+                type: "element",
+                tagName: "sup",
+                properties: {},
+                children: [{
+                    type: "text",
+                    value: String(rereferenceIndex)
+                }]
+            });
         }
-        if (typeof test2 === "string") {
-            return typeFactory(test2);
+        return result;
+    }
+
+    function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
+        return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
+    }
+
+    function footer(state) {
+        const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
+        const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
+        const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
+        const footnoteLabel = state.options.footnoteLabel || "Footnotes";
+        const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
+        const footnoteLabelProperties = state.options.footnoteLabelProperties || {
+            className: ["sr-only"]
+        };
+        const listItems = [];
+        let referenceIndex = -1;
+        while (++referenceIndex < state.footnoteOrder.length) {
+            const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
+            if (!def) {
+                continue;
+            }
+            const content2 = state.all(def);
+            const id2 = String(def.identifier).toUpperCase();
+            const safeId = normalizeUri(id2.toLowerCase());
+            let rereferenceIndex = 0;
+            const backReferences = [];
+            const counts = state.footnoteCounts.get(id2);
+            while (counts !== void 0 && ++rereferenceIndex <= counts) {
+                if (backReferences.length > 0) {
+                    backReferences.push({
+                        type: "text",
+                        value: " "
+                    });
+                }
+                let children2 = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
+                if (typeof children2 === "string") {
+                    children2 = {
+                        type: "text",
+                        value: children2
+                    };
+                }
+                backReferences.push({
+                    type: "element",
+                    tagName: "a",
+                    properties: {
+                        href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
+                        dataFootnoteBackref: "",
+                        ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
+                        className: ["data-footnote-backref"]
+                    },
+                    children: Array.isArray(children2) ? children2 : [children2]
+                });
+            }
+            const tail = content2[content2.length - 1];
+            if (tail && tail.type === "element" && tail.tagName === "p") {
+                const tailTail = tail.children[tail.children.length - 1];
+                if (tailTail && tailTail.type === "text") {
+                    tailTail.value += " ";
+                } else {
+                    tail.children.push({
+                        type: "text",
+                        value: " "
+                    });
+                }
+                tail.children.push(...backReferences);
+            } else {
+                content2.push(...backReferences);
+            }
+            const listItem2 = {
+                type: "element",
+                tagName: "li",
+                properties: {
+                    id: clobberPrefix + "fn-" + safeId
+                },
+                children: state.wrap(content2, true)
+            };
+            state.patch(def, listItem2);
+            listItems.push(listItem2);
         }
-        if (typeof test2 === "object") {
-            return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
+        if (listItems.length === 0) {
+            return;
+        }
+        return {
+            type: "element",
+            tagName: "section",
+            properties: {
+                dataFootnotes: true,
+                className: ["footnotes"]
+            },
+            children: [{
+                type: "element",
+                tagName: footnoteLabelTagName,
+                properties: {
+                    ...structuredClone$1(footnoteLabelProperties),
+                    id: "footnote-label"
+                },
+                children: [{
+                    type: "text",
+                    value: footnoteLabel
+                }]
+            }, {
+                type: "text",
+                value: "\n"
+            }, {
+                type: "element",
+                tagName: "ol",
+                properties: {},
+                children: state.wrap(listItems, true)
+            }, {
+                type: "text",
+                value: "\n"
+            }]
+        };
+    }
+    const convert$1 = function(test2) {
+        if (test2 === null || test2 === void 0) {
+            return ok$1;
         }
         if (typeof test2 === "function") {
-            return castFactory(test2);
+            return castFactory$1(test2);
+        }
+        if (typeof test2 === "object") {
+            return Array.isArray(test2) ? anyFactory$1(test2) : propsFactory$1(test2);
+        }
+        if (typeof test2 === "string") {
+            return typeFactory$1(test2);
         }
         throw new Error("Expected function, string, or object as test");
     };
 
-    function anyFactory(tests) {
+    function anyFactory$1(tests) {
         const checks2 = [];
         let index2 = -1;
         while (++index2 < tests.length) {
-            checks2[index2] = convert(tests[index2]);
+            checks2[index2] = convert$1(tests[index2]);
         }
-        return castFactory(any);
+        return castFactory$1(any);
 
         function any(...parameters) {
             let index3 = -1;
             while (++index3 < checks2.length) {
-                if (checks2[index3].call(this, ...parameters))
+                if (checks2[index3].apply(this, parameters))
                     return true;
             }
             return false;
         }
     }
 
-    function propsFactory(check) {
-        return castFactory(all2);
+    function propsFactory$1(check) {
+        const checkAsRecord = check;
+        return castFactory$1(all2);
 
         function all2(node2) {
+            const nodeAsRecord = node2;
             let key;
             for (key in check) {
-                if (node2[key] !== check[key])
+                if (nodeAsRecord[key] !== checkAsRecord[key])
                     return false;
             }
             return true;
         }
     }
 
-    function typeFactory(check) {
-        return castFactory(type2);
+    function typeFactory$1(check) {
+        return castFactory$1(type2);
 
         function type2(node2) {
             return node2 && node2.type === check;
         }
     }
 
-    function castFactory(check) {
-        return assertion;
+    function castFactory$1(testFunction) {
+        return check;
 
-        function assertion(node2, ...parameters) {
+        function check(value, index2, parent) {
             return Boolean(
-                node2 && typeof node2 === "object" && "type" in node2 && Boolean(check.call(this, node2, ...parameters))
+                looksLikeANode(value) && testFunction.call(
+                    this,
+                    value,
+                    typeof index2 === "number" ? index2 : void 0,
+                    parent || void 0
+                )
             );
         }
     }
 
-    function ok() {
+    function ok$1() {
         return true;
     }
 
-    function color$1(d2) {
+    function looksLikeANode(value) {
+        return value !== null && typeof value === "object" && "type" in value;
+    }
+
+    function color$2(d2) {
         return d2;
     }
-    const CONTINUE = true;
-    const EXIT = false;
-    const SKIP = "skip";
-    const visitParents = function(tree, test2, visitor, reverse) {
+    const empty$3 = [];
+    const CONTINUE$1 = true;
+    const EXIT$1 = false;
+    const SKIP$1 = "skip";
+
+    function visitParents$1(tree, test2, visitor, reverse) {
+        let check;
         if (typeof test2 === "function" && typeof visitor !== "function") {
             reverse = visitor;
             visitor = test2;
-            test2 = null;
+        } else {
+            check = test2;
         }
-        const is = convert(test2);
+        const is = convert$1(check);
         const step2 = reverse ? -1 : 1;
         factory2(tree, void 0, [])();
 
         function factory2(node2, index2, parents) {
             const value = node2 && typeof node2 === "object" ? node2 : {};
             if (typeof value.type === "string") {
                 const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
                 Object.defineProperty(visit2, "name", {
-                    value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
+                    value: "node (" + color$2(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
                 });
             }
             return visit2;
 
             function visit2() {
-                let result = [];
+                let result = empty$3;
                 let subresult;
                 let offset2;
                 let grandparents;
-                if (!test2 || is(node2, index2, parents[parents.length - 1] || null)) {
-                    result = toResult(visitor(node2, parents));
-                    if (result[0] === EXIT) {
+                if (!test2 || is(node2, index2, parents[parents.length - 1] || void 0)) {
+                    result = toResult$1(visitor(node2, parents));
+                    if (result[0] === EXIT$1) {
                         return result;
                     }
                 }
-                if (node2.children && result[0] !== SKIP) {
-                    offset2 = (reverse ? node2.children.length : -1) + step2;
-                    grandparents = parents.concat(node2);
-                    while (offset2 > -1 && offset2 < node2.children.length) {
-                        subresult = factory2(node2.children[offset2], offset2, grandparents)();
-                        if (subresult[0] === EXIT) {
-                            return subresult;
+                if ("children" in node2 && node2.children) {
+                    const nodeAsParent = node2;
+                    if (nodeAsParent.children && result[0] !== SKIP$1) {
+                        offset2 = (reverse ? nodeAsParent.children.length : -1) + step2;
+                        grandparents = parents.concat(nodeAsParent);
+                        while (offset2 > -1 && offset2 < nodeAsParent.children.length) {
+                            const child = nodeAsParent.children[offset2];
+                            subresult = factory2(child, offset2, grandparents)();
+                            if (subresult[0] === EXIT$1) {
+                                return subresult;
+                            }
+                            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
                         }
-                        offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
                     }
                 }
                 return result;
             }
         }
-    };
+    }
 
-    function toResult(value) {
+    function toResult$1(value) {
         if (Array.isArray(value)) {
             return value;
         }
         if (typeof value === "number") {
-            return [CONTINUE, value];
+            return [CONTINUE$1, value];
         }
-        return [value];
+        return value === null || value === void 0 ? empty$3 : [value];
     }
-    const visit = function(tree, test2, visitor, reverse) {
-        if (typeof test2 === "function" && typeof visitor !== "function") {
-            reverse = visitor;
-            visitor = test2;
-            test2 = null;
+
+    function visit$1(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
+        let reverse;
+        let test2;
+        let visitor;
+        if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
+            test2 = void 0;
+            visitor = testOrVisitor;
+            reverse = visitorOrReverse;
+        } else {
+            test2 = testOrVisitor;
+            visitor = visitorOrReverse;
+            reverse = maybeReverse;
         }
-        visitParents(tree, test2, overload, reverse);
+        visitParents$1(tree, test2, overload, reverse);
 
         function overload(node2, parents) {
             const parent = parents[parents.length - 1];
-            return visitor(
-                node2,
-                parent ? parent.children.indexOf(node2) : null,
-                parent
-            );
-        }
-    };
-
-    function generated(node2) {
-        return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
-    }
-    const own$9 = {}.hasOwnProperty;
-
-    function definitions(tree) {
-        const cache2 = /* @__PURE__ */ Object.create(null);
-        if (!tree || !tree.type) {
-            throw new Error("mdast-util-definitions expected node");
-        }
-        visit(tree, "definition", (definition3) => {
-            const id2 = clean(definition3.identifier);
-            if (id2 && !own$9.call(cache2, id2)) {
-                cache2[id2] = definition3;
-            }
-        });
-        return definition2;
-
-        function definition2(identifier) {
-            const id2 = clean(identifier);
-            return id2 && own$9.call(cache2, id2) ? cache2[id2] : null;
+            const index2 = parent ? parent.children.indexOf(node2) : void 0;
+            return visitor(node2, index2, parent);
         }
     }
-
-    function clean(value) {
-        return String(value || "").toUpperCase();
-    }
-    const own$8 = {}.hasOwnProperty;
+    const own$5 = {}.hasOwnProperty;
+    const emptyOptions$1 = {};
 
     function createState(tree, options) {
-        const settings2 = options || {};
-        const dangerous = settings2.allowDangerousHtml || false;
-        const footnoteById = {};
-        state.dangerous = dangerous;
-        state.clobberPrefix = settings2.clobberPrefix === void 0 || settings2.clobberPrefix === null ? "user-content-" : settings2.clobberPrefix;
-        state.footnoteLabel = settings2.footnoteLabel || "Footnotes";
-        state.footnoteLabelTagName = settings2.footnoteLabelTagName || "h2";
-        state.footnoteLabelProperties = settings2.footnoteLabelProperties || {
-            className: ["sr-only"]
-        };
-        state.footnoteBackLabel = settings2.footnoteBackLabel || "Back to content";
-        state.unknownHandler = settings2.unknownHandler;
-        state.passThrough = settings2.passThrough;
-        state.handlers = {
+        const settings2 = options || emptyOptions$1;
+        const definitionById = /* @__PURE__ */ new Map();
+        const footnoteById = /* @__PURE__ */ new Map();
+        const footnoteCounts = /* @__PURE__ */ new Map();
+        const handlers2 = {
             ...handlers$1,
             ...settings2.handlers
         };
-        state.definition = definitions(tree);
-        state.footnoteById = footnoteById;
-        state.footnoteOrder = [];
-        state.footnoteCounts = {};
-        state.patch = patch$2;
-        state.applyData = applyData;
-        state.one = oneBound;
-        state.all = allBound;
-        state.wrap = wrap;
-        state.augment = augment;
-        visit(tree, "footnoteDefinition", (definition2) => {
-            const id2 = String(definition2.identifier).toUpperCase();
-            if (!own$8.call(footnoteById, id2)) {
-                footnoteById[id2] = definition2;
+        const state = {
+            all: all2,
+            applyData,
+            definitionById,
+            footnoteById,
+            footnoteCounts,
+            footnoteOrder: [],
+            handlers: handlers2,
+            one: one2,
+            options: settings2,
+            patch: patch$2,
+            wrap: wrap$1
+        };
+        visit$1(tree, function(node2) {
+            if (node2.type === "definition" || node2.type === "footnoteDefinition") {
+                const map2 = node2.type === "definition" ? definitionById : footnoteById;
+                const id2 = String(node2.identifier).toUpperCase();
+                if (!map2.has(id2)) {
+                    map2.set(id2, node2);
+                }
             }
         });
         return state;
 
-        function augment(left2, right2) {
-            if (left2 && "data" in left2 && left2.data) {
-                const data2 = left2.data;
-                if (data2.hName) {
-                    if (right2.type !== "element") {
-                        right2 = {
-                            type: "element",
-                            tagName: "",
-                            properties: {},
-                            children: []
-                        };
-                    }
-                    right2.tagName = data2.hName;
-                }
-                if (right2.type === "element" && data2.hProperties) {
-                    right2.properties = {
-                        ...right2.properties,
-                        ...data2.hProperties
-                    };
-                }
-                if ("children" in right2 && right2.children && data2.hChildren) {
-                    right2.children = data2.hChildren;
-                }
+        function one2(node2, parent) {
+            const type2 = node2.type;
+            const handle2 = state.handlers[type2];
+            if (own$5.call(state.handlers, type2) && handle2) {
+                return handle2(state, node2, parent);
             }
-            if (left2) {
-                const ctx = "type" in left2 ? left2 : {
-                    position: left2
-                };
-                if (!generated(ctx)) {
-                    right2.position = {
-                        start: pointStart(ctx),
-                        end: pointEnd(ctx)
-                    };
+            if (state.options.passThrough && state.options.passThrough.includes(type2)) {
+                if ("children" in node2) {
+                    const {
+                        children: children2,
+                        ...shallow
+                    } = node2;
+                    const result = structuredClone$1(shallow);
+                    result.children = state.all(node2);
+                    return result;
                 }
+                return structuredClone$1(node2);
             }
-            return right2;
+            const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
+            return unknown2(state, node2, parent);
         }
 
-        function state(node2, tagName, props, children2) {
-            if (Array.isArray(props)) {
-                children2 = props;
-                props = {};
+        function all2(parent) {
+            const values = [];
+            if ("children" in parent) {
+                const nodes = parent.children;
+                let index2 = -1;
+                while (++index2 < nodes.length) {
+                    const result = state.one(nodes[index2], parent);
+                    if (result) {
+                        if (index2 && nodes[index2 - 1].type === "break") {
+                            if (!Array.isArray(result) && result.type === "text") {
+                                result.value = trimMarkdownSpaceStart(result.value);
+                            }
+                            if (!Array.isArray(result) && result.type === "element") {
+                                const head = result.children[0];
+                                if (head && head.type === "text") {
+                                    head.value = trimMarkdownSpaceStart(head.value);
+                                }
+                            }
+                        }
+                        if (Array.isArray(result)) {
+                            values.push(...result);
+                        } else {
+                            values.push(result);
+                        }
+                    }
+                }
             }
-            return augment(node2, {
-                type: "element",
-                tagName,
-                properties: props || {},
-                children: children2 || []
-            });
-        }
-
-        function oneBound(node2, parent) {
-            return one$3(state, node2, parent);
-        }
-
-        function allBound(parent) {
-            return all$2(state, parent);
+            return values;
         }
     }
 
     function patch$2(from, to2) {
         if (from.position)
-            to2.position = position$2(from);
+            to2.position = position$3(from);
     }
 
     function applyData(from, to2) {
         let result = to2;
         if (from && from.data) {
             const hName = from.data.hName;
             const hChildren = from.data.hChildren;
             const hProperties = from.data.hProperties;
             if (typeof hName === "string") {
                 if (result.type === "element") {
                     result.tagName = hName;
                 } else {
+                    const children2 = "children" in result ? result.children : [result];
                     result = {
                         type: "element",
                         tagName: hName,
                         properties: {},
-                        children: []
+                        children: children2
                     };
                 }
             }
             if (result.type === "element" && hProperties) {
-                result.properties = {
-                    ...result.properties,
-                    ...hProperties
-                };
+                Object.assign(result.properties, structuredClone$1(hProperties));
             }
             if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
                 result.children = hChildren;
             }
         }
         return result;
     }
 
-    function one$3(state, node2, parent) {
-        const type2 = node2 && node2.type;
-        if (!type2) {
-            throw new Error("Expected node, got `" + node2 + "`");
-        }
-        if (own$8.call(state.handlers, type2)) {
-            return state.handlers[type2](state, node2, parent);
-        }
-        if (state.passThrough && state.passThrough.includes(type2)) {
-            return "children" in node2 ? {
-                ...node2,
-                children: all$2(state, node2)
-            } : node2;
-        }
-        if (state.unknownHandler) {
-            return state.unknownHandler(state, node2, parent);
-        }
-        return defaultUnknownHandler(state, node2);
-    }
-
-    function all$2(state, parent) {
-        const values = [];
-        if ("children" in parent) {
-            const nodes = parent.children;
-            let index2 = -1;
-            while (++index2 < nodes.length) {
-                const result = one$3(state, nodes[index2], parent);
-                if (result) {
-                    if (index2 && nodes[index2 - 1].type === "break") {
-                        if (!Array.isArray(result) && result.type === "text") {
-                            result.value = result.value.replace(/^\s+/, "");
-                        }
-                        if (!Array.isArray(result) && result.type === "element") {
-                            const head = result.children[0];
-                            if (head && head.type === "text") {
-                                head.value = head.value.replace(/^\s+/, "");
-                            }
-                        }
-                    }
-                    if (Array.isArray(result)) {
-                        values.push(...result);
-                    } else {
-                        values.push(result);
-                    }
-                }
-            }
-        }
-        return values;
-    }
-
     function defaultUnknownHandler(state, node2) {
         const data2 = node2.data || {};
-        const result = "value" in node2 && !(own$8.call(data2, "hProperties") || own$8.call(data2, "hChildren")) ? {
+        const result = "value" in node2 && !(own$5.call(data2, "hProperties") || own$5.call(data2, "hChildren")) ? {
             type: "text",
             value: node2.value
         } : {
             type: "element",
             tagName: "div",
             properties: {},
-            children: all$2(state, node2)
+            children: state.all(node2)
         };
         state.patch(node2, result);
         return state.applyData(node2, result);
     }
 
-    function wrap(nodes, loose) {
+    function wrap$1(nodes, loose) {
         const result = [];
         let index2 = -1;
         if (loose) {
             result.push({
                 type: "text",
                 value: "\n"
             });
@@ -59043,2014 +60133,1178 @@
                 type: "text",
                 value: "\n"
             });
         }
         return result;
     }
 
-    function footer(state) {
-        const listItems = [];
-        let index2 = -1;
-        while (++index2 < state.footnoteOrder.length) {
-            const def = state.footnoteById[state.footnoteOrder[index2]];
-            if (!def) {
-                continue;
-            }
-            const content2 = state.all(def);
-            const id2 = String(def.identifier).toUpperCase();
-            const safeId = normalizeUri(id2.toLowerCase());
-            let referenceIndex = 0;
-            const backReferences = [];
-            while (++referenceIndex <= state.footnoteCounts[id2]) {
-                const backReference = {
-                    type: "element",
-                    tagName: "a",
-                    properties: {
-                        href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
-                        dataFootnoteBackref: true,
-                        className: ["data-footnote-backref"],
-                        ariaLabel: state.footnoteBackLabel
-                    },
-                    children: [{
-                        type: "text",
-                        value: "\u21A9"
-                    }]
-                };
-                if (referenceIndex > 1) {
-                    backReference.children.push({
-                        type: "element",
-                        tagName: "sup",
-                        children: [{
-                            type: "text",
-                            value: String(referenceIndex)
-                        }]
-                    });
-                }
-                if (backReferences.length > 0) {
-                    backReferences.push({
-                        type: "text",
-                        value: " "
-                    });
-                }
-                backReferences.push(backReference);
-            }
-            const tail = content2[content2.length - 1];
-            if (tail && tail.type === "element" && tail.tagName === "p") {
-                const tailTail = tail.children[tail.children.length - 1];
-                if (tailTail && tailTail.type === "text") {
-                    tailTail.value += " ";
-                } else {
-                    tail.children.push({
-                        type: "text",
-                        value: " "
-                    });
-                }
-                tail.children.push(...backReferences);
-            } else {
-                content2.push(...backReferences);
-            }
-            const listItem2 = {
-                type: "element",
-                tagName: "li",
-                properties: {
-                    id: state.clobberPrefix + "fn-" + safeId
-                },
-                children: state.wrap(content2, true)
-            };
-            state.patch(def, listItem2);
-            listItems.push(listItem2);
-        }
-        if (listItems.length === 0) {
-            return;
+    function trimMarkdownSpaceStart(value) {
+        let index2 = 0;
+        let code2 = value.charCodeAt(index2);
+        while (code2 === 9 || code2 === 32) {
+            index2++;
+            code2 = value.charCodeAt(index2);
         }
-        return {
-            type: "element",
-            tagName: "section",
-            properties: {
-                dataFootnotes: true,
-                className: ["footnotes"]
-            },
-            children: [{
-                type: "element",
-                tagName: state.footnoteLabelTagName,
-                properties: {
-                    ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
-                    id: "footnote-label"
-                },
-                children: [{
-                    type: "text",
-                    value: state.footnoteLabel
-                }]
-            }, {
-                type: "text",
-                value: "\n"
-            }, {
-                type: "element",
-                tagName: "ol",
-                properties: {},
-                children: state.wrap(listItems, true)
-            }, {
-                type: "text",
-                value: "\n"
-            }]
-        };
+        return value.slice(index2);
     }
 
     function toHast(tree, options) {
         const state = createState(tree, options);
-        const node2 = state.one(tree, null);
+        const node2 = state.one(tree, void 0);
         const foot = footer(state);
+        const result = Array.isArray(node2) ? {
+            type: "root",
+            children: node2
+        } : node2 || {
+            type: "root",
+            children: []
+        };
         if (foot) {
-            node2.children.push({
+            result.children.push({
                 type: "text",
                 value: "\n"
             }, foot);
         }
-        return Array.isArray(node2) ? {
-            type: "root",
-            children: node2
-        } : node2;
+        return result;
     }
-    const remarkRehype = function(destination, options) {
-        return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
-    };
-    const remarkRehype$1 = remarkRehype;
 
-    function bridge(destination, options) {
-        return (node2, file, next2) => {
-            destination.run(toHast(node2, options), file, (error2) => {
-                next2(error2);
+    function remarkRehype(destination, options) {
+        if (destination && "run" in destination) {
+            return async function(tree, file) {
+                const hastTree = toHast(tree, {
+                    file,
+                    ...options
+                });
+                await destination.run(hastTree, file);
+            };
+        }
+        return function(tree, file) {
+            return toHast(tree, {
+                file,
+                ...options || destination
             });
         };
     }
 
-    function mutate(options) {
-        return (node2) => toHast(node2, options);
+    function bail(error2) {
+        if (error2) {
+            throw error2;
+        }
     }
-    class Schema {
-        constructor(property, normal, space2) {
-            this.property = property;
-            this.normal = normal;
-            if (space2) {
-                this.space = space2;
+    var hasOwn$2 = Object.prototype.hasOwnProperty;
+    var toStr$2 = Object.prototype.toString;
+    var defineProperty$2 = Object.defineProperty;
+    var gOPD$1 = Object.getOwnPropertyDescriptor;
+    var isArray$a = function isArray2(arr) {
+        if (typeof Array.isArray === "function") {
+            return Array.isArray(arr);
+        }
+        return toStr$2.call(arr) === "[object Array]";
+    };
+    var isPlainObject$3 = function isPlainObject2(obj) {
+        if (!obj || toStr$2.call(obj) !== "[object Object]") {
+            return false;
+        }
+        var hasOwnConstructor = hasOwn$2.call(obj, "constructor");
+        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$2.call(obj.constructor.prototype, "isPrototypeOf");
+        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
+            return false;
+        }
+        var key;
+        for (key in obj) {}
+        return typeof key === "undefined" || hasOwn$2.call(obj, key);
+    };
+    var setProperty = function setProperty2(target, options) {
+        if (defineProperty$2 && options.name === "__proto__") {
+            defineProperty$2(target, options.name, {
+                enumerable: true,
+                configurable: true,
+                value: options.newValue,
+                writable: true
+            });
+        } else {
+            target[options.name] = options.newValue;
+        }
+    };
+    var getProperty = function getProperty2(obj, name2) {
+        if (name2 === "__proto__") {
+            if (!hasOwn$2.call(obj, name2)) {
+                return void 0;
+            } else if (gOPD$1) {
+                return gOPD$1(obj, name2).value;
+            }
+        }
+        return obj[name2];
+    };
+    var extend$3 = function extend2() {
+        var options, name2, src, copy2, copyIsArray, clone2;
+        var target = arguments[0];
+        var i2 = 1;
+        var length = arguments.length;
+        var deep = false;
+        if (typeof target === "boolean") {
+            deep = target;
+            target = arguments[1] || {};
+            i2 = 2;
+        }
+        if (target == null || typeof target !== "object" && typeof target !== "function") {
+            target = {};
+        }
+        for (; i2 < length; ++i2) {
+            options = arguments[i2];
+            if (options != null) {
+                for (name2 in options) {
+                    src = getProperty(target, name2);
+                    copy2 = getProperty(options, name2);
+                    if (target !== copy2) {
+                        if (deep && copy2 && (isPlainObject$3(copy2) || (copyIsArray = isArray$a(copy2)))) {
+                            if (copyIsArray) {
+                                copyIsArray = false;
+                                clone2 = src && isArray$a(src) ? src : [];
+                            } else {
+                                clone2 = src && isPlainObject$3(src) ? src : {};
+                            }
+                            setProperty(target, {
+                                name: name2,
+                                newValue: extend2(deep, clone2, copy2)
+                            });
+                        } else if (typeof copy2 !== "undefined") {
+                            setProperty(target, {
+                                name: name2,
+                                newValue: copy2
+                            });
+                        }
+                    }
+                }
             }
         }
+        return target;
+    };
+
+    function isPlainObject$2(value) {
+        if (typeof value !== "object" || value === null) {
+            return false;
+        }
+        const prototype = Object.getPrototypeOf(value);
+        return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
     }
-    Schema.prototype.property = {};
-    Schema.prototype.normal = {};
-    Schema.prototype.space = null;
 
-    function merge$1(definitions2, space2) {
-        const property = {};
-        const normal = {};
-        let index2 = -1;
-        while (++index2 < definitions2.length) {
-            Object.assign(property, definitions2[index2].property);
-            Object.assign(normal, definitions2[index2].normal);
+    function trough() {
+        const fns = [];
+        const pipeline = {
+            run,
+            use
+        };
+        return pipeline;
+
+        function run(...values) {
+            let middlewareIndex = -1;
+            const callback = values.pop();
+            if (typeof callback !== "function") {
+                throw new TypeError("Expected function as last argument, not " + callback);
+            }
+            next2(null, ...values);
+
+            function next2(error2, ...output2) {
+                const fn2 = fns[++middlewareIndex];
+                let index2 = -1;
+                if (error2) {
+                    callback(error2);
+                    return;
+                }
+                while (++index2 < values.length) {
+                    if (output2[index2] === null || output2[index2] === void 0) {
+                        output2[index2] = values[index2];
+                    }
+                }
+                values = output2;
+                if (fn2) {
+                    wrap(fn2, next2)(...output2);
+                } else {
+                    callback(null, ...output2);
+                }
+            }
+        }
+
+        function use(middelware) {
+            if (typeof middelware !== "function") {
+                throw new TypeError(
+                    "Expected `middelware` to be a function, not " + middelware
+                );
+            }
+            fns.push(middelware);
+            return pipeline;
         }
-        return new Schema(property, normal, space2);
     }
 
-    function normalize$1(value) {
-        return value.toLowerCase();
+    function wrap(middleware, callback) {
+        let called;
+        return wrapped;
+
+        function wrapped(...parameters) {
+            const fnExpectsCallback = middleware.length > parameters.length;
+            let result;
+            if (fnExpectsCallback) {
+                parameters.push(done);
+            }
+            try {
+                result = middleware.apply(this, parameters);
+            } catch (error2) {
+                const exception = error2;
+                if (fnExpectsCallback && called) {
+                    throw exception;
+                }
+                return done(exception);
+            }
+            if (!fnExpectsCallback) {
+                if (result instanceof Promise) {
+                    result.then(then, done);
+                } else if (result instanceof Error) {
+                    done(result);
+                } else {
+                    then(result);
+                }
+            }
+        }
+
+        function done(error2, ...output2) {
+            if (!called) {
+                called = true;
+                callback(error2, ...output2);
+            }
+        }
+
+        function then(value) {
+            done(null, value);
+        }
     }
-    class Info {
-        constructor(property, attribute) {
-            this.property = property;
-            this.attribute = attribute;
+    const path$2 = {
+        basename,
+        dirname,
+        extname,
+        join,
+        sep: "/"
+    };
+
+    function basename(path2, ext) {
+        if (ext !== void 0 && typeof ext !== "string") {
+            throw new TypeError('"ext" argument must be a string');
+        }
+        assertPath$2(path2);
+        let start2 = 0;
+        let end2 = -1;
+        let index2 = path2.length;
+        let seenNonSlash;
+        if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
+            while (index2--) {
+                if (path2.codePointAt(index2) === 47) {
+                    if (seenNonSlash) {
+                        start2 = index2 + 1;
+                        break;
+                    }
+                } else if (end2 < 0) {
+                    seenNonSlash = true;
+                    end2 = index2 + 1;
+                }
+            }
+            return end2 < 0 ? "" : path2.slice(start2, end2);
+        }
+        if (ext === path2) {
+            return "";
+        }
+        let firstNonSlashEnd = -1;
+        let extIndex = ext.length - 1;
+        while (index2--) {
+            if (path2.codePointAt(index2) === 47) {
+                if (seenNonSlash) {
+                    start2 = index2 + 1;
+                    break;
+                }
+            } else {
+                if (firstNonSlashEnd < 0) {
+                    seenNonSlash = true;
+                    firstNonSlashEnd = index2 + 1;
+                }
+                if (extIndex > -1) {
+                    if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
+                        if (extIndex < 0) {
+                            end2 = index2;
+                        }
+                    } else {
+                        extIndex = -1;
+                        end2 = firstNonSlashEnd;
+                    }
+                }
+            }
+        }
+        if (start2 === end2) {
+            end2 = firstNonSlashEnd;
+        } else if (end2 < 0) {
+            end2 = path2.length;
         }
+        return path2.slice(start2, end2);
     }
-    Info.prototype.space = null;
-    Info.prototype.boolean = false;
-    Info.prototype.booleanish = false;
-    Info.prototype.overloadedBoolean = false;
-    Info.prototype.number = false;
-    Info.prototype.commaSeparated = false;
-    Info.prototype.spaceSeparated = false;
-    Info.prototype.commaOrSpaceSeparated = false;
-    Info.prototype.mustUseProperty = false;
-    Info.prototype.defined = false;
-    let powers = 0;
-    const boolean = increment();
-    const booleanish = increment();
-    const overloadedBoolean = increment();
-    const number$3 = increment();
-    const spaceSeparated = increment();
-    const commaSeparated = increment();
-    const commaOrSpaceSeparated = increment();
 
-    function increment() {
-        return 2 ** ++powers;
+    function dirname(path2) {
+        assertPath$2(path2);
+        if (path2.length === 0) {
+            return ".";
+        }
+        let end2 = -1;
+        let index2 = path2.length;
+        let unmatchedSlash;
+        while (--index2) {
+            if (path2.codePointAt(index2) === 47) {
+                if (unmatchedSlash) {
+                    end2 = index2;
+                    break;
+                }
+            } else if (!unmatchedSlash) {
+                unmatchedSlash = true;
+            }
+        }
+        return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
     }
-    const types$1 = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
-        __proto__: null,
-        boolean,
-        booleanish,
-        overloadedBoolean,
-        number: number$3,
-        spaceSeparated,
-        commaSeparated,
-        commaOrSpaceSeparated
-    }, Symbol.toStringTag, {
-        value: "Module"
-    }));
-    const checks = Object.keys(types$1);
-    class DefinedInfo extends Info {
-        constructor(property, attribute, mask, space2) {
-            let index2 = -1;
-            super(property, attribute);
-            mark(this, "space", space2);
-            if (typeof mask === "number") {
-                while (++index2 < checks.length) {
-                    const check = checks[index2];
-                    mark(this, checks[index2], (mask & types$1[check]) === types$1[check]);
+
+    function extname(path2) {
+        assertPath$2(path2);
+        let index2 = path2.length;
+        let end2 = -1;
+        let startPart = 0;
+        let startDot = -1;
+        let preDotState = 0;
+        let unmatchedSlash;
+        while (index2--) {
+            const code2 = path2.codePointAt(index2);
+            if (code2 === 47) {
+                if (unmatchedSlash) {
+                    startPart = index2 + 1;
+                    break;
+                }
+                continue;
+            }
+            if (end2 < 0) {
+                unmatchedSlash = true;
+                end2 = index2 + 1;
+            }
+            if (code2 === 46) {
+                if (startDot < 0) {
+                    startDot = index2;
+                } else if (preDotState !== 1) {
+                    preDotState = 1;
                 }
+            } else if (startDot > -1) {
+                preDotState = -1;
             }
         }
+        if (startDot < 0 || end2 < 0 || preDotState === 0 || preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
+            return "";
+        }
+        return path2.slice(startDot, end2);
     }
-    DefinedInfo.prototype.defined = true;
 
-    function mark(values, key, value) {
-        if (value) {
-            values[key] = value;
+    function join(...segments) {
+        let index2 = -1;
+        let joined;
+        while (++index2 < segments.length) {
+            assertPath$2(segments[index2]);
+            if (segments[index2]) {
+                joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
+            }
         }
+        return joined === void 0 ? "." : normalize$1(joined);
     }
-    const own$7 = {}.hasOwnProperty;
 
-    function create$1(definition2) {
-        const property = {};
-        const normal = {};
-        let prop;
-        for (prop in definition2.properties) {
-            if (own$7.call(definition2.properties, prop)) {
-                const value = definition2.properties[prop];
-                const info = new DefinedInfo(
-                    prop,
-                    definition2.transform(definition2.attributes || {}, prop),
-                    value,
-                    definition2.space
-                );
-                if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
-                    info.mustUseProperty = true;
+    function normalize$1(path2) {
+        assertPath$2(path2);
+        const absolute = path2.codePointAt(0) === 47;
+        let value = normalizeString(path2, !absolute);
+        if (value.length === 0 && !absolute) {
+            value = ".";
+        }
+        if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
+            value += "/";
+        }
+        return absolute ? "/" + value : value;
+    }
+
+    function normalizeString(path2, allowAboveRoot) {
+        let result = "";
+        let lastSegmentLength = 0;
+        let lastSlash = -1;
+        let dots = 0;
+        let index2 = -1;
+        let code2;
+        let lastSlashIndex;
+        while (++index2 <= path2.length) {
+            if (index2 < path2.length) {
+                code2 = path2.codePointAt(index2);
+            } else if (code2 === 47) {
+                break;
+            } else {
+                code2 = 47;
+            }
+            if (code2 === 47) {
+                if (lastSlash === index2 - 1 || dots === 1)
+                ;
+                else if (lastSlash !== index2 - 1 && dots === 2) {
+                    if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
+                        if (result.length > 2) {
+                            lastSlashIndex = result.lastIndexOf("/");
+                            if (lastSlashIndex !== result.length - 1) {
+                                if (lastSlashIndex < 0) {
+                                    result = "";
+                                    lastSegmentLength = 0;
+                                } else {
+                                    result = result.slice(0, lastSlashIndex);
+                                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
+                                }
+                                lastSlash = index2;
+                                dots = 0;
+                                continue;
+                            }
+                        } else if (result.length > 0) {
+                            result = "";
+                            lastSegmentLength = 0;
+                            lastSlash = index2;
+                            dots = 0;
+                            continue;
+                        }
+                    }
+                    if (allowAboveRoot) {
+                        result = result.length > 0 ? result + "/.." : "..";
+                        lastSegmentLength = 2;
+                    }
+                } else {
+                    if (result.length > 0) {
+                        result += "/" + path2.slice(lastSlash + 1, index2);
+                    } else {
+                        result = path2.slice(lastSlash + 1, index2);
+                    }
+                    lastSegmentLength = index2 - lastSlash - 1;
                 }
-                property[prop] = info;
-                normal[normalize$1(prop)] = prop;
-                normal[normalize$1(info.attribute)] = prop;
+                lastSlash = index2;
+                dots = 0;
+            } else if (code2 === 46 && dots > -1) {
+                dots++;
+            } else {
+                dots = -1;
             }
         }
-        return new Schema(property, normal, definition2.space);
+        return result;
     }
-    const xlink = create$1({
-        space: "xlink",
-        transform(_2, prop) {
-            return "xlink:" + prop.slice(5).toLowerCase();
-        },
-        properties: {
-            xLinkActuate: null,
-            xLinkArcRole: null,
-            xLinkHref: null,
-            xLinkRole: null,
-            xLinkShow: null,
-            xLinkTitle: null,
-            xLinkType: null
-        }
-    });
-    const xml = create$1({
-        space: "xml",
-        transform(_2, prop) {
-            return "xml:" + prop.slice(3).toLowerCase();
-        },
-        properties: {
-            xmlLang: null,
-            xmlBase: null,
-            xmlSpace: null
+
+    function assertPath$2(path2) {
+        if (typeof path2 !== "string") {
+            throw new TypeError(
+                "Path must be a string. Received " + JSON.stringify(path2)
+            );
         }
-    });
+    }
+    const proc = {
+        cwd
+    };
 
-    function caseSensitiveTransform(attributes2, attribute) {
-        return attribute in attributes2 ? attributes2[attribute] : attribute;
+    function cwd() {
+        return "/";
     }
 
-    function caseInsensitiveTransform(attributes2, property) {
-        return caseSensitiveTransform(attributes2, property.toLowerCase());
+    function isUrl(fileUrlOrPath) {
+        return Boolean(
+            fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0
+        );
     }
-    const xmlns = create$1({
-        space: "xmlns",
-        attributes: {
-            xmlnsxlink: "xmlns:xlink"
-        },
-        transform: caseInsensitiveTransform,
-        properties: {
-            xmlns: null,
-            xmlnsXLink: null
+
+    function urlToPath(path2) {
+        if (typeof path2 === "string") {
+            path2 = new URL(path2);
+        } else if (!isUrl(path2)) {
+            const error2 = new TypeError(
+                'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
+            );
+            error2.code = "ERR_INVALID_ARG_TYPE";
+            throw error2;
         }
-    });
-    const aria = create$1({
-        transform(_2, prop) {
-            return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
-        },
-        properties: {
-            ariaActiveDescendant: null,
-            ariaAtomic: booleanish,
-            ariaAutoComplete: null,
-            ariaBusy: booleanish,
-            ariaChecked: booleanish,
-            ariaColCount: number$3,
-            ariaColIndex: number$3,
-            ariaColSpan: number$3,
-            ariaControls: spaceSeparated,
-            ariaCurrent: null,
-            ariaDescribedBy: spaceSeparated,
-            ariaDetails: null,
-            ariaDisabled: booleanish,
-            ariaDropEffect: spaceSeparated,
-            ariaErrorMessage: null,
-            ariaExpanded: booleanish,
-            ariaFlowTo: spaceSeparated,
-            ariaGrabbed: booleanish,
-            ariaHasPopup: null,
-            ariaHidden: booleanish,
-            ariaInvalid: null,
-            ariaKeyShortcuts: null,
-            ariaLabel: null,
-            ariaLabelledBy: spaceSeparated,
-            ariaLevel: number$3,
-            ariaLive: null,
-            ariaModal: booleanish,
-            ariaMultiLine: booleanish,
-            ariaMultiSelectable: booleanish,
-            ariaOrientation: null,
-            ariaOwns: spaceSeparated,
-            ariaPlaceholder: null,
-            ariaPosInSet: number$3,
-            ariaPressed: booleanish,
-            ariaReadOnly: booleanish,
-            ariaRelevant: null,
-            ariaRequired: booleanish,
-            ariaRoleDescription: spaceSeparated,
-            ariaRowCount: number$3,
-            ariaRowIndex: number$3,
-            ariaRowSpan: number$3,
-            ariaSelected: booleanish,
-            ariaSetSize: number$3,
-            ariaSort: null,
-            ariaValueMax: number$3,
-            ariaValueMin: number$3,
-            ariaValueNow: number$3,
-            ariaValueText: null,
-            role: null
+        if (path2.protocol !== "file:") {
+            const error2 = new TypeError("The URL must be of scheme file");
+            error2.code = "ERR_INVALID_URL_SCHEME";
+            throw error2;
         }
-    });
-    const html$2 = create$1({
-        space: "html",
-        attributes: {
-            acceptcharset: "accept-charset",
-            classname: "class",
-            htmlfor: "for",
-            httpequiv: "http-equiv"
-        },
-        transform: caseInsensitiveTransform,
-        mustUseProperty: ["checked", "multiple", "muted", "selected"],
-        properties: {
-            abbr: null,
-            accept: commaSeparated,
-            acceptCharset: spaceSeparated,
-            accessKey: spaceSeparated,
-            action: null,
-            allow: null,
-            allowFullScreen: boolean,
-            allowPaymentRequest: boolean,
-            allowUserMedia: boolean,
-            alt: null,
-            as: null,
-            async: boolean,
-            autoCapitalize: null,
-            autoComplete: spaceSeparated,
-            autoFocus: boolean,
-            autoPlay: boolean,
-            blocking: spaceSeparated,
-            capture: boolean,
-            charSet: null,
-            checked: boolean,
-            cite: null,
-            className: spaceSeparated,
-            cols: number$3,
-            colSpan: null,
-            content: null,
-            contentEditable: booleanish,
-            controls: boolean,
-            controlsList: spaceSeparated,
-            coords: number$3 | commaSeparated,
-            crossOrigin: null,
-            data: null,
-            dateTime: null,
-            decoding: null,
-            default: boolean,
-            defer: boolean,
-            dir: null,
-            dirName: null,
-            disabled: boolean,
-            download: overloadedBoolean,
-            draggable: booleanish,
-            encType: null,
-            enterKeyHint: null,
-            fetchPriority: null,
-            form: null,
-            formAction: null,
-            formEncType: null,
-            formMethod: null,
-            formNoValidate: boolean,
-            formTarget: null,
-            headers: spaceSeparated,
-            height: number$3,
-            hidden: boolean,
-            high: number$3,
-            href: null,
-            hrefLang: null,
-            htmlFor: spaceSeparated,
-            httpEquiv: spaceSeparated,
-            id: null,
-            imageSizes: null,
-            imageSrcSet: null,
-            inert: boolean,
-            inputMode: null,
-            integrity: null,
-            is: null,
-            isMap: boolean,
-            itemId: null,
-            itemProp: spaceSeparated,
-            itemRef: spaceSeparated,
-            itemScope: boolean,
-            itemType: spaceSeparated,
-            kind: null,
-            label: null,
-            lang: null,
-            language: null,
-            list: null,
-            loading: null,
-            loop: boolean,
-            low: number$3,
-            manifest: null,
-            max: null,
-            maxLength: number$3,
-            media: null,
-            method: null,
-            min: null,
-            minLength: number$3,
-            multiple: boolean,
-            muted: boolean,
-            name: null,
-            nonce: null,
-            noModule: boolean,
-            noValidate: boolean,
-            onAbort: null,
-            onAfterPrint: null,
-            onAuxClick: null,
-            onBeforeMatch: null,
-            onBeforePrint: null,
-            onBeforeToggle: null,
-            onBeforeUnload: null,
-            onBlur: null,
-            onCancel: null,
-            onCanPlay: null,
-            onCanPlayThrough: null,
-            onChange: null,
-            onClick: null,
-            onClose: null,
-            onContextLost: null,
-            onContextMenu: null,
-            onContextRestored: null,
-            onCopy: null,
-            onCueChange: null,
-            onCut: null,
-            onDblClick: null,
-            onDrag: null,
-            onDragEnd: null,
-            onDragEnter: null,
-            onDragExit: null,
-            onDragLeave: null,
-            onDragOver: null,
-            onDragStart: null,
-            onDrop: null,
-            onDurationChange: null,
-            onEmptied: null,
-            onEnded: null,
-            onError: null,
-            onFocus: null,
-            onFormData: null,
-            onHashChange: null,
-            onInput: null,
-            onInvalid: null,
-            onKeyDown: null,
-            onKeyPress: null,
-            onKeyUp: null,
-            onLanguageChange: null,
-            onLoad: null,
-            onLoadedData: null,
-            onLoadedMetadata: null,
-            onLoadEnd: null,
-            onLoadStart: null,
-            onMessage: null,
-            onMessageError: null,
-            onMouseDown: null,
-            onMouseEnter: null,
-            onMouseLeave: null,
-            onMouseMove: null,
-            onMouseOut: null,
-            onMouseOver: null,
-            onMouseUp: null,
-            onOffline: null,
-            onOnline: null,
-            onPageHide: null,
-            onPageShow: null,
-            onPaste: null,
-            onPause: null,
-            onPlay: null,
-            onPlaying: null,
-            onPopState: null,
-            onProgress: null,
-            onRateChange: null,
-            onRejectionHandled: null,
-            onReset: null,
-            onResize: null,
-            onScroll: null,
-            onScrollEnd: null,
-            onSecurityPolicyViolation: null,
-            onSeeked: null,
-            onSeeking: null,
-            onSelect: null,
-            onSlotChange: null,
-            onStalled: null,
-            onStorage: null,
-            onSubmit: null,
-            onSuspend: null,
-            onTimeUpdate: null,
-            onToggle: null,
-            onUnhandledRejection: null,
-            onUnload: null,
-            onVolumeChange: null,
-            onWaiting: null,
-            onWheel: null,
-            open: boolean,
-            optimum: number$3,
-            pattern: null,
-            ping: spaceSeparated,
-            placeholder: null,
-            playsInline: boolean,
-            popover: null,
-            popoverTarget: null,
-            popoverTargetAction: null,
-            poster: null,
-            preload: null,
-            readOnly: boolean,
-            referrerPolicy: null,
-            rel: spaceSeparated,
-            required: boolean,
-            reversed: boolean,
-            rows: number$3,
-            rowSpan: number$3,
-            sandbox: spaceSeparated,
-            scope: null,
-            scoped: boolean,
-            seamless: boolean,
-            selected: boolean,
-            shadowRootDelegatesFocus: boolean,
-            shadowRootMode: null,
-            shape: null,
-            size: number$3,
-            sizes: null,
-            slot: null,
-            span: number$3,
-            spellCheck: booleanish,
-            src: null,
-            srcDoc: null,
-            srcLang: null,
-            srcSet: null,
-            start: number$3,
-            step: null,
-            style: null,
-            tabIndex: number$3,
-            target: null,
-            title: null,
-            translate: null,
-            type: null,
-            typeMustMatch: boolean,
-            useMap: null,
-            value: booleanish,
-            width: number$3,
-            wrap: null,
-            align: null,
-            aLink: null,
-            archive: spaceSeparated,
-            axis: null,
-            background: null,
-            bgColor: null,
-            border: number$3,
-            borderColor: null,
-            bottomMargin: number$3,
-            cellPadding: null,
-            cellSpacing: null,
-            char: null,
-            charOff: null,
-            classId: null,
-            clear: null,
-            code: null,
-            codeBase: null,
-            codeType: null,
-            color: null,
-            compact: boolean,
-            declare: boolean,
-            event: null,
-            face: null,
-            frame: null,
-            frameBorder: null,
-            hSpace: number$3,
-            leftMargin: number$3,
-            link: null,
-            longDesc: null,
-            lowSrc: null,
-            marginHeight: number$3,
-            marginWidth: number$3,
-            noResize: boolean,
-            noHref: boolean,
-            noShade: boolean,
-            noWrap: boolean,
-            object: null,
-            profile: null,
-            prompt: null,
-            rev: null,
-            rightMargin: number$3,
-            rules: null,
-            scheme: null,
-            scrolling: booleanish,
-            standby: null,
-            summary: null,
-            text: null,
-            topMargin: number$3,
-            valueType: null,
-            version: null,
-            vAlign: null,
-            vLink: null,
-            vSpace: number$3,
-            allowTransparency: null,
-            autoCorrect: null,
-            autoSave: null,
-            disablePictureInPicture: boolean,
-            disableRemotePlayback: boolean,
-            prefix: null,
-            property: null,
-            results: number$3,
-            security: null,
-            unselectable: null
-        }
-    });
-    const svg$1 = create$1({
-        space: "svg",
-        attributes: {
-            accentHeight: "accent-height",
-            alignmentBaseline: "alignment-baseline",
-            arabicForm: "arabic-form",
-            baselineShift: "baseline-shift",
-            capHeight: "cap-height",
-            className: "class",
-            clipPath: "clip-path",
-            clipRule: "clip-rule",
-            colorInterpolation: "color-interpolation",
-            colorInterpolationFilters: "color-interpolation-filters",
-            colorProfile: "color-profile",
-            colorRendering: "color-rendering",
-            crossOrigin: "crossorigin",
-            dataType: "datatype",
-            dominantBaseline: "dominant-baseline",
-            enableBackground: "enable-background",
-            fillOpacity: "fill-opacity",
-            fillRule: "fill-rule",
-            floodColor: "flood-color",
-            floodOpacity: "flood-opacity",
-            fontFamily: "font-family",
-            fontSize: "font-size",
-            fontSizeAdjust: "font-size-adjust",
-            fontStretch: "font-stretch",
-            fontStyle: "font-style",
-            fontVariant: "font-variant",
-            fontWeight: "font-weight",
-            glyphName: "glyph-name",
-            glyphOrientationHorizontal: "glyph-orientation-horizontal",
-            glyphOrientationVertical: "glyph-orientation-vertical",
-            hrefLang: "hreflang",
-            horizAdvX: "horiz-adv-x",
-            horizOriginX: "horiz-origin-x",
-            horizOriginY: "horiz-origin-y",
-            imageRendering: "image-rendering",
-            letterSpacing: "letter-spacing",
-            lightingColor: "lighting-color",
-            markerEnd: "marker-end",
-            markerMid: "marker-mid",
-            markerStart: "marker-start",
-            navDown: "nav-down",
-            navDownLeft: "nav-down-left",
-            navDownRight: "nav-down-right",
-            navLeft: "nav-left",
-            navNext: "nav-next",
-            navPrev: "nav-prev",
-            navRight: "nav-right",
-            navUp: "nav-up",
-            navUpLeft: "nav-up-left",
-            navUpRight: "nav-up-right",
-            onAbort: "onabort",
-            onActivate: "onactivate",
-            onAfterPrint: "onafterprint",
-            onBeforePrint: "onbeforeprint",
-            onBegin: "onbegin",
-            onCancel: "oncancel",
-            onCanPlay: "oncanplay",
-            onCanPlayThrough: "oncanplaythrough",
-            onChange: "onchange",
-            onClick: "onclick",
-            onClose: "onclose",
-            onCopy: "oncopy",
-            onCueChange: "oncuechange",
-            onCut: "oncut",
-            onDblClick: "ondblclick",
-            onDrag: "ondrag",
-            onDragEnd: "ondragend",
-            onDragEnter: "ondragenter",
-            onDragExit: "ondragexit",
-            onDragLeave: "ondragleave",
-            onDragOver: "ondragover",
-            onDragStart: "ondragstart",
-            onDrop: "ondrop",
-            onDurationChange: "ondurationchange",
-            onEmptied: "onemptied",
-            onEnd: "onend",
-            onEnded: "onended",
-            onError: "onerror",
-            onFocus: "onfocus",
-            onFocusIn: "onfocusin",
-            onFocusOut: "onfocusout",
-            onHashChange: "onhashchange",
-            onInput: "oninput",
-            onInvalid: "oninvalid",
-            onKeyDown: "onkeydown",
-            onKeyPress: "onkeypress",
-            onKeyUp: "onkeyup",
-            onLoad: "onload",
-            onLoadedData: "onloadeddata",
-            onLoadedMetadata: "onloadedmetadata",
-            onLoadStart: "onloadstart",
-            onMessage: "onmessage",
-            onMouseDown: "onmousedown",
-            onMouseEnter: "onmouseenter",
-            onMouseLeave: "onmouseleave",
-            onMouseMove: "onmousemove",
-            onMouseOut: "onmouseout",
-            onMouseOver: "onmouseover",
-            onMouseUp: "onmouseup",
-            onMouseWheel: "onmousewheel",
-            onOffline: "onoffline",
-            onOnline: "ononline",
-            onPageHide: "onpagehide",
-            onPageShow: "onpageshow",
-            onPaste: "onpaste",
-            onPause: "onpause",
-            onPlay: "onplay",
-            onPlaying: "onplaying",
-            onPopState: "onpopstate",
-            onProgress: "onprogress",
-            onRateChange: "onratechange",
-            onRepeat: "onrepeat",
-            onReset: "onreset",
-            onResize: "onresize",
-            onScroll: "onscroll",
-            onSeeked: "onseeked",
-            onSeeking: "onseeking",
-            onSelect: "onselect",
-            onShow: "onshow",
-            onStalled: "onstalled",
-            onStorage: "onstorage",
-            onSubmit: "onsubmit",
-            onSuspend: "onsuspend",
-            onTimeUpdate: "ontimeupdate",
-            onToggle: "ontoggle",
-            onUnload: "onunload",
-            onVolumeChange: "onvolumechange",
-            onWaiting: "onwaiting",
-            onZoom: "onzoom",
-            overlinePosition: "overline-position",
-            overlineThickness: "overline-thickness",
-            paintOrder: "paint-order",
-            panose1: "panose-1",
-            pointerEvents: "pointer-events",
-            referrerPolicy: "referrerpolicy",
-            renderingIntent: "rendering-intent",
-            shapeRendering: "shape-rendering",
-            stopColor: "stop-color",
-            stopOpacity: "stop-opacity",
-            strikethroughPosition: "strikethrough-position",
-            strikethroughThickness: "strikethrough-thickness",
-            strokeDashArray: "stroke-dasharray",
-            strokeDashOffset: "stroke-dashoffset",
-            strokeLineCap: "stroke-linecap",
-            strokeLineJoin: "stroke-linejoin",
-            strokeMiterLimit: "stroke-miterlimit",
-            strokeOpacity: "stroke-opacity",
-            strokeWidth: "stroke-width",
-            tabIndex: "tabindex",
-            textAnchor: "text-anchor",
-            textDecoration: "text-decoration",
-            textRendering: "text-rendering",
-            transformOrigin: "transform-origin",
-            typeOf: "typeof",
-            underlinePosition: "underline-position",
-            underlineThickness: "underline-thickness",
-            unicodeBidi: "unicode-bidi",
-            unicodeRange: "unicode-range",
-            unitsPerEm: "units-per-em",
-            vAlphabetic: "v-alphabetic",
-            vHanging: "v-hanging",
-            vIdeographic: "v-ideographic",
-            vMathematical: "v-mathematical",
-            vectorEffect: "vector-effect",
-            vertAdvY: "vert-adv-y",
-            vertOriginX: "vert-origin-x",
-            vertOriginY: "vert-origin-y",
-            wordSpacing: "word-spacing",
-            writingMode: "writing-mode",
-            xHeight: "x-height",
-            playbackOrder: "playbackorder",
-            timelineBegin: "timelinebegin"
-        },
-        transform: caseSensitiveTransform,
-        properties: {
-            about: commaOrSpaceSeparated,
-            accentHeight: number$3,
-            accumulate: null,
-            additive: null,
-            alignmentBaseline: null,
-            alphabetic: number$3,
-            amplitude: number$3,
-            arabicForm: null,
-            ascent: number$3,
-            attributeName: null,
-            attributeType: null,
-            azimuth: number$3,
-            bandwidth: null,
-            baselineShift: null,
-            baseFrequency: null,
-            baseProfile: null,
-            bbox: null,
-            begin: null,
-            bias: number$3,
-            by: null,
-            calcMode: null,
-            capHeight: number$3,
-            className: spaceSeparated,
-            clip: null,
-            clipPath: null,
-            clipPathUnits: null,
-            clipRule: null,
-            color: null,
-            colorInterpolation: null,
-            colorInterpolationFilters: null,
-            colorProfile: null,
-            colorRendering: null,
-            content: null,
-            contentScriptType: null,
-            contentStyleType: null,
-            crossOrigin: null,
-            cursor: null,
-            cx: null,
-            cy: null,
-            d: null,
-            dataType: null,
-            defaultAction: null,
-            descent: number$3,
-            diffuseConstant: number$3,
-            direction: null,
-            display: null,
-            dur: null,
-            divisor: number$3,
-            dominantBaseline: null,
-            download: boolean,
-            dx: null,
-            dy: null,
-            edgeMode: null,
-            editable: null,
-            elevation: number$3,
-            enableBackground: null,
-            end: null,
-            event: null,
-            exponent: number$3,
-            externalResourcesRequired: null,
-            fill: null,
-            fillOpacity: number$3,
-            fillRule: null,
-            filter: null,
-            filterRes: null,
-            filterUnits: null,
-            floodColor: null,
-            floodOpacity: null,
-            focusable: null,
-            focusHighlight: null,
-            fontFamily: null,
-            fontSize: null,
-            fontSizeAdjust: null,
-            fontStretch: null,
-            fontStyle: null,
-            fontVariant: null,
-            fontWeight: null,
-            format: null,
-            fr: null,
-            from: null,
-            fx: null,
-            fy: null,
-            g1: commaSeparated,
-            g2: commaSeparated,
-            glyphName: commaSeparated,
-            glyphOrientationHorizontal: null,
-            glyphOrientationVertical: null,
-            glyphRef: null,
-            gradientTransform: null,
-            gradientUnits: null,
-            handler: null,
-            hanging: number$3,
-            hatchContentUnits: null,
-            hatchUnits: null,
-            height: null,
-            href: null,
-            hrefLang: null,
-            horizAdvX: number$3,
-            horizOriginX: number$3,
-            horizOriginY: number$3,
-            id: null,
-            ideographic: number$3,
-            imageRendering: null,
-            initialVisibility: null,
-            in: null,
-            in2: null,
-            intercept: number$3,
-            k: number$3,
-            k1: number$3,
-            k2: number$3,
-            k3: number$3,
-            k4: number$3,
-            kernelMatrix: commaOrSpaceSeparated,
-            kernelUnitLength: null,
-            keyPoints: null,
-            keySplines: null,
-            keyTimes: null,
-            kerning: null,
-            lang: null,
-            lengthAdjust: null,
-            letterSpacing: null,
-            lightingColor: null,
-            limitingConeAngle: number$3,
-            local: null,
-            markerEnd: null,
-            markerMid: null,
-            markerStart: null,
-            markerHeight: null,
-            markerUnits: null,
-            markerWidth: null,
-            mask: null,
-            maskContentUnits: null,
-            maskUnits: null,
-            mathematical: null,
-            max: null,
-            media: null,
-            mediaCharacterEncoding: null,
-            mediaContentEncodings: null,
-            mediaSize: number$3,
-            mediaTime: null,
-            method: null,
-            min: null,
-            mode: null,
-            name: null,
-            navDown: null,
-            navDownLeft: null,
-            navDownRight: null,
-            navLeft: null,
-            navNext: null,
-            navPrev: null,
-            navRight: null,
-            navUp: null,
-            navUpLeft: null,
-            navUpRight: null,
-            numOctaves: null,
-            observer: null,
-            offset: null,
-            onAbort: null,
-            onActivate: null,
-            onAfterPrint: null,
-            onBeforePrint: null,
-            onBegin: null,
-            onCancel: null,
-            onCanPlay: null,
-            onCanPlayThrough: null,
-            onChange: null,
-            onClick: null,
-            onClose: null,
-            onCopy: null,
-            onCueChange: null,
-            onCut: null,
-            onDblClick: null,
-            onDrag: null,
-            onDragEnd: null,
-            onDragEnter: null,
-            onDragExit: null,
-            onDragLeave: null,
-            onDragOver: null,
-            onDragStart: null,
-            onDrop: null,
-            onDurationChange: null,
-            onEmptied: null,
-            onEnd: null,
-            onEnded: null,
-            onError: null,
-            onFocus: null,
-            onFocusIn: null,
-            onFocusOut: null,
-            onHashChange: null,
-            onInput: null,
-            onInvalid: null,
-            onKeyDown: null,
-            onKeyPress: null,
-            onKeyUp: null,
-            onLoad: null,
-            onLoadedData: null,
-            onLoadedMetadata: null,
-            onLoadStart: null,
-            onMessage: null,
-            onMouseDown: null,
-            onMouseEnter: null,
-            onMouseLeave: null,
-            onMouseMove: null,
-            onMouseOut: null,
-            onMouseOver: null,
-            onMouseUp: null,
-            onMouseWheel: null,
-            onOffline: null,
-            onOnline: null,
-            onPageHide: null,
-            onPageShow: null,
-            onPaste: null,
-            onPause: null,
-            onPlay: null,
-            onPlaying: null,
-            onPopState: null,
-            onProgress: null,
-            onRateChange: null,
-            onRepeat: null,
-            onReset: null,
-            onResize: null,
-            onScroll: null,
-            onSeeked: null,
-            onSeeking: null,
-            onSelect: null,
-            onShow: null,
-            onStalled: null,
-            onStorage: null,
-            onSubmit: null,
-            onSuspend: null,
-            onTimeUpdate: null,
-            onToggle: null,
-            onUnload: null,
-            onVolumeChange: null,
-            onWaiting: null,
-            onZoom: null,
-            opacity: null,
-            operator: null,
-            order: null,
-            orient: null,
-            orientation: null,
-            origin: null,
-            overflow: null,
-            overlay: null,
-            overlinePosition: number$3,
-            overlineThickness: number$3,
-            paintOrder: null,
-            panose1: null,
-            path: null,
-            pathLength: number$3,
-            patternContentUnits: null,
-            patternTransform: null,
-            patternUnits: null,
-            phase: null,
-            ping: spaceSeparated,
-            pitch: null,
-            playbackOrder: null,
-            pointerEvents: null,
-            points: null,
-            pointsAtX: number$3,
-            pointsAtY: number$3,
-            pointsAtZ: number$3,
-            preserveAlpha: null,
-            preserveAspectRatio: null,
-            primitiveUnits: null,
-            propagate: null,
-            property: commaOrSpaceSeparated,
-            r: null,
-            radius: null,
-            referrerPolicy: null,
-            refX: null,
-            refY: null,
-            rel: commaOrSpaceSeparated,
-            rev: commaOrSpaceSeparated,
-            renderingIntent: null,
-            repeatCount: null,
-            repeatDur: null,
-            requiredExtensions: commaOrSpaceSeparated,
-            requiredFeatures: commaOrSpaceSeparated,
-            requiredFonts: commaOrSpaceSeparated,
-            requiredFormats: commaOrSpaceSeparated,
-            resource: null,
-            restart: null,
-            result: null,
-            rotate: null,
-            rx: null,
-            ry: null,
-            scale: null,
-            seed: null,
-            shapeRendering: null,
-            side: null,
-            slope: null,
-            snapshotTime: null,
-            specularConstant: number$3,
-            specularExponent: number$3,
-            spreadMethod: null,
-            spacing: null,
-            startOffset: null,
-            stdDeviation: null,
-            stemh: null,
-            stemv: null,
-            stitchTiles: null,
-            stopColor: null,
-            stopOpacity: null,
-            strikethroughPosition: number$3,
-            strikethroughThickness: number$3,
-            string: null,
-            stroke: null,
-            strokeDashArray: commaOrSpaceSeparated,
-            strokeDashOffset: null,
-            strokeLineCap: null,
-            strokeLineJoin: null,
-            strokeMiterLimit: number$3,
-            strokeOpacity: number$3,
-            strokeWidth: null,
-            style: null,
-            surfaceScale: number$3,
-            syncBehavior: null,
-            syncBehaviorDefault: null,
-            syncMaster: null,
-            syncTolerance: null,
-            syncToleranceDefault: null,
-            systemLanguage: commaOrSpaceSeparated,
-            tabIndex: number$3,
-            tableValues: null,
-            target: null,
-            targetX: number$3,
-            targetY: number$3,
-            textAnchor: null,
-            textDecoration: null,
-            textRendering: null,
-            textLength: null,
-            timelineBegin: null,
-            title: null,
-            transformBehavior: null,
-            type: null,
-            typeOf: commaOrSpaceSeparated,
-            to: null,
-            transform: null,
-            transformOrigin: null,
-            u1: null,
-            u2: null,
-            underlinePosition: number$3,
-            underlineThickness: number$3,
-            unicode: null,
-            unicodeBidi: null,
-            unicodeRange: null,
-            unitsPerEm: number$3,
-            values: null,
-            vAlphabetic: number$3,
-            vMathematical: number$3,
-            vectorEffect: null,
-            vHanging: number$3,
-            vIdeographic: number$3,
-            version: null,
-            vertAdvY: number$3,
-            vertOriginX: number$3,
-            vertOriginY: number$3,
-            viewBox: null,
-            viewTarget: null,
-            visibility: null,
-            width: null,
-            widths: null,
-            wordSpacing: null,
-            writingMode: null,
-            x: null,
-            x1: null,
-            x2: null,
-            xChannelSelector: null,
-            xHeight: number$3,
-            y: null,
-            y1: null,
-            y2: null,
-            yChannelSelector: null,
-            z: null,
-            zoomAndPan: null
-        }
-    });
-    const valid$1 = /^data[-\w.:]+$/i;
-    const dash = /-[a-z]/g;
-    const cap = /[A-Z]/g;
+        return getPathFromURLPosix(path2);
+    }
 
-    function find$3(schema, value) {
-        const normal = normalize$1(value);
-        let prop = value;
-        let Type2 = Info;
-        if (normal in schema.normal) {
-            return schema.property[schema.normal[normal]];
+    function getPathFromURLPosix(url2) {
+        if (url2.hostname !== "") {
+            const error2 = new TypeError(
+                'File URL host must be "localhost" or empty on darwin'
+            );
+            error2.code = "ERR_INVALID_FILE_URL_HOST";
+            throw error2;
         }
-        if (normal.length > 4 && normal.slice(0, 4) === "data" && valid$1.test(value)) {
-            if (value.charAt(4) === "-") {
-                const rest = value.slice(5).replace(dash, camelcase);
-                prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
-            } else {
-                const rest = value.slice(4);
-                if (!dash.test(rest)) {
-                    let dashes = rest.replace(cap, kebab);
-                    if (dashes.charAt(0) !== "-") {
-                        dashes = "-" + dashes;
-                    }
-                    value = "data" + dashes;
+        const pathname = url2.pathname;
+        let index2 = -1;
+        while (++index2 < pathname.length) {
+            if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
+                const third = pathname.codePointAt(index2 + 2);
+                if (third === 70 || third === 102) {
+                    const error2 = new TypeError(
+                        "File URL path must not include encoded / characters"
+                    );
+                    error2.code = "ERR_INVALID_FILE_URL_PATH";
+                    throw error2;
                 }
             }
-            Type2 = DefinedInfo;
         }
-        return new Type2(prop, value);
-    }
-
-    function kebab($0) {
-        return "-" + $0.toLowerCase();
-    }
-
-    function camelcase($0) {
-        return $0.charAt(1).toUpperCase();
+        return decodeURIComponent(pathname);
     }
-    const hastToReact = {
-        classId: "classID",
-        dataType: "datatype",
-        itemId: "itemID",
-        strokeDashArray: "strokeDasharray",
-        strokeDashOffset: "strokeDashoffset",
-        strokeLineCap: "strokeLinecap",
-        strokeLineJoin: "strokeLinejoin",
-        strokeMiterLimit: "strokeMiterlimit",
-        typeOf: "typeof",
-        xLinkActuate: "xlinkActuate",
-        xLinkArcRole: "xlinkArcrole",
-        xLinkHref: "xlinkHref",
-        xLinkRole: "xlinkRole",
-        xLinkShow: "xlinkShow",
-        xLinkTitle: "xlinkTitle",
-        xLinkType: "xlinkType",
-        xmlnsXLink: "xmlnsXlink"
-    };
-    const html$1 = merge$1([xml, xlink, xmlns, aria, html$2], "html");
-    const svg = merge$1([xml, xlink, xmlns, aria, svg$1], "svg");
-
-    function rehypeFilter(options) {
-        if (options.allowedElements && options.disallowedElements) {
-            throw new TypeError(
-                "Only one of `allowedElements` and `disallowedElements` should be defined"
-            );
+    const order = [
+        "history",
+        "path",
+        "basename",
+        "stem",
+        "extname",
+        "dirname"
+    ];
+    class VFile {
+        constructor(value) {
+            let options;
+            if (!value) {
+                options = {};
+            } else if (isUrl(value)) {
+                options = {
+                    path: value
+                };
+            } else if (typeof value === "string" || isUint8Array$1(value)) {
+                options = {
+                    value
+                };
+            } else {
+                options = value;
+            }
+            this.cwd = proc.cwd();
+            this.data = {};
+            this.history = [];
+            this.messages = [];
+            this.value;
+            this.map;
+            this.result;
+            this.stored;
+            let index2 = -1;
+            while (++index2 < order.length) {
+                const prop2 = order[index2];
+                if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
+                    this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
+                }
+            }
+            let prop;
+            for (prop in options) {
+                if (!order.includes(prop)) {
+                    this[prop] = options[prop];
+                }
+            }
         }
-        if (options.allowedElements || options.disallowedElements || options.allowElement) {
-            return (tree) => {
-                visit(tree, "element", (node2, index2, parent_) => {
-                    const parent = parent_;
-                    let remove2;
-                    if (options.allowedElements) {
-                        remove2 = !options.allowedElements.includes(node2.tagName);
-                    } else if (options.disallowedElements) {
-                        remove2 = options.disallowedElements.includes(node2.tagName);
-                    }
-                    if (!remove2 && options.allowElement && typeof index2 === "number") {
-                        remove2 = !options.allowElement(node2, index2, parent);
-                    }
-                    if (remove2 && typeof index2 === "number") {
-                        if (options.unwrapDisallowed && node2.children) {
-                            parent.children.splice(index2, 1, ...node2.children);
-                        } else {
-                            parent.children.splice(index2, 1);
-                        }
-                        return index2;
-                    }
-                    return void 0;
-                });
-            };
+        get basename() {
+            return typeof this.path === "string" ? path$2.basename(this.path) : void 0;
         }
-    }
-    var reactIs = {
-        exports: {}
-    };
-    var reactIs_production_min = {};
-    /**
-     * @license React
-     * react-is.production.min.js
-     *
-     * Copyright (c) Facebook, Inc. and its affiliates.
-     *
-     * This source code is licensed under the MIT license found in the
-     * LICENSE file in the root directory of this source tree.
-     */
-    var b$4 = Symbol.for("react.element"),
-        c$5 = Symbol.for("react.portal"),
-        d$2 = Symbol.for("react.fragment"),
-        e$1 = Symbol.for("react.strict_mode"),
-        f$3 = Symbol.for("react.profiler"),
-        g$3 = Symbol.for("react.provider"),
-        h$3 = Symbol.for("react.context"),
-        k$3 = Symbol.for("react.server_context"),
-        l$2 = Symbol.for("react.forward_ref"),
-        m$2 = Symbol.for("react.suspense"),
-        n$3 = Symbol.for("react.suspense_list"),
-        p$3 = Symbol.for("react.memo"),
-        q$3 = Symbol.for("react.lazy"),
-        t$3 = Symbol.for("react.offscreen"),
-        u$2;
-    u$2 = Symbol.for("react.module.reference");
-
-    function v$3(a2) {
-        if ("object" === typeof a2 && null !== a2) {
-            var r2 = a2.$$typeof;
-            switch (r2) {
-                case b$4:
-                    switch (a2 = a2.type, a2) {
-                        case d$2:
-                        case f$3:
-                        case e$1:
-                        case m$2:
-                        case n$3:
-                            return a2;
-                        default:
-                            switch (a2 = a2 && a2.$$typeof, a2) {
-                                case k$3:
-                                case h$3:
-                                case l$2:
-                                case q$3:
-                                case p$3:
-                                case g$3:
-                                    return a2;
-                                default:
-                                    return r2;
-                            }
-                    }
-                case c$5:
-                    return r2;
+        set basename(basename2) {
+            assertNonEmpty(basename2, "basename");
+            assertPart(basename2, "basename");
+            this.path = path$2.join(this.dirname || "", basename2);
+        }
+        get dirname() {
+            return typeof this.path === "string" ? path$2.dirname(this.path) : void 0;
+        }
+        set dirname(dirname2) {
+            assertPath$1(this.basename, "dirname");
+            this.path = path$2.join(dirname2 || "", this.basename);
+        }
+        get extname() {
+            return typeof this.path === "string" ? path$2.extname(this.path) : void 0;
+        }
+        set extname(extname2) {
+            assertPart(extname2, "extname");
+            assertPath$1(this.dirname, "extname");
+            if (extname2) {
+                if (extname2.codePointAt(0) !== 46) {
+                    throw new Error("`extname` must start with `.`");
+                }
+                if (extname2.includes(".", 1)) {
+                    throw new Error("`extname` cannot contain multiple dots");
+                }
             }
+            this.path = path$2.join(this.dirname, this.stem + (extname2 || ""));
         }
-    }
-    reactIs_production_min.ContextConsumer = h$3;
-    reactIs_production_min.ContextProvider = g$3;
-    reactIs_production_min.Element = b$4;
-    reactIs_production_min.ForwardRef = l$2;
-    reactIs_production_min.Fragment = d$2;
-    reactIs_production_min.Lazy = q$3;
-    reactIs_production_min.Memo = p$3;
-    reactIs_production_min.Portal = c$5;
-    reactIs_production_min.Profiler = f$3;
-    reactIs_production_min.StrictMode = e$1;
-    reactIs_production_min.Suspense = m$2;
-    reactIs_production_min.SuspenseList = n$3;
-    reactIs_production_min.isAsyncMode = function() {
-        return false;
-    };
-    reactIs_production_min.isConcurrentMode = function() {
-        return false;
-    };
-    reactIs_production_min.isContextConsumer = function(a2) {
-        return v$3(a2) === h$3;
-    };
-    reactIs_production_min.isContextProvider = function(a2) {
-        return v$3(a2) === g$3;
-    };
-    reactIs_production_min.isElement = function(a2) {
-        return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$4;
-    };
-    reactIs_production_min.isForwardRef = function(a2) {
-        return v$3(a2) === l$2;
-    };
-    reactIs_production_min.isFragment = function(a2) {
-        return v$3(a2) === d$2;
-    };
-    reactIs_production_min.isLazy = function(a2) {
-        return v$3(a2) === q$3;
-    };
-    reactIs_production_min.isMemo = function(a2) {
-        return v$3(a2) === p$3;
-    };
-    reactIs_production_min.isPortal = function(a2) {
-        return v$3(a2) === c$5;
-    };
-    reactIs_production_min.isProfiler = function(a2) {
-        return v$3(a2) === f$3;
-    };
-    reactIs_production_min.isStrictMode = function(a2) {
-        return v$3(a2) === e$1;
-    };
-    reactIs_production_min.isSuspense = function(a2) {
-        return v$3(a2) === m$2;
-    };
-    reactIs_production_min.isSuspenseList = function(a2) {
-        return v$3(a2) === n$3;
-    };
-    reactIs_production_min.isValidElementType = function(a2) {
-        return "string" === typeof a2 || "function" === typeof a2 || a2 === d$2 || a2 === f$3 || a2 === e$1 || a2 === m$2 || a2 === n$3 || a2 === t$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$3 || a2.$$typeof === p$3 || a2.$$typeof === g$3 || a2.$$typeof === h$3 || a2.$$typeof === l$2 || a2.$$typeof === u$2 || void 0 !== a2.getModuleId) ? true : false;
-    };
-    reactIs_production_min.typeOf = v$3;
-    (function(module2) {
-        {
-            module2.exports = reactIs_production_min;
+        get path() {
+            return this.history[this.history.length - 1];
+        }
+        set path(path2) {
+            if (isUrl(path2)) {
+                path2 = urlToPath(path2);
+            }
+            assertNonEmpty(path2, "path");
+            if (this.path !== path2) {
+                this.history.push(path2);
+            }
+        }
+        get stem() {
+            return typeof this.path === "string" ? path$2.basename(this.path, this.extname) : void 0;
+        }
+        set stem(stem) {
+            assertNonEmpty(stem, "stem");
+            assertPart(stem, "stem");
+            this.path = path$2.join(this.dirname || "", stem + (this.extname || ""));
+        }
+        fail(causeOrReason, optionsOrParentOrPlace, origin) {
+            const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
+            message.fatal = true;
+            throw message;
+        }
+        info(causeOrReason, optionsOrParentOrPlace, origin) {
+            const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
+            message.fatal = void 0;
+            return message;
+        }
+        message(causeOrReason, optionsOrParentOrPlace, origin) {
+            const message = new VFileMessage(
+                causeOrReason,
+                optionsOrParentOrPlace,
+                origin
+            );
+            if (this.path) {
+                message.name = this.path + ":" + message.name;
+                message.file = this.path;
+            }
+            message.fatal = false;
+            this.messages.push(message);
+            return message;
+        }
+        toString(encoding) {
+            if (this.value === void 0) {
+                return "";
+            }
+            if (typeof this.value === "string") {
+                return this.value;
+            }
+            const decoder = new TextDecoder(encoding || void 0);
+            return decoder.decode(this.value);
         }
-    })(reactIs);
-    const ReactIs = /* @__PURE__ */ getDefaultExportFromCjs(reactIs.exports);
-
-    function whitespace(thing) {
-        const value = thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing;
-        return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
     }
 
-    function parse$7(value) {
-        const input = String(value || "").trim();
-        return input ? input.split(/[ \t\n\r\f]+/g) : [];
+    function assertPart(part, name2) {
+        if (part && part.includes(path$2.sep)) {
+            throw new Error(
+                "`" + name2 + "` cannot be a path: did not expect `" + path$2.sep + "`"
+            );
+        }
     }
 
-    function stringify$3(values) {
-        return values.join(" ").trim();
+    function assertNonEmpty(part, name2) {
+        if (!part) {
+            throw new Error("`" + name2 + "` cannot be empty");
+        }
     }
 
-    function parse$6(value) {
-        const tokens2 = [];
-        const input = String(value || "");
-        let index2 = input.indexOf(",");
-        let start2 = 0;
-        let end2 = false;
-        while (!end2) {
-            if (index2 === -1) {
-                index2 = input.length;
-                end2 = true;
-            }
-            const token = input.slice(start2, index2).trim();
-            if (token || !end2) {
-                tokens2.push(token);
-            }
-            start2 = index2 + 1;
-            index2 = input.indexOf(",", start2);
+    function assertPath$1(path2, name2) {
+        if (!path2) {
+            throw new Error("Setting `" + name2 + "` requires `path` to be set too");
         }
-        return tokens2;
     }
 
-    function stringify$2(values, options) {
-        const settings2 = options || {};
-        const input = values[values.length - 1] === "" ? [...values, ""] : values;
-        return input.join(
-            (settings2.padRight ? " " : "") + "," + (settings2.padLeft === false ? "" : " ")
-        ).trim();
+    function isUint8Array$1(value) {
+        return Boolean(
+            value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
+        );
     }
-    var styleToObject = {
-        exports: {}
-    };
-    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
-    var NEWLINE_REGEX = /\n/g;
-    var WHITESPACE_REGEX = /^\s*/;
-    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
-    var COLON_REGEX = /^:\s*/;
-    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
-    var SEMICOLON_REGEX = /^[;\s]*/;
-    var TRIM_REGEX = /^\s+|\s+$/g;
-    var NEWLINE = "\n";
-    var FORWARD_SLASH = "/";
-    var ASTERISK = "*";
-    var EMPTY_STRING = "";
-    var TYPE_COMMENT = "comment";
-    var TYPE_DECLARATION = "declaration";
-    var inlineStyleParser = function(style2, options) {
-        if (typeof style2 !== "string") {
-            throw new TypeError("First argument must be a string");
+    const CallableInstance = function(property) {
+        const self2 = this;
+        const constr = self2.constructor;
+        const proto2 = constr.prototype;
+        const func = proto2[property];
+        const apply = function() {
+            return func.apply(apply, arguments);
+        };
+        Object.setPrototypeOf(apply, proto2);
+        const names = Object.getOwnPropertyNames(func);
+        for (const p2 of names) {
+            const descriptor = Object.getOwnPropertyDescriptor(func, p2);
+            if (descriptor)
+                Object.defineProperty(apply, p2, descriptor);
         }
-        if (!style2)
-            return [];
-        options = options || {};
-        var lineno = 1;
-        var column = 1;
-
-        function updatePosition(str) {
-            var lines = str.match(NEWLINE_REGEX);
-            if (lines)
-                lineno += lines.length;
-            var i2 = str.lastIndexOf(NEWLINE);
-            column = ~i2 ? str.length - i2 : column + str.length;
+        return apply;
+    };
+    const own$4 = {}.hasOwnProperty;
+    class Processor extends CallableInstance {
+        constructor() {
+            super("copy");
+            this.Compiler = void 0;
+            this.Parser = void 0;
+            this.attachers = [];
+            this.compiler = void 0;
+            this.freezeIndex = -1;
+            this.frozen = void 0;
+            this.namespace = {};
+            this.parser = void 0;
+            this.transformers = trough();
         }
-
-        function position2() {
-            var start2 = {
-                line: lineno,
-                column
-            };
-            return function(node2) {
-                node2.position = new Position(start2);
-                whitespace2();
-                return node2;
-            };
+        copy() {
+            const destination = new Processor();
+            let index2 = -1;
+            while (++index2 < this.attachers.length) {
+                const attacher = this.attachers[index2];
+                destination.use(...attacher);
+            }
+            destination.data(extend$3(true, {}, this.namespace));
+            return destination;
         }
-
-        function Position(start2) {
-            this.start = start2;
-            this.end = {
-                line: lineno,
-                column
-            };
-            this.source = options.source;
+        data(key, value) {
+            if (typeof key === "string") {
+                if (arguments.length === 2) {
+                    assertUnfrozen("data", this.frozen);
+                    this.namespace[key] = value;
+                    return this;
+                }
+                return own$4.call(this.namespace, key) && this.namespace[key] || void 0;
+            }
+            if (key) {
+                assertUnfrozen("data", this.frozen);
+                this.namespace = key;
+                return this;
+            }
+            return this.namespace;
         }
-        Position.prototype.content = style2;
-
-        function error2(msg) {
-            var err = new Error(
-                options.source + ":" + lineno + ":" + column + ": " + msg
-            );
-            err.reason = msg;
-            err.filename = options.source;
-            err.line = lineno;
-            err.column = column;
-            err.source = style2;
-            if (options.silent)
-            ;
-            else {
-                throw err;
+        freeze() {
+            if (this.frozen) {
+                return this;
+            }
+            const self2 = this;
+            while (++this.freezeIndex < this.attachers.length) {
+                const [attacher, ...options] = this.attachers[this.freezeIndex];
+                if (options[0] === false) {
+                    continue;
+                }
+                if (options[0] === true) {
+                    options[0] = void 0;
+                }
+                const transformer = attacher.call(self2, ...options);
+                if (typeof transformer === "function") {
+                    this.transformers.use(transformer);
+                }
             }
+            this.frozen = true;
+            this.freezeIndex = Number.POSITIVE_INFINITY;
+            return this;
         }
-
-        function match2(re2) {
-            var m2 = re2.exec(style2);
-            if (!m2)
-                return;
-            var str = m2[0];
-            updatePosition(str);
-            style2 = style2.slice(str.length);
-            return m2;
+        parse(file) {
+            this.freeze();
+            const realFile = vfile(file);
+            const parser2 = this.parser || this.Parser;
+            assertParser("parse", parser2);
+            return parser2(String(realFile), realFile);
         }
+        process(file, done) {
+            const self2 = this;
+            this.freeze();
+            assertParser("process", this.parser || this.Parser);
+            assertCompiler("process", this.compiler || this.Compiler);
+            return done ? executor(void 0, done) : new Promise(executor);
 
-        function whitespace2() {
-            match2(WHITESPACE_REGEX);
-        }
+            function executor(resolve2, reject) {
+                const realFile = vfile(file);
+                const parseTree = self2.parse(realFile);
+                self2.run(parseTree, realFile, function(error2, tree, file2) {
+                    if (error2 || !tree || !file2) {
+                        return realDone(error2);
+                    }
+                    const compileTree = tree;
+                    const compileResult = self2.stringify(compileTree, file2);
+                    if (looksLikeAValue(compileResult)) {
+                        file2.value = compileResult;
+                    } else {
+                        file2.result = compileResult;
+                    }
+                    realDone(error2, file2);
+                });
 
-        function comments(rules) {
-            var c2;
-            rules = rules || [];
-            while (c2 = comment2()) {
-                if (c2 !== false) {
-                    rules.push(c2);
+                function realDone(error2, file2) {
+                    if (error2 || !file2) {
+                        reject(error2);
+                    } else if (resolve2) {
+                        resolve2(file2);
+                    } else {
+                        done(void 0, file2);
+                    }
                 }
             }
-            return rules;
         }
+        processSync(file) {
+            let complete = false;
+            let result;
+            this.freeze();
+            assertParser("processSync", this.parser || this.Parser);
+            assertCompiler("processSync", this.compiler || this.Compiler);
+            this.process(file, realDone);
+            assertDone("processSync", "process", complete);
+            return result;
 
-        function comment2() {
-            var pos = position2();
-            if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
-                return;
-            var i2 = 2;
-            while (EMPTY_STRING != style2.charAt(i2) && (ASTERISK != style2.charAt(i2) || FORWARD_SLASH != style2.charAt(i2 + 1))) {
-                ++i2;
-            }
-            i2 += 2;
-            if (EMPTY_STRING === style2.charAt(i2 - 1)) {
-                return error2("End of comment missing");
+            function realDone(error2, file2) {
+                complete = true;
+                bail(error2);
+                result = file2;
             }
-            var str = style2.slice(2, i2 - 2);
-            column += 2;
-            updatePosition(str);
-            style2 = style2.slice(i2);
-            column += 2;
-            return pos({
-                type: TYPE_COMMENT,
-                comment: str
-            });
         }
+        run(tree, file, done) {
+            assertNode(tree);
+            this.freeze();
+            const transformers = this.transformers;
+            if (!done && typeof file === "function") {
+                done = file;
+                file = void 0;
+            }
+            return done ? executor(void 0, done) : new Promise(executor);
 
-        function declaration() {
-            var pos = position2();
-            var prop = match2(PROPERTY_REGEX);
-            if (!prop)
-                return;
-            comment2();
-            if (!match2(COLON_REGEX))
-                return error2("property missing ':'");
-            var val = match2(VALUE_REGEX);
-            var ret = pos({
-                type: TYPE_DECLARATION,
-                property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
-                value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
-            });
-            match2(SEMICOLON_REGEX);
-            return ret;
-        }
+            function executor(resolve2, reject) {
+                const realFile = vfile(file);
+                transformers.run(tree, realFile, realDone);
 
-        function declarations() {
-            var decls = [];
-            comments(decls);
-            var decl;
-            while (decl = declaration()) {
-                if (decl !== false) {
-                    decls.push(decl);
-                    comments(decls);
+                function realDone(error2, outputTree, file2) {
+                    const resultingTree = outputTree || tree;
+                    if (error2) {
+                        reject(error2);
+                    } else if (resolve2) {
+                        resolve2(resultingTree);
+                    } else {
+                        done(void 0, resultingTree, file2);
+                    }
                 }
             }
-            return decls;
         }
-        whitespace2();
-        return declarations();
-    };
-
-    function trim(str) {
-        return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
-    }
-    var parse$5 = inlineStyleParser;
+        runSync(tree, file) {
+            let complete = false;
+            let result;
+            this.run(tree, file, realDone);
+            assertDone("runSync", "run", complete);
+            return result;
 
-    function StyleToObject(style2, iterator2) {
-        var output2 = null;
-        if (!style2 || typeof style2 !== "string") {
-            return output2;
-        }
-        var declaration;
-        var declarations = parse$5(style2);
-        var hasIterator = typeof iterator2 === "function";
-        var property;
-        var value;
-        for (var i2 = 0, len = declarations.length; i2 < len; i2++) {
-            declaration = declarations[i2];
-            property = declaration.property;
-            value = declaration.value;
-            if (hasIterator) {
-                iterator2(property, value, declaration);
-            } else if (value) {
-                output2 || (output2 = {});
-                output2[property] = value;
+            function realDone(error2, tree2) {
+                bail(error2);
+                result = tree2;
+                complete = true;
             }
         }
-        return output2;
-    }
-    styleToObject.exports = StyleToObject;
-    styleToObject.exports.default = StyleToObject;
-    const style$1 = styleToObject.exports;
-    const own$6 = {}.hasOwnProperty;
-    const tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
-
-    function childrenToReact(context2, node2) {
-        const children2 = [];
-        let childIndex = -1;
-        let child;
-        while (++childIndex < node2.children.length) {
-            child = node2.children[childIndex];
-            if (child.type === "element") {
-                children2.push(toReact(context2, child, childIndex, node2));
-            } else if (child.type === "text") {
-                if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace(child)) {
-                    children2.push(child.value);
+        stringify(tree, file) {
+            this.freeze();
+            const realFile = vfile(file);
+            const compiler2 = this.compiler || this.Compiler;
+            assertCompiler("stringify", compiler2);
+            assertNode(tree);
+            return compiler2(tree, realFile);
+        }
+        use(value, ...parameters) {
+            const attachers = this.attachers;
+            const namespace2 = this.namespace;
+            assertUnfrozen("use", this.frozen);
+            if (value === null || value === void 0)
+            ;
+            else if (typeof value === "function") {
+                addPlugin(value, parameters);
+            } else if (typeof value === "object") {
+                if (Array.isArray(value)) {
+                    addList(value);
+                } else {
+                    addPreset(value);
                 }
-            } else if (child.type === "raw" && !context2.options.skipHtml) {
-                children2.push(child.value);
+            } else {
+                throw new TypeError("Expected usable value, not `" + value + "`");
             }
-        }
-        return children2;
-    }
+            return this;
 
-    function toReact(context2, node2, index2, parent) {
-        const options = context2.options;
-        const transform = options.transformLinkUri === void 0 ? uriTransformer : options.transformLinkUri;
-        const parentSchema = context2.schema;
-        const name2 = node2.tagName;
-        const properties = {};
-        let schema = parentSchema;
-        let property;
-        if (parentSchema.space === "html" && name2 === "svg") {
-            schema = svg;
-            context2.schema = schema;
-        }
-        if (node2.properties) {
-            for (property in node2.properties) {
-                if (own$6.call(node2.properties, property)) {
-                    addProperty$1(properties, property, node2.properties[property], context2);
+            function add2(value2) {
+                if (typeof value2 === "function") {
+                    addPlugin(value2, []);
+                } else if (typeof value2 === "object") {
+                    if (Array.isArray(value2)) {
+                        const [plugin, ...parameters2] = value2;
+                        addPlugin(plugin, parameters2);
+                    } else {
+                        addPreset(value2);
+                    }
+                } else {
+                    throw new TypeError("Expected usable value, not `" + value2 + "`");
                 }
             }
-        }
-        if (name2 === "ol" || name2 === "ul") {
-            context2.listDepth++;
-        }
-        const children2 = childrenToReact(context2, node2);
-        if (name2 === "ol" || name2 === "ul") {
-            context2.listDepth--;
-        }
-        context2.schema = parentSchema;
-        const position2 = node2.position || {
-            start: {
-                line: null,
-                column: null,
-                offset: null
-            },
-            end: {
-                line: null,
-                column: null,
-                offset: null
+
+            function addPreset(result) {
+                if (!("plugins" in result) && !("settings" in result)) {
+                    throw new Error(
+                        "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
+                    );
+                }
+                addList(result.plugins);
+                if (result.settings) {
+                    namespace2.settings = extend$3(true, namespace2.settings, result.settings);
+                }
             }
-        };
-        const component = options.components && own$6.call(options.components, name2) ? options.components[name2] : name2;
-        const basic = typeof component === "string" || component === React__default.default.Fragment;
-        if (!ReactIs.isValidElementType(component)) {
-            throw new TypeError(
-                `Component for name \`${name2}\` not defined or is not renderable`
-            );
-        }
-        properties.key = [
-            name2,
-            position2.start.line,
-            position2.start.column,
-            index2
-        ].join("-");
-        if (name2 === "a" && options.linkTarget) {
-            properties.target = typeof options.linkTarget === "function" ? options.linkTarget(
-                String(properties.href || ""),
-                node2.children,
-                typeof properties.title === "string" ? properties.title : null
-            ) : options.linkTarget;
-        }
-        if (name2 === "a" && transform) {
-            properties.href = transform(
-                String(properties.href || ""),
-                node2.children,
-                typeof properties.title === "string" ? properties.title : null
-            );
-        }
-        if (!basic && name2 === "code" && parent.type === "element" && parent.tagName !== "pre") {
-            properties.inline = true;
-        }
-        if (!basic && (name2 === "h1" || name2 === "h2" || name2 === "h3" || name2 === "h4" || name2 === "h5" || name2 === "h6")) {
-            properties.level = Number.parseInt(name2.charAt(1), 10);
-        }
-        if (name2 === "img" && options.transformImageUri) {
-            properties.src = options.transformImageUri(
-                String(properties.src || ""),
-                String(properties.alt || ""),
-                typeof properties.title === "string" ? properties.title : null
-            );
-        }
-        if (!basic && name2 === "li" && parent.type === "element") {
-            const input = getInputElement(node2);
-            properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
-            properties.index = getElementsBeforeCount(parent, node2);
-            properties.ordered = parent.tagName === "ol";
-        }
-        if (!basic && (name2 === "ol" || name2 === "ul")) {
-            properties.ordered = name2 === "ol";
-            properties.depth = context2.listDepth;
-        }
-        if (name2 === "td" || name2 === "th") {
-            if (properties.align) {
-                if (!properties.style)
-                    properties.style = {};
-                properties.style.textAlign = properties.align;
-                delete properties.align;
+
+            function addList(plugins2) {
+                let index2 = -1;
+                if (plugins2 === null || plugins2 === void 0)
+                ;
+                else if (Array.isArray(plugins2)) {
+                    while (++index2 < plugins2.length) {
+                        const thing = plugins2[index2];
+                        add2(thing);
+                    }
+                } else {
+                    throw new TypeError("Expected a list of plugins, not `" + plugins2 + "`");
+                }
             }
-            if (!basic) {
-                properties.isHeader = name2 === "th";
+
+            function addPlugin(plugin, parameters2) {
+                let index2 = -1;
+                let entryIndex = -1;
+                while (++index2 < attachers.length) {
+                    if (attachers[index2][0] === plugin) {
+                        entryIndex = index2;
+                        break;
+                    }
+                }
+                if (entryIndex === -1) {
+                    attachers.push([plugin, ...parameters2]);
+                } else if (parameters2.length > 0) {
+                    let [primary, ...rest] = parameters2;
+                    const currentPrimary = attachers[entryIndex][1];
+                    if (isPlainObject$2(currentPrimary) && isPlainObject$2(primary)) {
+                        primary = extend$3(true, currentPrimary, primary);
+                    }
+                    attachers[entryIndex] = [plugin, primary, ...rest];
+                }
             }
         }
-        if (!basic && name2 === "tr" && parent.type === "element") {
-            properties.isHeader = Boolean(parent.tagName === "thead");
-        }
-        if (options.sourcePos) {
-            properties["data-sourcepos"] = flattenPosition(position2);
-        }
-        if (!basic && options.rawSourcePos) {
-            properties.sourcePosition = node2.position;
-        }
-        if (!basic && options.includeElementIndex) {
-            properties.index = getElementsBeforeCount(parent, node2);
-            properties.siblingCount = getElementsBeforeCount(parent);
-        }
-        if (!basic) {
-            properties.node = node2;
-        }
-        return children2.length > 0 ? React__default.default.createElement(component, properties, children2) : React__default.default.createElement(component, properties);
     }
+    const unified = new Processor().freeze();
 
-    function getInputElement(node2) {
-        let index2 = -1;
-        while (++index2 < node2.children.length) {
-            const child = node2.children[index2];
-            if (child.type === "element" && child.tagName === "input") {
-                return child;
-            }
+    function assertParser(name2, value) {
+        if (typeof value !== "function") {
+            throw new TypeError("Cannot `" + name2 + "` without `parser`");
         }
-        return null;
     }
 
-    function getElementsBeforeCount(parent, node2) {
-        let index2 = -1;
-        let count2 = 0;
-        while (++index2 < parent.children.length) {
-            if (parent.children[index2] === node2)
-                break;
-            if (parent.children[index2].type === "element")
-                count2++;
+    function assertCompiler(name2, value) {
+        if (typeof value !== "function") {
+            throw new TypeError("Cannot `" + name2 + "` without `compiler`");
         }
-        return count2;
     }
 
-    function addProperty$1(props, prop, value, ctx) {
-        const info = find$3(ctx.schema, prop);
-        let result = value;
-        if (result === null || result === void 0 || result !== result) {
-            return;
-        }
-        if (Array.isArray(result)) {
-            result = info.commaSeparated ? stringify$2(result) : stringify$3(result);
+    function assertUnfrozen(name2, frozen) {
+        if (frozen) {
+            throw new Error(
+                "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
+            );
         }
-        if (info.property === "style" && typeof result === "string") {
-            result = parseStyle(result);
+    }
+
+    function assertNode(node2) {
+        if (!isPlainObject$2(node2) || typeof node2.type !== "string") {
+            throw new TypeError("Expected node, got `" + node2 + "`");
         }
-        if (info.space && info.property) {
-            props[own$6.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
-        } else if (info.attribute) {
-            props[info.attribute] = result;
+    }
+
+    function assertDone(name2, asyncName, complete) {
+        if (!complete) {
+            throw new Error(
+                "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
+            );
         }
     }
 
-    function parseStyle(value) {
-        const result = {};
-        try {
-            style$1(value, iterator2);
-        } catch {}
-        return result;
+    function vfile(value) {
+        return looksLikeAVFile(value) ? value : new VFile(value);
+    }
 
-        function iterator2(name2, v2) {
-            const k2 = name2.slice(0, 4) === "-ms-" ? `ms-${name2.slice(4)}` : name2;
-            result[k2.replace(/-([a-z])/g, styleReplacer)] = v2;
-        }
+    function looksLikeAVFile(value) {
+        return Boolean(
+            value && typeof value === "object" && "message" in value && "messages" in value
+        );
     }
 
-    function styleReplacer(_2, $1) {
-        return $1.toUpperCase();
+    function looksLikeAValue(value) {
+        return typeof value === "string" || isUint8Array(value);
     }
 
-    function flattenPosition(pos) {
-        return [
-            pos.start.line,
-            ":",
-            pos.start.column,
-            "-",
-            pos.end.line,
-            ":",
-            pos.end.column
-        ].map(String).join("");
+    function isUint8Array(value) {
+        return Boolean(
+            value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
+        );
     }
-    const own$5 = {}.hasOwnProperty;
     const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
-    const deprecated = {
-        plugins: {
-            to: "remarkPlugins",
-            id: "change-plugins-to-remarkplugins"
-        },
-        renderers: {
-            to: "components",
-            id: "change-renderers-to-components"
-        },
-        astPlugins: {
-            id: "remove-buggy-html-in-markdown-parser"
-        },
-        allowDangerousHtml: {
-            id: "remove-buggy-html-in-markdown-parser"
-        },
-        escapeHtml: {
-            id: "remove-buggy-html-in-markdown-parser"
-        },
-        source: {
-            to: "children",
-            id: "change-source-to-children"
-        },
-        allowNode: {
-            to: "allowElement",
-            id: "replace-allownode-allowedtypes-and-disallowedtypes"
-        },
-        allowedTypes: {
-            to: "allowedElements",
-            id: "replace-allownode-allowedtypes-and-disallowedtypes"
-        },
-        disallowedTypes: {
-            to: "disallowedElements",
-            id: "replace-allownode-allowedtypes-and-disallowedtypes"
-        },
-        includeNodeIndex: {
-            to: "includeElementIndex",
-            id: "change-includenodeindex-to-includeelementindex"
-        }
-    };
+    const emptyPlugins = [];
+    const emptyRemarkRehypeOptions = {
+        allowDangerousHtml: true
+    };
+    const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
+    const deprecations = [{
+        from: "astPlugins",
+        id: "remove-buggy-html-in-markdown-parser"
+    }, {
+        from: "allowDangerousHtml",
+        id: "remove-buggy-html-in-markdown-parser"
+    }, {
+        from: "allowNode",
+        id: "replace-allownode-allowedtypes-and-disallowedtypes",
+        to: "allowElement"
+    }, {
+        from: "allowedTypes",
+        id: "replace-allownode-allowedtypes-and-disallowedtypes",
+        to: "allowedElements"
+    }, {
+        from: "disallowedTypes",
+        id: "replace-allownode-allowedtypes-and-disallowedtypes",
+        to: "disallowedElements"
+    }, {
+        from: "escapeHtml",
+        id: "remove-buggy-html-in-markdown-parser"
+    }, {
+        from: "includeElementIndex",
+        id: "#remove-includeelementindex"
+    }, {
+        from: "includeNodeIndex",
+        id: "change-includenodeindex-to-includeelementindex"
+    }, {
+        from: "linkTarget",
+        id: "remove-linktarget"
+    }, {
+        from: "plugins",
+        id: "change-plugins-to-remarkplugins",
+        to: "remarkPlugins"
+    }, {
+        from: "rawSourcePos",
+        id: "#remove-rawsourcepos"
+    }, {
+        from: "renderers",
+        id: "change-renderers-to-components",
+        to: "components"
+    }, {
+        from: "source",
+        id: "change-source-to-children",
+        to: "children"
+    }, {
+        from: "sourcePos",
+        id: "#remove-sourcepos"
+    }, {
+        from: "transformImageUri",
+        id: "#add-urltransform",
+        to: "urlTransform"
+    }, {
+        from: "transformLinkUri",
+        id: "#add-urltransform",
+        to: "urlTransform"
+    }];
 
-    function ReactMarkdown(options) {
-        for (const key in deprecated) {
-            if (own$5.call(deprecated, key) && own$5.call(options, key)) {
-                const deprecation2 = deprecated[key];
-                console.warn(
-                    `[react-markdown] Warning: please ${deprecation2.to ? `use \`${deprecation2.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation2.id}> for more info)`
+    function Markdown$1(options) {
+        const allowedElements = options.allowedElements;
+        const allowElement = options.allowElement;
+        const children2 = options.children || "";
+        const className = options.className;
+        const components = options.components;
+        const disallowedElements = options.disallowedElements;
+        const rehypePlugins = options.rehypePlugins || emptyPlugins;
+        const remarkPlugins = options.remarkPlugins || emptyPlugins;
+        const remarkRehypeOptions = options.remarkRehypeOptions ? {
+            ...options.remarkRehypeOptions,
+            ...emptyRemarkRehypeOptions
+        } : emptyRemarkRehypeOptions;
+        const skipHtml = options.skipHtml;
+        const unwrapDisallowed = options.unwrapDisallowed;
+        const urlTransform = options.urlTransform || defaultUrlTransform;
+        const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
+        const file = new VFile();
+        if (typeof children2 === "string") {
+            file.value = children2;
+        }
+        for (const deprecation2 of deprecations) {
+            if (Object.hasOwn(options, deprecation2.from)) {
+                unreachable(
+                    "Unexpected `" + deprecation2.from + "` prop, " + (deprecation2.to ? "use `" + deprecation2.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation2.id + "> for more info)"
                 );
-                delete deprecated[key];
             }
         }
-        const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(remarkRehype$1, {
-            ...options.remarkRehypeOptions,
-            allowDangerousHtml: true
-        }).use(options.rehypePlugins || []).use(rehypeFilter, options);
-        const file = new VFile();
-        if (typeof options.children === "string") {
-            file.value = options.children;
-        } else if (options.children !== void 0 && options.children !== null) {
-            console.warn(
-                `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
-            );
+        const mdastTree = processor.parse(file);
+        let hastTree = processor.runSync(mdastTree, file);
+        if (className) {
+            hastTree = {
+                type: "element",
+                tagName: "div",
+                properties: {
+                    className
+                },
+                children: hastTree.type === "root" ? hastTree.children : [hastTree]
+            };
         }
-        const hastNode = processor.runSync(processor.parse(file), file);
-        if (hastNode.type !== "root") {
-            throw new TypeError("Expected a `root` node");
-        }
-        let result = React__default.default.createElement(
-            React__default.default.Fragment, {},
-            childrenToReact({
-                options,
-                schema: html$1,
-                listDepth: 0
-            }, hastNode)
-        );
-        if (options.className) {
-            result = React__default.default.createElement("div", {
-                className: options.className
-            }, result);
+        visit$1(hastTree, transform);
+        return toJsxRuntime(hastTree, {
+            Fragment: jsxRuntime.exports.Fragment,
+            components,
+            ignoreInvalidStyle: true,
+            jsx: jsxRuntime.exports.jsx,
+            jsxs: jsxRuntime.exports.jsxs,
+            passKeys: true,
+            passNode: true
+        });
+
+        function transform(node2, index2, parent) {
+            if (node2.type === "raw" && parent && typeof index2 === "number") {
+                if (skipHtml) {
+                    parent.children.splice(index2, 1);
+                } else {
+                    parent.children[index2] = {
+                        type: "text",
+                        value: node2.value
+                    };
+                }
+                return index2;
+            }
+            if (node2.type === "element") {
+                let key;
+                for (key in urlAttributes) {
+                    if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
+                        const value = node2.properties[key];
+                        const test2 = urlAttributes[key];
+                        if (test2 === null || test2.includes(node2.tagName)) {
+                            node2.properties[key] = urlTransform(String(value || ""), key, node2);
+                        }
+                    }
+                }
+            }
+            if (node2.type === "element") {
+                let remove2 = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
+                if (!remove2 && allowElement && typeof index2 === "number") {
+                    remove2 = !allowElement(node2, index2, parent);
+                }
+                if (remove2 && parent && typeof index2 === "number") {
+                    if (unwrapDisallowed && node2.children) {
+                        parent.children.splice(index2, 1, ...node2.children);
+                    } else {
+                        parent.children.splice(index2, 1);
+                    }
+                    return index2;
+                }
+            }
         }
-        return result;
     }
-    ReactMarkdown.propTypes = {
-        children: propTypes.exports.string,
-        className: propTypes.exports.string,
-        allowElement: propTypes.exports.func,
-        allowedElements: propTypes.exports.arrayOf(propTypes.exports.string),
-        disallowedElements: propTypes.exports.arrayOf(propTypes.exports.string),
-        unwrapDisallowed: propTypes.exports.bool,
-        remarkPlugins: propTypes.exports.arrayOf(
-            propTypes.exports.oneOfType([
-                propTypes.exports.object,
-                propTypes.exports.func,
-                propTypes.exports.arrayOf(
-                    propTypes.exports.oneOfType([
-                        propTypes.exports.bool,
-                        propTypes.exports.string,
-                        propTypes.exports.object,
-                        propTypes.exports.func,
-                        propTypes.exports.arrayOf(
-                            propTypes.exports.any
-                        )
-                    ])
-                )
-            ])
-        ),
-        rehypePlugins: propTypes.exports.arrayOf(
-            propTypes.exports.oneOfType([
-                propTypes.exports.object,
-                propTypes.exports.func,
-                propTypes.exports.arrayOf(
-                    propTypes.exports.oneOfType([
-                        propTypes.exports.bool,
-                        propTypes.exports.string,
-                        propTypes.exports.object,
-                        propTypes.exports.func,
-                        propTypes.exports.arrayOf(
-                            propTypes.exports.any
-                        )
-                    ])
-                )
-            ])
-        ),
-        sourcePos: propTypes.exports.bool,
-        rawSourcePos: propTypes.exports.bool,
-        skipHtml: propTypes.exports.bool,
-        includeElementIndex: propTypes.exports.bool,
-        transformLinkUri: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.bool]),
-        linkTarget: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.string]),
-        transformImageUri: propTypes.exports.func,
-        components: propTypes.exports.object
-    };
+
+    function defaultUrlTransform(value) {
+        const colon = value.indexOf(":");
+        const questionMark = value.indexOf("?");
+        const numberSign = value.indexOf("#");
+        const slash = value.indexOf("/");
+        if (colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || safeProtocol.test(value.slice(0, colon))) {
+            return value;
+        }
+        return "";
+    }
     var unicode$3 = {};
     const UNDEFINED_CODE_POINTS = [
         65534,
         65535,
         131070,
         131071,
         196606,
@@ -63071,39 +63325,39 @@
             if (token.attrs[i2].name === attrName) {
                 return token.attrs[i2].value;
             }
         }
         return null;
     };
     var tokenizer = Tokenizer$4;
-    var html = {};
-    const NS$3 = html.NAMESPACES = {
+    var html$1 = {};
+    const NS$3 = html$1.NAMESPACES = {
         HTML: "http://www.w3.org/1999/xhtml",
         MATHML: "http://www.w3.org/1998/Math/MathML",
         SVG: "http://www.w3.org/2000/svg",
         XLINK: "http://www.w3.org/1999/xlink",
         XML: "http://www.w3.org/XML/1998/namespace",
         XMLNS: "http://www.w3.org/2000/xmlns/"
     };
-    html.ATTRS = {
+    html$1.ATTRS = {
         TYPE: "type",
         ACTION: "action",
         ENCODING: "encoding",
         PROMPT: "prompt",
         NAME: "name",
         COLOR: "color",
         FACE: "face",
         SIZE: "size"
     };
-    html.DOCUMENT_MODE = {
+    html$1.DOCUMENT_MODE = {
         NO_QUIRKS: "no-quirks",
         QUIRKS: "quirks",
         LIMITED_QUIRKS: "limited-quirks"
     };
-    const $$6 = html.TAG_NAMES = {
+    const $$6 = html$1.TAG_NAMES = {
         A: "a",
         ADDRESS: "address",
         ANNOTATION_XML: "annotation-xml",
         APPLET: "applet",
         AREA: "area",
         ARTICLE: "article",
         ASIDE: "aside",
@@ -63219,15 +63473,15 @@
         U: "u",
         UL: "ul",
         SVG: "svg",
         VAR: "var",
         WBR: "wbr",
         XMP: "xmp"
     };
-    html.SPECIAL_ELEMENTS = {
+    html$1.SPECIAL_ELEMENTS = {
         [NS$3.HTML]: {
             [$$6.ADDRESS]: true,
             [$$6.APPLET]: true,
             [$$6.AREA]: true,
             [$$6.ARTICLE]: true,
             [$$6.ASIDE]: true,
             [$$6.BASE]: true,
@@ -63317,15 +63571,15 @@
         },
         [NS$3.SVG]: {
             [$$6.TITLE]: true,
             [$$6.FOREIGN_OBJECT]: true,
             [$$6.DESC]: true
         }
     };
-    const HTML$4 = html;
+    const HTML$4 = html$1;
     const $$5 = HTML$4.TAG_NAMES;
     const NS$2 = HTML$4.NAMESPACES;
 
     function isImpliedEndTagRequired(tn2) {
         switch (tn2.length) {
             case 1:
                 return tn2 === $$5.P;
@@ -63997,15 +64251,15 @@
         }
     }
     var openElementStackMixin = LocationInfoOpenElementStackMixin$1;
     const Mixin$5 = mixin;
     const Tokenizer$2 = tokenizer;
     const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
     const LocationInfoOpenElementStackMixin = openElementStackMixin;
-    const HTML$3 = html;
+    const HTML$3 = html$1;
     const $$4 = HTML$3.TAG_NAMES;
     class LocationInfoParserMixin$1 extends Mixin$5 {
         constructor(parser2) {
             super(parser2);
             this.parser = parser2;
             this.treeAdapter = this.parser.treeAdapter;
             this.posTracker = null;
@@ -64255,15 +64509,15 @@
             };
         }
     }
     var parserMixin = ErrorReportingParserMixin$1;
     var _default = {};
     const {
         DOCUMENT_MODE: DOCUMENT_MODE$1
-    } = html;
+    } = html$1;
     _default.createDocument = function() {
         return {
             nodeName: "#document",
             mode: DOCUMENT_MODE$1.NO_QUIRKS,
             childNodes: []
         };
     };
@@ -64437,15 +64691,15 @@
             });
             return merged;
         }, /* @__PURE__ */ Object.create(null));
     };
     var doctype$2 = {};
     const {
         DOCUMENT_MODE
-    } = html;
+    } = html$1;
     const VALID_DOCTYPE_NAME = "html";
     const VALID_SYSTEM_ID = "about:legacy-compat";
     const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
     const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
         "+//silmaril//dtd html pro v0r11 19970101//",
         "-//as//dtd html 3.0 aswedit + extensions//",
         "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
@@ -64567,15 +64821,15 @@
         if (systemId !== null) {
             str += " " + enquoteDoctypeId(systemId);
         }
         return str;
     };
     var foreignContent$1 = {};
     const Tokenizer$1 = tokenizer;
-    const HTML$2 = html;
+    const HTML$2 = html$1;
     const $$3 = HTML$2.TAG_NAMES;
     const NS$1 = HTML$2.NAMESPACES;
     const ATTRS$1 = HTML$2.ATTRS;
     const MIME_TYPES = {
         TEXT_HTML: "text/html",
         APPLICATION_XML: "application/xhtml+xml"
     };
@@ -64857,15 +65111,15 @@
     const Mixin = mixin;
     const defaultTreeAdapter = _default;
     const mergeOptions = mergeOptions$1;
     const doctype$1 = doctype$2;
     const foreignContent = foreignContent$1;
     const ERR = errorCodes;
     const unicode = unicode$3;
-    const HTML$1 = html;
+    const HTML$1 = html$1;
     const $$2 = HTML$1.TAG_NAMES;
     const NS = HTML$1.NAMESPACES;
     const ATTRS = HTML$1.ATTRS;
     const DEFAULT_OPTIONS = {
         scriptingEnabled: true,
         sourceCodeLocationInfo: false,
         onParseError: null,
@@ -67205,14 +67459,177 @@
             }
             if (p2.treeAdapter.getTagName(element2).toLowerCase() === token.tagName) {
                 p2.openElements.popUntilElementPopped(element2);
                 break;
             }
         }
     }
+    const pointStart = point$1("start");
+    const pointEnd = point$1("end");
+
+    function point$1(type2) {
+        return point2;
+
+        function point2(node2) {
+            const point3 = node2 && node2.position && node2.position[type2] || {};
+            return {
+                line: point3.line || null,
+                column: point3.column || null,
+                offset: point3.offset > -1 ? point3.offset : null
+            };
+        }
+    }
+    const convert = function(test2) {
+        if (test2 === void 0 || test2 === null) {
+            return ok;
+        }
+        if (typeof test2 === "string") {
+            return typeFactory(test2);
+        }
+        if (typeof test2 === "object") {
+            return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
+        }
+        if (typeof test2 === "function") {
+            return castFactory(test2);
+        }
+        throw new Error("Expected function, string, or object as test");
+    };
+
+    function anyFactory(tests) {
+        const checks2 = [];
+        let index2 = -1;
+        while (++index2 < tests.length) {
+            checks2[index2] = convert(tests[index2]);
+        }
+        return castFactory(any);
+
+        function any(...parameters) {
+            let index3 = -1;
+            while (++index3 < checks2.length) {
+                if (checks2[index3].call(this, ...parameters))
+                    return true;
+            }
+            return false;
+        }
+    }
+
+    function propsFactory(check) {
+        return castFactory(all2);
+
+        function all2(node2) {
+            let key;
+            for (key in check) {
+                if (node2[key] !== check[key])
+                    return false;
+            }
+            return true;
+        }
+    }
+
+    function typeFactory(check) {
+        return castFactory(type2);
+
+        function type2(node2) {
+            return node2 && node2.type === check;
+        }
+    }
+
+    function castFactory(check) {
+        return assertion;
+
+        function assertion(node2, ...parameters) {
+            return Boolean(
+                node2 && typeof node2 === "object" && "type" in node2 && Boolean(check.call(this, node2, ...parameters))
+            );
+        }
+    }
+
+    function ok() {
+        return true;
+    }
+
+    function color$1(d2) {
+        return d2;
+    }
+    const CONTINUE = true;
+    const EXIT = false;
+    const SKIP = "skip";
+    const visitParents = function(tree, test2, visitor, reverse) {
+        if (typeof test2 === "function" && typeof visitor !== "function") {
+            reverse = visitor;
+            visitor = test2;
+            test2 = null;
+        }
+        const is = convert(test2);
+        const step2 = reverse ? -1 : 1;
+        factory2(tree, void 0, [])();
+
+        function factory2(node2, index2, parents) {
+            const value = node2 && typeof node2 === "object" ? node2 : {};
+            if (typeof value.type === "string") {
+                const name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
+                Object.defineProperty(visit2, "name", {
+                    value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
+                });
+            }
+            return visit2;
+
+            function visit2() {
+                let result = [];
+                let subresult;
+                let offset2;
+                let grandparents;
+                if (!test2 || is(node2, index2, parents[parents.length - 1] || null)) {
+                    result = toResult(visitor(node2, parents));
+                    if (result[0] === EXIT) {
+                        return result;
+                    }
+                }
+                if (node2.children && result[0] !== SKIP) {
+                    offset2 = (reverse ? node2.children.length : -1) + step2;
+                    grandparents = parents.concat(node2);
+                    while (offset2 > -1 && offset2 < node2.children.length) {
+                        subresult = factory2(node2.children[offset2], offset2, grandparents)();
+                        if (subresult[0] === EXIT) {
+                            return subresult;
+                        }
+                        offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step2;
+                    }
+                }
+                return result;
+            }
+        }
+    };
+
+    function toResult(value) {
+        if (Array.isArray(value)) {
+            return value;
+        }
+        if (typeof value === "number") {
+            return [CONTINUE, value];
+        }
+        return [value];
+    }
+    const visit = function(tree, test2, visitor, reverse) {
+        if (typeof test2 === "function" && typeof visitor !== "function") {
+            reverse = visitor;
+            visitor = test2;
+            test2 = null;
+        }
+        visitParents(tree, test2, overload, reverse);
+
+        function overload(node2, parents) {
+            const parent = parents[parents.length - 1];
+            return visitor(
+                node2,
+                parent ? parent.children.indexOf(node2) : null,
+                parent
+            );
+        }
+    };
     const search = /[#.]/g;
 
     function parseSelector(selector2, defaultTagName) {
         const value = selector2 || "";
         const props = {};
         let start2 = 0;
         let previous2;
@@ -67242,15 +67659,15 @@
             type: "element",
             tagName: tagName || defaultTagName || "div",
             properties: props,
             children: []
         };
     }
     const buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
-    const own$4 = {}.hasOwnProperty;
+    const own$3 = {}.hasOwnProperty;
 
     function core$1(schema, defaultTagName, caseSensitive) {
         const adjust = caseSensitive && createAdjustMap(caseSensitive);
         const h2 = function(selector2, properties, ...children2) {
             let index2 = -1;
             let node2;
             if (selector2 === void 0 || selector2 === null) {
@@ -67258,21 +67675,21 @@
                     type: "root",
                     children: []
                 };
                 children2.unshift(properties);
             } else {
                 node2 = parseSelector(selector2, defaultTagName);
                 node2.tagName = node2.tagName.toLowerCase();
-                if (adjust && own$4.call(adjust, node2.tagName)) {
+                if (adjust && own$3.call(adjust, node2.tagName)) {
                     node2.tagName = adjust[node2.tagName];
                 }
                 if (isProperties(properties, node2.tagName)) {
                     let key;
                     for (key in properties) {
-                        if (own$4.call(properties, key)) {
+                        if (own$3.call(properties, key)) {
                             addProperty(schema, node2.properties, key, properties[key]);
                         }
                     }
                 } else {
                     children2.unshift(properties);
                 }
             }
@@ -67317,19 +67734,19 @@
             if (Number.isNaN(value))
                 return;
             result = value;
         } else if (typeof value === "boolean") {
             result = value;
         } else if (typeof value === "string") {
             if (info.spaceSeparated) {
-                result = parse$7(value);
-            } else if (info.commaSeparated) {
                 result = parse$6(value);
+            } else if (info.commaSeparated) {
+                result = parse$7(value);
             } else if (info.commaOrSpaceSeparated) {
-                result = parse$7(parse$6(value).join(" "));
+                result = parse$6(parse$7(value).join(" "));
             } else {
                 result = parsePrimitive(info, info.property, value);
             }
         } else if (Array.isArray(value)) {
             result = value.concat();
         } else {
             result = info.property === "style" ? style(value) : String(value);
@@ -67372,41 +67789,41 @@
     }
 
     function parsePrimitive(info, name2, value) {
         if (typeof value === "string") {
             if (info.number && value && !Number.isNaN(Number(value))) {
                 return Number(value);
             }
-            if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$1(value) === normalize$1(name2))) {
+            if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize$2(value) === normalize$2(name2))) {
                 return true;
             }
         }
         return value;
     }
 
     function style(value) {
         const result = [];
         let key;
         for (key in value) {
-            if (own$4.call(value, key)) {
+            if (own$3.call(value, key)) {
                 result.push([key, value[key]].join(": "));
             }
         }
         return result.join("; ");
     }
 
     function createAdjustMap(values) {
         const result = {};
         let index2 = -1;
         while (++index2 < values.length) {
             result[values[index2].toLowerCase()] = values[index2];
         }
         return result;
     }
-    const h$2 = core$1(html$1, "div");
+    const h$2 = core$1(html$3, "div");
     const svgCaseSensitiveTagNames = [
         "altGlyph",
         "altGlyphDef",
         "altGlyphItem",
         "animateColor",
         "animateMotion",
         "animateTransform",
@@ -67495,30 +67912,30 @@
         html: "http://www.w3.org/1999/xhtml",
         mathml: "http://www.w3.org/1998/Math/MathML",
         svg: "http://www.w3.org/2000/svg",
         xlink: "http://www.w3.org/1999/xlink",
         xml: "http://www.w3.org/XML/1998/namespace",
         xmlns: "http://www.w3.org/2000/xmlns/"
     };
-    const own$3 = {}.hasOwnProperty;
+    const own$2 = {}.hasOwnProperty;
     const proto = Object.prototype;
 
     function fromParse5(tree, options) {
         const options_ = options || {};
         let settings2;
         let file;
         if (isFile(options_)) {
             file = options_;
             settings2 = {};
         } else {
             file = options_.file || void 0;
             settings2 = options_;
         }
         return one$2({
-                schema: settings2.space === "svg" ? svg : html$1,
+                schema: settings2.space === "svg" ? svg : html$3,
                 file,
                 verbose: settings2.verbose,
                 location: false
             },
             tree
         );
     }
@@ -67590,21 +68007,21 @@
             result[index2] = one$2(state, nodes[index2]);
         }
         return result;
     }
 
     function element$2(state, node2) {
         const schema = state.schema;
-        state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$1;
+        state.schema = node2.namespaceURI === webNamespaces.svg ? svg : html$3;
         let index2 = -1;
         const props = {};
         while (++index2 < node2.attrs.length) {
             const attribute = node2.attrs[index2];
             const name2 = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
-            if (!own$3.call(proto, name2)) {
+            if (!own$2.call(proto, name2)) {
                 props[name2] = attribute.value;
             }
         }
         const fn2 = state.schema.space === "svg" ? s$2 : h$2;
         const result = fn2(node2.tagName, props, all$1(state, node2.childNodes));
         patch$1(state, node2, result);
         if (result.tagName === "template") {
@@ -67643,15 +68060,15 @@
                 result.end = Object.assign({}, tail.position.end);
             }
             if (state.verbose) {
                 const props = {};
                 let key;
                 if (location2.attrs) {
                     for (key in location2.attrs) {
-                        if (own$3.call(location2.attrs, key)) {
+                        if (own$2.call(location2.attrs, key)) {
                             props[find$3(state.schema, key).property] = position$1(
                                 location2.attrs[key]
                             );
                         }
                     }
                 }
                 node2.data = {
@@ -67686,52 +68103,52 @@
     function point(point2) {
         return point2.line && point2.column ? point2 : void 0;
     }
 
     function isFile(value) {
         return "messages" in value;
     }
-    const own$2 = {}.hasOwnProperty;
+    const own$1 = {}.hasOwnProperty;
 
     function zwitch(key, options) {
         const settings2 = options || {};
 
         function one2(value, ...parameters) {
             let fn2 = one2.invalid;
             const handlers2 = one2.handlers;
-            if (value && own$2.call(value, key)) {
+            if (value && own$1.call(value, key)) {
                 const id2 = String(value[key]);
-                fn2 = own$2.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
+                fn2 = own$1.call(handlers2, id2) ? handlers2[id2] : one2.unknown;
             }
             if (fn2) {
                 return fn2.call(this, value, ...parameters);
             }
         }
         one2.handlers = settings2.handlers || {};
         one2.invalid = settings2.invalid;
         one2.unknown = settings2.unknown;
         return one2;
     }
-    const own$1 = {}.hasOwnProperty;
+    const own = {}.hasOwnProperty;
     const one$1 = zwitch("type", {
         handlers: {
-            root: root$1,
+            root: root$2,
             element: element$1,
-            text: text$1,
+            text: text$2,
             comment: comment$1,
             doctype
         }
     });
 
     function toParse5(tree, options) {
         const space2 = options && typeof options === "object" ? options.space : options;
-        return one$1(tree, space2 === "svg" ? svg : html$1);
+        return one$1(tree, space2 === "svg" ? svg : html$3);
     }
 
-    function root$1(node2, schema) {
+    function root$2(node2, schema) {
         const result = {
             nodeName: "#document",
             mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
             childNodes: []
         };
         result.childNodes = all(node2.children, result, schema);
         patch(node2, result);
@@ -67756,15 +68173,15 @@
             systemId: "",
             parentNode: void 0
         };
         patch(node2, result);
         return result;
     }
 
-    function text$1(node2) {
+    function text$2(node2) {
         const result = {
             nodeName: "#text",
             value: node2.value,
             parentNode: void 0
         };
         patch(node2, result);
         return result;
@@ -67786,15 +68203,15 @@
         if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
             currentSchema = svg;
         }
         const attrs2 = [];
         let prop;
         if (node2.properties) {
             for (prop in node2.properties) {
-                if (prop !== "children" && own$1.call(node2.properties, prop)) {
+                if (prop !== "children" && own.call(node2.properties, prop)) {
                     const result2 = createProperty(
                         currentSchema,
                         prop,
                         node2.properties[prop]
                     );
                     if (result2) {
                         attrs2.push(result2);
@@ -67820,15 +68237,15 @@
 
     function createProperty(schema, prop, value) {
         const info = find$3(schema, prop);
         if (value === void 0 || value === null || value === false || typeof value === "number" && Number.isNaN(value) || !value && info.boolean) {
             return;
         }
         if (Array.isArray(value)) {
-            value = info.commaSeparated ? stringify$2(value) : stringify$3(value);
+            value = info.commaSeparated ? stringify$3(value) : stringify$2(value);
         }
         const attribute = {
             name: info.attribute,
             value: value === true ? "" : String(value)
         };
         if (info.space && info.space !== "html" && info.space !== "svg") {
             const index2 = attribute.name.indexOf(":");
@@ -68207,14 +68624,1720 @@
 
     function rehypeRaw(options = {}) {
         return (tree, file) => {
             const result = raw(tree, file, options);
             return result;
         };
     }
+
+    function ccount(value, character) {
+        const source = String(value);
+        if (typeof character !== "string") {
+            throw new TypeError("Expected character");
+        }
+        let count2 = 0;
+        let index2 = source.indexOf(character);
+        while (index2 !== -1) {
+            count2++;
+            index2 = source.indexOf(character, index2 + character.length);
+        }
+        return count2;
+    }
+
+    function escapeStringRegexp(string2) {
+        if (typeof string2 !== "string") {
+            throw new TypeError("Expected a string");
+        }
+        return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
+    }
+
+    function findAndReplace(tree, list2, options) {
+        const settings2 = options || {};
+        const ignored = convert$1(settings2.ignore || []);
+        const pairs = toPairs(list2);
+        let pairIndex = -1;
+        while (++pairIndex < pairs.length) {
+            visitParents$1(tree, "text", visitor);
+        }
+
+        function visitor(node2, parents) {
+            let index2 = -1;
+            let grandparent;
+            while (++index2 < parents.length) {
+                const parent = parents[index2];
+                const siblings = grandparent ? grandparent.children : void 0;
+                if (ignored(
+                        parent,
+                        siblings ? siblings.indexOf(parent) : void 0,
+                        grandparent
+                    )) {
+                    return;
+                }
+                grandparent = parent;
+            }
+            if (grandparent) {
+                return handler(node2, parents);
+            }
+        }
+
+        function handler(node2, parents) {
+            const parent = parents[parents.length - 1];
+            const find2 = pairs[pairIndex][0];
+            const replace2 = pairs[pairIndex][1];
+            let start2 = 0;
+            const siblings = parent.children;
+            const index2 = siblings.indexOf(node2);
+            let change = false;
+            let nodes = [];
+            find2.lastIndex = 0;
+            let match2 = find2.exec(node2.value);
+            while (match2) {
+                const position2 = match2.index;
+                const matchObject = {
+                    index: match2.index,
+                    input: match2.input,
+                    stack: [...parents, node2]
+                };
+                let value = replace2(...match2, matchObject);
+                if (typeof value === "string") {
+                    value = value.length > 0 ? {
+                        type: "text",
+                        value
+                    } : void 0;
+                }
+                if (value === false) {
+                    find2.lastIndex = position2 + 1;
+                } else {
+                    if (start2 !== position2) {
+                        nodes.push({
+                            type: "text",
+                            value: node2.value.slice(start2, position2)
+                        });
+                    }
+                    if (Array.isArray(value)) {
+                        nodes.push(...value);
+                    } else if (value) {
+                        nodes.push(value);
+                    }
+                    start2 = position2 + match2[0].length;
+                    change = true;
+                }
+                if (!find2.global) {
+                    break;
+                }
+                match2 = find2.exec(node2.value);
+            }
+            if (change) {
+                if (start2 < node2.value.length) {
+                    nodes.push({
+                        type: "text",
+                        value: node2.value.slice(start2)
+                    });
+                }
+                parent.children.splice(index2, 1, ...nodes);
+            } else {
+                nodes = [node2];
+            }
+            return index2 + nodes.length;
+        }
+    }
+
+    function toPairs(tupleOrList) {
+        const result = [];
+        if (!Array.isArray(tupleOrList)) {
+            throw new TypeError("Expected find and replace tuple or list of tuples");
+        }
+        const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
+        let index2 = -1;
+        while (++index2 < list2.length) {
+            const tuple = list2[index2];
+            result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
+        }
+        return result;
+    }
+
+    function toExpression(find2) {
+        return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
+    }
+
+    function toFunction(replace2) {
+        return typeof replace2 === "function" ? replace2 : function() {
+            return replace2;
+        };
+    }
+    const inConstruct = "phrasing";
+    const notInConstruct = ["autolink", "link", "image", "label"];
+
+    function gfmAutolinkLiteralFromMarkdown() {
+        return {
+            transforms: [transformGfmAutolinkLiterals],
+            enter: {
+                literalAutolink: enterLiteralAutolink,
+                literalAutolinkEmail: enterLiteralAutolinkValue,
+                literalAutolinkHttp: enterLiteralAutolinkValue,
+                literalAutolinkWww: enterLiteralAutolinkValue
+            },
+            exit: {
+                literalAutolink: exitLiteralAutolink,
+                literalAutolinkEmail: exitLiteralAutolinkEmail,
+                literalAutolinkHttp: exitLiteralAutolinkHttp,
+                literalAutolinkWww: exitLiteralAutolinkWww
+            }
+        };
+    }
+
+    function gfmAutolinkLiteralToMarkdown() {
+        return {
+            unsafe: [{
+                character: "@",
+                before: "[+\\-.\\w]",
+                after: "[\\-.\\w]",
+                inConstruct,
+                notInConstruct
+            }, {
+                character: ".",
+                before: "[Ww]",
+                after: "[\\-.\\w]",
+                inConstruct,
+                notInConstruct
+            }, {
+                character: ":",
+                before: "[ps]",
+                after: "\\/",
+                inConstruct,
+                notInConstruct
+            }]
+        };
+    }
+
+    function enterLiteralAutolink(token) {
+        this.enter({
+            type: "link",
+            title: null,
+            url: "",
+            children: []
+        }, token);
+    }
+
+    function enterLiteralAutolinkValue(token) {
+        this.config.enter.autolinkProtocol.call(this, token);
+    }
+
+    function exitLiteralAutolinkHttp(token) {
+        this.config.exit.autolinkProtocol.call(this, token);
+    }
+
+    function exitLiteralAutolinkWww(token) {
+        this.config.exit.data.call(this, token);
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "link");
+        node2.url = "http://" + this.sliceSerialize(token);
+    }
+
+    function exitLiteralAutolinkEmail(token) {
+        this.config.exit.autolinkEmail.call(this, token);
+    }
+
+    function exitLiteralAutolink(token) {
+        this.exit(token);
+    }
+
+    function transformGfmAutolinkLiterals(tree) {
+        findAndReplace(
+            tree,
+            [
+                [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
+                [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
+            ], {
+                ignore: ["link", "linkReference"]
+            }
+        );
+    }
+
+    function findUrl(_2, protocol, domain2, path2, match2) {
+        let prefix = "";
+        if (!previous(match2)) {
+            return false;
+        }
+        if (/^w/i.test(protocol)) {
+            domain2 = protocol + domain2;
+            protocol = "";
+            prefix = "http://";
+        }
+        if (!isCorrectDomain(domain2)) {
+            return false;
+        }
+        const parts = splitUrl(domain2 + path2);
+        if (!parts[0])
+            return false;
+        const result = {
+            type: "link",
+            title: null,
+            url: prefix + protocol + parts[0],
+            children: [{
+                type: "text",
+                value: protocol + parts[0]
+            }]
+        };
+        if (parts[1]) {
+            return [result, {
+                type: "text",
+                value: parts[1]
+            }];
+        }
+        return result;
+    }
+
+    function findEmail(_2, atext, label, match2) {
+        if (!previous(match2, true) || /[-\d_]$/.test(label)) {
+            return false;
+        }
+        return {
+            type: "link",
+            title: null,
+            url: "mailto:" + atext + "@" + label,
+            children: [{
+                type: "text",
+                value: atext + "@" + label
+            }]
+        };
+    }
+
+    function isCorrectDomain(domain2) {
+        const parts = domain2.split(".");
+        if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
+            return false;
+        }
+        return true;
+    }
+
+    function splitUrl(url2) {
+        const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url2);
+        if (!trailExec) {
+            return [url2, void 0];
+        }
+        url2 = url2.slice(0, trailExec.index);
+        let trail2 = trailExec[0];
+        let closingParenIndex = trail2.indexOf(")");
+        const openingParens = ccount(url2, "(");
+        let closingParens = ccount(url2, ")");
+        while (closingParenIndex !== -1 && openingParens > closingParens) {
+            url2 += trail2.slice(0, closingParenIndex + 1);
+            trail2 = trail2.slice(closingParenIndex + 1);
+            closingParenIndex = trail2.indexOf(")");
+            closingParens++;
+        }
+        return [url2, trail2];
+    }
+
+    function previous(match2, email) {
+        const code2 = match2.input.charCodeAt(match2.index - 1);
+        return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
+    }
+    footnoteReference.peek = footnoteReferencePeek;
+
+    function gfmFootnoteFromMarkdown() {
+        return {
+            enter: {
+                gfmFootnoteDefinition: enterFootnoteDefinition,
+                gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
+                gfmFootnoteCall: enterFootnoteCall,
+                gfmFootnoteCallString: enterFootnoteCallString
+            },
+            exit: {
+                gfmFootnoteDefinition: exitFootnoteDefinition,
+                gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
+                gfmFootnoteCall: exitFootnoteCall,
+                gfmFootnoteCallString: exitFootnoteCallString
+            }
+        };
+    }
+
+    function gfmFootnoteToMarkdown() {
+        return {
+            unsafe: [{
+                character: "[",
+                inConstruct: ["phrasing", "label", "reference"]
+            }],
+            handlers: {
+                footnoteDefinition,
+                footnoteReference
+            }
+        };
+    }
+
+    function enterFootnoteDefinition(token) {
+        this.enter({
+                type: "footnoteDefinition",
+                identifier: "",
+                label: "",
+                children: []
+            },
+            token
+        );
+    }
+
+    function enterFootnoteDefinitionLabelString() {
+        this.buffer();
+    }
+
+    function exitFootnoteDefinitionLabelString(token) {
+        const label = this.resume();
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "footnoteDefinition");
+        node2.label = label;
+        node2.identifier = normalizeIdentifier(
+            this.sliceSerialize(token)
+        ).toLowerCase();
+    }
+
+    function exitFootnoteDefinition(token) {
+        this.exit(token);
+    }
+
+    function enterFootnoteCall(token) {
+        this.enter({
+            type: "footnoteReference",
+            identifier: "",
+            label: ""
+        }, token);
+    }
+
+    function enterFootnoteCallString() {
+        this.buffer();
+    }
+
+    function exitFootnoteCallString(token) {
+        const label = this.resume();
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "footnoteReference");
+        node2.label = label;
+        node2.identifier = normalizeIdentifier(
+            this.sliceSerialize(token)
+        ).toLowerCase();
+    }
+
+    function exitFootnoteCall(token) {
+        this.exit(token);
+    }
+
+    function footnoteReference(node2, _2, state, info) {
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[^");
+        const exit2 = state.enter("footnoteReference");
+        const subexit = state.enter("reference");
+        value += tracker.move(
+            state.safe(state.associationId(node2), {
+                ...tracker.current(),
+                before: value,
+                after: "]"
+            })
+        );
+        subexit();
+        exit2();
+        value += tracker.move("]");
+        return value;
+    }
+
+    function footnoteReferencePeek() {
+        return "[";
+    }
+
+    function footnoteDefinition(node2, _2, state, info) {
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[^");
+        const exit2 = state.enter("footnoteDefinition");
+        const subexit = state.enter("label");
+        value += tracker.move(
+            state.safe(state.associationId(node2), {
+                ...tracker.current(),
+                before: value,
+                after: "]"
+            })
+        );
+        subexit();
+        value += tracker.move(
+            "]:" + (node2.children && node2.children.length > 0 ? " " : "")
+        );
+        tracker.shift(4);
+        value += tracker.move(
+            state.indentLines(state.containerFlow(node2, tracker.current()), map$4)
+        );
+        exit2();
+        return value;
+    }
+
+    function map$4(line, index2, blank) {
+        if (index2 === 0) {
+            return line;
+        }
+        return (blank ? "" : "    ") + line;
+    }
+    const constructsWithoutStrikethrough = [
+        "autolink",
+        "destinationLiteral",
+        "destinationRaw",
+        "reference",
+        "titleQuote",
+        "titleApostrophe"
+    ];
+    handleDelete.peek = peekDelete;
+
+    function gfmStrikethroughFromMarkdown() {
+        return {
+            canContainEols: ["delete"],
+            enter: {
+                strikethrough: enterStrikethrough
+            },
+            exit: {
+                strikethrough: exitStrikethrough
+            }
+        };
+    }
+
+    function gfmStrikethroughToMarkdown() {
+        return {
+            unsafe: [{
+                character: "~",
+                inConstruct: "phrasing",
+                notInConstruct: constructsWithoutStrikethrough
+            }],
+            handlers: {
+                delete: handleDelete
+            }
+        };
+    }
+
+    function enterStrikethrough(token) {
+        this.enter({
+            type: "delete",
+            children: []
+        }, token);
+    }
+
+    function exitStrikethrough(token) {
+        this.exit(token);
+    }
+
+    function handleDelete(node2, _2, state, info) {
+        const tracker = state.createTracker(info);
+        const exit2 = state.enter("strikethrough");
+        let value = tracker.move("~~");
+        value += state.containerPhrasing(node2, {
+            ...tracker.current(),
+            before: value,
+            after: "~"
+        });
+        value += tracker.move("~~");
+        exit2();
+        return value;
+    }
+
+    function peekDelete() {
+        return "~";
+    }
+
+    function markdownTable(table2, options = {}) {
+        const align = (options.align || []).concat();
+        const stringLength = options.stringLength || defaultStringLength;
+        const alignments = [];
+        const cellMatrix = [];
+        const sizeMatrix = [];
+        const longestCellByColumn = [];
+        let mostCellsPerRow = 0;
+        let rowIndex = -1;
+        while (++rowIndex < table2.length) {
+            const row2 = [];
+            const sizes2 = [];
+            let columnIndex2 = -1;
+            if (table2[rowIndex].length > mostCellsPerRow) {
+                mostCellsPerRow = table2[rowIndex].length;
+            }
+            while (++columnIndex2 < table2[rowIndex].length) {
+                const cell = serialize(table2[rowIndex][columnIndex2]);
+                if (options.alignDelimiters !== false) {
+                    const size2 = stringLength(cell);
+                    sizes2[columnIndex2] = size2;
+                    if (longestCellByColumn[columnIndex2] === void 0 || size2 > longestCellByColumn[columnIndex2]) {
+                        longestCellByColumn[columnIndex2] = size2;
+                    }
+                }
+                row2.push(cell);
+            }
+            cellMatrix[rowIndex] = row2;
+            sizeMatrix[rowIndex] = sizes2;
+        }
+        let columnIndex = -1;
+        if (typeof align === "object" && "length" in align) {
+            while (++columnIndex < mostCellsPerRow) {
+                alignments[columnIndex] = toAlignment(align[columnIndex]);
+            }
+        } else {
+            const code2 = toAlignment(align);
+            while (++columnIndex < mostCellsPerRow) {
+                alignments[columnIndex] = code2;
+            }
+        }
+        columnIndex = -1;
+        const row = [];
+        const sizes = [];
+        while (++columnIndex < mostCellsPerRow) {
+            const code2 = alignments[columnIndex];
+            let before = "";
+            let after = "";
+            if (code2 === 99) {
+                before = ":";
+                after = ":";
+            } else if (code2 === 108) {
+                before = ":";
+            } else if (code2 === 114) {
+                after = ":";
+            }
+            let size2 = options.alignDelimiters === false ? 1 : Math.max(
+                1,
+                longestCellByColumn[columnIndex] - before.length - after.length
+            );
+            const cell = before + "-".repeat(size2) + after;
+            if (options.alignDelimiters !== false) {
+                size2 = before.length + size2 + after.length;
+                if (size2 > longestCellByColumn[columnIndex]) {
+                    longestCellByColumn[columnIndex] = size2;
+                }
+                sizes[columnIndex] = size2;
+            }
+            row[columnIndex] = cell;
+        }
+        cellMatrix.splice(1, 0, row);
+        sizeMatrix.splice(1, 0, sizes);
+        rowIndex = -1;
+        const lines = [];
+        while (++rowIndex < cellMatrix.length) {
+            const row2 = cellMatrix[rowIndex];
+            const sizes2 = sizeMatrix[rowIndex];
+            columnIndex = -1;
+            const line = [];
+            while (++columnIndex < mostCellsPerRow) {
+                const cell = row2[columnIndex] || "";
+                let before = "";
+                let after = "";
+                if (options.alignDelimiters !== false) {
+                    const size2 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
+                    const code2 = alignments[columnIndex];
+                    if (code2 === 114) {
+                        before = " ".repeat(size2);
+                    } else if (code2 === 99) {
+                        if (size2 % 2) {
+                            before = " ".repeat(size2 / 2 + 0.5);
+                            after = " ".repeat(size2 / 2 - 0.5);
+                        } else {
+                            before = " ".repeat(size2 / 2);
+                            after = before;
+                        }
+                    } else {
+                        after = " ".repeat(size2);
+                    }
+                }
+                if (options.delimiterStart !== false && !columnIndex) {
+                    line.push("|");
+                }
+                if (options.padding !== false && !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
+                    line.push(" ");
+                }
+                if (options.alignDelimiters !== false) {
+                    line.push(before);
+                }
+                line.push(cell);
+                if (options.alignDelimiters !== false) {
+                    line.push(after);
+                }
+                if (options.padding !== false) {
+                    line.push(" ");
+                }
+                if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
+                    line.push("|");
+                }
+            }
+            lines.push(
+                options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
+            );
+        }
+        return lines.join("\n");
+    }
+
+    function serialize(value) {
+        return value === null || value === void 0 ? "" : String(value);
+    }
+
+    function defaultStringLength(value) {
+        return value.length;
+    }
+
+    function toAlignment(value) {
+        const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
+        return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
+    }
+
+    function blockquote(node2, _2, state, info) {
+        const exit2 = state.enter("blockquote");
+        const tracker = state.createTracker(info);
+        tracker.move("> ");
+        tracker.shift(2);
+        const value = state.indentLines(
+            state.containerFlow(node2, tracker.current()),
+            map$3
+        );
+        exit2();
+        return value;
+    }
+
+    function map$3(line, _2, blank) {
+        return ">" + (blank ? "" : " ") + line;
+    }
+
+    function patternInScope(stack, pattern) {
+        return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
+    }
+
+    function listInScope(stack, list2, none2) {
+        if (typeof list2 === "string") {
+            list2 = [list2];
+        }
+        if (!list2 || list2.length === 0) {
+            return none2;
+        }
+        let index2 = -1;
+        while (++index2 < list2.length) {
+            if (stack.includes(list2[index2])) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    function hardBreak(_2, _1, state, info) {
+        let index2 = -1;
+        while (++index2 < state.unsafe.length) {
+            if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
+                return /[ \t]/.test(info.before) ? "" : " ";
+            }
+        }
+        return "\\\n";
+    }
+
+    function longestStreak(value, substring) {
+        const source = String(value);
+        let index2 = source.indexOf(substring);
+        let expected = index2;
+        let count2 = 0;
+        let max2 = 0;
+        if (typeof substring !== "string") {
+            throw new TypeError("Expected substring");
+        }
+        while (index2 !== -1) {
+            if (index2 === expected) {
+                if (++count2 > max2) {
+                    max2 = count2;
+                }
+            } else {
+                count2 = 1;
+            }
+            expected = index2 + substring.length;
+            index2 = source.indexOf(substring, expected);
+        }
+        return max2;
+    }
+
+    function formatCodeAsIndented(node2, state) {
+        return Boolean(
+            state.options.fences === false && node2.value && !node2.lang && /[^ \r\n]/.test(node2.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
+        );
+    }
+
+    function checkFence(state) {
+        const marker = state.options.fence || "`";
+        if (marker !== "`" && marker !== "~") {
+            throw new Error(
+                "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
+            );
+        }
+        return marker;
+    }
+
+    function code$2(node2, _2, state, info) {
+        const marker = checkFence(state);
+        const raw2 = node2.value || "";
+        const suffix = marker === "`" ? "GraveAccent" : "Tilde";
+        if (formatCodeAsIndented(node2, state)) {
+            const exit3 = state.enter("codeIndented");
+            const value2 = state.indentLines(raw2, map$2);
+            exit3();
+            return value2;
+        }
+        const tracker = state.createTracker(info);
+        const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
+        const exit2 = state.enter("codeFenced");
+        let value = tracker.move(sequence);
+        if (node2.lang) {
+            const subexit = state.enter(`codeFencedLang${suffix}`);
+            value += tracker.move(
+                state.safe(node2.lang, {
+                    before: value,
+                    after: " ",
+                    encode: ["`"],
+                    ...tracker.current()
+                })
+            );
+            subexit();
+        }
+        if (node2.lang && node2.meta) {
+            const subexit = state.enter(`codeFencedMeta${suffix}`);
+            value += tracker.move(" ");
+            value += tracker.move(
+                state.safe(node2.meta, {
+                    before: value,
+                    after: "\n",
+                    encode: ["`"],
+                    ...tracker.current()
+                })
+            );
+            subexit();
+        }
+        value += tracker.move("\n");
+        if (raw2) {
+            value += tracker.move(raw2 + "\n");
+        }
+        value += tracker.move(sequence);
+        exit2();
+        return value;
+    }
+
+    function map$2(line, _2, blank) {
+        return (blank ? "" : "    ") + line;
+    }
+
+    function checkQuote(state) {
+        const marker = state.options.quote || '"';
+        if (marker !== '"' && marker !== "'") {
+            throw new Error(
+                "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
+            );
+        }
+        return marker;
+    }
+
+    function definition(node2, _2, state, info) {
+        const quote2 = checkQuote(state);
+        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
+        const exit2 = state.enter("definition");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[");
+        value += tracker.move(
+            state.safe(state.associationId(node2), {
+                before: value,
+                after: "]",
+                ...tracker.current()
+            })
+        );
+        value += tracker.move("]: ");
+        subexit();
+        if (!node2.url || /[\0- \u007F]/.test(node2.url)) {
+            subexit = state.enter("destinationLiteral");
+            value += tracker.move("<");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(">");
+        } else {
+            subexit = state.enter("destinationRaw");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: node2.title ? " " : "\n",
+                    ...tracker.current()
+                })
+            );
+        }
+        subexit();
+        if (node2.title) {
+            subexit = state.enter(`title${suffix}`);
+            value += tracker.move(" " + quote2);
+            value += tracker.move(
+                state.safe(node2.title, {
+                    before: value,
+                    after: quote2,
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(quote2);
+            subexit();
+        }
+        exit2();
+        return value;
+    }
+
+    function checkEmphasis(state) {
+        const marker = state.options.emphasis || "*";
+        if (marker !== "*" && marker !== "_") {
+            throw new Error(
+                "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
+            );
+        }
+        return marker;
+    }
+    emphasis.peek = emphasisPeek;
+
+    function emphasis(node2, _2, state, info) {
+        const marker = checkEmphasis(state);
+        const exit2 = state.enter("emphasis");
+        const tracker = state.createTracker(info);
+        let value = tracker.move(marker);
+        value += tracker.move(
+            state.containerPhrasing(node2, {
+                before: value,
+                after: marker,
+                ...tracker.current()
+            })
+        );
+        value += tracker.move(marker);
+        exit2();
+        return value;
+    }
+
+    function emphasisPeek(_2, _1, state) {
+        return state.options.emphasis || "*";
+    }
+
+    function formatHeadingAsSetext(node2, state) {
+        let literalWithBreak = false;
+        visit$1(node2, function(node3) {
+            if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
+                literalWithBreak = true;
+                return EXIT$1;
+            }
+        });
+        return Boolean(
+            (!node2.depth || node2.depth < 3) && toString$4(node2) && (state.options.setext || literalWithBreak)
+        );
+    }
+
+    function heading$1(node2, _2, state, info) {
+        const rank = Math.max(Math.min(6, node2.depth || 1), 1);
+        const tracker = state.createTracker(info);
+        if (formatHeadingAsSetext(node2, state)) {
+            const exit3 = state.enter("headingSetext");
+            const subexit2 = state.enter("phrasing");
+            const value2 = state.containerPhrasing(node2, {
+                ...tracker.current(),
+                before: "\n",
+                after: "\n"
+            });
+            subexit2();
+            exit3();
+            return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
+                value2.length - (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
+            );
+        }
+        const sequence = "#".repeat(rank);
+        const exit2 = state.enter("headingAtx");
+        const subexit = state.enter("phrasing");
+        tracker.move(sequence + " ");
+        let value = state.containerPhrasing(node2, {
+            before: "# ",
+            after: "\n",
+            ...tracker.current()
+        });
+        if (/^[\t ]/.test(value)) {
+            value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
+        }
+        value = value ? sequence + " " + value : sequence;
+        if (state.options.closeAtx) {
+            value += " " + sequence;
+        }
+        subexit();
+        exit2();
+        return value;
+    }
+    html.peek = htmlPeek;
+
+    function html(node2) {
+        return node2.value || "";
+    }
+
+    function htmlPeek() {
+        return "<";
+    }
+    image.peek = imagePeek;
+
+    function image(node2, _2, state, info) {
+        const quote2 = checkQuote(state);
+        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
+        const exit2 = state.enter("image");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("![");
+        value += tracker.move(
+            state.safe(node2.alt, {
+                before: value,
+                after: "]",
+                ...tracker.current()
+            })
+        );
+        value += tracker.move("](");
+        subexit();
+        if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
+            subexit = state.enter("destinationLiteral");
+            value += tracker.move("<");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(">");
+        } else {
+            subexit = state.enter("destinationRaw");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: node2.title ? " " : ")",
+                    ...tracker.current()
+                })
+            );
+        }
+        subexit();
+        if (node2.title) {
+            subexit = state.enter(`title${suffix}`);
+            value += tracker.move(" " + quote2);
+            value += tracker.move(
+                state.safe(node2.title, {
+                    before: value,
+                    after: quote2,
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(quote2);
+            subexit();
+        }
+        value += tracker.move(")");
+        exit2();
+        return value;
+    }
+
+    function imagePeek() {
+        return "!";
+    }
+    imageReference.peek = imageReferencePeek;
+
+    function imageReference(node2, _2, state, info) {
+        const type2 = node2.referenceType;
+        const exit2 = state.enter("imageReference");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("![");
+        const alt = state.safe(node2.alt, {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        value += tracker.move(alt + "][");
+        subexit();
+        const stack = state.stack;
+        state.stack = [];
+        subexit = state.enter("reference");
+        const reference2 = state.safe(state.associationId(node2), {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        subexit();
+        state.stack = stack;
+        exit2();
+        if (type2 === "full" || !alt || alt !== reference2) {
+            value += tracker.move(reference2 + "]");
+        } else if (type2 === "shortcut") {
+            value = value.slice(0, -1);
+        } else {
+            value += tracker.move("]");
+        }
+        return value;
+    }
+
+    function imageReferencePeek() {
+        return "!";
+    }
+    inlineCode.peek = inlineCodePeek;
+
+    function inlineCode(node2, _2, state) {
+        let value = node2.value || "";
+        let sequence = "`";
+        let index2 = -1;
+        while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
+            sequence += "`";
+        }
+        if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
+            value = " " + value + " ";
+        }
+        while (++index2 < state.unsafe.length) {
+            const pattern = state.unsafe[index2];
+            const expression = state.compilePattern(pattern);
+            let match2;
+            if (!pattern.atBreak)
+                continue;
+            while (match2 = expression.exec(value)) {
+                let position2 = match2.index;
+                if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
+                    position2--;
+                }
+                value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
+            }
+        }
+        return sequence + value + sequence;
+    }
+
+    function inlineCodePeek() {
+        return "`";
+    }
+
+    function formatLinkAsAutolink(node2, state) {
+        const raw2 = toString$4(node2);
+        return Boolean(
+            !state.options.resourceLink && node2.url && !node2.title && node2.children && node2.children.length === 1 && node2.children[0].type === "text" && (raw2 === node2.url || "mailto:" + raw2 === node2.url) && /^[a-z][a-z+.-]+:/i.test(node2.url) && !/[\0- <>\u007F]/.test(node2.url)
+        );
+    }
+    link$1.peek = linkPeek;
+
+    function link$1(node2, _2, state, info) {
+        const quote2 = checkQuote(state);
+        const suffix = quote2 === '"' ? "Quote" : "Apostrophe";
+        const tracker = state.createTracker(info);
+        let exit2;
+        let subexit;
+        if (formatLinkAsAutolink(node2, state)) {
+            const stack = state.stack;
+            state.stack = [];
+            exit2 = state.enter("autolink");
+            let value2 = tracker.move("<");
+            value2 += tracker.move(
+                state.containerPhrasing(node2, {
+                    before: value2,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value2 += tracker.move(">");
+            exit2();
+            state.stack = stack;
+            return value2;
+        }
+        exit2 = state.enter("link");
+        subexit = state.enter("label");
+        let value = tracker.move("[");
+        value += tracker.move(
+            state.containerPhrasing(node2, {
+                before: value,
+                after: "](",
+                ...tracker.current()
+            })
+        );
+        value += tracker.move("](");
+        subexit();
+        if (!node2.url && node2.title || /[\0- \u007F]/.test(node2.url)) {
+            subexit = state.enter("destinationLiteral");
+            value += tracker.move("<");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: ">",
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(">");
+        } else {
+            subexit = state.enter("destinationRaw");
+            value += tracker.move(
+                state.safe(node2.url, {
+                    before: value,
+                    after: node2.title ? " " : ")",
+                    ...tracker.current()
+                })
+            );
+        }
+        subexit();
+        if (node2.title) {
+            subexit = state.enter(`title${suffix}`);
+            value += tracker.move(" " + quote2);
+            value += tracker.move(
+                state.safe(node2.title, {
+                    before: value,
+                    after: quote2,
+                    ...tracker.current()
+                })
+            );
+            value += tracker.move(quote2);
+            subexit();
+        }
+        value += tracker.move(")");
+        exit2();
+        return value;
+    }
+
+    function linkPeek(node2, _2, state) {
+        return formatLinkAsAutolink(node2, state) ? "<" : "[";
+    }
+    linkReference.peek = linkReferencePeek;
+
+    function linkReference(node2, _2, state, info) {
+        const type2 = node2.referenceType;
+        const exit2 = state.enter("linkReference");
+        let subexit = state.enter("label");
+        const tracker = state.createTracker(info);
+        let value = tracker.move("[");
+        const text2 = state.containerPhrasing(node2, {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        value += tracker.move(text2 + "][");
+        subexit();
+        const stack = state.stack;
+        state.stack = [];
+        subexit = state.enter("reference");
+        const reference2 = state.safe(state.associationId(node2), {
+            before: value,
+            after: "]",
+            ...tracker.current()
+        });
+        subexit();
+        state.stack = stack;
+        exit2();
+        if (type2 === "full" || !text2 || text2 !== reference2) {
+            value += tracker.move(reference2 + "]");
+        } else if (type2 === "shortcut") {
+            value = value.slice(0, -1);
+        } else {
+            value += tracker.move("]");
+        }
+        return value;
+    }
+
+    function linkReferencePeek() {
+        return "[";
+    }
+
+    function checkBullet(state) {
+        const marker = state.options.bullet || "*";
+        if (marker !== "*" && marker !== "+" && marker !== "-") {
+            throw new Error(
+                "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
+            );
+        }
+        return marker;
+    }
+
+    function checkBulletOther(state) {
+        const bullet = checkBullet(state);
+        const bulletOther = state.options.bulletOther;
+        if (!bulletOther) {
+            return bullet === "*" ? "-" : "*";
+        }
+        if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
+            throw new Error(
+                "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
+            );
+        }
+        if (bulletOther === bullet) {
+            throw new Error(
+                "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
+            );
+        }
+        return bulletOther;
+    }
+
+    function checkBulletOrdered(state) {
+        const marker = state.options.bulletOrdered || ".";
+        if (marker !== "." && marker !== ")") {
+            throw new Error(
+                "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
+            );
+        }
+        return marker;
+    }
+
+    function checkRule(state) {
+        const marker = state.options.rule || "*";
+        if (marker !== "*" && marker !== "-" && marker !== "_") {
+            throw new Error(
+                "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
+            );
+        }
+        return marker;
+    }
+
+    function list(node2, parent, state, info) {
+        const exit2 = state.enter("list");
+        const bulletCurrent = state.bulletCurrent;
+        let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
+        const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
+        let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
+        if (!node2.ordered) {
+            const firstListItem = node2.children ? node2.children[0] : void 0;
+            if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0) {
+                useDifferentMarker = true;
+            }
+            if (checkRule(state) === bullet && firstListItem) {
+                let index2 = -1;
+                while (++index2 < node2.children.length) {
+                    const item = node2.children[index2];
+                    if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
+                        useDifferentMarker = true;
+                        break;
+                    }
+                }
+            }
+        }
+        if (useDifferentMarker) {
+            bullet = bulletOther;
+        }
+        state.bulletCurrent = bullet;
+        const value = state.containerFlow(node2, info);
+        state.bulletLastUsed = bullet;
+        state.bulletCurrent = bulletCurrent;
+        exit2();
+        return value;
+    }
+
+    function checkListItemIndent(state) {
+        const style2 = state.options.listItemIndent || "one";
+        if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
+            throw new Error(
+                "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
+            );
+        }
+        return style2;
+    }
+
+    function listItem(node2, parent, state, info) {
+        const listItemIndent = checkListItemIndent(state);
+        let bullet = state.bulletCurrent || checkBullet(state);
+        if (parent && parent.type === "list" && parent.ordered) {
+            bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
+        }
+        let size2 = bullet.length + 1;
+        if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
+            size2 = Math.ceil(size2 / 4) * 4;
+        }
+        const tracker = state.createTracker(info);
+        tracker.move(bullet + " ".repeat(size2 - bullet.length));
+        tracker.shift(size2);
+        const exit2 = state.enter("listItem");
+        const value = state.indentLines(
+            state.containerFlow(node2, tracker.current()),
+            map2
+        );
+        exit2();
+        return value;
+
+        function map2(line, index2, blank) {
+            if (index2) {
+                return (blank ? "" : " ".repeat(size2)) + line;
+            }
+            return (blank ? bullet : bullet + " ".repeat(size2 - bullet.length)) + line;
+        }
+    }
+
+    function paragraph(node2, _2, state, info) {
+        const exit2 = state.enter("paragraph");
+        const subexit = state.enter("phrasing");
+        const value = state.containerPhrasing(node2, info);
+        subexit();
+        exit2();
+        return value;
+    }
+    const phrasing = convert$1([
+        "break",
+        "delete",
+        "emphasis",
+        "footnote",
+        "footnoteReference",
+        "image",
+        "imageReference",
+        "inlineCode",
+        "inlineMath",
+        "link",
+        "linkReference",
+        "mdxJsxTextElement",
+        "mdxTextExpression",
+        "strong",
+        "text",
+        "textDirective"
+    ]);
+
+    function root$1(node2, _2, state, info) {
+        const hasPhrasing = node2.children.some(function(d2) {
+            return phrasing(d2);
+        });
+        const fn2 = hasPhrasing ? state.containerPhrasing : state.containerFlow;
+        return fn2.call(state, node2, info);
+    }
+
+    function checkStrong(state) {
+        const marker = state.options.strong || "*";
+        if (marker !== "*" && marker !== "_") {
+            throw new Error(
+                "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
+            );
+        }
+        return marker;
+    }
+    strong.peek = strongPeek;
+
+    function strong(node2, _2, state, info) {
+        const marker = checkStrong(state);
+        const exit2 = state.enter("strong");
+        const tracker = state.createTracker(info);
+        let value = tracker.move(marker + marker);
+        value += tracker.move(
+            state.containerPhrasing(node2, {
+                before: value,
+                after: marker,
+                ...tracker.current()
+            })
+        );
+        value += tracker.move(marker + marker);
+        exit2();
+        return value;
+    }
+
+    function strongPeek(_2, _1, state) {
+        return state.options.strong || "*";
+    }
+
+    function text$1(node2, _2, state, info) {
+        return state.safe(node2.value, info);
+    }
+
+    function checkRuleRepetition(state) {
+        const repetition = state.options.ruleRepetition || 3;
+        if (repetition < 3) {
+            throw new Error(
+                "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
+            );
+        }
+        return repetition;
+    }
+
+    function thematicBreak(_2, _1, state) {
+        const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
+        return state.options.ruleSpaces ? value.slice(0, -1) : value;
+    }
+    const handle = {
+        blockquote,
+        break: hardBreak,
+        code: code$2,
+        definition,
+        emphasis,
+        hardBreak,
+        heading: heading$1,
+        html,
+        image,
+        imageReference,
+        inlineCode,
+        link: link$1,
+        linkReference,
+        list,
+        listItem,
+        paragraph,
+        root: root$1,
+        strong,
+        text: text$1,
+        thematicBreak
+    };
+
+    function gfmTableFromMarkdown() {
+        return {
+            enter: {
+                table: enterTable,
+                tableData: enterCell,
+                tableHeader: enterCell,
+                tableRow: enterRow
+            },
+            exit: {
+                codeText: exitCodeText,
+                table: exitTable,
+                tableData: exit,
+                tableHeader: exit,
+                tableRow: exit
+            }
+        };
+    }
+
+    function enterTable(token) {
+        const align = token._align;
+        this.enter({
+                type: "table",
+                align: align.map(function(d2) {
+                    return d2 === "none" ? null : d2;
+                }),
+                children: []
+            },
+            token
+        );
+        this.data.inTable = true;
+    }
+
+    function exitTable(token) {
+        this.exit(token);
+        this.data.inTable = void 0;
+    }
+
+    function enterRow(token) {
+        this.enter({
+            type: "tableRow",
+            children: []
+        }, token);
+    }
+
+    function exit(token) {
+        this.exit(token);
+    }
+
+    function enterCell(token) {
+        this.enter({
+            type: "tableCell",
+            children: []
+        }, token);
+    }
+
+    function exitCodeText(token) {
+        let value = this.resume();
+        if (this.data.inTable) {
+            value = value.replace(/\\([\\|])/g, replace$1);
+        }
+        const node2 = this.stack[this.stack.length - 1];
+        ok$2(node2.type === "inlineCode");
+        node2.value = value;
+        this.exit(token);
+    }
+
+    function replace$1($0, $1) {
+        return $1 === "|" ? $1 : $0;
+    }
+
+    function gfmTableToMarkdown(options) {
+        const settings2 = options || {};
+        const padding = settings2.tableCellPadding;
+        const alignDelimiters = settings2.tablePipeAlign;
+        const stringLength = settings2.stringLength;
+        const around = padding ? " " : "|";
+        return {
+            unsafe: [{
+                character: "\r",
+                inConstruct: "tableCell"
+            }, {
+                character: "\n",
+                inConstruct: "tableCell"
+            }, {
+                atBreak: true,
+                character: "|",
+                after: "[	 :-]"
+            }, {
+                character: "|",
+                inConstruct: "tableCell"
+            }, {
+                atBreak: true,
+                character: ":",
+                after: "-"
+            }, {
+                atBreak: true,
+                character: "-",
+                after: "[:|-]"
+            }],
+            handlers: {
+                inlineCode: inlineCodeWithTable,
+                table: handleTable,
+                tableCell: handleTableCell,
+                tableRow: handleTableRow
+            }
+        };
+
+        function handleTable(node2, _2, state, info) {
+            return serializeData(handleTableAsData(node2, state, info), node2.align);
+        }
+
+        function handleTableRow(node2, _2, state, info) {
+            const row = handleTableRowAsData(node2, state, info);
+            const value = serializeData([row]);
+            return value.slice(0, value.indexOf("\n"));
+        }
+
+        function handleTableCell(node2, _2, state, info) {
+            const exit2 = state.enter("tableCell");
+            const subexit = state.enter("phrasing");
+            const value = state.containerPhrasing(node2, {
+                ...info,
+                before: around,
+                after: around
+            });
+            subexit();
+            exit2();
+            return value;
+        }
+
+        function serializeData(matrix, align) {
+            return markdownTable(matrix, {
+                align,
+                alignDelimiters,
+                padding,
+                stringLength
+            });
+        }
+
+        function handleTableAsData(node2, state, info) {
+            const children2 = node2.children;
+            let index2 = -1;
+            const result = [];
+            const subexit = state.enter("table");
+            while (++index2 < children2.length) {
+                result[index2] = handleTableRowAsData(children2[index2], state, info);
+            }
+            subexit();
+            return result;
+        }
+
+        function handleTableRowAsData(node2, state, info) {
+            const children2 = node2.children;
+            let index2 = -1;
+            const result = [];
+            const subexit = state.enter("tableRow");
+            while (++index2 < children2.length) {
+                result[index2] = handleTableCell(children2[index2], node2, state, info);
+            }
+            subexit();
+            return result;
+        }
+
+        function inlineCodeWithTable(node2, parent, state) {
+            let value = handle.inlineCode(node2, parent, state);
+            if (state.stack.includes("tableCell")) {
+                value = value.replace(/\|/g, "\\$&");
+            }
+            return value;
+        }
+    }
+
+    function gfmTaskListItemFromMarkdown() {
+        return {
+            exit: {
+                taskListCheckValueChecked: exitCheck,
+                taskListCheckValueUnchecked: exitCheck,
+                paragraph: exitParagraphWithTaskListItem
+            }
+        };
+    }
+
+    function gfmTaskListItemToMarkdown() {
+        return {
+            unsafe: [{
+                atBreak: true,
+                character: "-",
+                after: "[:|-]"
+            }],
+            handlers: {
+                listItem: listItemWithTaskListItem
+            }
+        };
+    }
+
+    function exitCheck(token) {
+        const node2 = this.stack[this.stack.length - 2];
+        ok$2(node2.type === "listItem");
+        node2.checked = token.type === "taskListCheckValueChecked";
+    }
+
+    function exitParagraphWithTaskListItem(token) {
+        const parent = this.stack[this.stack.length - 2];
+        if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
+            const node2 = this.stack[this.stack.length - 1];
+            ok$2(node2.type === "paragraph");
+            const head = node2.children[0];
+            if (head && head.type === "text") {
+                const siblings = parent.children;
+                let index2 = -1;
+                let firstParaghraph;
+                while (++index2 < siblings.length) {
+                    const sibling = siblings[index2];
+                    if (sibling.type === "paragraph") {
+                        firstParaghraph = sibling;
+                        break;
+                    }
+                }
+                if (firstParaghraph === node2) {
+                    head.value = head.value.slice(1);
+                    if (head.value.length === 0) {
+                        node2.children.shift();
+                    } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
+                        head.position.start.column++;
+                        head.position.start.offset++;
+                        node2.position.start = Object.assign({}, head.position.start);
+                    }
+                }
+            }
+        }
+        this.exit(token);
+    }
+
+    function listItemWithTaskListItem(node2, parent, state, info) {
+        const head = node2.children[0];
+        const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
+        const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
+        const tracker = state.createTracker(info);
+        if (checkable) {
+            tracker.move(checkbox);
+        }
+        let value = handle.listItem(node2, parent, state, {
+            ...info,
+            ...tracker.current()
+        });
+        if (checkable) {
+            value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
+        }
+        return value;
+
+        function check($0) {
+            return $0 + checkbox;
+        }
+    }
+
+    function gfmFromMarkdown() {
+        return [
+            gfmAutolinkLiteralFromMarkdown(),
+            gfmFootnoteFromMarkdown(),
+            gfmStrikethroughFromMarkdown(),
+            gfmTableFromMarkdown(),
+            gfmTaskListItemFromMarkdown()
+        ];
+    }
+
+    function gfmToMarkdown(options) {
+        return {
+            extensions: [
+                gfmAutolinkLiteralToMarkdown(),
+                gfmFootnoteToMarkdown(),
+                gfmStrikethroughToMarkdown(),
+                gfmTableToMarkdown(options),
+                gfmTaskListItemToMarkdown()
+            ]
+        };
+    }
     const wwwPrefix = {
         tokenize: tokenizeWwwPrefix,
         partial: true
     };
     const domain = {
         tokenize: tokenizeDomain,
         partial: true
@@ -68240,17 +70363,20 @@
         previous: previousProtocol
     };
     const emailAutolink = {
         tokenize: tokenizeEmailAutolink,
         previous: previousEmail
     };
     const text = {};
-    const gfmAutolinkLiteral = {
-        text
-    };
+
+    function gfmAutolinkLiteral() {
+        return {
+            text
+        };
+    }
     let code$1 = 48;
     while (code$1 < 123) {
         text[code$1] = emailAutolink;
         code$1++;
         if (code$1 === 58)
             code$1 = 65;
         else if (code$1 === 91)
@@ -68346,37 +70472,37 @@
             effects.exit("literalAutolink");
             return ok2(code2);
         }
     }
 
     function tokenizeProtocolAutolink(effects, ok2, nok) {
         const self2 = this;
-        let buffer2 = "";
+        let buffer = "";
         let seen = false;
         return protocolStart;
 
         function protocolStart(code2) {
             if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
                 effects.enter("literalAutolink");
                 effects.enter("literalAutolinkHttp");
-                buffer2 += String.fromCodePoint(code2);
+                buffer += String.fromCodePoint(code2);
                 effects.consume(code2);
                 return protocolPrefixInside;
             }
             return nok(code2);
         }
 
         function protocolPrefixInside(code2) {
-            if (asciiAlpha(code2) && buffer2.length < 5) {
-                buffer2 += String.fromCodePoint(code2);
+            if (asciiAlpha(code2) && buffer.length < 5) {
+                buffer += String.fromCodePoint(code2);
                 effects.consume(code2);
                 return protocolPrefixInside;
             }
             if (code2 === 58) {
-                const protocol = buffer2.toLowerCase();
+                const protocol = buffer.toLowerCase();
                 if (protocol === "http" || protocol === "https") {
                     effects.consume(code2);
                     return protocolSlashesInside;
                 }
             }
             return nok(code2);
         }
@@ -68401,24 +70527,24 @@
             effects.exit("literalAutolinkHttp");
             effects.exit("literalAutolink");
             return ok2(code2);
         }
     }
 
     function tokenizeWwwPrefix(effects, ok2, nok) {
-        let size = 0;
+        let size2 = 0;
         return wwwPrefixInside;
 
         function wwwPrefixInside(code2) {
-            if ((code2 === 87 || code2 === 119) && size < 3) {
-                size++;
+            if ((code2 === 87 || code2 === 119) && size2 < 3) {
+                size2++;
                 effects.consume(code2);
                 return wwwPrefixInside;
             }
-            if (code2 === 46 && size === 3) {
+            if (code2 === 46 && size2 === 3) {
                 effects.consume(code2);
                 return wwwPrefixAfter;
             }
             return nok(code2);
         }
 
         function wwwPrefixAfter(code2) {
@@ -68709,15 +70835,15 @@
         events2.splice(index2, events2.length - index2 + 1, ...replacement);
         return events2;
     }
 
     function tokenizeGfmFootnoteCall(effects, ok2, nok) {
         const self2 = this;
         const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
-        let size = 0;
+        let size2 = 0;
         let data2;
         return start2;
 
         function start2(code2) {
             effects.enter("gfmFootnoteCall");
             effects.enter("gfmFootnoteCallLabelMarker");
             effects.consume(code2);
@@ -68733,15 +70859,15 @@
             effects.exit("gfmFootnoteCallMarker");
             effects.enter("gfmFootnoteCallString");
             effects.enter("chunkString").contentType = "string";
             return callData;
         }
 
         function callData(code2) {
-            if (size > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
+            if (size2 > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
                 return nok(code2);
             }
             if (code2 === 93) {
                 effects.exit("chunkString");
                 const token = effects.exit("gfmFootnoteCallString");
                 if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
                     return nok(code2);
@@ -68751,34 +70877,34 @@
                 effects.exit("gfmFootnoteCallLabelMarker");
                 effects.exit("gfmFootnoteCall");
                 return ok2;
             }
             if (!markdownLineEndingOrSpace(code2)) {
                 data2 = true;
             }
-            size++;
+            size2++;
             effects.consume(code2);
             return code2 === 92 ? callEscape : callData;
         }
 
         function callEscape(code2) {
             if (code2 === 91 || code2 === 92 || code2 === 93) {
                 effects.consume(code2);
-                size++;
+                size2++;
                 return callData;
             }
             return callData(code2);
         }
     }
 
     function tokenizeDefinitionStart(effects, ok2, nok) {
         const self2 = this;
         const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
         let identifier;
-        let size = 0;
+        let size2 = 0;
         let data2;
         return start2;
 
         function start2(code2) {
             effects.enter("gfmFootnoteDefinition")._container = true;
             effects.enter("gfmFootnoteDefinitionLabel");
             effects.enter("gfmFootnoteDefinitionLabelMarker");
@@ -68796,15 +70922,15 @@
                 effects.enter("chunkString").contentType = "string";
                 return labelInside;
             }
             return nok(code2);
         }
 
         function labelInside(code2) {
-            if (size > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
+            if (size2 > 999 || code2 === 93 && !data2 || code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)) {
                 return nok(code2);
             }
             if (code2 === 93) {
                 effects.exit("chunkString");
                 const token = effects.exit("gfmFootnoteDefinitionLabelString");
                 identifier = normalizeIdentifier(self2.sliceSerialize(token));
                 effects.enter("gfmFootnoteDefinitionLabelMarker");
@@ -68812,23 +70938,23 @@
                 effects.exit("gfmFootnoteDefinitionLabelMarker");
                 effects.exit("gfmFootnoteDefinitionLabel");
                 return labelAfter;
             }
             if (!markdownLineEndingOrSpace(code2)) {
                 data2 = true;
             }
-            size++;
+            size2++;
             effects.consume(code2);
             return code2 === 92 ? labelEscape : labelInside;
         }
 
         function labelEscape(code2) {
             if (code2 === 91 || code2 === 92 || code2 === 93) {
                 effects.consume(code2);
-                size++;
+                size2++;
                 return labelInside;
             }
             return labelInside(code2);
         }
 
         function labelAfter(code2) {
             if (code2 === 58) {
@@ -68952,35 +71078,35 @@
             }
             return events2;
         }
 
         function tokenizeStrikethrough(effects, ok2, nok) {
             const previous2 = this.previous;
             const events2 = this.events;
-            let size = 0;
+            let size2 = 0;
             return start2;
 
             function start2(code2) {
                 if (previous2 === 126 && events2[events2.length - 1][1].type !== "characterEscape") {
                     return nok(code2);
                 }
                 effects.enter("strikethroughSequenceTemporary");
                 return more(code2);
             }
 
             function more(code2) {
                 const before = classifyCharacter(previous2);
                 if (code2 === 126) {
-                    if (size > 1)
+                    if (size2 > 1)
                         return nok(code2);
                     effects.consume(code2);
-                    size++;
+                    size2++;
                     return more;
                 }
-                if (size < 2 && !single)
+                if (size2 < 2 && !single)
                     return nok(code2);
                 const token = effects.exit("strikethroughSequenceTemporary");
                 const after = classifyCharacter(code2);
                 token._open = !after || after === 2 && Boolean(before);
                 token._close = !before || before === 2 && Boolean(after);
                 return ok2(code2);
             }
@@ -68990,24 +71116,28 @@
         constructor() {
             this.map = [];
         }
         add(index2, remove2, add2) {
             addImpl(this, index2, remove2, add2);
         }
         consume(events2) {
-            this.map.sort((a2, b2) => a2[0] - b2[0]);
+            this.map.sort(function(a2, b2) {
+                return a2[0] - b2[0];
+            });
             if (this.map.length === 0) {
                 return;
             }
             let index2 = this.map.length;
             const vecs = [];
             while (index2 > 0) {
                 index2 -= 1;
-                vecs.push(events2.slice(this.map[index2][0] + this.map[index2][1]));
-                vecs.push(this.map[index2][2]);
+                vecs.push(
+                    events2.slice(this.map[index2][0] + this.map[index2][1]),
+                    this.map[index2][2]
+                );
                 events2.length = this.map[index2][0];
             }
             vecs.push([...events2]);
             events2.length = 0;
             let slice = vecs.pop();
             while (slice) {
                 events2.push(...slice);
@@ -69056,26 +71186,29 @@
             } else if (event2[0] === "enter" && event2[1].type === "tableDelimiterRow") {
                 inDelimiterRow = true;
             }
             index2 += 1;
         }
         return align;
     }
-    const gfmTable = {
-        flow: {
-            null: {
-                tokenize: tokenizeTable,
-                resolveAll: resolveTable
+
+    function gfmTable() {
+        return {
+            flow: {
+                null: {
+                    tokenize: tokenizeTable,
+                    resolveAll: resolveTable
+                }
             }
-        }
-    };
+        };
+    }
 
     function tokenizeTable(effects, ok2, nok) {
         const self2 = this;
-        let size = 0;
+        let size2 = 0;
         let sizeB = 0;
         let seen;
         return start2;
 
         function start2(code2) {
             let index2 = self2.events.length - 1;
             while (index2 > -1) {
@@ -69126,15 +71259,15 @@
             }
             if (markdownSpace(code2)) {
                 return factorySpace(effects, headRowBreak, "whitespace")(code2);
             }
             sizeB += 1;
             if (seen) {
                 seen = false;
-                size += 1;
+                size2 += 1;
             }
             if (code2 === 124) {
                 effects.enter("tableCellDivider");
                 effects.consume(code2);
                 effects.exit("tableCellDivider");
                 seen = true;
                 return headRowBreak;
@@ -69251,15 +71384,15 @@
         }
 
         function headDelimiterCellAfter(code2) {
             if (code2 === 124) {
                 return headDelimiterBefore(code2);
             }
             if (code2 === null || markdownLineEnding(code2)) {
-                if (!seen || size !== sizeB) {
+                if (!seen || size2 !== sizeB) {
                     return headDelimiterNok(code2);
                 }
                 effects.exit("tableDelimiterRow");
                 effects.exit("tableHead");
                 return ok2(code2);
             }
             return headDelimiterNok(code2);
@@ -69502,19 +71635,22 @@
         const event2 = events2[index2];
         const side = event2[0] === "enter" ? "start" : "end";
         return event2[1][side];
     }
     const tasklistCheck = {
         tokenize: tokenizeTasklistCheck
     };
-    const gfmTaskListItem = {
-        text: {
-            [91]: tasklistCheck
-        }
-    };
+
+    function gfmTaskListItem() {
+        return {
+            text: {
+                [91]: tasklistCheck
+            }
+        };
+    }
 
     function tokenizeTasklistCheck(effects, ok2, nok) {
         const self2 = this;
         return open;
 
         function open(code2) {
             if (self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
@@ -69576,1320 +71712,33 @@
         function after(code2) {
             return code2 === null ? nok(code2) : ok2(code2);
         }
     }
 
     function gfm(options) {
         return combineExtensions([
-            gfmAutolinkLiteral,
+            gfmAutolinkLiteral(),
             gfmFootnote(),
             gfmStrikethrough(options),
-            gfmTable,
-            gfmTaskListItem
+            gfmTable(),
+            gfmTaskListItem()
         ]);
     }
+    const emptyOptions = {};
 
-    function ccount(value, character) {
-        const source = String(value);
-        if (typeof character !== "string") {
-            throw new TypeError("Expected character");
-        }
-        let count2 = 0;
-        let index2 = source.indexOf(character);
-        while (index2 !== -1) {
-            count2++;
-            index2 = source.indexOf(character, index2 + character.length);
-        }
-        return count2;
-    }
-
-    function escapeStringRegexp(string2) {
-        if (typeof string2 !== "string") {
-            throw new TypeError("Expected a string");
-        }
-        return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
-    }
-    const own = {}.hasOwnProperty;
-    const findAndReplace = function(tree, find2, replace2, options) {
-        let settings2;
-        let schema;
-        if (typeof find2 === "string" || find2 instanceof RegExp) {
-            schema = [
-                [find2, replace2]
-            ];
-            settings2 = options;
-        } else {
-            schema = find2;
-            settings2 = replace2;
-        }
-        if (!settings2) {
-            settings2 = {};
-        }
-        const ignored = convert(settings2.ignore || []);
-        const pairs = toPairs(schema);
-        let pairIndex = -1;
-        while (++pairIndex < pairs.length) {
-            visitParents(tree, "text", visitor);
-        }
-        return tree;
-
-        function visitor(node2, parents) {
-            let index2 = -1;
-            let grandparent;
-            while (++index2 < parents.length) {
-                const parent = parents[index2];
-                if (ignored(
-                        parent,
-                        grandparent ? grandparent.children.indexOf(parent) : void 0,
-                        grandparent
-                    )) {
-                    return;
-                }
-                grandparent = parent;
-            }
-            if (grandparent) {
-                return handler(node2, parents);
-            }
-        }
-
-        function handler(node2, parents) {
-            const parent = parents[parents.length - 1];
-            const find3 = pairs[pairIndex][0];
-            const replace3 = pairs[pairIndex][1];
-            let start2 = 0;
-            const index2 = parent.children.indexOf(node2);
-            let change = false;
-            let nodes = [];
-            find3.lastIndex = 0;
-            let match2 = find3.exec(node2.value);
-            while (match2) {
-                const position2 = match2.index;
-                const matchObject = {
-                    index: match2.index,
-                    input: match2.input,
-                    stack: [...parents, node2]
-                };
-                let value = replace3(...match2, matchObject);
-                if (typeof value === "string") {
-                    value = value.length > 0 ? {
-                        type: "text",
-                        value
-                    } : void 0;
-                }
-                if (value !== false) {
-                    if (start2 !== position2) {
-                        nodes.push({
-                            type: "text",
-                            value: node2.value.slice(start2, position2)
-                        });
-                    }
-                    if (Array.isArray(value)) {
-                        nodes.push(...value);
-                    } else if (value) {
-                        nodes.push(value);
-                    }
-                    start2 = position2 + match2[0].length;
-                    change = true;
-                }
-                if (!find3.global) {
-                    break;
-                }
-                match2 = find3.exec(node2.value);
-            }
-            if (change) {
-                if (start2 < node2.value.length) {
-                    nodes.push({
-                        type: "text",
-                        value: node2.value.slice(start2)
-                    });
-                }
-                parent.children.splice(index2, 1, ...nodes);
-            } else {
-                nodes = [node2];
-            }
-            return index2 + nodes.length;
-        }
-    };
-
-    function toPairs(schema) {
-        const result = [];
-        if (typeof schema !== "object") {
-            throw new TypeError("Expected array or object as schema");
-        }
-        if (Array.isArray(schema)) {
-            let index2 = -1;
-            while (++index2 < schema.length) {
-                result.push([
-                    toExpression(schema[index2][0]),
-                    toFunction(schema[index2][1])
-                ]);
-            }
-        } else {
-            let key;
-            for (key in schema) {
-                if (own.call(schema, key)) {
-                    result.push([toExpression(key), toFunction(schema[key])]);
-                }
-            }
-        }
-        return result;
-    }
-
-    function toExpression(find2) {
-        return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
-    }
-
-    function toFunction(replace2) {
-        return typeof replace2 === "function" ? replace2 : () => replace2;
-    }
-    const inConstruct = "phrasing";
-    const notInConstruct = ["autolink", "link", "image", "label"];
-    const gfmAutolinkLiteralFromMarkdown = {
-        transforms: [transformGfmAutolinkLiterals],
-        enter: {
-            literalAutolink: enterLiteralAutolink,
-            literalAutolinkEmail: enterLiteralAutolinkValue,
-            literalAutolinkHttp: enterLiteralAutolinkValue,
-            literalAutolinkWww: enterLiteralAutolinkValue
-        },
-        exit: {
-            literalAutolink: exitLiteralAutolink,
-            literalAutolinkEmail: exitLiteralAutolinkEmail,
-            literalAutolinkHttp: exitLiteralAutolinkHttp,
-            literalAutolinkWww: exitLiteralAutolinkWww
-        }
-    };
-    const gfmAutolinkLiteralToMarkdown = {
-        unsafe: [{
-            character: "@",
-            before: "[+\\-.\\w]",
-            after: "[\\-.\\w]",
-            inConstruct,
-            notInConstruct
-        }, {
-            character: ".",
-            before: "[Ww]",
-            after: "[\\-.\\w]",
-            inConstruct,
-            notInConstruct
-        }, {
-            character: ":",
-            before: "[ps]",
-            after: "\\/",
-            inConstruct,
-            notInConstruct
-        }]
-    };
-
-    function enterLiteralAutolink(token) {
-        this.enter({
-            type: "link",
-            title: null,
-            url: "",
-            children: []
-        }, token);
-    }
-
-    function enterLiteralAutolinkValue(token) {
-        this.config.enter.autolinkProtocol.call(this, token);
-    }
-
-    function exitLiteralAutolinkHttp(token) {
-        this.config.exit.autolinkProtocol.call(this, token);
-    }
-
-    function exitLiteralAutolinkWww(token) {
-        this.config.exit.data.call(this, token);
-        const node2 = this.stack[this.stack.length - 1];
-        node2.url = "http://" + this.sliceSerialize(token);
-    }
-
-    function exitLiteralAutolinkEmail(token) {
-        this.config.exit.autolinkEmail.call(this, token);
-    }
-
-    function exitLiteralAutolink(token) {
-        this.exit(token);
-    }
-
-    function transformGfmAutolinkLiterals(tree) {
-        findAndReplace(
-            tree,
-            [
-                [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
-                [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
-            ], {
-                ignore: ["link", "linkReference"]
-            }
-        );
-    }
-
-    function findUrl(_2, protocol, domain2, path2, match2) {
-        let prefix = "";
-        if (!previous(match2)) {
-            return false;
-        }
-        if (/^w/i.test(protocol)) {
-            domain2 = protocol + domain2;
-            protocol = "";
-            prefix = "http://";
-        }
-        if (!isCorrectDomain(domain2)) {
-            return false;
-        }
-        const parts = splitUrl(domain2 + path2);
-        if (!parts[0])
-            return false;
-        const result = {
-            type: "link",
-            title: null,
-            url: prefix + protocol + parts[0],
-            children: [{
-                type: "text",
-                value: protocol + parts[0]
-            }]
-        };
-        if (parts[1]) {
-            return [result, {
-                type: "text",
-                value: parts[1]
-            }];
-        }
-        return result;
-    }
-
-    function findEmail(_2, atext, label, match2) {
-        if (!previous(match2, true) || /[-\d_]$/.test(label)) {
-            return false;
-        }
-        return {
-            type: "link",
-            title: null,
-            url: "mailto:" + atext + "@" + label,
-            children: [{
-                type: "text",
-                value: atext + "@" + label
-            }]
-        };
-    }
-
-    function isCorrectDomain(domain2) {
-        const parts = domain2.split(".");
-        if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
-            return false;
-        }
-        return true;
-    }
-
-    function splitUrl(url2) {
-        const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url2);
-        if (!trailExec) {
-            return [url2, void 0];
-        }
-        url2 = url2.slice(0, trailExec.index);
-        let trail2 = trailExec[0];
-        let closingParenIndex = trail2.indexOf(")");
-        const openingParens = ccount(url2, "(");
-        let closingParens = ccount(url2, ")");
-        while (closingParenIndex !== -1 && openingParens > closingParens) {
-            url2 += trail2.slice(0, closingParenIndex + 1);
-            trail2 = trail2.slice(closingParenIndex + 1);
-            closingParenIndex = trail2.indexOf(")");
-            closingParens++;
-        }
-        return [url2, trail2];
-    }
-
-    function previous(match2, email) {
-        const code2 = match2.input.charCodeAt(match2.index - 1);
-        return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
-    }
-
-    function association(node2) {
-        if (node2.label || !node2.identifier) {
-            return node2.label || "";
-        }
-        return decodeString(node2.identifier);
-    }
-
-    function containerFlow(parent, state, info) {
-        const indexStack = state.indexStack;
-        const children2 = parent.children || [];
-        const tracker = state.createTracker(info);
-        const results = [];
-        let index2 = -1;
-        indexStack.push(-1);
-        while (++index2 < children2.length) {
-            const child = children2[index2];
-            indexStack[indexStack.length - 1] = index2;
-            results.push(
-                tracker.move(
-                    state.handle(child, parent, state, {
-                        before: "\n",
-                        after: "\n",
-                        ...tracker.current()
-                    })
-                )
-            );
-            if (child.type !== "list") {
-                state.bulletLastUsed = void 0;
-            }
-            if (index2 < children2.length - 1) {
-                results.push(
-                    tracker.move(between(child, children2[index2 + 1], parent, state))
-                );
-            }
-        }
-        indexStack.pop();
-        return results.join("");
-    }
-
-    function between(left2, right2, parent, state) {
-        let index2 = state.join.length;
-        while (index2--) {
-            const result = state.join[index2](left2, right2, parent, state);
-            if (result === true || result === 1) {
-                break;
-            }
-            if (typeof result === "number") {
-                return "\n".repeat(1 + result);
-            }
-            if (result === false) {
-                return "\n\n<!---->\n\n";
-            }
-        }
-        return "\n\n";
-    }
-    const eol = /\r?\n|\r/g;
-
-    function indentLines(value, map2) {
-        const result = [];
-        let start2 = 0;
-        let line = 0;
-        let match2;
-        while (match2 = eol.exec(value)) {
-            one2(value.slice(start2, match2.index));
-            result.push(match2[0]);
-            start2 = match2.index + match2[0].length;
-            line++;
-        }
-        one2(value.slice(start2));
-        return result.join("");
-
-        function one2(value2) {
-            result.push(map2(value2, line, !value2));
-        }
-    }
-
-    function patternCompile(pattern) {
-        if (!pattern._compiled) {
-            const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
-            pattern._compiled = new RegExp(
-                (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
-                "g"
-            );
-        }
-        return pattern._compiled;
-    }
-
-    function patternInScope(stack, pattern) {
-        return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
-    }
-
-    function listInScope(stack, list2, none2) {
-        if (typeof list2 === "string") {
-            list2 = [list2];
-        }
-        if (!list2 || list2.length === 0) {
-            return none2;
-        }
-        let index2 = -1;
-        while (++index2 < list2.length) {
-            if (stack.includes(list2[index2])) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    function safe(state, input, config2) {
-        const value = (config2.before || "") + (input || "") + (config2.after || "");
-        const positions = [];
-        const result = [];
-        const infos = {};
-        let index2 = -1;
-        while (++index2 < state.unsafe.length) {
-            const pattern = state.unsafe[index2];
-            if (!patternInScope(state.stack, pattern)) {
-                continue;
-            }
-            const expression = patternCompile(pattern);
-            let match2;
-            while (match2 = expression.exec(value)) {
-                const before = "before" in pattern || Boolean(pattern.atBreak);
-                const after = "after" in pattern;
-                const position2 = match2.index + (before ? match2[1].length : 0);
-                if (positions.includes(position2)) {
-                    if (infos[position2].before && !before) {
-                        infos[position2].before = false;
-                    }
-                    if (infos[position2].after && !after) {
-                        infos[position2].after = false;
-                    }
-                } else {
-                    positions.push(position2);
-                    infos[position2] = {
-                        before,
-                        after
-                    };
-                }
-            }
-        }
-        positions.sort(numerical);
-        let start2 = config2.before ? config2.before.length : 0;
-        const end2 = value.length - (config2.after ? config2.after.length : 0);
-        index2 = -1;
-        while (++index2 < positions.length) {
-            const position2 = positions[index2];
-            if (position2 < start2 || position2 >= end2) {
-                continue;
-            }
-            if (position2 + 1 < end2 && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
-                continue;
-            }
-            if (start2 !== position2) {
-                result.push(escapeBackslashes(value.slice(start2, position2), "\\"));
-            }
-            start2 = position2;
-            if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config2.encode || !config2.encode.includes(value.charAt(position2)))) {
-                result.push("\\");
-            } else {
-                result.push(
-                    "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
-                );
-                start2++;
-            }
-        }
-        result.push(escapeBackslashes(value.slice(start2, end2), config2.after));
-        return result.join("");
-    }
-
-    function numerical(a2, b2) {
-        return a2 - b2;
-    }
-
-    function escapeBackslashes(value, after) {
-        const expression = /\\(?=[!-/:-@[-`{-~])/g;
-        const positions = [];
-        const results = [];
-        const whole = value + after;
-        let index2 = -1;
-        let start2 = 0;
-        let match2;
-        while (match2 = expression.exec(whole)) {
-            positions.push(match2.index);
-        }
-        while (++index2 < positions.length) {
-            if (start2 !== positions[index2]) {
-                results.push(value.slice(start2, positions[index2]));
-            }
-            results.push("\\");
-            start2 = positions[index2];
-        }
-        results.push(value.slice(start2));
-        return results.join("");
-    }
-
-    function track(config2) {
-        const options = config2 || {};
-        const now2 = options.now || {};
-        let lineShift = options.lineShift || 0;
-        let line = now2.line || 1;
-        let column = now2.column || 1;
-        return {
-            move,
-            current,
-            shift: shift2
-        };
-
-        function current() {
-            return {
-                now: {
-                    line,
-                    column
-                },
-                lineShift
-            };
-        }
-
-        function shift2(value) {
-            lineShift += value;
-        }
-
-        function move(input) {
-            const value = input || "";
-            const chunks = value.split(/\r?\n|\r/g);
-            const tail = chunks[chunks.length - 1];
-            line += chunks.length - 1;
-            column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
-            return value;
-        }
-    }
-    footnoteReference.peek = footnoteReferencePeek;
-
-    function gfmFootnoteFromMarkdown() {
-        return {
-            enter: {
-                gfmFootnoteDefinition: enterFootnoteDefinition,
-                gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
-                gfmFootnoteCall: enterFootnoteCall,
-                gfmFootnoteCallString: enterFootnoteCallString
-            },
-            exit: {
-                gfmFootnoteDefinition: exitFootnoteDefinition,
-                gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
-                gfmFootnoteCall: exitFootnoteCall,
-                gfmFootnoteCallString: exitFootnoteCallString
-            }
-        };
-    }
-
-    function gfmFootnoteToMarkdown() {
-        return {
-            unsafe: [{
-                character: "[",
-                inConstruct: ["phrasing", "label", "reference"]
-            }],
-            handlers: {
-                footnoteDefinition,
-                footnoteReference
-            }
-        };
-    }
-
-    function enterFootnoteDefinition(token) {
-        this.enter({
-                type: "footnoteDefinition",
-                identifier: "",
-                label: "",
-                children: []
-            },
-            token
-        );
-    }
-
-    function enterFootnoteDefinitionLabelString() {
-        this.buffer();
-    }
-
-    function exitFootnoteDefinitionLabelString(token) {
-        const label = this.resume();
-        const node2 = this.stack[this.stack.length - 1];
-        node2.label = label;
-        node2.identifier = normalizeIdentifier(
-            this.sliceSerialize(token)
-        ).toLowerCase();
-    }
-
-    function exitFootnoteDefinition(token) {
-        this.exit(token);
-    }
-
-    function enterFootnoteCall(token) {
-        this.enter({
-            type: "footnoteReference",
-            identifier: "",
-            label: ""
-        }, token);
-    }
-
-    function enterFootnoteCallString() {
-        this.buffer();
-    }
-
-    function exitFootnoteCallString(token) {
-        const label = this.resume();
-        const node2 = this.stack[this.stack.length - 1];
-        node2.label = label;
-        node2.identifier = normalizeIdentifier(
-            this.sliceSerialize(token)
-        ).toLowerCase();
-    }
-
-    function exitFootnoteCall(token) {
-        this.exit(token);
-    }
-
-    function footnoteReference(node2, _2, context2, safeOptions) {
-        const tracker = track(safeOptions);
-        let value = tracker.move("[^");
-        const exit2 = context2.enter("footnoteReference");
-        const subexit = context2.enter("reference");
-        value += tracker.move(
-            safe(context2, association(node2), {
-                ...tracker.current(),
-                before: value,
-                after: "]"
-            })
-        );
-        subexit();
-        exit2();
-        value += tracker.move("]");
-        return value;
-    }
-
-    function footnoteReferencePeek() {
-        return "[";
-    }
-
-    function footnoteDefinition(node2, _2, context2, safeOptions) {
-        const tracker = track(safeOptions);
-        let value = tracker.move("[^");
-        const exit2 = context2.enter("footnoteDefinition");
-        const subexit = context2.enter("label");
-        value += tracker.move(
-            safe(context2, association(node2), {
-                ...tracker.current(),
-                before: value,
-                after: "]"
-            })
-        );
-        subexit();
-        value += tracker.move(
-            "]:" + (node2.children && node2.children.length > 0 ? " " : "")
-        );
-        tracker.shift(4);
-        value += tracker.move(
-            indentLines(containerFlow(node2, context2, tracker.current()), map$2)
-        );
-        exit2();
-        return value;
-    }
-
-    function map$2(line, index2, blank) {
-        if (index2 === 0) {
-            return line;
-        }
-        return (blank ? "" : "    ") + line;
-    }
-
-    function containerPhrasing(parent, state, info) {
-        const indexStack = state.indexStack;
-        const children2 = parent.children || [];
-        const results = [];
-        let index2 = -1;
-        let before = info.before;
-        indexStack.push(-1);
-        let tracker = state.createTracker(info);
-        while (++index2 < children2.length) {
-            const child = children2[index2];
-            let after;
-            indexStack[indexStack.length - 1] = index2;
-            if (index2 + 1 < children2.length) {
-                let handle = state.handle.handlers[children2[index2 + 1].type];
-                if (handle && handle.peek)
-                    handle = handle.peek;
-                after = handle ? handle(children2[index2 + 1], parent, state, {
-                    before: "",
-                    after: "",
-                    ...tracker.current()
-                }).charAt(0) : "";
-            } else {
-                after = info.after;
-            }
-            if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
-                results[results.length - 1] = results[results.length - 1].replace(
-                    /(\r?\n|\r)$/,
-                    " "
-                );
-                before = " ";
-                tracker = state.createTracker(info);
-                tracker.move(results.join(""));
-            }
-            results.push(
-                tracker.move(
-                    state.handle(child, parent, state, {
-                        ...tracker.current(),
-                        before,
-                        after
-                    })
-                )
-            );
-            before = results[results.length - 1].slice(-1);
-        }
-        indexStack.pop();
-        return results.join("");
-    }
-    const constructsWithoutStrikethrough = [
-        "autolink",
-        "destinationLiteral",
-        "destinationRaw",
-        "reference",
-        "titleQuote",
-        "titleApostrophe"
-    ];
-    handleDelete.peek = peekDelete;
-    const gfmStrikethroughFromMarkdown = {
-        canContainEols: ["delete"],
-        enter: {
-            strikethrough: enterStrikethrough
-        },
-        exit: {
-            strikethrough: exitStrikethrough
-        }
-    };
-    const gfmStrikethroughToMarkdown = {
-        unsafe: [{
-            character: "~",
-            inConstruct: "phrasing",
-            notInConstruct: constructsWithoutStrikethrough
-        }],
-        handlers: {
-            delete: handleDelete
-        }
-    };
-
-    function enterStrikethrough(token) {
-        this.enter({
-            type: "delete",
-            children: []
-        }, token);
-    }
-
-    function exitStrikethrough(token) {
-        this.exit(token);
-    }
-
-    function handleDelete(node2, _2, context2, safeOptions) {
-        const tracker = track(safeOptions);
-        const exit2 = context2.enter("strikethrough");
-        let value = tracker.move("~~");
-        value += containerPhrasing(node2, context2, {
-            ...tracker.current(),
-            before: value,
-            after: "~"
-        });
-        value += tracker.move("~~");
-        exit2();
-        return value;
-    }
-
-    function peekDelete() {
-        return "~";
-    }
-    inlineCode.peek = inlineCodePeek;
-
-    function inlineCode(node2, _2, state) {
-        let value = node2.value || "";
-        let sequence = "`";
-        let index2 = -1;
-        while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
-            sequence += "`";
-        }
-        if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
-            value = " " + value + " ";
-        }
-        while (++index2 < state.unsafe.length) {
-            const pattern = state.unsafe[index2];
-            const expression = patternCompile(pattern);
-            let match2;
-            if (!pattern.atBreak)
-                continue;
-            while (match2 = expression.exec(value)) {
-                let position2 = match2.index;
-                if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
-                    position2--;
-                }
-                value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
-            }
-        }
-        return sequence + value + sequence;
-    }
-
-    function inlineCodePeek() {
-        return "`";
-    }
-
-    function markdownTable(table2, options = {}) {
-        const align = (options.align || []).concat();
-        const stringLength = options.stringLength || defaultStringLength;
-        const alignments = [];
-        const cellMatrix = [];
-        const sizeMatrix = [];
-        const longestCellByColumn = [];
-        let mostCellsPerRow = 0;
-        let rowIndex = -1;
-        while (++rowIndex < table2.length) {
-            const row2 = [];
-            const sizes2 = [];
-            let columnIndex2 = -1;
-            if (table2[rowIndex].length > mostCellsPerRow) {
-                mostCellsPerRow = table2[rowIndex].length;
-            }
-            while (++columnIndex2 < table2[rowIndex].length) {
-                const cell = serialize(table2[rowIndex][columnIndex2]);
-                if (options.alignDelimiters !== false) {
-                    const size = stringLength(cell);
-                    sizes2[columnIndex2] = size;
-                    if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
-                        longestCellByColumn[columnIndex2] = size;
-                    }
-                }
-                row2.push(cell);
-            }
-            cellMatrix[rowIndex] = row2;
-            sizeMatrix[rowIndex] = sizes2;
-        }
-        let columnIndex = -1;
-        if (typeof align === "object" && "length" in align) {
-            while (++columnIndex < mostCellsPerRow) {
-                alignments[columnIndex] = toAlignment(align[columnIndex]);
-            }
-        } else {
-            const code2 = toAlignment(align);
-            while (++columnIndex < mostCellsPerRow) {
-                alignments[columnIndex] = code2;
-            }
-        }
-        columnIndex = -1;
-        const row = [];
-        const sizes = [];
-        while (++columnIndex < mostCellsPerRow) {
-            const code2 = alignments[columnIndex];
-            let before = "";
-            let after = "";
-            if (code2 === 99) {
-                before = ":";
-                after = ":";
-            } else if (code2 === 108) {
-                before = ":";
-            } else if (code2 === 114) {
-                after = ":";
-            }
-            let size = options.alignDelimiters === false ? 1 : Math.max(
-                1,
-                longestCellByColumn[columnIndex] - before.length - after.length
-            );
-            const cell = before + "-".repeat(size) + after;
-            if (options.alignDelimiters !== false) {
-                size = before.length + size + after.length;
-                if (size > longestCellByColumn[columnIndex]) {
-                    longestCellByColumn[columnIndex] = size;
-                }
-                sizes[columnIndex] = size;
-            }
-            row[columnIndex] = cell;
-        }
-        cellMatrix.splice(1, 0, row);
-        sizeMatrix.splice(1, 0, sizes);
-        rowIndex = -1;
-        const lines = [];
-        while (++rowIndex < cellMatrix.length) {
-            const row2 = cellMatrix[rowIndex];
-            const sizes2 = sizeMatrix[rowIndex];
-            columnIndex = -1;
-            const line = [];
-            while (++columnIndex < mostCellsPerRow) {
-                const cell = row2[columnIndex] || "";
-                let before = "";
-                let after = "";
-                if (options.alignDelimiters !== false) {
-                    const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
-                    const code2 = alignments[columnIndex];
-                    if (code2 === 114) {
-                        before = " ".repeat(size);
-                    } else if (code2 === 99) {
-                        if (size % 2) {
-                            before = " ".repeat(size / 2 + 0.5);
-                            after = " ".repeat(size / 2 - 0.5);
-                        } else {
-                            before = " ".repeat(size / 2);
-                            after = before;
-                        }
-                    } else {
-                        after = " ".repeat(size);
-                    }
-                }
-                if (options.delimiterStart !== false && !columnIndex) {
-                    line.push("|");
-                }
-                if (options.padding !== false && !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
-                    line.push(" ");
-                }
-                if (options.alignDelimiters !== false) {
-                    line.push(before);
-                }
-                line.push(cell);
-                if (options.alignDelimiters !== false) {
-                    line.push(after);
-                }
-                if (options.padding !== false) {
-                    line.push(" ");
-                }
-                if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
-                    line.push("|");
-                }
-            }
-            lines.push(
-                options.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
-            );
-        }
-        return lines.join("\n");
-    }
-
-    function serialize(value) {
-        return value === null || value === void 0 ? "" : String(value);
-    }
-
-    function defaultStringLength(value) {
-        return value.length;
-    }
-
-    function toAlignment(value) {
-        const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
-        return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
-    }
-    const gfmTableFromMarkdown = {
-        enter: {
-            table: enterTable,
-            tableData: enterCell,
-            tableHeader: enterCell,
-            tableRow: enterRow
-        },
-        exit: {
-            codeText: exitCodeText,
-            table: exitTable,
-            tableData: exit,
-            tableHeader: exit,
-            tableRow: exit
-        }
-    };
-
-    function enterTable(token) {
-        const align = token._align;
-        this.enter({
-                type: "table",
-                align: align.map((d2) => d2 === "none" ? null : d2),
-                children: []
-            },
-            token
-        );
-        this.setData("inTable", true);
-    }
-
-    function exitTable(token) {
-        this.exit(token);
-        this.setData("inTable");
-    }
-
-    function enterRow(token) {
-        this.enter({
-            type: "tableRow",
-            children: []
-        }, token);
-    }
-
-    function exit(token) {
-        this.exit(token);
-    }
-
-    function enterCell(token) {
-        this.enter({
-            type: "tableCell",
-            children: []
-        }, token);
-    }
-
-    function exitCodeText(token) {
-        let value = this.resume();
-        if (this.getData("inTable")) {
-            value = value.replace(/\\([\\|])/g, replace$1);
-        }
-        const node2 = this.stack[this.stack.length - 1];
-        node2.value = value;
-        this.exit(token);
-    }
-
-    function replace$1($0, $1) {
-        return $1 === "|" ? $1 : $0;
-    }
-
-    function gfmTableToMarkdown(options) {
-        const settings2 = options || {};
-        const padding = settings2.tableCellPadding;
-        const alignDelimiters = settings2.tablePipeAlign;
-        const stringLength = settings2.stringLength;
-        const around = padding ? " " : "|";
-        return {
-            unsafe: [{
-                character: "\r",
-                inConstruct: "tableCell"
-            }, {
-                character: "\n",
-                inConstruct: "tableCell"
-            }, {
-                atBreak: true,
-                character: "|",
-                after: "[	 :-]"
-            }, {
-                character: "|",
-                inConstruct: "tableCell"
-            }, {
-                atBreak: true,
-                character: ":",
-                after: "-"
-            }, {
-                atBreak: true,
-                character: "-",
-                after: "[:|-]"
-            }],
-            handlers: {
-                table: handleTable,
-                tableRow: handleTableRow,
-                tableCell: handleTableCell,
-                inlineCode: inlineCodeWithTable
-            }
-        };
-
-        function handleTable(node2, _2, context2, safeOptions) {
-            return serializeData(
-                handleTableAsData(node2, context2, safeOptions),
-                node2.align
-            );
-        }
-
-        function handleTableRow(node2, _2, context2, safeOptions) {
-            const row = handleTableRowAsData(node2, context2, safeOptions);
-            const value = serializeData([row]);
-            return value.slice(0, value.indexOf("\n"));
-        }
-
-        function handleTableCell(node2, _2, context2, safeOptions) {
-            const exit2 = context2.enter("tableCell");
-            const subexit = context2.enter("phrasing");
-            const value = containerPhrasing(node2, context2, {
-                ...safeOptions,
-                before: around,
-                after: around
-            });
-            subexit();
-            exit2();
-            return value;
-        }
-
-        function serializeData(matrix, align) {
-            return markdownTable(matrix, {
-                align,
-                alignDelimiters,
-                padding,
-                stringLength
-            });
-        }
-
-        function handleTableAsData(node2, context2, safeOptions) {
-            const children2 = node2.children;
-            let index2 = -1;
-            const result = [];
-            const subexit = context2.enter("table");
-            while (++index2 < children2.length) {
-                result[index2] = handleTableRowAsData(
-                    children2[index2],
-                    context2,
-                    safeOptions
-                );
-            }
-            subexit();
-            return result;
-        }
-
-        function handleTableRowAsData(node2, context2, safeOptions) {
-            const children2 = node2.children;
-            let index2 = -1;
-            const result = [];
-            const subexit = context2.enter("tableRow");
-            while (++index2 < children2.length) {
-                result[index2] = handleTableCell(
-                    children2[index2],
-                    node2,
-                    context2,
-                    safeOptions
-                );
-            }
-            subexit();
-            return result;
-        }
-
-        function inlineCodeWithTable(node2, parent, context2) {
-            let value = inlineCode(node2, parent, context2);
-            if (context2.stack.includes("tableCell")) {
-                value = value.replace(/\|/g, "\\$&");
-            }
-            return value;
-        }
-    }
-
-    function checkBullet(state) {
-        const marker = state.options.bullet || "*";
-        if (marker !== "*" && marker !== "+" && marker !== "-") {
-            throw new Error(
-                "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
-            );
-        }
-        return marker;
-    }
-
-    function checkListItemIndent(state) {
-        const style2 = state.options.listItemIndent || "tab";
-        if (style2 === 1 || style2 === "1") {
-            return "one";
-        }
-        if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
-            throw new Error(
-                "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
-            );
-        }
-        return style2;
-    }
-
-    function listItem(node2, parent, state, info) {
-        const listItemIndent = checkListItemIndent(state);
-        let bullet = state.bulletCurrent || checkBullet(state);
-        if (parent && parent.type === "list" && parent.ordered) {
-            bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
-        }
-        let size = bullet.length + 1;
-        if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
-            size = Math.ceil(size / 4) * 4;
-        }
-        const tracker = state.createTracker(info);
-        tracker.move(bullet + " ".repeat(size - bullet.length));
-        tracker.shift(size);
-        const exit2 = state.enter("listItem");
-        const value = state.indentLines(
-            state.containerFlow(node2, tracker.current()),
-            map2
-        );
-        exit2();
-        return value;
-
-        function map2(line, index2, blank) {
-            if (index2) {
-                return (blank ? "" : " ".repeat(size)) + line;
-            }
-            return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
-        }
-    }
-    const gfmTaskListItemFromMarkdown = {
-        exit: {
-            taskListCheckValueChecked: exitCheck,
-            taskListCheckValueUnchecked: exitCheck,
-            paragraph: exitParagraphWithTaskListItem
-        }
-    };
-    const gfmTaskListItemToMarkdown = {
-        unsafe: [{
-            atBreak: true,
-            character: "-",
-            after: "[:|-]"
-        }],
-        handlers: {
-            listItem: listItemWithTaskListItem
-        }
-    };
-
-    function exitCheck(token) {
-        const node2 = this.stack[this.stack.length - 2];
-        node2.checked = token.type === "taskListCheckValueChecked";
-    }
-
-    function exitParagraphWithTaskListItem(token) {
-        const parent = this.stack[this.stack.length - 2];
-        if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
-            const node2 = this.stack[this.stack.length - 1];
-            const head = node2.children[0];
-            if (head && head.type === "text") {
-                const siblings = parent.children;
-                let index2 = -1;
-                let firstParaghraph;
-                while (++index2 < siblings.length) {
-                    const sibling = siblings[index2];
-                    if (sibling.type === "paragraph") {
-                        firstParaghraph = sibling;
-                        break;
-                    }
-                }
-                if (firstParaghraph === node2) {
-                    head.value = head.value.slice(1);
-                    if (head.value.length === 0) {
-                        node2.children.shift();
-                    } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
-                        head.position.start.column++;
-                        head.position.start.offset++;
-                        node2.position.start = Object.assign({}, head.position.start);
-                    }
-                }
-            }
-        }
-        this.exit(token);
-    }
-
-    function listItemWithTaskListItem(node2, parent, context2, safeOptions) {
-        const head = node2.children[0];
-        const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
-        const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
-        const tracker = track(safeOptions);
-        if (checkable) {
-            tracker.move(checkbox);
-        }
-        let value = listItem(node2, parent, context2, {
-            ...safeOptions,
-            ...tracker.current()
-        });
-        if (checkable) {
-            value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
-        }
-        return value;
-
-        function check($0) {
-            return $0 + checkbox;
-        }
-    }
-
-    function gfmFromMarkdown() {
-        return [
-            gfmAutolinkLiteralFromMarkdown,
-            gfmFootnoteFromMarkdown(),
-            gfmStrikethroughFromMarkdown,
-            gfmTableFromMarkdown,
-            gfmTaskListItemFromMarkdown
-        ];
-    }
-
-    function gfmToMarkdown(options) {
-        return {
-            extensions: [
-                gfmAutolinkLiteralToMarkdown,
-                gfmFootnoteToMarkdown(),
-                gfmStrikethroughToMarkdown,
-                gfmTableToMarkdown(options),
-                gfmTaskListItemToMarkdown
-            ]
-        };
-    }
-
-    function remarkGfm(options = {}) {
-        const data2 = this.data();
-        add2("micromarkExtensions", gfm(options));
-        add2("fromMarkdownExtensions", gfmFromMarkdown());
-        add2("toMarkdownExtensions", gfmToMarkdown(options));
-
-        function add2(field, value) {
-            const list2 = data2[field] ? data2[field] : data2[field] = [];
-            list2.push(value);
-        }
+    function remarkGfm(options) {
+        const self2 = this;
+        const settings2 = options || emptyOptions;
+        const data2 = self2.data();
+        const micromarkExtensions = data2.micromarkExtensions || (data2.micromarkExtensions = []);
+        const fromMarkdownExtensions = data2.fromMarkdownExtensions || (data2.fromMarkdownExtensions = []);
+        const toMarkdownExtensions = data2.toMarkdownExtensions || (data2.toMarkdownExtensions = []);
+        micromarkExtensions.push(gfm(settings2));
+        fromMarkdownExtensions.push(gfmFromMarkdown());
+        toMarkdownExtensions.push(gfmToMarkdown(settings2));
     }
     const _CustomMarkdown = styled__default.default.div`
     /*
      * Apply some base styles to the markdown content so it looks good by default
      * Inspired by https://tailwindcss.com/docs/typography-plugin
     */
     p {
@@ -71061,22 +71910,22 @@
         if (props.html_raw) {
             rehypePlugins.push(rehypeRaw);
         }
         return /* @__PURE__ */ React__default.default.createElement(CustomMarkdown, {
             $rawCss: css2,
             className: props.className,
             style: style2
-        }, /* @__PURE__ */ React__default.default.createElement(ReactMarkdown, {
+        }, /* @__PURE__ */ React__default.default.createElement(Markdown$1, {
             rehypePlugins,
             remarkPlugins: [remarkGfm]
         }, markdown));
     }
-    const StyledModal = core$2.injectCss(Modal$1);
+    const StyledModal = core$2.injectCss(Modal$2);
 
-    function Modal(props) {
+    function Modal$1(props) {
         const [style2, css2] = core$2.useComponentStyles(props, false);
         const [show, setShow] = core$2.useVariable(props.show);
 
         function onAttemptClose() {
             setShow(false);
         }
         return /* @__PURE__ */ React__default.default.createElement(
@@ -71319,15 +72168,15 @@
             margin-left: ${getMarginLeft(widths.xl, offsets == null ? void 0 : offsets.xl, columnGap)}%
         }
     `;
     }
     const StyledRow = core$2.injectCss(RowComponent);
     const StyledColumn = core$2.injectCss("div");
 
-    function Row(props) {
+    function Row$1(props) {
         const [style2, css2] = core$2.useComponentStyles(props);
         const childrenWithOffset = React.useMemo(
             () => props.children.flatMap((child) => {
                 var _a3, _b;
                 const childWithOffset = [child];
                 if ((_a3 = child.props) == null ? void 0 : _a3.offset) {
                     const offset_child = {
@@ -71419,32 +72268,32 @@
             const stringOfValues = values.map((value) => String(value));
             if (stringOfValues.includes(String(item.value))) {
                 return [...acc, item];
             }
             return acc;
         }, []);
     }
-    const StyledSelect = core$2.injectCss(Select$1);
+    const StyledSelect$2 = core$2.injectCss(Select$2);
     const StyledMultiSelect = core$2.injectCss(MultiSelect);
     const StyledComboBox = core$2.injectCss(ComboBox);
-    const StyledSectionedList = core$2.injectCss(SectionedList);
+    const StyledSectionedList = core$2.injectCss(SectionedList$1);
 
     function hasListSection(items) {
         return items.length > 0 && "items" in items[0];
     }
 
     function isStringArray(value) {
         return Array.isArray(value) && value.every((item) => typeof item === "string");
     }
 
     function isItem(obj) {
         return obj && Object.prototype.hasOwnProperty.call(obj, "value");
     }
 
-    function Select(props) {
+    function Select$1(props) {
         var _a3;
         const formCtx2 = useFormContext(props);
         const [items] = core$2.useVariable(props.items);
         const [style2, css2] = core$2.useComponentStyles(props);
         const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
         const formattedItems = React.useMemo(() => {
             if (isStringArray(items)) {
@@ -71568,15 +72417,15 @@
                     placeholder: props.placeholder,
                     selectedItem,
                     style: style2
                 }
             );
         }
         return /* @__PURE__ */ React__default.default.createElement(
-            StyledSelect, {
+            StyledSelect$2, {
                 $rawCss: css2,
                 className: props.className,
                 items: itemArray,
                 onSelect,
                 placeholder: props.placeholder,
                 selectedItem,
                 style: style2
@@ -71726,15 +72575,15 @@
     display: flex;
     flex-direction: row;
     align-items: center;
     margin: 0.5rem 0;
 `;
     const SwitchDiv = core$2.injectCss(_SwitchDiv);
 
-    function Switch(props) {
+    function Switch$1(props) {
         const formCtx2 = useFormContext(props);
         const [style2, css2] = core$2.useComponentStyles(props);
         const [value, setValue] = core$2.useVariable(formCtx2.resolveInitialValue());
         const [onChangeAction] = core$2.useAction(props.onchange);
 
         function onChange2(enabled) {
             setValue(enabled);
@@ -71797,15 +72646,15 @@
         const [selectedCard, setSelectedCard] = React.useState(getCardBody(props.children, selectedTab.title));
         React.useEffect(() => {
             const updatedSelectedTab = getTabHeader(props.children, selectedTabFromVar || props.initial_tab);
             if (updatedSelectedTab !== selectedTab) {
                 setSelectedTab(updatedSelectedTab);
                 setSelectedCard(getCardBody(props.children, updatedSelectedTab.title));
             }
-        }, [selectedTabFromVar, useDeepCompare(props.children)]);
+        }, [selectedTabFromVar, useDeepCompare$1(props.children)]);
         const tabs = props.children.map((tab2) => mapTabProps(tab2));
         const onSelectTab = (tab2) => {
             setSelectedTabFromVar(tab2.title);
             setSelectedTab(tab2);
             setSelectedCard(getCardBody(props.children, tab2.title));
         };
         return /* @__PURE__ */ React__default.default.createElement(TabbedCardWrapper, {
@@ -71856,15 +72705,15 @@
         };
     }
 
     function BadgeFormattedCell(badges) {
         function FormattedBadge({
             value
         }) {
-            return badges[value] ? /* @__PURE__ */ React__default.default.createElement(Badge, {
+            return badges[value] ? /* @__PURE__ */ React__default.default.createElement(Badge$1, {
                 color: badges[value].color,
                 width: "100%"
             }, badges[value].label) : /* @__PURE__ */ React__default.default.createElement("span", null, value);
         }
         return FormattedBadge;
     }
 
@@ -72046,15 +72895,15 @@
         if (formatter.type === "code") {
             return CodeCell(formatter.language);
         }
         if (formatter.type === "compare") {
             return CompareCell(formatter.condition, formatter.target);
         }
         if (formatter.type === "datetime") {
-            return Table$1.cells.DATETIME(formatter.format);
+            return Table$2.cells.DATETIME(formatter.format);
         }
         if (formatter.type === "formatted_text") {
             return FormattedTextCell();
         }
         if (formatter.type === "number") {
             return NumberCell(formatter.precision);
         }
@@ -72205,15 +73054,15 @@
             throw new Error(
                 "Columns could not be rendered, check that your data is correct and columns are passed as a List"
             );
         });
     }
     const TableWrapper = core$2.injectCss("div");
 
-    function Table(props) {
+    function Table$1(props) {
         const [searchQuery, setSearchQuery2] = React.useState(null);
         const getData = core$2.useDataVariable(props.data);
         const [selectedRowIndices, setSelectedRowIndices] = core$2.useVariable(props.selected_indices);
         const [columnsProp] = core$2.useVariable(props.columns);
         const [resolvedColumns, setResolvedColumns] = React.useState(null);
         React.useEffect(() => {
             if (columnsProp) {
@@ -72228,16 +73077,16 @@
                 const columnsWithoutIndex = columns2.filter((col) => col !== "__index__");
                 setResolvedColumns(getColumnProps(columnsWithoutIndex));
             }).catch((err) => {
                 throw new Error(err);
             });
         }, [columnsProp, getData]);
         const debouncedSetSearchQuery = React.useMemo(() => debounce_1(setSearchQuery2, 500), [setSearchQuery2]);
-        const [sortingRules, setSortingRules] = useThrottledState([], 300);
-        const [filters2, setFilters] = useThrottledState([], 500);
+        const [sortingRules, setSortingRules] = useThrottledState$1([], 300);
+        const [filters2, setFilters] = useThrottledState$1([], 500);
         const datetimeColumns = React.useMemo(() => getDatetimeColumns(resolvedColumns), [resolvedColumns]);
         const fetchData = React.useCallback(
             async (startIndex, stopIndex, index2) => {
                     const response = await getData(core$2.combineFilters("AND", [filtersToFilterQuery(filters2), searchQuery]), {
                         index: index2,
                         limit: stopIndex !== void 0 && startIndex !== void 0 ? stopIndex - startIndex : void 0,
                         offset: startIndex !== void 0 ? startIndex : void 0,
@@ -72278,15 +73127,15 @@
             extraDataCache.current = {};
         }, [getData]);
         const [style2, css2] = core$2.useComponentStyles(props);
         const [onClickRow] = core$2.useAction(props.onclick_row);
         const columns = React.useMemo(() => {
             const mappedCols = mapColumns(resolvedColumns);
             if (props.show_checkboxes && props.onclick_row || props.selected_indices) {
-                mappedCols == null ? void 0 : mappedCols.unshift(Table$1.ActionColumn([Table$1.Actions.SELECT], "select_box_col", "left", true));
+                mappedCols == null ? void 0 : mappedCols.unshift(Table$2.ActionColumn([Table$2.Actions.SELECT], "select_box_col", "left", true));
             }
             return mappedCols;
         }, [resolvedColumns, props.onclick_row]);
         const onSelect = React.useCallback(
             async (row) => {
                     if ((selectedRowIndices != null ? selectedRowIndices : []).find((idx) => row[INDEX_COL] === idx) !== void 0) {
                         const newSelectedIndices = (selectedRowIndices != null ? selectedRowIndices : []).filter((idx) => row[INDEX_COL] !== idx);
@@ -72307,15 +73156,15 @@
                         onClickRow(cleanIndex(selectedRows));
                     }
                 },
                 [selectedRowIndices, getItem]
         );
         const onAction = React.useCallback(
             (actionId, row) => {
-                if (actionId === Table$1.Actions.SELECT.id) {
+                if (actionId === Table$2.Actions.SELECT.id) {
                     onSelect(row);
                 }
             },
             [onSelect]
         );
         const searchColumns = React.useMemo(() => {
             if (props.search_columns) {
@@ -72368,15 +73217,15 @@
                     flexDirection: "column",
                     minHeight: props.searchable ? "9rem" : "6rem",
                     overflow: "auto",
                     position: "relative",
                     ...style2
                 }
             },
-            props.searchable && /* @__PURE__ */ React__default.default.createElement(TableSearch, null, /* @__PURE__ */ React__default.default.createElement(Input$3, {
+            props.searchable && /* @__PURE__ */ React__default.default.createElement(TableSearch, null, /* @__PURE__ */ React__default.default.createElement(Input$5, {
                 onChange: onSearchChange,
                 placeholder: "Search Table..."
             })),
             resolvedColumns && /* @__PURE__ */ React__default.default.createElement(
                 "div", {
                     style: {
                         bottom: 0,
@@ -72387,15 +73236,15 @@
                         right: 0,
                         top: props.searchable ? "3rem" : 0,
                         width: "calc(100% - 1px)"
                     }
                 },
                 /* @__PURE__ */
                 React__default.default.createElement(
-                    Table$1, {
+                    Table$2, {
                         columns,
                         getItem: getItemWithSelected,
                         itemCount: totalCount,
                         maxRows: props.max_rows,
                         onAction,
                         onClickRow: props.onclick_row && onSelect,
                         onFilter,
@@ -72412,15 +73261,15 @@
     const StyledSpan = core$2.injectCss("span");
     const StyledTag = core$2.injectCss("div");
 
     function Text$2(props) {
         var _a3;
         const [style2, css2] = core$2.useComponentStyles(props);
         const [text2] = core$2.useVariable(props.text);
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const display_ctx = React.useContext(core$2.DisplayCtx);
         const color2 = ["anchor", "button"].includes(display_ctx.component) ? props.color : props.color || theme2.colors.text;
         if (["anchor", "paragraph"].includes(display_ctx.component)) {
             return /* @__PURE__ */ React__default.default.createElement(
                 StyledSpan, {
                     $rawCss: css2,
                     className: props.className,
@@ -72485,17 +73334,17 @@
                 onChange: handleChange,
                 resize: props.resize,
                 style: style2,
                 value: internalValue
             }
         );
     }
-    const StyledTooltip = core$2.injectCss(Tooltip$1);
+    const StyledTooltip = core$2.injectCss(Tooltip$2);
 
-    function Tooltip(props) {
+    function Tooltip$1(props) {
         const [styles2, css2] = core$2.useComponentStyles(props);
         const [content2] = core$2.useVariable(props.content);
         return /* @__PURE__ */ React__default.default.createElement(
             StyledTooltip, {
                 $rawCss: css2,
                 content: typeof content2 === "string" ? content2 : /* @__PURE__ */ React__default.default.createElement(core$2.DynamicComponent, {
                     component: content2,
@@ -74591,34 +75440,34 @@
                             }
                             scene.fullLayout._infolayer.selectAll(".annotation-" + scene.id).remove();
                         };
 
                         function mockAnnAxes(ann, scene) {
                             var fullSceneLayout = scene.fullSceneLayout;
                             var domain2 = fullSceneLayout.domain;
-                            var size = scene.fullLayout._size;
+                            var size2 = scene.fullLayout._size;
                             var base2 = {
                                 pdata: null,
                                 type: "linear",
                                 autorange: false,
                                 range: [-Infinity, Infinity]
                             };
                             ann._xa = {};
                             Lib.extendFlat(ann._xa, base2);
                             Axes.setConvert(ann._xa);
-                            ann._xa._offset = size.l + domain2.x[0] * size.w;
+                            ann._xa._offset = size2.l + domain2.x[0] * size2.w;
                             ann._xa.l2p = function() {
-                                return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain2.x[1] - domain2.x[0]);
+                                return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size2.w * (domain2.x[1] - domain2.x[0]);
                             };
                             ann._ya = {};
                             Lib.extendFlat(ann._ya, base2);
                             Axes.setConvert(ann._ya);
-                            ann._ya._offset = size.t + (1 - domain2.y[1]) * size.h;
+                            ann._ya._offset = size2.t + (1 - domain2.y[1]) * size2.h;
                             ann._ya.l2p = function() {
-                                return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain2.y[1] - domain2.y[0]);
+                                return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size2.h * (domain2.y[1] - domain2.y[0]);
                             };
                         }
                     },
                     20226: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var Lib = __webpack_require__2(71828);
                         var Axes = __webpack_require__2(89298);
                         var handleArrayContainerDefaults = __webpack_require__2(85501);
@@ -77283,24 +78132,24 @@
                         var alignment = __webpack_require__2(18783);
                         var LINE_SPACING = alignment.LINE_SPACING;
                         var DESELECTDIM = __webpack_require__2(37822).DESELECTDIM;
                         var subTypes = __webpack_require__2(34098);
                         var makeBubbleSizeFn = __webpack_require__2(39984);
                         var appendArrayPointValue = __webpack_require__2(23469).appendArrayPointValue;
                         var drawing = module3.exports = {};
-                        drawing.font = function(s2, family, size, color2) {
+                        drawing.font = function(s2, family, size2, color2) {
                             if (Lib.isPlainObject(family)) {
                                 color2 = family.color;
-                                size = family.size;
+                                size2 = family.size;
                                 family = family.family;
                             }
                             if (family)
                                 s2.style("font-family", family);
-                            if (size + 1)
-                                s2.style("font-size", size + "px");
+                            if (size2 + 1)
+                                s2.style("font-size", size2 + "px");
                             if (color2)
                                 s2.call(Color2.fill, color2);
                         };
                         drawing.setPosition = function(s2, x2, y2) {
                             s2.attr("x", x2).attr("y", y2);
                         };
                         drawing.setSize = function(s2, w2, h2) {
@@ -77553,15 +78402,15 @@
                                         "stop-opacity": tc.getAlpha()
                                     });
                                 });
                             });
                             sel.style(prop, getFullUrl(fullID, gd)).style(prop + "-opacity", null);
                             sel.classed("gradient_filled", true);
                         };
-                        drawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {
+                        drawing.pattern = function(sel, calledBy, gd, patternID, shape, size2, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {
                             var isLegend = calledBy === "legend";
                             if (mcc) {
                                 if (fillmode === "overlay") {
                                     bgcolor = mcc;
                                     fgcolor = Color2.contrast(bgcolor);
                                 } else {
                                     bgcolor = void 0;
@@ -77579,113 +78428,113 @@
                             var patternAttrs = {};
                             var fgC = tinycolor(fgcolor);
                             var fgRGB = Color2.tinyRGB(fgC);
                             var fgAlpha = fgC.getAlpha();
                             var opacity = fgopacity * fgAlpha;
                             switch (shape) {
                                 case "/":
-                                    width = size * Math.sqrt(2);
-                                    height = size * Math.sqrt(2);
+                                    width = size2 * Math.sqrt(2);
+                                    height = size2 * Math.sqrt(2);
                                     path2 = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2;
-                                    linewidth = solidity * size;
+                                    linewidth = solidity * size2;
                                     patternTag = "path";
                                     patternAttrs = {
                                         d: path2,
                                         opacity,
                                         stroke: fgRGB,
                                         "stroke-width": linewidth + "px"
                                     };
                                     break;
                                 case "\\":
-                                    width = size * Math.sqrt(2);
-                                    height = size * Math.sqrt(2);
+                                    width = size2 * Math.sqrt(2);
+                                    height = size2 * Math.sqrt(2);
                                     path2 = "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
-                                    linewidth = solidity * size;
+                                    linewidth = solidity * size2;
                                     patternTag = "path";
                                     patternAttrs = {
                                         d: path2,
                                         opacity,
                                         stroke: fgRGB,
                                         "stroke-width": linewidth + "px"
                                     };
                                     break;
                                 case "x":
-                                    width = size * Math.sqrt(2);
-                                    height = size * Math.sqrt(2);
+                                    width = size2 * Math.sqrt(2);
+                                    height = size2 * Math.sqrt(2);
                                     path2 = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2 + "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
-                                    linewidth = size - size * Math.sqrt(1 - solidity);
+                                    linewidth = size2 - size2 * Math.sqrt(1 - solidity);
                                     patternTag = "path";
                                     patternAttrs = {
                                         d: path2,
                                         opacity,
                                         stroke: fgRGB,
                                         "stroke-width": linewidth + "px"
                                     };
                                     break;
                                 case "|":
-                                    width = size;
-                                    height = size;
+                                    width = size2;
+                                    height = size2;
                                     patternTag = "path";
                                     path2 = "M" + width / 2 + ",0L" + width / 2 + "," + height;
-                                    linewidth = solidity * size;
+                                    linewidth = solidity * size2;
                                     patternTag = "path";
                                     patternAttrs = {
                                         d: path2,
                                         opacity,
                                         stroke: fgRGB,
                                         "stroke-width": linewidth + "px"
                                     };
                                     break;
                                 case "-":
-                                    width = size;
-                                    height = size;
+                                    width = size2;
+                                    height = size2;
                                     patternTag = "path";
                                     path2 = "M0," + height / 2 + "L" + width + "," + height / 2;
-                                    linewidth = solidity * size;
+                                    linewidth = solidity * size2;
                                     patternTag = "path";
                                     patternAttrs = {
                                         d: path2,
                                         opacity,
                                         stroke: fgRGB,
                                         "stroke-width": linewidth + "px"
                                     };
                                     break;
                                 case "+":
-                                    width = size;
-                                    height = size;
+                                    width = size2;
+                                    height = size2;
                                     patternTag = "path";
                                     path2 = "M" + width / 2 + ",0L" + width / 2 + "," + height + "M0," + height / 2 + "L" + width + "," + height / 2;
-                                    linewidth = size - size * Math.sqrt(1 - solidity);
+                                    linewidth = size2 - size2 * Math.sqrt(1 - solidity);
                                     patternTag = "path";
                                     patternAttrs = {
                                         d: path2,
                                         opacity,
                                         stroke: fgRGB,
                                         "stroke-width": linewidth + "px"
                                     };
                                     break;
                                 case ".":
-                                    width = size;
-                                    height = size;
+                                    width = size2;
+                                    height = size2;
                                     if (solidity < Math.PI / 4) {
-                                        radius = Math.sqrt(solidity * size * size / Math.PI);
+                                        radius = Math.sqrt(solidity * size2 * size2 / Math.PI);
                                     } else {
-                                        radius = linearFn(solidity, Math.PI / 4, 1, size / 2, size / Math.sqrt(2));
+                                        radius = linearFn(solidity, Math.PI / 4, 1, size2 / 2, size2 / Math.sqrt(2));
                                     }
                                     patternTag = "circle";
                                     patternAttrs = {
                                         cx: width / 2,
                                         cy: height / 2,
                                         r: radius,
                                         opacity,
                                         fill: fgRGB
                                     };
                                     break;
                             }
-                            var str = [shape || "noSh", bgcolor || "noBg", fgcolor || "noFg", size, solidity].join(";");
+                            var str = [shape || "noSh", bgcolor || "noBg", fgcolor || "noFg", size2, solidity].join(";");
                             var pattern = fullLayout._defs.select(".patterns").selectAll("#" + fullID).data([str], Lib.identity);
                             pattern.exit().remove();
                             pattern.enter().append("pattern").each(function() {
                                 var el = d3.select(this);
                                 el.attr({
                                     id: fullID,
                                     width: width + "px",
@@ -82425,40 +83274,40 @@
 
                             function applyAttributes(d2) {
                                 var thisImage = d3.select(this);
                                 var xa = Axes.getFromId(gd, d2.xref);
                                 var ya = Axes.getFromId(gd, d2.yref);
                                 var xIsDomain = Axes.getRefType(d2.xref) === "domain";
                                 var yIsDomain = Axes.getRefType(d2.yref) === "domain";
-                                var size = fullLayout._size;
+                                var size2 = fullLayout._size;
                                 var width, height;
                                 if (xa !== void 0) {
                                     width = typeof d2.xref === "string" && xIsDomain ? xa._length * d2.sizex : Math.abs(xa.l2p(d2.sizex) - xa.l2p(0));
                                 } else {
-                                    width = d2.sizex * size.w;
+                                    width = d2.sizex * size2.w;
                                 }
                                 if (ya !== void 0) {
                                     height = typeof d2.yref === "string" && yIsDomain ? ya._length * d2.sizey : Math.abs(ya.l2p(d2.sizey) - ya.l2p(0));
                                 } else {
-                                    height = d2.sizey * size.h;
+                                    height = d2.sizey * size2.h;
                                 }
                                 var xOffset = width * anchors.x[d2.xanchor].offset;
                                 var yOffset = height * anchors.y[d2.yanchor].offset;
                                 var sizing = anchors.x[d2.xanchor].sizing + anchors.y[d2.yanchor].sizing;
                                 var xPos, yPos;
                                 if (xa !== void 0) {
                                     xPos = typeof d2.xref === "string" && xIsDomain ? xa._length * d2.x + xa._offset : xa.r2p(d2.x) + xa._offset;
                                 } else {
-                                    xPos = d2.x * size.w + size.l;
+                                    xPos = d2.x * size2.w + size2.l;
                                 }
                                 xPos += xOffset;
                                 if (ya !== void 0) {
                                     yPos = typeof d2.yref === "string" && yIsDomain ? ya._length * (1 - d2.y) + ya._offset : ya.r2p(d2.y) + ya._offset;
                                 } else {
-                                    yPos = size.h - d2.y * size.h + size.t;
+                                    yPos = size2.h - d2.y * size2.h + size2.t;
                                 }
                                 yPos += yOffset;
                                 switch (d2.sizing) {
                                     case "fill":
                                         sizing += " slice";
                                         break;
                                     case "stretch":
@@ -90605,15 +91454,15 @@
                                             x2 = initX;
                                             y2 = initY;
                                             newPos.push([w2, x2, y2]);
                                         }
                                         break;
                                 }
                                 var domain2 = (plotinfo || {}).domain;
-                                var size = gd._fullLayout._size;
+                                var size2 = gd._fullLayout._size;
                                 var xPixelSized = plotinfo && plotinfo.xsizemode === "pixel";
                                 var yPixelSized = plotinfo && plotinfo.ysizemode === "pixel";
                                 var noOffset = isActiveShape === false;
                                 for (var j2 = 0; j2 < newPos.length; j2++) {
                                     for (k2 = 0; k2 + 2 < 7; k2 += 2) {
                                         var _x = newPos[j2][k2 + 1];
                                         var _y = newPos[j2][k2 + 2];
@@ -90628,35 +91477,35 @@
                                                 if (xPixelSized) {
                                                     _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;
                                                 } else {
                                                     _x = p2r(plotinfo.xaxis, _x);
                                                 }
                                             } else {
                                                 if (noOffset)
-                                                    _x -= size.l;
+                                                    _x -= size2.l;
                                                 if (domain2)
-                                                    _x = domain2.x[0] + _x / size.w;
+                                                    _x = domain2.x[0] + _x / size2.w;
                                                 else
-                                                    _x = _x / size.w;
+                                                    _x = _x / size2.w;
                                             }
                                             if (plotinfo.yaxis && plotinfo.yaxis.p2r) {
                                                 if (noOffset)
                                                     _y -= plotinfo.yaxis._offset;
                                                 if (yPixelSized) {
                                                     _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;
                                                 } else {
                                                     _y = p2r(plotinfo.yaxis, _y);
                                                 }
                                             } else {
                                                 if (noOffset)
-                                                    _y -= size.t;
+                                                    _y -= size2.t;
                                                 if (domain2)
-                                                    _y = domain2.y[1] - _y / size.h;
+                                                    _y = domain2.y[1] - _y / size2.h;
                                                 else
-                                                    _y = 1 - _y / size.h;
+                                                    _y = 1 - _y / size2.h;
                                             }
                                         }
                                         newPos[j2][k2 + 1] = _x;
                                         newPos[j2][k2 + 2] = _y;
                                     }
                                     polys[n2].push(newPos[j2].slice());
                                 }
@@ -93855,40 +94704,40 @@
                             var out = [];
                             var v2 = coerceTypedArraySpec(vIn);
                             var dtype = v2.dtype;
                             var T2 = typedArrays2[dtype];
                             if (!T2)
                                 throw new Error('Error in dtype: "' + dtype + '"');
                             var BYTES_PER_ELEMENT = T2.BYTES_PER_ELEMENT;
-                            var buffer2 = v2.bdata;
-                            if (!isArrayBuffer(buffer2)) {
-                                buffer2 = b64decode(buffer2);
+                            var buffer = v2.bdata;
+                            if (!isArrayBuffer(buffer)) {
+                                buffer = b64decode(buffer);
                             }
-                            var shape = v2.shape === void 0 ? [buffer2.byteLength / BYTES_PER_ELEMENT] : ("" + v2.shape).split(",");
+                            var shape = v2.shape === void 0 ? [buffer.byteLength / BYTES_PER_ELEMENT] : ("" + v2.shape).split(",");
                             shape.reverse();
                             var ndim = shape.length;
                             var nj, j2;
                             var ni = +shape[0];
                             var rowBytes = BYTES_PER_ELEMENT * ni;
                             var pos = 0;
                             if (ndim === 1) {
-                                out = new T2(buffer2);
+                                out = new T2(buffer);
                             } else if (ndim === 2) {
                                 nj = +shape[1];
                                 for (j2 = 0; j2 < nj; j2++) {
-                                    out[j2] = new T2(buffer2, pos, ni);
+                                    out[j2] = new T2(buffer, pos, ni);
                                     pos += rowBytes;
                                 }
                             } else if (ndim === 3) {
                                 nj = +shape[1];
                                 var nk = +shape[2];
                                 for (var k2 = 0; k2 < nk; k2++) {
                                     out[k2] = [];
                                     for (j2 = 0; j2 < nj; j2++) {
-                                        out[k2][j2] = new T2(buffer2, pos, ni);
+                                        out[k2][j2] = new T2(buffer, pos, ni);
                                         pos += rowBytes;
                                     }
                                 }
                             } else {
                                 throw new Error("ndim: " + ndim + 'is not supported with the shape:"' + v2.shape + '"');
                             }
                             out.bdata = v2.bdata;
@@ -95431,15 +96280,15 @@
                             };
                             locationCache[positionOnPath] = out;
                             return out;
                         };
                         exports4.clearLocationCache = function() {
                             workingPath = null;
                         };
-                        exports4.getVisibleSegment = function getVisibleSegment(path2, bounds2, buffer2) {
+                        exports4.getVisibleSegment = function getVisibleSegment(path2, bounds2, buffer) {
                             var left2 = bounds2.left;
                             var right2 = bounds2.right;
                             var top2 = bounds2.top;
                             var bottom2 = bounds2.bottom;
                             var pMin = 0;
                             var pTotal = path2.getTotalLength();
                             var pMax = pTotal;
@@ -95453,22 +96302,22 @@
                                     ptTotal = pt2;
                                 var dx = pt2.x < left2 ? left2 - pt2.x : pt2.x > right2 ? pt2.x - right2 : 0;
                                 var dy = pt2.y < top2 ? top2 - pt2.y : pt2.y > bottom2 ? pt2.y - bottom2 : 0;
                                 return Math.sqrt(dx * dx + dy * dy);
                             }
                             var distToPlot = getDistToPlot(pMin);
                             while (distToPlot) {
-                                pMin += distToPlot + buffer2;
+                                pMin += distToPlot + buffer;
                                 if (pMin > pMax)
                                     return;
                                 distToPlot = getDistToPlot(pMin);
                             }
                             distToPlot = getDistToPlot(pMax);
                             while (distToPlot) {
-                                pMax -= distToPlot + buffer2;
+                                pMax -= distToPlot + buffer;
                                 if (pMin > pMax)
                                     return;
                                 distToPlot = getDistToPlot(pMax);
                             }
                             return {
                                 min: pMin,
                                 max: pMax,
@@ -96542,16 +97391,16 @@
                         lib2.join2 = function(arr, mainSeparator, lastSeparator) {
                             var len = arr.length;
                             if (len > 1) {
                                 return arr.slice(0, -1).join(mainSeparator) + lastSeparator + arr[len - 1];
                             }
                             return arr.join(mainSeparator);
                         };
-                        lib2.bigFont = function(size) {
-                            return Math.round(1.2 * size);
+                        lib2.bigFont = function(size2) {
+                            return Math.round(1.2 * size2);
                         };
                         var firefoxVersion = lib2.getFirefoxVersion();
                         var isProblematicFirefox = firefoxVersion !== null && firefoxVersion < 86;
                         lib2.getPositionFromD3Event = function() {
                             if (isProblematicFirefox) {
                                 return [d3.event.layerX, d3.event.layerY];
                             } else {
@@ -105620,22 +106469,22 @@
                                 if (allSpikesEnabled === "on" && !ax.showspikes) {
                                     allSpikesEnabled = "off";
                                 }
                             }
                             gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
                             return hasOneAxisChanged;
                         };
-                        axes.autoBin = function(data2, ax, nbins, is2d, calendar, size) {
+                        axes.autoBin = function(data2, ax, nbins, is2d, calendar, size2) {
                             var dataMin = Lib.aggNums(Math.min, null, data2);
                             var dataMax = Lib.aggNums(Math.max, null, data2);
                             if (ax.type === "category" || ax.type === "multicategory") {
                                 return {
                                     start: dataMin - 0.5,
                                     end: dataMax + 0.5,
-                                    size: Math.max(1, Math.round(size) || 1),
+                                    size: Math.max(1, Math.round(size2) || 1),
                                     _dataSpan: dataMax - dataMin
                                 };
                             }
                             if (!calendar)
                                 calendar = ax.calendar;
                             var dummyAx;
                             if (ax.type === "log") {
@@ -105647,17 +106496,17 @@
                                 dummyAx = {
                                     type: ax.type,
                                     range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
                                     calendar
                                 };
                             }
                             axes.setConvert(dummyAx);
-                            size = size && cleanTicks.dtick(size, dummyAx.type);
-                            if (size) {
-                                dummyAx.dtick = size;
+                            size2 = size2 && cleanTicks.dtick(size2, dummyAx.type);
+                            if (size2) {
+                                dummyAx.dtick = size2;
                                 dummyAx.tick0 = cleanTicks.tick0(void 0, dummyAx.type, calendar);
                             } else {
                                 var size0;
                                 if (nbins)
                                     size0 = (dataMax - dataMin) / nbins;
                                 else {
                                     var distinctData = Lib.distinctVals(data2);
@@ -108858,17 +109707,17 @@
                         function indexOfDay(v2) {
                             if (typeof v2 !== "string")
                                 return;
                             return dayStrToNum[v2.substr(0, 3).toLowerCase()];
                         }
                     },
                     12663: function(module3, __unused_webpack_exports, __webpack_require__2) {
-                        var docs = __webpack_require__2(31562);
-                        var FORMAT_LINK = docs.FORMAT_LINK;
-                        var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
+                        var docs2 = __webpack_require__2(31562);
+                        var FORMAT_LINK = docs2.FORMAT_LINK;
+                        var DATE_FORMAT_LINK = docs2.DATE_FORMAT_LINK;
 
                         function axisHoverFormat(x2, noDates) {
                             return {
                                 valType: "string",
                                 dflt: "",
                                 editType: "none",
                                 description: (noDates ? descriptionOnlyNumbers : descriptionWithDates)("hover text", x2) + ["By default the values are formatted using " + (noDates ? "generic number format" : "`" + x2 + "axis.hoverformat`") + "."].join(" ")
@@ -109417,16 +110266,16 @@
                             if (aLen === bLen) {
                                 return c2;
                             }
                             return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c2;
                         }
 
                         function finalRatios(group, fullLayout) {
-                            var size = fullLayout._size;
-                            var yRatio = size.h / size.w;
+                            var size2 = fullLayout._size;
+                            var yRatio = size2.h / size2.w;
                             var out = {};
                             var keys2 = Object.keys(group);
                             for (var i2 = 0; i2 < keys2.length; i2++) {
                                 var key = keys2[i2];
                                 var val = group[key];
                                 if (typeof val === "string") {
                                     var prefix = val.match(/^[xy]*/)[0];
@@ -109546,15 +110395,15 @@
                             for (var i2 = 0; i2 < matchGroups.length; i2++) {
                                 var group = matchGroups[i2];
                                 if (group[axId])
                                     return "g" + i2;
                             }
                             return axId;
                         };
-                        exports4.clean = function clean2(gd, ax) {
+                        exports4.clean = function clean(gd, ax) {
                             if (ax._inputDomain) {
                                 var isConstrained = false;
                                 var axId = ax._id;
                                 var constraintGroups = gd._fullLayout._axisConstraintGroups;
                                 for (var j2 = 0; j2 < constraintGroups.length; j2++) {
                                     if (constraintGroups[j2][axId]) {
                                         isConstrained = true;
@@ -114817,15 +115666,15 @@
                                     });
                                     fullLayout[geoId]._subplot = geo;
                                 }
                                 geo.plot(geoCalcData, fullLayout, gd._promises);
                             }
                         }
 
-                        function clean2(newFullData, newFullLayout, oldFullData, oldFullLayout) {
+                        function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
                             var oldGeoKeys = oldFullLayout._subplots[GEO] || [];
                             for (var i2 = 0; i2 < oldGeoKeys.length; i2++) {
                                 var oldGeoKey = oldGeoKeys[i2];
                                 var oldGeo = oldFullLayout[oldGeoKey]._subplot;
                                 if (!newFullLayout[oldGeoKey] && !!oldGeo) {
                                     oldGeo.framework.remove();
                                     oldGeo.clipDef.remove();
@@ -114849,15 +115698,15 @@
                             idRegex: counter2,
                             attrRegex: counter2,
                             attributes: attributes2,
                             layoutAttributes: __webpack_require__2(77519),
                             supplyLayoutDefaults: __webpack_require__2(82161),
                             plot: plotGeo,
                             updateFx,
-                            clean: clean2
+                            clean
                         };
                     },
                     77519: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var colorAttrs = __webpack_require__2(22399);
                         var domainAttrs = __webpack_require__2(27670).Y;
                         var dash2 = __webpack_require__2(79952).P;
                         var constants = __webpack_require__2(78776);
@@ -115425,16 +116274,16 @@
                                     projection.scale(d3.event.scale);
                                     if (!zoomPoint) {
                                         mouse0 = mouse1;
                                         zoomPoint = position2(projection, mouse0);
                                     } else if (position2(projection, mouse1)) {
                                         projection.rotate(rotate0).translate(translate0);
                                         var point1 = position2(projection, mouse1);
-                                        var between2 = rotateBetween(zoomPoint, point1);
-                                        var newEuler = eulerFromQuaternion(multiply(q2, between2));
+                                        var between = rotateBetween(zoomPoint, point1);
+                                        var newEuler = eulerFromQuaternion(multiply(q2, between));
                                         var rotateAngles = unRoll(newEuler, zoomPoint, lastRotate);
                                         if (!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) || !isFinite(rotateAngles[2])) {
                                             rotateAngles = lastRotate;
                                         }
                                         projection.rotate(rotateAngles);
                                         lastRotate = rotateAngles;
                                     }
@@ -116484,23 +117333,23 @@
                                     xaxis: this.xaxis,
                                     yaxis: this.yaxis,
                                     _size: fullLayout._size
                                 }
                             };
                             cleanAxisConstraints(mockGraphDiv, this.xaxis);
                             cleanAxisConstraints(mockGraphDiv, this.yaxis);
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             var domainX = this.xaxis.domain;
                             var domainY = this.yaxis.domain;
-                            options.viewBox = [size.l + domainX[0] * size.w, size.b + domainY[0] * size.h, width - size.r - (1 - domainX[1]) * size.w, height - size.t - (1 - domainY[1]) * size.h];
-                            this.mouseContainer.style.width = size.w * (domainX[1] - domainX[0]) + "px";
-                            this.mouseContainer.style.height = size.h * (domainY[1] - domainY[0]) + "px";
-                            this.mouseContainer.height = size.h * (domainY[1] - domainY[0]);
-                            this.mouseContainer.style.left = size.l + domainX[0] * size.w + "px";
-                            this.mouseContainer.style.top = size.t + (1 - domainY[1]) * size.h + "px";
+                            options.viewBox = [size2.l + domainX[0] * size2.w, size2.b + domainY[0] * size2.h, width - size2.r - (1 - domainX[1]) * size2.w, height - size2.t - (1 - domainY[1]) * size2.h];
+                            this.mouseContainer.style.width = size2.w * (domainX[1] - domainX[0]) + "px";
+                            this.mouseContainer.style.height = size2.h * (domainY[1] - domainY[0]) + "px";
+                            this.mouseContainer.height = size2.h * (domainY[1] - domainY[0]);
+                            this.mouseContainer.style.left = size2.l + domainX[0] * size2.w + "px";
+                            this.mouseContainer.style.top = size2.t + (1 - domainY[1]) * size2.h + "px";
                             var ax, i2;
                             for (i2 = 0; i2 < 2; ++i2) {
                                 ax = this[AXES[i2]];
                                 ax._length = options.viewBox[i2 + 2] - options.viewBox[i2];
                                 doAutoRange(this.graphDiv, ax);
                                 ax.setScale();
                             }
@@ -116622,18 +117471,18 @@
                                         selectBox[i2] = glplot.dataBox[i2];
                                         selectBox[i2 + 2] = glplot.dataBox[i2 + 2];
                                     }
                                 }
                                 glplot.setDirty();
                             } else if (!camera.panning && this.isMouseOver) {
                                 this.selectBox.enabled = false;
-                                var size = fullLayout._size;
+                                var size2 = fullLayout._size;
                                 var domainX = this.xaxis.domain;
                                 var domainY = this.yaxis.domain;
-                                result = glplot.pick(x2 / glplot.pixelRatio + size.l + domainX[0] * size.w, y2 / glplot.pixelRatio - (size.t + (1 - domainY[1]) * size.h));
+                                result = glplot.pick(x2 / glplot.pixelRatio + size2.l + domainX[0] * size2.w, y2 / glplot.pixelRatio - (size2.t + (1 - domainY[1]) * size2.h));
                                 var nextSelection = result && result.object._trace.handlePick(result);
                                 if (nextSelection && mouseUp) {
                                     this.emitPointAction(nextSelection, "plotly_click");
                                 }
                                 if (result && result.object._trace.hoverinfo !== "skip" && fullLayout.hovermode) {
                                     if (nextSelection && (!this.lastPickResult || this.lastPickResult.traceUid !== nextSelection.trace.uid || this.lastPickResult.dataCoord[0] !== nextSelection.dataCoord[0] || this.lastPickResult.dataCoord[1] !== nextSelection.dataCoord[1])) {
                                         var selection2 = nextSelection;
@@ -116777,28 +117626,28 @@
                                     }
                                 }
                             }
                         };
                         exports4.toSVG = function(gd) {
                             var fullLayout = gd._fullLayout;
                             var sceneIds = fullLayout._subplots[GL3D];
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             for (var i2 = 0; i2 < sceneIds.length; i2++) {
                                 var sceneLayout = fullLayout[sceneIds[i2]];
                                 var domain2 = sceneLayout.domain;
                                 var scene = sceneLayout._scene;
                                 var imageData = scene.toImage("png");
                                 var image2 = fullLayout._glimages.append("svg:image");
                                 image2.attr({
                                     xmlns: xmlnsNamespaces.svg,
                                     "xlink:href": imageData,
-                                    x: size.l + size.w * domain2.x[0],
-                                    y: size.t + size.h * (1 - domain2.y[1]),
-                                    width: size.w * (domain2.x[1] - domain2.x[0]),
-                                    height: size.h * (domain2.y[1] - domain2.y[0]),
+                                    x: size2.l + size2.w * domain2.x[0],
+                                    y: size2.t + size2.h * (1 - domain2.y[1]),
+                                    width: size2.w * (domain2.x[1] - domain2.x[0]),
+                                    height: size2.h * (domain2.y[1] - domain2.y[0]),
                                     preserveAspectRatio: "none"
                                 });
                                 scene.destroy();
                             }
                         };
                         exports4.cleanId = function cleanId(id2) {
                             if (!id2.match(/^scene[0-9]*$/))
@@ -118146,22 +118995,22 @@
                                     z: fullSceneLayout.aspectratio.z
                                 };
                             }
                             if (!scene.viewInitial.aspectmode) {
                                 scene.viewInitial.aspectmode = fullSceneLayout.aspectmode;
                             }
                             var domain2 = fullSceneLayout.domain || null;
-                            var size = fullLayout._size || null;
-                            if (domain2 && size) {
+                            var size2 = fullLayout._size || null;
+                            if (domain2 && size2) {
                                 var containerStyle = scene.container.style;
                                 containerStyle.position = "absolute";
-                                containerStyle.left = size.l + domain2.x[0] * size.w + "px";
-                                containerStyle.top = size.t + (1 - domain2.y[1]) * size.h + "px";
-                                containerStyle.width = size.w * (domain2.x[1] - domain2.x[0]) + "px";
-                                containerStyle.height = size.h * (domain2.y[1] - domain2.y[0]) + "px";
+                                containerStyle.left = size2.l + domain2.x[0] * size2.w + "px";
+                                containerStyle.top = size2.t + (1 - domain2.y[1]) * size2.h + "px";
+                                containerStyle.width = size2.w * (domain2.x[1] - domain2.x[0]) + "px";
+                                containerStyle.height = size2.h * (domain2.y[1] - domain2.y[0]) + "px";
                             }
                             scene.glplot.redraw();
                         };
                         proto2.destroy = function() {
                             var scene = this;
                             if (!scene.glplot)
                                 return;
@@ -118970,35 +119819,35 @@
                                     oldFullLayout[oldMapboxKey]._subplot.destroy();
                                 }
                             }
                         };
                         exports4.toSVG = function(gd) {
                             var fullLayout = gd._fullLayout;
                             var subplotIds = fullLayout._subplots[MAPBOX];
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             for (var i2 = 0; i2 < subplotIds.length; i2++) {
                                 var opts = fullLayout[subplotIds[i2]];
                                 var domain2 = opts.domain;
                                 var mapbox = opts._subplot;
                                 var imageData = mapbox.toImage("png");
                                 var image2 = fullLayout._glimages.append("svg:image");
                                 image2.attr({
                                     xmlns: xmlnsNamespaces.svg,
                                     "xlink:href": imageData,
-                                    x: size.l + size.w * domain2.x[0],
-                                    y: size.t + size.h * (1 - domain2.y[1]),
-                                    width: size.w * (domain2.x[1] - domain2.x[0]),
-                                    height: size.h * (domain2.y[1] - domain2.y[0]),
+                                    x: size2.l + size2.w * domain2.x[0],
+                                    y: size2.t + size2.h * (1 - domain2.y[1]),
+                                    width: size2.w * (domain2.x[1] - domain2.x[0]),
+                                    height: size2.h * (domain2.y[1] - domain2.y[0]),
                                     preserveAspectRatio: "none"
                                 });
                                 var subplotDiv = d3.select(opts._subplot.div);
                                 var hidden = subplotDiv.select(".mapboxgl-ctrl-logo").node().offsetParent === null;
                                 if (!hidden) {
                                     var logo = fullLayout._glimages.append("g");
-                                    logo.attr("transform", strTranslate(size.l + size.w * domain2.x[0] + 10, size.t + size.h * (1 - domain2.y[0]) - 31));
+                                    logo.attr("transform", strTranslate(size2.l + size2.w * domain2.x[0] + 10, size2.t + size2.h * (1 - domain2.y[0]) - 31));
                                     logo.append("path").attr("d", constants.mapboxLogo.path0).style({
                                         opacity: 0.9,
                                         fill: "#ffffff",
                                         "enable-background": "new"
                                     });
                                     logo.append("path").attr("d", constants.mapboxLogo.path1).style("opacity", 0.35).style("enable-background", "new");
                                     logo.append("path").attr("d", constants.mapboxLogo.path2).style("opacity", 0.35).style("enable-background", "new");
@@ -119015,15 +119864,15 @@
                                     "font-size": 12,
                                     "font-family": "Arial",
                                     color: "rgba(0, 0, 0, 0.75)",
                                     "text-anchor": "end",
                                     "data-unformatted": attributions
                                 });
                                 var bBox = Drawing.bBox(attributionText.node());
-                                var maxWidth = size.w * (domain2.x[1] - domain2.x[0]);
+                                var maxWidth = size2.w * (domain2.x[1] - domain2.x[0]);
                                 if (bBox.width > maxWidth / 2) {
                                     var multilineAttributions = attributions.split("|").join("<br>");
                                     attributionText.text(multilineAttributions).attr("data-unformatted", multilineAttributions).call(svgTextUtils.convertToTspans, gd);
                                     bBox = Drawing.bBox(attributionText.node());
                                 }
                                 attributionText.attr("transform", strTranslate(-3, -bBox.height + 8));
                                 attributionGroup.insert("rect", ".static-attribution").attr({
@@ -119032,15 +119881,15 @@
                                     width: bBox.width + 6,
                                     height: bBox.height + 3,
                                     fill: "rgba(255, 255, 255, 0.75)"
                                 });
                                 var scaleRatio = 1;
                                 if (bBox.width + 6 > maxWidth)
                                     scaleRatio = maxWidth / (bBox.width + 6);
-                                var offset2 = [size.l + size.w * domain2.x[1], size.t + size.h * (1 - domain2.y[0])];
+                                var offset2 = [size2.l + size2.w * domain2.x[1], size2.t + size2.h * (1 - domain2.y[0])];
                                 attributionGroup.attr("transform", strTranslate(offset2[0], offset2[1]) + strScale(scaleRatio));
                             }
                         };
 
                         function findAccessToken(gd, mapboxIds) {
                             var fullLayout = gd._fullLayout;
                             var context2 = gd._context;
@@ -120031,24 +120880,24 @@
                                 self2.div.removeEventListener("touchstart", self2.div._ontouchstart);
                                 self2.onClickInPanHandler = self2.onClickInPanFn(self2.dragOptions);
                                 map2.on("click", self2.onClickInPanHandler);
                             }
                         };
                         proto2.updateFramework = function(fullLayout) {
                             var domain2 = fullLayout[this.id].domain;
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             var style2 = this.div.style;
-                            style2.width = size.w * (domain2.x[1] - domain2.x[0]) + "px";
-                            style2.height = size.h * (domain2.y[1] - domain2.y[0]) + "px";
-                            style2.left = size.l + domain2.x[0] * size.w + "px";
-                            style2.top = size.t + (1 - domain2.y[1]) * size.h + "px";
-                            this.xaxis._offset = size.l + domain2.x[0] * size.w;
-                            this.xaxis._length = size.w * (domain2.x[1] - domain2.x[0]);
-                            this.yaxis._offset = size.t + (1 - domain2.y[1]) * size.h;
-                            this.yaxis._length = size.h * (domain2.y[1] - domain2.y[0]);
+                            style2.width = size2.w * (domain2.x[1] - domain2.x[0]) + "px";
+                            style2.height = size2.h * (domain2.y[1] - domain2.y[0]) + "px";
+                            style2.left = size2.l + domain2.x[0] * size2.w + "px";
+                            style2.top = size2.t + (1 - domain2.y[1]) * size2.h + "px";
+                            this.xaxis._offset = size2.l + domain2.x[0] * size2.w;
+                            this.xaxis._length = size2.w * (domain2.x[1] - domain2.x[0]);
+                            this.yaxis._offset = size2.t + (1 - domain2.y[1]) * size2.h;
+                            this.yaxis._length = size2.h * (domain2.y[1] - domain2.y[0]);
                         };
                         proto2.updateLayers = function(fullLayout) {
                             var opts = fullLayout[this.id];
                             var layers = opts.layers;
                             var layerList = this.layerList;
                             var i2;
                             if (layers.length !== layerList.length) {
@@ -122912,15 +123761,15 @@
                                     subplot = createPolar(gd, id2);
                                     fullLayout[id2]._subplot = subplot;
                                 }
                                 subplot.plot(subplotCalcData, fullLayout, gd._promises);
                             }
                         }
 
-                        function clean2(newFullData, newFullLayout, oldFullData, oldFullLayout) {
+                        function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
                             var oldIds = oldFullLayout._subplots[name2] || [];
                             var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
                             var hasGl = newFullLayout._has && newFullLayout._has("gl");
                             var mustCleanScene = hadGl && !hasGl;
                             for (var i2 = 0; i2 < oldIds.length; i2++) {
                                 var id2 = oldIds[i2];
                                 var oldSubplot = oldFullLayout[id2]._subplot;
@@ -122943,15 +123792,15 @@
                             idRoot: name2,
                             idRegex: counter2,
                             attrRegex: counter2,
                             attributes: attributes2,
                             layoutAttributes: __webpack_require__2(73812),
                             supplyLayoutDefaults: __webpack_require__2(68993),
                             plot,
-                            clean: clean2,
+                            clean,
                             toSVG: __webpack_require__2(93612).toSVG
                         };
                     },
                     73812: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var colorAttrs = __webpack_require__2(22399);
                         var axesAttrs = __webpack_require__2(13838);
                         var domainAttrs = __webpack_require__2(27670).Y;
@@ -124844,15 +125693,15 @@
                                     subplot = createPolar(gd, id2, true);
                                     fullLayout[id2]._subplot = subplot;
                                 }
                                 subplot.plot(subplotCalcData, fullLayout, gd._promises);
                             }
                         }
 
-                        function clean2(newFullData, newFullLayout, oldFullData, oldFullLayout) {
+                        function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
                             var oldIds = oldFullLayout._subplots[name2] || [];
                             for (var i2 = 0; i2 < oldIds.length; i2++) {
                                 var id2 = oldIds[i2];
                                 var oldSubplot = oldFullLayout[id2]._subplot;
                                 if (!newFullLayout[id2] && !!oldSubplot) {
                                     oldSubplot.framework.remove();
                                     for (var k2 in oldSubplot.clipPaths) {
@@ -124867,15 +125716,15 @@
                             idRoot: name2,
                             idRegex: counter2,
                             attrRegex: counter2,
                             attributes: attributes2,
                             layoutAttributes: __webpack_require__2(33419),
                             supplyLayoutDefaults: __webpack_require__2(9558),
                             plot,
-                            clean: clean2,
+                            clean,
                             toSVG: __webpack_require__2(93612).toSVG
                         };
                     },
                     33419: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var colorAttrs = __webpack_require__2(22399);
                         var axesAttrs = __webpack_require__2(13838);
                         var domainAttrs = __webpack_require__2(27670).Y;
@@ -125125,17 +125974,17 @@
                                 handleDomainDefaults(subplotLayoutOut, layoutOut, coerce2, dfltDomains);
                                 opts.id = id2;
                                 handleDefaults(subplotLayoutIn, subplotLayoutOut, coerce2, opts);
                             }
                         };
                     },
                     5386: function(__unused_webpack_module, exports4, __webpack_require__2) {
-                        var docs = __webpack_require__2(31562);
-                        docs.FORMAT_LINK;
-                        docs.DATE_FORMAT_LINK;
+                        var docs2 = __webpack_require__2(31562);
+                        docs2.FORMAT_LINK;
+                        docs2.DATE_FORMAT_LINK;
 
                         function describeVariables(extra) {
                             var descPart = extra.description ? " " + extra.description : "";
                             var keys2 = extra.keys || [];
                             if (keys2.length > 0) {
                                 var quotedKeys = [];
                                 for (var i2 = 0; i2 < keys2.length; i2++) {
@@ -127027,38 +127876,38 @@
                         var hasColorscale = __webpack_require__2(52075).hasColorscale;
                         var colorscaleCalc = __webpack_require__2(78803);
                         var arraysToCalcdata = __webpack_require__2(75341);
                         var calcSelection = __webpack_require__2(66279);
                         module3.exports = function calc(gd, trace) {
                             var xa = Axes.getFromId(gd, trace.xaxis || "x");
                             var ya = Axes.getFromId(gd, trace.yaxis || "y");
-                            var size, pos, origPos, pObj, hasPeriod, pLetter;
+                            var size2, pos, origPos, pObj, hasPeriod, pLetter;
                             var sizeOpts = {
                                 msUTC: !!(trace.base || trace.base === 0)
                             };
                             if (trace.orientation === "h") {
-                                size = xa.makeCalcdata(trace, "x", sizeOpts);
+                                size2 = xa.makeCalcdata(trace, "x", sizeOpts);
                                 origPos = ya.makeCalcdata(trace, "y");
                                 pObj = alignPeriod(trace, ya, "y", origPos);
                                 hasPeriod = !!trace.yperiodalignment;
                                 pLetter = "y";
                             } else {
-                                size = ya.makeCalcdata(trace, "y", sizeOpts);
+                                size2 = ya.makeCalcdata(trace, "y", sizeOpts);
                                 origPos = xa.makeCalcdata(trace, "x");
                                 pObj = alignPeriod(trace, xa, "x", origPos);
                                 hasPeriod = !!trace.xperiodalignment;
                                 pLetter = "x";
                             }
                             pos = pObj.vals;
-                            var serieslen = Math.min(pos.length, size.length);
+                            var serieslen = Math.min(pos.length, size2.length);
                             var cd = new Array(serieslen);
                             for (var i2 = 0; i2 < serieslen; i2++) {
                                 cd[i2] = {
                                     p: pos[i2],
-                                    s: size[i2]
+                                    s: size2[i2]
                                 };
                                 if (hasPeriod) {
                                     cd[i2].orig_p = origPos[i2];
                                     cd[i2][pLetter + "End"] = pObj.ends[i2];
                                     cd[i2][pLetter + "Start"] = pObj.starts[i2];
                                 }
                                 if (trace.ids) {
@@ -128000,17 +128849,17 @@
                                 };
                                 maxPos = function(di2) {
                                     return Math.max(thisBarMaxPos(di2), di2.p + t2.bargroupwidth / 2);
                                 };
                             }
                             var index2 = pointData.index;
                             var di = cd[index2];
-                            var size = trace.base ? di.b + di.s : di.s;
+                            var size2 = trace.base ? di.b + di.s : di.s;
                             pointData[sizeLetter + "0"] = pointData[sizeLetter + "1"] = sa.c2p(di[sizeLetter], true);
-                            pointData[sizeLetter + "LabelVal"] = size;
+                            pointData[sizeLetter + "LabelVal"] = size2;
                             var extent = t2.extents[t2.extents.round(di.p)];
                             pointData[posLetter + "0"] = pa.c2p(isClosest ? minPos(di) : extent[0], true);
                             pointData[posLetter + "1"] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);
                             var hasPeriod = di.orig_p !== void 0;
                             pointData[posLetter + "LabelVal"] = hasPeriod ? di.orig_p : di.p;
                             pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + "LabelVal"], trace[posLetter + "hoverformat"]);
                             pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + "LabelVal"], trace[sizeLetter + "hoverformat"]);
@@ -129034,19 +129883,19 @@
                             }
                         }
 
                         function recordMinTextSize(traceType, transform, fullLayout) {
                             if (fullLayout.uniformtext.mode) {
                                 var minKey = getMinKey(traceType);
                                 var minSize = fullLayout.uniformtext.minsize;
-                                var size = transform.scale * transform.fontSize;
-                                transform.hide = size < minSize;
+                                var size2 = transform.scale * transform.fontSize;
+                                transform.hide = size2 < minSize;
                                 fullLayout[minKey] = fullLayout[minKey] || Infinity;
                                 if (!transform.hide) {
-                                    fullLayout[minKey] = Math.min(fullLayout[minKey], Math.max(size, minSize));
+                                    fullLayout[minKey] = Math.min(fullLayout[minKey], Math.max(size2, minSize));
                                 }
                             }
                         }
 
                         function clearMinTextSize(traceType, fullLayout) {
                             var minKey = getMinKey(traceType);
                             fullLayout[minKey] = void 0;
@@ -137051,44 +137900,44 @@
                         var alignPeriod = __webpack_require__2(42973);
                         var arraysToCalcdata = __webpack_require__2(49789);
                         var calcSelection = __webpack_require__2(66279);
                         var BADNUM = __webpack_require__2(50606).BADNUM;
                         module3.exports = function calc(gd, trace) {
                             var xa = Axes.getFromId(gd, trace.xaxis || "x");
                             var ya = Axes.getFromId(gd, trace.yaxis || "y");
-                            var size, pos, origPos, pObj, hasPeriod, pLetter, i2, cdi;
+                            var size2, pos, origPos, pObj, hasPeriod, pLetter, i2, cdi;
                             if (trace.orientation === "h") {
-                                size = xa.makeCalcdata(trace, "x");
+                                size2 = xa.makeCalcdata(trace, "x");
                                 origPos = ya.makeCalcdata(trace, "y");
                                 pObj = alignPeriod(trace, ya, "y", origPos);
                                 hasPeriod = !!trace.yperiodalignment;
                                 pLetter = "y";
                             } else {
-                                size = ya.makeCalcdata(trace, "y");
+                                size2 = ya.makeCalcdata(trace, "y");
                                 origPos = xa.makeCalcdata(trace, "x");
                                 pObj = alignPeriod(trace, xa, "x", origPos);
                                 hasPeriod = !!trace.xperiodalignment;
                                 pLetter = "x";
                             }
                             pos = pObj.vals;
-                            var serieslen = Math.min(pos.length, size.length);
+                            var serieslen = Math.min(pos.length, size2.length);
                             var cd = new Array(serieslen);
                             trace._base = [];
                             for (i2 = 0; i2 < serieslen; i2++) {
-                                if (size[i2] < 0)
-                                    size[i2] = BADNUM;
+                                if (size2[i2] < 0)
+                                    size2[i2] = BADNUM;
                                 var connectToNext = false;
-                                if (size[i2] !== BADNUM) {
-                                    if (i2 + 1 < serieslen && size[i2 + 1] !== BADNUM) {
+                                if (size2[i2] !== BADNUM) {
+                                    if (i2 + 1 < serieslen && size2[i2 + 1] !== BADNUM) {
                                         connectToNext = true;
                                     }
                                 }
                                 cdi = cd[i2] = {
                                     p: pos[i2],
-                                    s: size[i2],
+                                    s: size2[i2],
                                     cNext: connectToNext
                                 };
                                 trace._base[i2] = -0.5 * cdi.s;
                                 if (hasPeriod) {
                                     cd[i2].orig_p = origPos[i2];
                                     cd[i2][pLetter + "End"] = pObj.ends[i2];
                                     cd[i2][pLetter + "Start"] = pObj.starts[i2];
@@ -139707,23 +140556,23 @@
                             unselected: barAttrs.unselected,
                             _deprecated: {
                                 bardir: barAttrs._deprecated.bardir
                             }
                         };
                     },
                     42174: function(module3) {
-                        module3.exports = function doAvg(size, counts) {
-                            var nMax = size.length;
+                        module3.exports = function doAvg(size2, counts) {
+                            var nMax = size2.length;
                             var total = 0;
                             for (var i2 = 0; i2 < nMax; i2++) {
                                 if (counts[i2]) {
-                                    size[i2] /= counts[i2];
-                                    total += size[i2];
+                                    size2[i2] /= counts[i2];
+                                    total += size2[i2];
                                 } else
-                                    size[i2] = null;
+                                    size2[i2] = null;
                             }
                             return total;
                         };
                     },
                     17656: function(module3) {
                         module3.exports = function makeBinAttrs(axLetter, match2) {
                             return {
@@ -139742,61 +140591,61 @@
                                 editType: "calc"
                             };
                         };
                     },
                     59575: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var isNumeric = __webpack_require__2(92770);
                         module3.exports = {
-                            count: function(n2, i2, size) {
-                                size[n2]++;
+                            count: function(n2, i2, size2) {
+                                size2[n2]++;
                                 return 1;
                             },
-                            sum: function(n2, i2, size, counterData) {
+                            sum: function(n2, i2, size2, counterData) {
                                 var v2 = counterData[i2];
                                 if (isNumeric(v2)) {
                                     v2 = Number(v2);
-                                    size[n2] += v2;
+                                    size2[n2] += v2;
                                     return v2;
                                 }
                                 return 0;
                             },
-                            avg: function(n2, i2, size, counterData, counts) {
+                            avg: function(n2, i2, size2, counterData, counts) {
                                 var v2 = counterData[i2];
                                 if (isNumeric(v2)) {
                                     v2 = Number(v2);
-                                    size[n2] += v2;
+                                    size2[n2] += v2;
                                     counts[n2]++;
                                 }
                                 return 0;
                             },
-                            min: function(n2, i2, size, counterData) {
+                            min: function(n2, i2, size2, counterData) {
                                 var v2 = counterData[i2];
                                 if (isNumeric(v2)) {
                                     v2 = Number(v2);
-                                    if (!isNumeric(size[n2])) {
-                                        size[n2] = v2;
+                                    if (!isNumeric(size2[n2])) {
+                                        size2[n2] = v2;
                                         return v2;
-                                    } else if (size[n2] > v2) {
-                                        var delta = v2 - size[n2];
-                                        size[n2] = v2;
+                                    } else if (size2[n2] > v2) {
+                                        var delta = v2 - size2[n2];
+                                        size2[n2] = v2;
                                         return delta;
                                     }
                                 }
                                 return 0;
                             },
-                            max: function(n2, i2, size, counterData) {
+                            max: function(n2, i2, size2, counterData) {
                                 var v2 = counterData[i2];
                                 if (isNumeric(v2)) {
                                     v2 = Number(v2);
-                                    if (!isNumeric(size[n2])) {
-                                        size[n2] = v2;
+                                    if (!isNumeric(size2[n2])) {
+                                        size2[n2] = v2;
                                         return v2;
-                                    } else if (size[n2] < v2) {
-                                        var delta = v2 - size[n2];
-                                        size[n2] = v2;
+                                    } else if (size2[n2] < v2) {
+                                        var delta = v2 - size2[n2];
+                                        size2[n2] = v2;
                                         return delta;
                                     }
                                 }
                                 return 0;
                             }
                         };
                     },
@@ -139921,15 +140770,15 @@
                         var binFunctions = __webpack_require__2(59575);
                         var normFunctions = __webpack_require__2(36362);
                         var doAvg = __webpack_require__2(42174);
                         var getBinSpanLabelRound = __webpack_require__2(40965);
 
                         function calc(gd, trace) {
                             var pos = [];
-                            var size = [];
+                            var size2 = [];
                             var isHorizontal = trace.orientation === "h";
                             var pa = Axes.getFromId(gd, isHorizontal ? trace.yaxis : trace.xaxis);
                             var mainData = isHorizontal ? "y" : "x";
                             var counterData = {
                                 x: "y",
                                 y: "x"
                             } [mainData];
@@ -139969,15 +140818,15 @@
                                 binFunc = binFunctions[func];
                             }
                             i2 = pr2c(binSpec.start);
                             binEnd = pr2c(binSpec.end) + (i2 - Axes.tickIncrement(i2, binSpec.size, false, calendar)) / 1e6;
                             while (i2 < binEnd && pos.length < 1e6) {
                                 i22 = Axes.tickIncrement(i2, binSpec.size, false, calendar);
                                 pos.push((i2 + i22) / 2);
-                                size.push(sizeInit);
+                                size2.push(sizeInit);
                                 inputPoints.push([]);
                                 binEdges.push(i2);
                                 if (densityNorm)
                                     inc.push(1 / (i22 - i2));
                                 if (isAvg)
                                     counts.push(0);
                                 if (i22 <= i2)
@@ -140000,24 +140849,24 @@
                                 rightGap: Infinity
                             };
                             if (groupName) {
                                 if (!gd._fullLayout._roundFnOpts[groupName])
                                     gd._fullLayout._roundFnOpts[groupName] = roundFnOpts;
                                 roundFnOpts = gd._fullLayout._roundFnOpts[groupName];
                             }
-                            var nMax = size.length;
+                            var nMax = size2.length;
                             var uniqueValsPerBin = true;
                             var leftGap = roundFnOpts.leftGap;
                             var rightGap = roundFnOpts.rightGap;
                             var ptNumber2cdIndex = {};
                             for (i2 = 0; i2 < pos0.length; i2++) {
                                 var posi = pos0[i2];
                                 n2 = Lib.findBin(posi, bins);
                                 if (n2 >= 0 && n2 < nMax) {
-                                    total += binFunc(n2, i2, size, rawCounterData, counts);
+                                    total += binFunc(n2, i2, size2, rawCounterData, counts);
                                     if (uniqueValsPerBin && inputPoints[n2].length && posi !== pos0[inputPoints[n2][0]]) {
                                         uniqueValsPerBin = false;
                                     }
                                     inputPoints[n2].push(i2);
                                     ptNumber2cdIndex[i2] = n2;
                                     leftGap = Math.min(leftGap, posi - binEdges[n2]);
                                     rightGap = Math.min(rightGap, binEdges[n2 + 1] - posi);
@@ -140031,40 +140880,40 @@
                                     return function() {
                                         var roundFnOpts2 = gd._fullLayout._roundFnOpts[groupName];
                                         return getBinSpanLabelRound(roundFnOpts2.leftGap, roundFnOpts2.rightGap, binEdges, pa, calendar)(v2, isRightEdge);
                                     };
                                 };
                             }
                             if (isAvg)
-                                total = doAvg(size, counts);
+                                total = doAvg(size2, counts);
                             if (normFunc)
-                                normFunc(size, total, inc);
+                                normFunc(size2, total, inc);
                             if (cumulativeSpec.enabled)
-                                cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);
-                            var seriesLen = Math.min(pos.length, size.length);
+                                cdf(size2, cumulativeSpec.direction, cumulativeSpec.currentbin);
+                            var seriesLen = Math.min(pos.length, size2.length);
                             var cd = [];
                             var firstNonzero = 0;
                             var lastNonzero = seriesLen - 1;
                             for (i2 = 0; i2 < seriesLen; i2++) {
-                                if (size[i2]) {
+                                if (size2[i2]) {
                                     firstNonzero = i2;
                                     break;
                                 }
                             }
                             for (i2 = seriesLen - 1; i2 >= firstNonzero; i2--) {
-                                if (size[i2]) {
+                                if (size2[i2]) {
                                     lastNonzero = i2;
                                     break;
                                 }
                             }
                             for (i2 = firstNonzero; i2 <= lastNonzero; i2++) {
-                                if (isNumeric(pos[i2]) && isNumeric(size[i2])) {
+                                if (isNumeric(pos[i2]) && isNumeric(size2[i2])) {
                                     var cdi = {
                                         p: pos[i2],
-                                        s: size[i2],
+                                        s: size2[i2],
                                         b: 0
                                     };
                                     if (!cumulativeSpec.enabled) {
                                         cdi.pts = inputPoints[i2];
                                         if (uniqueValsPerBin) {
                                             cdi.ph0 = cdi.ph1 = inputPoints[i2].length ? pos0[inputPoints[i2][0]] : pos[i2];
                                         } else {
@@ -140289,54 +141138,54 @@
                                 if (tracei.type === "histogram" && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {
                                     out.push(tracei);
                                 }
                             }
                             return out;
                         }
 
-                        function cdf(size, direction, currentBin) {
+                        function cdf(size2, direction, currentBin) {
                             var i2, vi, prevSum;
 
                             function firstHalfPoint(i3) {
-                                prevSum = size[i3];
-                                size[i3] /= 2;
+                                prevSum = size2[i3];
+                                size2[i3] /= 2;
                             }
 
                             function nextHalfPoint(i3) {
-                                vi = size[i3];
-                                size[i3] = prevSum + vi / 2;
+                                vi = size2[i3];
+                                size2[i3] = prevSum + vi / 2;
                                 prevSum += vi;
                             }
                             if (currentBin === "half") {
                                 if (direction === "increasing") {
                                     firstHalfPoint(0);
-                                    for (i2 = 1; i2 < size.length; i2++) {
+                                    for (i2 = 1; i2 < size2.length; i2++) {
                                         nextHalfPoint(i2);
                                     }
                                 } else {
-                                    firstHalfPoint(size.length - 1);
-                                    for (i2 = size.length - 2; i2 >= 0; i2--) {
+                                    firstHalfPoint(size2.length - 1);
+                                    for (i2 = size2.length - 2; i2 >= 0; i2--) {
                                         nextHalfPoint(i2);
                                     }
                                 }
                             } else if (direction === "increasing") {
-                                for (i2 = 1; i2 < size.length; i2++) {
-                                    size[i2] += size[i2 - 1];
+                                for (i2 = 1; i2 < size2.length; i2++) {
+                                    size2[i2] += size2[i2 - 1];
                                 }
                                 if (currentBin === "exclude") {
-                                    size.unshift(0);
-                                    size.pop();
+                                    size2.unshift(0);
+                                    size2.pop();
                                 }
                             } else {
-                                for (i2 = size.length - 2; i2 >= 0; i2--) {
-                                    size[i2] += size[i2 + 1];
+                                for (i2 = size2.length - 2; i2 >= 0; i2--) {
+                                    size2[i2] += size2[i2 + 1];
                                 }
                                 if (currentBin === "exclude") {
-                                    size.push(0);
-                                    size.shift();
+                                    size2.push(0);
+                                    size2.shift();
                                 }
                             }
                         }
                         module3.exports = {
                             calc,
                             calcAllAutoBins
                         };
@@ -140678,37 +141527,37 @@
                             basePlotModule: __webpack_require__2(93612),
                             categories: ["bar-like", "cartesian", "svg", "bar", "histogram", "oriented", "errorBarsOK", "showLegend"],
                             meta: {}
                         };
                     },
                     36362: function(module3) {
                         module3.exports = {
-                            percent: function(size, total) {
-                                var nMax = size.length;
+                            percent: function(size2, total) {
+                                var nMax = size2.length;
                                 var norm = 100 / total;
                                 for (var n2 = 0; n2 < nMax; n2++)
-                                    size[n2] *= norm;
+                                    size2[n2] *= norm;
                             },
-                            probability: function(size, total) {
-                                var nMax = size.length;
+                            probability: function(size2, total) {
+                                var nMax = size2.length;
                                 for (var n2 = 0; n2 < nMax; n2++)
-                                    size[n2] /= total;
+                                    size2[n2] /= total;
                             },
-                            density: function(size, total, inc, yinc) {
-                                var nMax = size.length;
+                            density: function(size2, total, inc, yinc) {
+                                var nMax = size2.length;
                                 yinc = yinc || 1;
                                 for (var n2 = 0; n2 < nMax; n2++)
-                                    size[n2] *= inc[n2] * yinc;
+                                    size2[n2] *= inc[n2] * yinc;
                             },
-                            "probability density": function(size, total, inc, yinc) {
-                                var nMax = size.length;
+                            "probability density": function(size2, total, inc, yinc) {
+                                var nMax = size2.length;
                                 if (yinc)
                                     total /= yinc;
                                 for (var n2 = 0; n2 < nMax; n2++)
-                                    size[n2] *= inc[n2] / total;
+                                    size2[n2] *= inc[n2] / total;
                             }
                         };
                     },
                     35361: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var histogramAttrs = __webpack_require__2(7745);
                         var makeBinAttrs = __webpack_require__2(17656);
                         var heatmapAttrs = __webpack_require__2(21606);
@@ -141505,28 +142354,28 @@
                             coerce2("iciclecolorway", layoutOut.colorway);
                             coerce2("extendiciclecolors");
                         };
                     },
                     21538: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var d3Hierarchy = __webpack_require__2(674);
                         var flipTree = __webpack_require__2(14102);
-                        module3.exports = function partition(entry, size, opts) {
+                        module3.exports = function partition(entry, size2, opts) {
                             var flipX = opts.flipX;
                             var flipY = opts.flipY;
                             var swapXY = opts.orientation === "h";
                             var maxDepth = opts.maxDepth;
-                            var newWidth = size[0];
-                            var newHeight = size[1];
+                            var newWidth = size2[0];
+                            var newHeight = size2[1];
                             if (maxDepth) {
-                                newWidth = (entry.height + 1) * size[0] / Math.min(entry.height + 1, maxDepth);
-                                newHeight = (entry.height + 1) * size[1] / Math.min(entry.height + 1, maxDepth);
+                                newWidth = (entry.height + 1) * size2[0] / Math.min(entry.height + 1, maxDepth);
+                                newHeight = (entry.height + 1) * size2[1] / Math.min(entry.height + 1, maxDepth);
                             }
-                            var result = d3Hierarchy.partition().padding(opts.pad.inner).size(swapXY ? [size[1], newWidth] : [size[0], newHeight])(entry);
+                            var result = d3Hierarchy.partition().padding(opts.pad.inner).size(swapXY ? [size2[1], newWidth] : [size2[0], newHeight])(entry);
                             if (swapXY || flipX || flipY) {
-                                flipTree(result, size, {
+                                flipTree(result, size2, {
                                     swapXY,
                                     flipX,
                                     flipY
                                 });
                             }
                             return result;
                         };
@@ -141690,17 +142539,17 @@
                         module3.exports = function calc(gd, trace) {
                             var h2;
                             var w2;
                             if (trace._hasZ) {
                                 h2 = trace.z.length;
                                 w2 = maxRowLength(trace.z);
                             } else if (trace._hasSource) {
-                                var size = getImageSize(trace.source);
-                                h2 = size.height;
-                                w2 = size.width;
+                                var size2 = getImageSize(trace.source);
+                                h2 = size2.height;
+                                w2 = size2.width;
                             }
                             var xa = Axes.getFromId(gd, trace.xaxis || "x");
                             var ya = Axes.getFromId(gd, trace.yaxis || "y");
                             var x0 = xa.d2c(trace.x0) - trace.dx / 2;
                             var y0 = ya.d2c(trace.y0) - trace.dy / 2;
                             var i2;
                             var xrange = [x0, x0 + w2 * trace.dx];
@@ -142679,48 +143528,48 @@
                                 var cd0 = cd[0];
                                 var trace = cd0.trace;
                                 var plotGroup = d3.select(this);
                                 var hasGauge = trace._hasGauge;
                                 var isAngular = trace._isAngular;
                                 var isBullet = trace._isBullet;
                                 var domain2 = trace.domain;
-                                var size = {
+                                var size2 = {
                                     w: fullLayout._size.w * (domain2.x[1] - domain2.x[0]),
                                     h: fullLayout._size.h * (domain2.y[1] - domain2.y[0]),
                                     l: fullLayout._size.l + fullLayout._size.w * domain2.x[0],
                                     r: fullLayout._size.r + fullLayout._size.w * (1 - domain2.x[1]),
                                     t: fullLayout._size.t + fullLayout._size.h * (1 - domain2.y[1]),
                                     b: fullLayout._size.b + fullLayout._size.h * domain2.y[0]
                                 };
-                                var centerX = size.l + size.w / 2;
-                                var centerY = size.t + size.h / 2;
-                                var radius = Math.min(size.w / 2, size.h);
+                                var centerX = size2.l + size2.w / 2;
+                                var centerY = size2.t + size2.h / 2;
+                                var radius = Math.min(size2.w / 2, size2.h);
                                 var innerRadius = cn.innerRadius * radius;
                                 var numbersX, numbersY, numbersScaler;
                                 var numbersAlign = trace.align || "center";
                                 numbersY = centerY;
                                 if (!hasGauge) {
-                                    numbersX = size.l + position2[numbersAlign] * size.w;
+                                    numbersX = size2.l + position2[numbersAlign] * size2.w;
                                     numbersScaler = function(el) {
-                                        return fitTextInsideBox(el, size.w, size.h);
+                                        return fitTextInsideBox(el, size2.w, size2.h);
                                     };
                                 } else {
                                     if (isAngular) {
                                         numbersX = centerX;
                                         numbersY = centerY + radius / 2;
                                         numbersScaler = function(el) {
                                             return fitTextInsideCircle(el, 0.9 * innerRadius);
                                         };
                                     }
                                     if (isBullet) {
                                         var padding = cn.bulletPadding;
                                         var p2 = 1 - cn.bulletNumberDomainSize + padding;
-                                        numbersX = size.l + (p2 + (1 - p2) * position2[numbersAlign]) * size.w;
+                                        numbersX = size2.l + (p2 + (1 - p2) * position2[numbersAlign]) * size2.w;
                                         numbersScaler = function(el) {
-                                            return fitTextInsideBox(el, (cn.bulletNumberDomainSize - padding) * size.w, size.h);
+                                            return fitTextInsideBox(el, (cn.bulletNumberDomainSize - padding) * size2.w, size2.h);
                                         };
                                     }
                                 }
                                 drawNumbers(gd, plotGroup, cd, {
                                     numbersX,
                                     numbersY,
                                     numbersScaler,
@@ -142754,59 +143603,59 @@
                                 angularaxisLayer.exit().remove();
                                 if (isAngular) {
                                     drawAngularGauge(gd, plotGroup, cd, {
                                         radius,
                                         innerRadius,
                                         gauge: angularGauge,
                                         layer: angularaxisLayer,
-                                        size,
+                                        size: size2,
                                         gaugeBg,
                                         gaugeOutline,
                                         transitionOpts,
                                         onComplete
                                     });
                                 }
                                 var bulletGauge = plotGroup.selectAll("g.bullet").data(isBullet ? cd : []);
                                 bulletGauge.exit().remove();
                                 var bulletaxisLayer = plotGroup.selectAll("g.bulletaxis").data(isBullet ? cd : []);
                                 bulletaxisLayer.exit().remove();
                                 if (isBullet) {
                                     drawBulletGauge(gd, plotGroup, cd, {
                                         gauge: bulletGauge,
                                         layer: bulletaxisLayer,
-                                        size,
+                                        size: size2,
                                         gaugeBg,
                                         gaugeOutline,
                                         transitionOpts,
                                         onComplete
                                     });
                                 }
                                 var title = plotGroup.selectAll("text.title").data(cd);
                                 title.exit().remove();
                                 title.enter().append("text").classed("title", true);
                                 title.attr("text-anchor", function() {
                                     return isBullet ? anchor.right : anchor[trace.title.align];
                                 }).text(trace.title.text).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);
                                 title.attr("transform", function() {
-                                    var titleX = size.l + size.w * position2[trace.title.align];
+                                    var titleX = size2.l + size2.w * position2[trace.title.align];
                                     var titleY;
                                     var titlePadding = cn.titlePadding;
                                     var titlebBox = Drawing.bBox(title.node());
                                     if (hasGauge) {
                                         if (isAngular) {
                                             if (trace.gauge.axis.visible) {
                                                 var bBox = Drawing.bBox(angularaxisLayer.node());
                                                 titleY = bBox.top - titlePadding - titlebBox.bottom;
                                             } else {
-                                                titleY = size.t + size.h / 2 - radius / 2 - titlebBox.bottom - titlePadding;
+                                                titleY = size2.t + size2.h / 2 - radius / 2 - titlebBox.bottom - titlePadding;
                                             }
                                         }
                                         if (isBullet) {
                                             titleY = numbersY - (titlebBox.top + titlebBox.bottom) / 2;
-                                            titleX = size.l - cn.bulletPadding * size.w;
+                                            titleX = size2.l - cn.bulletPadding * size2.w;
                                         }
                                     } else {
                                         titleY = trace._numbersTop - titlePadding - titlebBox.bottom;
                                     }
                                     return strTranslate(titleX, titleY);
                                 });
                             });
@@ -142814,35 +143663,35 @@
 
                         function drawBulletGauge(gd, plotGroup, cd, opts) {
                             var trace = cd[0].trace;
                             var bullet = opts.gauge;
                             var axisLayer = opts.layer;
                             var gaugeBg = opts.gaugeBg;
                             var gaugeOutline = opts.gaugeOutline;
-                            var size = opts.size;
+                            var size2 = opts.size;
                             var domain2 = trace.domain;
                             var transitionOpts = opts.transitionOpts;
                             var onComplete = opts.onComplete;
                             var ax, vals, transFn, tickSign, shift2;
                             bullet.enter().append("g").classed("bullet", true);
-                            bullet.attr("transform", strTranslate(size.l, size.t));
+                            bullet.attr("transform", strTranslate(size2.l, size2.t));
                             axisLayer.enter().append("g").classed("bulletaxis", true).classed("crisp", true);
                             axisLayer.selectAll("g.xbulletaxistick,path,text").remove();
-                            var bulletHeight = size.h;
+                            var bulletHeight = size2.h;
                             var innerBulletHeight = trace.gauge.bar.thickness * bulletHeight;
                             var bulletLeft = domain2.x[0];
                             var bulletRight = domain2.x[0] + (domain2.x[1] - domain2.x[0]) * (trace._hasNumber || trace._hasDelta ? 1 - cn.bulletNumberDomainSize : 1);
                             ax = mockAxis(gd, trace.gauge.axis);
                             ax._id = "xbulletaxis";
                             ax.domain = [bulletLeft, bulletRight];
                             ax.setScale();
                             vals = Axes.calcTicks(ax);
                             transFn = Axes.makeTransTickFn(ax);
                             tickSign = Axes.getTickSigns(ax)[2];
-                            shift2 = size.t + size.h;
+                            shift2 = size2.t + size2.h;
                             if (ax.visible) {
                                 Axes.drawTicks(gd, ax, {
                                     vals: ax.ticks === "inside" ? Axes.clipEnds(ax, vals) : vals,
                                     layer: axisLayer,
                                     path: Axes.makeTickPath(ax, shift2, tickSign),
                                     transFn
                                 });
@@ -142894,20 +143743,20 @@
                             bulletOutline.enter().append("g").classed("gauge-outline", true).append("rect");
                             bulletOutline.select("rect").call(drawRect).call(styleShape);
                             bulletOutline.exit().remove();
                         }
 
                         function drawAngularGauge(gd, plotGroup, cd, opts) {
                             var trace = cd[0].trace;
-                            var size = opts.size;
+                            var size2 = opts.size;
                             var radius = opts.radius;
                             var innerRadius = opts.innerRadius;
                             var gaugeBg = opts.gaugeBg;
                             var gaugeOutline = opts.gaugeOutline;
-                            var gaugePosition = [size.l + size.w / 2, size.t + size.h / 2 + radius / 2];
+                            var gaugePosition = [size2.l + size2.w / 2, size2.t + size2.h / 2 + radius / 2];
                             var gauge = opts.gauge;
                             var axisLayer = opts.layer;
                             var transitionOpts = opts.transitionOpts;
                             var onComplete = opts.onComplete;
                             var theta = Math.PI / 2;
 
                             function valueToAngle(v3) {
@@ -142917,16 +143766,16 @@
                                 if (angle < -theta)
                                     return -theta;
                                 if (angle > theta)
                                     return theta;
                                 return angle;
                             }
 
-                            function arcPathGenerator(size2) {
-                                return d3.svg.arc().innerRadius((innerRadius + radius) / 2 - size2 / 2 * (radius - innerRadius)).outerRadius((innerRadius + radius) / 2 + size2 / 2 * (radius - innerRadius)).startAngle(-theta);
+                            function arcPathGenerator(size3) {
+                                return d3.svg.arc().innerRadius((innerRadius + radius) / 2 - size3 / 2 * (radius - innerRadius)).outerRadius((innerRadius + radius) / 2 + size3 / 2 * (radius - innerRadius)).startAngle(-theta);
                             }
 
                             function drawArc(p2) {
                                 p2.attr("d", function(d2) {
                                     return arcPathGenerator(d2.thickness).startAngle(valueToAngle(d2.range[0])).endAngle(valueToAngle(d2.range[1]))();
                                 });
                             }
@@ -147090,23 +147939,23 @@
                         }
                     },
                     45784: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var parcats = __webpack_require__2(45460);
                         module3.exports = function plot(graphDiv, parcatsModels, transitionOpts, makeOnCompleteCallback) {
                             var fullLayout = graphDiv._fullLayout;
                             var svg2 = fullLayout._paper;
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             parcats(graphDiv, svg2, parcatsModels, {
-                                width: size.w,
-                                height: size.h,
+                                width: size2.w,
+                                height: size2.h,
                                 margin: {
-                                    t: size.t,
-                                    r: size.r,
-                                    b: size.b,
-                                    l: size.l
+                                    t: size2.t,
+                                    r: size2.r,
+                                    b: size2.b,
+                                    l: size2.l
                                 }
                             }, transitionOpts, makeOnCompleteCallback);
                         };
                     },
                     73362: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var colorScaleAttrs = __webpack_require__2(50693);
                         var axesAttrs = __webpack_require__2(13838);
@@ -149046,15 +149895,15 @@
                             var success = prepareRegl(gd, [], reglPrecompiled);
                             if (!success)
                                 return;
                             var currentDims = {};
                             var initialDims = {};
                             var fullIndices = {};
                             var inputIndices = {};
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             cdModule.forEach(function(d2, i2) {
                                 var trace = d2[0].trace;
                                 fullIndices[i2] = trace.index;
                                 var iIn = inputIndices[i2] = trace._fullInput.index;
                                 currentDims[i2] = gd.data[iIn].dimensions;
                                 initialDims[i2] = gd.data[iIn].dimensions.slice();
                             });
@@ -149105,21 +149954,21 @@
                                 gd.emit("plotly_restyle", [{
                                         dimensions: [currentDims[i2]]
                                     },
                                     [inputIndices[i2]]
                                 ]);
                             };
                             parcoords(gd, cdModule, {
-                                width: size.w,
-                                height: size.h,
+                                width: size2.w,
+                                height: size2.h,
                                 margin: {
-                                    t: size.t,
-                                    r: size.r,
-                                    b: size.b,
-                                    l: size.l
+                                    t: size2.t,
+                                    r: size2.r,
+                                    b: size2.b,
+                                    l: size2.l
                                 }
                             }, {
                                 filterChanged,
                                 hover,
                                 unhover,
                                 axesMoved
                             });
@@ -150035,33 +150884,33 @@
                                 Fx.click(gd, d3.event);
                             });
                         }
 
                         function determineOutsideTextFont(trace, pt2, layoutFont) {
                             var color2 = helpers2.castOption(trace.outsidetextfont.color, pt2.pts) || helpers2.castOption(trace.textfont.color, pt2.pts) || layoutFont.color;
                             var family = helpers2.castOption(trace.outsidetextfont.family, pt2.pts) || helpers2.castOption(trace.textfont.family, pt2.pts) || layoutFont.family;
-                            var size = helpers2.castOption(trace.outsidetextfont.size, pt2.pts) || helpers2.castOption(trace.textfont.size, pt2.pts) || layoutFont.size;
+                            var size2 = helpers2.castOption(trace.outsidetextfont.size, pt2.pts) || helpers2.castOption(trace.textfont.size, pt2.pts) || layoutFont.size;
                             return {
                                 color: color2,
                                 family,
-                                size
+                                size: size2
                             };
                         }
 
                         function determineInsideTextFont(trace, pt2, layoutFont) {
                             var customColor = helpers2.castOption(trace.insidetextfont.color, pt2.pts);
                             if (!customColor && trace._input.textfont) {
                                 customColor = helpers2.castOption(trace._input.textfont.color, pt2.pts);
                             }
                             var family = helpers2.castOption(trace.insidetextfont.family, pt2.pts) || helpers2.castOption(trace.textfont.family, pt2.pts) || layoutFont.family;
-                            var size = helpers2.castOption(trace.insidetextfont.size, pt2.pts) || helpers2.castOption(trace.textfont.size, pt2.pts) || layoutFont.size;
+                            var size2 = helpers2.castOption(trace.insidetextfont.size, pt2.pts) || helpers2.castOption(trace.textfont.size, pt2.pts) || layoutFont.size;
                             return {
                                 color: customColor || Color2.contrast(pt2.color),
                                 family,
-                                size
+                                size: size2
                             };
                         }
 
                         function prerenderTitles(cdModule, gd) {
                             var cd0, trace;
                             for (var i2 = 0; i2 < cdModule.length; i2++) {
                                 cd0 = cdModule[i2][0];
@@ -151567,15 +152416,15 @@
                             var labelOpts = trace.hoverlabel || {};
                             var val = Lib.nestedProperty(labelOpts, attr).get();
                             return Array.isArray(val) ? false : val;
                         }
                         module3.exports = function plot(gd, calcData) {
                             var fullLayout = gd._fullLayout;
                             var svg2 = fullLayout._paper;
-                            var size = fullLayout._size;
+                            var size2 = fullLayout._size;
                             for (var i2 = 0; i2 < gd._fullData.length; i2++) {
                                 if (!gd._fullData[i2].visible)
                                     continue;
                                 if (gd._fullData[i2].type !== cn.sankey)
                                     continue;
                                 if (!gd._fullData[i2]._viewInitial) {
                                     var node2 = gd._fullData[i2].node;
@@ -151770,21 +152619,21 @@
                                         event: d3.event,
                                         points: [d2.node]
                                     });
                                 }
                                 Fx.loneUnhover(fullLayout._hoverlayer.node());
                             };
                             render2(gd, svg2, calcData, {
-                                width: size.w,
-                                height: size.h,
+                                width: size2.w,
+                                height: size2.h,
                                 margin: {
-                                    t: size.t,
-                                    r: size.r,
-                                    b: size.b,
-                                    l: size.l
+                                    t: size2.t,
+                                    r: size2.r,
+                                    b: size2.b,
+                                    l: size2.l
                                 }
                             }, {
                                 linkEvents: {
                                     hover: linkHover,
                                     follow: linkHoverFollow,
                                     unhover: linkUnhover,
                                     select: linkSelect
@@ -160761,15 +161610,15 @@
                             var gridBatches = [];
                             for (k2 in lookup2) {
                                 gridBatches.push(lookup2[k2]);
                             }
                             return gridBatches;
                         }
 
-                        function clean2(newFullData, newFullLayout, oldFullData, oldFullLayout) {
+                        function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
                             var lookup2 = {};
                             var i2;
                             if (oldFullLayout._splomScenes) {
                                 for (i2 = 0; i2 < newFullData.length; i2++) {
                                     var newTrace = newFullData[i2];
                                     if (newTrace.type === "splom") {
                                         lookup2[newTrace.uid] = 1;
@@ -160802,15 +161651,15 @@
                             attrRegex: Cartesian.attrRegex,
                             layoutAttributes: Cartesian.layoutAttributes,
                             supplyLayoutDefaults: Cartesian.supplyLayoutDefaults,
                             drawFramework: Cartesian.drawFramework,
                             plot,
                             drag,
                             updateGrid,
-                            clean: clean2,
+                            clean,
                             updateFx: Cartesian.updateFx,
                             toSVG: Cartesian.toSVG,
                             reglPrecompiled
                         };
                     },
                     87625: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var Lib = __webpack_require__2(71828);
@@ -166000,38 +166849,38 @@
                                     sliceText2.attr("transform", strTransform(pt2));
                                 }
                             });
                             return nextOfPrevEntry;
                         };
                     },
                     14102: function(module3) {
-                        module3.exports = function flipTree(node2, size, opts) {
+                        module3.exports = function flipTree(node2, size2, opts) {
                             var tmp;
                             if (opts.swapXY) {
                                 tmp = node2.x0;
                                 node2.x0 = node2.y0;
                                 node2.y0 = tmp;
                                 tmp = node2.x1;
                                 node2.x1 = node2.y1;
                                 node2.y1 = tmp;
                             }
                             if (opts.flipX) {
                                 tmp = node2.x0;
-                                node2.x0 = size[0] - node2.x1;
-                                node2.x1 = size[0] - tmp;
+                                node2.x0 = size2[0] - node2.x1;
+                                node2.x1 = size2[0] - tmp;
                             }
                             if (opts.flipY) {
                                 tmp = node2.y0;
-                                node2.y0 = size[1] - node2.y1;
-                                node2.y1 = size[1] - tmp;
+                                node2.y0 = size2[1] - node2.y1;
+                                node2.y1 = size2[1] - tmp;
                             }
                             var children2 = node2.children;
                             if (children2) {
                                 for (var i2 = 0; i2 < children2.length; i2++) {
-                                    flipTree(children2[i2], size, opts);
+                                    flipTree(children2[i2], size2, opts);
                                 }
                             }
                         };
                     },
                     70954: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         module3.exports = {
                             moduleType: "trace",
@@ -166074,15 +166923,15 @@
                             coerce2("treemapcolorway", layoutOut.colorway);
                             coerce2("extendtreemapcolors");
                         };
                     },
                     37210: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var d3Hierarchy = __webpack_require__2(674);
                         var flipTree = __webpack_require__2(14102);
-                        module3.exports = function partition(entry, size, opts) {
+                        module3.exports = function partition(entry, size2, opts) {
                             var flipX = opts.flipX;
                             var flipY = opts.flipY;
                             var swapXY = opts.packing === "dice-slice";
                             var top2 = opts.pad[flipY ? "bottom" : "top"];
                             var left2 = opts.pad[flipX ? "right" : "left"];
                             var right2 = opts.pad[flipX ? "left" : "right"];
                             var bottom2 = opts.pad[flipY ? "top" : "bottom"];
@@ -166091,17 +166940,17 @@
                                 tmp = left2;
                                 left2 = top2;
                                 top2 = tmp;
                                 tmp = right2;
                                 right2 = bottom2;
                                 bottom2 = tmp;
                             }
-                            var result = d3Hierarchy.treemap().tile(getTilingMethod(opts.packing, opts.squarifyratio)).paddingInner(opts.pad.inner).paddingLeft(left2).paddingRight(right2).paddingTop(top2).paddingBottom(bottom2).size(swapXY ? [size[1], size[0]] : size)(entry);
+                            var result = d3Hierarchy.treemap().tile(getTilingMethod(opts.packing, opts.squarifyratio)).paddingInner(opts.pad.inner).paddingLeft(left2).paddingRight(right2).paddingTop(top2).paddingBottom(bottom2).size(swapXY ? [size2[1], size2[0]] : size2)(entry);
                             if (swapXY || flipX || flipY) {
-                                flipTree(result, size, {
+                                flipTree(result, size2, {
                                     swapXY,
                                     flipX,
                                     flipY
                                 });
                             }
                             return result;
                         };
@@ -166179,15 +167028,15 @@
                             var barDifY = !trace.pathbar.visible ? 0 : trace.pathbar.side.indexOf("bottom") > -1 ? vph + barPad : -(barH + barPad);
                             var pathbarOrigin = {
                                 x0: barW,
                                 x1: barW,
                                 y0: barDifY,
                                 y1: barDifY + barH
                             };
-                            var findClosestEdge = function(pt2, ref2, size) {
+                            var findClosestEdge = function(pt2, ref2, size2) {
                                 var e3 = trace.tiling.pad;
                                 var isLeftOfRect = function(x2) {
                                     return x2 - e3 <= ref2.x0;
                                 };
                                 var isRightOfRect = function(x2) {
                                     return x2 + e3 >= ref2.x1;
                                 };
@@ -166202,34 +167051,34 @@
                                         x0: pt2.x0,
                                         x1: pt2.x1,
                                         y0: pt2.y0,
                                         y1: pt2.y1
                                     };
                                 }
                                 return {
-                                    x0: isLeftOfRect(pt2.x0 - e3) ? 0 : isRightOfRect(pt2.x0 - e3) ? size[0] : pt2.x0,
-                                    x1: isLeftOfRect(pt2.x1 + e3) ? 0 : isRightOfRect(pt2.x1 + e3) ? size[0] : pt2.x1,
-                                    y0: isBottomOfRect(pt2.y0 - e3) ? 0 : isTopOfRect(pt2.y0 - e3) ? size[1] : pt2.y0,
-                                    y1: isBottomOfRect(pt2.y1 + e3) ? 0 : isTopOfRect(pt2.y1 + e3) ? size[1] : pt2.y1
+                                    x0: isLeftOfRect(pt2.x0 - e3) ? 0 : isRightOfRect(pt2.x0 - e3) ? size2[0] : pt2.x0,
+                                    x1: isLeftOfRect(pt2.x1 + e3) ? 0 : isRightOfRect(pt2.x1 + e3) ? size2[0] : pt2.x1,
+                                    y0: isBottomOfRect(pt2.y0 - e3) ? 0 : isTopOfRect(pt2.y0 - e3) ? size2[1] : pt2.y0,
+                                    y1: isBottomOfRect(pt2.y1 + e3) ? 0 : isTopOfRect(pt2.y1 + e3) ? size2[1] : pt2.y1
                                 };
                             };
                             var prevEntry = null;
                             var prevLookupPathbar = {};
                             var prevLookupSlices = {};
                             var nextOfPrevEntry = null;
                             var getPrev = function(pt2, onPathbar) {
                                 return onPathbar ? prevLookupPathbar[getKey2(pt2)] : prevLookupSlices[getKey2(pt2)];
                             };
-                            var getOrigin = function(pt2, onPathbar, refRect, size) {
+                            var getOrigin = function(pt2, onPathbar, refRect, size2) {
                                 if (onPathbar) {
                                     return prevLookupPathbar[getKey2(hierarchy2)] || pathbarOrigin;
                                 } else {
                                     var ref2 = prevLookupSlices[trace.level] || refRect;
                                     if (hasVisibleDepth(pt2)) {
-                                        return findClosestEdge(pt2, ref2, size);
+                                        return findClosestEdge(pt2, ref2, size2);
                                     }
                                 }
                                 return {};
                             };
                             if (cd0.hasMultipleRoots && isRoot) {
                                 maxDepth++;
                             }
@@ -166417,43 +167266,43 @@
                                     if (Q2) {
                                         parentPrev = getPrev(Q2, onPathbar);
                                     } else
                                         i2 = maxDepth;
                                 }
                                 return parentPrev || {};
                             };
-                            var makeExitSliceInterpolator = function(pt2, onPathbar, refRect, size) {
+                            var makeExitSliceInterpolator = function(pt2, onPathbar, refRect, size2) {
                                 var prev = getPrev(pt2, onPathbar);
                                 var next2;
                                 if (onPathbar) {
                                     next2 = pathbarOrigin;
                                 } else {
                                     var entryPrev = getPrev(entry, onPathbar);
                                     if (entryPrev) {
-                                        next2 = findClosestEdge(pt2, entryPrev, size);
+                                        next2 = findClosestEdge(pt2, entryPrev, size2);
                                     } else {
                                         next2 = {};
                                     }
                                 }
                                 return interpolate2(prev, next2);
                             };
-                            var makeUpdateSliceInterpolator = function(pt2, onPathbar, refRect, size, opts) {
+                            var makeUpdateSliceInterpolator = function(pt2, onPathbar, refRect, size2, opts) {
                                 var prev0 = getPrev(pt2, onPathbar);
                                 var prev;
                                 if (prev0) {
                                     prev = prev0;
                                 } else {
                                     if (onPathbar) {
                                         prev = pathbarOrigin;
                                     } else {
                                         if (prevEntry) {
                                             if (pt2.parent) {
                                                 var ref2 = nextOfPrevEntry || refRect;
                                                 if (ref2 && !onPathbar) {
-                                                    prev = findClosestEdge(pt2, ref2, size);
+                                                    prev = findClosestEdge(pt2, ref2, size2);
                                                 } else {
                                                     prev = {};
                                                     Lib.extendFlat(prev, interpFromParent(pt2, onPathbar));
                                                 }
                                             } else {
                                                 prev = Lib.extendFlat({}, pt2);
                                                 if (isIcicle) {
@@ -166478,18 +167327,18 @@
                                 return interpolate2(prev, {
                                     x0: pt2.x0,
                                     x1: pt2.x1,
                                     y0: pt2.y0,
                                     y1: pt2.y1
                                 });
                             };
-                            var makeUpdateTextInterpolator = function(pt2, onPathbar, refRect, size) {
+                            var makeUpdateTextInterpolator = function(pt2, onPathbar, refRect, size2) {
                                 var prev0 = getPrev(pt2, onPathbar);
                                 var prev = {};
-                                var origin = getOrigin(pt2, onPathbar, refRect, size);
+                                var origin = getOrigin(pt2, onPathbar, refRect, size2);
                                 Lib.extendFlat(prev, {
                                     transform: toMoveInsideSlice({
                                         x0: origin.x0,
                                         x1: origin.x1,
                                         y0: origin.y0,
                                         y1: origin.y1,
                                         textBB: pt2.textBB,
@@ -166518,17 +167367,17 @@
                                         anchorX: transform.anchorX,
                                         anchorY: transform.anchorY,
                                         targetX: transform.targetX,
                                         targetY: transform.targetY
                                     }
                                 });
                             };
-                            var handleSlicesExit = function(slices, onPathbar, refRect, size, pathSlice) {
-                                var width = size[0];
-                                var height = size[1];
+                            var handleSlicesExit = function(slices, onPathbar, refRect, size2, pathSlice) {
+                                var width = size2[0];
+                                var height = size2[1];
                                 if (hasTransition) {
                                     slices.exit().transition().each(function() {
                                         var sliceTop = d3.select(this);
                                         var slicePath = sliceTop.select("path.surface");
                                         slicePath.transition().attrTween("d", function(pt2) {
                                             var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);
                                             return function(t2) {
@@ -167737,39 +168586,39 @@
 
                         function isTotal(a2) {
                             return a2 === "t" || a2 === "total";
                         }
                         module3.exports = function calc(gd, trace) {
                             var xa = Axes.getFromId(gd, trace.xaxis || "x");
                             var ya = Axes.getFromId(gd, trace.yaxis || "y");
-                            var size, pos, origPos, pObj, hasPeriod, pLetter;
+                            var size2, pos, origPos, pObj, hasPeriod, pLetter;
                             if (trace.orientation === "h") {
-                                size = xa.makeCalcdata(trace, "x");
+                                size2 = xa.makeCalcdata(trace, "x");
                                 origPos = ya.makeCalcdata(trace, "y");
                                 pObj = alignPeriod(trace, ya, "y", origPos);
                                 hasPeriod = !!trace.yperiodalignment;
                                 pLetter = "y";
                             } else {
-                                size = ya.makeCalcdata(trace, "y");
+                                size2 = ya.makeCalcdata(trace, "y");
                                 origPos = xa.makeCalcdata(trace, "x");
                                 pObj = alignPeriod(trace, xa, "x", origPos);
                                 hasPeriod = !!trace.xperiodalignment;
                                 pLetter = "x";
                             }
                             pos = pObj.vals;
-                            var serieslen = Math.min(pos.length, size.length);
+                            var serieslen = Math.min(pos.length, size2.length);
                             var cd = new Array(serieslen);
                             var previousSum = 0;
                             var newSize;
                             var hasTotals = false;
                             for (var i2 = 0; i2 < serieslen; i2++) {
-                                var amount = size[i2] || 0;
+                                var amount = size2[i2] || 0;
                                 var connectToNext = false;
-                                if (size[i2] !== BADNUM || isTotal(trace.measure[i2]) || isAbsolute(trace.measure[i2])) {
-                                    if (i2 + 1 < serieslen && (size[i2 + 1] !== BADNUM || isTotal(trace.measure[i2 + 1]) || isAbsolute(trace.measure[i2 + 1]))) {
+                                if (size2[i2] !== BADNUM || isTotal(trace.measure[i2]) || isAbsolute(trace.measure[i2])) {
+                                    if (i2 + 1 < serieslen && (size2[i2 + 1] !== BADNUM || isTotal(trace.measure[i2 + 1]) || isAbsolute(trace.measure[i2 + 1]))) {
                                         connectToNext = true;
                                     }
                                 }
                                 var cdi = cd[i2] = {
                                     i: i2,
                                     p: pos[i2],
                                     s: amount,
@@ -167988,20 +168837,20 @@
                             var vAxis = isHorizontal ? pointData.xa : pointData.ya;
 
                             function formatNumber2(a2) {
                                 return hoverLabelText(vAxis, a2, trace[vLetter + "hoverformat"]);
                             }
                             var index2 = point2.index;
                             var di = cd[index2];
-                            var size = di.isSum ? di.b + di.s : di.rawS;
-                            point2.initial = di.b + di.s - size;
-                            point2.delta = size;
+                            var size2 = di.isSum ? di.b + di.s : di.rawS;
+                            point2.initial = di.b + di.s - size2;
+                            point2.delta = size2;
                             point2.final = point2.initial + point2.delta;
                             var v2 = formatNumber2(Math.abs(point2.delta));
-                            point2.deltaLabel = size < 0 ? "(" + v2 + ")" : v2;
+                            point2.deltaLabel = size2 < 0 ? "(" + v2 + ")" : v2;
                             point2.finalLabel = formatNumber2(point2.final);
                             point2.initialLabel = formatNumber2(point2.initial);
                             var hoverinfo = di.hi || trace.hoverinfo;
                             var text2 = [];
                             if (hoverinfo && hoverinfo !== "none" && hoverinfo !== "skip") {
                                 var isAll = hoverinfo === "all";
                                 var parts = hoverinfo.split("+");
@@ -168009,15 +168858,15 @@
                                     return isAll || parts.indexOf(flag) !== -1;
                                 };
                                 if (!di.isSum) {
                                     if (hasFlag("final") && (isHorizontal ? !hasFlag("x") : !hasFlag("y"))) {
                                         text2.push(point2.finalLabel);
                                     }
                                     if (hasFlag("delta")) {
-                                        if (size < 0) {
+                                        if (size2 < 0) {
                                             text2.push(point2.deltaLabel + " " + DIRSYMBOL.decreasing);
                                         } else {
                                             text2.push(point2.deltaLabel + " " + DIRSYMBOL.increasing);
                                         }
                                     }
                                     if (hasFlag("initial")) {
                                         text2.push("Initial: " + point2.initialLabel);
@@ -169336,45 +170185,45 @@
                                         }
                                         Buffer2.from = function(value, encodingOrOffset, length) {
                                             return from(value, encodingOrOffset, length);
                                         };
                                         Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
                                         Object.setPrototypeOf(Buffer2, Uint8Array);
 
-                                        function assertSize(size) {
-                                            if (typeof size !== "number") {
+                                        function assertSize(size2) {
+                                            if (typeof size2 !== "number") {
                                                 throw new TypeError('"size" argument must be of type number');
-                                            } else if (size < 0) {
-                                                throw new RangeError('The value "' + size + '" is invalid for option "size"');
+                                            } else if (size2 < 0) {
+                                                throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
                                             }
                                         }
 
-                                        function alloc(size, fill, encoding) {
-                                            assertSize(size);
-                                            if (size <= 0) {
-                                                return createBuffer(size);
+                                        function alloc(size2, fill, encoding) {
+                                            assertSize(size2);
+                                            if (size2 <= 0) {
+                                                return createBuffer(size2);
                                             }
                                             if (fill !== void 0) {
-                                                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
+                                                return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
                                             }
-                                            return createBuffer(size);
+                                            return createBuffer(size2);
                                         }
-                                        Buffer2.alloc = function(size, fill, encoding) {
-                                            return alloc(size, fill, encoding);
+                                        Buffer2.alloc = function(size2, fill, encoding) {
+                                            return alloc(size2, fill, encoding);
                                         };
 
-                                        function allocUnsafe(size) {
-                                            assertSize(size);
-                                            return createBuffer(size < 0 ? 0 : checked(size) | 0);
+                                        function allocUnsafe(size2) {
+                                            assertSize(size2);
+                                            return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
                                         }
-                                        Buffer2.allocUnsafe = function(size) {
-                                            return allocUnsafe(size);
+                                        Buffer2.allocUnsafe = function(size2) {
+                                            return allocUnsafe(size2);
                                         };
-                                        Buffer2.allocUnsafeSlow = function(size) {
-                                            return allocUnsafe(size);
+                                        Buffer2.allocUnsafeSlow = function(size2) {
+                                            return allocUnsafe(size2);
                                         };
 
                                         function fromString(string2, encoding) {
                                             if (typeof encoding !== "string" || encoding === "") {
                                                 encoding = "utf8";
                                             }
                                             if (!Buffer2.isEncoding(encoding)) {
@@ -169508,34 +170357,34 @@
                                             var i2;
                                             if (length === void 0) {
                                                 length = 0;
                                                 for (i2 = 0; i2 < list2.length; ++i2) {
                                                     length += list2[i2].length;
                                                 }
                                             }
-                                            var buffer2 = Buffer2.allocUnsafe(length);
+                                            var buffer = Buffer2.allocUnsafe(length);
                                             var pos = 0;
                                             for (i2 = 0; i2 < list2.length; ++i2) {
                                                 var buf = list2[i2];
                                                 if (isInstance(buf, Uint8Array)) {
-                                                    if (pos + buf.length > buffer2.length) {
+                                                    if (pos + buf.length > buffer.length) {
                                                         if (!Buffer2.isBuffer(buf))
                                                             buf = Buffer2.from(buf);
-                                                        buf.copy(buffer2, pos);
+                                                        buf.copy(buffer, pos);
                                                     } else {
-                                                        Uint8Array.prototype.set.call(buffer2, buf, pos);
+                                                        Uint8Array.prototype.set.call(buffer, buf, pos);
                                                     }
                                                 } else if (!Buffer2.isBuffer(buf)) {
                                                     throw new TypeError('"list" argument must be an Array of Buffers');
                                                 } else {
-                                                    buf.copy(buffer2, pos);
+                                                    buf.copy(buffer, pos);
                                                 }
                                                 pos += buf.length;
                                             }
-                                            return buffer2;
+                                            return buffer;
                                         };
 
                                         function byteLength(string2, encoding) {
                                             if (Buffer2.isBuffer(string2)) {
                                                 return string2.length;
                                             }
                                             if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
@@ -169746,60 +170595,60 @@
                                             if (x2 < y2)
                                                 return -1;
                                             if (y2 < x2)
                                                 return 1;
                                             return 0;
                                         };
 
-                                        function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
-                                            if (buffer2.length === 0)
+                                        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
+                                            if (buffer.length === 0)
                                                 return -1;
                                             if (typeof byteOffset === "string") {
                                                 encoding = byteOffset;
                                                 byteOffset = 0;
                                             } else if (byteOffset > 2147483647) {
                                                 byteOffset = 2147483647;
                                             } else if (byteOffset < -2147483648) {
                                                 byteOffset = -2147483648;
                                             }
                                             byteOffset = +byteOffset;
                                             if (numberIsNaN(byteOffset)) {
-                                                byteOffset = dir ? 0 : buffer2.length - 1;
+                                                byteOffset = dir ? 0 : buffer.length - 1;
                                             }
                                             if (byteOffset < 0)
-                                                byteOffset = buffer2.length + byteOffset;
-                                            if (byteOffset >= buffer2.length) {
+                                                byteOffset = buffer.length + byteOffset;
+                                            if (byteOffset >= buffer.length) {
                                                 if (dir)
                                                     return -1;
                                                 else
-                                                    byteOffset = buffer2.length - 1;
+                                                    byteOffset = buffer.length - 1;
                                             } else if (byteOffset < 0) {
                                                 if (dir)
                                                     byteOffset = 0;
                                                 else
                                                     return -1;
                                             }
                                             if (typeof val === "string") {
                                                 val = Buffer2.from(val, encoding);
                                             }
                                             if (Buffer2.isBuffer(val)) {
                                                 if (val.length === 0) {
                                                     return -1;
                                                 }
-                                                return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
+                                                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                                             } else if (typeof val === "number") {
                                                 val = val & 255;
                                                 if (typeof Uint8Array.prototype.indexOf === "function") {
                                                     if (dir) {
-                                                        return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
+                                                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                                                     } else {
-                                                        return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
+                                                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                                                     }
                                                 }
-                                                return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
+                                                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                                             }
                                             throw new TypeError("val must be string, number or Buffer");
                                         }
 
                                         function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                                             var indexSize = 1;
                                             var arrLength = arr.length;
@@ -171060,43 +171909,43 @@
                                                 parts.push(lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "=");
                                             }
                                             return parts.join("");
                                         }
                                     },
                                     3187: function(__unused_webpack_module, exports4) {
                                         /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
-                                        exports4.read = function(buffer2, offset2, isLE, mLen, nBytes) {
+                                        exports4.read = function(buffer, offset2, isLE, mLen, nBytes) {
                                             var e3, m2;
                                             var eLen = nBytes * 8 - mLen - 1;
                                             var eMax = (1 << eLen) - 1;
                                             var eBias = eMax >> 1;
                                             var nBits = -7;
                                             var i2 = isLE ? nBytes - 1 : 0;
                                             var d2 = isLE ? -1 : 1;
-                                            var s2 = buffer2[offset2 + i2];
+                                            var s2 = buffer[offset2 + i2];
                                             i2 += d2;
                                             e3 = s2 & (1 << -nBits) - 1;
                                             s2 >>= -nBits;
                                             nBits += eLen;
-                                            for (; nBits > 0; e3 = e3 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {}
+                                            for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {}
                                             m2 = e3 & (1 << -nBits) - 1;
                                             e3 >>= -nBits;
                                             nBits += mLen;
-                                            for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {}
+                                            for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {}
                                             if (e3 === 0) {
                                                 e3 = 1 - eBias;
                                             } else if (e3 === eMax) {
                                                 return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
                                             } else {
                                                 m2 = m2 + Math.pow(2, mLen);
                                                 e3 = e3 - eBias;
                                             }
                                             return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
                                         };
-                                        exports4.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
+                                        exports4.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
                                             var e3, m2, c2;
                                             var eLen = nBytes * 8 - mLen - 1;
                                             var eMax = (1 << eLen) - 1;
                                             var eBias = eMax >> 1;
                                             var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                                             var i2 = isLE ? 0 : nBytes - 1;
                                             var d2 = isLE ? 1 : -1;
@@ -171127,19 +171976,19 @@
                                                     m2 = (value * c2 - 1) * Math.pow(2, mLen);
                                                     e3 = e3 + eBias;
                                                 } else {
                                                     m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                                                     e3 = 0;
                                                 }
                                             }
-                                            for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {}
+                                            for (; mLen >= 8; buffer[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {}
                                             e3 = e3 << mLen | m2;
                                             eLen += mLen;
-                                            for (; eLen > 0; buffer2[offset2 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {}
-                                            buffer2[offset2 + i2 - d2] |= s2 * 128;
+                                            for (; eLen > 0; buffer[offset2 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {}
+                                            buffer[offset2 + i2 - d2] |= s2 * 128;
                                         };
                                     },
                                     1152: function(module4, __unused_webpack_exports2, __nested_webpack_require_58199__) {
                                         module4.exports = createViewController;
                                         var createTurntable = __nested_webpack_require_58199__(3440);
                                         var createOrbit = __nested_webpack_require_58199__(7774);
                                         var createMatrix = __nested_webpack_require_58199__(9298);
@@ -171281,16 +172130,16 @@
                                         var weakMap = typeof WeakMap === "undefined" ? __nested_webpack_require_61625__(5346) : WeakMap;
                                         var createBuffer = __nested_webpack_require_61625__(5827);
                                         var createVAO = __nested_webpack_require_61625__(2944);
                                         var TriangleCache = new weakMap();
 
                                         function createABigTriangle(gl2) {
                                             var triangleVAO = TriangleCache.get(gl2);
-                                            var handle = triangleVAO && (triangleVAO._triangleBuffer.handle || triangleVAO._triangleBuffer.buffer);
-                                            if (!handle || !gl2.isBuffer(handle)) {
+                                            var handle2 = triangleVAO && (triangleVAO._triangleBuffer.handle || triangleVAO._triangleBuffer.buffer);
+                                            if (!handle2 || !gl2.isBuffer(handle2)) {
                                                 var buf = createBuffer(gl2, new Float32Array([-1, -1, -1, 4, 4, -1]));
                                                 triangleVAO = createVAO(gl2, [{
                                                     buffer: buf,
                                                     type: gl2.FLOAT,
                                                     size: 2
                                                 }]);
                                                 triangleVAO._triangleBuffer = buf;
@@ -172224,16 +173073,16 @@
                                                 dest.red = this.red;
                                             };
                                             BN.prototype.clone = function clone2() {
                                                 var r2 = new BN(null);
                                                 this.copy(r2);
                                                 return r2;
                                             };
-                                            BN.prototype._expand = function _expand(size) {
-                                                while (this.length < size) {
+                                            BN.prototype._expand = function _expand(size2) {
+                                                while (this.length < size2) {
                                                     this.words[this.length++] = 0;
                                                 }
                                                 return this;
                                             };
                                             BN.prototype.strip = function strip() {
                                                 while (this.length > 1 && this.words[this.length - 1] === 0) {
                                                     this.length--;
@@ -178731,30 +179580,30 @@
                                                 module4.exports.hi = highUintBE;
                                             } else {
                                                 hasTypedArrays = false;
                                             }
                                         }
                                         if (!hasTypedArrays) {
                                             let toDouble = function(lo2, hi) {
-                                                    buffer2.writeUInt32LE(lo2, 0, true);
-                                                    buffer2.writeUInt32LE(hi, 4, true);
-                                                    return buffer2.readDoubleLE(0, true);
+                                                    buffer.writeUInt32LE(lo2, 0, true);
+                                                    buffer.writeUInt32LE(hi, 4, true);
+                                                    return buffer.readDoubleLE(0, true);
                                                 },
                                                 lowUint = function(n2) {
-                                                    buffer2.writeDoubleLE(n2, 0, true);
-                                                    return buffer2.readUInt32LE(0, true);
+                                                    buffer.writeDoubleLE(n2, 0, true);
+                                                    return buffer.readUInt32LE(0, true);
                                                 },
                                                 highUint = function(n2) {
-                                                    buffer2.writeDoubleLE(n2, 0, true);
-                                                    return buffer2.readUInt32LE(4, true);
+                                                    buffer.writeDoubleLE(n2, 0, true);
+                                                    return buffer.readUInt32LE(4, true);
                                                 };
-                                            var buffer2 = new Buffer(8);
+                                            var buffer = new Buffer(8);
                                             module4.exports = function doubleBits(n2) {
-                                                buffer2.writeDoubleLE(n2, 0, true);
-                                                return [buffer2.readUInt32LE(0, true), buffer2.readUInt32LE(4, true)];
+                                                buffer.writeDoubleLE(n2, 0, true);
+                                                return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
                                             };
                                             module4.exports.pack = toDouble;
                                             module4.exports.lo = lowUint;
                                             module4.exports.hi = highUint;
                                         }
                                         module4.exports.sign = function(n2) {
                                             return module4.exports.hi(n2) >>> 31;
@@ -180528,17 +181377,17 @@
                                     },
                                     1011: function(module4, __unused_webpack_exports2, __nested_webpack_require_248714__) {
                                         module4.exports = createBackgroundCube;
                                         var createBuffer = __nested_webpack_require_248714__(5827);
                                         var createVAO = __nested_webpack_require_248714__(2944);
                                         var createShader = __nested_webpack_require_248714__(1943).bg;
 
-                                        function BackgroundCube(gl2, buffer2, vao, shader) {
+                                        function BackgroundCube(gl2, buffer, vao, shader) {
                                             this.gl = gl2;
-                                            this.buffer = buffer2;
+                                            this.buffer = buffer;
                                             this.vao = vao;
                                             this.shader = shader;
                                         }
                                         var proto2 = BackgroundCube.prototype;
                                         proto2.draw = function(model, view, projection, bounds2, enable, colors2) {
                                             var needsBG = false;
                                             for (var i2 = 0; i2 < 3; ++i2) {
@@ -180592,33 +181441,33 @@
                                                         }
                                                     }
                                                     var tt2 = u2;
                                                     u2 = v2;
                                                     v2 = tt2;
                                                 }
                                             }
-                                            var buffer2 = createBuffer(gl2, new Float32Array(vertices));
+                                            var buffer = createBuffer(gl2, new Float32Array(vertices));
                                             var elements = createBuffer(gl2, new Uint16Array(indices2), gl2.ELEMENT_ARRAY_BUFFER);
                                             var vao = createVAO(gl2, [{
-                                                buffer: buffer2,
+                                                buffer,
                                                 type: gl2.FLOAT,
                                                 size: 3,
                                                 offset: 0,
                                                 stride: 24
                                             }, {
-                                                buffer: buffer2,
+                                                buffer,
                                                 type: gl2.FLOAT,
                                                 size: 3,
                                                 offset: 12,
                                                 stride: 24
                                             }], elements);
                                             var shader = createShader(gl2);
                                             shader.attributes.position.location = 0;
                                             shader.attributes.normal.location = 1;
-                                            return new BackgroundCube(gl2, buffer2, vao, shader);
+                                            return new BackgroundCube(gl2, buffer, vao, shader);
                                         }
                                     },
                                     2864: function(module4, __unused_webpack_exports2, __nested_webpack_require_250569__) {
                                         module4.exports = getCubeEdges;
                                         var bits = __nested_webpack_require_250569__(2288);
                                         var multiply = __nested_webpack_require_250569__(104);
                                         var splitPoly = __nested_webpack_require_250569__(4670);
@@ -181021,18 +181870,18 @@
                                         var vectorizeText = __nested_webpack_require_265252__(875);
                                         var createShader = __nested_webpack_require_265252__(1943).f;
                                         var globals2 = window || process2.global || {};
                                         var __TEXT_CACHE = globals2.__TEXT_CACHE || {};
                                         globals2.__TEXT_CACHE = {};
                                         var VERTEX_SIZE = 3;
 
-                                        function TextSprites(gl2, shader, buffer2, vao) {
+                                        function TextSprites(gl2, shader, buffer, vao) {
                                             this.gl = gl2;
                                             this.shader = shader;
-                                            this.buffer = buffer2;
+                                            this.buffer = buffer;
                                             this.vao = vao;
                                             this.tickOffset = this.tickCount = this.labelOffset = this.labelCount = null;
                                         }
                                         var proto2 = TextSprites.prototype;
                                         var SHAPE = [0, 0];
                                         proto2.bind = function(model, view, projection, pixelScale) {
                                             this.vao.bind();
@@ -181048,15 +181897,15 @@
                                         };
                                         proto2.unbind = function() {
                                             this.vao.unbind();
                                         };
                                         proto2.update = function(bounds2, labels, labelFont, ticks2, tickFont) {
                                             var data2 = [];
 
-                                            function addItem(t2, text2, font, size, lineSpacing2, styletags2) {
+                                            function addItem(t2, text2, font, size2, lineSpacing2, styletags2) {
                                                 var fontcache = __TEXT_CACHE[font];
                                                 if (!fontcache) {
                                                     fontcache = __TEXT_CACHE[font] = {};
                                                 }
                                                 var mesh = fontcache[text2];
                                                 if (!mesh) {
                                                     mesh = fontcache[text2] = tryVectorizeText(text2, {
@@ -181064,15 +181913,15 @@
                                                         font,
                                                         textAlign: "center",
                                                         textBaseline: "middle",
                                                         lineSpacing: lineSpacing2,
                                                         styletags: styletags2
                                                     });
                                                 }
-                                                var scale = (size || 12) / 12;
+                                                var scale = (size2 || 12) / 12;
                                                 var positions = mesh.positions;
                                                 var cells2 = mesh.cells;
                                                 for (var i3 = 0, nc = cells2.length; i3 < nc; ++i3) {
                                                     var c2 = cells2[i3];
                                                     for (var j2 = 2; j2 >= 0; --j2) {
                                                         var p2 = positions[c2[j2]];
                                                         data2.push(scale * p2[0], -scale * p2[1], t2);
@@ -181158,22 +182007,22 @@
                                                     cells: [],
                                                     positions: []
                                                 };
                                             }
                                         }
 
                                         function createTextSprites(gl2, bounds2, labels, labelFont, ticks2, tickFont) {
-                                            var buffer2 = createBuffer(gl2);
+                                            var buffer = createBuffer(gl2);
                                             var vao = createVAO(gl2, [{
-                                                "buffer": buffer2,
+                                                "buffer": buffer,
                                                 "size": 3
                                             }]);
                                             var shader = createShader(gl2);
                                             shader.attributes.position.location = 0;
-                                            var result = new TextSprites(gl2, shader, buffer2, vao);
+                                            var result = new TextSprites(gl2, shader, buffer, vao);
                                             result.update(bounds2, labels, labelFont, ticks2, tickFont);
                                             return result;
                                         }
                                     },
                                     8468: function(__unused_webpack_module, exports4) {
                                         exports4.create = defaultTicks;
                                         exports4.equal = ticksEqual;
@@ -181360,18 +182209,18 @@
                                     },
                                     5827: function(module4, __unused_webpack_exports2, __nested_webpack_require_273777__) {
                                         var pool = __nested_webpack_require_273777__(5306);
                                         var ops = __nested_webpack_require_273777__(7498);
                                         var ndarray = __nested_webpack_require_273777__(5050);
                                         var SUPPORTED_TYPES = ["uint8", "uint8_clamped", "uint16", "uint32", "int8", "int16", "int32", "float32"];
 
-                                        function GLBuffer2(gl2, type2, handle, length, usage) {
+                                        function GLBuffer2(gl2, type2, handle2, length, usage) {
                                             this.gl = gl2;
                                             this.type = type2;
-                                            this.handle = handle;
+                                            this.handle = handle2;
                                             this.length = length;
                                             this.usage = usage;
                                         }
                                         var proto2 = GLBuffer2.prototype;
                                         proto2.bind = function() {
                                             this.gl.bindBuffer(this.type, this.handle);
                                         };
@@ -181484,16 +182333,16 @@
                                             usage = usage || gl2.DYNAMIC_DRAW;
                                             if (type2 !== gl2.ARRAY_BUFFER && type2 !== gl2.ELEMENT_ARRAY_BUFFER) {
                                                 throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER");
                                             }
                                             if (usage !== gl2.DYNAMIC_DRAW && usage !== gl2.STATIC_DRAW && usage !== gl2.STREAM_DRAW) {
                                                 throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW");
                                             }
-                                            var handle = gl2.createBuffer();
-                                            var result = new GLBuffer2(gl2, type2, handle, 0, usage);
+                                            var handle2 = gl2.createBuffer();
+                                            var result = new GLBuffer2(gl2, type2, handle2, 0, usage);
                                             result.update(data2);
                                             return result;
                                         }
                                         module4.exports = createBuffer;
                                     },
                                     1140: function(module4, __unused_webpack_exports2, __nested_webpack_require_277599__) {
                                         var vec3 = __nested_webpack_require_277599__(2858);
@@ -182396,18 +183245,18 @@
                                     3110: function(module4, __unused_webpack_exports2, __nested_webpack_require_309464__) {
                                         module4.exports = createErrorBars;
                                         var createBuffer = __nested_webpack_require_309464__(5827);
                                         var createVAO = __nested_webpack_require_309464__(2944);
                                         var createShader = __nested_webpack_require_309464__(7667);
                                         var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
 
-                                        function ErrorBars(gl2, buffer2, vao, shader) {
+                                        function ErrorBars(gl2, buffer, vao, shader) {
                                             this.gl = gl2;
                                             this.shader = shader;
-                                            this.buffer = buffer2;
+                                            this.buffer = buffer;
                                             this.vao = vao;
                                             this.pixelRatio = 1;
                                             this.bounds = [
                                                 [Infinity, Infinity, Infinity],
                                                 [-Infinity, -Infinity, -Infinity]
                                             ];
                                             this.clipBounds = [
@@ -182575,39 +183424,39 @@
                                             this.shader.dispose();
                                             this.buffer.dispose();
                                             this.vao.dispose();
                                         };
 
                                         function createErrorBars(options) {
                                             var gl2 = options.gl;
-                                            var buffer2 = createBuffer(gl2);
+                                            var buffer = createBuffer(gl2);
                                             var vao = createVAO(gl2, [{
-                                                buffer: buffer2,
+                                                buffer,
                                                 type: gl2.FLOAT,
                                                 size: 3,
                                                 offset: 0,
                                                 stride: 40
                                             }, {
-                                                buffer: buffer2,
+                                                buffer,
                                                 type: gl2.FLOAT,
                                                 size: 4,
                                                 offset: 12,
                                                 stride: 40
                                             }, {
-                                                buffer: buffer2,
+                                                buffer,
                                                 type: gl2.FLOAT,
                                                 size: 3,
                                                 offset: 28,
                                                 stride: 40
                                             }]);
                                             var shader = createShader(gl2);
                                             shader.attributes.position.location = 0;
                                             shader.attributes.color.location = 1;
                                             shader.attributes.offset.location = 2;
-                                            var result = new ErrorBars(gl2, buffer2, vao, shader);
+                                            var result = new ErrorBars(gl2, buffer, vao, shader);
                                             result.update(options);
                                             return result;
                                         }
                                     },
                                     7667: function(module4, __unused_webpack_exports2, __nested_webpack_require_314103__) {
                                         var glslify = __nested_webpack_require_314103__(6832);
                                         var createShader = __nested_webpack_require_314103__(5158);
@@ -182698,23 +183547,23 @@
                                             gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, attachment, gl2.RENDERBUFFER, result);
                                             return result;
                                         }
 
                                         function rebuildFBO(fbo) {
                                             var state = saveFBOState(fbo.gl);
                                             var gl2 = fbo.gl;
-                                            var handle = fbo.handle = gl2.createFramebuffer();
+                                            var handle2 = fbo.handle = gl2.createFramebuffer();
                                             var width = fbo._shape[0];
                                             var height = fbo._shape[1];
                                             var numColors = fbo.color.length;
                                             var ext = fbo._ext;
                                             var useStencil = fbo._useStencil;
                                             var useDepth = fbo._useDepth;
                                             var colorType = fbo._colorType;
-                                            gl2.bindFramebuffer(gl2.FRAMEBUFFER, handle);
+                                            gl2.bindFramebuffer(gl2.FRAMEBUFFER, handle2);
                                             for (var i2 = 0; i2 < numColors; ++i2) {
                                                 fbo.color[i2] = initTexture(gl2, width, height, colorType, gl2.RGBA, gl2.COLOR_ATTACHMENT0 + i2);
                                             }
                                             if (numColors === 0) {
                                                 fbo._color_rb = initRenderBuffer(gl2, width, height, gl2.RGBA4, gl2.COLOR_ATTACHMENT0);
                                                 if (ext) {
                                                     ext.drawBuffersWEBGL(colorAttachmentArrays[0]);
@@ -183370,19 +184219,19 @@
                                         function PickResult(tau, position2, index2, dataCoordinate) {
                                             this.arcLength = tau;
                                             this.position = position2;
                                             this.index = index2;
                                             this.dataCoordinate = dataCoordinate;
                                         }
 
-                                        function LinePlot(gl2, shader, pickShader, buffer2, vao, texture) {
+                                        function LinePlot(gl2, shader, pickShader, buffer, vao, texture) {
                                             this.gl = gl2;
                                             this.shader = shader;
                                             this.pickShader = pickShader;
-                                            this.buffer = buffer2;
+                                            this.buffer = buffer;
                                             this.vao = vao;
                                             this.clipBounds = [
                                                 [-Infinity, -Infinity, -Infinity],
                                                 [Infinity, Infinity, Infinity]
                                             ];
                                             this.points = [];
                                             this.arcLength = [];
@@ -183463,15 +184312,15 @@
                                             this.hasAlpha = false;
                                             if ("opacity" in options) {
                                                 this.opacity = +options.opacity;
                                                 if (this.opacity < 1) {
                                                     this.hasAlpha = true;
                                                 }
                                             }
-                                            var buffer2 = [];
+                                            var buffer = [];
                                             var arcLengthArray = [];
                                             var pointArray = [];
                                             var arcLength = 0;
                                             var vertexCount = 0;
                                             var bounds2 = [
                                                 [Infinity, Infinity, Infinity],
                                                 [-Infinity, -Infinity, -Infinity]
@@ -183485,17 +184334,17 @@
                                                     for (i2 = 1; i2 < positions.length; ++i2) {
                                                         var a2 = positions[i2 - 1];
                                                         var b2 = positions[i2];
                                                         arcLengthArray.push(arcLength);
                                                         pointArray.push(a2.slice());
                                                         for (j2 = 0; j2 < 3; ++j2) {
                                                             if (isNaN(a2[j2]) || isNaN(b2[j2]) || !isFinite(a2[j2]) || !isFinite(b2[j2])) {
-                                                                if (!connectGaps && buffer2.length > 0) {
+                                                                if (!connectGaps && buffer.length > 0) {
                                                                     for (var k2 = 0; k2 < 24; ++k2) {
-                                                                        buffer2.push(buffer2[buffer2.length - 12]);
+                                                                        buffer.push(buffer[buffer.length - 12]);
                                                                     }
                                                                     vertexCount += 2;
                                                                     hadGap = true;
                                                                 }
                                                                 continue fill_loop;
                                                             }
                                                             bounds2[0][j2] = Math.min(bounds2[0][j2], a2[j2], b2[j2]);
@@ -183522,24 +184371,24 @@
                                                         } else {
                                                             w0 = lineWidth;
                                                         }
                                                         var t0 = arcLength;
                                                         arcLength += distance(a2, b2);
                                                         if (hadGap) {
                                                             for (j2 = 0; j2 < 2; ++j2) {
-                                                                buffer2.push(a2[0], a2[1], a2[2], b2[0], b2[1], b2[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3]);
+                                                                buffer.push(a2[0], a2[1], a2[2], b2[0], b2[1], b2[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3]);
                                                             }
                                                             vertexCount += 2;
                                                             hadGap = false;
                                                         }
-                                                        buffer2.push(a2[0], a2[1], a2[2], b2[0], b2[1], b2[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3], a2[0], a2[1], a2[2], b2[0], b2[1], b2[2], t0, -w0, acolor[0], acolor[1], acolor[2], acolor[3], b2[0], b2[1], b2[2], a2[0], a2[1], a2[2], arcLength, -w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3], b2[0], b2[1], b2[2], a2[0], a2[1], a2[2], arcLength, w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3]);
+                                                        buffer.push(a2[0], a2[1], a2[2], b2[0], b2[1], b2[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3], a2[0], a2[1], a2[2], b2[0], b2[1], b2[2], t0, -w0, acolor[0], acolor[1], acolor[2], acolor[3], b2[0], b2[1], b2[2], a2[0], a2[1], a2[2], arcLength, -w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3], b2[0], b2[1], b2[2], a2[0], a2[1], a2[2], arcLength, w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3]);
                                                         vertexCount += 4;
                                                     }
                                             }
-                                            this.buffer.update(buffer2);
+                                            this.buffer.update(buffer);
                                             arcLengthArray.push(arcLength);
                                             pointArray.push(positions[positions.length - 1].slice());
                                             this.bounds = bounds2;
                                             this.vertexCount = vertexCount;
                                             this.points = pointArray;
                                             this.arcLength = arcLengthArray;
                                             if ("dashes" in options) {
@@ -183605,48 +184454,48 @@
                                             shader.attributes.color.location = 4;
                                             var pickShader = createPickShader(gl2);
                                             pickShader.attributes.position.location = 0;
                                             pickShader.attributes.nextPosition.location = 1;
                                             pickShader.attributes.arcLength.location = 2;
                                             pickShader.attributes.lineWidth.location = 3;
                                             pickShader.attributes.color.location = 4;
-                                            var buffer2 = createBuffer(gl2);
+                                            var buffer = createBuffer(gl2);
                                             var vao = createVAO(gl2, [{
-                                                "buffer": buffer2,
+                                                "buffer": buffer,
                                                 "size": 3,
                                                 "offset": 0,
                                                 "stride": 48
                                             }, {
-                                                "buffer": buffer2,
+                                                "buffer": buffer,
                                                 "size": 3,
                                                 "offset": 12,
                                                 "stride": 48
                                             }, {
-                                                "buffer": buffer2,
+                                                "buffer": buffer,
                                                 "size": 1,
                                                 "offset": 24,
                                                 "stride": 48
                                             }, {
-                                                "buffer": buffer2,
+                                                "buffer": buffer,
                                                 "size": 1,
                                                 "offset": 28,
                                                 "stride": 48
                                             }, {
-                                                "buffer": buffer2,
+                                                "buffer": buffer,
                                                 "size": 4,
                                                 "offset": 32,
                                                 "stride": 48
                                             }]);
                                             var defaultTexture = ndarray(new Array(256 * 4), [256, 1, 4]);
                                             for (var i2 = 0; i2 < 256 * 4; ++i2) {
                                                 defaultTexture.data[i2] = 255;
                                             }
                                             var texture = createTexture2(gl2, defaultTexture);
                                             texture.wrap = gl2.REPEAT;
-                                            var linePlot = new LinePlot(gl2, shader, pickShader, buffer2, vao, texture);
+                                            var linePlot = new LinePlot(gl2, shader, pickShader, buffer, vao, texture);
                                             linePlot.update(options);
                                             return linePlot;
                                         }
                                     },
                                     7332: function(module4) {
                                         module4.exports = clone2;
 
@@ -185508,19 +186357,19 @@
                                                 var offset2 = 0;
                                                 for (var i2 = 0; i2 < 2; ++i2) {
                                                     DATA_AXIS[0] = DATA_AXIS[1] = 0;
                                                     DATA_AXIS[i2] = 1;
                                                     shader.uniforms.dataAxis = DATA_AXIS;
                                                     shader.uniforms.lineWidth = lineWidth[i2] / (viewPixels[i2 + 2] - viewPixels[i2]) * pixelRatio;
                                                     shader.uniforms.color = gridColor[i2];
-                                                    var size = ticks2[i2].length * 6;
-                                                    if (gridEnable[i2] && size) {
-                                                        gl2.drawArrays(gl2.TRIANGLES, offset2, size);
+                                                    var size2 = ticks2[i2].length * 6;
+                                                    if (gridEnable[i2] && size2) {
+                                                        gl2.drawArrays(gl2.TRIANGLES, offset2, size2);
                                                     }
-                                                    offset2 += size;
+                                                    offset2 += size2;
                                                 }
                                             };
                                         }();
                                         proto2.drawTickMarks = function() {
                                             var DATA_SHIFT = [0, 0];
                                             var DATA_SCALE = [0, 0];
                                             var X_AXIS = [1, 0];
@@ -187495,19 +188344,19 @@
                                                 pointId,
                                                 dataCoord: [points[2 * pointId], points[2 * pointId + 1]]
                                             };
                                         };
 
                                         function createPointcloud2D(plot, options) {
                                             var gl2 = plot.gl;
-                                            var buffer2 = createBuffer(gl2);
+                                            var buffer = createBuffer(gl2);
                                             var pickBuffer = createBuffer(gl2);
                                             var shader = createShader(gl2, SHADERS.pointVertex, SHADERS.pointFragment);
                                             var pickShader = createShader(gl2, SHADERS.pickVertex, SHADERS.pickFragment);
-                                            var result = new Pointcloud2D(plot, buffer2, pickBuffer, shader, pickShader);
+                                            var result = new Pointcloud2D(plot, buffer, pickBuffer, shader, pickShader);
                                             result.update(options);
                                             plot.addObject(result);
                                             return result;
                                         }
                                     },
                                     6093: function(module4) {
                                         module4.exports = slerp;
@@ -188218,27 +189067,27 @@
                                                                 if (!this.hasAlpha && c2[3] < 1)
                                                                     this.hasAlpha = true;
                                                             }
                                                         } else {
                                                             lineColor[0] = lineColor[1] = lineColor[2] = 0;
                                                             lineColor[3] = 1;
                                                         }
-                                                        var size = 0.5;
+                                                        var size2 = 0.5;
                                                         if (!glyphVisible)
-                                                            size = 0;
+                                                            size2 = 0;
                                                         else if (Array.isArray(sizes)) {
                                                             if (i2 < sizes.length) {
-                                                                size = +sizes[i2];
+                                                                size2 = +sizes[i2];
                                                             } else {
-                                                                size = 12;
+                                                                size2 = 12;
                                                             }
                                                         } else if (sizes) {
-                                                            size = +sizes;
+                                                            size2 = +sizes;
                                                         } else if (this.useOrtho) {
-                                                            size = 12;
+                                                            size2 = 12;
                                                         }
                                                         var angle = 0;
                                                         if (Array.isArray(angles)) {
                                                             if (i2 < angles.length) {
                                                                 angle = +angles[i2];
                                                             } else {
                                                                 angle = 0;
@@ -188287,16 +189136,16 @@
                                                                     positionArray[3 * triOffset + l2] = x2[l2];
                                                                 }
                                                                 for (var l2 = 0; l2 < 4; ++l2) {
                                                                     colorArray[4 * triOffset + l2] = color2[l2];
                                                                 }
                                                                 idArray[triOffset] = pickCounter;
                                                                 var p2 = verts2[cell[k2]];
-                                                                glyphArray[2 * triOffset] = size * (cos2 * p2[0] - sin2 * p2[1] + textOffset[0]);
-                                                                glyphArray[2 * triOffset + 1] = size * (sin2 * p2[0] + cos2 * p2[1] + textOffset[1]);
+                                                                glyphArray[2 * triOffset] = size2 * (cos2 * p2[0] - sin2 * p2[1] + textOffset[0]);
+                                                                glyphArray[2 * triOffset + 1] = size2 * (sin2 * p2[0] + cos2 * p2[1] + textOffset[1]);
                                                                 triOffset += 1;
                                                             }
                                                         }
                                                         var cells2 = glyphLines.edges;
                                                         var verts2 = glyphLines.positions;
                                                         for (var j2 = 0; j2 < cells2.length; ++j2) {
                                                             var cell = cells2[j2];
@@ -188305,16 +189154,16 @@
                                                                     positionArray[3 * lineOffset + l2] = x2[l2];
                                                                 }
                                                                 for (var l2 = 0; l2 < 4; ++l2) {
                                                                     colorArray[4 * lineOffset + l2] = lineColor[l2];
                                                                 }
                                                                 idArray[lineOffset] = pickCounter;
                                                                 var p2 = verts2[cell[k2]];
-                                                                glyphArray[2 * lineOffset] = size * (cos2 * p2[0] - sin2 * p2[1] + textOffset[0]);
-                                                                glyphArray[2 * lineOffset + 1] = size * (sin2 * p2[0] + cos2 * p2[1] + textOffset[1]);
+                                                                glyphArray[2 * lineOffset] = size2 * (cos2 * p2[0] - sin2 * p2[1] + textOffset[0]);
+                                                                glyphArray[2 * lineOffset + 1] = size2 * (sin2 * p2[0] + cos2 * p2[1] + textOffset[1]);
                                                                 lineOffset += 1;
                                                             }
                                                         }
                                                     }
                                             }
                                             this.bounds = [lowerBound, upperBound];
                                             this.points = points;
@@ -188464,17 +189313,17 @@
                                             this.boxBuffer.dispose();
                                             this.boxShader.dispose();
                                             this.plot.removeOverlay(this);
                                         };
 
                                         function createSelectBox(plot, options) {
                                             var gl2 = plot.gl;
-                                            var buffer2 = createBuffer(gl2, [0, 0, 0, 1, 1, 0, 1, 1]);
+                                            var buffer = createBuffer(gl2, [0, 0, 0, 1, 1, 0, 1, 1]);
                                             var shader = createShader(gl2, SHADERS.boxVertex, SHADERS.boxFragment);
-                                            var selectBox = new SelectBox(plot, buffer2, shader);
+                                            var selectBox = new SelectBox(plot, buffer, shader);
                                             selectBox.update(options);
                                             plot.addOverlay(selectBox);
                                             return selectBox;
                                         }
                                     },
                                     2611: function(module4, __unused_webpack_exports2, __nested_webpack_require_487476__) {
                                         module4.exports = createSelectBuffer;
@@ -188512,18 +189361,18 @@
                                         function SelectResult(x2, y2, id2, value, distance) {
                                             this.coord = [x2, y2];
                                             this.id = id2;
                                             this.value = value;
                                             this.distance = distance;
                                         }
 
-                                        function SelectBuffer(gl2, fbo, buffer2) {
+                                        function SelectBuffer(gl2, fbo, buffer) {
                                             this.gl = gl2;
                                             this.fbo = fbo;
-                                            this.buffer = buffer2;
+                                            this.buffer = buffer;
                                             this._readTimeout = null;
                                             var self2 = this;
                                             this._readCallback = function() {
                                                 if (!self2.gl) {
                                                     return;
                                                 }
                                                 fbo.bind();
@@ -188544,17 +189393,17 @@
                                                     return;
                                                 }
                                                 this.fbo.shape = v2;
                                                 var c2 = this.fbo.shape[0];
                                                 var r2 = this.fbo.shape[1];
                                                 if (r2 * c2 * 4 > this.buffer.length) {
                                                     pool.free(this.buffer);
-                                                    var buffer2 = this.buffer = pool.mallocUint8(nextPow22(r2 * c2 * 4));
+                                                    var buffer = this.buffer = pool.mallocUint8(nextPow22(r2 * c2 * 4));
                                                     for (var i2 = 0; i2 < r2 * c2 * 4; ++i2) {
-                                                        buffer2[i2] = 255;
+                                                        buffer[i2] = 255;
                                                     }
                                                 }
                                                 return v2;
                                             }
                                         });
                                         proto2.begin = function() {
                                             var gl2 = this.gl;
@@ -188621,16 +189470,16 @@
                                         };
 
                                         function createSelectBuffer(gl2, shape) {
                                             var width = shape[0];
                                             var height = shape[1];
                                             var options = {};
                                             var fbo = createFBO(gl2, width, height, options);
-                                            var buffer2 = pool.mallocUint8(width * height * 4);
-                                            return new SelectBuffer(gl2, fbo, buffer2);
+                                            var buffer = pool.mallocUint8(width * height * 4);
+                                            return new SelectBuffer(gl2, fbo, buffer);
                                         }
                                     },
                                     5158: function(module4, __unused_webpack_exports2, __nested_webpack_require_490573__) {
                                         var createUniformWrapper = __nested_webpack_require_490573__(9016);
                                         var createAttributeWrapper = __nested_webpack_require_490573__(4280);
                                         var makeReflect = __nested_webpack_require_490573__(3984);
                                         var shaderCache = __nested_webpack_require_490573__(1628);
@@ -188723,22 +189572,22 @@
                                             var attributeUnpacked = [];
                                             var attributeNames = [];
                                             var attributeLocations = [];
                                             var i2;
                                             for (i2 = 0; i2 < attributes2.length; ++i2) {
                                                 var attr = attributes2[i2];
                                                 if (attr.type.indexOf("mat") >= 0) {
-                                                    var size = attr.type.charAt(attr.type.length - 1) | 0;
-                                                    var locVector = new Array(size);
-                                                    for (var j2 = 0; j2 < size; ++j2) {
+                                                    var size2 = attr.type.charAt(attr.type.length - 1) | 0;
+                                                    var locVector = new Array(size2);
+                                                    for (var j2 = 0; j2 < size2; ++j2) {
                                                         locVector[j2] = attributeLocations.length;
                                                         attributeNames.push(attr.name + "[" + j2 + "]");
                                                         if (typeof attr.location === "number") {
                                                             attributeLocations.push(attr.location + j2);
-                                                        } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j2] === "number") {
+                                                        } else if (Array.isArray(attr.location) && attr.location.length === size2 && typeof attr.location[j2] === "number") {
                                                             attributeLocations.push(attr.location[j2] | 0);
                                                         } else {
                                                             attributeLocations.push(-1);
                                                         }
                                                     }
                                                     attributeUnpacked.push({
                                                         name: attr.name,
@@ -189513,17 +190362,17 @@
                                     6496: function(module4, __unused_webpack_exports2, __nested_webpack_require_513517__) {
                                         var createBuffer = __nested_webpack_require_513517__(5827);
                                         var createVAO = __nested_webpack_require_513517__(2944);
                                         var createShader = __nested_webpack_require_513517__(3540);
                                         module4.exports = createSpikes;
                                         var identity2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
 
-                                        function AxisSpikes(gl2, buffer2, vao, shader) {
+                                        function AxisSpikes(gl2, buffer, vao, shader) {
                                             this.gl = gl2;
-                                            this.buffer = buffer2;
+                                            this.buffer = buffer;
                                             this.vao = vao;
                                             this.shader = shader;
                                             this.pixelRatio = 1;
                                             this.bounds = [
                                                 [-1e3, -1e3, -1e3],
                                                 [1e3, 1e3, 1e3]
                                             ];
@@ -189641,39 +190490,39 @@
                                             line(0, 0, 0, 2, 0, 1);
                                             line(1, 0, 0, 1, -1, 1);
                                             line(1, 0, 0, 2, -1, 1);
                                             line(0, 1, 0, 0, -1, 1);
                                             line(0, 1, 0, 2, -1, 1);
                                             line(0, 0, 1, 0, -1, 1);
                                             line(0, 0, 1, 1, -1, 1);
-                                            var buffer2 = createBuffer(gl2, data2);
+                                            var buffer = createBuffer(gl2, data2);
                                             var vao = createVAO(gl2, [{
                                                 type: gl2.FLOAT,
-                                                buffer: buffer2,
+                                                buffer,
                                                 size: 3,
                                                 offset: 0,
                                                 stride: 28
                                             }, {
                                                 type: gl2.FLOAT,
-                                                buffer: buffer2,
+                                                buffer,
                                                 size: 3,
                                                 offset: 12,
                                                 stride: 28
                                             }, {
                                                 type: gl2.FLOAT,
-                                                buffer: buffer2,
+                                                buffer,
                                                 size: 1,
                                                 offset: 24,
                                                 stride: 28
                                             }]);
                                             var shader = createShader(gl2);
                                             shader.attributes.position.location = 0;
                                             shader.attributes.color.location = 1;
                                             shader.attributes.weight.location = 2;
-                                            var spikes = new AxisSpikes(gl2, buffer2, vao, shader);
+                                            var spikes = new AxisSpikes(gl2, buffer, vao, shader);
                                             spikes.update(options);
                                             return spikes;
                                         }
                                     },
                                     9578: function(__unused_webpack_module, exports4, __nested_webpack_require_516827__) {
                                         var glslify = __nested_webpack_require_516827__(6832);
                                         var triVertSrc = glslify(["precision highp float;\n\nprecision highp float;\n#define GLSLIFY 1\n\nvec3 getOrthogonalVector(vec3 v) {\n  // Return up-vector for only-z vector.\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\n  // Assign z = 0, x = -b, y = a:\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\n    return normalize(vec3(-v.y, v.x, 0.0));\n  } else {\n    return normalize(vec3(0.0, v.z, -v.y));\n  }\n}\n\n// Calculate the tube vertex and normal at the given index.\n//\n// The returned vertex is for a tube ring with its center at origin, radius of length(d), pointing in the direction of d.\n//\n// Each tube segment is made up of a ring of vertices.\n// These vertices are used to make up the triangles of the tube by connecting them together in the vertex array.\n// The indexes of tube segments run from 0 to 8.\n//\nvec3 getTubePosition(vec3 d, float index, out vec3 normal) {\n  float segmentCount = 8.0;\n\n  float angle = 2.0 * 3.14159 * (index / segmentCount);\n\n  vec3 u = getOrthogonalVector(d);\n  vec3 v = normalize(cross(u, d));\n\n  vec3 x = u * cos(angle) * length(d);\n  vec3 y = v * sin(angle) * length(d);\n  vec3 v3 = x + y;\n\n  normal = normalize(v3);\n\n  return v3;\n}\n\nattribute vec4 vector;\nattribute vec4 color, position;\nattribute vec2 uv;\n\nuniform float vectorScale, tubeScale;\nuniform mat4 model, view, projection, inverseModel;\nuniform vec3 eyePosition, lightPosition;\n\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\nvarying vec4 f_color;\nvarying vec2 f_uv;\n\nvoid main() {\n  // Scale the vector magnitude to stay constant with\n  // model & view changes.\n  vec3 normal;\n  vec3 XYZ = getTubePosition(mat3(model) * (tubeScale * vector.w * normalize(vector.xyz)), position.w, normal);\n  vec4 tubePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\n\n  //Lighting geometry parameters\n  vec4 cameraCoordinate = view * tubePosition;\n  cameraCoordinate.xyz /= cameraCoordinate.w;\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\n  f_normal = normalize((vec4(normal, 0.0) * inverseModel).xyz);\n\n  // vec4 m_position  = model * vec4(tubePosition, 1.0);\n  vec4 t_position  = view * tubePosition;\n  gl_Position      = projection * t_position;\n\n  f_color          = color;\n  f_data           = tubePosition.xyz;\n  f_position       = position.xyz;\n  f_uv             = uv;\n}\n"]);
@@ -191366,17 +192215,17 @@
                                             tex._shape = [w2, h2];
                                             tex.bind();
                                             gl2.texImage2D(gl2.TEXTURE_2D, 0, tex.format, w2, h2, 0, tex.format, tex.type, null);
                                             tex._mipLevels = [0];
                                             return tex;
                                         }
 
-                                        function Texture2D(gl2, handle, width, height, format2, type2) {
+                                        function Texture2D(gl2, handle2, width, height, format2, type2) {
                                             this.gl = gl2;
-                                            this.handle = handle;
+                                            this.handle = handle2;
                                             this.format = format2;
                                             this.type = type2;
                                             this._shape = [width, height];
                                             this._mipLevels = [0];
                                             this._magFilter = gl2.NEAREST;
                                             this._minFilter = gl2.NEAREST;
                                             this._wrapS = gl2.CLAMP_TO_EDGE;
@@ -191668,50 +192517,50 @@
                                             }
                                             if ((format2 === gl2.LUMINANCE || format2 === gl2.ALPHA) && (cformat === gl2.LUMINANCE || cformat === gl2.ALPHA)) {
                                                 format2 = cformat;
                                             }
                                             if (format2 !== cformat) {
                                                 throw new Error("gl-texture2d: Incompatible texture format for setPixels");
                                             }
-                                            var size = array2.size;
+                                            var size2 = array2.size;
                                             var needsMip = mipLevels.indexOf(mip_level) < 0;
                                             if (needsMip) {
                                                 mipLevels.push(mip_level);
                                             }
                                             if (type2 === ctype && packed) {
-                                                if (array2.offset === 0 && array2.data.length === size) {
+                                                if (array2.offset === 0 && array2.data.length === size2) {
                                                     if (needsMip) {
                                                         gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array2.data);
                                                     } else {
                                                         gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array2.data);
                                                     }
                                                 } else {
                                                     if (needsMip) {
-                                                        gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array2.data.subarray(array2.offset, array2.offset + size));
+                                                        gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array2.data.subarray(array2.offset, array2.offset + size2));
                                                     } else {
-                                                        gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array2.data.subarray(array2.offset, array2.offset + size));
+                                                        gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array2.data.subarray(array2.offset, array2.offset + size2));
                                                     }
                                                 }
                                             } else {
                                                 var pack_buffer;
                                                 if (ctype === gl2.FLOAT) {
-                                                    pack_buffer = pool.mallocFloat32(size);
+                                                    pack_buffer = pool.mallocFloat32(size2);
                                                 } else {
-                                                    pack_buffer = pool.mallocUint8(size);
+                                                    pack_buffer = pool.mallocUint8(size2);
                                                 }
                                                 var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2] * shape[0], 1]);
                                                 if (type2 === gl2.FLOAT && ctype === gl2.UNSIGNED_BYTE) {
                                                     convertFloatToUint8(pack_view, array2);
                                                 } else {
                                                     ops.assign(pack_view, array2);
                                                 }
                                                 if (needsMip) {
-                                                    gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size));
+                                                    gl2.texImage2D(gl2.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size2));
                                                 } else {
-                                                    gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size));
+                                                    gl2.texSubImage2D(gl2.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size2));
                                                 }
                                                 if (ctype === gl2.FLOAT) {
                                                     pool.freeFloat32(pack_buffer);
                                                 } else {
                                                     pool.freeUint8(pack_buffer);
                                                 }
                                             }
@@ -191788,33 +192637,33 @@
                                             } else {
                                                 throw new Error("gl-texture2d: Invalid shape for texture");
                                             }
                                             if (type2 === gl2.FLOAT && !gl2.getExtension("OES_texture_float")) {
                                                 type2 = gl2.UNSIGNED_BYTE;
                                                 packed = false;
                                             }
-                                            var buffer2, buf_store;
-                                            var size = array2.size;
+                                            var buffer, buf_store;
+                                            var size2 = array2.size;
                                             if (!packed) {
                                                 var stride = [shape[2], shape[2] * shape[0], 1];
-                                                buf_store = pool.malloc(size, dtype);
+                                                buf_store = pool.malloc(size2, dtype);
                                                 var buf_array = ndarray(buf_store, shape, stride, 0);
                                                 if ((dtype === "float32" || dtype === "float64") && type2 === gl2.UNSIGNED_BYTE) {
                                                     convertFloatToUint8(buf_array, array2);
                                                 } else {
                                                     ops.assign(buf_array, array2);
                                                 }
-                                                buffer2 = buf_store.subarray(0, size);
-                                            } else if (array2.offset === 0 && array2.data.length === size) {
-                                                buffer2 = array2.data;
+                                                buffer = buf_store.subarray(0, size2);
+                                            } else if (array2.offset === 0 && array2.data.length === size2) {
+                                                buffer = array2.data;
                                             } else {
-                                                buffer2 = array2.data.subarray(array2.offset, array2.offset + size);
+                                                buffer = array2.data.subarray(array2.offset, array2.offset + size2);
                                             }
                                             var tex = initTexture(gl2);
-                                            gl2.texImage2D(gl2.TEXTURE_2D, 0, format2, shape[0], shape[1], 0, format2, type2, buffer2);
+                                            gl2.texImage2D(gl2.TEXTURE_2D, 0, format2, shape[0], shape[1], 0, format2, type2, buffer);
                                             if (!packed) {
                                                 pool.free(buf_store);
                                             }
                                             return new Texture2D(gl2, tex, shape[0], shape[1], format2, type2);
                                         }
 
                                         function createTexture2D(gl2) {
@@ -191853,23 +192702,23 @@
                                             if (attributes2) {
                                                 if (attributes2.length > nattribs) {
                                                     throw new Error("gl-vao: Too many vertex attributes");
                                                 }
                                                 for (var i2 = 0; i2 < attributes2.length; ++i2) {
                                                     var attrib = attributes2[i2];
                                                     if (attrib.buffer) {
-                                                        var buffer2 = attrib.buffer;
-                                                        var size = attrib.size || 4;
+                                                        var buffer = attrib.buffer;
+                                                        var size2 = attrib.size || 4;
                                                         var type2 = attrib.type || gl2.FLOAT;
                                                         var normalized = !!attrib.normalized;
                                                         var stride = attrib.stride || 0;
                                                         var offset2 = attrib.offset || 0;
-                                                        buffer2.bind();
+                                                        buffer.bind();
                                                         gl2.enableVertexAttribArray(i2);
-                                                        gl2.vertexAttribPointer(i2, size, type2, normalized, stride, offset2);
+                                                        gl2.vertexAttribPointer(i2, size2, type2, normalized, stride, offset2);
                                                     } else {
                                                         if (typeof attrib === "number") {
                                                             gl2.vertexAttrib1f(i2, attrib);
                                                         } else if (attrib.length === 1) {
                                                             gl2.vertexAttrib1f(i2, attrib[0]);
                                                         } else if (attrib.length === 2) {
                                                             gl2.vertexAttrib2f(i2, attrib[0], attrib[1]);
@@ -191953,18 +192802,18 @@
                                                     break;
                                                 case 4:
                                                     gl2.vertexAttrib4f(this.location, this.a, this.b, this.c, this.d);
                                                     break;
                                             }
                                         };
 
-                                        function VAONative(gl2, ext, handle) {
+                                        function VAONative(gl2, ext, handle2) {
                                             this.gl = gl2;
                                             this._ext = ext;
-                                            this.handle = handle;
+                                            this.handle = handle2;
                                             this._attribs = [];
                                             this._useElements = false;
                                             this._elementsType = gl2.UNSIGNED_SHORT;
                                         }
                                         VAONative.prototype.bind = function() {
                                             this._ext.bindVertexArrayOES(this.handle);
                                             for (var i2 = 0; i2 < this._attribs.length; ++i2) {
@@ -193985,15 +194834,15 @@
                                             return triangles.boundary();
                                         }
                                     },
                                     9014: function(module4, __unused_webpack_exports2, __nested_webpack_require_638365__) {
                                         var bounds2 = __nested_webpack_require_638365__(5070);
                                         var NOT_FOUND = 0;
                                         var SUCCESS = 1;
-                                        var EMPTY = 2;
+                                        var EMPTY2 = 2;
                                         module4.exports = createWrapper;
 
                                         function IntervalTreeNode(mid, left2, right2, leftPoints, rightPoints) {
                                             this.mid = mid;
                                             this.left = left2;
                                             this.right = right2;
                                             this.leftPoints = leftPoints;
@@ -194084,15 +194933,15 @@
                                                     return NOT_FOUND;
                                                 }
                                                 var rw = this.right ? this.right.count : 0;
                                                 if (4 * rw > 3 * (weight - 1)) {
                                                     return rebuildWithoutInterval(this, interval2);
                                                 }
                                                 var r2 = this.left.remove(interval2);
-                                                if (r2 === EMPTY) {
+                                                if (r2 === EMPTY2) {
                                                     this.left = null;
                                                     this.count -= 1;
                                                     return SUCCESS;
                                                 } else if (r2 === SUCCESS) {
                                                     this.count -= 1;
                                                 }
                                                 return r2;
@@ -194101,26 +194950,26 @@
                                                     return NOT_FOUND;
                                                 }
                                                 var lw = this.left ? this.left.count : 0;
                                                 if (4 * lw > 3 * (weight - 1)) {
                                                     return rebuildWithoutInterval(this, interval2);
                                                 }
                                                 var r2 = this.right.remove(interval2);
-                                                if (r2 === EMPTY) {
+                                                if (r2 === EMPTY2) {
                                                     this.right = null;
                                                     this.count -= 1;
                                                     return SUCCESS;
                                                 } else if (r2 === SUCCESS) {
                                                     this.count -= 1;
                                                 }
                                                 return r2;
                                             } else {
                                                 if (this.count === 1) {
                                                     if (this.leftPoints[0] === interval2) {
-                                                        return EMPTY;
+                                                        return EMPTY2;
                                                     } else {
                                                         return NOT_FOUND;
                                                     }
                                                 }
                                                 if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {
                                                     if (this.left && this.right) {
                                                         var p2 = this;
@@ -194298,15 +195147,15 @@
                                             } else {
                                                 this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);
                                             }
                                         };
                                         tproto.remove = function(interval2) {
                                             if (this.root) {
                                                 var r2 = this.root.remove(interval2);
-                                                if (r2 === EMPTY) {
+                                                if (r2 === EMPTY2) {
                                                     this.root = null;
                                                 }
                                                 return r2 !== NOT_FOUND;
                                             }
                                             return false;
                                         };
                                         tproto.queryPoint = function(p2, cb) {
@@ -197220,15 +198069,15 @@
                                                     this.stride = [c0];
                                                     this.offset = d2 | 0;
                                                 }
                                                 var proto2 = View.prototype;
                                                 proto2.dtype = dtype;
                                                 proto2.dimension = 1;
                                                 Object.defineProperty(proto2, "size", {
-                                                    get: function size() {
+                                                    get: function size2() {
                                                         return this.shape[0];
                                                     }
                                                 });
                                                 proto2.order = [0];
                                                 proto2.set = function set2(i0, v2) {
                                                     return dtype === "generic" ? this.data.set(this.offset + this.stride[0] * i0, v2) : this.data[this.offset + this.stride[0] * i0] = v2;
                                                 };
@@ -197301,15 +198150,15 @@
                                                     this.stride = [c0, c1];
                                                     this.offset = d2 | 0;
                                                 }
                                                 var proto2 = View.prototype;
                                                 proto2.dtype = dtype;
                                                 proto2.dimension = 2;
                                                 Object.defineProperty(proto2, "size", {
-                                                    get: function size() {
+                                                    get: function size2() {
                                                         return this.shape[0] * this.shape[1];
                                                     }
                                                 });
                                                 Object.defineProperty(proto2, "order", {
                                                     get: function order3() {
                                                         return Math.abs(this.stride[0]) > Math.abs(this.stride[1]) ? [1, 0] : [0, 1];
                                                     }
@@ -197412,15 +198261,15 @@
                                                     this.stride = [c0, c1, c2];
                                                     this.offset = d2 | 0;
                                                 }
                                                 var proto2 = View.prototype;
                                                 proto2.dtype = dtype;
                                                 proto2.dimension = 3;
                                                 Object.defineProperty(proto2, "size", {
-                                                    get: function size() {
+                                                    get: function size2() {
                                                         return this.shape[0] * this.shape[1] * this.shape[2];
                                                     }
                                                 });
                                                 Object.defineProperty(proto2, "order", {
                                                     get: function order3() {
                                                         var s0 = Math.abs(this.stride[0]),
                                                             s1 = Math.abs(this.stride[1]),
@@ -197566,15 +198415,15 @@
                                                     this.stride = [c0, c1, c2, c3];
                                                     this.offset = d2 | 0;
                                                 }
                                                 var proto2 = View.prototype;
                                                 proto2.dtype = dtype;
                                                 proto2.dimension = 4;
                                                 Object.defineProperty(proto2, "size", {
-                                                    get: function size() {
+                                                    get: function size2() {
                                                         return this.shape[0] * this.shape[1] * this.shape[2] * this.shape[3];
                                                     }
                                                 });
                                                 Object.defineProperty(proto2, "order", {
                                                     get: ORDER
                                                 });
                                                 proto2.set = function set2(i0, i1, i2, i3, v2) {
@@ -197727,15 +198576,15 @@
                                                     this.stride = [c0, c1, c2, c3, c4];
                                                     this.offset = d2 | 0;
                                                 }
                                                 var proto2 = View.prototype;
                                                 proto2.dtype = dtype;
                                                 proto2.dimension = 5;
                                                 Object.defineProperty(proto2, "size", {
-                                                    get: function size() {
+                                                    get: function size2() {
                                                         return this.shape[0] * this.shape[1] * this.shape[2] * this.shape[3] * this.shape[4];
                                                     }
                                                 });
                                                 Object.defineProperty(proto2, "order", {
                                                     get: ORDER
                                                 });
                                                 proto2.set = function set2(i0, i1, i2, i3, i4, v2) {
@@ -202417,35 +203266,35 @@
                                                             italics: true,
                                                             subscripts: true,
                                                             superscripts: true
                                                         }
                                                     }));
                                                 } else {
                                                     var parts = text2.split(/(\d|\s)/);
-                                                    var buffer2 = new Array(parts.length);
+                                                    var buffer = new Array(parts.length);
                                                     var bufferSize = 0;
                                                     var shapeX = 0;
                                                     for (var i2 = 0; i2 < parts.length; ++i2) {
-                                                        buffer2[i2] = textGet(font, parts[i2]);
-                                                        bufferSize += buffer2[i2].data.length;
-                                                        shapeX += buffer2[i2].shape;
+                                                        buffer[i2] = textGet(font, parts[i2]);
+                                                        bufferSize += buffer[i2].data.length;
+                                                        shapeX += buffer[i2].shape;
                                                         if (i2 > 0) {
                                                             shapeX += 0.02;
                                                         }
                                                     }
                                                     var data2 = new Float32Array(bufferSize);
                                                     var ptr = 0;
                                                     var xOffset = -0.5 * shapeX;
-                                                    for (var i2 = 0; i2 < buffer2.length; ++i2) {
-                                                        var bdata = buffer2[i2].data;
+                                                    for (var i2 = 0; i2 < buffer.length; ++i2) {
+                                                        var bdata = buffer[i2].data;
                                                         for (var j2 = 0; j2 < bdata.length; j2 += 2) {
                                                             data2[ptr++] = bdata[j2] + xOffset;
                                                             data2[ptr++] = bdata[j2 + 1];
                                                         }
-                                                        xOffset += buffer2[i2].shape + 0.02;
+                                                        xOffset += buffer[i2].shape + 0.02;
                                                     }
                                                     mesh = fontcache[text2] = {
                                                         data: data2,
                                                         shape: shapeX
                                                     };
                                                 }
                                             }
@@ -202462,17 +203311,17 @@
                                             return parts[0] * toPX(parts[1], element2);
                                         }
 
                                         function getSizeBrutal(unit, element2) {
                                             var testDIV = document.createElement("div");
                                             testDIV.style["font-size"] = "128" + unit;
                                             element2.appendChild(testDIV);
-                                            var size = getPropertyInPX(testDIV, "font-size") / 128;
+                                            var size2 = getPropertyInPX(testDIV, "font-size") / 128;
                                             element2.removeChild(testDIV);
-                                            return size;
+                                            return size2;
                                         }
 
                                         function toPX(str, element2) {
                                             element2 = element2 || document.body;
                                             str = (str || "px").trim().toLowerCase();
                                             if (element2 === window || element2 === document) {
                                                 element2 = document.body;
@@ -203074,21 +203923,21 @@
                                                 }
                                                 var n2 = array2.length || array2.byteLength;
                                                 var log_n = bits.log2(n2) | 0;
                                                 DATA[log_n].push(array2);
                                             }
                                         };
 
-                                        function freeArrayBuffer(buffer2) {
-                                            if (!buffer2) {
+                                        function freeArrayBuffer(buffer) {
+                                            if (!buffer) {
                                                 return;
                                             }
-                                            var n2 = buffer2.length || buffer2.byteLength;
+                                            var n2 = buffer.length || buffer.byteLength;
                                             var log_n = bits.log2(n2);
-                                            DATA[log_n].push(buffer2);
+                                            DATA[log_n].push(buffer);
                                         }
 
                                         function freeTypedArray(array2) {
                                             freeArrayBuffer(array2.buffer);
                                         }
                                         exports4.freeUint8 = exports4.freeUint16 = exports4.freeUint32 = exports4.freeBigUint64 = exports4.freeInt8 = exports4.freeInt16 = exports4.freeInt32 = exports4.freeBigInt64 = exports4.freeFloat32 = exports4.freeFloat = exports4.freeFloat64 = exports4.freeDouble = exports4.freeUint8Clamped = exports4.freeDataView = freeTypedArray;
                                         exports4.freeArrayBuffer = freeArrayBuffer;
@@ -203442,15 +204291,15 @@
                                                     a2 = c2;
                                                 else
                                                     a2 = b2 + nCLS;
                                             }
                                             return map2;
                                         }
 
-                                        function transformPositions(positions, options, size) {
+                                        function transformPositions(positions, options, size2) {
                                             var align = options.textAlign || "start";
                                             var baseline = options.textBaseline || "alphabetic";
                                             var lo2 = [1 << 30, 1 << 30];
                                             var hi = [0, 0];
                                             var n2 = positions.length;
                                             for (var i2 = 0; i2 < n2; ++i2) {
                                                 var p2 = positions[i2];
@@ -203482,23 +204331,23 @@
                                                     yShift = -lo2[1];
                                                     break;
                                                 case "middle":
                                                     yShift = -0.5 * (lo2[1] + hi[1]);
                                                     break;
                                                 case "alphabetic":
                                                 case "ideographic":
-                                                    yShift = -3 * size;
+                                                    yShift = -3 * size2;
                                                     break;
                                                 case "bottom":
                                                     yShift = -hi[1];
                                                     break;
                                                 default:
                                                     throw new Error("vectorize-text: Unrecoginized textBaseline: '" + baseline + "'");
                                             }
-                                            var scale = 1 / size;
+                                            var scale = 1 / size2;
                                             if ("lineHeight" in options) {
                                                 scale *= +options.lineHeight;
                                             } else if ("width" in options) {
                                                 scale = options.width / (hi[0] - lo2[0]);
                                             } else if ("height" in options) {
                                                 scale = options.height / (hi[1] - lo2[1]);
                                             }
@@ -203546,20 +204395,20 @@
                                                 canvas.height = minHeight;
                                             }
                                             context2.fillStyle = "#000";
                                             context2.fillRect(0, 0, canvas.width, canvas.height);
                                             context2.fillStyle = "#fff";
                                             var i2, j2, xPos, yPos, zPos;
                                             var nDone = 0;
-                                            var buffer2 = "";
+                                            var buffer = "";
 
                                             function writeBuffer() {
-                                                if (buffer2 !== "") {
-                                                    var delta = context2.measureText(buffer2).width;
-                                                    context2.fillText(buffer2, offsetX + xPos, offsetY + yPos);
+                                                if (buffer !== "") {
+                                                    var delta = context2.measureText(buffer).width;
+                                                    context2.fillText(buffer, offsetX + xPos, offsetY + yPos);
                                                     xPos += delta;
                                                 }
                                             }
 
                                             function getTextFontSize() {
                                                 return "" + Math.round(zPos) + "px ";
                                             }
@@ -203617,22 +204466,22 @@
                                                 context2.font = ctxFont;
                                             }
                                             for (i2 = 0; i2 < numberOfLines; ++i2) {
                                                 var txt = allTexts[i2] + "\n";
                                                 xPos = 0;
                                                 yPos = i2 * lineHeight;
                                                 zPos = fontSize2;
-                                                buffer2 = "";
+                                                buffer = "";
                                                 for (j2 = 0; j2 < txt.length; ++j2) {
                                                     var style2 = j2 + nDone < allStyles.length ? allStyles[j2 + nDone] : allStyles[allStyles.length - 1];
                                                     if (activeStyle === style2) {
-                                                        buffer2 += txt[j2];
+                                                        buffer += txt[j2];
                                                     } else {
                                                         writeBuffer();
-                                                        buffer2 = txt[j2];
+                                                        buffer = txt[j2];
                                                         if (style2 !== void 0) {
                                                             changeStyle(activeStyle, style2);
                                                             activeStyle = style2;
                                                         }
                                                     }
                                                 }
                                                 writeBuffer();
@@ -203654,17 +204503,17 @@
                                             }
                                             return {
                                                 edges: contour.cells,
                                                 positions: contour.positions
                                             };
                                         }
 
-                                        function processPixelsImpl(pixels, options, size, simplify2) {
+                                        function processPixelsImpl(pixels, options, size2, simplify2) {
                                             var contour = getContour(pixels, simplify2);
-                                            var positions = transformPositions(contour.positions, options, size);
+                                            var positions = transformPositions(contour.positions, options, size2);
                                             var edges = contour.edges;
                                             var flip2 = "ccw" === options.orientation;
                                             cleanPSLG(positions, edges);
                                             if (options.polygons || options.polygon || options.polyline) {
                                                 var result = toPolygonCrappy(edges, positions);
                                                 var nresult = new Array(result.length);
                                                 for (var i2 = 0; i2 < result.length; ++i2) {
@@ -203697,20 +204546,20 @@
                                                 return {
                                                     edges,
                                                     positions
                                                 };
                                             }
                                         }
 
-                                        function processPixels(pixels, options, size) {
+                                        function processPixels(pixels, options, size2) {
                                             try {
-                                                return processPixelsImpl(pixels, options, size, true);
+                                                return processPixelsImpl(pixels, options, size2, true);
                                             } catch (e3) {}
                                             try {
-                                                return processPixelsImpl(pixels, options, size, false);
+                                                return processPixelsImpl(pixels, options, size2, false);
                                             } catch (e3) {}
                                             if (options.polygons || options.polyline || options.polygon) {
                                                 return [];
                                             }
                                             if (options.triangles || options.triangulate || options.triangle) {
                                                 return {
                                                     cells: [],
@@ -203720,47 +204569,47 @@
                                             return {
                                                 edges: [],
                                                 positions: []
                                             };
                                         }
 
                                         function vectorizeText(str, canvas, context2, options) {
-                                            var size = 64;
+                                            var size2 = 64;
                                             var lineSpacing = 1.25;
                                             var styletags = {
                                                 breaklines: false,
                                                 bolds: false,
                                                 italics: false,
                                                 subscripts: false,
                                                 superscripts: false
                                             };
                                             if (options) {
                                                 if (options.size && options.size > 0)
-                                                    size = options.size;
+                                                    size2 = options.size;
                                                 if (options.lineSpacing && options.lineSpacing > 0)
                                                     lineSpacing = options.lineSpacing;
                                                 if (options.styletags && options.styletags.breaklines)
                                                     styletags.breaklines = options.styletags.breaklines ? true : false;
                                                 if (options.styletags && options.styletags.bolds)
                                                     styletags.bolds = options.styletags.bolds ? true : false;
                                                 if (options.styletags && options.styletags.italics)
                                                     styletags.italics = options.styletags.italics ? true : false;
                                                 if (options.styletags && options.styletags.subscripts)
                                                     styletags.subscripts = options.styletags.subscripts ? true : false;
                                                 if (options.styletags && options.styletags.superscripts)
                                                     styletags.superscripts = options.styletags.superscripts ? true : false;
                                             }
-                                            context2.font = [options.fontStyle, options.fontVariant, options.fontWeight, size + "px", options.font].filter(function(d2) {
+                                            context2.font = [options.fontStyle, options.fontVariant, options.fontWeight, size2 + "px", options.font].filter(function(d2) {
                                                 return d2;
                                             }).join(" ");
                                             context2.textAlign = "start";
                                             context2.textBaseline = "alphabetic";
                                             context2.direction = "ltr";
-                                            var pixels = getPixels(canvas, context2, str, size, lineSpacing, styletags);
-                                            return processPixels(pixels, options, size);
+                                            var pixels = getPixels(canvas, context2, str, size2, lineSpacing, styletags);
+                                            return processPixels(pixels, options, size2);
                                         }
                                     },
                                     5346: function(module4) {
                                         (function WeakMapModule() {
                                             if (typeof ses !== "undefined" && ses.ok && !ses.ok()) {
                                                 return;
                                             }
@@ -204500,45 +205349,45 @@
                         }
                         Buffer2.from = function(value, encodingOrOffset, length) {
                             return from(value, encodingOrOffset, length);
                         };
                         Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
                         Object.setPrototypeOf(Buffer2, Uint8Array);
 
-                        function assertSize(size) {
-                            if (typeof size !== "number") {
+                        function assertSize(size2) {
+                            if (typeof size2 !== "number") {
                                 throw new TypeError('"size" argument must be of type number');
-                            } else if (size < 0) {
-                                throw new RangeError('The value "' + size + '" is invalid for option "size"');
+                            } else if (size2 < 0) {
+                                throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
                             }
                         }
 
-                        function alloc(size, fill, encoding) {
-                            assertSize(size);
-                            if (size <= 0) {
-                                return createBuffer(size);
+                        function alloc(size2, fill, encoding) {
+                            assertSize(size2);
+                            if (size2 <= 0) {
+                                return createBuffer(size2);
                             }
                             if (fill !== void 0) {
-                                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
+                                return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
                             }
-                            return createBuffer(size);
+                            return createBuffer(size2);
                         }
-                        Buffer2.alloc = function(size, fill, encoding) {
-                            return alloc(size, fill, encoding);
+                        Buffer2.alloc = function(size2, fill, encoding) {
+                            return alloc(size2, fill, encoding);
                         };
 
-                        function allocUnsafe(size) {
-                            assertSize(size);
-                            return createBuffer(size < 0 ? 0 : checked(size) | 0);
+                        function allocUnsafe(size2) {
+                            assertSize(size2);
+                            return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
                         }
-                        Buffer2.allocUnsafe = function(size) {
-                            return allocUnsafe(size);
+                        Buffer2.allocUnsafe = function(size2) {
+                            return allocUnsafe(size2);
                         };
-                        Buffer2.allocUnsafeSlow = function(size) {
-                            return allocUnsafe(size);
+                        Buffer2.allocUnsafeSlow = function(size2) {
+                            return allocUnsafe(size2);
                         };
 
                         function fromString(string2, encoding) {
                             if (typeof encoding !== "string" || encoding === "") {
                                 encoding = "utf8";
                             }
                             if (!Buffer2.isEncoding(encoding)) {
@@ -204679,34 +205528,34 @@
                             var i2;
                             if (length === void 0) {
                                 length = 0;
                                 for (i2 = 0; i2 < list2.length; ++i2) {
                                     length += list2[i2].length;
                                 }
                             }
-                            var buffer2 = Buffer2.allocUnsafe(length);
+                            var buffer = Buffer2.allocUnsafe(length);
                             var pos = 0;
                             for (i2 = 0; i2 < list2.length; ++i2) {
                                 var buf = list2[i2];
                                 if (isInstance(buf, Uint8Array)) {
-                                    if (pos + buf.length > buffer2.length) {
+                                    if (pos + buf.length > buffer.length) {
                                         if (!Buffer2.isBuffer(buf))
                                             buf = Buffer2.from(buf);
-                                        buf.copy(buffer2, pos);
+                                        buf.copy(buffer, pos);
                                     } else {
-                                        Uint8Array.prototype.set.call(buffer2, buf, pos);
+                                        Uint8Array.prototype.set.call(buffer, buf, pos);
                                     }
                                 } else if (!Buffer2.isBuffer(buf)) {
                                     throw new TypeError('"list" argument must be an Array of Buffers');
                                 } else {
-                                    buf.copy(buffer2, pos);
+                                    buf.copy(buffer, pos);
                                 }
                                 pos += buf.length;
                             }
-                            return buffer2;
+                            return buffer;
                         };
 
                         function byteLength(string2, encoding) {
                             if (Buffer2.isBuffer(string2)) {
                                 return string2.length;
                             }
                             if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
@@ -204917,60 +205766,60 @@
                             if (x2 < y2)
                                 return -1;
                             if (y2 < x2)
                                 return 1;
                             return 0;
                         };
 
-                        function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
-                            if (buffer2.length === 0)
+                        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
+                            if (buffer.length === 0)
                                 return -1;
                             if (typeof byteOffset === "string") {
                                 encoding = byteOffset;
                                 byteOffset = 0;
                             } else if (byteOffset > 2147483647) {
                                 byteOffset = 2147483647;
                             } else if (byteOffset < -2147483648) {
                                 byteOffset = -2147483648;
                             }
                             byteOffset = +byteOffset;
                             if (numberIsNaN(byteOffset)) {
-                                byteOffset = dir ? 0 : buffer2.length - 1;
+                                byteOffset = dir ? 0 : buffer.length - 1;
                             }
                             if (byteOffset < 0)
-                                byteOffset = buffer2.length + byteOffset;
-                            if (byteOffset >= buffer2.length) {
+                                byteOffset = buffer.length + byteOffset;
+                            if (byteOffset >= buffer.length) {
                                 if (dir)
                                     return -1;
                                 else
-                                    byteOffset = buffer2.length - 1;
+                                    byteOffset = buffer.length - 1;
                             } else if (byteOffset < 0) {
                                 if (dir)
                                     byteOffset = 0;
                                 else
                                     return -1;
                             }
                             if (typeof val === "string") {
                                 val = Buffer2.from(val, encoding);
                             }
                             if (Buffer2.isBuffer(val)) {
                                 if (val.length === 0) {
                                     return -1;
                                 }
-                                return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
+                                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                             } else if (typeof val === "number") {
                                 val = val & 255;
                                 if (typeof Uint8Array.prototype.indexOf === "function") {
                                     if (dir) {
-                                        return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
+                                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                                     } else {
-                                        return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
+                                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                                     }
                                 }
-                                return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
+                                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                             }
                             throw new TypeError("val must be string, number or Buffer");
                         }
 
                         function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                             var indexSize = 1;
                             var arrLength = arr.length;
@@ -206768,33 +207617,33 @@
                                 return true;
                             }
                         }
 
                         function calcVerticalBuffer(links, circularLinkGap, id2) {
                             links.sort(sortLinkColumnAscending);
                             links.forEach(function(link2, i2) {
-                                var buffer2 = 0;
+                                var buffer = 0;
                                 if (selfLinking(link2, id2) && onlyCircularLink(link2)) {
-                                    link2.circularPathData.verticalBuffer = buffer2 + link2.width / 2;
+                                    link2.circularPathData.verticalBuffer = buffer + link2.width / 2;
                                 } else {
                                     var j2 = 0;
                                     for (j2; j2 < i2; j2++) {
                                         if (circularLinksCross(links[i2], links[j2])) {
                                             var bufferOverThisLink = links[j2].circularPathData.verticalBuffer + links[j2].width / 2 + circularLinkGap;
-                                            buffer2 = bufferOverThisLink > buffer2 ? bufferOverThisLink : buffer2;
+                                            buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;
                                         }
                                     }
-                                    link2.circularPathData.verticalBuffer = buffer2 + link2.width / 2;
+                                    link2.circularPathData.verticalBuffer = buffer + link2.width / 2;
                                 }
                             });
                             return links;
                         }
 
                         function addCircularPathData(graph, circularLinkGap, y1, id2) {
-                            var buffer2 = 5;
+                            var buffer = 5;
                             var minY = (0, d3_array__WEBPACK_IMPORTED_MODULE_0__.VV)(graph.links, function(link2) {
                                 return link2.source.y0;
                             });
                             graph.links.forEach(function(link2) {
                                 if (link2.circular) {
                                     link2.circularPathData = {};
                                 }
@@ -206806,16 +207655,16 @@
                             var bottomLinks = graph.links.filter(function(l2) {
                                 return l2.circularLinkType == "bottom";
                             });
                             calcVerticalBuffer(bottomLinks, circularLinkGap, id2);
                             graph.links.forEach(function(link2) {
                                 if (link2.circular) {
                                     link2.circularPathData.arcRadius = link2.width + baseRadius;
-                                    link2.circularPathData.leftNodeBuffer = buffer2;
-                                    link2.circularPathData.rightNodeBuffer = buffer2;
+                                    link2.circularPathData.leftNodeBuffer = buffer;
+                                    link2.circularPathData.rightNodeBuffer = buffer;
                                     link2.circularPathData.sourceWidth = link2.source.x1 - link2.source.x0;
                                     link2.circularPathData.sourceX = link2.source.x0 + link2.circularPathData.sourceWidth;
                                     link2.circularPathData.targetX = link2.target.x0;
                                     link2.circularPathData.sourceY = link2.y0;
                                     link2.circularPathData.targetY = link2.y1;
                                     if (selfLinking(link2, id2) && onlyCircularLink(link2)) {
                                         link2.circularPathData.leftSmallArcRadius = baseRadius + link2.width / 2;
@@ -208053,18 +208902,18 @@
                                 var keys2 = [];
                                 for (var key in this._)
                                     keys2.push(d3_map_unescape(key));
                                 return keys2;
                             }
 
                             function d3_map_size() {
-                                var size = 0;
+                                var size2 = 0;
                                 for (var key in this._)
-                                    ++size;
-                                return size;
+                                    ++size2;
+                                return size2;
                             }
 
                             function d3_map_empty() {
                                 for (var key in this._)
                                     return false;
                                 return true;
                             }
@@ -209224,15 +210073,15 @@
                             };
                             d3.behavior.zoom = function() {
                                 var view = {
                                         x: 0,
                                         y: 0,
                                         k: 1
                                     },
-                                    translate0, center0, center2, size = [960, 500],
+                                    translate0, center0, center2, size2 = [960, 500],
                                     scaleExtent = d3_behavior_zoomInfinity,
                                     duration = 250,
                                     zooming = 0,
                                     mousedown = "mousedown.zoom",
                                     mousemove = "mousemove.zoom",
                                     mouseup = "mouseup.zoom",
                                     mousewheelTimer, touchstart = "touchstart.zoom",
@@ -209260,16 +210109,16 @@
                                                 view = this.__chart__ || {
                                                     x: 0,
                                                     y: 0,
                                                     k: 1
                                                 };
                                                 zoomstarted(dispatch2);
                                             }).tween("zoom:zoom", function() {
-                                                var dx = size[0],
-                                                    dy = size[1],
+                                                var dx = size2[0],
+                                                    dy = size2[1],
                                                     cx = center0 ? center0[0] : dx / 2,
                                                     cy = center0 ? center0[1] : dy / 2,
                                                     i2 = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                                                 return function(t2) {
                                                     var l2 = i2(t2),
                                                         k2 = dx / l2[2];
                                                     this.__chart__ = view = {
@@ -209325,16 +210174,16 @@
                                     if (!arguments.length)
                                         return center2;
                                     center2 = _2 && [+_2[0], +_2[1]];
                                     return zoom;
                                 };
                                 zoom.size = function(_2) {
                                     if (!arguments.length)
-                                        return size;
-                                    size = _2 && [+_2[0], +_2[1]];
+                                        return size2;
+                                    size2 = _2 && [+_2[0], +_2[1]];
                                     return zoom;
                                 };
                                 zoom.duration = function(_2) {
                                     if (!arguments.length)
                                         return duration;
                                     duration = +_2;
                                     return zoom;
@@ -210130,49 +210979,49 @@
                                 dsv.parseRows = function(text2, f2) {
                                     var EOL = {},
                                         EOF = {},
                                         rows = [],
                                         N2 = text2.length,
                                         I2 = 0,
                                         n2 = 0,
-                                        t2, eol2;
+                                        t2, eol;
 
                                     function token() {
                                         if (I2 >= N2)
                                             return EOF;
-                                        if (eol2)
-                                            return eol2 = false, EOL;
+                                        if (eol)
+                                            return eol = false, EOL;
                                         var j2 = I2;
                                         if (text2.charCodeAt(j2) === 34) {
                                             var i2 = j2;
                                             while (i2++ < N2) {
                                                 if (text2.charCodeAt(i2) === 34) {
                                                     if (text2.charCodeAt(i2 + 1) !== 34)
                                                         break;
                                                     ++i2;
                                                 }
                                             }
                                             I2 = i2 + 2;
                                             var c2 = text2.charCodeAt(i2 + 1);
                                             if (c2 === 13) {
-                                                eol2 = true;
+                                                eol = true;
                                                 if (text2.charCodeAt(i2 + 2) === 10)
                                                     ++I2;
                                             } else if (c2 === 10) {
-                                                eol2 = true;
+                                                eol = true;
                                             }
                                             return text2.slice(j2 + 1, i2).replace(/""/g, '"');
                                         }
                                         while (I2 < N2) {
                                             var c2 = text2.charCodeAt(I2++),
                                                 k2 = 1;
                                             if (c2 === 10)
-                                                eol2 = true;
+                                                eol = true;
                                             else if (c2 === 13) {
-                                                eol2 = true;
+                                                eol = true;
                                                 if (text2.charCodeAt(I2) === 10)
                                                     ++I2, ++k2;
                                             } else if (c2 !== delimiterCode)
                                                 continue;
                                             return text2.slice(j2, I2 - k2);
                                         }
                                         return text2.slice(j2);
@@ -212280,15 +213129,15 @@
                                     return groups;
                                 };
                                 return chord;
                             };
                             d3.layout.force = function() {
                                 var force = {},
                                     event2 = d3.dispatch("start", "tick", "end"),
-                                    timer2, size = [1, 1],
+                                    timer2, size2 = [1, 1],
                                     drag, alpha, friction = 0.9,
                                     linkDistance = d3_layout_forceLinkDistance,
                                     linkStrength = d3_layout_forceLinkStrength,
                                     charge = -30,
                                     chargeDistance2 = d3_layout_forceChargeDistance2,
                                     gravity = 0.1,
                                     theta2 = 0.64,
@@ -212345,16 +213194,16 @@
                                             t2.x -= x2 * (k2 = s2.weight + t2.weight ? s2.weight / (s2.weight + t2.weight) : 0.5);
                                             t2.y -= y2 * k2;
                                             s2.x += x2 * (k2 = 1 - k2);
                                             s2.y += y2 * k2;
                                         }
                                     }
                                     if (k2 = alpha * gravity) {
-                                        x2 = size[0] / 2;
-                                        y2 = size[1] / 2;
+                                        x2 = size2[0] / 2;
+                                        y2 = size2[1] / 2;
                                         i2 = -1;
                                         if (k2)
                                             while (++i2 < n2) {
                                                 o2 = nodes[i2];
                                                 o2.x += (x2 - o2.x) * k2;
                                                 o2.y += (y2 - o2.y) * k2;
                                             }
@@ -212394,16 +213243,16 @@
                                     if (!arguments.length)
                                         return links;
                                     links = x2;
                                     return force;
                                 };
                                 force.size = function(x2) {
                                     if (!arguments.length)
-                                        return size;
-                                    size = x2;
+                                        return size2;
+                                    size2 = x2;
                                     return force;
                                 };
                                 force.linkDistance = function(x2) {
                                     if (!arguments.length)
                                         return linkDistance;
                                     linkDistance = typeof x2 === "function" ? x2 : +x2;
                                     return force;
@@ -212467,16 +213316,16 @@
                                         timer2 = d3_timer(force.tick);
                                     }
                                     return force;
                                 };
                                 force.start = function() {
                                     var i2, n2 = nodes.length,
                                         m2 = links.length,
-                                        w2 = size[0],
-                                        h2 = size[1],
+                                        w2 = size2[0],
+                                        h2 = size2[1],
                                         neighbors, o2;
                                     for (i2 = 0; i2 < n2; ++i2) {
                                         (o2 = nodes[i2]).index = i2;
                                         o2.weight = 0;
                                     }
                                     for (i2 = 0; i2 < m2; ++i2) {
                                         o2 = links[i2];
@@ -212516,15 +213365,15 @@
                                     if (typeof charge === "function")
                                         for (i2 = 0; i2 < n2; ++i2)
                                             charges[i2] = +charge.call(this, nodes[i2], i2);
                                     else
                                         for (i2 = 0; i2 < n2; ++i2)
                                             charges[i2] = charge;
 
-                                    function position2(dimension, size2) {
+                                    function position2(dimension, size3) {
                                         if (!neighbors) {
                                             neighbors = new Array(n2);
                                             for (j2 = 0; j2 < n2; ++j2) {
                                                 neighbors[j2] = [];
                                             }
                                             for (j2 = 0; j2 < m2; ++j2) {
                                                 var o3 = links[j2];
@@ -212535,15 +213384,15 @@
                                         var candidates = neighbors[i2],
                                             j2 = -1,
                                             l2 = candidates.length,
                                             x2;
                                         while (++j2 < l2)
                                             if (!isNaN(x2 = candidates[j2][dimension]))
                                                 return x2;
-                                        return Math.random() * size2;
+                                        return Math.random() * size3;
                                     }
                                     return force.resume();
                                 };
                                 force.resume = function() {
                                     return force.alpha(0.1);
                                 };
                                 force.stop = function() {
@@ -212746,15 +213595,15 @@
                                             target: child
                                         };
                                     });
                                 }));
                             }
                             d3.layout.partition = function() {
                                 var hierarchy2 = d3.layout.hierarchy(),
-                                    size = [1, 1];
+                                    size2 = [1, 1];
 
                                 function position2(node2, x2, dx, dy) {
                                     var children2 = node2.children;
                                     node2.x = x2;
                                     node2.y = node2.depth * dy;
                                     node2.dx = dx;
                                     node2.dy = dy;
@@ -212779,21 +213628,21 @@
                                             d2 = Math.max(d2, depth(children2[i2]));
                                     }
                                     return 1 + d2;
                                 }
 
                                 function partition(d2, i2) {
                                     var nodes = hierarchy2.call(this, d2, i2);
-                                    position2(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
+                                    position2(nodes[0], 0, size2[0], size2[1] / depth(nodes[0]));
                                     return nodes;
                                 }
                                 partition.size = function(x2) {
                                     if (!arguments.length)
-                                        return size;
-                                    size = x2;
+                                        return size2;
+                                    size2 = x2;
                                     return partition;
                                 };
                                 return d3_layout_hierarchyRebind(partition, hierarchy2);
                             };
                             d3.layout.pie = function() {
                                 var value = Number,
                                     sort = d3_layout_pieSortByValue,
@@ -213155,22 +214004,22 @@
 
                             function d3_layout_histogramRange(values) {
                                 return [d3.min(values), d3.max(values)];
                             }
                             d3.layout.pack = function() {
                                 var hierarchy2 = d3.layout.hierarchy().sort(d3_layout_packSort),
                                     padding = 0,
-                                    size = [1, 1],
+                                    size2 = [1, 1],
                                     radius;
 
                                 function pack(d2, i2) {
                                     var nodes = hierarchy2.call(this, d2, i2),
                                         root2 = nodes[0],
-                                        w2 = size[0],
-                                        h2 = size[1],
+                                        w2 = size2[0],
+                                        h2 = size2[1],
                                         r2 = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                                             return radius;
                                         };
                                     root2.x = root2.y = 0;
                                     d3_layout_hierarchyVisitAfter(root2, function(d4) {
                                         d4.r = +r2(d4.value);
                                     });
@@ -213186,16 +214035,16 @@
                                         });
                                     }
                                     d3_layout_packTransform(root2, w2 / 2, h2 / 2, radius ? 1 : 1 / Math.max(2 * root2.r / w2, 2 * root2.r / h2));
                                     return nodes;
                                 }
                                 pack.size = function(_2) {
                                     if (!arguments.length)
-                                        return size;
-                                    size = _2;
+                                        return size2;
+                                    size2 = _2;
                                     return pack;
                                 };
                                 pack.radius = function(_2) {
                                     if (!arguments.length)
                                         return radius;
                                     radius = _2 == null || typeof _2 === "function" ? _2 : +_2;
                                     return pack;
@@ -213350,15 +214199,15 @@
                                     c2.x = a2.x + db;
                                     c2.y = a2.y;
                                 }
                             }
                             d3.layout.tree = function() {
                                 var hierarchy2 = d3.layout.hierarchy().sort(null).value(null),
                                     separation = d3_layout_treeSeparation,
-                                    size = [1, 1],
+                                    size2 = [1, 1],
                                     nodeSize2 = null;
 
                                 function tree(d2, i2) {
                                     var nodes = hierarchy2.call(this, d2, i2),
                                         root0 = nodes[0],
                                         root1 = wrapTree(root0);
                                     d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
@@ -213374,16 +214223,16 @@
                                                 left2 = node2;
                                             if (node2.x > right2.x)
                                                 right2 = node2;
                                             if (node2.depth > bottom2.depth)
                                                 bottom2 = node2;
                                         });
                                         var tx = separation(left2, right2) / 2 - left2.x,
-                                            kx = size[0] / (right2.x + separation(right2, left2) / 2 + tx),
-                                            ky = size[1] / (bottom2.depth || 1);
+                                            kx = size2[0] / (right2.x + separation(right2, left2) / 2 + tx),
+                                            ky = size2[1] / (bottom2.depth || 1);
                                         d3_layout_hierarchyVisitBefore(root0, function(node2) {
                                             node2.x = (node2.x + tx) * kx;
                                             node2.y = node2.depth * ky;
                                         });
                                     }
                                     return nodes;
                                 }
@@ -213475,33 +214324,33 @@
                                             ancestor = v2;
                                         }
                                     }
                                     return ancestor;
                                 }
 
                                 function sizeNode(node2) {
-                                    node2.x *= size[0];
-                                    node2.y = node2.depth * size[1];
+                                    node2.x *= size2[0];
+                                    node2.y = node2.depth * size2[1];
                                 }
                                 tree.separation = function(x2) {
                                     if (!arguments.length)
                                         return separation;
                                     separation = x2;
                                     return tree;
                                 };
                                 tree.size = function(x2) {
                                     if (!arguments.length)
-                                        return nodeSize2 ? null : size;
-                                    nodeSize2 = (size = x2) == null ? sizeNode : null;
+                                        return nodeSize2 ? null : size2;
+                                    nodeSize2 = (size2 = x2) == null ? sizeNode : null;
                                     return tree;
                                 };
                                 tree.nodeSize = function(x2) {
                                     if (!arguments.length)
-                                        return nodeSize2 ? size : null;
-                                    nodeSize2 = (size = x2) == null ? null : sizeNode;
+                                        return nodeSize2 ? size2 : null;
+                                    nodeSize2 = (size2 = x2) == null ? null : sizeNode;
                                     return tree;
                                 };
                                 return d3_layout_hierarchyRebind(tree, hierarchy2);
                             };
 
                             function d3_layout_treeSeparation(a2, b2) {
                                 return a2.parent == b2.parent ? 1 : 2;
@@ -213543,15 +214392,15 @@
 
                             function d3_layout_treeAncestor(vim, v2, ancestor) {
                                 return vim.a.parent === v2.parent ? vim.a : ancestor;
                             }
                             d3.layout.cluster = function() {
                                 var hierarchy2 = d3.layout.hierarchy().sort(null).value(null),
                                     separation = d3_layout_treeSeparation,
-                                    size = [1, 1],
+                                    size2 = [1, 1],
                                     nodeSize2 = false;
 
                                 function cluster(d2, i2) {
                                     var nodes = hierarchy2.call(this, d2, i2),
                                         root2 = nodes[0],
                                         previousNode, x2 = 0;
                                     d3_layout_hierarchyVisitAfter(root2, function(node2) {
@@ -213566,38 +214415,38 @@
                                         }
                                     });
                                     var left2 = d3_layout_clusterLeft(root2),
                                         right2 = d3_layout_clusterRight(root2),
                                         x0 = left2.x - separation(left2, right2) / 2,
                                         x1 = right2.x + separation(right2, left2) / 2;
                                     d3_layout_hierarchyVisitAfter(root2, nodeSize2 ? function(node2) {
-                                        node2.x = (node2.x - root2.x) * size[0];
-                                        node2.y = (root2.y - node2.y) * size[1];
+                                        node2.x = (node2.x - root2.x) * size2[0];
+                                        node2.y = (root2.y - node2.y) * size2[1];
                                     } : function(node2) {
-                                        node2.x = (node2.x - x0) / (x1 - x0) * size[0];
-                                        node2.y = (1 - (root2.y ? node2.y / root2.y : 1)) * size[1];
+                                        node2.x = (node2.x - x0) / (x1 - x0) * size2[0];
+                                        node2.y = (1 - (root2.y ? node2.y / root2.y : 1)) * size2[1];
                                     });
                                     return nodes;
                                 }
                                 cluster.separation = function(x2) {
                                     if (!arguments.length)
                                         return separation;
                                     separation = x2;
                                     return cluster;
                                 };
                                 cluster.size = function(x2) {
                                     if (!arguments.length)
-                                        return nodeSize2 ? null : size;
-                                    nodeSize2 = (size = x2) == null;
+                                        return nodeSize2 ? null : size2;
+                                    nodeSize2 = (size2 = x2) == null;
                                     return cluster;
                                 };
                                 cluster.nodeSize = function(x2) {
                                     if (!arguments.length)
-                                        return nodeSize2 ? size : null;
-                                    nodeSize2 = (size = x2) != null;
+                                        return nodeSize2 ? size2 : null;
+                                    nodeSize2 = (size2 = x2) != null;
                                     return cluster;
                                 };
                                 return d3_layout_hierarchyRebind(cluster, hierarchy2);
                             };
 
                             function d3_layout_clusterY(children2) {
                                 return 1 + d3.max(children2, function(child) {
@@ -213620,15 +214469,15 @@
                                 var children2 = node2.children,
                                     n2;
                                 return children2 && (n2 = children2.length) ? d3_layout_clusterRight(children2[n2 - 1]) : node2;
                             }
                             d3.layout.treemap = function() {
                                 var hierarchy2 = d3.layout.hierarchy(),
                                     round2 = Math.round,
-                                    size = [1, 1],
+                                    size2 = [1, 1],
                                     padding = null,
                                     pad = d3_layout_treemapPadNull,
                                     sticky = false,
                                     stickies, mode = "squarify",
                                     ratio = 0.5 * (1 + Math.sqrt(5));
 
                                 function scale(children2, k2) {
@@ -213752,29 +214601,29 @@
                                 }
 
                                 function treemap(d2) {
                                     var nodes = stickies || hierarchy2(d2),
                                         root2 = nodes[0];
                                     root2.x = root2.y = 0;
                                     if (root2.value)
-                                        root2.dx = size[0], root2.dy = size[1];
+                                        root2.dx = size2[0], root2.dy = size2[1];
                                     else
                                         root2.dx = root2.dy = 0;
                                     if (stickies)
                                         hierarchy2.revalue(root2);
                                     scale([root2], root2.dx * root2.dy / root2.value);
                                     (stickies ? stickify : squarify2)(root2);
                                     if (sticky)
                                         stickies = nodes;
                                     return nodes;
                                 }
                                 treemap.size = function(x2) {
                                     if (!arguments.length)
-                                        return size;
-                                    size = x2;
+                                        return size2;
+                                    size2 = x2;
                                     return treemap;
                                 };
                                 treemap.padding = function(x2) {
                                     if (!arguments.length)
                                         return padding;
 
                                     function padFunction(node2) {
@@ -215313,68 +216162,68 @@
                                         r2 = d2[0],
                                         a2 = d2[1] - half\u03C0;
                                     return [r2 * Math.cos(a2), r2 * Math.sin(a2)];
                                 };
                             }
                             d3.svg.symbol = function() {
                                 var type2 = d3_svg_symbolType,
-                                    size = d3_svg_symbolSize;
+                                    size2 = d3_svg_symbolSize;
 
                                 function symbol(d2, i2) {
-                                    return (d3_svg_symbols.get(type2.call(this, d2, i2)) || d3_svg_symbolCircle)(size.call(this, d2, i2));
+                                    return (d3_svg_symbols.get(type2.call(this, d2, i2)) || d3_svg_symbolCircle)(size2.call(this, d2, i2));
                                 }
                                 symbol.type = function(x2) {
                                     if (!arguments.length)
                                         return type2;
                                     type2 = d3_functor(x2);
                                     return symbol;
                                 };
                                 symbol.size = function(x2) {
                                     if (!arguments.length)
-                                        return size;
-                                    size = d3_functor(x2);
+                                        return size2;
+                                    size2 = d3_functor(x2);
                                     return symbol;
                                 };
                                 return symbol;
                             };
 
                             function d3_svg_symbolSize() {
                                 return 64;
                             }
 
                             function d3_svg_symbolType() {
                                 return "circle";
                             }
 
-                            function d3_svg_symbolCircle(size) {
-                                var r2 = Math.sqrt(size / \u03C0);
+                            function d3_svg_symbolCircle(size2) {
+                                var r2 = Math.sqrt(size2 / \u03C0);
                                 return "M0," + r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + -r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + r2 + "Z";
                             }
                             var d3_svg_symbols = d3.map({
                                 circle: d3_svg_symbolCircle,
-                                cross: function(size) {
-                                    var r2 = Math.sqrt(size / 5) / 2;
+                                cross: function(size2) {
+                                    var r2 = Math.sqrt(size2 / 5) / 2;
                                     return "M" + -3 * r2 + "," + -r2 + "H" + -r2 + "V" + -3 * r2 + "H" + r2 + "V" + -r2 + "H" + 3 * r2 + "V" + r2 + "H" + r2 + "V" + 3 * r2 + "H" + -r2 + "V" + r2 + "H" + -3 * r2 + "Z";
                                 },
-                                diamond: function(size) {
-                                    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
+                                diamond: function(size2) {
+                                    var ry = Math.sqrt(size2 / (2 * d3_svg_symbolTan30)),
                                         rx = ry * d3_svg_symbolTan30;
                                     return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
                                 },
-                                square: function(size) {
-                                    var r2 = Math.sqrt(size) / 2;
+                                square: function(size2) {
+                                    var r2 = Math.sqrt(size2) / 2;
                                     return "M" + -r2 + "," + -r2 + "L" + r2 + "," + -r2 + " " + r2 + "," + r2 + " " + -r2 + "," + r2 + "Z";
                                 },
-                                "triangle-down": function(size) {
-                                    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
+                                "triangle-down": function(size2) {
+                                    var rx = Math.sqrt(size2 / d3_svg_symbolSqrt3),
                                         ry = rx * d3_svg_symbolSqrt3 / 2;
                                     return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                                 },
-                                "triangle-up": function(size) {
-                                    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
+                                "triangle-up": function(size2) {
+                                    var rx = Math.sqrt(size2 / d3_svg_symbolSqrt3),
                                         ry = rx * d3_svg_symbolSqrt3 / 2;
                                     return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                                 }
                             });
                             d3.svg.symbolTypes = d3_svg_symbols.keys();
                             var d3_svg_symbolSqrt3 = Math.sqrt(3),
                                 d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
@@ -216158,23 +217007,23 @@
 
                                     function move1(point2, scale, i2) {
                                         var range2 = d3_scaleRange(scale),
                                             r0 = range2[0],
                                             r1 = range2[1],
                                             position2 = origin[i2],
                                             extent = i2 ? yExtent : xExtent,
-                                            size = extent[1] - extent[0],
+                                            size2 = extent[1] - extent[0],
                                             min2, max2;
                                         if (dragging) {
                                             r0 -= position2;
-                                            r1 -= size + position2;
+                                            r1 -= size2 + position2;
                                         }
                                         min2 = (i2 ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point2[i2])) : point2[i2];
                                         if (dragging) {
-                                            max2 = (min2 += position2) + size;
+                                            max2 = (min2 += position2) + size2;
                                         } else {
                                             if (center2)
                                                 position2 = Math.max(r0, Math.min(r1, 2 * center2[i2] - min2));
                                             if (position2 < min2) {
                                                 max2 = min2;
                                                 min2 = position2;
                                             } else {
@@ -222152,15 +223001,15 @@
                                         }
                                         return true;
                                     } else {
                                         return false;
                                     }
                                 }
 
-                                function typeOf(value) {
+                                function typeOf2(value) {
                                     if (value === null) {
                                         return NullType;
                                     } else if (typeof value === "string") {
                                         return StringType;
                                     } else if (typeof value === "boolean") {
                                         return BooleanType;
                                     } else if (typeof value === "number") {
@@ -222174,15 +223023,15 @@
                                     } else if (value instanceof ResolvedImage) {
                                         return ResolvedImageType;
                                     } else if (Array.isArray(value)) {
                                         var length = value.length;
                                         var itemType;
                                         for (var i2 = 0, list2 = value; i2 < list2.length; i2 += 1) {
                                             var item = list2[i2];
-                                            var t4 = typeOf(item);
+                                            var t4 = typeOf2(item);
                                             if (!itemType) {
                                                 itemType = t4;
                                             } else if (itemType === t4) {
                                                 continue;
                                             } else {
                                                 itemType = ValueType;
                                                 break;
@@ -222214,15 +223063,15 @@
                                     if (args.length !== 2) {
                                         return context2.error("'literal' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
                                     }
                                     if (!isValue(args[1])) {
                                         return context2.error("invalid value");
                                     }
                                     var value = args[1];
-                                    var type2 = typeOf(value);
+                                    var type2 = typeOf2(value);
                                     var expected = context2.expectedType;
                                     if (type2.kind === "array" && type2.N === 0 && expected && expected.kind === "array" && (typeof expected.N !== "number" || expected.N === 0)) {
                                         type2 = expected;
                                     }
                                     return new Literal(type2, value);
                                 };
                                 Literal.prototype.evaluate = function evaluate() {
@@ -222303,19 +223152,19 @@
                                         parsed.push(input);
                                     }
                                     return new Assertion(type2, parsed);
                                 };
                                 Assertion.prototype.evaluate = function evaluate(ctx) {
                                     for (var i2 = 0; i2 < this.args.length; i2++) {
                                         var value = this.args[i2].evaluate(ctx);
-                                        var error3 = checkSubtype(this.type, typeOf(value));
+                                        var error3 = checkSubtype(this.type, typeOf2(value));
                                         if (!error3) {
                                             return value;
                                         } else if (i2 === this.args.length - 1) {
-                                            throw new RuntimeError("Expected value to be of type " + toString2(this.type) + ", but found " + toString2(typeOf(value)) + " instead.");
+                                            throw new RuntimeError("Expected value to be of type " + toString2(this.type) + ", but found " + toString2(typeOf2(value)) + " instead.");
                                         }
                                     }
                                     return null;
                                 };
                                 Assertion.prototype.eachChild = function eachChild(fn2) {
                                     this.args.forEach(fn2);
                                 };
@@ -222403,15 +223252,15 @@
                                         }
                                     }
                                     return new FormatExpression(sections);
                                 };
                                 FormatExpression.prototype.evaluate = function evaluate(ctx) {
                                     var evaluateSection = function(section) {
                                         var evaluatedContent = section.content.evaluate(ctx);
-                                        if (typeOf(evaluatedContent) === ResolvedImageType) {
+                                        if (typeOf2(evaluatedContent) === ResolvedImageType) {
                                             return new FormattedSection("", evaluatedContent, null, null, null);
                                         }
                                         return new FormattedSection(toString$12(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(",") : null, section.textColor ? section.textColor.evaluate(ctx) : null);
                                     };
                                     return new Formatted(this.sections.map(evaluateSection));
                                 };
                                 FormatExpression.prototype.eachChild = function eachChild(fn2) {
@@ -222719,17 +223568,17 @@
                                             }
                                             actualTypes.push(toString2(parsed$1.type));
                                         }
                                         context2.error("Expected arguments of type " + signatures + ", but found (" + actualTypes.join(", ") + ") instead.");
                                     }
                                     return null;
                                 };
-                                CompoundExpression.register = function register2(registry2, definitions2) {
-                                    CompoundExpression.definitions = definitions2;
-                                    for (var name3 in definitions2) {
+                                CompoundExpression.register = function register2(registry2, definitions) {
+                                    CompoundExpression.definitions = definitions;
+                                    for (var name3 in definitions) {
                                         registry2[name3] = CompoundExpression;
                                     }
                                 };
 
                                 function stringifySignature(signature) {
                                     if (Array.isArray(signature)) {
                                         return "(" + signature.map(toString2).join(", ") + ")";
@@ -223028,16 +223877,16 @@
                                         }
                                         tileLines.push(tileLine);
                                     }
                                     if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
                                         resetBBox(lineBBox);
                                         for (var i$32 = 0, list$3 = tileLines; i$32 < list$3.length; i$32 += 1) {
                                             var line$1 = list$3[i$32];
-                                            for (var i$22 = 0, list$2 = line$1; i$22 < list$2.length; i$22 += 1) {
-                                                var p$12 = list$2[i$22];
+                                            for (var i$22 = 0, list$22 = line$1; i$22 < list$22.length; i$22 += 1) {
+                                                var p$12 = list$22[i$22];
                                                 updatePoint(p$12, lineBBox, polyBBox, worldSize);
                                             }
                                         }
                                     }
                                     return tileLines;
                                 }
 
@@ -224037,21 +224886,21 @@
                                     }
                                     if (!isValidNativeType(needle, [
                                             "boolean",
                                             "string",
                                             "number",
                                             "null"
                                         ])) {
-                                        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString2(typeOf(needle)) + " instead.");
+                                        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString2(typeOf2(needle)) + " instead.");
                                     }
                                     if (!isValidNativeType(haystack, [
                                             "string",
                                             "array"
                                         ])) {
-                                        throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString2(typeOf(haystack)) + " instead.");
+                                        throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString2(typeOf2(haystack)) + " instead.");
                                     }
                                     return haystack.indexOf(needle) >= 0;
                                 };
                                 In2.prototype.eachChild = function eachChild(fn2) {
                                     fn2(this.needle);
                                     fn2(this.haystack);
                                 };
@@ -224104,21 +224953,21 @@
                                     var haystack = this.haystack.evaluate(ctx);
                                     if (!isValidNativeType(needle, [
                                             "boolean",
                                             "string",
                                             "number",
                                             "null"
                                         ])) {
-                                        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString2(typeOf(needle)) + " instead.");
+                                        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString2(typeOf2(needle)) + " instead.");
                                     }
                                     if (!isValidNativeType(haystack, [
                                             "string",
                                             "array"
                                         ])) {
-                                        throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString2(typeOf(haystack)) + " instead.");
+                                        throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString2(typeOf2(haystack)) + " instead.");
                                     }
                                     if (this.fromIndex) {
                                         var fromIndex = this.fromIndex.evaluate(ctx);
                                         return haystack.indexOf(needle, fromIndex);
                                     }
                                     return haystack.indexOf(needle);
                                 };
@@ -224185,16 +225034,16 @@
                                             if (typeof label !== "number" && typeof label !== "string") {
                                                 return labelContext.error("Branch labels must be numbers or strings.");
                                             } else if (typeof label === "number" && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                                                 return labelContext.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
                                             } else if (typeof label === "number" && Math.floor(label) !== label) {
                                                 return labelContext.error("Numeric branch labels must be integer values.");
                                             } else if (!inputType) {
-                                                inputType = typeOf(label);
-                                            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
+                                                inputType = typeOf2(label);
+                                            } else if (labelContext.checkSubtype(inputType, typeOf2(label))) {
                                                 return null;
                                             }
                                             if (typeof cases[String(label)] !== "undefined") {
                                                 return labelContext.error("Branch labels must be unique.");
                                             }
                                             cases[String(label)] = outputs.length;
                                         }
@@ -224216,15 +225065,15 @@
                                     if (input.type.kind !== "value" && context2.concat(1).checkSubtype(inputType, input.type)) {
                                         return null;
                                     }
                                     return new Match(inputType, outputType, input, cases, outputs, otherwise);
                                 };
                                 Match.prototype.evaluate = function evaluate(ctx) {
                                     var input = this.input.evaluate(ctx);
-                                    var output2 = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
+                                    var output2 = typeOf2(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
                                     return output2.evaluate(ctx);
                                 };
                                 Match.prototype.eachChild = function eachChild(fn2) {
                                     fn2(this.input);
                                     this.outputs.forEach(fn2);
                                     fn2(this.otherwise);
                                 };
@@ -224380,15 +225229,15 @@
                                 Slice.prototype.evaluate = function evaluate(ctx) {
                                     var input = this.input.evaluate(ctx);
                                     var beginIndex = this.beginIndex.evaluate(ctx);
                                     if (!isValidNativeType(input, [
                                             "string",
                                             "array"
                                         ])) {
-                                        throw new RuntimeError("Expected first argument to be of type array or string, but found " + toString2(typeOf(input)) + " instead.");
+                                        throw new RuntimeError("Expected first argument to be of type array or string, but found " + toString2(typeOf2(input)) + " instead.");
                                     }
                                     if (this.endIndex) {
                                         var endIndex = this.endIndex.evaluate(ctx);
                                         return input.slice(beginIndex, endIndex);
                                     }
                                     return input.slice(beginIndex);
                                 };
@@ -224526,23 +225375,23 @@
                                             }
                                             return new Comparison(lhs, rhs, collator);
                                         };
                                         Comparison.prototype.evaluate = function evaluate(ctx) {
                                             var lhs = this.lhs.evaluate(ctx);
                                             var rhs = this.rhs.evaluate(ctx);
                                             if (isOrderComparison && this.hasUntypedArgument) {
-                                                var lt3 = typeOf(lhs);
-                                                var rt2 = typeOf(rhs);
+                                                var lt3 = typeOf2(lhs);
+                                                var rt2 = typeOf2(rhs);
                                                 if (lt3.kind !== rt2.kind || !(lt3.kind === "string" || lt3.kind === "number")) {
                                                     throw new RuntimeError('Expected arguments for "' + op + '" to be (string, string) or (number, number), but found (' + lt3.kind + ", " + rt2.kind + ") instead.");
                                                 }
                                             }
                                             if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
-                                                var lt$12 = typeOf(lhs);
-                                                var rt$1 = typeOf(rhs);
+                                                var lt$12 = typeOf2(lhs);
+                                                var rt$1 = typeOf2(rhs);
                                                 if (lt$12.kind !== "string" || rt$1.kind !== "string") {
                                                     return compareBasic(ctx, lhs, rhs);
                                                 }
                                             }
                                             return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
                                         };
                                         Comparison.prototype.eachChild = function eachChild(fn2) {
@@ -224687,15 +225536,15 @@
                                 Length.prototype.evaluate = function evaluate(ctx) {
                                     var input = this.input.evaluate(ctx);
                                     if (typeof input === "string") {
                                         return input.length;
                                     } else if (Array.isArray(input)) {
                                         return input.length;
                                     } else {
-                                        throw new RuntimeError("Expected value to be of type string or array, but found " + toString2(typeOf(input)) + " instead.");
+                                        throw new RuntimeError("Expected value to be of type string or array, but found " + toString2(typeOf2(input)) + " instead.");
                                     }
                                 };
                                 Length.prototype.eachChild = function eachChild(fn2) {
                                     fn2(this.input);
                                 };
                                 Length.prototype.outputDefined = function outputDefined() {
                                     return false;
@@ -224800,15 +225649,15 @@
                                         }
                                     ],
                                     "typeof": [
                                         StringType,
                                         [ValueType],
                                         function(ctx, ref2) {
                                             var v2 = ref2[0];
-                                            return toString2(typeOf(v2.evaluate(ctx)));
+                                            return toString2(typeOf2(v2.evaluate(ctx)));
                                         }
                                     ],
                                     "to-rgba": [
                                         array2(NumberType, 4),
                                         [ColorType],
                                         function(ctx, ref2) {
                                             var v2 = ref2[0];
@@ -225863,15 +226712,15 @@
                                     return success(isFeatureConstant$1 ? new ZoomDependentExpression("camera", expression2.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression("composite", expression2.value, zoomCurve.labels, interpolationType));
                                 }
                                 var StylePropertyFunction = function StylePropertyFunction2(parameters, specification) {
                                     this._parameters = parameters;
                                     this._specification = specification;
                                     extend$12(this, createFunction(this._parameters, this._specification));
                                 };
-                                StylePropertyFunction.deserialize = function deserialize2(serialized) {
+                                StylePropertyFunction.deserialize = function deserialize3(serialized) {
                                     return new StylePropertyFunction(serialized._parameters, serialized._specification);
                                 };
                                 StylePropertyFunction.serialize = function serialize3(input) {
                                     return {
                                         _parameters: input._parameters,
                                         _specification: input._specification
                                     };
@@ -227247,23 +228096,23 @@
                                         klass,
                                         omit: options.omit || [],
                                         shallow: options.shallow || []
                                     };
                                 }
                                 register("Object", Object);
                                 gridIndex.serialize = function serialize3(grid, transferables) {
-                                    var buffer2 = grid.toArrayBuffer();
+                                    var buffer = grid.toArrayBuffer();
                                     if (transferables) {
-                                        transferables.push(buffer2);
+                                        transferables.push(buffer);
                                     }
                                     return {
-                                        buffer: buffer2
+                                        buffer
                                     };
                                 };
-                                gridIndex.deserialize = function deserialize2(serialized) {
+                                gridIndex.deserialize = function deserialize3(serialized) {
                                     return new gridIndex(serialized.buffer);
                                 };
                                 register("Grid", gridIndex);
                                 register("Color", Color2);
                                 register("Error", Error);
                                 register("ResolvedImage", ResolvedImage);
                                 register("StylePropertyFunction", StylePropertyFunction);
@@ -227350,20 +228199,20 @@
                                             properties2.$name = name3;
                                         }
                                         return properties2;
                                     }
                                     throw new Error("can't serialize object of type " + typeof input);
                                 }
 
-                                function deserialize(input) {
+                                function deserialize2(input) {
                                     if (input === null || input === void 0 || typeof input === "boolean" || typeof input === "number" || typeof input === "string" || input instanceof Boolean || input instanceof Number || input instanceof String || input instanceof Date || input instanceof RegExp || isArrayBuffer(input) || isImageBitmap(input) || ArrayBuffer.isView(input) || input instanceof ImageData2) {
                                         return input;
                                     }
                                     if (Array.isArray(input)) {
-                                        return input.map(deserialize);
+                                        return input.map(deserialize2);
                                     }
                                     if (typeof input === "object") {
                                         var name3 = input.$name || "Object";
                                         var ref2 = registry[name3];
                                         var klass = ref2.klass;
                                         if (!klass) {
                                             throw new Error("can't deserialize unregistered class " + name3);
@@ -227374,15 +228223,15 @@
                                         var result = Object.create(klass.prototype);
                                         for (var i2 = 0, list2 = Object.keys(input); i2 < list2.length; i2 += 1) {
                                             var key = list2[i2];
                                             if (key === "$name") {
                                                 continue;
                                             }
                                             var value = input[key];
-                                            result[key] = registry[name3].shallow.indexOf(key) >= 0 ? value : deserialize(value);
+                                            result[key] = registry[name3].shallow.indexOf(key) >= 0 ? value : deserialize2(value);
                                         }
                                         return result;
                                     }
                                     throw new Error("can't deserialize object of type " + typeof input);
                                 }
                                 var ZoomHistory = function ZoomHistory2() {
                                     this.first = true;
@@ -228600,15 +229449,15 @@
                                         transferables.push(array3.arrayBuffer);
                                     }
                                     return {
                                         length: array3.length,
                                         arrayBuffer: array3.arrayBuffer
                                     };
                                 };
-                                StructArray.deserialize = function deserialize2(input) {
+                                StructArray.deserialize = function deserialize3(input) {
                                     var structArray = Object.create(this.prototype);
                                     structArray.arrayBuffer = input.arrayBuffer;
                                     structArray.length = input.length;
                                     structArray.capacity = input.arrayBuffer.byteLength / structArray.bytesPerElement;
                                     structArray._refreshViews();
                                     return structArray;
                                 };
@@ -228655,28 +229504,28 @@
                                         return {
                                             name: member.name,
                                             type: member.type,
                                             components,
                                             offset: memberOffset
                                         };
                                     });
-                                    var size = align(offset2, Math.max(maxSize, alignment));
+                                    var size2 = align(offset2, Math.max(maxSize, alignment));
                                     return {
                                         members: layoutMembers,
-                                        size,
+                                        size: size2,
                                         alignment
                                     };
                                 }
 
                                 function sizeOf(type2) {
                                     return viewTypes[type2].BYTES_PER_ELEMENT;
                                 }
 
-                                function align(offset2, size) {
-                                    return Math.ceil(offset2 / size) * size;
+                                function align(offset2, size2) {
+                                    return Math.ceil(offset2 / size2) * size2;
                                 }
                                 var StructArrayLayout2i4 = function(StructArray2) {
                                     function StructArrayLayout2i42() {
                                         StructArray2.apply(this, arguments);
                                     }
                                     if (StructArray2)
                                         StructArrayLayout2i42.__proto__ = StructArray2;
@@ -230081,15 +230930,15 @@
                                         transferables.push(ids.buffer, positions.buffer);
                                     }
                                     return {
                                         ids,
                                         positions
                                     };
                                 };
-                                FeaturePositionMap.deserialize = function deserialize2(obj) {
+                                FeaturePositionMap.deserialize = function deserialize3(obj) {
                                     var map2 = new FeaturePositionMap();
                                     map2.ids = obj.ids;
                                     map2.positions = obj.positions;
                                     map2.indexed = true;
                                     return map2;
                                 };
                                 var MAX_SAFE_INTEGER$12 = Math.pow(2, 53) - 1;
@@ -231866,18 +232715,18 @@
                                         var circleBucket = bucket;
                                         return getMaximumPaintValue("circle-radius", this, circleBucket) + getMaximumPaintValue("circle-stroke-width", this, circleBucket) + translateDistance(this.paint.get("circle-translate"));
                                     };
                                     CircleStyleLayer2.prototype.queryIntersectsFeature = function queryIntersectsFeature(queryGeometry, feature, featureState, geometry, zoom, transform, pixelsToTileUnits, pixelPosMatrix) {
                                         var translatedPolygon = translate(queryGeometry, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), transform.angle, pixelsToTileUnits);
                                         var radius = this.paint.get("circle-radius").evaluate(feature, featureState);
                                         var stroke = this.paint.get("circle-stroke-width").evaluate(feature, featureState);
-                                        var size = radius + stroke;
+                                        var size2 = radius + stroke;
                                         var alignWithMap = this.paint.get("circle-pitch-alignment") === "map";
                                         var transformedPolygon = alignWithMap ? translatedPolygon : projectQueryGeometry(translatedPolygon, pixelPosMatrix);
-                                        var transformedSize = alignWithMap ? size * pixelsToTileUnits : size;
+                                        var transformedSize = alignWithMap ? size2 * pixelsToTileUnits : size2;
                                         for (var i$12 = 0, list$12 = geometry; i$12 < list$12.length; i$12 += 1) {
                                             var ring = list$12[i$12];
                                             for (var i2 = 0, list2 = ring; i2 < list2.length; i2 += 1) {
                                                 var point2 = list2[i2];
                                                 var transformedPoint = alignWithMap ? point2 : projectPoint(point2, pixelPosMatrix);
                                                 var adjustedSize = transformedSize;
                                                 var projectedCenter = transformMat4([], [
@@ -231967,55 +232816,55 @@
                                         height: Math.min(image2.height, height)
                                     }, channels);
                                     image2.width = width;
                                     image2.height = height;
                                     image2.data = newImage.data;
                                 }
 
-                                function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
-                                    if (size.width === 0 || size.height === 0) {
+                                function copyImage(srcImg, dstImg, srcPt, dstPt, size2, channels) {
+                                    if (size2.width === 0 || size2.height === 0) {
                                         return dstImg;
                                     }
-                                    if (size.width > srcImg.width || size.height > srcImg.height || srcPt.x > srcImg.width - size.width || srcPt.y > srcImg.height - size.height) {
+                                    if (size2.width > srcImg.width || size2.height > srcImg.height || srcPt.x > srcImg.width - size2.width || srcPt.y > srcImg.height - size2.height) {
                                         throw new RangeError("out of range source coordinates for image copy");
                                     }
-                                    if (size.width > dstImg.width || size.height > dstImg.height || dstPt.x > dstImg.width - size.width || dstPt.y > dstImg.height - size.height) {
+                                    if (size2.width > dstImg.width || size2.height > dstImg.height || dstPt.x > dstImg.width - size2.width || dstPt.y > dstImg.height - size2.height) {
                                         throw new RangeError("out of range destination coordinates for image copy");
                                     }
                                     var srcData = srcImg.data;
                                     var dstData = dstImg.data;
-                                    for (var y2 = 0; y2 < size.height; y2++) {
+                                    for (var y2 = 0; y2 < size2.height; y2++) {
                                         var srcOffset = ((srcPt.y + y2) * srcImg.width + srcPt.x) * channels;
                                         var dstOffset = ((dstPt.y + y2) * dstImg.width + dstPt.x) * channels;
-                                        for (var i2 = 0; i2 < size.width * channels; i2++) {
+                                        for (var i2 = 0; i2 < size2.width * channels; i2++) {
                                             dstData[dstOffset + i2] = srcData[srcOffset + i2];
                                         }
                                     }
                                     return dstImg;
                                 }
-                                var AlphaImage = function AlphaImage2(size, data2) {
-                                    createImage(this, size, 1, data2);
+                                var AlphaImage = function AlphaImage2(size2, data2) {
+                                    createImage(this, size2, 1, data2);
                                 };
-                                AlphaImage.prototype.resize = function resize(size) {
-                                    resizeImage(this, size, 1);
+                                AlphaImage.prototype.resize = function resize(size2) {
+                                    resizeImage(this, size2, 1);
                                 };
                                 AlphaImage.prototype.clone = function clone3() {
                                     return new AlphaImage({
                                         width: this.width,
                                         height: this.height
                                     }, new Uint8Array(this.data));
                                 };
-                                AlphaImage.copy = function copy2(srcImg, dstImg, srcPt, dstPt, size) {
-                                    copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);
+                                AlphaImage.copy = function copy2(srcImg, dstImg, srcPt, dstPt, size2) {
+                                    copyImage(srcImg, dstImg, srcPt, dstPt, size2, 1);
                                 };
-                                var RGBAImage = function RGBAImage2(size, data2) {
-                                    createImage(this, size, 4, data2);
+                                var RGBAImage = function RGBAImage2(size2, data2) {
+                                    createImage(this, size2, 4, data2);
                                 };
-                                RGBAImage.prototype.resize = function resize(size) {
-                                    resizeImage(this, size, 4);
+                                RGBAImage.prototype.resize = function resize(size2) {
+                                    resizeImage(this, size2, 4);
                                 };
                                 RGBAImage.prototype.replace = function replace2(data2, copy2) {
                                     if (copy2) {
                                         this.data.set(data2);
                                     } else if (data2 instanceof Uint8ClampedArray) {
                                         this.data = new Uint8Array(data2.buffer);
                                     } else {
@@ -232024,16 +232873,16 @@
                                 };
                                 RGBAImage.prototype.clone = function clone3() {
                                     return new RGBAImage({
                                         width: this.width,
                                         height: this.height
                                     }, new Uint8Array(this.data));
                                 };
-                                RGBAImage.copy = function copy2(srcImg, dstImg, srcPt, dstPt, size) {
-                                    copyImage(srcImg, dstImg, srcPt, dstPt, size, 4);
+                                RGBAImage.copy = function copy2(srcImg, dstImg, srcPt, dstPt, size2) {
+                                    copyImage(srcImg, dstImg, srcPt, dstPt, size2, 4);
                                 };
                                 register("AlphaImage", AlphaImage);
                                 register("RGBAImage", RGBAImage);
                                 var paint$2 = new Properties({
                                     "heatmap-radius": new DataDrivenProperty(spec["paint_heatmap"]["heatmap-radius"]),
                                     "heatmap-weight": new DataDrivenProperty(spec["paint_heatmap"]["heatmap-weight"]),
                                     "heatmap-intensity": new DataConstantProperty(spec["paint_heatmap"]["heatmap-intensity"]),
@@ -232979,16 +233828,16 @@
                                     this.indexBuffer.destroy();
                                     this.indexBuffer2.destroy();
                                     this.programConfigurations.destroy();
                                     this.segments.destroy();
                                     this.segments2.destroy();
                                 };
                                 FillBucket.prototype.addFeature = function addFeature2(feature, geometry, index2, canonical, imagePositions) {
-                                    for (var i$42 = 0, list$2 = classifyRings(geometry, EARCUT_MAX_RINGS); i$42 < list$2.length; i$42 += 1) {
-                                        var polygon2 = list$2[i$42];
+                                    for (var i$42 = 0, list$22 = classifyRings(geometry, EARCUT_MAX_RINGS); i$42 < list$22.length; i$42 += 1) {
+                                        var polygon2 = list$22[i$42];
                                         var numVertices = 0;
                                         for (var i$22 = 0, list2 = polygon2; i$22 < list2.length; i$22 += 1) {
                                             var ring = list2[i$22];
                                             numVertices += ring.length;
                                         }
                                         var triangleSegment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);
                                         var triangleIndex = triangleSegment.vertexLength;
@@ -233209,27 +234058,27 @@
                                         x1,
                                         y1,
                                         x22,
                                         y22
                                     ];
                                 };
                                 VectorTileFeature.prototype.toGeoJSON = function(x2, y2, z2) {
-                                    var size = this.extent * Math.pow(2, z2),
+                                    var size2 = this.extent * Math.pow(2, z2),
                                         x0 = this.extent * x2,
                                         y0 = this.extent * y2,
                                         coords = this.loadGeometry(),
                                         type2 = VectorTileFeature.types[this.type],
                                         i2, j2;
 
                                     function project(line) {
                                         for (var j3 = 0; j3 < line.length; j3++) {
                                             var p2 = line[j3],
-                                                y22 = 180 - (p2.y + y0) * 360 / size;
+                                                y22 = 180 - (p2.y + y0) * 360 / size2;
                                             line[j3] = [
-                                                (p2.x + x0) * 360 / size - 180,
+                                                (p2.x + x0) * 360 / size2 - 180,
                                                 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90
                                             ];
                                         }
                                     }
                                     switch (this.type) {
                                         case 1:
                                             var points = [];
@@ -233524,16 +234373,16 @@
                                         }
                                         if (vectorTileFeatureTypes[feature.type] !== "Polygon") {
                                             continue;
                                         }
                                         var flattened2 = [];
                                         var holeIndices = [];
                                         var triangleIndex = segment.vertexLength;
-                                        for (var i$32 = 0, list$2 = polygon2; i$32 < list$2.length; i$32 += 1) {
-                                            var ring$2 = list$2[i$32];
+                                        for (var i$32 = 0, list$22 = polygon2; i$32 < list$22.length; i$32 += 1) {
+                                            var ring$2 = list$22[i$32];
                                             if (ring$2.length === 0) {
                                                 continue;
                                             }
                                             if (ring$2 !== polygon2[0]) {
                                                 holeIndices.push(flattened2.length / 2);
                                             }
                                             for (var i2 = 0; i2 < ring$2.length; i2++) {
@@ -234675,43 +235524,43 @@
                                         } else {
                                             output2 += input[i2];
                                         }
                                     }
                                     return output2;
                                 }
                                 var ONE_EM = 24;
-                                var read2 = function(buffer2, offset2, isLE, mLen, nBytes) {
+                                var read2 = function(buffer, offset2, isLE, mLen, nBytes) {
                                     var e3, m2;
                                     var eLen = nBytes * 8 - mLen - 1;
                                     var eMax = (1 << eLen) - 1;
                                     var eBias = eMax >> 1;
                                     var nBits = -7;
                                     var i2 = isLE ? nBytes - 1 : 0;
                                     var d2 = isLE ? -1 : 1;
-                                    var s2 = buffer2[offset2 + i2];
+                                    var s2 = buffer[offset2 + i2];
                                     i2 += d2;
                                     e3 = s2 & (1 << -nBits) - 1;
                                     s2 >>= -nBits;
                                     nBits += eLen;
-                                    for (; nBits > 0; e3 = e3 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {}
+                                    for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {}
                                     m2 = e3 & (1 << -nBits) - 1;
                                     e3 >>= -nBits;
                                     nBits += mLen;
-                                    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {}
+                                    for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {}
                                     if (e3 === 0) {
                                         e3 = 1 - eBias;
                                     } else if (e3 === eMax) {
                                         return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
                                     } else {
                                         m2 = m2 + Math.pow(2, mLen);
                                         e3 = e3 - eBias;
                                     }
                                     return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
                                 };
-                                var write2 = function(buffer2, value, offset2, isLE, mLen, nBytes) {
+                                var write2 = function(buffer, value, offset2, isLE, mLen, nBytes) {
                                     var e3, m2, c2;
                                     var eLen = nBytes * 8 - mLen - 1;
                                     var eMax = (1 << eLen) - 1;
                                     var eBias = eMax >> 1;
                                     var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                                     var i2 = isLE ? 0 : nBytes - 1;
                                     var d2 = isLE ? 1 : -1;
@@ -234742,19 +235591,19 @@
                                             m2 = (value * c2 - 1) * Math.pow(2, mLen);
                                             e3 = e3 + eBias;
                                         } else {
                                             m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                                             e3 = 0;
                                         }
                                     }
-                                    for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {}
+                                    for (; mLen >= 8; buffer[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {}
                                     e3 = e3 << mLen | m2;
                                     eLen += mLen;
-                                    for (; eLen > 0; buffer2[offset2 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {}
-                                    buffer2[offset2 + i2 - d2] |= s2 * 128;
+                                    for (; eLen > 0; buffer[offset2 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {}
+                                    buffer[offset2 + i2 - d2] |= s2 * 128;
                                 };
                                 var ieee754 = {
                                     read: read2,
                                     write: write2
                                 };
                                 var pbf = Pbf;
 
@@ -234867,17 +235716,17 @@
                                         if (end2 - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
                                             return readUtf8TextDecoder(this.buf, pos, end2);
                                         }
                                         return readUtf8(this.buf, pos, end2);
                                     },
                                     readBytes: function() {
                                         var end2 = this.readVarint() + this.pos,
-                                            buffer2 = this.buf.subarray(this.pos, end2);
+                                            buffer = this.buf.subarray(this.pos, end2);
                                         this.pos = end2;
-                                        return buffer2;
+                                        return buffer;
                                     },
                                     readPackedVarint: function(arr, isSigned) {
                                         if (this.type !== Pbf.Bytes) {
                                             return arr.push(this.readVarint(isSigned));
                                         }
                                         var end2 = readPackedEnd(this);
                                         arr = arr || [];
@@ -235077,20 +235926,20 @@
                                         this.pos += 4;
                                     },
                                     writeDouble: function(val) {
                                         this.realloc(8);
                                         ieee754.write(this.buf, val, this.pos, true, 52, 8);
                                         this.pos += 8;
                                     },
-                                    writeBytes: function(buffer2) {
-                                        var len = buffer2.length;
+                                    writeBytes: function(buffer) {
+                                        var len = buffer.length;
                                         this.writeVarint(len);
                                         this.realloc(len);
                                         for (var i2 = 0; i2 < len; i2++) {
-                                            this.buf[this.pos++] = buffer2[i2];
+                                            this.buf[this.pos++] = buffer[i2];
                                         }
                                     },
                                     writeRawMessage: function(fn2, obj) {
                                         this.pos++;
                                         var startPos = this.pos;
                                         fn2(obj, this);
                                         var len = this.pos - startPos;
@@ -235146,17 +235995,17 @@
                                         }
                                     },
                                     writePackedSFixed64: function(tag, arr) {
                                         if (arr.length) {
                                             this.writeMessage(tag, writePackedSFixed64, arr);
                                         }
                                     },
-                                    writeBytesField: function(tag, buffer2) {
+                                    writeBytesField: function(tag, buffer) {
                                         this.writeTag(tag, Pbf.Bytes);
-                                        this.writeBytes(buffer2);
+                                        this.writeBytes(buffer);
                                     },
                                     writeFixed32Field: function(tag, val) {
                                         this.writeTag(tag, Pbf.Fixed32);
                                         this.writeFixed32(val);
                                     },
                                     writeSFixed32Field: function(tag, val) {
                                         this.writeTag(tag, Pbf.Fixed32);
@@ -236200,27 +237049,27 @@
                                                 var imagePosition = imagePositions[section.imageName];
                                                 if (!imagePosition) {
                                                     continue;
                                                 }
                                                 imageName = section.imageName;
                                                 shaping.iconsInText = shaping.iconsInText || true;
                                                 rect = imagePosition.paddedRect;
-                                                var size = imagePosition.displaySize;
+                                                var size2 = imagePosition.displaySize;
                                                 section.scale = section.scale * ONE_EM / layoutTextSizeThisZoom;
                                                 metrics = {
-                                                    width: size[0],
-                                                    height: size[1],
+                                                    width: size2[0],
+                                                    height: size2[1],
                                                     left: IMAGE_PADDING,
                                                     top: -GLYPH_PBF_BORDER,
-                                                    advance: vertical ? size[1] : size[0]
+                                                    advance: vertical ? size2[1] : size2[0]
                                                 };
-                                                var imageOffset = ONE_EM - size[1] * section.scale;
+                                                var imageOffset = ONE_EM - size2[1] * section.scale;
                                                 baselineOffset2 = maxLineOffset + imageOffset;
                                                 verticalAdvance = metrics.advance;
-                                                var offset2 = vertical ? size[0] * section.scale - ONE_EM * lineMaxScale : size[1] * section.scale - ONE_EM * lineMaxScale;
+                                                var offset2 = vertical ? size2[0] * section.scale - ONE_EM * lineMaxScale : size2[1] * section.scale - ONE_EM * lineMaxScale;
                                                 if (offset2 > 0 && offset2 > lineOffset) {
                                                     lineOffset = offset2;
                                                 }
                                             }
                                             if (!vertical) {
                                                 positionedGlyphs.push({
                                                     glyph: codePoint,
@@ -237466,16 +238315,16 @@
                                                 var shapedText = defaultHorizontalShaping;
                                                 if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {
                                                     addSymbolAtAnchor(line, anchor);
                                                 }
                                             }
                                         }
                                     } else if (symbolPlacement === "line-center") {
-                                        for (var i$22 = 0, list$2 = feature.geometry; i$22 < list$2.length; i$22 += 1) {
-                                            var line$1 = list$2[i$22];
+                                        for (var i$22 = 0, list$22 = feature.geometry; i$22 < list$22.length; i$22 += 1) {
+                                            var line$1 = list$22[i$22];
                                             if (line$1.length > 1) {
                                                 var anchor$1 = getCenterAnchor(line$1, textMaxAngle, shapedTextOrientations.vertical || defaultHorizontalShaping, shapedIcon, glyphSize, textMaxBoxScale);
                                                 if (anchor$1) {
                                                     addSymbolAtAnchor(line$1, anchor$1);
                                                 }
                                             }
                                         }
@@ -238452,15 +239301,15 @@
                                         if (textField.value.kind === "constant" && textField.value.value instanceof Formatted) {
                                             checkSections(textField.value.value.sections);
                                         } else if (textField.value.kind === "source") {
                                             var checkExpression = function(expression2) {
                                                 if (hasOverrides) {
                                                     return;
                                                 }
-                                                if (expression2 instanceof Literal && typeOf(expression2.value) === FormattedType) {
+                                                if (expression2 instanceof Literal && typeOf2(expression2.value) === FormattedType) {
                                                     var formatted = expression2.value;
                                                     checkSections(formatted.sections);
                                                 } else if (expression2 instanceof FormatExpression) {
                                                     checkSections(expression2.sections);
                                                 } else {
                                                     expression2.eachChild(checkExpression);
                                                 }
@@ -238786,17 +239635,17 @@
                                 Actor.prototype.processTask = function processTask(id3, task) {
                                     var this$1$1 = this;
                                     if (task.type === "<response>") {
                                         var callback = this.callbacks[id3];
                                         delete this.callbacks[id3];
                                         if (callback) {
                                             if (task.error) {
-                                                callback(deserialize(task.error));
+                                                callback(deserialize2(task.error));
                                             } else {
-                                                callback(null, deserialize(task.data));
+                                                callback(null, deserialize2(task.data));
                                             }
                                         }
                                     } else {
                                         var completed = false;
                                         var buffers = isSafari2(this.globalScope) ? void 0 : [];
                                         var done = task.hasCallback ? function(err, data2) {
                                             completed = true;
@@ -238808,15 +239657,15 @@
                                                 error: err ? serialize2(err) : null,
                                                 data: serialize2(data2, buffers)
                                             }, buffers);
                                         } : function(_2) {
                                             completed = true;
                                         };
                                         var callback$1 = null;
-                                        var params = deserialize(task.data);
+                                        var params = deserialize2(task.data);
                                         if (this.parent[task.type]) {
                                             callback$1 = this.parent[task.type](task.sourceMapId, params, done);
                                         } else if (this.parent.getWorkerSource) {
                                             var keys2 = task.type.split(".");
                                             var scope2 = this.parent.getWorkerSource(task.sourceMapId, keys2[0], params.source);
                                             callback$1 = scope2[keys2[1]](params, done);
                                         } else {
@@ -239711,19 +240560,19 @@
                                     };
                                 }
 
                                 function topDownFeatureComparator(a2, b2) {
                                     return b2 - a2;
                                 }
                                 var CLOCK_SKEW_RETRY_TIMEOUT = 3e4;
-                                var Tile = function Tile2(tileID, size) {
+                                var Tile = function Tile2(tileID, size2) {
                                     this.tileID = tileID;
                                     this.uid = uniqueId();
                                     this.uses = 0;
-                                    this.tileSize = size;
+                                    this.tileSize = size2;
                                     this.buckets = {};
                                     this.expirationTime = null;
                                     this.queryPadding = 0;
                                     this.hasSymbolBuckets = false;
                                     this.hasRTLText = false;
                                     this.dependencies = {};
                                     this.expiredRequestCount = 0;
@@ -240274,16 +241123,16 @@
                                         var id2 = list$12[i$12];
                                         delete this.keyCache[id2];
                                         delete this._layerConfigs[id2];
                                         delete this._layers[id2];
                                     }
                                     this.familiesBySource = {};
                                     var groups = groupByLayout(performance2.values(this._layerConfigs), this.keyCache);
-                                    for (var i$22 = 0, list$2 = groups; i$22 < list$2.length; i$22 += 1) {
-                                        var layerConfigs$1 = list$2[i$22];
+                                    for (var i$22 = 0, list$22 = groups; i$22 < list$22.length; i$22 += 1) {
+                                        var layerConfigs$1 = list$22[i$22];
                                         var layers = layerConfigs$1.map(function(layerConfig2) {
                                             return this$1$1._layers[layerConfig2.id];
                                         });
                                         var layer$1 = layers[0];
                                         if (layer$1.visibility === "none") {
                                             continue;
                                         }
@@ -240739,16 +241588,16 @@
                                         for (var i2 = 0, list2 = this._feature.geometry; i2 < list2.length; i2 += 1) {
                                             var point2 = list2[i2];
                                             geometry.push([new performance2.Point$1(point2[0], point2[1])]);
                                         }
                                         return geometry;
                                     } else {
                                         var geometry$1 = [];
-                                        for (var i$22 = 0, list$2 = this._feature.geometry; i$22 < list$2.length; i$22 += 1) {
-                                            var ring = list$2[i$22];
+                                        for (var i$22 = 0, list$22 = this._feature.geometry; i$22 < list$22.length; i$22 += 1) {
+                                            var ring = list$22[i$22];
                                             var newRing = [];
                                             for (var i$12 = 0, list$12 = ring; i$12 < list$12.length; i$12 += 1) {
                                                 var point$12 = list$12[i$12];
                                                 newRing.push(new performance2.Point$1(point$12[0], point$12[1]));
                                             }
                                             geometry$1.push(newRing);
                                         }
@@ -241432,16 +242281,16 @@
                                                 }
                                             }
                                             p2.parentId = id2;
                                             clusters.push(createCluster(wx / numPoints, wy / numPoints, id2, numPoints, clusterProperties));
                                         } else {
                                             clusters.push(p2);
                                             if (numPoints > 1) {
-                                                for (var i$32 = 0, list$2 = neighborIds; i$32 < list$2.length; i$32 += 1) {
-                                                    var neighborId$2 = list$2[i$32];
+                                                for (var i$32 = 0, list$22 = neighborIds; i$32 < list$22.length; i$32 += 1) {
+                                                    var neighborId$2 = list$22[i$32];
                                                     var b$22 = tree.points[neighborId$2];
                                                     if (b$22.zoom <= zoom) {
                                                         continue;
                                                     }
                                                     b$22.zoom = zoom;
                                                     clusters.push(b$22);
                                                 }
@@ -241719,36 +242568,36 @@
                                     out.push(projectX(coords[0]));
                                     out.push(projectY(coords[1]));
                                     out.push(0);
                                 }
 
                                 function convertLine(ring, out, tolerance, isPolygon) {
                                     var x0, y0;
-                                    var size = 0;
+                                    var size2 = 0;
                                     for (var j2 = 0; j2 < ring.length; j2++) {
                                         var x2 = projectX(ring[j2][0]);
                                         var y2 = projectY(ring[j2][1]);
                                         out.push(x2);
                                         out.push(y2);
                                         out.push(0);
                                         if (j2 > 0) {
                                             if (isPolygon) {
-                                                size += (x0 * y2 - x2 * y0) / 2;
+                                                size2 += (x0 * y2 - x2 * y0) / 2;
                                             } else {
-                                                size += Math.sqrt(Math.pow(x2 - x0, 2) + Math.pow(y2 - y0, 2));
+                                                size2 += Math.sqrt(Math.pow(x2 - x0, 2) + Math.pow(y2 - y0, 2));
                                             }
                                         }
                                         x0 = x2;
                                         y0 = y2;
                                     }
                                     var last = out.length - 3;
                                     out[2] = 1;
                                     simplify(out, 0, last, tolerance);
                                     out[last + 2] = 1;
-                                    out.size = Math.abs(size);
+                                    out.size = Math.abs(size2);
                                     out.start = 0;
                                     out.end = out.size;
                                 }
 
                                 function convertLines(rings, out, tolerance, isPolygon) {
                                     for (var i2 = 0; i2 < rings.length; i2++) {
                                         var geom = [];
@@ -241944,20 +242793,20 @@
                                     out.push(ax + (bx - ax) * t2);
                                     out.push(y2);
                                     out.push(1);
                                     return t2;
                                 }
 
                                 function wrap2(features, options) {
-                                    var buffer2 = options.buffer / options.extent;
+                                    var buffer = options.buffer / options.extent;
                                     var merged = features;
-                                    var left2 = clip2(features, 1, -1 - buffer2, buffer2, 0, -1, 2, options);
-                                    var right2 = clip2(features, 1, 1 - buffer2, 2 + buffer2, 0, -1, 2, options);
+                                    var left2 = clip2(features, 1, -1 - buffer, buffer, 0, -1, 2, options);
+                                    var right2 = clip2(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);
                                     if (left2 || right2) {
-                                        merged = clip2(features, 1, -buffer2, 1 + buffer2, 0, -1, 2, options) || [];
+                                        merged = clip2(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];
                                         if (left2) {
                                             merged = shiftFeatureCoords(left2, 1).concat(merged);
                                         }
                                         if (right2) {
                                             merged = merged.concat(shiftFeatureCoords(right2, -1));
                                         }
                                     }
@@ -243136,22 +243985,22 @@
                                         }
                                         if (!this._validateContent(image2.content, image2)) {
                                             this.fire(new performance2.ErrorEvent(new Error('Image "' + id2 + '" has invalid "content" value')));
                                             valid2 = false;
                                         }
                                         return valid2;
                                     };
-                                    ImageManager2.prototype._validateStretch = function _validateStretch(stretch, size) {
+                                    ImageManager2.prototype._validateStretch = function _validateStretch(stretch, size2) {
                                         if (!stretch) {
                                             return true;
                                         }
                                         var last = 0;
                                         for (var i2 = 0, list2 = stretch; i2 < list2.length; i2 += 1) {
                                             var part = list2[i2];
-                                            if (part[0] < last || part[1] < part[0] || size < part[1]) {
+                                            if (part[0] < last || part[1] < part[0] || size2 < part[1]) {
                                                 return false;
                                             }
                                             last = part[1];
                                         }
                                         return true;
                                     };
                                     ImageManager2.prototype._validateContent = function _validateContent(content2, image2) {
@@ -243403,35 +244252,35 @@
                                         }
                                     });
                                 }
                                 var tinySdf = TinySDF;
                                 var default_1 = TinySDF;
                                 var INF = 1e20;
 
-                                function TinySDF(fontSize2, buffer2, radius, cutoff, fontFamily, fontWeight) {
+                                function TinySDF(fontSize2, buffer, radius, cutoff, fontFamily, fontWeight) {
                                     this.fontSize = fontSize2 || 24;
-                                    this.buffer = buffer2 === void 0 ? 3 : buffer2;
+                                    this.buffer = buffer === void 0 ? 3 : buffer;
                                     this.cutoff = cutoff || 0.25;
                                     this.fontFamily = fontFamily || "sans-serif";
                                     this.fontWeight = fontWeight || "normal";
                                     this.radius = radius || 8;
-                                    var size = this.size = this.fontSize + this.buffer * 2;
+                                    var size2 = this.size = this.fontSize + this.buffer * 2;
                                     this.canvas = document.createElement("canvas");
-                                    this.canvas.width = this.canvas.height = size;
+                                    this.canvas.width = this.canvas.height = size2;
                                     this.ctx = this.canvas.getContext("2d");
                                     this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily;
                                     this.ctx.textBaseline = "middle";
                                     this.ctx.fillStyle = "black";
-                                    this.gridOuter = new Float64Array(size * size);
-                                    this.gridInner = new Float64Array(size * size);
-                                    this.f = new Float64Array(size);
-                                    this.d = new Float64Array(size);
-                                    this.z = new Float64Array(size + 1);
-                                    this.v = new Int16Array(size);
-                                    this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
+                                    this.gridOuter = new Float64Array(size2 * size2);
+                                    this.gridInner = new Float64Array(size2 * size2);
+                                    this.f = new Float64Array(size2);
+                                    this.d = new Float64Array(size2);
+                                    this.z = new Float64Array(size2 + 1);
+                                    this.v = new Int16Array(size2);
+                                    this.middle = Math.round(size2 / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
                                 }
                                 TinySDF.prototype.draw = function(char) {
                                     this.ctx.clearRect(0, 0, this.size, this.size);
                                     this.ctx.fillText(char, this.buffer, this.middle);
                                     var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
                                     var alphaChannel = new Uint8ClampedArray(this.size * this.size);
                                     for (var i2 = 0; i2 < this.size * this.size; i2++) {
@@ -245127,15 +245976,15 @@
                                     var bucketQueryData = [];
                                     for (var i2 = 0, list2 = Object.keys(renderedSymbols).map(Number); i2 < list2.length; i2 += 1) {
                                         var bucketInstanceId = list2[i2];
                                         bucketQueryData.push(retainedQueryData[bucketInstanceId]);
                                     }
                                     bucketQueryData.sort(sortTilesIn);
                                     var loop = function() {
-                                        var queryData = list$2[i$22];
+                                        var queryData = list$22[i$22];
                                         var bucketSymbols = queryData.featureIndex.lookupSymbolFeatures(renderedSymbols[queryData.bucketInstanceId], serializedLayers, queryData.bucketIndex, queryData.sourceLayerIndex, params.filter, params.layers, params.availableImages, styleLayers);
                                         for (var layerID in bucketSymbols) {
                                             var resultFeatures = result[layerID] = result[layerID] || [];
                                             var layerSymbols = bucketSymbols[layerID];
                                             layerSymbols.sort(function(a2, b2) {
                                                 var featureSortOrder = queryData.featureSortOrder;
                                                 if (featureSortOrder) {
@@ -245148,15 +245997,15 @@
                                             });
                                             for (var i$12 = 0, list$12 = layerSymbols; i$12 < list$12.length; i$12 += 1) {
                                                 var symbolFeature = list$12[i$12];
                                                 resultFeatures.push(symbolFeature);
                                             }
                                         }
                                     };
-                                    for (var i$22 = 0, list$2 = bucketQueryData; i$22 < list$2.length; i$22 += 1)
+                                    for (var i$22 = 0, list$22 = bucketQueryData; i$22 < list$22.length; i$22 += 1)
                                         loop();
                                     var loop$1 = function(layerName2) {
                                         result[layerName2].forEach(function(featureWrapper) {
                                             var feature = featureWrapper.feature;
                                             var layer = styleLayers[layerName2];
                                             var sourceCache = sourceCaches[layer.source];
                                             var state = sourceCache.getFeatureState(feature.layer["source-layer"], feature.id);
@@ -247467,15 +248316,15 @@
                                     before = before || [];
                                     after = after || [];
                                     var beforeOrder = before.map(pluckId);
                                     var afterOrder = after.map(pluckId);
                                     var beforeIndex = before.reduce(indexById, {});
                                     var afterIndex = after.reduce(indexById, {});
                                     var tracker = beforeOrder.slice();
-                                    var clean2 = /* @__PURE__ */ Object.create(null);
+                                    var clean = /* @__PURE__ */ Object.create(null);
                                     var i2, d2, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;
                                     for (i2 = 0, d2 = 0; i2 < beforeOrder.length; i2++) {
                                         layerId = beforeOrder[i2];
                                         if (!afterIndex.hasOwnProperty(layerId)) {
                                             commands.push({
                                                 command: operations.removeLayer,
                                                 args: [layerId]
@@ -247504,21 +248353,21 @@
                                             command: operations.addLayer,
                                             args: [
                                                 afterIndex[layerId],
                                                 insertBeforeLayerId
                                             ]
                                         });
                                         tracker.splice(tracker.length - i2, 0, layerId);
-                                        clean2[layerId] = true;
+                                        clean[layerId] = true;
                                     }
                                     for (i2 = 0; i2 < afterOrder.length; i2++) {
                                         layerId = afterOrder[i2];
                                         beforeLayer = beforeIndex[layerId];
                                         afterLayer = afterIndex[layerId];
-                                        if (clean2[layerId] || performance2.deepEqual(beforeLayer, afterLayer)) {
+                                        if (clean[layerId] || performance2.deepEqual(beforeLayer, afterLayer)) {
                                             continue;
                                         }
                                         if (!performance2.deepEqual(beforeLayer.source, afterLayer.source) || !performance2.deepEqual(beforeLayer["source-layer"], afterLayer["source-layer"]) || !performance2.deepEqual(beforeLayer.type, afterLayer.type)) {
                                             commands.push({
                                                 command: operations.removeLayer,
                                                 args: [layerId]
                                             });
@@ -250333,16 +251182,16 @@
                                                     features3D.pop();
                                                 }
                                             } else {
                                                 for (var i$42 = 0, list$3 = sourceResults; i$42 < list$3.length; i$42 += 1) {
                                                     var sourceResult$1 = list$3[i$42];
                                                     var layerFeatures$1 = sourceResult$1[layerId$1];
                                                     if (layerFeatures$1) {
-                                                        for (var i$32 = 0, list$2 = layerFeatures$1; i$32 < list$2.length; i$32 += 1) {
-                                                            var featureWrapper$1 = list$2[i$32];
+                                                        for (var i$32 = 0, list$22 = layerFeatures$1; i$32 < list$22.length; i$32 += 1) {
+                                                            var featureWrapper$1 = list$22[i$32];
                                                             features.push(featureWrapper$1.feature);
                                                         }
                                                     }
                                                 }
                                             }
                                         }
                                         return features;
@@ -251537,45 +252386,45 @@
                                         "u_texture": new performance2.Uniform1i(context2, locations.u_texture),
                                         "u_texture_icon": new performance2.Uniform1i(context2, locations.u_texture_icon),
                                         "u_gamma_scale": new performance2.Uniform1f(context2, locations.u_gamma_scale),
                                         "u_device_pixel_ratio": new performance2.Uniform1f(context2, locations.u_device_pixel_ratio),
                                         "u_is_halo": new performance2.Uniform1i(context2, locations.u_is_halo)
                                     };
                                 };
-                                var symbolIconUniformValues = function(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize) {
+                                var symbolIconUniformValues = function(functionType, size2, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize) {
                                     var transform = painter.transform;
                                     return {
                                         "u_is_size_zoom_constant": +(functionType === "constant" || functionType === "source"),
                                         "u_is_size_feature_constant": +(functionType === "constant" || functionType === "camera"),
-                                        "u_size_t": size ? size.uSizeT : 0,
-                                        "u_size": size ? size.uSize : 0,
+                                        "u_size_t": size2 ? size2.uSizeT : 0,
+                                        "u_size": size2 ? size2.uSize : 0,
                                         "u_camera_to_center_distance": transform.cameraToCenterDistance,
                                         "u_pitch": transform.pitch / 360 * 2 * Math.PI,
                                         "u_rotate_symbol": +rotateInShader,
                                         "u_aspect_ratio": transform.width / transform.height,
                                         "u_fade_change": painter.options.fadeDuration ? painter.symbolFadeChange : 1,
                                         "u_matrix": matrix,
                                         "u_label_plane_matrix": labelPlaneMatrix,
                                         "u_coord_matrix": glCoordMatrix,
                                         "u_is_text": +isText,
                                         "u_pitch_with_map": +pitchWithMap,
                                         "u_texsize": texSize,
                                         "u_texture": 0
                                     };
                                 };
-                                var symbolSDFUniformValues = function(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize, isHalo) {
+                                var symbolSDFUniformValues = function(functionType, size2, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize, isHalo) {
                                     var transform = painter.transform;
-                                    return performance2.extend(symbolIconUniformValues(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize), {
+                                    return performance2.extend(symbolIconUniformValues(functionType, size2, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, isText, texSize), {
                                         "u_gamma_scale": pitchWithMap ? Math.cos(transform._pitch) * transform.cameraToCenterDistance : 1,
                                         "u_device_pixel_ratio": performance2.browser.devicePixelRatio,
                                         "u_is_halo": +isHalo
                                     });
                                 };
-                                var symbolTextAndIconUniformValues = function(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, texSizeSDF, texSizeIcon) {
-                                    return performance2.extend(symbolSDFUniformValues(functionType, size, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, true, texSizeSDF, true), {
+                                var symbolTextAndIconUniformValues = function(functionType, size2, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, texSizeSDF, texSizeIcon) {
+                                    return performance2.extend(symbolSDFUniformValues(functionType, size2, rotateInShader, pitchWithMap, painter, matrix, labelPlaneMatrix, glCoordMatrix, true, texSizeSDF, true), {
                                         "u_texsize_icon": texSizeIcon,
                                         "u_texture_icon": 1
                                     });
                                 };
                                 var backgroundUniforms = function(context2, locations) {
                                     return {
                                         "u_matrix": new performance2.UniformMatrix4f(context2, locations.u_matrix),
@@ -251778,26 +252627,26 @@
                                         var coord = list2[i2];
                                         var tile = sourceCache.getTile(coord);
                                         var bucket = tile.getBucket(layer);
                                         if (!bucket || !bucket.text || !bucket.text.segments.get().length) {
                                             continue;
                                         }
                                         var sizeData = bucket.textSizeData;
-                                        var size = performance2.evaluateSizeForZoom(sizeData, tr2.zoom);
+                                        var size2 = performance2.evaluateSizeForZoom(sizeData, tr2.zoom);
                                         var pixelToTileScale = pixelsToTileUnits(tile, 1, painter.transform.zoom);
                                         var labelPlaneMatrix = getLabelPlaneMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, pixelToTileScale);
                                         var updateTextFitIcon = layer.layout.get("icon-text-fit") !== "none" && bucket.hasIconData();
-                                        if (size) {
+                                        if (size2) {
                                             var tileScale = Math.pow(2, tr2.zoom - tile.tileID.overscaledZ);
-                                            updateVariableAnchorsForBucket(bucket, rotateWithMap, pitchWithMap, variableOffsets, performance2.symbolSize, tr2, labelPlaneMatrix, coord.posMatrix, tileScale, size, updateTextFitIcon);
+                                            updateVariableAnchorsForBucket(bucket, rotateWithMap, pitchWithMap, variableOffsets, performance2.symbolSize, tr2, labelPlaneMatrix, coord.posMatrix, tileScale, size2, updateTextFitIcon);
                                         }
                                     }
                                 }
 
-                                function updateVariableAnchorsForBucket(bucket, rotateWithMap, pitchWithMap, variableOffsets, symbolSize, transform, labelPlaneMatrix, posMatrix, tileScale, size, updateTextFitIcon) {
+                                function updateVariableAnchorsForBucket(bucket, rotateWithMap, pitchWithMap, variableOffsets, symbolSize, transform, labelPlaneMatrix, posMatrix, tileScale, size2, updateTextFitIcon) {
                                     var placedSymbols = bucket.text.placedSymbolArray;
                                     var dynamicTextLayoutVertexArray = bucket.text.dynamicLayoutVertexArray;
                                     var dynamicIconLayoutVertexArray = bucket.icon.dynamicLayoutVertexArray;
                                     var placedTextShifts = {};
                                     dynamicTextLayoutVertexArray.clear();
                                     for (var s2 = 0; s2 < placedSymbols.length; s2++) {
                                         var symbol = placedSymbols.get(s2);
@@ -251805,15 +252654,15 @@
                                         var variableOffset = !symbol.hidden && symbol.crossTileID && !skipOrientation ? variableOffsets[symbol.crossTileID] : null;
                                         if (!variableOffset) {
                                             hideGlyphs(symbol.numGlyphs, dynamicTextLayoutVertexArray);
                                         } else {
                                             var tileAnchor = new performance2.Point(symbol.anchorX, symbol.anchorY);
                                             var projectedAnchor = project(tileAnchor, pitchWithMap ? posMatrix : labelPlaneMatrix);
                                             var perspectiveRatio = getPerspectiveRatio(transform.cameraToCenterDistance, projectedAnchor.signedDistanceFromCamera);
-                                            var renderTextSize = symbolSize.evaluateSizeForFeature(bucket.textSizeData, size, symbol) * perspectiveRatio / performance2.ONE_EM;
+                                            var renderTextSize = symbolSize.evaluateSizeForFeature(bucket.textSizeData, size2, symbol) * perspectiveRatio / performance2.ONE_EM;
                                             if (pitchWithMap) {
                                                 renderTextSize *= bucket.tilePixelRatio / tileScale;
                                             }
                                             var width = variableOffset.width;
                                             var height = variableOffset.height;
                                             var anchor = variableOffset.anchor;
                                             var textOffset = variableOffset.textOffset;
@@ -251890,15 +252739,15 @@
                                             continue;
                                         }
                                         var programConfiguration = buffers.programConfigurations.get(layer.id);
                                         var isSDF = isText || bucket.sdfIcons;
                                         var sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;
                                         var transformed = pitchWithMap || tr2.pitch !== 0;
                                         var program = painter.useProgram(getSymbolProgramName(isSDF, isText, bucket), programConfiguration);
-                                        var size = performance2.evaluateSizeForZoom(sizeData, tr2.zoom);
+                                        var size2 = performance2.evaluateSizeForZoom(sizeData, tr2.zoom);
                                         var texSize = void 0;
                                         var texSizeIcon = [
                                             0,
                                             0
                                         ];
                                         var atlasTexture = void 0;
                                         var atlasInterpolation = void 0;
@@ -251931,20 +252780,20 @@
                                         var matrix = painter.translatePosMatrix(coord.posMatrix, tile, translate, translateAnchor),
                                             uLabelPlaneMatrix = alongLine || isText && variablePlacement || updateTextFitIcon ? identityMat4 : labelPlaneMatrix,
                                             uglCoordMatrix = painter.translatePosMatrix(glCoordMatrix, tile, translate, translateAnchor, true);
                                         var hasHalo = isSDF && layer.paint.get(isText ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                                         var uniformValues = void 0;
                                         if (isSDF) {
                                             if (!bucket.iconsInText) {
-                                                uniformValues = symbolSDFUniformValues(sizeData.kind, size, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, isText, texSize, true);
+                                                uniformValues = symbolSDFUniformValues(sizeData.kind, size2, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, isText, texSize, true);
                                             } else {
-                                                uniformValues = symbolTextAndIconUniformValues(sizeData.kind, size, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, texSize, texSizeIcon);
+                                                uniformValues = symbolTextAndIconUniformValues(sizeData.kind, size2, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, texSize, texSizeIcon);
                                             }
                                         } else {
-                                            uniformValues = symbolIconUniformValues(sizeData.kind, size, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, isText, texSize);
+                                            uniformValues = symbolIconUniformValues(sizeData.kind, size2, rotateInShader, pitchWithMap, painter, matrix, uLabelPlaneMatrix, uglCoordMatrix, isText, texSize);
                                         }
                                         var state = {
                                             program,
                                             buffers,
                                             uniformValues,
                                             atlasTexture,
                                             atlasTextureIcon,
@@ -251973,16 +252822,16 @@
                                         }
                                     }
                                     if (sortFeaturesByKey) {
                                         tileRenderState.sort(function(a2, b2) {
                                             return a2.sortKey - b2.sortKey;
                                         });
                                     }
-                                    for (var i$22 = 0, list$2 = tileRenderState; i$22 < list$2.length; i$22 += 1) {
-                                        var segmentState = list$2[i$22];
+                                    for (var i$22 = 0, list$22 = tileRenderState; i$22 < list$22.length; i$22 += 1) {
+                                        var segmentState = list$22[i$22];
                                         var state$1 = segmentState.state;
                                         context2.activeTexture.set(gl2.TEXTURE0);
                                         state$1.atlasTexture.bind(state$1.atlasInterpolation, gl2.CLAMP_TO_EDGE);
                                         if (state$1.atlasTextureIcon) {
                                             context2.activeTexture.set(gl2.TEXTURE1);
                                             if (state$1.atlasTextureIcon) {
                                                 state$1.atlasTextureIcon.bind(state$1.atlasInterpolationIcon, gl2.CLAMP_TO_EDGE);
@@ -252631,18 +253480,18 @@
                                     drawVerticalLine(painter, padding2.left || 0, lineWidth, leftColor);
                                     drawVerticalLine(painter, painter.transform.width - (padding2.right || 0), lineWidth, rightColor);
                                     var center2 = painter.transform.centerPoint;
                                     drawCrosshair(painter, center2.x, painter.transform.height - center2.y, centerColor);
                                 }
 
                                 function drawCrosshair(painter, x2, y2, color2) {
-                                    var size = 20;
+                                    var size2 = 20;
                                     var lineWidth = 2;
-                                    drawDebugSSRect(painter, x2 - lineWidth / 2, y2 - size / 2, lineWidth, size, color2);
-                                    drawDebugSSRect(painter, x2 - size / 2, y2 - lineWidth / 2, size, lineWidth, color2);
+                                    drawDebugSSRect(painter, x2 - lineWidth / 2, y2 - size2 / 2, lineWidth, size2, color2);
+                                    drawDebugSSRect(painter, x2 - size2 / 2, y2 - lineWidth / 2, size2, lineWidth, color2);
                                 }
 
                                 function drawHorizontalLine(painter, y2, lineWidth, color2) {
                                     drawDebugSSRect(painter, 0, y2 + lineWidth / 2, painter.transform.width, lineWidth, color2);
                                 }
 
                                 function drawVerticalLine(painter, x2, lineWidth, color2) {
@@ -253124,16 +253973,16 @@
                                     var textures = this._tileTextures[texture.size[0]];
                                     if (!textures) {
                                         this._tileTextures[texture.size[0]] = [texture];
                                     } else {
                                         textures.push(texture);
                                     }
                                 };
-                                Painter.prototype.getTileTexture = function getTileTexture(size) {
-                                    var textures = this._tileTextures[size];
+                                Painter.prototype.getTileTexture = function getTileTexture(size2) {
+                                    var textures = this._tileTextures[size2];
                                     return textures && textures.length > 0 ? textures.pop() : null;
                                 };
                                 Painter.prototype.isPatternMissing = function isPatternMissing(image2) {
                                     if (!image2) {
                                         return false;
                                     }
                                     if (!image2.from || !image2.to) {
@@ -253938,50 +254787,50 @@
                                     }
                                     this._constraining = true;
                                     var minY = -90;
                                     var maxY = 90;
                                     var minX = -180;
                                     var maxX = 180;
                                     var sy, sx, x2, y2;
-                                    var size = this.size,
+                                    var size2 = this.size,
                                         unmodified = this._unmodified;
                                     if (this.latRange) {
                                         var latRange = this.latRange;
                                         minY = performance2.mercatorYfromLat(latRange[1]) * this.worldSize;
                                         maxY = performance2.mercatorYfromLat(latRange[0]) * this.worldSize;
-                                        sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
+                                        sy = maxY - minY < size2.y ? size2.y / (maxY - minY) : 0;
                                     }
                                     if (this.lngRange) {
                                         var lngRange = this.lngRange;
                                         minX = performance2.mercatorXfromLng(lngRange[0]) * this.worldSize;
                                         maxX = performance2.mercatorXfromLng(lngRange[1]) * this.worldSize;
-                                        sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
+                                        sx = maxX - minX < size2.x ? size2.x / (maxX - minX) : 0;
                                     }
                                     var point2 = this.point;
                                     var s2 = Math.max(sx || 0, sy || 0);
                                     if (s2) {
                                         this.center = this.unproject(new performance2.Point(sx ? (maxX + minX) / 2 : point2.x, sy ? (maxY + minY) / 2 : point2.y));
                                         this.zoom += this.scaleZoom(s2);
                                         this._unmodified = unmodified;
                                         this._constraining = false;
                                         return;
                                     }
                                     if (this.latRange) {
                                         var y3 = point2.y,
-                                            h2 = size.y / 2;
+                                            h2 = size2.y / 2;
                                         if (y3 - h2 < minY) {
                                             y2 = minY + h2;
                                         }
                                         if (y3 + h2 > maxY) {
                                             y2 = maxY - h2;
                                         }
                                     }
                                     if (this.lngRange) {
                                         var x3 = point2.x,
-                                            w2 = size.x / 2;
+                                            w2 = size2.x / 2;
                                         if (x3 - w2 < minX) {
                                             x2 = minX + w2;
                                         }
                                         if (x3 + w2 > maxX) {
                                             x2 = maxX - w2;
                                         }
                                     }
@@ -256506,17 +257355,17 @@
                                         var edgePadding = tr2.padding;
                                         var p0world = tr2.project(performance2.LngLat.convert(p0));
                                         var p1world = tr2.project(performance2.LngLat.convert(p1));
                                         var p0rotated = p0world.rotate(-bearing * Math.PI / 180);
                                         var p1rotated = p1world.rotate(-bearing * Math.PI / 180);
                                         var upperRight = new performance2.Point(Math.max(p0rotated.x, p1rotated.x), Math.max(p0rotated.y, p1rotated.y));
                                         var lowerLeft = new performance2.Point(Math.min(p0rotated.x, p1rotated.x), Math.min(p0rotated.y, p1rotated.y));
-                                        var size = upperRight.sub(lowerLeft);
-                                        var scaleX = (tr2.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size.x;
-                                        var scaleY = (tr2.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size.y;
+                                        var size2 = upperRight.sub(lowerLeft);
+                                        var scaleX = (tr2.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size2.x;
+                                        var scaleY = (tr2.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size2.y;
                                         if (scaleY < 0 || scaleX < 0) {
                                             performance2.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                                             return;
                                         }
                                         var zoom = Math.min(tr2.scaleZoom(tr2.scale * Math.min(scaleX, scaleY)), options.maxZoom);
                                         var offset2 = typeof options.offset.x === "number" ? new performance2.Point(options.offset.x, options.offset.y) : performance2.Point.convert(options.offset);
                                         var paddingOffsetX = (options.padding.left - options.padding.right) / 2;
@@ -265670,15 +266519,15 @@
 
                         function calcSDF(src, options) {
                             if (!options)
                                 options = {};
                             var cutoff = options.cutoff == null ? 0.25 : options.cutoff;
                             var radius = options.radius == null ? 8 : options.radius;
                             var channel = options.channel || 0;
-                            var w2, h2, size, data2, intData, stride, ctx, canvas, imgData, i2, l2;
+                            var w2, h2, size2, data2, intData, stride, ctx, canvas, imgData, i2, l2;
                             if (ArrayBuffer.isView(src) || Array.isArray(src)) {
                                 if (!options.width || !options.height)
                                     throw Error("For raw data width and height should be provided by options");
                                 w2 = options.width, h2 = options.height;
                                 data2 = src;
                                 if (!options.stride)
                                     stride = Math.floor(src.length / w2 / h2);
@@ -265702,31 +266551,31 @@
                                 } else if (window.ImageData && src instanceof window.ImageData) {
                                     imgData = src;
                                     w2 = src.width, h2 = src.height;
                                     data2 = imgData.data;
                                     stride = 4;
                                 }
                             }
-                            size = Math.max(w2, h2);
+                            size2 = Math.max(w2, h2);
                             if (window.Uint8ClampedArray && data2 instanceof window.Uint8ClampedArray || window.Uint8Array && data2 instanceof window.Uint8Array) {
                                 intData = data2;
                                 data2 = Array(w2 * h2);
                                 for (i2 = 0, l2 = intData.length; i2 < l2; i2++) {
                                     data2[i2] = intData[i2 * stride + channel] / 255;
                                 }
                             } else {
                                 if (stride !== 1)
                                     throw Error("Raw data can have only 1 value per pixel");
                             }
                             var gridOuter = Array(w2 * h2);
                             var gridInner = Array(w2 * h2);
-                            var f2 = Array(size);
-                            var d2 = Array(size);
-                            var z2 = Array(size + 1);
-                            var v2 = Array(size);
+                            var f2 = Array(size2);
+                            var d2 = Array(size2);
+                            var z2 = Array(size2 + 1);
+                            var v2 = Array(size2);
                             for (i2 = 0, l2 = w2 * h2; i2 < l2; i2++) {
                                 var a2 = data2[i2];
                                 gridOuter[i2] = a2 === 1 ? 0 : a2 === 0 ? INF : Math.pow(Math.max(0, 0.5 - a2), 2);
                                 gridInner[i2] = a2 === 1 ? INF : a2 === 0 ? 0 : Math.pow(Math.max(0, a2 - 0.5), 2);
                             }
                             edt(gridOuter, w2, h2, f2, d2, v2, z2);
                             edt(gridInner, w2, h2, f2, d2, v2, z2);
@@ -266114,33 +266963,33 @@
                                     space2 = "rgb";
                                 } else if (cstr === "transparent") {
                                     alpha = 0;
                                     space2 = "rgb";
                                     parts = [0, 0, 0];
                                 } else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
                                     var base2 = cstr.slice(1);
-                                    var size = base2.length;
-                                    var isShort = size <= 4;
+                                    var size2 = base2.length;
+                                    var isShort = size2 <= 4;
                                     alpha = 1;
                                     if (isShort) {
                                         parts = [
                                             parseInt(base2[0] + base2[0], 16),
                                             parseInt(base2[1] + base2[1], 16),
                                             parseInt(base2[2] + base2[2], 16)
                                         ];
-                                        if (size === 4) {
+                                        if (size2 === 4) {
                                             alpha = parseInt(base2[3] + base2[3], 16) / 255;
                                         }
                                     } else {
                                         parts = [
                                             parseInt(base2[0] + base2[1], 16),
                                             parseInt(base2[2] + base2[3], 16),
                                             parseInt(base2[4] + base2[5], 16)
                                         ];
-                                        if (size === 8) {
+                                        if (size2 === 8) {
                                             alpha = parseInt(base2[6] + base2[7], 16) / 255;
                                         }
                                     }
                                     if (!parts[0])
                                         parts[0] = 0;
                                     if (!parts[1])
                                         parts[1] = 0;
@@ -266148,18 +266997,18 @@
                                         parts[2] = 0;
                                     space2 = "rgb";
                                 } else if (m2 = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
                                     var name2 = m2[1];
                                     var isRGB = name2 === "rgb";
                                     var base2 = name2.replace(/a$/, "");
                                     space2 = base2;
-                                    var size = base2 === "cmyk" ? 4 : base2 === "gray" ? 1 : 3;
+                                    var size2 = base2 === "cmyk" ? 4 : base2 === "gray" ? 1 : 3;
                                     parts = m2[2].trim().split(/\s*,\s*/).map(function(x2, i2) {
                                         if (/%$/.test(x2)) {
-                                            if (i2 === size)
+                                            if (i2 === size2)
                                                 return parseFloat(x2) / 100;
                                             if (base2 === "rgb")
                                                 return parseFloat(x2) * 255 / 100;
                                             return parseFloat(x2);
                                         } else if (base2[i2] === "h") {
                                             if (/deg$/.test(x2)) {
                                                 return parseFloat(x2);
@@ -266167,16 +267016,16 @@
                                                 return baseHues[x2];
                                             }
                                         }
                                         return parseFloat(x2);
                                     });
                                     if (name2 === base2)
                                         parts.push(1);
-                                    alpha = isRGB ? 1 : parts[size] === void 0 ? 1 : parts[size];
-                                    parts = parts.slice(0, size);
+                                    alpha = isRGB ? 1 : parts[size2] === void 0 ? 1 : parts[size2];
+                                    parts = parts.slice(0, size2);
                                 } else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
                                     parts = cstr.match(/([0-9]+)/g).map(function(value) {
                                         return parseFloat(value);
                                     });
                                     space2 = cstr.match(/([a-z])/ig).join("").toLowerCase();
                                 }
                             } else if (!isNaN(cstr)) {
@@ -267136,19 +267985,19 @@
                                         entries.push({
                                             key: property.slice(1),
                                             value: this[property]
                                         });
                                 return entries;
                             },
                             size: function() {
-                                var size = 0;
+                                var size2 = 0;
                                 for (var property in this)
                                     if (property[0] === prefix)
-                                        ++size;
-                                return size;
+                                        ++size2;
+                                return size2;
                             },
                             empty: function() {
                                 for (var property in this)
                                     if (property[0] === prefix)
                                         return false;
                                 return true;
                             },
@@ -267611,24 +268460,24 @@
                             return this;
                         }
 
                         function root2() {
                             return this._root;
                         }
 
-                        function size() {
-                            var size2 = 0;
+                        function size2() {
+                            var size3 = 0;
                             this.visit(function(node2) {
                                 if (!node2.length)
                                     do
 
-                                        ++size2;
+                                        ++size3;
                                     while (node2 = node2.next);
                             });
-                            return size2;
+                            return size3;
                         }
 
                         function visit2(callback) {
                             var quads = [],
                                 q2, node2 = this._root,
                                 child, x0, y0, x1, y1;
                             if (node2)
@@ -267757,15 +268606,15 @@
                         treeProto2.cover = cover;
                         treeProto2.data = data2;
                         treeProto2.extent = extent;
                         treeProto2.find = find2;
                         treeProto2.remove = remove2;
                         treeProto2.removeAll = removeAll2;
                         treeProto2.root = root2;
-                        treeProto2.size = size;
+                        treeProto2.size = size2;
                         treeProto2.visit = visit2;
                         treeProto2.visitAfter = visitAfter;
                         treeProto2.x = x2;
                         treeProto2.y = y2;
 
                         function collide_x(d2) {
                             return d2.x + d2.vx;
@@ -271408,27 +272257,27 @@
                         }
 
                         function hufnagel() {
                             var a2 = 1,
                                 b2 = 0,
                                 psiMax = 45 * radians,
                                 ratio = 2,
-                                mutate2 = (0, src_projection.r)(hufnagelRaw),
-                                projection = mutate2(a2, b2, psiMax, ratio);
+                                mutate = (0, src_projection.r)(hufnagelRaw),
+                                projection = mutate(a2, b2, psiMax, ratio);
                             projection.a = function(_2) {
-                                return arguments.length ? mutate2(a2 = +_2, b2, psiMax, ratio) : a2;
+                                return arguments.length ? mutate(a2 = +_2, b2, psiMax, ratio) : a2;
                             };
                             projection.b = function(_2) {
-                                return arguments.length ? mutate2(a2, b2 = +_2, psiMax, ratio) : b2;
+                                return arguments.length ? mutate(a2, b2 = +_2, psiMax, ratio) : b2;
                             };
                             projection.psiMax = function(_2) {
-                                return arguments.length ? mutate2(a2, b2, psiMax = +_2 * radians, ratio) : psiMax * degrees2;
+                                return arguments.length ? mutate(a2, b2, psiMax = +_2 * radians, ratio) : psiMax * degrees2;
                             };
                             projection.ratio = function(_2) {
-                                return arguments.length ? mutate2(a2, b2, psiMax, ratio = +_2) : ratio;
+                                return arguments.length ? mutate(a2, b2, psiMax, ratio = +_2) : ratio;
                             };
                             return projection.scale(180.739);
                         }
 
                         function adsimp(f2, a2, b2, fa, fm, fb, V0, tol, maxdepth, depth, state) {
                             if (state.nanEncountered) {
                                 return NaN;
@@ -274028,27 +274877,27 @@
                         }
 
                         function wagner() {
                             var poleline = 65 * radians,
                                 parallels = 60 * radians,
                                 inflation = 20,
                                 ratio = 200,
-                                mutate2 = (0, src_projection.r)(wagnerRaw),
-                                projection = mutate2(poleline, parallels, inflation, ratio);
+                                mutate = (0, src_projection.r)(wagnerRaw),
+                                projection = mutate(poleline, parallels, inflation, ratio);
                             projection.poleline = function(_2) {
-                                return arguments.length ? mutate2(poleline = +_2 * radians, parallels, inflation, ratio) : poleline * degrees2;
+                                return arguments.length ? mutate(poleline = +_2 * radians, parallels, inflation, ratio) : poleline * degrees2;
                             };
                             projection.parallels = function(_2) {
-                                return arguments.length ? mutate2(poleline, parallels = +_2 * radians, inflation, ratio) : parallels * degrees2;
+                                return arguments.length ? mutate(poleline, parallels = +_2 * radians, inflation, ratio) : parallels * degrees2;
                             };
                             projection.inflation = function(_2) {
-                                return arguments.length ? mutate2(poleline, parallels, inflation = +_2, ratio) : inflation;
+                                return arguments.length ? mutate(poleline, parallels, inflation = +_2, ratio) : inflation;
                             };
                             projection.ratio = function(_2) {
-                                return arguments.length ? mutate2(poleline, parallels, inflation, ratio = +_2) : ratio;
+                                return arguments.length ? mutate(poleline, parallels, inflation, ratio = +_2) : ratio;
                             };
                             return projection.scale(163.775);
                         }
 
                         function wagner7() {
                             return wagner().poleline(65).parallels(60).inflation(0).ratio(200).scale(172.633);
                         }
@@ -274730,52 +275579,52 @@
                             [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.ou]
                         );
 
                         function clipAntimeridianLine(stream) {
                             var lambda0 = NaN,
                                 phi0 = NaN,
                                 sign0 = NaN,
-                                clean2;
+                                clean;
                             return {
                                 lineStart: function() {
                                     stream.lineStart();
-                                    clean2 = 1;
+                                    clean = 1;
                                 },
                                 point: function(lambda1, phi1) {
                                     var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
                                         delta = (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.Wn)(lambda1 - lambda0);
                                     if ((0, _math_js__WEBPACK_IMPORTED_MODULE_1__.Wn)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.Ho) {
                                         stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.ou : -_math_js__WEBPACK_IMPORTED_MODULE_1__.ou);
                                         stream.point(sign0, phi0);
                                         stream.lineEnd();
                                         stream.lineStart();
                                         stream.point(sign1, phi0);
                                         stream.point(lambda1, phi0);
-                                        clean2 = 0;
+                                        clean = 0;
                                     } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) {
                                         if ((0, _math_js__WEBPACK_IMPORTED_MODULE_1__.Wn)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.Ho)
                                             lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.Ho;
                                         if ((0, _math_js__WEBPACK_IMPORTED_MODULE_1__.Wn)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.Ho)
                                             lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.Ho;
                                         phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
                                         stream.point(sign0, phi0);
                                         stream.lineEnd();
                                         stream.lineStart();
                                         stream.point(sign1, phi0);
-                                        clean2 = 0;
+                                        clean = 0;
                                     }
                                     stream.point(lambda0 = lambda1, phi0 = phi1);
                                     sign0 = sign1;
                                 },
                                 lineEnd: function() {
                                     stream.lineEnd();
                                     lambda0 = phi0 = NaN;
                                 },
                                 clean: function() {
-                                    return 2 - clean2;
+                                    return 2 - clean;
                                 }
                             };
                         }
 
                         function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
                             var cosPhi0, cosPhi1, sinLambda0Lambda1 = (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.O$)(lambda0 - lambda1);
                             return (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.Wn)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.Ho ? (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.z4)(((0, _math_js__WEBPACK_IMPORTED_MODULE_1__.O$)(phi0) * (cosPhi1 = (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.mC)(phi1)) * (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.O$)(lambda1) - (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.O$)(phi1) * (cosPhi0 = (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.mC)(phi0)) * (0, _math_js__WEBPACK_IMPORTED_MODULE_1__.O$)(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
@@ -274860,47 +275709,47 @@
                             }
 
                             function visible(lambda, phi2) {
                                 return (0, _math_js__WEBPACK_IMPORTED_MODULE_0__.mC)(lambda) * (0, _math_js__WEBPACK_IMPORTED_MODULE_0__.mC)(phi2) > cr2;
                             }
 
                             function clipLine(stream) {
-                                var point0, c0, v0, v00, clean2;
+                                var point0, c0, v0, v00, clean;
                                 return {
                                     lineStart: function() {
                                         v00 = v0 = false;
-                                        clean2 = 1;
+                                        clean = 1;
                                     },
                                     point: function(lambda, phi2) {
                                         var point1 = [lambda, phi2],
                                             point2, v2 = visible(lambda, phi2),
                                             c2 = smallRadius ? v2 ? 0 : code2(lambda, phi2) : v2 ? code2(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi2) : 0;
                                         if (!point0 && (v00 = v0 = v2))
                                             stream.lineStart();
                                         if (v2 !== v0) {
                                             point2 = intersect(point0, point1);
                                             if (!point2 || (0, _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.Z)(point0, point2) || (0, _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.Z)(point1, point2))
                                                 point1[2] = 1;
                                         }
                                         if (v2 !== v0) {
-                                            clean2 = 0;
+                                            clean = 0;
                                             if (v2) {
                                                 stream.lineStart();
                                                 point2 = intersect(point1, point0);
                                                 stream.point(point2[0], point2[1]);
                                             } else {
                                                 point2 = intersect(point0, point1);
                                                 stream.point(point2[0], point2[1], 2);
                                                 stream.lineEnd();
                                             }
                                             point0 = point2;
                                         } else if (notHemisphere && point0 && smallRadius ^ v2) {
                                             var t2;
                                             if (!(c2 & c0) && (t2 = intersect(point1, point0, true))) {
-                                                clean2 = 0;
+                                                clean = 0;
                                                 if (smallRadius) {
                                                     stream.lineStart();
                                                     stream.point(t2[0][0], t2[0][1]);
                                                     stream.point(t2[1][0], t2[1][1]);
                                                     stream.lineEnd();
                                                 } else {
                                                     stream.point(t2[1][0], t2[1][1]);
@@ -274917,15 +275766,15 @@
                                     },
                                     lineEnd: function() {
                                         if (v0)
                                             stream.lineEnd();
                                         point0 = null;
                                     },
                                     clean: function() {
-                                        return clean2 | (v00 && v0) << 1;
+                                        return clean | (v00 && v0) << 1;
                                     }
                                 };
                             }
 
                             function intersect(a2, b2, two) {
                                 var pa = (0, _cartesian_js__WEBPACK_IMPORTED_MODULE_3__.Og)(a2),
                                     pb = (0, _cartesian_js__WEBPACK_IMPORTED_MODULE_3__.Og)(b2);
@@ -275077,36 +275926,36 @@
                                     ringSink.lineStart();
                                     ring = [];
                                 }
 
                                 function ringEnd() {
                                     pointRing(ring[0][0], ring[0][1]);
                                     ringSink.lineEnd();
-                                    var clean2 = ringSink.clean(),
+                                    var clean = ringSink.clean(),
                                         ringSegments = ringBuffer.result(),
                                         i2, n2 = ringSegments.length,
                                         m2, segment, point3;
                                     ring.pop();
                                     polygon2.push(ring);
                                     ring = null;
                                     if (!n2)
                                         return;
-                                    if (clean2 & 1) {
+                                    if (clean & 1) {
                                         segment = ringSegments[0];
                                         if ((m2 = segment.length - 1) > 0) {
                                             if (!polygonStarted)
                                                 sink.polygonStart(), polygonStarted = true;
                                             sink.lineStart();
                                             for (i2 = 0; i2 < m2; ++i2)
                                                 sink.point((point3 = segment[i2])[0], point3[1]);
                                             sink.lineEnd();
                                         }
                                         return;
                                     }
-                                    if (n2 > 1 && clean2 & 2)
+                                    if (n2 > 1 && clean & 2)
                                         ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                                     segments.push(ringSegments.filter(validSegment));
                                 }
                                 return clip2;
                             };
                         }
 
@@ -275121,15 +275970,15 @@
                     87605: function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                         __webpack_require__2.d(__webpack_exports__2, {
                             Z: function() {
                                 return clipRectangle;
                             }
                         });
                         var math = __webpack_require__2(39695);
-                        var buffer2 = __webpack_require__2(85272);
+                        var buffer = __webpack_require__2(85272);
 
                         function line(a2, b2, x0, y0, x1, y1) {
                             var ax = a2[0],
                                 ay = a2[1],
                                 bx = b2[0],
                                 by = b2[1],
                                 t0 = 0,
@@ -275236,16 +276085,16 @@
                             function comparePoint(a2, b2) {
                                 var ca = corner(a2, 1),
                                     cb = corner(b2, 1);
                                 return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
                             }
                             return function(stream) {
                                 var activeStream = stream,
-                                    bufferStream = (0, buffer2.Z)(),
-                                    segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean2;
+                                    bufferStream = (0, buffer.Z)(),
+                                    segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean;
                                 var clipStream = {
                                     point: point2,
                                     lineStart,
                                     lineEnd,
                                     polygonStart,
                                     polygonEnd
                                 };
@@ -275269,20 +276118,20 @@
                                             }
                                         }
                                     }
                                     return winding;
                                 }
 
                                 function polygonStart() {
-                                    activeStream = bufferStream, segments = [], polygon2 = [], clean2 = true;
+                                    activeStream = bufferStream, segments = [], polygon2 = [], clean = true;
                                 }
 
                                 function polygonEnd() {
                                     var startInside = polygonInside(),
-                                        cleanInside = clean2 && startInside,
+                                        cleanInside = clean && startInside,
                                         visible2 = (segments = (0, src.TS)(segments)).length;
                                     if (cleanInside || visible2) {
                                         stream.polygonStart();
                                         if (cleanInside) {
                                             stream.lineStart();
                                             interpolate2(null, null, 1, stream);
                                             stream.lineEnd();
@@ -275337,19 +276186,19 @@
                                                 if (!v_) {
                                                     activeStream.lineStart();
                                                     activeStream.point(a2[0], a2[1]);
                                                 }
                                                 activeStream.point(b2[0], b2[1]);
                                                 if (!v2)
                                                     activeStream.lineEnd();
-                                                clean2 = false;
+                                                clean = false;
                                             } else if (v2) {
                                                 activeStream.lineStart();
                                                 activeStream.point(x2, y2);
-                                                clean2 = false;
+                                                clean = false;
                                             }
                                         }
                                     }
                                     x_ = x2, y_ = y2, v_ = v2;
                                 }
                                 return clipStream;
                             };
@@ -276427,16 +277276,16 @@
                                     [x2 - 0.115 * k2 - math.Ho, y2 + 0.234 * k2 - math.Ho]
                                 ]).stream(pointStream);
                                 return reset2();
                             };
                             albersUsa2.fitExtent = function(extent2, object3) {
                                 return (0, fit.qg)(albersUsa2, extent2, object3);
                             };
-                            albersUsa2.fitSize = function(size, object3) {
-                                return (0, fit.mF)(albersUsa2, size, object3);
+                            albersUsa2.fitSize = function(size2, object3) {
+                                return (0, fit.mF)(albersUsa2, size2, object3);
                             };
                             albersUsa2.fitWidth = function(width, object3) {
                                 return (0, fit.V6)(albersUsa2, width, object3);
                             };
                             albersUsa2.fitHeight = function(height, object3) {
                                 return (0, fit.rf)(albersUsa2, height, object3);
                             };
@@ -276677,16 +277526,16 @@
                             };
                             projection2.reflectY = function(_2) {
                                 return arguments.length ? (sy = _2 ? -1 : 1, reset2()) : sy < 0;
                             };
                             projection2.fitExtent = function(extent2, object3) {
                                 return (0, fit.qg)(projection2, extent2, object3);
                             };
-                            projection2.fitSize = function(size, object3) {
-                                return (0, fit.mF)(projection2, size, object3);
+                            projection2.fitSize = function(size2, object3) {
+                                return (0, fit.mF)(projection2, size2, object3);
                             };
                             projection2.fitWidth = function(width, object3) {
                                 return (0, fit.V6)(projection2, width, object3);
                             };
                             projection2.fitHeight = function(height, object3) {
                                 return (0, fit.rf)(projection2, height, object3);
                             };
@@ -277136,17 +277985,17 @@
                                     k2 = Math.min(w2 / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])),
                                     x2 = +extent[0][0] + (w2 - k2 * (b2[1][0] + b2[0][0])) / 2,
                                     y2 = +extent[0][1] + (h2 - k2 * (b2[1][1] + b2[0][1])) / 2;
                                 projection.scale(150 * k2).translate([x2, y2]);
                             }, object2);
                         }
 
-                        function fitSize(projection, size, object2) {
+                        function fitSize(projection, size2, object2) {
                             return fitExtent(projection, [
-                                [0, 0], size
+                                [0, 0], size2
                             ], object2);
                         }
 
                         function fitWidth(projection, width, object2) {
                             return fit(projection, function(b2) {
                                 var w2 = +width,
                                     k2 = w2 / (b2[1][0] - b2[0][0]),
@@ -277430,16 +278279,16 @@
                             };
                             projection2.precision = function(_2) {
                                 return arguments.length ? (projectResample = resample(projectTransform, delta2 = _2 * _2), reset2()) : (0, math._b)(delta2);
                             };
                             projection2.fitExtent = function(extent, object2) {
                                 return (0, fit.qg)(projection2, extent, object2);
                             };
-                            projection2.fitSize = function(size, object2) {
-                                return (0, fit.mF)(projection2, size, object2);
+                            projection2.fitSize = function(size2, object2) {
+                                return (0, fit.mF)(projection2, size2, object2);
                             };
                             projection2.fitWidth = function(width, object2) {
                                 return (0, fit.V6)(projection2, width, object2);
                             };
                             projection2.fitHeight = function(height, object2) {
                                 return (0, fit.rf)(projection2, height, object2);
                             };
@@ -279104,22 +279953,22 @@
                             var source = linkSource,
                                 target = linkTarget,
                                 x2 = point_x,
                                 y2 = point_y,
                                 context2 = null;
 
                             function link2() {
-                                var buffer2, argv = slice.call(arguments),
+                                var buffer, argv = slice.call(arguments),
                                     s2 = source.apply(this, argv),
                                     t2 = target.apply(this, argv);
                                 if (!context2)
-                                    context2 = buffer2 = src_path();
+                                    context2 = buffer = src_path();
                                 curve(context2, +x2.apply(this, (argv[0] = s2, argv)), +y2.apply(this, argv), +x2.apply(this, (argv[0] = t2, argv)), +y2.apply(this, argv));
-                                if (buffer2)
-                                    return context2 = null, buffer2 + "" || null;
+                                if (buffer)
+                                    return context2 = null, buffer + "" || null;
                             }
                             link2.source = function(_2) {
                                 return arguments.length ? (source = _2, link2) : source;
                             };
                             link2.target = function(_2) {
                                 return arguments.length ? (target = _2, link2) : target;
                             };
@@ -281892,21 +282741,21 @@
                         var objToString = Object.prototype.toString,
                             id2 = objToString.call("");
                         module3.exports = function(value) {
                             return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id2) || false;
                         };
                     },
                     43043: function(module3) {
-                        var generated2 = /* @__PURE__ */ Object.create(null),
+                        var generated = /* @__PURE__ */ Object.create(null),
                             random2 = Math.random;
                         module3.exports = function() {
                             var str;
                             do {
                                 str = random2().toString(36).slice(2);
-                            } while (generated2[str]);
+                            } while (generated[str]);
                             return str;
                         };
                     },
                     32411: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var setPrototypeOf = __webpack_require__2(1496),
                             contains2 = __webpack_require__2(66741),
                             d2 = __webpack_require__2(62072),
@@ -285572,43 +286421,43 @@
                     },
                     35065: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var bind2 = __webpack_require__2(77575);
                         module3.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
                     },
                     95280: function(__unused_webpack_module, exports4) {
                         /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
-                        exports4.read = function(buffer2, offset2, isLE, mLen, nBytes) {
+                        exports4.read = function(buffer, offset2, isLE, mLen, nBytes) {
                             var e3, m2;
                             var eLen = nBytes * 8 - mLen - 1;
                             var eMax = (1 << eLen) - 1;
                             var eBias = eMax >> 1;
                             var nBits = -7;
                             var i2 = isLE ? nBytes - 1 : 0;
                             var d2 = isLE ? -1 : 1;
-                            var s2 = buffer2[offset2 + i2];
+                            var s2 = buffer[offset2 + i2];
                             i2 += d2;
                             e3 = s2 & (1 << -nBits) - 1;
                             s2 >>= -nBits;
                             nBits += eLen;
-                            for (; nBits > 0; e3 = e3 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {}
+                            for (; nBits > 0; e3 = e3 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {}
                             m2 = e3 & (1 << -nBits) - 1;
                             e3 >>= -nBits;
                             nBits += mLen;
-                            for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {}
+                            for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {}
                             if (e3 === 0) {
                                 e3 = 1 - eBias;
                             } else if (e3 === eMax) {
                                 return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
                             } else {
                                 m2 = m2 + Math.pow(2, mLen);
                                 e3 = e3 - eBias;
                             }
                             return (s2 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
                         };
-                        exports4.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
+                        exports4.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
                             var e3, m2, c2;
                             var eLen = nBytes * 8 - mLen - 1;
                             var eMax = (1 << eLen) - 1;
                             var eBias = eMax >> 1;
                             var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                             var i2 = isLE ? 0 : nBytes - 1;
                             var d2 = isLE ? 1 : -1;
@@ -285639,19 +286488,19 @@
                                     m2 = (value * c2 - 1) * Math.pow(2, mLen);
                                     e3 = e3 + eBias;
                                 } else {
                                     m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                                     e3 = 0;
                                 }
                             }
-                            for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {}
+                            for (; mLen >= 8; buffer[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {}
                             e3 = e3 << mLen | m2;
                             eLen += mLen;
-                            for (; eLen > 0; buffer2[offset2 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {}
-                            buffer2[offset2 + i2 - d2] |= s2 * 128;
+                            for (; eLen > 0; buffer[offset2 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {}
+                            buffer[offset2 + i2 - d2] |= s2 * 128;
                         };
                     },
                     42018: function(module3) {
                         if (typeof Object.create === "function") {
                             module3.exports = function inherits2(ctor, superCtor) {
                                 if (superCtor) {
                                     ctor.super_ = superCtor;
@@ -288942,21 +289791,21 @@
                     76767: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var readUInt16BE = __webpack_require__2(14847).n8;
                         var readUInt32BE = __webpack_require__2(14847).Ag;
 
                         function unbox(data2, offset2) {
                             if (data2.length < 4 + offset2)
                                 return null;
-                            var size = readUInt32BE(data2, offset2);
-                            if (data2.length < size + offset2 || size < 8)
+                            var size2 = readUInt32BE(data2, offset2);
+                            if (data2.length < size2 + offset2 || size2 < 8)
                                 return null;
                             return {
                                 boxtype: String.fromCharCode.apply(null, data2.slice(offset2 + 4, offset2 + 8)),
-                                data: data2.slice(offset2 + 8, offset2 + size),
-                                end: offset2 + size
+                                data: data2.slice(offset2 + 8, offset2 + size2),
+                                end: offset2 + size2
                             };
                         }
                         module3.exports.unbox = unbox;
 
                         function scan_ipco(data2, sandbox) {
                             var offset2 = 0;
                             for (;;) {
@@ -288983,17 +289832,17 @@
                                         });
                                         break;
                                 }
                                 offset2 = box.end;
                             }
                         }
 
-                        function readUIntBE(data2, offset2, size) {
+                        function readUIntBE(data2, offset2, size2) {
                             var result = 0;
-                            for (var i2 = 0; i2 < size; i2++) {
+                            for (var i2 = 0; i2 < size2; i2++) {
                                 result = result * 256 + (data2[offset2 + i2] || 0);
                             }
                             return result;
                         }
 
                         function scan_iloc(data2, sandbox) {
                             var offset_size = data2[4] >> 4 & 15;
@@ -289313,21 +290162,21 @@
                             var maxSize = {
                                 width: 0,
                                 height: 0
                             };
                             for (var i2 = 0; i2 < numImages; i2++) {
                                 var width = data2[6 + INDEX_SIZE * i2] || 256;
                                 var height = data2[6 + INDEX_SIZE * i2 + 1] || 256;
-                                var size = {
+                                var size2 = {
                                     width,
                                     height
                                 };
-                                variants.push(size);
+                                variants.push(size2);
                                 if (width > maxSize.width || height > maxSize.height) {
-                                    maxSize = size;
+                                    maxSize = size2;
                                 }
                             }
                             return {
                                 width: maxSize.width,
                                 height: maxSize.height,
                                 variants,
                                 type: "ico",
@@ -289560,20 +290409,20 @@
                         var readUInt16LE = __webpack_require__2(14847).mP;
                         var readUInt16BE = __webpack_require__2(14847).n8;
                         var readUInt32LE = __webpack_require__2(14847).nm;
                         var readUInt32BE = __webpack_require__2(14847).Ag;
                         var SIG_1 = str2arr("II*\0");
                         var SIG_2 = str2arr("MM\0*");
 
-                        function readUInt16(buffer2, offset2, is_big_endian) {
-                            return is_big_endian ? readUInt16BE(buffer2, offset2) : readUInt16LE(buffer2, offset2);
+                        function readUInt16(buffer, offset2, is_big_endian) {
+                            return is_big_endian ? readUInt16BE(buffer, offset2) : readUInt16LE(buffer, offset2);
                         }
 
-                        function readUInt32(buffer2, offset2, is_big_endian) {
-                            return is_big_endian ? readUInt32BE(buffer2, offset2) : readUInt32LE(buffer2, offset2);
+                        function readUInt32(buffer, offset2, is_big_endian) {
+                            return is_big_endian ? readUInt32BE(buffer, offset2) : readUInt32LE(buffer, offset2);
                         }
 
                         function readIFDValue(data2, data_offset, is_big_endian) {
                             var type2 = readUInt16(data2, data_offset + 2, is_big_endian);
                             var values = readUInt32(data2, data_offset + 4, is_big_endian);
                             if (values !== 1 || type2 !== 3 && type2 !== 4)
                                 return null;
@@ -289719,18 +290568,18 @@
                             tiff: __webpack_require__2(66278),
                             webp: __webpack_require__2(90784)
                         };
                     },
                     33575: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         var parsers2 = __webpack_require__2(91497);
 
-                        function probeBuffer(buffer2) {
+                        function probeBuffer(buffer) {
                             var parser_names = Object.keys(parsers2);
                             for (var i2 = 0; i2 < parser_names.length; i2++) {
-                                var result = parsers2[parser_names[i2]](buffer2);
+                                var result = parsers2[parser_names[i2]](buffer);
                                 if (result)
                                     return result;
                             }
                             return null;
                         }
                         module3.exports = function get_image_size(src) {
                             return probeBuffer(src);
@@ -289942,17 +290791,17 @@
                                 queue.push({
                                     handle: ++id2,
                                     callback,
                                     cancelled: false
                                 });
                                 return id2;
                             };
-                            caf = function(handle) {
+                            caf = function(handle2) {
                                 for (var i3 = 0; i3 < queue.length; i3++) {
-                                    if (queue[i3].handle === handle) {
+                                    if (queue[i3].handle === handle2) {
                                         queue[i3].cancelled = true;
                                     }
                                 }
                             };
                         }
                         module3.exports = function(fn2) {
                             return raf2.call(root2, fn2);
@@ -291285,15 +292134,15 @@
                                             constant: [0, 0]
                                         } : {
                                             buffer: prop.positionFractBuffer,
                                             stride: 8,
                                             offset: 4
                                         };
                                     },
-                                    size: function size(ctx, prop) {
+                                    size: function size2(ctx, prop) {
                                         return prop.size.length ? {
                                             buffer: prop.sizeBuffer,
                                             stride: 2,
                                             offset: 0
                                         } : {
                                             constant: [Math.round(prop.size * 255 / _this.maxSize)]
                                         };
@@ -291584,15 +292433,15 @@
                                     options.positions = group.positions;
                                     delete group.positions;
                                 }
                                 var hasSize = 0,
                                     hasColor = 0;
                                 updateDiff(group, options, [{
                                     snap: true,
-                                    size: function size2(s2, group2) {
+                                    size: function size3(s2, group2) {
                                         if (s2 == null)
                                             s2 = Scatter.defaults.size;
                                         hasSize += s2 && s2.length ? 1 : 0;
                                         return s2;
                                     },
                                     borderSize: function borderSize2(s2, group2) {
                                         if (s2 == null)
@@ -291705,16 +292554,16 @@
                                             usage: "stream"
                                         });
                                         return _positions;
                                     }
                                 }, {
                                     marker: function marker(markers, group2, options2) {
                                         var activation = group2.activation;
-                                        activation.forEach(function(buffer2) {
-                                            return buffer2 && buffer2.destroy && buffer2.destroy();
+                                        activation.forEach(function(buffer) {
+                                            return buffer && buffer.destroy && buffer.destroy();
                                         });
                                         activation.length = 0;
                                         if (!markers || typeof markers[0] === "number") {
                                             var id2 = _this3.addMarker(markers);
                                             activation[id2] = true;
                                         } else {
                                             var markerMasks = [];
@@ -291758,21 +292607,21 @@
                                         var rect = parseRect(vp || [gl2.drawingBufferWidth, gl2.drawingBufferHeight]);
                                         return rect;
                                     }
                                 }]);
                                 if (hasSize) {
                                     var _group = group,
                                         count2 = _group.count,
-                                        size = _group.size,
+                                        size2 = _group.size,
                                         borderSize = _group.borderSize,
                                         sizeBuffer = _group.sizeBuffer;
                                     var sizes = new Uint8Array(count2 * 2);
-                                    if (size.length || borderSize.length) {
+                                    if (size2.length || borderSize.length) {
                                         for (var _i2 = 0; _i2 < count2; _i2++) {
-                                            sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);
+                                            sizes[_i2 * 2] = Math.round((size2[_i2] == null ? size2 : size2[_i2]) * 255 / maxSize);
                                             sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);
                                         }
                                     }
                                     sizeBuffer({
                                         data: sizes,
                                         usage: "dynamic"
                                     });
@@ -297431,67 +298280,67 @@
                                 a2.onDone(null, l2);
                                 return l2;
                             };
                         });
                     },
                     71665: function(module3, exports4, __webpack_require__2) {
                         /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
-                        var buffer2 = __webpack_require__2(12856);
-                        var Buffer2 = buffer2.Buffer;
+                        var buffer = __webpack_require__2(12856);
+                        var Buffer2 = buffer.Buffer;
 
                         function copyProps(src, dst) {
                             for (var key in src) {
                                 dst[key] = src[key];
                             }
                         }
                         if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
-                            module3.exports = buffer2;
+                            module3.exports = buffer;
                         } else {
-                            copyProps(buffer2, exports4);
+                            copyProps(buffer, exports4);
                             exports4.Buffer = SafeBuffer;
                         }
 
                         function SafeBuffer(arg, encodingOrOffset, length) {
                             return Buffer2(arg, encodingOrOffset, length);
                         }
                         SafeBuffer.prototype = Object.create(Buffer2.prototype);
                         copyProps(Buffer2, SafeBuffer);
                         SafeBuffer.from = function(arg, encodingOrOffset, length) {
                             if (typeof arg === "number") {
                                 throw new TypeError("Argument must not be a number");
                             }
                             return Buffer2(arg, encodingOrOffset, length);
                         };
-                        SafeBuffer.alloc = function(size, fill, encoding) {
-                            if (typeof size !== "number") {
+                        SafeBuffer.alloc = function(size2, fill, encoding) {
+                            if (typeof size2 !== "number") {
                                 throw new TypeError("Argument must be a number");
                             }
-                            var buf = Buffer2(size);
+                            var buf = Buffer2(size2);
                             if (fill !== void 0) {
                                 if (typeof encoding === "string") {
                                     buf.fill(fill, encoding);
                                 } else {
                                     buf.fill(fill);
                                 }
                             } else {
                                 buf.fill(0);
                             }
                             return buf;
                         };
-                        SafeBuffer.allocUnsafe = function(size) {
-                            if (typeof size !== "number") {
+                        SafeBuffer.allocUnsafe = function(size2) {
+                            if (typeof size2 !== "number") {
                                 throw new TypeError("Argument must be a number");
                             }
-                            return Buffer2(size);
+                            return Buffer2(size2);
                         };
-                        SafeBuffer.allocUnsafeSlow = function(size) {
-                            if (typeof size !== "number") {
+                        SafeBuffer.allocUnsafeSlow = function(size2) {
+                            if (typeof size2 !== "number") {
                                 throw new TypeError("Argument must be a number");
                             }
-                            return buffer2.SlowBuffer(size);
+                            return buffer.SlowBuffer(size2);
                         };
                     },
                     21630: function(module3, __unused_webpack_exports, __webpack_require__2) {
                         module3.exports = Stream;
                         var EE = __webpack_require__2(15398).EventEmitter;
                         var inherits2 = __webpack_require__2(42018);
                         inherits2(Stream, EE);
@@ -299032,28 +299881,28 @@
                         }
 
                         function clearBuffer(stream, state) {
                             state.bufferProcessing = true;
                             var entry = state.bufferedRequest;
                             if (stream._writev && entry && entry.next) {
                                 var l2 = state.bufferedRequestCount;
-                                var buffer2 = new Array(l2);
+                                var buffer = new Array(l2);
                                 var holder = state.corkedRequestsFree;
                                 holder.entry = entry;
                                 var count2 = 0;
                                 var allBuffers = true;
                                 while (entry) {
-                                    buffer2[count2] = entry;
+                                    buffer[count2] = entry;
                                     if (!entry.isBuf)
                                         allBuffers = false;
                                     entry = entry.next;
                                     count2 += 1;
                                 }
-                                buffer2.allBuffers = allBuffers;
-                                doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
+                                buffer.allBuffers = allBuffers;
+                                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                                 state.pendingcb++;
                                 state.lastBufferedRequest = null;
                                 if (holder.next) {
                                     state.corkedRequestsFree = holder.next;
                                     holder.next = null;
                                 } else {
                                     state.corkedRequestsFree = new CorkedRequest(state);
@@ -301198,15 +302047,15 @@
                             if (options.shape) {
                                 w2 = options.shape[0];
                                 h2 = options.shape[1];
                             } else {
                                 w2 = canvas.width = options.w || options.width || 200;
                                 h2 = canvas.height = options.h || options.height || 200;
                             }
-                            var size = Math.min(w2, h2);
+                            var size2 = Math.min(w2, h2);
                             var stroke = options.stroke || 0;
                             var viewbox = options.viewbox || options.viewBox || pathBounds(path2);
                             var scale = [w2 / (viewbox[2] - viewbox[0]), h2 / (viewbox[3] - viewbox[1])];
                             var maxScale = Math.min(scale[0] || 0, scale[1] || 0) / 2;
                             ctx.fillStyle = "black";
                             ctx.fillRect(0, 0, w2, h2);
                             ctx.fillStyle = "white";
@@ -301231,15 +302080,15 @@
                                 drawPath2(ctx, segments);
                                 ctx.fill();
                                 stroke && ctx.stroke();
                             }
                             ctx.setTransform(1, 0, 0, 1, 0, 0);
                             var data2 = bitmapSdf(ctx, {
                                 cutoff: options.cutoff != null ? options.cutoff : 0.5,
-                                radius: options.radius != null ? options.radius : size * 0.5
+                                radius: options.radius != null ? options.radius : size2 * 0.5
                             });
                             return data2;
                         }
                         var path2DSupported;
 
                         function isPath2DSupported() {
                             if (path2DSupported != null)
@@ -301946,29 +302795,29 @@
                                 }
                                 return out;
                             };
                             tinycolor.mostReadable = function(baseColor, colorList, args) {
                                 var bestColor = null;
                                 var bestScore = 0;
                                 var readability;
-                                var includeFallbackColors, level, size;
+                                var includeFallbackColors, level, size2;
                                 args = args || {};
                                 includeFallbackColors = args.includeFallbackColors;
                                 level = args.level;
-                                size = args.size;
+                                size2 = args.size;
                                 for (var i2 = 0; i2 < colorList.length; i2++) {
                                     readability = tinycolor.readability(baseColor, colorList[i2]);
                                     if (readability > bestScore) {
                                         bestScore = readability;
                                         bestColor = tinycolor(colorList[i2]);
                                     }
                                 }
                                 if (tinycolor.isReadable(baseColor, bestColor, {
                                         "level": level,
-                                        "size": size
+                                        "size": size2
                                     }) || !includeFallbackColors) {
                                     return bestColor;
                                 } else {
                                     args.includeFallbackColors = false;
                                     return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
                                 }
                             };
@@ -302312,30 +303161,30 @@
                                         format: named2 ? "name" : "hex"
                                     };
                                 }
                                 return false;
                             }
 
                             function validateWCAG2Parms(parms) {
-                                var level, size;
+                                var level, size2;
                                 parms = parms || {
                                     "level": "AA",
                                     "size": "small"
                                 };
                                 level = (parms.level || "AA").toUpperCase();
-                                size = (parms.size || "small").toLowerCase();
+                                size2 = (parms.size || "small").toLowerCase();
                                 if (level !== "AA" && level !== "AAA") {
                                     level = "AA";
                                 }
-                                if (size !== "small" && size !== "large") {
-                                    size = "small";
+                                if (size2 !== "small" && size2 !== "large") {
+                                    size2 = "small";
                                 }
                                 return {
                                     "level": level,
-                                    "size": size
+                                    "size": size2
                                 };
                             }
                             if (module3.exports) {
                                 module3.exports = tinycolor;
                             } else {
                                 !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                                     return tinycolor;
@@ -302383,17 +303232,17 @@
                             return parts[0] * toPX(parts[1], element2);
                         }
 
                         function getSizeBrutal(unit, element2) {
                             var testDIV = document.createElement("div");
                             testDIV.style["font-size"] = "128" + unit;
                             element2.appendChild(testDIV);
-                            var size = getPropertyInPX(testDIV, "font-size") / 128;
+                            var size2 = getPropertyInPX(testDIV, "font-size") / 128;
                             element2.removeChild(testDIV);
-                            return size;
+                            return size2;
                         }
 
                         function toPX(str, element2) {
                             element2 = element2 || document.body;
                             str = (str || "px").trim().toLowerCase();
                             if (element2 === window || element2 === document) {
                                 element2 = document.body;
@@ -302795,21 +303644,21 @@
                                 }
                                 var n2 = array2.length || array2.byteLength;
                                 var log_n = bits.log2(n2) | 0;
                                 DATA[log_n].push(array2);
                             }
                         };
 
-                        function freeArrayBuffer(buffer2) {
-                            if (!buffer2) {
+                        function freeArrayBuffer(buffer) {
+                            if (!buffer) {
                                 return;
                             }
-                            var n2 = buffer2.length || buffer2.byteLength;
+                            var n2 = buffer.length || buffer.byteLength;
                             var log_n = bits.log2(n2);
-                            DATA[log_n].push(buffer2);
+                            DATA[log_n].push(buffer);
                         }
 
                         function freeTypedArray(array2) {
                             freeArrayBuffer(array2.buffer);
                         }
                         exports4.freeUint8 = exports4.freeUint16 = exports4.freeUint32 = exports4.freeBigUint64 = exports4.freeInt8 = exports4.freeInt16 = exports4.freeInt32 = exports4.freeBigInt64 = exports4.freeFloat32 = exports4.freeFloat = exports4.freeFloat64 = exports4.freeDouble = exports4.freeUint8Clamped = exports4.freeDataView = freeTypedArray;
                         exports4.freeArrayBuffer = freeArrayBuffer;
@@ -303015,28 +303864,28 @@
 
                         function deprecate(fn2, msg) {
                             if (config2("noDeprecation")) {
                                 return fn2;
                             }
                             var warned2 = false;
 
-                            function deprecated2() {
+                            function deprecated() {
                                 if (!warned2) {
                                     if (config2("throwDeprecation")) {
                                         throw new Error(msg);
                                     } else if (config2("traceDeprecation")) {
                                         console.trace(msg);
                                     } else {
                                         console.warn(msg);
                                     }
                                     warned2 = true;
                                 }
                                 return fn2.apply(this, arguments);
                             }
-                            return deprecated2;
+                            return deprecated;
                         }
 
                         function config2(name2) {
                             try {
                                 if (!__webpack_require__2.g.localStorage)
                                     return false;
                             } catch (_2) {
@@ -303099,18 +303948,18 @@
                             if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                                 return ArrayBuffer.isView(value);
                             }
                             return isTypedArray2(value) || isDataView(value);
                         }
                         exports4.isArrayBufferView = isArrayBufferView;
 
-                        function isUint8Array(value) {
+                        function isUint8Array2(value) {
                             return whichTypedArray(value) === "Uint8Array";
                         }
-                        exports4.isUint8Array = isUint8Array;
+                        exports4.isUint8Array = isUint8Array2;
 
                         function isUint8ClampedArray(value) {
                             return whichTypedArray(value) === "Uint8ClampedArray";
                         }
                         exports4.isUint8ClampedArray = isUint8ClampedArray;
 
                         function isUint16Array(value) {
@@ -303375,28 +304224,28 @@
                             if (typeof process2 === "undefined") {
                                 return function() {
                                     return exports4.deprecate(fn2, msg).apply(this, arguments);
                                 };
                             }
                             var warned2 = false;
 
-                            function deprecated2() {
+                            function deprecated() {
                                 if (!warned2) {
                                     if (process2.throwDeprecation) {
                                         throw new Error(msg);
                                     } else if (process2.traceDeprecation) {
                                         console.trace(msg);
                                     } else {
                                         console.error(msg);
                                     }
                                     warned2 = true;
                                 }
                                 return fn2.apply(this, arguments);
                             }
-                            return deprecated2;
+                            return deprecated;
                         };
                         var debugs = {};
                         var debugEnvRegex = /^$/;
                         if (process2.env.NODE_DEBUG) {
                             var debugEnv = process2.env.NODE_DEBUG;
                             debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
                             debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
@@ -309914,16 +310763,16 @@
                                         matches2++;
                                     }
                                     iFormat += matches2 - 1;
                                     return Math.floor(matches2 / (step2 || 1)) > 1;
                                 };
                                 var getNumber = function(match2, step2) {
                                     var isDoubled = doubled(match2, step2);
-                                    var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]["oyYJ@!".indexOf(match2) + 1];
-                                    var digits = new RegExp("^-?\\d{1," + size + "}");
+                                    var size2 = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]["oyYJ@!".indexOf(match2) + 1];
+                                    var digits = new RegExp("^-?\\d{1," + size2 + "}");
                                     var num = value.substring(iValue).match(digits);
                                     if (!num) {
                                         throw (main2.local.missingNumberAt || main2.regionalOptions[""].missingNumberAt).replace(/\{0\}/, iValue);
                                     }
                                     iValue += num[0].length;
                                     return parseInt(num[0], 10);
                                 };
@@ -311435,30 +312284,30 @@
     an.produceWithPatches.bind(an);
     an.setAutoFreeze.bind(an);
     an.setUseProxies.bind(an);
     an.applyPatches.bind(an);
     an.createDraft.bind(an);
     an.finishDraft.bind(an);
     const n$2 = fn$7;
-    const ColumnSelect = styled__default.default(Select$1)`
+    const ColumnSelect = styled__default.default(Select$2)`
     flex-basis: 15rem;
 `;
     const FilterLabel = styled__default.default.span`
     flex-basis: 50px;
 `;
-    const AddFilterButton = styled__default.default(Button$3)`
+    const AddFilterButton = styled__default.default(Button$5)`
     flex-shrink: 0;
     width: max-content;
 
     svg {
         margin-right: 0.5rem;
         color: ${(props) => props.theme.colors.blue1};
     }
 `;
-    const RemoveFilterButton = styled__default.default(Cross$1)`
+    const RemoveFilterButton = styled__default.default(Cross$2)`
     color: ${(props) => props.theme.colors.error};
 
     :hover {
         color: ${(props) => props.theme.colors.errorHover};
     }
 `;
     const SlicerFilterWrapper = styled__default.default.div`
@@ -311559,34 +312408,34 @@
         }), /* @__PURE__ */ React__default.default.createElement(FilterLabel, null, "Variable"), /* @__PURE__ */ React__default.default.createElement(
             ColumnSelect, {
                 initialValue: columnItems.find((ci) => ci.value === f2.column),
                 items: columnItems,
                 onSelect: (i2) => updateFilter(f2.__id, "column", i2.value)
             }
         ), f2.column && /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, columnMap.get(f2.column) === "datetime" && /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(FilterLabel, null, "From"), /* @__PURE__ */ React__default.default.createElement(
-            DatePicker, {
+            DatePicker$1, {
                 initialValue: parseDateString(f2.from_date),
                 onChange: (v2) => updateFilter(f2.__id, "from_date", formatISO(v2)),
                 shouldCloseOnSelect: true,
                 showTimeInput: true
             }
         ), /* @__PURE__ */ React__default.default.createElement(FilterLabel, null, "To"), /* @__PURE__ */ React__default.default.createElement(
-            DatePicker, {
+            DatePicker$1, {
                 initialValue: parseDateString(f2.to_date),
                 onChange: (v2) => updateFilter(f2.__id, "to_date", formatISO(v2)),
                 shouldCloseOnSelect: true,
                 showTimeInput: true
             }
         )), ["categorical", "numerical"].includes(columnMap.get(f2.column)) && /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(FilterLabel, null, "Values"), /* @__PURE__ */ React__default.default.createElement(
-            Input$3, {
+            Input$5, {
                 initialValue: f2.values,
                 onChange: (v2) => updateFilter(f2.__id, "values", v2)
             }
         )), columnMap.get(f2.column) === "numerical" && /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, /* @__PURE__ */ React__default.default.createElement(FilterLabel, null, "or range"), /* @__PURE__ */ React__default.default.createElement(
-            Input$3, {
+            Input$5, {
                 initialValue: f2.range,
                 onChange: (v2) => updateFilter(f2.__id, "range", v2)
             }
         )))))), /* @__PURE__ */ React__default.default.createElement(AddFilterButton, {
             onClick: addFilter
         }, /* @__PURE__ */ React__default.default.createElement(Plus, null), "Add Filter"));
     }
@@ -312142,18 +312991,18 @@
                     return node2;
             }
         }
         return null;
     }
 
     function selection_size() {
-        let size = 0;
+        let size2 = 0;
         for (const node2 of this)
-            ++size;
-        return size;
+            ++size2;
+        return size2;
     }
 
     function selection_empty() {
         return !this.node();
     }
 
     function selection_each(callback) {
@@ -313254,15 +314103,15 @@
         clockNow = 0,
         clockSkew = 0,
         clock = typeof performance === "object" && performance.now ? performance : Date,
         setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
             setTimeout(f2, 17);
         };
 
-    function now() {
+    function now$1() {
         return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
     }
 
     function clearNow() {
         clockNow = 0;
     }
 
@@ -313270,15 +314119,15 @@
         this._call = this._time = this._next = null;
     }
     Timer.prototype = timer.prototype = {
         constructor: Timer,
         restart: function(callback, delay, time) {
             if (typeof callback !== "function")
                 throw new TypeError("callback is not a function");
-            time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
+            time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
             if (!this._next && taskTail !== this) {
                 if (taskTail)
                     taskTail._next = this;
                 else
                     taskHead = this;
                 taskTail = this;
             }
@@ -313298,15 +314147,15 @@
     function timer(callback, delay, time) {
         var t2 = new Timer();
         t2.restart(callback, delay, time);
         return t2;
     }
 
     function timerFlush() {
-        now();
+        now$1();
         ++frame;
         var t2 = taskHead,
             e3;
         while (t2) {
             if ((e3 = clockNow - t2._time) >= 0)
                 t2._call.call(null, e3);
             t2 = t2._next;
@@ -314051,37 +314900,37 @@
         }
         return new Transition(groups, this._parents, name2, id1);
     }
 
     function transition_end() {
         var on0, on1, that = this,
             id2 = that._id,
-            size = that.size();
+            size2 = that.size();
         return new Promise(function(resolve2, reject) {
             var cancel = {
                     value: reject
                 },
                 end2 = {
                     value: function() {
-                        if (--size === 0)
+                        if (--size2 === 0)
                             resolve2();
                     }
                 };
             that.each(function() {
                 var schedule2 = set$2(this, id2),
                     on2 = schedule2.on;
                 if (on2 !== on0) {
                     on1 = (on0 = on2).copy();
                     on1._.cancel.push(cancel);
                     on1._.interrupt.push(cancel);
                     on1._.end.push(end2);
                 }
                 schedule2.on = on1;
             });
-            if (size === 0)
+            if (size2 === 0)
                 resolve2();
         });
     }
     var id$1 = 0;
 
     function Transition(groups, parents, name2, id2) {
         this._groups = groups;
@@ -314146,15 +314995,15 @@
     }
 
     function selection_transition(name2) {
         var id2, timing;
         if (name2 instanceof Transition) {
             id2 = name2._id, name2 = name2._name;
         } else {
-            id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
+            id2 = newId(), (timing = defaultTiming).time = now$1(), name2 = name2 == null ? null : name2 + "";
         }
         for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2) {
             for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2) {
                 if (node2 = group[i2]) {
                     schedule(node2, name2, id2, i2, group, timing || inherit(node2, id2));
                 }
             }
@@ -314449,23 +315298,23 @@
     }
 
     function tree_root() {
         return this._root;
     }
 
     function tree_size() {
-        var size = 0;
+        var size2 = 0;
         this.visit(function(node2) {
             if (!node2.length)
                 do
 
-                    ++size;
+                    ++size2;
                 while (node2 = node2.next);
         });
-        return size;
+        return size2;
     }
 
     function tree_visit(callback) {
         var quads = [],
             q2, node2 = this._root,
             child, x0, y0, x1, y1;
         if (node2)
@@ -315734,26 +316583,26 @@
                     onClick: props.onClick
                 }, (_a4 = child.data) === null || _a4 === void 0 ? void 0 : _a4.id);
             })]
         });
     }
 
     function Treemap(props) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const ref2 = React.useRef();
         const [treemap, setTreemap] = React.useState();
         React.useEffect(() => {
             if (props.data) {
                 const root2 = hierarchy(props.data).sum((node2) => {
                     return node2.children && node2.children.length > 0 ? 0 : node2.weight;
                 });
                 index().size([props.width, props.height]).paddingTop(28).paddingBottom(8).paddingRight(7).paddingLeft(7).paddingInner(3)(root2);
                 setTreemap(root2);
             }
-        }, useDeepCompare([props.data, props.height, props.width]));
+        }, useDeepCompare$1([props.data, props.height, props.width]));
         const color2 = ordinal().domain(["0", "1", "2", "3", "4"]).range([theme2.colors.grey2, theme2.colors.grey3, theme2.colors.grey4, theme2.colors.grey5, theme2.colors.grey6]);
         if (!treemap) {
             return null;
         }
         const maxDepth = treemap.leaves() ? treemap.leaves()[0].depth : 0;
         return jsxRuntime.exports.jsx("svg", {
             height: props.height,
@@ -315765,22 +316614,22 @@
                 color: color2,
                 maxDepth,
                 node: treemap,
                 onClick: props.onClick
             })
         });
     }
-    const Wrapper$2 = styled__default.default.div`
+    const Wrapper$8 = styled__default.default.div`
     width: 100%;
     height: 100%;
 `;
 
     function HierarchyViewer$1(props) {
         const [ref2, dimensions2] = useDimensions();
-        return jsxRuntime.exports.jsx(Wrapper$2, {
+        return jsxRuntime.exports.jsx(Wrapper$8, {
             className: props.className,
             id: "hierarchy-viewer-root",
             ref: ref2,
             style: props.style,
             children: jsxRuntime.exports.jsx(Treemap, {
                 allowLeafClick: props.allowLeafClick,
                 allowParentClick: props.allowParentClick,
@@ -316160,16 +317009,16 @@
         nextInner(skip, dir) {
             this.done = this.lineBreak = false;
             for (;;) {
                 let last = this.nodes.length - 1;
                 let top2 = this.nodes[last],
                     offsetValue = this.offsets[last],
                     offset2 = offsetValue >> 1;
-                let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
-                if (offset2 == (dir > 0 ? size : 0)) {
+                let size2 = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
+                if (offset2 == (dir > 0 ? size2 : 0)) {
                     if (last == 0) {
                         this.done = true;
                         this.value = "";
                         return this;
                     }
                     if (dir > 0)
                         this.offsets[last - 1]++;
@@ -318094,18 +318943,18 @@
         get length() {
             let last = this.chunk.length - 1;
             return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
         }
         get size() {
             if (this.isEmpty)
                 return 0;
-            let size = this.nextLayer.size;
+            let size2 = this.nextLayer.size;
             for (let chunk of this.chunk)
-                size += chunk.value.length;
-            return size;
+                size2 += chunk.value.length;
+            return size2;
         }
         chunkEnd(index2) {
             return this.chunkPos[index2] + this.chunk[index2].length;
         }
         update(updateSpec) {
             let {
                 add: add2 = [],
@@ -319362,49 +320211,49 @@
                 pos += child.length + child.breakAfter;
             }
             throw new RangeError("Invalid child in posBefore");
         }
         posAfter(view) {
             return this.posBefore(view) + view.length;
         }
-        sync(view, track2) {
+        sync(view, track) {
             if (this.flags & 2) {
                 let parent = this.dom;
                 let prev = null,
                     next2;
                 for (let child of this.children) {
                     if (child.flags & 7) {
                         if (!child.dom && (next2 = prev ? prev.nextSibling : parent.firstChild)) {
                             let contentView = ContentView.get(next2);
                             if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                                 child.reuseDOM(next2);
                         }
-                        child.sync(view, track2);
+                        child.sync(view, track);
                         child.flags &= ~7;
                     }
                     next2 = prev ? prev.nextSibling : parent.firstChild;
-                    if (track2 && !track2.written && track2.node == parent && next2 != child.dom)
-                        track2.written = true;
+                    if (track && !track.written && track.node == parent && next2 != child.dom)
+                        track.written = true;
                     if (child.dom.parentNode == parent) {
                         while (next2 && next2 != child.dom)
                             next2 = rm$1(next2);
                     } else {
                         parent.insertBefore(child.dom, next2);
                     }
                     prev = child.dom;
                 }
                 next2 = prev ? prev.nextSibling : parent.firstChild;
-                if (next2 && track2 && track2.node == parent)
-                    track2.written = true;
+                if (next2 && track && track.node == parent)
+                    track.written = true;
                 while (next2)
                     next2 = rm$1(next2);
             } else if (this.flags & 1) {
                 for (let child of this.children)
                     if (child.flags & 7) {
-                        child.sync(view, track2);
+                        child.sync(view, track);
                         child.flags &= ~7;
                     }
             }
         }
         reuseDOM(_dom) {}
         localPosFromDOM(node2, offset2) {
             let after;
@@ -319713,20 +320562,20 @@
         }
         get length() {
             return this.text.length;
         }
         createDOM(textDOM) {
             this.setDOM(textDOM || document.createTextNode(this.text));
         }
-        sync(view, track2) {
+        sync(view, track) {
             if (!this.dom)
                 this.createDOM();
             if (this.dom.nodeValue != this.text) {
-                if (track2 && track2.node == this.dom)
-                    track2.written = true;
+                if (track && track.node == this.dom)
+                    track.written = true;
                 this.dom.nodeValue = this.text;
             }
         }
         reuseDOM(dom2) {
             if (dom2.nodeType == 3)
                 this.createDOM(dom2);
         }
@@ -319785,20 +320634,20 @@
         }
         reuseDOM(node2) {
             if (node2.nodeName == this.mark.tagName.toUpperCase()) {
                 this.setDOM(node2);
                 this.flags |= 4 | 2;
             }
         }
-        sync(view, track2) {
+        sync(view, track) {
             if (!this.dom)
                 this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
             else if (this.flags & 4)
                 this.setAttrs(this.dom);
-            super.sync(view, track2);
+            super.sync(view, track);
         }
         merge(from, to2, source, _hasStart, openStart, openEnd) {
             if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to2 < this.length && openEnd <= 0))
                 return false;
             mergeChildrenInto(this, from, to2, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
             this.markDirty();
             return true;
@@ -320240,15 +321089,15 @@
         }
         reuseDOM(node2) {
             if (node2.nodeName == "DIV") {
                 this.setDOM(node2);
                 this.flags |= 4 | 2;
             }
         }
-        sync(view, track2) {
+        sync(view, track) {
             var _a3;
             if (!this.dom) {
                 this.setDOM(document.createElement("div"));
                 this.dom.className = "cm-line";
                 this.prevAttrs = this.attrs ? null : void 0;
             } else if (this.flags & 4) {
                 clearAttributes(this.dom);
@@ -320256,15 +321105,15 @@
                 this.prevAttrs = this.attrs ? null : void 0;
             }
             if (this.prevAttrs !== void 0) {
                 updateAttrs(this.dom, this.prevAttrs, this.attrs);
                 this.dom.classList.add("cm-line");
                 this.prevAttrs = void 0;
             }
-            super.sync(view, track2);
+            super.sync(view, track);
             let last = this.dom.lastChild;
             while (last && ContentView.get(last) instanceof MarkView)
                 last = last.lastChild;
             if (!last || !this.length || last.nodeName != "BR" && ((_a3 = ContentView.get(last)) === null || _a3 === void 0 ? void 0 : _a3.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
                 let hack = document.createElement("BR");
                 hack.cmIgnore = true;
                 this.dom.appendChild(hack);
@@ -321508,21 +322357,21 @@
             this.updateChildren(changes, oldLength, composition);
             let {
                 observer
             } = this.view;
             observer.ignore(() => {
                 this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
                 this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
-                let track2 = browser.chrome || browser.ios ? {
+                let track = browser.chrome || browser.ios ? {
                     node: observer.selectionRange.focusNode,
                     written: false
                 } : void 0;
-                this.sync(this.view, track2);
+                this.sync(this.view, track);
                 this.flags &= ~7;
-                if (track2 && (track2.written || observer.selectionRange.focusNode != track2.node))
+                if (track && (track.written || observer.selectionRange.focusNode != track.node))
                     this.forceSelection = true;
                 this.dom.style.height = "";
             });
             this.markedForComposition.forEach((cView) => cView.flags &= ~8);
             let gaps = [];
             if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
                 for (let child of this.children)
@@ -324177,18 +325026,18 @@
             left: 0,
             right: rect.right - rect.left,
             top: paddingTop,
             bottom: rect.bottom - (rect.top + paddingTop)
         };
     }
     class LineGap {
-        constructor(from, to2, size) {
+        constructor(from, to2, size2) {
             this.from = from;
             this.to = to2;
-            this.size = size;
+            this.size = size2;
         }
         static same(a2, b2) {
             if (a2.length != b2.length)
                 return false;
             for (let i2 = 0; i2 < a2.length; i2++) {
                 let gA = a2[i2],
                     gB = b2[i2];
@@ -324200,17 +325049,17 @@
         draw(viewState, wrapping) {
             return Decoration.replace({
                 widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
             }).range(this.from, this.to);
         }
     }
     class LineGapWidget extends WidgetType {
-        constructor(size, vertical) {
+        constructor(size2, vertical) {
             super();
-            this.size = size;
+            this.size = size2;
             this.vertical = vertical;
         }
         eq(other) {
             return other.size == this.size && other.vertical == this.vertical;
         }
         toDOM() {
             let elt = document.createElement("div");
@@ -324675,18 +325524,18 @@
         if (ratio >= 1)
             return ranges[ranges.length - 1].to;
         let dist2 = Math.floor(total * ratio);
         for (let i2 = 0;; i2++) {
             let {
                 from,
                 to: to2
-            } = ranges[i2], size = to2 - from;
-            if (dist2 <= size)
+            } = ranges[i2], size2 = to2 - from;
+            if (dist2 <= size2)
                 return from + dist2;
-            dist2 -= size;
+            dist2 -= size2;
         }
     }
 
     function findFraction(structure, pos) {
         let counted = 0;
         for (let {
                 from,
@@ -325329,24 +326178,24 @@
                         from: composition.from,
                         to: composition.to - dLen
                     };
                 } else {
                     compositionRange = view.state.doc.lineAt(sel.head);
                 }
                 let offset2 = sel.to - change.to,
-                    size = sel.to - sel.from;
+                    size2 = sel.to - sel.from;
                 tr2 = startState.changeByRange((range2) => {
                     if (range2.from == sel.from && range2.to == sel.to)
                         return {
                             changes,
                             range: mainSel || range2.map(changes)
                         };
                     let to2 = range2.to - offset2,
                         from = to2 - replaced.length;
-                    if (range2.to - range2.from != size || view.state.sliceDoc(from, to2) != replaced || range2.to >= compositionRange.from && range2.from <= compositionRange.to)
+                    if (range2.to - range2.from != size2 || view.state.sliceDoc(from, to2) != replaced || range2.to >= compositionRange.from && range2.from <= compositionRange.to)
                         return {
                             range: range2
                         };
                     let rangeChanges = startState.changes({
                             from,
                             to: to2,
                             insert: change.insert
@@ -327583,16 +328432,16 @@
         }
         static build(data2) {
             return buildTree(data2);
         }
     }
     Tree.empty = new Tree(NodeType.none, [], [], 0);
     class FlatBufferCursor {
-        constructor(buffer2, index2) {
-            this.buffer = buffer2;
+        constructor(buffer, index2) {
+            this.buffer = buffer;
             this.index = index2;
         }
         get id() {
             return this.buffer[this.index - 4];
         }
         get start() {
             return this.buffer[this.index - 3];
@@ -327610,16 +328459,16 @@
             this.index -= 4;
         }
         fork() {
             return new FlatBufferCursor(this.buffer, this.index);
         }
     }
     class TreeBuffer {
-        constructor(buffer2, length, set2) {
-            this.buffer = buffer2;
+        constructor(buffer, length, set2) {
+            this.buffer = buffer;
             this.length = length;
             this.set = set2;
         }
         get type() {
             return NodeType.none;
         }
         toString() {
@@ -327645,18 +328494,18 @@
                 children2.push(this.childString(index2));
                 index2 = this.buffer[index2 + 3];
             }
             return result + "(" + children2.join(",") + ")";
         }
         findChild(startIndex, endIndex, dir, pos, side) {
             let {
-                buffer: buffer2
+                buffer
             } = this, pick = -1;
-            for (let i2 = startIndex; i2 != endIndex; i2 = buffer2[i2 + 3]) {
-                if (checkSide(side, pos, buffer2[i2 + 1], buffer2[i2 + 2])) {
+            for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
+                if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
                     pick = i2;
                     if (dir > 0)
                         break;
                 }
             }
             return pick;
         }
@@ -327891,17 +328740,17 @@
                     return false;
                 i2--;
             }
         }
         return true;
     }
     class BufferContext {
-        constructor(parent, buffer2, index2, start2) {
+        constructor(parent, buffer, index2, start2) {
             this.parent = parent;
-            this.buffer = buffer2;
+            this.buffer = buffer;
             this.index = index2;
             this.start = start2;
         }
     }
     class BufferNode extends BaseNode {
         get name() {
             return this.type.name;
@@ -327917,17 +328766,17 @@
             this.context = context2;
             this._parent = _parent;
             this.index = index2;
             this.type = context2.buffer.set.types[context2.buffer.buffer[index2]];
         }
         child(dir, pos, side) {
             let {
-                buffer: buffer2
+                buffer
             } = this.context;
-            let index2 = buffer2.findChild(this.index + 4, buffer2.buffer[this.index + 3], dir, pos - this.context.start, side);
+            let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
             return index2 < 0 ? null : new BufferNode(this.context, this, index2);
         }
         get firstChild() {
             return this.child(1, 0, 4);
         }
         get lastChild() {
             return this.child(-1, 0, 4);
@@ -327938,57 +328787,57 @@
         childBefore(pos) {
             return this.child(-1, pos, -2);
         }
         enter(pos, side, mode = 0) {
             if (mode & IterMode.ExcludeBuffers)
                 return null;
             let {
-                buffer: buffer2
+                buffer
             } = this.context;
-            let index2 = buffer2.findChild(this.index + 4, buffer2.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
+            let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
             return index2 < 0 ? null : new BufferNode(this.context, this, index2);
         }
         get parent() {
             return this._parent || this.context.parent.nextSignificantParent();
         }
         externalSibling(dir) {
             return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
         }
         get nextSibling() {
             let {
-                buffer: buffer2
+                buffer
             } = this.context;
-            let after = buffer2.buffer[this.index + 3];
-            if (after < (this._parent ? buffer2.buffer[this._parent.index + 3] : buffer2.buffer.length))
+            let after = buffer.buffer[this.index + 3];
+            if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
                 return new BufferNode(this.context, this._parent, after);
             return this.externalSibling(1);
         }
         get prevSibling() {
             let {
-                buffer: buffer2
+                buffer
             } = this.context;
             let parentStart = this._parent ? this._parent.index + 4 : 0;
             if (this.index == parentStart)
                 return this.externalSibling(-1);
-            return new BufferNode(this.context, this._parent, buffer2.findChild(parentStart, this.index, -1, 0, 4));
+            return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
         }
         get tree() {
             return null;
         }
         toTree() {
             let children2 = [],
                 positions = [];
             let {
-                buffer: buffer2
+                buffer
             } = this.context;
             let startI = this.index + 4,
-                endI = buffer2.buffer[this.index + 3];
+                endI = buffer.buffer[this.index + 3];
             if (endI > startI) {
-                let from = buffer2.buffer[this.index + 1];
-                children2.push(buffer2.slice(startI, endI, from));
+                let from = buffer.buffer[this.index + 1];
+                children2.push(buffer.slice(startI, endI, from));
                 positions.push(0);
             }
             return new Tree(this.type, children2, positions, this.to - this.from);
         }
         toString() {
             return this.context.buffer.childString(this.index);
         }
@@ -328072,19 +328921,19 @@
             this.to = node2.to;
             return true;
         }
         yieldBuf(index2, type2) {
             this.index = index2;
             let {
                 start: start2,
-                buffer: buffer2
+                buffer
             } = this.buffer;
-            this.type = type2 || buffer2.set.types[buffer2.buffer[index2]];
-            this.from = start2 + buffer2.buffer[index2 + 1];
-            this.to = start2 + buffer2.buffer[index2 + 2];
+            this.type = type2 || buffer.set.types[buffer.buffer[index2]];
+            this.from = start2 + buffer.buffer[index2 + 1];
+            this.to = start2 + buffer.buffer[index2 + 2];
             return true;
         }
         yield(node2) {
             if (!node2)
                 return false;
             if (node2 instanceof TreeNode) {
                 this.buffer = null;
@@ -328096,17 +328945,17 @@
         toString() {
             return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
         }
         enterChild(dir, pos, side) {
             if (!this.buffer)
                 return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
             let {
-                buffer: buffer2
+                buffer
             } = this.buffer;
-            let index2 = buffer2.findChild(this.index + 4, buffer2.buffer[this.index + 3], dir, pos - this.buffer.start, side);
+            let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
             if (index2 < 0)
                 return false;
             this.stack.push(this.index);
             return this.yieldBuf(index2);
         }
         firstChild() {
             return this.enterChild(1, 0, 4);
@@ -328134,50 +328983,50 @@
             this.buffer = null;
             return this.yieldNode(parent);
         }
         sibling(dir) {
             if (!this.buffer)
                 return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
             let {
-                buffer: buffer2
+                buffer
             } = this.buffer, d2 = this.stack.length - 1;
             if (dir < 0) {
                 let parentStart = d2 < 0 ? 0 : this.stack[d2] + 4;
                 if (this.index != parentStart)
-                    return this.yieldBuf(buffer2.findChild(parentStart, this.index, -1, 0, 4));
+                    return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
             } else {
-                let after = buffer2.buffer[this.index + 3];
-                if (after < (d2 < 0 ? buffer2.buffer.length : buffer2.buffer[this.stack[d2] + 3]))
+                let after = buffer.buffer[this.index + 3];
+                if (after < (d2 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d2] + 3]))
                     return this.yieldBuf(after);
             }
             return d2 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
         }
         nextSibling() {
             return this.sibling(1);
         }
         prevSibling() {
             return this.sibling(-1);
         }
         atLastNode(dir) {
             let index2, parent, {
-                buffer: buffer2
+                buffer
             } = this;
-            if (buffer2) {
+            if (buffer) {
                 if (dir > 0) {
-                    if (this.index < buffer2.buffer.buffer.length)
+                    if (this.index < buffer.buffer.buffer.length)
                         return false;
                 } else {
                     for (let i2 = 0; i2 < this.index; i2++)
-                        if (buffer2.buffer.buffer[i2 + 3] < this.index)
+                        if (buffer.buffer.buffer[i2 + 3] < this.index)
                             return false;
                 }
                 ({
                     index: index2,
                     parent
-                } = buffer2);
+                } = buffer);
             } else {
                 ({
                     index: index2,
                     _parent: parent
                 } = this._tree);
             }
             for (; parent;
@@ -328268,22 +329117,22 @@
                 }
             }
         }
         matchContext(context2) {
             if (!this.buffer)
                 return matchNodeContext(this.node, context2);
             let {
-                buffer: buffer2
+                buffer
             } = this.buffer, {
                 types: types2
-            } = buffer2.set;
+            } = buffer.set;
             for (let i2 = context2.length - 1, d2 = this.stack.length - 1; i2 >= 0; d2--) {
                 if (d2 < 0)
                     return matchNodeContext(this.node, context2, i2);
-                let type2 = types2[buffer2.buffer[this.stack[d2]]];
+                let type2 = types2[buffer.buffer[this.stack[d2]]];
                 if (!type2.isAnonymous) {
                     if (context2[i2] && context2[i2] != type2.name)
                         return false;
                     i2--;
                 }
             }
             return true;
@@ -328293,63 +329142,63 @@
     function hasChild(tree) {
         return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
     }
 
     function buildTree(data2) {
         var _a3;
         let {
-            buffer: buffer2,
+            buffer,
             nodeSet,
             maxBufferLength = DefaultBufferLength,
             reused = [],
             minRepeatType = nodeSet.types.length
         } = data2;
-        let cursor = Array.isArray(buffer2) ? new FlatBufferCursor(buffer2, buffer2.length) : buffer2;
+        let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
         let types2 = nodeSet.types;
         let contextHash = 0,
             lookAhead = 0;
 
         function takeNode(parentStart, minPos, children3, positions2, inRepeat, depth) {
             let {
                 id: id2,
                 start: start2,
                 end: end2,
-                size
+                size: size2
             } = cursor;
             let lookAheadAtStart = lookAhead;
-            while (size < 0) {
+            while (size2 < 0) {
                 cursor.next();
-                if (size == -1) {
+                if (size2 == -1) {
                     let node3 = reused[id2];
                     children3.push(node3);
                     positions2.push(start2 - parentStart);
                     return;
-                } else if (size == -3) {
+                } else if (size2 == -3) {
                     contextHash = id2;
                     return;
-                } else if (size == -4) {
+                } else if (size2 == -4) {
                     lookAhead = id2;
                     return;
                 } else {
-                    throw new RangeError(`Unrecognized record size: ${size}`);
+                    throw new RangeError(`Unrecognized record size: ${size2}`);
                 }
             }
             let type2 = types2[id2],
-                node2, buffer3;
+                node2, buffer2;
             let startPos = start2 - parentStart;
-            if (end2 - start2 <= maxBufferLength && (buffer3 = findBufferSize(cursor.pos - minPos, inRepeat))) {
-                let data3 = new Uint16Array(buffer3.size - buffer3.skip);
-                let endPos = cursor.pos - buffer3.size,
+            if (end2 - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
+                let data3 = new Uint16Array(buffer2.size - buffer2.skip);
+                let endPos = cursor.pos - buffer2.size,
                     index2 = data3.length;
                 while (cursor.pos > endPos)
-                    index2 = copyToBuffer(buffer3.start, data3, index2);
-                node2 = new TreeBuffer(data3, end2 - buffer3.start, nodeSet);
-                startPos = buffer3.start - parentStart;
+                    index2 = copyToBuffer(buffer2.start, data3, index2);
+                node2 = new TreeBuffer(data3, end2 - buffer2.start, nodeSet);
+                startPos = buffer2.start - parentStart;
             } else {
-                let endPos = cursor.pos - size;
+                let endPos = cursor.pos - size2;
                 cursor.next();
                 let localChildren = [],
                     localPositions = [];
                 let localInRepeat = id2 >= minRepeatType ? id2 : -1;
                 let lastGroup = 0,
                     lastEnd = end2;
                 while (cursor.pos > endPos) {
@@ -328386,38 +329235,38 @@
             let nodeCount = 0,
                 stopAt = -1;
             while (cursor.pos > minPos) {
                 let {
                     id: id2,
                     start: start2,
                     end: end2,
-                    size
+                    size: size2
                 } = cursor;
-                if (size > 4) {
+                if (size2 > 4) {
                     cursor.next();
                 } else if (stopAt > -1 && start2 < stopAt) {
                     break;
                 } else {
                     if (stopAt < 0)
                         stopAt = end2 - maxBufferLength;
                     nodes.push(id2, start2, end2);
                     nodeCount++;
                     cursor.next();
                 }
             }
             if (nodeCount) {
-                let buffer3 = new Uint16Array(nodeCount * 4);
+                let buffer2 = new Uint16Array(nodeCount * 4);
                 let start2 = nodes[nodes.length - 2];
                 for (let i2 = nodes.length - 3, j2 = 0; i2 >= 0; i2 -= 3) {
-                    buffer3[j2++] = nodes[i2];
-                    buffer3[j2++] = nodes[i2 + 1] - start2;
-                    buffer3[j2++] = nodes[i2 + 2] - start2;
-                    buffer3[j2++] = j2;
+                    buffer2[j2++] = nodes[i2];
+                    buffer2[j2++] = nodes[i2 + 1] - start2;
+                    buffer2[j2++] = nodes[i2 + 2] - start2;
+                    buffer2[j2++] = j2;
                 }
-                children3.push(new TreeBuffer(buffer3, nodes[2] - start2, nodeSet));
+                children3.push(new TreeBuffer(buffer2, nodes[2] - start2, nodeSet));
                 positions2.push(start2 - parentStart);
             }
         }
 
         function makeBalanced(type2) {
             return (children3, positions2, length2) => {
                 let lookAhead2 = 0,
@@ -328454,32 +329303,32 @@
                 props = props ? [pair2].concat(props) : [pair2];
             }
             return new Tree(type2, children3, positions2, length2, props);
         }
 
         function findBufferSize(maxSize, inRepeat) {
             let fork = cursor.fork();
-            let size = 0,
+            let size2 = 0,
                 start2 = 0,
                 skip = 0,
                 minStart = fork.end - maxBufferLength;
             let result = {
                 size: 0,
                 start: 0,
                 skip: 0
             };
             scan:
                 for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
                     let nodeSize2 = fork.size;
                     if (fork.id == inRepeat && nodeSize2 >= 0) {
-                        result.size = size;
+                        result.size = size2;
                         result.start = start2;
                         result.skip = skip;
                         skip += 4;
-                        size += 4;
+                        size2 += 4;
                         fork.next();
                         continue;
                     }
                     let startPos = fork.pos - nodeSize2;
                     if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
                         break;
                     let localSkipped = fork.id >= minRepeatType ? 4 : 0;
@@ -328493,47 +329342,47 @@
                                 break scan;
                         } else if (fork.id >= minRepeatType) {
                             localSkipped += 4;
                         }
                         fork.next();
                     }
                     start2 = nodeStart2;
-                    size += nodeSize2;
+                    size2 += nodeSize2;
                     skip += localSkipped;
                 }
-            if (inRepeat < 0 || size == maxSize) {
-                result.size = size;
+            if (inRepeat < 0 || size2 == maxSize) {
+                result.size = size2;
                 result.start = start2;
                 result.skip = skip;
             }
             return result.size > 4 ? result : void 0;
         }
 
-        function copyToBuffer(bufferStart, buffer3, index2) {
+        function copyToBuffer(bufferStart, buffer2, index2) {
             let {
                 id: id2,
                 start: start2,
                 end: end2,
-                size
+                size: size2
             } = cursor;
             cursor.next();
-            if (size >= 0 && id2 < minRepeatType) {
+            if (size2 >= 0 && id2 < minRepeatType) {
                 let startIndex = index2;
-                if (size > 4) {
-                    let endPos = cursor.pos - (size - 4);
+                if (size2 > 4) {
+                    let endPos = cursor.pos - (size2 - 4);
                     while (cursor.pos > endPos)
-                        index2 = copyToBuffer(bufferStart, buffer3, index2);
+                        index2 = copyToBuffer(bufferStart, buffer2, index2);
                 }
-                buffer3[--index2] = startIndex;
-                buffer3[--index2] = end2 - bufferStart;
-                buffer3[--index2] = start2 - bufferStart;
-                buffer3[--index2] = id2;
-            } else if (size == -3) {
+                buffer2[--index2] = startIndex;
+                buffer2[--index2] = end2 - bufferStart;
+                buffer2[--index2] = start2 - bufferStart;
+                buffer2[--index2] = id2;
+            } else if (size2 == -3) {
                 contextHash = id2;
-            } else if (size == -4) {
+            } else if (size2 == -4) {
                 lookAhead = id2;
             }
             return index2;
         }
         let children2 = [],
             positions = [];
         while (cursor.pos > 0)
@@ -328542,27 +329391,27 @@
         return new Tree(types2[data2.topID], children2.reverse(), positions.reverse(), length);
     }
     const nodeSizeCache = /* @__PURE__ */ new WeakMap();
 
     function nodeSize(balanceType, node2) {
         if (!balanceType.isAnonymous || node2 instanceof TreeBuffer || node2.type != balanceType)
             return 1;
-        let size = nodeSizeCache.get(node2);
-        if (size == null) {
-            size = 1;
+        let size2 = nodeSizeCache.get(node2);
+        if (size2 == null) {
+            size2 = 1;
             for (let child of node2.children) {
                 if (child.type != balanceType || !(child instanceof Tree)) {
-                    size = 1;
+                    size2 = 1;
                     break;
                 }
-                size += nodeSize(balanceType, child);
+                size2 += nodeSize(balanceType, child);
             }
-            nodeSizeCache.set(node2, size);
+            nodeSizeCache.set(node2, size2);
         }
-        return size;
+        return size2;
     }
 
     function balanceRange(balanceType, children2, positions, from, to2, start2, length, mkTop, mkTree) {
         let total = 0;
         for (let i2 = from; i2 < to2; i2++)
             total += nodeSize(balanceType, children2[i2]);
         let maxChild = Math.ceil(total * 1.5 / 8);
@@ -328598,22 +329447,22 @@
         divide(children2, positions, from, to2, 0);
         return (mkTop || mkTree)(localChildren, localPositions, length);
     }
     class NodeWeakMap {
         constructor() {
             this.map = /* @__PURE__ */ new WeakMap();
         }
-        setBuffer(buffer2, index2, value) {
-            let inner = this.map.get(buffer2);
+        setBuffer(buffer, index2, value) {
+            let inner = this.map.get(buffer);
             if (!inner)
-                this.map.set(buffer2, inner = /* @__PURE__ */ new Map());
+                this.map.set(buffer, inner = /* @__PURE__ */ new Map());
             inner.set(index2, value);
         }
-        getBuffer(buffer2, index2) {
-            let inner = this.map.get(buffer2);
+        getBuffer(buffer, index2) {
+            let inner = this.map.get(buffer);
             return inner && inner.get(index2);
         }
         set(node2, value) {
             if (node2 instanceof BufferNode)
                 this.setBuffer(node2.context.buffer, node2.index, value);
             else if (node2 instanceof TreeNode)
                 this.map.set(node2.tree, value);
@@ -329261,17 +330110,17 @@
                         else
                             result.push({
                                 from,
                                 to: from + tree.length
                             });
                         return;
                     } else if (mount.overlay) {
-                        let size = result.length;
+                        let size2 = result.length;
                         explore(mount.tree, mount.overlay[0].from + from);
-                        if (result.length > size)
+                        if (result.length > size2)
                             return;
                     }
                 }
                 for (let i2 = 0; i2 < tree.children.length; i2++) {
                     let ch = tree.children[i2];
                     if (ch instanceof Tree)
                         explore(ch, tree.positions[i2] + from);
@@ -330211,27 +331060,27 @@
         let maxScanDistance = config2.maxScanDistance || DefaultScanDist,
             brackets = config2.brackets || DefaultBrackets;
         let tree = syntaxTree(state),
             node2 = tree.resolveInner(pos, dir);
         for (let cur = node2; cur; cur = cur.parent) {
             let matches2 = matchingNodes(cur.type, dir, brackets);
             if (matches2 && cur.from < cur.to) {
-                let handle = findHandle(cur);
-                if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
-                    return matchMarkedBrackets(state, pos, dir, cur, handle, matches2, brackets);
+                let handle2 = findHandle(cur);
+                if (handle2 && (dir > 0 ? pos >= handle2.from && pos < handle2.to : pos > handle2.from && pos <= handle2.to))
+                    return matchMarkedBrackets(state, pos, dir, cur, handle2, matches2, brackets);
             }
         }
         return matchPlainBrackets(state, pos, dir, tree, node2.type, maxScanDistance, brackets);
     }
 
-    function matchMarkedBrackets(_state, _pos, dir, token, handle, matching2, brackets) {
+    function matchMarkedBrackets(_state, _pos, dir, token, handle2, matching2, brackets) {
         let parent = token.parent,
             firstToken = {
-                from: handle.from,
-                to: handle.to
+                from: handle2.from,
+                to: handle2.to
             };
         let depth = 0,
             cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
         if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
             do {
                 if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                     if (depth == 0 && matching2.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
@@ -332184,35 +333033,35 @@
             return false;
         let changes = [],
             ranges = [];
         for (let block of selectedLineBlocks(state)) {
             if (forward ? block.to == state.doc.length : block.from == 0)
                 continue;
             let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
-            let size = nextLine.length + 1;
+            let size2 = nextLine.length + 1;
             if (forward) {
                 changes.push({
                     from: block.to,
                     to: nextLine.to
                 }, {
                     from: block.from,
                     insert: nextLine.text + state.lineBreak
                 });
                 for (let r2 of block.ranges)
-                    ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size), Math.min(state.doc.length, r2.head + size)));
+                    ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size2), Math.min(state.doc.length, r2.head + size2)));
             } else {
                 changes.push({
                     from: nextLine.from,
                     to: block.from
                 }, {
                     from: block.to,
                     insert: state.lineBreak + nextLine.text
                 });
                 for (let r2 of block.ranges)
-                    ranges.push(EditorSelection.range(r2.anchor - size, r2.head - size));
+                    ranges.push(EditorSelection.range(r2.anchor - size2, r2.head - size2));
             }
         }
         if (!changes.length)
             return false;
         dispatch2(state.update({
             changes,
             scrollIntoView: true,
@@ -332679,22 +333528,22 @@
     }].concat(standardKeymap);
     const indentWithTab = {
         key: "Tab",
         run: indentMore,
         shift: indentLess
     };
     class Stack$1 {
-        constructor(p2, stack, state, reducePos, pos, score2, buffer2, bufferBase, curContext, lookAhead = 0, parent) {
+        constructor(p2, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
             this.p = p2;
             this.stack = stack;
             this.state = state;
             this.reducePos = reducePos;
             this.pos = pos;
             this.score = score2;
-            this.buffer = buffer2;
+            this.buffer = buffer;
             this.bufferBase = bufferBase;
             this.curContext = curContext;
             this.lookAhead = lookAhead;
             this.parent = parent;
         }
         toString() {
             return `[${this.stack.filter((_2, i2) => i2 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
@@ -332725,23 +333574,23 @@
                 if (type2 < parser2.minRepeatTerm)
                     this.storeNode(type2, this.reducePos, this.reducePos, 4, true);
                 this.reduceContext(type2, this.reducePos);
                 return;
             }
             let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
             let start2 = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from,
-                size = this.reducePos - start2;
-            if (size >= 2e3 && !((_a3 = this.p.parser.nodeSet.types[type2]) === null || _a3 === void 0 ? void 0 : _a3.isAnonymous)) {
+                size2 = this.reducePos - start2;
+            if (size2 >= 2e3 && !((_a3 = this.p.parser.nodeSet.types[type2]) === null || _a3 === void 0 ? void 0 : _a3.isAnonymous)) {
                 if (start2 == this.p.lastBigReductionStart) {
                     this.p.bigReductionCount++;
-                    this.p.lastBigReductionSize = size;
-                } else if (this.p.lastBigReductionSize < size) {
+                    this.p.lastBigReductionSize = size2;
+                } else if (this.p.lastBigReductionSize < size2) {
                     this.p.bigReductionCount = 1;
                     this.p.lastBigReductionStart = start2;
-                    this.p.lastBigReductionSize = size;
+                    this.p.lastBigReductionSize = size2;
                 }
             }
             let bufferBase = base2 ? this.stack[base2 - 1] : 0,
                 count2 = this.bufferBase + this.buffer.length - bufferBase;
             if (type2 < parser2.minRepeatTerm || action & 131072) {
                 let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
                 this.storeNode(type2, start2, pos, count2 + 4, true);
@@ -332752,15 +333601,15 @@
                 let baseStateID = this.stack[base2 - 3];
                 this.state = parser2.getGoto(baseStateID, type2, true);
             }
             while (this.stack.length > base2)
                 this.stack.pop();
             this.reduceContext(type2, start2);
         }
-        storeNode(term, start2, end2, size = 4, isReduce = false) {
+        storeNode(term, start2, end2, size2 = 4, isReduce = false) {
             if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
                 let cur = this,
                     top2 = this.buffer.length;
                 if (top2 == 0 && cur.parent) {
                     top2 = cur.bufferBase - cur.parent.bufferBase;
                     cur = cur.parent;
                 }
@@ -332770,31 +333619,31 @@
                     if (cur.buffer[top2 - 2] >= start2) {
                         cur.buffer[top2 - 2] = end2;
                         return;
                     }
                 }
             }
             if (!isReduce || this.pos == end2) {
-                this.buffer.push(term, start2, end2, size);
+                this.buffer.push(term, start2, end2, size2);
             } else {
                 let index2 = this.buffer.length;
                 if (index2 > 0 && this.buffer[index2 - 4] != 0)
                     while (index2 > 0 && this.buffer[index2 - 2] > end2) {
                         this.buffer[index2] = this.buffer[index2 - 4];
                         this.buffer[index2 + 1] = this.buffer[index2 - 3];
                         this.buffer[index2 + 2] = this.buffer[index2 - 2];
                         this.buffer[index2 + 3] = this.buffer[index2 - 1];
                         index2 -= 4;
-                        if (size > 4)
-                            size -= 4;
+                        if (size2 > 4)
+                            size2 -= 4;
                     }
                 this.buffer[index2] = term;
                 this.buffer[index2 + 1] = start2;
                 this.buffer[index2 + 2] = end2;
-                this.buffer[index2 + 3] = size;
+                this.buffer[index2 + 3] = size2;
             }
         }
         shift(action, type2, start2, end2) {
             if (action & 131072) {
                 this.pushState(action & 65535, this.pos);
             } else if ((action & 262144) == 0) {
                 let nextState = action,
@@ -332837,19 +333686,19 @@
                 this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
         }
         split() {
             let parent = this;
             let off = parent.buffer.length;
             while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
                 off -= 4;
-            let buffer2 = parent.buffer.slice(off),
+            let buffer = parent.buffer.slice(off),
                 base2 = parent.bufferBase + off;
             while (parent && base2 == parent.bufferBase)
                 parent = parent.parent;
-            return new Stack$1(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer2, base2, this.curContext, this.lookAhead, parent);
+            return new Stack$1(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
         }
         recoverByDelete(next2, nextEnd) {
             let isNode = next2 <= this.p.parser.maxNode;
             if (isNode)
                 this.storeNode(next2, this.pos, nextEnd, 4);
             this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
             this.pos = this.reducePos = nextEnd;
@@ -335163,2310 +336012,9751 @@
                     if (i2 == norm.length - 1) {
                         if (match2) {
                             this.value = match2;
                             return this;
                         }
                         break;
                     }
-                    if (pos == start2 && i2 < str.length && str.charCodeAt(i2) == code2)
-                        pos++;
+                    if (pos == start2 && i2 < str.length && str.charCodeAt(i2) == code2)
+                        pos++;
+                }
+            }
+        }
+        match(code2, pos, end2) {
+            let match2 = null;
+            for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
+                let index2 = this.matches[i2],
+                    keep = false;
+                if (this.query.charCodeAt(index2) == code2) {
+                    if (index2 == this.query.length - 1) {
+                        match2 = {
+                            from: this.matches[i2 + 1],
+                            to: end2
+                        };
+                    } else {
+                        this.matches[i2]++;
+                        keep = true;
+                    }
+                }
+                if (!keep) {
+                    this.matches.splice(i2, 2);
+                    i2 -= 2;
+                }
+            }
+            if (this.query.charCodeAt(0) == code2) {
+                if (this.query.length == 1)
+                    match2 = {
+                        from: pos,
+                        to: end2
+                    };
+                else
+                    this.matches.push(1, pos);
+            }
+            if (match2 && this.test && !this.test(match2.from, match2.to, this.buffer, this.bufferStart))
+                match2 = null;
+            return match2;
+        }
+    }
+    if (typeof Symbol != "undefined")
+        SearchCursor.prototype[Symbol.iterator] = function() {
+            return this;
+        };
+    const empty$1 = {
+        from: -1,
+        to: -1,
+        match: /* @__PURE__ */ /.*/.exec("")
+    };
+    const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
+    class RegExpCursor {
+        constructor(text2, query, options, from = 0, to2 = text2.length) {
+            this.text = text2;
+            this.to = to2;
+            this.curLine = "";
+            this.done = false;
+            this.value = empty$1;
+            if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
+                return new MultilineRegExpCursor(text2, query, options, from, to2);
+            this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
+            this.test = options === null || options === void 0 ? void 0 : options.test;
+            this.iter = text2.iter();
+            let startLine = text2.lineAt(from);
+            this.curLineStart = startLine.from;
+            this.matchPos = toCharEnd(text2, from);
+            this.getLine(this.curLineStart);
+        }
+        getLine(skip) {
+            this.iter.next(skip);
+            if (this.iter.lineBreak) {
+                this.curLine = "";
+            } else {
+                this.curLine = this.iter.value;
+                if (this.curLineStart + this.curLine.length > this.to)
+                    this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
+                this.iter.next();
+            }
+        }
+        nextLine() {
+            this.curLineStart = this.curLineStart + this.curLine.length + 1;
+            if (this.curLineStart > this.to)
+                this.curLine = "";
+            else
+                this.getLine(0);
+        }
+        next() {
+            for (let off = this.matchPos - this.curLineStart;;) {
+                this.re.lastIndex = off;
+                let match2 = this.matchPos <= this.to && this.re.exec(this.curLine);
+                if (match2) {
+                    let from = this.curLineStart + match2.index,
+                        to2 = from + match2[0].length;
+                    this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
+                    if (from == this.curLineStart + this.curLine.length)
+                        this.nextLine();
+                    if ((from < to2 || from > this.value.to) && (!this.test || this.test(from, to2, match2))) {
+                        this.value = {
+                            from,
+                            to: to2,
+                            match: match2
+                        };
+                        return this;
+                    }
+                    off = this.matchPos - this.curLineStart;
+                } else if (this.curLineStart + this.curLine.length < this.to) {
+                    this.nextLine();
+                    off = 0;
+                } else {
+                    this.done = true;
+                    return this;
+                }
+            }
+        }
+    }
+    const flattened = /* @__PURE__ */ new WeakMap();
+    class FlattenedDoc {
+        constructor(from, text2) {
+            this.from = from;
+            this.text = text2;
+        }
+        get to() {
+            return this.from + this.text.length;
+        }
+        static get(doc2, from, to2) {
+            let cached = flattened.get(doc2);
+            if (!cached || cached.from >= to2 || cached.to <= from) {
+                let flat = new FlattenedDoc(from, doc2.sliceString(from, to2));
+                flattened.set(doc2, flat);
+                return flat;
+            }
+            if (cached.from == from && cached.to == to2)
+                return cached;
+            let {
+                text: text2,
+                from: cachedFrom
+            } = cached;
+            if (cachedFrom > from) {
+                text2 = doc2.sliceString(from, cachedFrom) + text2;
+                cachedFrom = from;
+            }
+            if (cached.to < to2)
+                text2 += doc2.sliceString(cached.to, to2);
+            flattened.set(doc2, new FlattenedDoc(cachedFrom, text2));
+            return new FlattenedDoc(from, text2.slice(from - cachedFrom, to2 - cachedFrom));
+        }
+    }
+    class MultilineRegExpCursor {
+        constructor(text2, query, options, from, to2) {
+            this.text = text2;
+            this.to = to2;
+            this.done = false;
+            this.value = empty$1;
+            this.matchPos = toCharEnd(text2, from);
+            this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
+            this.test = options === null || options === void 0 ? void 0 : options.test;
+            this.flat = FlattenedDoc.get(text2, from, this.chunkEnd(from + 5e3));
+        }
+        chunkEnd(pos) {
+            return pos >= this.to ? this.to : this.text.lineAt(pos).to;
+        }
+        next() {
+            for (;;) {
+                let off = this.re.lastIndex = this.matchPos - this.flat.from;
+                let match2 = this.re.exec(this.flat.text);
+                if (match2 && !match2[0] && match2.index == off) {
+                    this.re.lastIndex = off + 1;
+                    match2 = this.re.exec(this.flat.text);
+                }
+                if (match2) {
+                    let from = this.flat.from + match2.index,
+                        to2 = from + match2[0].length;
+                    if ((this.flat.to >= this.to || match2.index + match2[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to2, match2))) {
+                        this.value = {
+                            from,
+                            to: to2,
+                            match: match2
+                        };
+                        this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
+                        return this;
+                    }
+                }
+                if (this.flat.to == this.to) {
+                    this.done = true;
+                    return this;
+                }
+                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
+            }
+        }
+    }
+    if (typeof Symbol != "undefined") {
+        RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
+            return this;
+        };
+    }
+
+    function validRegExp(source) {
+        try {
+            new RegExp(source, baseFlags);
+            return true;
+        } catch (_a3) {
+            return false;
+        }
+    }
+
+    function toCharEnd(text2, pos) {
+        if (pos >= text2.length)
+            return pos;
+        let line = text2.lineAt(pos),
+            next2;
+        while (pos < line.to && (next2 = line.text.charCodeAt(pos - line.from)) >= 56320 && next2 < 57344)
+            pos++;
+        return pos;
+    }
+
+    function createLineDialog(view) {
+        let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
+        let input = crelt("input", {
+            class: "cm-textfield",
+            name: "line",
+            value: line
+        });
+        let dom2 = crelt("form", {
+            class: "cm-gotoLine",
+            onkeydown: (event2) => {
+                if (event2.keyCode == 27) {
+                    event2.preventDefault();
+                    view.dispatch({
+                        effects: dialogEffect.of(false)
+                    });
+                    view.focus();
+                } else if (event2.keyCode == 13) {
+                    event2.preventDefault();
+                    go2();
+                }
+            },
+            onsubmit: (event2) => {
+                event2.preventDefault();
+                go2();
+            }
+        }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
+            class: "cm-button",
+            type: "submit"
+        }, view.state.phrase("go")));
+
+        function go2() {
+            let match2 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
+            if (!match2)
+                return;
+            let {
+                state
+            } = view, startLine = state.doc.lineAt(state.selection.main.head);
+            let [, sign2, ln, cl, percent] = match2;
+            let col = cl ? +cl.slice(1) : 0;
+            let line2 = ln ? +ln : startLine.number;
+            if (ln && percent) {
+                let pc = line2 / 100;
+                if (sign2)
+                    pc = pc * (sign2 == "-" ? -1 : 1) + startLine.number / state.doc.lines;
+                line2 = Math.round(state.doc.lines * pc);
+            } else if (ln && sign2) {
+                line2 = line2 * (sign2 == "-" ? -1 : 1) + startLine.number;
+            }
+            let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
+            let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
+            view.dispatch({
+                effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, {
+                    y: "center"
+                })],
+                selection: selection2
+            });
+            view.focus();
+        }
+        return {
+            dom: dom2
+        };
+    }
+    const dialogEffect = /* @__PURE__ */ StateEffect.define();
+    const dialogField = /* @__PURE__ */ StateField.define({
+        create() {
+            return true;
+        },
+        update(value, tr2) {
+            for (let e3 of tr2.effects)
+                if (e3.is(dialogEffect))
+                    value = e3.value;
+            return value;
+        },
+        provide: (f2) => showPanel.from(f2, (val) => val ? createLineDialog : null)
+    });
+    const gotoLine = (view) => {
+        let panel = getPanel(view, createLineDialog);
+        if (!panel) {
+            let effects = [dialogEffect.of(true)];
+            if (view.state.field(dialogField, false) == null)
+                effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
+            view.dispatch({
+                effects
+            });
+            panel = getPanel(view, createLineDialog);
+        }
+        if (panel)
+            panel.dom.querySelector("input").select();
+        return true;
+    };
+    const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
+        ".cm-panel.cm-gotoLine": {
+            padding: "2px 6px 4px",
+            "& label": {
+                fontSize: "80%"
+            }
+        }
+    });
+    const selectWord = ({
+        state,
+        dispatch: dispatch2
+    }) => {
+        let {
+            selection: selection2
+        } = state;
+        let newSel = EditorSelection.create(selection2.ranges.map((range2) => state.wordAt(range2.head) || EditorSelection.cursor(range2.head)), selection2.mainIndex);
+        if (newSel.eq(selection2))
+            return false;
+        dispatch2(state.update({
+            selection: newSel
+        }));
+        return true;
+    };
+
+    function findNextOccurrence(state, query) {
+        let {
+            main: main2,
+            ranges
+        } = state.selection;
+        let word = state.wordAt(main2.head),
+            fullWord = word && word.from == main2.from && word.to == main2.to;
+        for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
+            cursor.next();
+            if (cursor.done) {
+                if (cycled)
+                    return null;
+                cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
+                cycled = true;
+            } else {
+                if (cycled && ranges.some((r2) => r2.from == cursor.value.from))
+                    continue;
+                if (fullWord) {
+                    let word2 = state.wordAt(cursor.value.from);
+                    if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
+                        continue;
+                }
+                return cursor.value;
+            }
+        }
+    }
+    const selectNextOccurrence = ({
+        state,
+        dispatch: dispatch2
+    }) => {
+        let {
+            ranges
+        } = state.selection;
+        if (ranges.some((sel) => sel.from === sel.to))
+            return selectWord({
+                state,
+                dispatch: dispatch2
+            });
+        let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
+        if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
+            return false;
+        let range2 = findNextOccurrence(state, searchedText);
+        if (!range2)
+            return false;
+        dispatch2(state.update({
+            selection: state.selection.addRange(EditorSelection.range(range2.from, range2.to), false),
+            effects: EditorView.scrollIntoView(range2.to)
+        }));
+        return true;
+    };
+    const searchConfigFacet = /* @__PURE__ */ Facet.define({
+        combine(configs) {
+            return combineConfig(configs, {
+                top: false,
+                caseSensitive: false,
+                literal: false,
+                regexp: false,
+                wholeWord: false,
+                createPanel: (view) => new SearchPanel(view),
+                scrollToMatch: (range2) => EditorView.scrollIntoView(range2)
+            });
+        }
+    });
+    class SearchQuery {
+        constructor(config2) {
+            this.search = config2.search;
+            this.caseSensitive = !!config2.caseSensitive;
+            this.literal = !!config2.literal;
+            this.regexp = !!config2.regexp;
+            this.replace = config2.replace || "";
+            this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
+            this.unquoted = this.unquote(this.search);
+            this.wholeWord = !!config2.wholeWord;
+        }
+        unquote(text2) {
+            return this.literal ? text2 : text2.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
+        }
+        eq(other) {
+            return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
+        }
+        create() {
+            return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
+        }
+        getCursor(state, from = 0, to2) {
+            let st2 = state.doc ? state : EditorState.create({
+                doc: state
+            });
+            if (to2 == null)
+                to2 = st2.doc.length;
+            return this.regexp ? regexpCursor(this, st2, from, to2) : stringCursor(this, st2, from, to2);
+        }
+    }
+    class QueryType {
+        constructor(spec) {
+            this.spec = spec;
+        }
+    }
+
+    function stringCursor(spec, state, from, to2) {
+        return new SearchCursor(state.doc, spec.unquoted, from, to2, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
+    }
+
+    function stringWordTest(doc2, categorizer) {
+        return (from, to2, buf, bufPos) => {
+            if (bufPos > from || bufPos + buf.length < to2) {
+                bufPos = Math.max(0, from - 2);
+                buf = doc2.sliceString(bufPos, Math.min(doc2.length, to2 + 2));
+            }
+            return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to2 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to2 - bufPos)) != CharCategory.Word);
+        };
+    }
+    class StringQuery extends QueryType {
+        constructor(spec) {
+            super(spec);
+        }
+        nextMatch(state, curFrom, curTo) {
+            let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
+            if (cursor.done)
+                cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
+            return cursor.done ? null : cursor.value;
+        }
+        prevMatchInRange(state, from, to2) {
+            for (let pos = to2;;) {
+                let start2 = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
+                let cursor = stringCursor(this.spec, state, start2, pos),
+                    range2 = null;
+                while (!cursor.nextOverlapping().done)
+                    range2 = cursor.value;
+                if (range2)
+                    return range2;
+                if (start2 == from)
+                    return null;
+                pos -= 1e4;
+            }
+        }
+        prevMatch(state, curFrom, curTo) {
+            return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
+        }
+        getReplacement(_result) {
+            return this.spec.unquote(this.spec.replace);
+        }
+        matchAll(state, limit) {
+            let cursor = stringCursor(this.spec, state, 0, state.doc.length),
+                ranges = [];
+            while (!cursor.next().done) {
+                if (ranges.length >= limit)
+                    return null;
+                ranges.push(cursor.value);
+            }
+            return ranges;
+        }
+        highlight(state, from, to2, add2) {
+            let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, state.doc.length));
+            while (!cursor.next().done)
+                add2(cursor.value.from, cursor.value.to);
+        }
+    }
+
+    function regexpCursor(spec, state, from, to2) {
+        return new RegExpCursor(state.doc, spec.search, {
+            ignoreCase: !spec.caseSensitive,
+            test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
+        }, from, to2);
+    }
+
+    function charBefore(str, index2) {
+        return str.slice(findClusterBreak(str, index2, false), index2);
+    }
+
+    function charAfter(str, index2) {
+        return str.slice(index2, findClusterBreak(str, index2));
+    }
+
+    function regexpWordTest(categorizer) {
+        return (_from, _to, match2) => !match2[0].length || (categorizer(charBefore(match2.input, match2.index)) != CharCategory.Word || categorizer(charAfter(match2.input, match2.index)) != CharCategory.Word) && (categorizer(charAfter(match2.input, match2.index + match2[0].length)) != CharCategory.Word || categorizer(charBefore(match2.input, match2.index + match2[0].length)) != CharCategory.Word);
+    }
+    class RegExpQuery extends QueryType {
+        nextMatch(state, curFrom, curTo) {
+            let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
+            if (cursor.done)
+                cursor = regexpCursor(this.spec, state, 0, curFrom).next();
+            return cursor.done ? null : cursor.value;
+        }
+        prevMatchInRange(state, from, to2) {
+            for (let size2 = 1;; size2++) {
+                let start2 = Math.max(from, to2 - size2 * 1e4);
+                let cursor = regexpCursor(this.spec, state, start2, to2),
+                    range2 = null;
+                while (!cursor.next().done)
+                    range2 = cursor.value;
+                if (range2 && (start2 == from || range2.from > start2 + 10))
+                    return range2;
+                if (start2 == from)
+                    return null;
+            }
+        }
+        prevMatch(state, curFrom, curTo) {
+            return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
+        }
+        getReplacement(result) {
+            return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m2, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m2);
+        }
+        matchAll(state, limit) {
+            let cursor = regexpCursor(this.spec, state, 0, state.doc.length),
+                ranges = [];
+            while (!cursor.next().done) {
+                if (ranges.length >= limit)
+                    return null;
+                ranges.push(cursor.value);
+            }
+            return ranges;
+        }
+        highlight(state, from, to2, add2) {
+            let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to2 + 250, state.doc.length));
+            while (!cursor.next().done)
+                add2(cursor.value.from, cursor.value.to);
+        }
+    }
+    const setSearchQuery = /* @__PURE__ */ StateEffect.define();
+    const togglePanel = /* @__PURE__ */ StateEffect.define();
+    const searchState = /* @__PURE__ */ StateField.define({
+        create(state) {
+            return new SearchState(defaultQuery(state).create(), null);
+        },
+        update(value, tr2) {
+            for (let effect2 of tr2.effects) {
+                if (effect2.is(setSearchQuery))
+                    value = new SearchState(effect2.value.create(), value.panel);
+                else if (effect2.is(togglePanel))
+                    value = new SearchState(value.query, effect2.value ? createSearchPanel : null);
+            }
+            return value;
+        },
+        provide: (f2) => showPanel.from(f2, (val) => val.panel)
+    });
+    class SearchState {
+        constructor(query, panel) {
+            this.query = query;
+            this.panel = panel;
+        }
+    }
+    const matchMark = /* @__PURE__ */ Decoration.mark({
+            class: "cm-searchMatch"
+        }),
+        selectedMatchMark = /* @__PURE__ */ Decoration.mark({
+            class: "cm-searchMatch cm-searchMatch-selected"
+        });
+    const searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
+        constructor(view) {
+            this.view = view;
+            this.decorations = this.highlight(view.state.field(searchState));
+        }
+        update(update2) {
+            let state = update2.state.field(searchState);
+            if (state != update2.startState.field(searchState) || update2.docChanged || update2.selectionSet || update2.viewportChanged)
+                this.decorations = this.highlight(state);
+        }
+        highlight({
+            query,
+            panel
+        }) {
+            if (!panel || !query.spec.valid)
+                return Decoration.none;
+            let {
+                view
+            } = this;
+            let builder = new RangeSetBuilder();
+            for (let i2 = 0, ranges = view.visibleRanges, l2 = ranges.length; i2 < l2; i2++) {
+                let {
+                    from,
+                    to: to2
+                } = ranges[i2];
+                while (i2 < l2 - 1 && to2 > ranges[i2 + 1].from - 2 * 250)
+                    to2 = ranges[++i2].to;
+                query.highlight(view.state, from, to2, (from2, to3) => {
+                    let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to3);
+                    builder.add(from2, to3, selected ? selectedMatchMark : matchMark);
+                });
+            }
+            return builder.finish();
+        }
+    }, {
+        decorations: (v2) => v2.decorations
+    });
+
+    function searchCommand(f2) {
+        return (view) => {
+            let state = view.state.field(searchState, false);
+            return state && state.query.spec.valid ? f2(view, state) : openSearchPanel(view);
+        };
+    }
+    const findNext = /* @__PURE__ */ searchCommand((view, {
+        query
+    }) => {
+        let {
+            to: to2
+        } = view.state.selection.main;
+        let next2 = query.nextMatch(view.state, to2, to2);
+        if (!next2)
+            return false;
+        let selection2 = EditorSelection.single(next2.from, next2.to);
+        let config2 = view.state.facet(searchConfigFacet);
+        view.dispatch({
+            selection: selection2,
+            effects: [announceMatch(view, next2), config2.scrollToMatch(selection2.main, view)],
+            userEvent: "select.search"
+        });
+        selectSearchInput(view);
+        return true;
+    });
+    const findPrevious = /* @__PURE__ */ searchCommand((view, {
+        query
+    }) => {
+        let {
+            state
+        } = view, {
+            from
+        } = state.selection.main;
+        let prev = query.prevMatch(state, from, from);
+        if (!prev)
+            return false;
+        let selection2 = EditorSelection.single(prev.from, prev.to);
+        let config2 = view.state.facet(searchConfigFacet);
+        view.dispatch({
+            selection: selection2,
+            effects: [announceMatch(view, prev), config2.scrollToMatch(selection2.main, view)],
+            userEvent: "select.search"
+        });
+        selectSearchInput(view);
+        return true;
+    });
+    const selectMatches = /* @__PURE__ */ searchCommand((view, {
+        query
+    }) => {
+        let ranges = query.matchAll(view.state, 1e3);
+        if (!ranges || !ranges.length)
+            return false;
+        view.dispatch({
+            selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
+            userEvent: "select.search.matches"
+        });
+        return true;
+    });
+    const selectSelectionMatches = ({
+        state,
+        dispatch: dispatch2
+    }) => {
+        let sel = state.selection;
+        if (sel.ranges.length > 1 || sel.main.empty)
+            return false;
+        let {
+            from,
+            to: to2
+        } = sel.main;
+        let ranges = [],
+            main2 = 0;
+        for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to2)); !cur.next().done;) {
+            if (ranges.length > 1e3)
+                return false;
+            if (cur.value.from == from)
+                main2 = ranges.length;
+            ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
+        }
+        dispatch2(state.update({
+            selection: EditorSelection.create(ranges, main2),
+            userEvent: "select.search.matches"
+        }));
+        return true;
+    };
+    const replaceNext = /* @__PURE__ */ searchCommand((view, {
+        query
+    }) => {
+        let {
+            state
+        } = view, {
+            from,
+            to: to2
+        } = state.selection.main;
+        if (state.readOnly)
+            return false;
+        let next2 = query.nextMatch(state, from, from);
+        if (!next2)
+            return false;
+        let changes = [],
+            selection2, replacement;
+        let effects = [];
+        if (next2.from == from && next2.to == to2) {
+            replacement = state.toText(query.getReplacement(next2));
+            changes.push({
+                from: next2.from,
+                to: next2.to,
+                insert: replacement
+            });
+            next2 = query.nextMatch(state, next2.from, next2.to);
+            effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
+        }
+        if (next2) {
+            let off = changes.length == 0 || changes[0].from >= next2.to ? 0 : next2.to - next2.from - replacement.length;
+            selection2 = EditorSelection.single(next2.from - off, next2.to - off);
+            effects.push(announceMatch(view, next2));
+            effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
+        }
+        view.dispatch({
+            changes,
+            selection: selection2,
+            effects,
+            userEvent: "input.replace"
+        });
+        return true;
+    });
+    const replaceAll$1 = /* @__PURE__ */ searchCommand((view, {
+        query
+    }) => {
+        if (view.state.readOnly)
+            return false;
+        let changes = query.matchAll(view.state, 1e9).map((match2) => {
+            let {
+                from,
+                to: to2
+            } = match2;
+            return {
+                from,
+                to: to2,
+                insert: query.getReplacement(match2)
+            };
+        });
+        if (!changes.length)
+            return false;
+        let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
+        view.dispatch({
+            changes,
+            effects: EditorView.announce.of(announceText),
+            userEvent: "input.replace.all"
+        });
+        return true;
+    });
+
+    function createSearchPanel(view) {
+        return view.state.facet(searchConfigFacet).createPanel(view);
+    }
+
+    function defaultQuery(state, fallback) {
+        var _a3, _b, _c, _d, _e2;
+        let sel = state.selection.main;
+        let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
+        if (fallback && !selText)
+            return fallback;
+        let config2 = state.facet(searchConfigFacet);
+        return new SearchQuery({
+            search: ((_a3 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a3 !== void 0 ? _a3 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
+            caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
+            literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
+            regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
+            wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config2.wholeWord
+        });
+    }
+
+    function getSearchInput(view) {
+        let panel = getPanel(view, createSearchPanel);
+        return panel && panel.dom.querySelector("[main-field]");
+    }
+
+    function selectSearchInput(view) {
+        let input = getSearchInput(view);
+        if (input && input == view.root.activeElement)
+            input.select();
+    }
+    const openSearchPanel = (view) => {
+        let state = view.state.field(searchState, false);
+        if (state && state.panel) {
+            let searchInput = getSearchInput(view);
+            if (searchInput && searchInput != view.root.activeElement) {
+                let query = defaultQuery(view.state, state.query.spec);
+                if (query.valid)
+                    view.dispatch({
+                        effects: setSearchQuery.of(query)
+                    });
+                searchInput.focus();
+                searchInput.select();
+            }
+        } else {
+            view.dispatch({
+                effects: [
+                    togglePanel.of(true),
+                    state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
+                ]
+            });
+        }
+        return true;
+    };
+    const closeSearchPanel = (view) => {
+        let state = view.state.field(searchState, false);
+        if (!state || !state.panel)
+            return false;
+        let panel = getPanel(view, createSearchPanel);
+        if (panel && panel.dom.contains(view.root.activeElement))
+            view.focus();
+        view.dispatch({
+            effects: togglePanel.of(false)
+        });
+        return true;
+    };
+    const searchKeymap = [{
+        key: "Mod-f",
+        run: openSearchPanel,
+        scope: "editor search-panel"
+    }, {
+        key: "F3",
+        run: findNext,
+        shift: findPrevious,
+        scope: "editor search-panel",
+        preventDefault: true
+    }, {
+        key: "Mod-g",
+        run: findNext,
+        shift: findPrevious,
+        scope: "editor search-panel",
+        preventDefault: true
+    }, {
+        key: "Escape",
+        run: closeSearchPanel,
+        scope: "editor search-panel"
+    }, {
+        key: "Mod-Shift-l",
+        run: selectSelectionMatches
+    }, {
+        key: "Mod-Alt-g",
+        run: gotoLine
+    }, {
+        key: "Mod-d",
+        run: selectNextOccurrence,
+        preventDefault: true
+    }];
+    class SearchPanel {
+        constructor(view) {
+            this.view = view;
+            let query = this.query = view.state.field(searchState).query.spec;
+            this.commit = this.commit.bind(this);
+            this.searchField = crelt("input", {
+                value: query.search,
+                placeholder: phrase(view, "Find"),
+                "aria-label": phrase(view, "Find"),
+                class: "cm-textfield",
+                name: "search",
+                form: "",
+                "main-field": "true",
+                onchange: this.commit,
+                onkeyup: this.commit
+            });
+            this.replaceField = crelt("input", {
+                value: query.replace,
+                placeholder: phrase(view, "Replace"),
+                "aria-label": phrase(view, "Replace"),
+                class: "cm-textfield",
+                name: "replace",
+                form: "",
+                onchange: this.commit,
+                onkeyup: this.commit
+            });
+            this.caseField = crelt("input", {
+                type: "checkbox",
+                name: "case",
+                form: "",
+                checked: query.caseSensitive,
+                onchange: this.commit
+            });
+            this.reField = crelt("input", {
+                type: "checkbox",
+                name: "re",
+                form: "",
+                checked: query.regexp,
+                onchange: this.commit
+            });
+            this.wordField = crelt("input", {
+                type: "checkbox",
+                name: "word",
+                form: "",
+                checked: query.wholeWord,
+                onchange: this.commit
+            });
+
+            function button(name2, onclick, content2) {
+                return crelt("button", {
+                    class: "cm-button",
+                    name: name2,
+                    onclick,
+                    type: "button"
+                }, content2);
+            }
+            this.dom = crelt("div", {
+                onkeydown: (e3) => this.keydown(e3),
+                class: "cm-search"
+            }, [
+                this.searchField,
+                button("next", () => findNext(view), [phrase(view, "next")]),
+                button("prev", () => findPrevious(view), [phrase(view, "previous")]),
+                button("select", () => selectMatches(view), [phrase(view, "all")]),
+                crelt("label", null, [this.caseField, phrase(view, "match case")]),
+                crelt("label", null, [this.reField, phrase(view, "regexp")]),
+                crelt("label", null, [this.wordField, phrase(view, "by word")]),
+                ...view.state.readOnly ? [] : [
+                    crelt("br"),
+                    this.replaceField,
+                    button("replace", () => replaceNext(view), [phrase(view, "replace")]),
+                    button("replaceAll", () => replaceAll$1(view), [phrase(view, "replace all")])
+                ],
+                crelt("button", {
+                    name: "close",
+                    onclick: () => closeSearchPanel(view),
+                    "aria-label": phrase(view, "close"),
+                    type: "button"
+                }, ["\xD7"])
+            ]);
+        }
+        commit() {
+            let query = new SearchQuery({
+                search: this.searchField.value,
+                caseSensitive: this.caseField.checked,
+                regexp: this.reField.checked,
+                wholeWord: this.wordField.checked,
+                replace: this.replaceField.value
+            });
+            if (!query.eq(this.query)) {
+                this.query = query;
+                this.view.dispatch({
+                    effects: setSearchQuery.of(query)
+                });
+            }
+        }
+        keydown(e3) {
+            if (runScopeHandlers(this.view, e3, "search-panel")) {
+                e3.preventDefault();
+            } else if (e3.keyCode == 13 && e3.target == this.searchField) {
+                e3.preventDefault();
+                (e3.shiftKey ? findPrevious : findNext)(this.view);
+            } else if (e3.keyCode == 13 && e3.target == this.replaceField) {
+                e3.preventDefault();
+                replaceNext(this.view);
+            }
+        }
+        update(update2) {
+            for (let tr2 of update2.transactions)
+                for (let effect2 of tr2.effects) {
+                    if (effect2.is(setSearchQuery) && !effect2.value.eq(this.query))
+                        this.setQuery(effect2.value);
+                }
+        }
+        setQuery(query) {
+            this.query = query;
+            this.searchField.value = query.search;
+            this.replaceField.value = query.replace;
+            this.caseField.checked = query.caseSensitive;
+            this.reField.checked = query.regexp;
+            this.wordField.checked = query.wholeWord;
+        }
+        mount() {
+            this.searchField.select();
+        }
+        get pos() {
+            return 80;
+        }
+        get top() {
+            return this.view.state.facet(searchConfigFacet).top;
+        }
+    }
+
+    function phrase(view, phrase2) {
+        return view.state.phrase(phrase2);
+    }
+    const AnnounceMargin = 30;
+    const Break = /[\s\.,:;?!]/;
+
+    function announceMatch(view, {
+        from,
+        to: to2
+    }) {
+        let line = view.state.doc.lineAt(from),
+            lineEnd = view.state.doc.lineAt(to2).to;
+        let start2 = Math.max(line.from, from - AnnounceMargin),
+            end2 = Math.min(lineEnd, to2 + AnnounceMargin);
+        let text2 = view.state.sliceDoc(start2, end2);
+        if (start2 != line.from) {
+            for (let i2 = 0; i2 < AnnounceMargin; i2++)
+                if (!Break.test(text2[i2 + 1]) && Break.test(text2[i2])) {
+                    text2 = text2.slice(i2);
+                    break;
+                }
+        }
+        if (end2 != lineEnd) {
+            for (let i2 = text2.length - 1; i2 > text2.length - AnnounceMargin; i2--)
+                if (!Break.test(text2[i2 - 1]) && Break.test(text2[i2])) {
+                    text2 = text2.slice(0, i2);
+                    break;
+                }
+        }
+        return EditorView.announce.of(`${view.state.phrase("current match")}. ${text2} ${view.state.phrase("on line")} ${line.number}.`);
+    }
+    const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
+        ".cm-panel.cm-search": {
+            padding: "2px 6px 4px",
+            position: "relative",
+            "& [name=close]": {
+                position: "absolute",
+                top: "0",
+                right: "4px",
+                backgroundColor: "inherit",
+                border: "none",
+                font: "inherit",
+                padding: 0,
+                margin: 0
+            },
+            "& input, & button, & label": {
+                margin: ".2em .6em .2em 0"
+            },
+            "& input[type=checkbox]": {
+                marginRight: ".2em"
+            },
+            "& label": {
+                fontSize: "80%",
+                whiteSpace: "pre"
+            }
+        },
+        "&light .cm-searchMatch": {
+            backgroundColor: "#ffff0054"
+        },
+        "&dark .cm-searchMatch": {
+            backgroundColor: "#00ffff8a"
+        },
+        "&light .cm-searchMatch-selected": {
+            backgroundColor: "#ff6a0054"
+        },
+        "&dark .cm-searchMatch-selected": {
+            backgroundColor: "#ff00ff8a"
+        }
+    });
+    const searchExtensions = [
+        searchState,
+        /* @__PURE__ */
+        Prec.low(searchHighlighter),
+        baseTheme
+    ];
+    const EditorRoot = styled__default.default.div`
+    overflow-y: scroll;
+    display: flex;
+    flex: 1 1 auto;
+    flex-direction: column;
+
+    border: 1px solid ${(props) => props.theme.colors.grey3};
+    .cm-wrap {
+        flex: 1 1 auto;
+        color: ${(props) => props.theme.colors.text};
+    }
+    .cm-gutters {
+        color: ${(props) => props.theme.colors.grey4};
+        background-color: ${(props) => props.theme.colors.grey2};
+        border-right-color: ${(props) => props.theme.colors.grey3};
+    }
+`;
+
+    function CodeEditor$1({
+        initialScript,
+        disabled: disabled2,
+        onChange: onChange2,
+        style: style2,
+        className
+    }) {
+        const editorRef = React.useRef();
+        React.useEffect(() => {
+            if (editorRef.current) {
+                const dispatchChanges = StateField.define({
+                    create() {
+                        return true;
+                    },
+                    update(value, tr2) {
+                        if (onChange2) {
+                            onChange2(tr2.state.doc.toString());
+                        }
+                        return true;
+                    }
+                });
+                const startState = EditorState.create({
+                    doc: initialScript !== null && initialScript !== void 0 ? initialScript : "",
+                    extensions: [
+                        lineNumbers(),
+                        dispatchChanges,
+                        history(),
+                        python(),
+                        json(),
+                        bracketMatching(),
+                        closeBrackets(),
+                        syntaxHighlighting(defaultHighlightStyle),
+                        EditorState.tabSize.of(4),
+                        EditorView.editable.of(!disabled2),
+                        keymap.of([...defaultKeymap, ...searchKeymap, ...historyKeymap, indentWithTab])
+                    ]
+                });
+                const view = new EditorView({
+                    parent: editorRef.current,
+                    state: startState
+                });
+                return () => view.destroy();
+            }
+        }, []);
+        return jsxRuntime.exports.jsx(EditorRoot, {
+            className,
+            ref: editorRef,
+            style: style2
+        });
+    }
+    const StyledCodeEditor = core$2.injectCss(CodeEditor$1);
+
+    function CodeEditor(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [script, setScript] = core$2.useVariable(props.script);
+        return /* @__PURE__ */ React__default.default.createElement(StyledCodeEditor, {
+            $rawCss: css2,
+            initialScript: script,
+            onChange: setScript,
+            style: style2
+        });
+    }
+    const ChatWrapper = styled__default.default.div`
+    pointer-events: auto;
+
+    position: fixed;
+    z-index: 999;
+    right: 1rem;
+    bottom: -0.1rem;
+`;
+    const ChatButton = styled__default.default.button`
+    width: 3.5rem;
+    height: 3.5rem;
+    margin: 0 2rem 2rem 0;
+    padding-top: 0.5rem;
+
+    color: ${(props) => props.theme.colors.background};
+
+    background-color: ${(props) => props.theme.colors.primary};
+    border: none;
+    border-radius: 3rem;
+
+    :hover {
+        background-color: ${(props) => props.theme.colors.primaryHover};
+    }
+
+    :active {
+        background-color: ${(props) => props.theme.colors.primaryDown};
+    }
+`;
+    const StyledChat = core$2.injectCss(Chat$1);
+
+    function Chat(props) {
+        const [style2, css2] = core$2.useComponentStyles(props);
+        const [value, setValue] = core$2.useVariable(props.value);
+        const [showChat, setShowChat] = React__namespace.useState(false);
+        const theme2 = useClTheme$1();
+        return /* @__PURE__ */ React__namespace.createElement(ChatWrapper, null, showChat && /* @__PURE__ */ React__namespace.createElement(
+            StyledChat, {
+                $rawCss: css2,
+                className: props.className,
+                onClose: () => setShowChat(false),
+                onUpdate: setValue,
+                style: style2,
+                value
+            }
+        ), !showChat && /* @__PURE__ */ React__namespace.createElement(ChatButton, {
+            onClick: () => setShowChat(true)
+        }, /* @__PURE__ */ React__namespace.createElement("svg", {
+            fill: "none",
+            height: "32",
+            viewBox: "0 0 32 32",
+            width: "32",
+            xmlns: "http://www.w3.org/2000/svg"
+        }, /* @__PURE__ */ React__namespace.createElement("rect", {
+            fill: "none",
+            height: "24",
+            rx: "3",
+            width: "30",
+            x: "1",
+            y: "1.33594"
+        }), /* @__PURE__ */ React__namespace.createElement(
+            "rect", {
+                height: "24",
+                rx: "3",
+                stroke: theme2.colors.background,
+                strokeWidth: "2",
+                width: "30",
+                x: "1",
+                y: "1.33594"
+            }
+        ), /* @__PURE__ */ React__namespace.createElement(
+            "path", {
+                d: "M8 8.33594H24",
+                stroke: theme2.colors.background,
+                strokeLinecap: "round",
+                strokeWidth: "2"
+            }
+        ), /* @__PURE__ */ React__namespace.createElement(
+            "path", {
+                d: "M8 13.3359H24",
+                stroke: theme2.colors.background,
+                strokeLinecap: "round",
+                strokeWidth: "2"
+            }
+        ), /* @__PURE__ */ React__namespace.createElement(
+            "path", {
+                d: "M8 18.3359H24",
+                stroke: theme2.colors.background,
+                strokeLinecap: "round",
+                strokeWidth: "2"
+            }
+        ), /* @__PURE__ */ React__namespace.createElement(
+            "path", {
+                d: "M18.5981 26.1641L16 30.6641L13.4019 26.1641L18.5981 26.1641Z",
+                fill: theme2.colors.background,
+                stroke: theme2.colors.background
+            }
+        ), /* @__PURE__ */ React__namespace.createElement("path", {
+            d: "M16 28.3359L13.4019 23.8359L18.5981 23.8359L16 28.3359Z",
+            fill: "none"
+        }))));
+    }
+
+    function noop$2() {}
+    var noop_1 = noop$2;
+    /*! *****************************************************************************
+        Copyright (c) Microsoft Corporation.
+  
+        Permission to use, copy, modify, and/or distribute this software for any
+        purpose with or without fee is hereby granted.
+  
+        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
+        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
+        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+        PERFORMANCE OF THIS SOFTWARE.
+        ***************************************************************************** */
+    var extendStatics = function(d2, b2) {
+        extendStatics = Object.setPrototypeOf || {
+            __proto__: []
+        }
+        instanceof Array && function(d3, b3) {
+            d3.__proto__ = b3;
+        } || function(d3, b3) {
+            for (var p2 in b3)
+                if (b3.hasOwnProperty(p2))
+                    d3[p2] = b3[p2];
+        };
+        return extendStatics(d2, b2);
+    };
+
+    function __extends(d2, b2) {
+        extendStatics(d2, b2);
+
+        function __() {
+            this.constructor = d2;
+        }
+        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
+    }
+
+    function isFunction(x2) {
+        return typeof x2 === "function";
+    }
+    var _enable_super_gross_mode_that_will_cause_bad_things = false;
+    var config = {
+        Promise: void 0,
+        set useDeprecatedSynchronousErrorHandling(value) {
+            if (value) {
+                var error2 = /* @__PURE__ */ new Error();
+                /* @__PURE__ */
+                console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error2.stack);
+            }
+            _enable_super_gross_mode_that_will_cause_bad_things = value;
+        },
+        get useDeprecatedSynchronousErrorHandling() {
+            return _enable_super_gross_mode_that_will_cause_bad_things;
+        }
+    };
+
+    function hostReportError(err) {
+        setTimeout(function() {
+            throw err;
+        }, 0);
+    }
+    var empty = {
+        closed: true,
+        next: function(value) {},
+        error: function(err) {
+            if (config.useDeprecatedSynchronousErrorHandling) {
+                throw err;
+            } else {
+                hostReportError(err);
+            }
+        },
+        complete: function() {}
+    };
+    var isArray$9 = /* @__PURE__ */ function() {
+        return Array.isArray || function(x2) {
+            return x2 && typeof x2.length === "number";
+        };
+    }();
+
+    function isObject$5(x2) {
+        return x2 !== null && typeof x2 === "object";
+    }
+    var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
+        function UnsubscriptionErrorImpl2(errors) {
+            Error.call(this);
+            this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
+                return i2 + 1 + ") " + err.toString();
+            }).join("\n  ") : "";
+            this.name = "UnsubscriptionError";
+            this.errors = errors;
+            return this;
+        }
+        UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
+        return UnsubscriptionErrorImpl2;
+    }();
+    var UnsubscriptionError = UnsubscriptionErrorImpl;
+    var Subscription = /* @__PURE__ */ function() {
+        function Subscription2(unsubscribe) {
+            this.closed = false;
+            this._parentOrParents = null;
+            this._subscriptions = null;
+            if (unsubscribe) {
+                this._unsubscribe = unsubscribe;
+            }
+        }
+        Subscription2.prototype.unsubscribe = function() {
+            var errors;
+            if (this.closed) {
+                return;
+            }
+            var _a3 = this,
+                _parentOrParents = _a3._parentOrParents,
+                _unsubscribe = _a3._unsubscribe,
+                _subscriptions = _a3._subscriptions;
+            this.closed = true;
+            this._parentOrParents = null;
+            this._subscriptions = null;
+            if (_parentOrParents instanceof Subscription2) {
+                _parentOrParents.remove(this);
+            } else if (_parentOrParents !== null) {
+                for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
+                    var parent_1 = _parentOrParents[index2];
+                    parent_1.remove(this);
+                }
+            }
+            if (isFunction(_unsubscribe)) {
+                try {
+                    _unsubscribe.call(this);
+                } catch (e3) {
+                    errors = e3 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e3.errors) : [e3];
+                }
+            }
+            if (isArray$9(_subscriptions)) {
+                var index2 = -1;
+                var len = _subscriptions.length;
+                while (++index2 < len) {
+                    var sub = _subscriptions[index2];
+                    if (isObject$5(sub)) {
+                        try {
+                            sub.unsubscribe();
+                        } catch (e3) {
+                            errors = errors || [];
+                            if (e3 instanceof UnsubscriptionError) {
+                                errors = errors.concat(flattenUnsubscriptionErrors(e3.errors));
+                            } else {
+                                errors.push(e3);
+                            }
+                        }
+                    }
+                }
+            }
+            if (errors) {
+                throw new UnsubscriptionError(errors);
+            }
+        };
+        Subscription2.prototype.add = function(teardown) {
+            var subscription = teardown;
+            if (!teardown) {
+                return Subscription2.EMPTY;
+            }
+            switch (typeof teardown) {
+                case "function":
+                    subscription = new Subscription2(teardown);
+                case "object":
+                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
+                        return subscription;
+                    } else if (this.closed) {
+                        subscription.unsubscribe();
+                        return subscription;
+                    } else if (!(subscription instanceof Subscription2)) {
+                        var tmp = subscription;
+                        subscription = new Subscription2();
+                        subscription._subscriptions = [tmp];
+                    }
+                    break;
+                default: {
+                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
+                }
+            }
+            var _parentOrParents = subscription._parentOrParents;
+            if (_parentOrParents === null) {
+                subscription._parentOrParents = this;
+            } else if (_parentOrParents instanceof Subscription2) {
+                if (_parentOrParents === this) {
+                    return subscription;
+                }
+                subscription._parentOrParents = [_parentOrParents, this];
+            } else if (_parentOrParents.indexOf(this) === -1) {
+                _parentOrParents.push(this);
+            } else {
+                return subscription;
+            }
+            var subscriptions = this._subscriptions;
+            if (subscriptions === null) {
+                this._subscriptions = [subscription];
+            } else {
+                subscriptions.push(subscription);
+            }
+            return subscription;
+        };
+        Subscription2.prototype.remove = function(subscription) {
+            var subscriptions = this._subscriptions;
+            if (subscriptions) {
+                var subscriptionIndex = subscriptions.indexOf(subscription);
+                if (subscriptionIndex !== -1) {
+                    subscriptions.splice(subscriptionIndex, 1);
+                }
+            }
+        };
+        Subscription2.EMPTY = function(empty2) {
+            empty2.closed = true;
+            return empty2;
+        }(new Subscription2());
+        return Subscription2;
+    }();
+
+    function flattenUnsubscriptionErrors(errors) {
+        return errors.reduce(function(errs, err) {
+            return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
+        }, []);
+    }
+    var rxSubscriber = /* @__PURE__ */ function() {
+        return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
+    }();
+    var Subscriber = /* @__PURE__ */ function(_super) {
+        __extends(Subscriber2, _super);
+
+        function Subscriber2(destinationOrNext, error2, complete) {
+            var _this = _super.call(this) || this;
+            _this.syncErrorValue = null;
+            _this.syncErrorThrown = false;
+            _this.syncErrorThrowable = false;
+            _this.isStopped = false;
+            switch (arguments.length) {
+                case 0:
+                    _this.destination = empty;
+                    break;
+                case 1:
+                    if (!destinationOrNext) {
+                        _this.destination = empty;
+                        break;
+                    }
+                    if (typeof destinationOrNext === "object") {
+                        if (destinationOrNext instanceof Subscriber2) {
+                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
+                            _this.destination = destinationOrNext;
+                            destinationOrNext.add(_this);
+                        } else {
+                            _this.syncErrorThrowable = true;
+                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
+                        }
+                        break;
+                    }
+                default:
+                    _this.syncErrorThrowable = true;
+                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error2, complete);
+                    break;
+            }
+            return _this;
+        }
+        Subscriber2.prototype[rxSubscriber] = function() {
+            return this;
+        };
+        Subscriber2.create = function(next2, error2, complete) {
+            var subscriber = new Subscriber2(next2, error2, complete);
+            subscriber.syncErrorThrowable = false;
+            return subscriber;
+        };
+        Subscriber2.prototype.next = function(value) {
+            if (!this.isStopped) {
+                this._next(value);
+            }
+        };
+        Subscriber2.prototype.error = function(err) {
+            if (!this.isStopped) {
+                this.isStopped = true;
+                this._error(err);
+            }
+        };
+        Subscriber2.prototype.complete = function() {
+            if (!this.isStopped) {
+                this.isStopped = true;
+                this._complete();
+            }
+        };
+        Subscriber2.prototype.unsubscribe = function() {
+            if (this.closed) {
+                return;
+            }
+            this.isStopped = true;
+            _super.prototype.unsubscribe.call(this);
+        };
+        Subscriber2.prototype._next = function(value) {
+            this.destination.next(value);
+        };
+        Subscriber2.prototype._error = function(err) {
+            this.destination.error(err);
+            this.unsubscribe();
+        };
+        Subscriber2.prototype._complete = function() {
+            this.destination.complete();
+            this.unsubscribe();
+        };
+        Subscriber2.prototype._unsubscribeAndRecycle = function() {
+            var _parentOrParents = this._parentOrParents;
+            this._parentOrParents = null;
+            this.unsubscribe();
+            this.closed = false;
+            this.isStopped = false;
+            this._parentOrParents = _parentOrParents;
+            return this;
+        };
+        return Subscriber2;
+    }(Subscription);
+    var SafeSubscriber = /* @__PURE__ */ function(_super) {
+        __extends(SafeSubscriber2, _super);
+
+        function SafeSubscriber2(_parentSubscriber, observerOrNext, error2, complete) {
+            var _this = _super.call(this) || this;
+            _this._parentSubscriber = _parentSubscriber;
+            var next2;
+            var context2 = _this;
+            if (isFunction(observerOrNext)) {
+                next2 = observerOrNext;
+            } else if (observerOrNext) {
+                next2 = observerOrNext.next;
+                error2 = observerOrNext.error;
+                complete = observerOrNext.complete;
+                if (observerOrNext !== empty) {
+                    context2 = Object.create(observerOrNext);
+                    if (isFunction(context2.unsubscribe)) {
+                        _this.add(context2.unsubscribe.bind(context2));
+                    }
+                    context2.unsubscribe = _this.unsubscribe.bind(_this);
+                }
+            }
+            _this._context = context2;
+            _this._next = next2;
+            _this._error = error2;
+            _this._complete = complete;
+            return _this;
+        }
+        SafeSubscriber2.prototype.next = function(value) {
+            if (!this.isStopped && this._next) {
+                var _parentSubscriber = this._parentSubscriber;
+                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
+                    this.__tryOrUnsub(this._next, value);
+                } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
+                    this.unsubscribe();
+                }
+            }
+        };
+        SafeSubscriber2.prototype.error = function(err) {
+            if (!this.isStopped) {
+                var _parentSubscriber = this._parentSubscriber;
+                var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
+                if (this._error) {
+                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
+                        this.__tryOrUnsub(this._error, err);
+                        this.unsubscribe();
+                    } else {
+                        this.__tryOrSetError(_parentSubscriber, this._error, err);
+                        this.unsubscribe();
+                    }
+                } else if (!_parentSubscriber.syncErrorThrowable) {
+                    this.unsubscribe();
+                    if (useDeprecatedSynchronousErrorHandling) {
+                        throw err;
+                    }
+                    hostReportError(err);
+                } else {
+                    if (useDeprecatedSynchronousErrorHandling) {
+                        _parentSubscriber.syncErrorValue = err;
+                        _parentSubscriber.syncErrorThrown = true;
+                    } else {
+                        hostReportError(err);
+                    }
+                    this.unsubscribe();
+                }
+            }
+        };
+        SafeSubscriber2.prototype.complete = function() {
+            var _this = this;
+            if (!this.isStopped) {
+                var _parentSubscriber = this._parentSubscriber;
+                if (this._complete) {
+                    var wrappedComplete = function() {
+                        return _this._complete.call(_this._context);
+                    };
+                    if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
+                        this.__tryOrUnsub(wrappedComplete);
+                        this.unsubscribe();
+                    } else {
+                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
+                        this.unsubscribe();
+                    }
+                } else {
+                    this.unsubscribe();
+                }
+            }
+        };
+        SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
+            try {
+                fn2.call(this._context, value);
+            } catch (err) {
+                this.unsubscribe();
+                if (config.useDeprecatedSynchronousErrorHandling) {
+                    throw err;
+                } else {
+                    hostReportError(err);
+                }
+            }
+        };
+        SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
+            if (!config.useDeprecatedSynchronousErrorHandling) {
+                throw new Error("bad call");
+            }
+            try {
+                fn2.call(this._context, value);
+            } catch (err) {
+                if (config.useDeprecatedSynchronousErrorHandling) {
+                    parent.syncErrorValue = err;
+                    parent.syncErrorThrown = true;
+                    return true;
+                } else {
+                    hostReportError(err);
+                    return true;
+                }
+            }
+            return false;
+        };
+        SafeSubscriber2.prototype._unsubscribe = function() {
+            var _parentSubscriber = this._parentSubscriber;
+            this._context = null;
+            this._parentSubscriber = null;
+            _parentSubscriber.unsubscribe();
+        };
+        return SafeSubscriber2;
+    }(Subscriber);
+
+    function canReportError(observer) {
+        while (observer) {
+            var _a3 = observer,
+                closed_1 = _a3.closed,
+                destination = _a3.destination,
+                isStopped = _a3.isStopped;
+            if (closed_1 || isStopped) {
+                return false;
+            } else if (destination && destination instanceof Subscriber) {
+                observer = destination;
+            } else {
+                observer = null;
+            }
+        }
+        return true;
+    }
+
+    function toSubscriber(nextOrObserver, error2, complete) {
+        if (nextOrObserver) {
+            if (nextOrObserver instanceof Subscriber) {
+                return nextOrObserver;
+            }
+            if (nextOrObserver[rxSubscriber]) {
+                return nextOrObserver[rxSubscriber]();
+            }
+        }
+        if (!nextOrObserver && !error2 && !complete) {
+            return new Subscriber(empty);
+        }
+        return new Subscriber(nextOrObserver, error2, complete);
+    }
+    var observable = /* @__PURE__ */ function() {
+        return typeof Symbol === "function" && Symbol.observable || "@@observable";
+    }();
+
+    function identity$1(x2) {
+        return x2;
+    }
+
+    function pipeFromArray(fns) {
+        if (fns.length === 0) {
+            return identity$1;
+        }
+        if (fns.length === 1) {
+            return fns[0];
+        }
+        return function piped(input) {
+            return fns.reduce(function(prev, fn2) {
+                return fn2(prev);
+            }, input);
+        };
+    }
+    var Observable = /* @__PURE__ */ function() {
+        function Observable2(subscribe) {
+            this._isScalar = false;
+            if (subscribe) {
+                this._subscribe = subscribe;
+            }
+        }
+        Observable2.prototype.lift = function(operator2) {
+            var observable2 = new Observable2();
+            observable2.source = this;
+            observable2.operator = operator2;
+            return observable2;
+        };
+        Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
+            var operator2 = this.operator;
+            var sink = toSubscriber(observerOrNext, error2, complete);
+            if (operator2) {
+                sink.add(operator2.call(sink, this.source));
+            } else {
+                sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
+            }
+            if (config.useDeprecatedSynchronousErrorHandling) {
+                if (sink.syncErrorThrowable) {
+                    sink.syncErrorThrowable = false;
+                    if (sink.syncErrorThrown) {
+                        throw sink.syncErrorValue;
+                    }
+                }
+            }
+            return sink;
+        };
+        Observable2.prototype._trySubscribe = function(sink) {
+            try {
+                return this._subscribe(sink);
+            } catch (err) {
+                if (config.useDeprecatedSynchronousErrorHandling) {
+                    sink.syncErrorThrown = true;
+                    sink.syncErrorValue = err;
+                }
+                if (canReportError(sink)) {
+                    sink.error(err);
+                } else {
+                    console.warn(err);
+                }
+            }
+        };
+        Observable2.prototype.forEach = function(next2, promiseCtor) {
+            var _this = this;
+            promiseCtor = getPromiseCtor(promiseCtor);
+            return new promiseCtor(function(resolve2, reject) {
+                var subscription;
+                subscription = _this.subscribe(function(value) {
+                    try {
+                        next2(value);
+                    } catch (err) {
+                        reject(err);
+                        if (subscription) {
+                            subscription.unsubscribe();
+                        }
+                    }
+                }, reject, resolve2);
+            });
+        };
+        Observable2.prototype._subscribe = function(subscriber) {
+            var source = this.source;
+            return source && source.subscribe(subscriber);
+        };
+        Observable2.prototype[observable] = function() {
+            return this;
+        };
+        Observable2.prototype.pipe = function() {
+            var operations = [];
+            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
+                operations[_i2] = arguments[_i2];
+            }
+            if (operations.length === 0) {
+                return this;
+            }
+            return pipeFromArray(operations)(this);
+        };
+        Observable2.prototype.toPromise = function(promiseCtor) {
+            var _this = this;
+            promiseCtor = getPromiseCtor(promiseCtor);
+            return new promiseCtor(function(resolve2, reject) {
+                var value;
+                _this.subscribe(function(x2) {
+                    return value = x2;
+                }, function(err) {
+                    return reject(err);
+                }, function() {
+                    return resolve2(value);
+                });
+            });
+        };
+        Observable2.create = function(subscribe) {
+            return new Observable2(subscribe);
+        };
+        return Observable2;
+    }();
+
+    function getPromiseCtor(promiseCtor) {
+        if (!promiseCtor) {
+            promiseCtor = config.Promise || Promise;
+        }
+        if (!promiseCtor) {
+            throw new Error("no Promise impl found");
+        }
+        return promiseCtor;
+    }
+    var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
+        function ObjectUnsubscribedErrorImpl2() {
+            Error.call(this);
+            this.message = "object unsubscribed";
+            this.name = "ObjectUnsubscribedError";
+            return this;
+        }
+        ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
+        return ObjectUnsubscribedErrorImpl2;
+    }();
+    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
+    var SubjectSubscription = /* @__PURE__ */ function(_super) {
+        __extends(SubjectSubscription2, _super);
+
+        function SubjectSubscription2(subject, subscriber) {
+            var _this = _super.call(this) || this;
+            _this.subject = subject;
+            _this.subscriber = subscriber;
+            _this.closed = false;
+            return _this;
+        }
+        SubjectSubscription2.prototype.unsubscribe = function() {
+            if (this.closed) {
+                return;
+            }
+            this.closed = true;
+            var subject = this.subject;
+            var observers2 = subject.observers;
+            this.subject = null;
+            if (!observers2 || observers2.length === 0 || subject.isStopped || subject.closed) {
+                return;
+            }
+            var subscriberIndex = observers2.indexOf(this.subscriber);
+            if (subscriberIndex !== -1) {
+                observers2.splice(subscriberIndex, 1);
+            }
+        };
+        return SubjectSubscription2;
+    }(Subscription);
+    var SubjectSubscriber = /* @__PURE__ */ function(_super) {
+        __extends(SubjectSubscriber2, _super);
+
+        function SubjectSubscriber2(destination) {
+            var _this = _super.call(this, destination) || this;
+            _this.destination = destination;
+            return _this;
+        }
+        return SubjectSubscriber2;
+    }(Subscriber);
+    var Subject = /* @__PURE__ */ function(_super) {
+        __extends(Subject2, _super);
+
+        function Subject2() {
+            var _this = _super.call(this) || this;
+            _this.observers = [];
+            _this.closed = false;
+            _this.isStopped = false;
+            _this.hasError = false;
+            _this.thrownError = null;
+            return _this;
+        }
+        Subject2.prototype[rxSubscriber] = function() {
+            return new SubjectSubscriber(this);
+        };
+        Subject2.prototype.lift = function(operator2) {
+            var subject = new AnonymousSubject(this, this);
+            subject.operator = operator2;
+            return subject;
+        };
+        Subject2.prototype.next = function(value) {
+            if (this.closed) {
+                throw new ObjectUnsubscribedError();
+            }
+            if (!this.isStopped) {
+                var observers2 = this.observers;
+                var len = observers2.length;
+                var copy2 = observers2.slice();
+                for (var i2 = 0; i2 < len; i2++) {
+                    copy2[i2].next(value);
+                }
+            }
+        };
+        Subject2.prototype.error = function(err) {
+            if (this.closed) {
+                throw new ObjectUnsubscribedError();
+            }
+            this.hasError = true;
+            this.thrownError = err;
+            this.isStopped = true;
+            var observers2 = this.observers;
+            var len = observers2.length;
+            var copy2 = observers2.slice();
+            for (var i2 = 0; i2 < len; i2++) {
+                copy2[i2].error(err);
+            }
+            this.observers.length = 0;
+        };
+        Subject2.prototype.complete = function() {
+            if (this.closed) {
+                throw new ObjectUnsubscribedError();
+            }
+            this.isStopped = true;
+            var observers2 = this.observers;
+            var len = observers2.length;
+            var copy2 = observers2.slice();
+            for (var i2 = 0; i2 < len; i2++) {
+                copy2[i2].complete();
+            }
+            this.observers.length = 0;
+        };
+        Subject2.prototype.unsubscribe = function() {
+            this.isStopped = true;
+            this.closed = true;
+            this.observers = null;
+        };
+        Subject2.prototype._trySubscribe = function(subscriber) {
+            if (this.closed) {
+                throw new ObjectUnsubscribedError();
+            } else {
+                return _super.prototype._trySubscribe.call(this, subscriber);
+            }
+        };
+        Subject2.prototype._subscribe = function(subscriber) {
+            if (this.closed) {
+                throw new ObjectUnsubscribedError();
+            } else if (this.hasError) {
+                subscriber.error(this.thrownError);
+                return Subscription.EMPTY;
+            } else if (this.isStopped) {
+                subscriber.complete();
+                return Subscription.EMPTY;
+            } else {
+                this.observers.push(subscriber);
+                return new SubjectSubscription(this, subscriber);
+            }
+        };
+        Subject2.prototype.asObservable = function() {
+            var observable2 = new Observable();
+            observable2.source = this;
+            return observable2;
+        };
+        Subject2.create = function(destination, source) {
+            return new AnonymousSubject(destination, source);
+        };
+        return Subject2;
+    }(Observable);
+    var AnonymousSubject = /* @__PURE__ */ function(_super) {
+        __extends(AnonymousSubject2, _super);
+
+        function AnonymousSubject2(destination, source) {
+            var _this = _super.call(this) || this;
+            _this.destination = destination;
+            _this.source = source;
+            return _this;
+        }
+        AnonymousSubject2.prototype.next = function(value) {
+            var destination = this.destination;
+            if (destination && destination.next) {
+                destination.next(value);
+            }
+        };
+        AnonymousSubject2.prototype.error = function(err) {
+            var destination = this.destination;
+            if (destination && destination.error) {
+                this.destination.error(err);
+            }
+        };
+        AnonymousSubject2.prototype.complete = function() {
+            var destination = this.destination;
+            if (destination && destination.complete) {
+                this.destination.complete();
+            }
+        };
+        AnonymousSubject2.prototype._subscribe = function(subscriber) {
+            var source = this.source;
+            if (source) {
+                return this.source.subscribe(subscriber);
+            } else {
+                return Subscription.EMPTY;
+            }
+        };
+        return AnonymousSubject2;
+    }(Subject);
+    var PolishedError = /* @__PURE__ */ function(_Error) {
+        _inheritsLoose$2(PolishedError2, _Error);
+
+        function PolishedError2(code2) {
+            var _this;
+            {
+                _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
+            }
+            return _assertThisInitialized$3(_this);
+        }
+        return PolishedError2;
+    }( /* @__PURE__ */ _wrapNativeSuper$1(Error));
+
+    function colorToInt(color2) {
+        return Math.round(color2 * 255);
+    }
+
+    function convertToInt(red, green, blue) {
+        return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
+    }
+
+    function hslToRgb(hue, saturation, lightness, convert2) {
+        if (convert2 === void 0) {
+            convert2 = convertToInt;
+        }
+        if (saturation === 0) {
+            return convert2(lightness, lightness, lightness);
+        }
+        var huePrime = (hue % 360 + 360) % 360 / 60;
+        var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
+        var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
+        var red = 0;
+        var green = 0;
+        var blue = 0;
+        if (huePrime >= 0 && huePrime < 1) {
+            red = chroma;
+            green = secondComponent;
+        } else if (huePrime >= 1 && huePrime < 2) {
+            red = secondComponent;
+            green = chroma;
+        } else if (huePrime >= 2 && huePrime < 3) {
+            green = chroma;
+            blue = secondComponent;
+        } else if (huePrime >= 3 && huePrime < 4) {
+            green = secondComponent;
+            blue = chroma;
+        } else if (huePrime >= 4 && huePrime < 5) {
+            red = secondComponent;
+            blue = chroma;
+        } else if (huePrime >= 5 && huePrime < 6) {
+            red = chroma;
+            blue = secondComponent;
+        }
+        var lightnessModification = lightness - chroma / 2;
+        var finalRed = red + lightnessModification;
+        var finalGreen = green + lightnessModification;
+        var finalBlue = blue + lightnessModification;
+        return convert2(finalRed, finalGreen, finalBlue);
+    }
+    var namedColorMap = {
+        aliceblue: "f0f8ff",
+        antiquewhite: "faebd7",
+        aqua: "00ffff",
+        aquamarine: "7fffd4",
+        azure: "f0ffff",
+        beige: "f5f5dc",
+        bisque: "ffe4c4",
+        black: "000",
+        blanchedalmond: "ffebcd",
+        blue: "0000ff",
+        blueviolet: "8a2be2",
+        brown: "a52a2a",
+        burlywood: "deb887",
+        cadetblue: "5f9ea0",
+        chartreuse: "7fff00",
+        chocolate: "d2691e",
+        coral: "ff7f50",
+        cornflowerblue: "6495ed",
+        cornsilk: "fff8dc",
+        crimson: "dc143c",
+        cyan: "00ffff",
+        darkblue: "00008b",
+        darkcyan: "008b8b",
+        darkgoldenrod: "b8860b",
+        darkgray: "a9a9a9",
+        darkgreen: "006400",
+        darkgrey: "a9a9a9",
+        darkkhaki: "bdb76b",
+        darkmagenta: "8b008b",
+        darkolivegreen: "556b2f",
+        darkorange: "ff8c00",
+        darkorchid: "9932cc",
+        darkred: "8b0000",
+        darksalmon: "e9967a",
+        darkseagreen: "8fbc8f",
+        darkslateblue: "483d8b",
+        darkslategray: "2f4f4f",
+        darkslategrey: "2f4f4f",
+        darkturquoise: "00ced1",
+        darkviolet: "9400d3",
+        deeppink: "ff1493",
+        deepskyblue: "00bfff",
+        dimgray: "696969",
+        dimgrey: "696969",
+        dodgerblue: "1e90ff",
+        firebrick: "b22222",
+        floralwhite: "fffaf0",
+        forestgreen: "228b22",
+        fuchsia: "ff00ff",
+        gainsboro: "dcdcdc",
+        ghostwhite: "f8f8ff",
+        gold: "ffd700",
+        goldenrod: "daa520",
+        gray: "808080",
+        green: "008000",
+        greenyellow: "adff2f",
+        grey: "808080",
+        honeydew: "f0fff0",
+        hotpink: "ff69b4",
+        indianred: "cd5c5c",
+        indigo: "4b0082",
+        ivory: "fffff0",
+        khaki: "f0e68c",
+        lavender: "e6e6fa",
+        lavenderblush: "fff0f5",
+        lawngreen: "7cfc00",
+        lemonchiffon: "fffacd",
+        lightblue: "add8e6",
+        lightcoral: "f08080",
+        lightcyan: "e0ffff",
+        lightgoldenrodyellow: "fafad2",
+        lightgray: "d3d3d3",
+        lightgreen: "90ee90",
+        lightgrey: "d3d3d3",
+        lightpink: "ffb6c1",
+        lightsalmon: "ffa07a",
+        lightseagreen: "20b2aa",
+        lightskyblue: "87cefa",
+        lightslategray: "789",
+        lightslategrey: "789",
+        lightsteelblue: "b0c4de",
+        lightyellow: "ffffe0",
+        lime: "0f0",
+        limegreen: "32cd32",
+        linen: "faf0e6",
+        magenta: "f0f",
+        maroon: "800000",
+        mediumaquamarine: "66cdaa",
+        mediumblue: "0000cd",
+        mediumorchid: "ba55d3",
+        mediumpurple: "9370db",
+        mediumseagreen: "3cb371",
+        mediumslateblue: "7b68ee",
+        mediumspringgreen: "00fa9a",
+        mediumturquoise: "48d1cc",
+        mediumvioletred: "c71585",
+        midnightblue: "191970",
+        mintcream: "f5fffa",
+        mistyrose: "ffe4e1",
+        moccasin: "ffe4b5",
+        navajowhite: "ffdead",
+        navy: "000080",
+        oldlace: "fdf5e6",
+        olive: "808000",
+        olivedrab: "6b8e23",
+        orange: "ffa500",
+        orangered: "ff4500",
+        orchid: "da70d6",
+        palegoldenrod: "eee8aa",
+        palegreen: "98fb98",
+        paleturquoise: "afeeee",
+        palevioletred: "db7093",
+        papayawhip: "ffefd5",
+        peachpuff: "ffdab9",
+        peru: "cd853f",
+        pink: "ffc0cb",
+        plum: "dda0dd",
+        powderblue: "b0e0e6",
+        purple: "800080",
+        rebeccapurple: "639",
+        red: "f00",
+        rosybrown: "bc8f8f",
+        royalblue: "4169e1",
+        saddlebrown: "8b4513",
+        salmon: "fa8072",
+        sandybrown: "f4a460",
+        seagreen: "2e8b57",
+        seashell: "fff5ee",
+        sienna: "a0522d",
+        silver: "c0c0c0",
+        skyblue: "87ceeb",
+        slateblue: "6a5acd",
+        slategray: "708090",
+        slategrey: "708090",
+        snow: "fffafa",
+        springgreen: "00ff7f",
+        steelblue: "4682b4",
+        tan: "d2b48c",
+        teal: "008080",
+        thistle: "d8bfd8",
+        tomato: "ff6347",
+        turquoise: "40e0d0",
+        violet: "ee82ee",
+        wheat: "f5deb3",
+        white: "fff",
+        whitesmoke: "f5f5f5",
+        yellow: "ff0",
+        yellowgreen: "9acd32"
+    };
+
+    function nameToHex(color2) {
+        if (typeof color2 !== "string")
+            return color2;
+        var normalizedColorName = color2.toLowerCase();
+        return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
+    }
+    var hexRegex = /^#[a-fA-F0-9]{6}$/;
+    var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
+    var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
+    var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
+    var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
+    var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
+    var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
+    var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
+
+    function parseToRgb(color2) {
+        if (typeof color2 !== "string") {
+            throw new PolishedError(3);
+        }
+        var normalizedColor = nameToHex(color2);
+        if (normalizedColor.match(hexRegex)) {
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
+                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
+                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
+            };
+        }
+        if (normalizedColor.match(hexRgbaRegex)) {
+            var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
+                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
+                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
+                alpha
+            };
+        }
+        if (normalizedColor.match(reducedHexRegex)) {
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
+                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
+                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
+            };
+        }
+        if (normalizedColor.match(reducedRgbaHexRegex)) {
+            var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
+            return {
+                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
+                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
+                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
+                alpha: _alpha
+            };
+        }
+        var rgbMatched = rgbRegex.exec(normalizedColor);
+        if (rgbMatched) {
+            return {
+                red: parseInt("" + rgbMatched[1], 10),
+                green: parseInt("" + rgbMatched[2], 10),
+                blue: parseInt("" + rgbMatched[3], 10)
+            };
+        }
+        var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
+        if (rgbaMatched) {
+            return {
+                red: parseInt("" + rgbaMatched[1], 10),
+                green: parseInt("" + rgbaMatched[2], 10),
+                blue: parseInt("" + rgbaMatched[3], 10),
+                alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
+            };
+        }
+        var hslMatched = hslRegex.exec(normalizedColor);
+        if (hslMatched) {
+            var hue = parseInt("" + hslMatched[1], 10);
+            var saturation = parseInt("" + hslMatched[2], 10) / 100;
+            var lightness = parseInt("" + hslMatched[3], 10) / 100;
+            var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
+            var hslRgbMatched = rgbRegex.exec(rgbColorString);
+            if (!hslRgbMatched) {
+                throw new PolishedError(4, normalizedColor, rgbColorString);
+            }
+            return {
+                red: parseInt("" + hslRgbMatched[1], 10),
+                green: parseInt("" + hslRgbMatched[2], 10),
+                blue: parseInt("" + hslRgbMatched[3], 10)
+            };
+        }
+        var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
+        if (hslaMatched) {
+            var _hue = parseInt("" + hslaMatched[1], 10);
+            var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
+            var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
+            var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
+            var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
+            if (!_hslRgbMatched) {
+                throw new PolishedError(4, normalizedColor, _rgbColorString);
+            }
+            return {
+                red: parseInt("" + _hslRgbMatched[1], 10),
+                green: parseInt("" + _hslRgbMatched[2], 10),
+                blue: parseInt("" + _hslRgbMatched[3], 10),
+                alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
+            };
+        }
+        throw new PolishedError(5);
+    }
+
+    function rgbToHsl(color2) {
+        var red = color2.red / 255;
+        var green = color2.green / 255;
+        var blue = color2.blue / 255;
+        var max2 = Math.max(red, green, blue);
+        var min2 = Math.min(red, green, blue);
+        var lightness = (max2 + min2) / 2;
+        if (max2 === min2) {
+            if (color2.alpha !== void 0) {
+                return {
+                    hue: 0,
+                    saturation: 0,
+                    lightness,
+                    alpha: color2.alpha
+                };
+            } else {
+                return {
+                    hue: 0,
+                    saturation: 0,
+                    lightness
+                };
+            }
+        }
+        var hue;
+        var delta = max2 - min2;
+        var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
+        switch (max2) {
+            case red:
+                hue = (green - blue) / delta + (green < blue ? 6 : 0);
+                break;
+            case green:
+                hue = (blue - red) / delta + 2;
+                break;
+            default:
+                hue = (red - green) / delta + 4;
+                break;
+        }
+        hue *= 60;
+        if (color2.alpha !== void 0) {
+            return {
+                hue,
+                saturation,
+                lightness,
+                alpha: color2.alpha
+            };
+        }
+        return {
+            hue,
+            saturation,
+            lightness
+        };
+    }
+
+    function parseToHsl(color2) {
+        return rgbToHsl(parseToRgb(color2));
+    }
+    var reduceHexValue = function reduceHexValue2(value) {
+        if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
+            return "#" + value[1] + value[3] + value[5];
+        }
+        return value;
+    };
+    var reduceHexValue$1 = reduceHexValue;
+
+    function numberToHex(value) {
+        var hex2 = value.toString(16);
+        return hex2.length === 1 ? "0" + hex2 : hex2;
+    }
+
+    function colorToHex(color2) {
+        return numberToHex(Math.round(color2 * 255));
+    }
+
+    function convertToHex(red, green, blue) {
+        return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
+    }
+
+    function hslToHex(hue, saturation, lightness) {
+        return hslToRgb(hue, saturation, lightness, convertToHex);
+    }
+
+    function hsl(value, saturation, lightness) {
+        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
+            return hslToHex(value, saturation, lightness);
+        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
+            return hslToHex(value.hue, value.saturation, value.lightness);
+        }
+        throw new PolishedError(1);
+    }
+
+    function hsla$1(value, saturation, lightness, alpha) {
+        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
+            return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
+        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
+            return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
+        }
+        throw new PolishedError(2);
+    }
+
+    function rgb(value, green, blue) {
+        if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
+            return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
+        } else if (typeof value === "object" && green === void 0 && blue === void 0) {
+            return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
+        }
+        throw new PolishedError(6);
+    }
+
+    function rgba$1(firstValue, secondValue, thirdValue, fourthValue) {
+        if (typeof firstValue === "string" && typeof secondValue === "number") {
+            var rgbValue = parseToRgb(firstValue);
+            return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
+        } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
+            return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
+        } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
+            return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
+        }
+        throw new PolishedError(7);
+    }
+    var isRgb = function isRgb2(color2) {
+        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
+    };
+    var isRgba = function isRgba2(color2) {
+        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && typeof color2.alpha === "number";
+    };
+    var isHsl = function isHsl2(color2) {
+        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
+    };
+    var isHsla = function isHsla2(color2) {
+        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && typeof color2.alpha === "number";
+    };
+
+    function toColorString(color2) {
+        if (typeof color2 !== "object")
+            throw new PolishedError(8);
+        if (isRgba(color2))
+            return rgba$1(color2);
+        if (isRgb(color2))
+            return rgb(color2);
+        if (isHsla(color2))
+            return hsla$1(color2);
+        if (isHsl(color2))
+            return hsl(color2);
+        throw new PolishedError(8);
+    }
+
+    function curried(f2, length, acc) {
+        return function fn2() {
+            var combined = acc.concat(Array.prototype.slice.call(arguments));
+            return combined.length >= length ? f2.apply(this, combined) : curried(f2, length, combined);
+        };
+    }
+
+    function curry(f2) {
+        return curried(f2, f2.length, []);
+    }
+
+    function adjustHue(degree, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            hue: hslColor.hue + parseFloat(degree)
+        }));
+    }
+    curry(adjustHue);
+
+    function guard(lowerBoundary, upperBoundary, value) {
+        return Math.max(lowerBoundary, Math.min(upperBoundary, value));
+    }
+
+    function darken(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
+        }));
+    }
+    curry(darken);
+
+    function desaturate(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
+        }));
+    }
+    curry(desaturate);
+
+    function lighten(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
+        }));
+    }
+    curry(lighten);
+
+    function mix(weight, color2, otherColor) {
+        if (color2 === "transparent")
+            return otherColor;
+        if (otherColor === "transparent")
+            return color2;
+        if (weight === 0)
+            return otherColor;
+        var parsedColor1 = parseToRgb(color2);
+        var color1 = _extends$3({}, parsedColor1, {
+            alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
+        });
+        var parsedColor2 = parseToRgb(otherColor);
+        var color22 = _extends$3({}, parsedColor2, {
+            alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
+        });
+        var alphaDelta = color1.alpha - color22.alpha;
+        var x2 = parseFloat(weight) * 2 - 1;
+        var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
+        var z2 = 1 + x2 * alphaDelta;
+        var weight1 = (y2 / z2 + 1) / 2;
+        var weight2 = 1 - weight1;
+        var mixedColor = {
+            red: Math.floor(color1.red * weight1 + color22.red * weight2),
+            green: Math.floor(color1.green * weight1 + color22.green * weight2),
+            blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
+            alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
+        };
+        return rgba$1(mixedColor);
+    }
+    var curriedMix = curry(mix);
+    var mix$1 = curriedMix;
+
+    function opacify(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var parsedColor = parseToRgb(color2);
+        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
+        var colorWithAlpha = _extends$3({}, parsedColor, {
+            alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
+        });
+        return rgba$1(colorWithAlpha);
+    }
+    curry(opacify);
+
+    function saturate(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var hslColor = parseToHsl(color2);
+        return toColorString(_extends$3({}, hslColor, {
+            saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
+        }));
+    }
+    curry(saturate);
+
+    function setHue(hue, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return toColorString(_extends$3({}, parseToHsl(color2), {
+            hue: parseFloat(hue)
+        }));
+    }
+    curry(setHue);
+
+    function setLightness(lightness, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return toColorString(_extends$3({}, parseToHsl(color2), {
+            lightness: parseFloat(lightness)
+        }));
+    }
+    curry(setLightness);
+
+    function setSaturation(saturation, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return toColorString(_extends$3({}, parseToHsl(color2), {
+            saturation: parseFloat(saturation)
+        }));
+    }
+    curry(setSaturation);
+
+    function shade(percentage, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
+    }
+    curry(shade);
+
+    function tint(percentage, color2) {
+        if (color2 === "transparent")
+            return color2;
+        return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
+    }
+    curry(tint);
+
+    function transparentize(amount, color2) {
+        if (color2 === "transparent")
+            return color2;
+        var parsedColor = parseToRgb(color2);
+        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
+        var colorWithAlpha = _extends$3({}, parsedColor, {
+            alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
+        });
+        return rgba$1(colorWithAlpha);
+    }
+    curry(transparentize);
+
+    function useClTheme() {
+        return styled.useTheme();
+    }
+    const shouldForwardProp$4 = (prop) => !["asButton"].includes(prop);
+    const StyledFAIcon = styled__default.default(FontAwesomeIcon).withConfig({
+        shouldForwardProp: shouldForwardProp$4
+    })`
+        cursor: ${(props) => props.asButton ? "pointer" : "inherit"};
+        color: inherit;
+        ${(props) => props.asButton ? `:hover { color: ${props.theme.colors.grey6}; }` : ""}
+    `;
+    const mapFASizeToMD = {
+        "10x": "120px",
+        "1x": "12px",
+        "2x": "24px",
+        "3x": "36px",
+        "4x": "48px",
+        "5x": "60px",
+        "6x": "72px",
+        "7x": "84px",
+        "8x": "96px",
+        "9x": "108px",
+        lg: "24px",
+        sm: "12px",
+        xs: "6px"
+    };
+    const SizeMappedMDIcon = (props) => {
+        if (props.size) {
+            return jsxRuntime.exports.jsx(Icon$4.Icon, Object.assign({}, props, {
+                size: mapFASizeToMD[props.size]
+            }));
+        }
+        return jsxRuntime.exports.jsx(Icon$4.Icon, Object.assign({}, props));
+    };
+    styled__default.default(SizeMappedMDIcon).withConfig({
+        shouldForwardProp: shouldForwardProp$4
+    })`
+    cursor: ${(props) => props.asButton ? "pointer" : "default"};
+    color: inherit;
+    ${(props) => props.asButton ? `:hover { color: ${props.theme.colors.grey6}; }` : ""}
+`;
+    const CheckSquare = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faCheckSquare
+        }, props));
+    };
+    const ChevronLeft = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faChevronLeft
+        }, props));
+    };
+    const ChevronRight = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faChevronRight
+        }, props));
+    };
+    const Circle$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faCircle
+        }, props));
+    };
+    const Copy = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faCopy
+        }, props));
+    };
+    const Cross$1 = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faTimes
+        }, props));
+    };
+    const Square = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faSquare
+        }, props));
+    };
+    const ToggleOff = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faToggleOff
+        }, props));
+    };
+    const ToggleOn = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faToggleOn
+        }, props));
+    };
+    const Trash = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faTrash
+        }, props));
+    };
+    const ChevronDown = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faChevronDown
+        }, props));
+    };
+    const ChevronUp = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faChevronUp
+        }, props));
+    };
+    const Moon = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faMoon
+        }, props));
+    };
+    const PenToSquare = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faPenToSquare
+        }, props));
+    };
+    const CircleCheck = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faCircleCheck
+        }, props));
+    };
+    const CircleInfo = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faCircleInfo
+        }, props));
+    };
+    const MagnifyingGlass = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faMagnifyingGlass
+        }, props));
+    };
+    const Xmark = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faXmark
+        }, props));
+    };
+    const TriangleExclamation = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faTriangleExclamation
+        }, props));
+    };
+    const CircleXmark = (props) => {
+        return jsxRuntime.exports.jsx(StyledFAIcon, Object.assign({
+            icon: faCircleXmark
+        }, props));
+    };
+    const NotificationWrapper$1 = styled__default.default.div`
+    pointer-events: auto;
+
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 22rem;
+    height: ${(props) => props.hasTitle ? "5.625rem" : "4.375rem"};
+    padding: 1rem;
+
+    color: ${(props) => getStatusColor(props.status, props.theme.colors)};
+
+    background-color: ${(props) => mix$1(0.1, getStatusColor(props.status, props.theme.colors), props.theme.colors.background)};
+    border: 1px solid ${(props) => getStatusColor(props.status, props.theme.colors)};
+    border-radius: 0.25rem;
+    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
+`;
+    const Message = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+
+    width: 15.75rem;
+
+    font-size: 1rem;
+    line-height: 1.1875rem;
+`;
+    const Heading = styled__default.default.h2`
+    overflow: hidden;
+    display: -webkit-box; /* stylelint-disable-line value-no-vendor-prefix */
+
+    font-size: 1rem;
+    font-weight: 700;
+    text-overflow: ellipsis;
+
+    -webkit-box-orient: vertical;
+    -webkit-line-clamp: 1;
+`;
+    const Body = styled__default.default.span`
+    overflow: hidden;
+    display: -webkit-box; /* stylelint-disable-line value-no-vendor-prefix */
+
+    font-weight: 400;
+    line-height: 1.25rem;
+    text-overflow: ellipsis;
+
+    -webkit-box-orient: vertical;
+    -webkit-line-clamp: ${(props) => props.moreDetailsShown ? 1 : 2};
+`;
+    const Icon$1 = styled__default.default.div`
+    display: flex;
+
+    svg {
+        width: 1.5rem;
+        height: 1.3125rem;
+        color: ${(props) => getStatusColor(props.status, props.theme.colors)};
+    }
+`;
+    const MoreDetailsButton = styled__default.default.button`
+    cursor: pointer;
+
+    display: flex;
+
+    padding-left: 0;
+
+    color: ${() => theme$3.colors.grey4};
+
+    background: transparent;
+    border: none;
+    :hover {
+        text-decoration: underline;
+    }
+`;
+    const CloseBtn = styled__default.default(Cross$1)`
+    height: 1.2rem;
+    color: ${(props) => getStatusColor(props.status, props.theme.colors)};
+`;
+
+    function getIcon(status2) {
+        if ([Status$1.ERROR, Status$1.FAILED].includes(status2)) {
+            return jsxRuntime.exports.jsx(CircleXmark, {});
+        }
+        if ([Status$1.CANCELED, Status$1.WARNING].includes(status2)) {
+            return jsxRuntime.exports.jsx(TriangleExclamation, {});
+        }
+        return status2 === Status$1.SUCCESS ? jsxRuntime.exports.jsx(CircleCheck, {}) : jsxRuntime.exports.jsx(CircleInfo, {});
+    }
+
+    function Notification(props) {
+        const isOverflowing = props.notification.message.length > 30;
+        const showMoreDetails = props.onMoreDetailsClick && isOverflowing;
+        return jsxRuntime.exports.jsxs(NotificationWrapper$1, {
+            hasTitle: !!props.notification.title,
+            status: props.notification.status,
+            children: [jsxRuntime.exports.jsx(Icon$1, {
+                status: props.notification.status,
+                children: getIcon(props.notification.status)
+            }), jsxRuntime.exports.jsxs(Message, {
+                children: [jsxRuntime.exports.jsx(Heading, {
+                    children: props.notification.title
+                }), jsxRuntime.exports.jsx(Body, {
+                    moreDetailsShown: showMoreDetails,
+                    children: props.notification.message
+                }), showMoreDetails && jsxRuntime.exports.jsx(MoreDetailsButton, {
+                    onClick: (e3) => props.onMoreDetailsClick(e3, props.notification),
+                    type: "button",
+                    children: "Details >"
+                })]
+            }), jsxRuntime.exports.jsx(CloseBtn, {
+                asButton: true,
+                onClick: () => props.onDismiss(props.notification.key),
+                status: props.notification.status
+            })]
+        });
+    }
+    styled__default.default.div`
+    pointer-events: none;
+
+    position: fixed;
+    z-index: 6000;
+    right: 1rem;
+
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
+    align-items: center;
+    justify-content: flex-end;
+
+    width: 324px;
+    height: 100%;
+    padding: 0.75rem 0;
+`;
+    const baseNotifications$ = new Subject();
+    React__namespace.createContext({
+        notifications$: baseNotifications$,
+        onMoreDetailsClick: null,
+        push: (notification) => baseNotifications$.next(notification)
+    });
+    var WeakMap$1 = _WeakMap;
+    WeakMap$1 && new WeakMap$1();
+    var isObject$4 = isObject_1;
+    var objectCreate = Object.create;
+    var baseCreate$3 = function() {
+        function object2() {}
+        return function(proto2) {
+            if (!isObject$4(proto2)) {
+                return {};
+            }
+            if (objectCreate) {
+                return objectCreate(proto2);
+            }
+            object2.prototype = proto2;
+            var result = new object2();
+            object2.prototype = void 0;
+            return result;
+        };
+    }();
+    var _baseCreate = baseCreate$3;
+
+    function baseLodash$3() {}
+    var _baseLodash = baseLodash$3;
+    var baseCreate$2 = _baseCreate,
+        baseLodash$2 = _baseLodash;
+    var MAX_ARRAY_LENGTH = 4294967295;
+
+    function LazyWrapper$2(value) {
+        this.__wrapped__ = value;
+        this.__actions__ = [];
+        this.__dir__ = 1;
+        this.__filtered__ = false;
+        this.__iteratees__ = [];
+        this.__takeCount__ = MAX_ARRAY_LENGTH;
+        this.__views__ = [];
+    }
+    LazyWrapper$2.prototype = baseCreate$2(baseLodash$2.prototype);
+    LazyWrapper$2.prototype.constructor = LazyWrapper$2;
+    var _LazyWrapper = LazyWrapper$2;
+    var baseCreate$1 = _baseCreate,
+        baseLodash$1 = _baseLodash;
+
+    function LodashWrapper$2(value, chainAll) {
+        this.__wrapped__ = value;
+        this.__actions__ = [];
+        this.__chain__ = !!chainAll;
+        this.__index__ = 0;
+        this.__values__ = void 0;
+    }
+    LodashWrapper$2.prototype = baseCreate$1(baseLodash$1.prototype);
+    LodashWrapper$2.prototype.constructor = LodashWrapper$2;
+    var _LodashWrapper = LodashWrapper$2;
+
+    function copyArray$4(source, array2) {
+        var index2 = -1,
+            length = source.length;
+        array2 || (array2 = Array(length));
+        while (++index2 < length) {
+            array2[index2] = source[index2];
+        }
+        return array2;
+    }
+    var _copyArray = copyArray$4;
+    var LazyWrapper$1 = _LazyWrapper,
+        LodashWrapper$1 = _LodashWrapper,
+        copyArray$3 = _copyArray;
+
+    function wrapperClone$1(wrapper) {
+        if (wrapper instanceof LazyWrapper$1) {
+            return wrapper.clone();
+        }
+        var result = new LodashWrapper$1(wrapper.__wrapped__, wrapper.__chain__);
+        result.__actions__ = copyArray$3(wrapper.__actions__);
+        result.__index__ = wrapper.__index__;
+        result.__values__ = wrapper.__values__;
+        return result;
+    }
+    var _wrapperClone = wrapperClone$1;
+    var LazyWrapper = _LazyWrapper,
+        LodashWrapper = _LodashWrapper,
+        baseLodash = _baseLodash,
+        isArray$8 = isArray_1,
+        isObjectLike$2 = isObjectLike_1,
+        wrapperClone = _wrapperClone;
+    var objectProto$3 = Object.prototype;
+    var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
+
+    function lodash(value) {
+        if (isObjectLike$2(value) && !isArray$8(value) && !(value instanceof LazyWrapper)) {
+            if (value instanceof LodashWrapper) {
+                return value;
+            }
+            if (hasOwnProperty$4.call(value, "__wrapped__")) {
+                return wrapperClone(value);
+            }
+        }
+        return new LodashWrapper(value);
+    }
+    lodash.prototype = baseLodash.prototype;
+    lodash.prototype.constructor = lodash;
+    var getNative = _getNative;
+    var defineProperty$1 = function() {
+        try {
+            var func = getNative(Object, "defineProperty");
+            func({}, "", {});
+            return func;
+        } catch (e3) {}
+    }();
+    var _defineProperty$k = defineProperty$1;
+
+    function arrayEach$1(array2, iteratee) {
+        var index2 = -1,
+            length = array2 == null ? 0 : array2.length;
+        while (++index2 < length) {
+            if (iteratee(array2[index2], index2, array2) === false) {
+                break;
+            }
+        }
+        return array2;
+    }
+    var _arrayEach = arrayEach$1;
+    var Key;
+    (function(Key2) {
+        Key2["BACKSPACE"] = "Backspace";
+        Key2["CTRL"] = "Control";
+        Key2["DOWN"] = "ArrowDown";
+        Key2["ENTER"] = "Enter";
+        Key2["ESCAPE"] = "Escape";
+        Key2["LEFT"] = "ArrowLeft";
+        Key2["META"] = "Meta";
+        Key2["MINUS"] = "-";
+        Key2["PERIOD"] = ".";
+        Key2["RIGHT"] = "ArrowRight";
+        Key2["SHIFT"] = "Shift";
+        Key2["TAB"] = "Tab";
+        Key2["UP"] = "ArrowUp";
+    })(Key || (Key = {}));
+    const CONTROL_KEYS = [
+        Key.ESCAPE,
+        Key.TAB,
+        Key.ENTER,
+        Key.BACKSPACE,
+        Key.CTRL,
+        Key.SHIFT,
+        Key.UP,
+        Key.DOWN,
+        Key.LEFT,
+        Key.RIGHT,
+        Key.META
+    ];
+    const shouldForwardProp$3 = (prop) => !["isOpen"].includes(prop);
+    const Icon = styled__default.default(ChevronDown).withConfig({
+        shouldForwardProp: shouldForwardProp$3
+    })`
+    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+    transform: ${(props) => {
+    const start2 = props.angles ? props.angles[0] : 0;
+    const end2 = props.angles ? props.angles[1] : 180;
+    return props.isOpen ? `rotate(${end2}deg)` : `rotate(${start2}deg)`;
+  }};
+    color: ${(props) => props.theme.colors.grey5};
+    transition: transform 0.1s linear;
+`;
+
+    function Chevron$1(props, ref2) {
+        return jsxRuntime.exports.jsx(Icon, {
+            angles: props.angles,
+            className: props.className,
+            disabled: props.disabled,
+            isOpen: props.isOpen,
+            onClick: props.onClick,
+            ref: ref2,
+            style: props.style
+        });
+    }
+    const Chevron$2 = React__namespace.forwardRef(Chevron$1);
+    styled__default.default.label`
+    margin-bottom: 0;
+    font-size: 11px;
+    color: ${(props) => props.theme.colors.grey6};
+`;
+    const List = styled__default.default.div`
+    z-index: 5000;
+
+    overflow-y: auto;
+    display: ${(props) => props.isOpen ? "flex" : "none"};
+    flex-direction: column;
+
+    max-height: calc(${(props) => (props.maxItems || 5) * 2}em + 2px);
+
+    border: 1px solid ${(props) => props.theme.colors.grey3};
+`;
+    const ListItem = styled__default.default.span`
+    cursor: pointer;
+    user-select: none;
+
+    overflow: hidden;
+
+    width: 100%;
+    min-height: 2rem;
+    padding: 0.25rem 1rem;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : "1rem"};
+    font-weight: 300;
+    color: ${(props) => props.theme.colors.text};
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: ${(props) => props.hovered ? props.theme.colors.grey2 : props.theme.colors.blue1};
+    border-bottom: 1px solid ${(props) => props.theme.colors.grey3};
+
+    :active {
+        color: ${(props) => props.theme.colors.blue1};
+        background-color: ${(props) => props.theme.colors.primary};
+    }
+
+    &:last-child {
+        border-bottom: none;
+    }
+`;
+    const sameWidthModifier = {
+        effect: ({
+            state
+        }) => () => {
+            state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
+        },
+        enabled: true,
+        fn: ({
+            state
+        }) => {
+            state.styles.popper.width = `${state.rects.reference.width}px`;
+        },
+        name: "sameWidth",
+        phase: "beforeWrite",
+        requires: ["computeStyles"]
+    };
+    globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
+        function adopt(value) {
+            return value instanceof P2 ? value : new P2(function(resolve2) {
+                resolve2(value);
+            });
+        }
+        return new(P2 || (P2 = Promise))(function(resolve2, reject) {
+            function fulfilled(value) {
+                try {
+                    step2(generator.next(value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
+
+            function rejected(value) {
+                try {
+                    step2(generator["throw"](value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
+
+            function step2(result) {
+                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
+            }
+            step2((generator = generator.apply(thisArg, _arguments || [])).next());
+        });
+    };
+    var Status;
+    (function(Status2) {
+        Status2["CANCELED"] = "CANCELED";
+        Status2["CREATED"] = "CREATED";
+        Status2["ERROR"] = "ERROR";
+        Status2["FAILED"] = "FAILED";
+        Status2["NONE"] = "";
+        Status2["QUEUED"] = "QUEUED";
+        Status2["RUNNING"] = "RUNNING";
+        Status2["SUCCESS"] = "SUCCESS";
+        Status2["WARNING"] = "WARNING";
+    })(Status || (Status = {}));
+    var HTTP_METHOD;
+    (function(HTTP_METHOD2) {
+        HTTP_METHOD2["DELETE"] = "DELETE";
+        HTTP_METHOD2["GET"] = "GET";
+        HTTP_METHOD2["PATCH"] = "PATCH";
+        HTTP_METHOD2["POST"] = "POST";
+        HTTP_METHOD2["PUT"] = "PUT";
+    })(HTTP_METHOD || (HTTP_METHOD = {}));
+    globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
+        function adopt(value) {
+            return value instanceof P2 ? value : new P2(function(resolve2) {
+                resolve2(value);
+            });
+        }
+        return new(P2 || (P2 = Promise))(function(resolve2, reject) {
+            function fulfilled(value) {
+                try {
+                    step2(generator.next(value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
+
+            function rejected(value) {
+                try {
+                    step2(generator["throw"](value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
+
+            function step2(result) {
+                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
+            }
+            step2((generator = generator.apply(thisArg, _arguments || [])).next());
+        });
+    };
+
+    function useDeepCompare(value) {
+        const ref2 = React.useRef();
+        if (!isEqual_1(value, ref2.current)) {
+            ref2.current = value;
+        }
+        return ref2.current;
+    }
+
+    function useThrottle(cb, delay, options) {
+        const cbRef = React.useRef(cb);
+        React.useEffect(() => {
+            cbRef.current = cb;
+        });
+        return React.useCallback(throttle_1((...args) => cbRef.current(...args), delay, options), [delay, options]);
+    }
+
+    function useThrottledState(initialValue, delay, options = {
+        leading: false,
+        trailing: true
+    }) {
+        const [value, setValue] = React.useState(initialValue);
+        const throttledSetValue = useThrottle(setValue, delay, options);
+        return [value, throttledSetValue, setValue];
+    }
+
+    function useOnClickOutside(element2, handler) {
+        React.useEffect(() => {
+            const listener2 = (event2) => {
+                if (!element2 || element2.contains(event2.target)) {
+                    return;
+                }
+                handler();
+            };
+            document.addEventListener("mousedown", listener2);
+            document.addEventListener("touchstart", listener2);
+            return () => {
+                document.removeEventListener("mousedown", listener2);
+                document.removeEventListener("touchstart", listener2);
+            };
+        }, [element2, handler]);
+    }
+    globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
+        function adopt(value) {
+            return value instanceof P2 ? value : new P2(function(resolve2) {
+                resolve2(value);
+            });
+        }
+        return new(P2 || (P2 = Promise))(function(resolve2, reject) {
+            function fulfilled(value) {
+                try {
+                    step2(generator.next(value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
+
+            function rejected(value) {
+                try {
+                    step2(generator["throw"](value));
+                } catch (e3) {
+                    reject(e3);
+                }
+            }
+
+            function step2(result) {
+                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
+            }
+            step2((generator = generator.apply(thisArg, _arguments || [])).next());
+        });
+    };
+    styled__default.default.div`
+    width: 100%;
+    background-color: ${(props) => {
+    var _a3;
+    return (_a3 = props.backgroundColor) !== null && _a3 !== void 0 ? _a3 : props.theme.colors.blue1;
+  }};
+    border: 1px solid ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+
+    /* Define the animation used for collapsing */
+    /* stylelint-disable-next-line -- external classname */
+    .ReactCollapse--collapse {
+        transition: height 0.35s ease;
+    }
+`;
+    styled__default.default.dt`
+    cursor: pointer;
+
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    padding: 0.5rem 1rem;
+
+    font-size: 1.2em;
+    font-weight: 400;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+
+    &:hover {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    &:active {
+        background-color: ${(props) => props.theme.colors.grey3};
+    }
+`;
+    styled__default.default.dd`
+    overflow: hidden;
+
+    width: 100%;
+    height: 100%;
+
+    /*
+    We have to use padding for the gap between items rather than margin
+    because margin doesn't work well with react-collapse and causes jumping
+    See: https://github.com/nkbt/react-collapse#behaviour-notes
+    */
+    margin: 0;
+    padding: 1rem;
+`;
+    styled__default.default.div`
+    display: flex;
+
+    height: auto;
+
+    font-size: 1em;
+    font-weight: 300;
+    color: ${(props) => props.theme.colors.text};
+`;
+    styled__default.default.dl`
+    overflow: auto;
+    display: flex;
+    flex-direction: column;
+    gap: 2px;
+    align-items: center;
+
+    width: 100%;
+    height: 100%;
+`;
+    const shouldForwardProp$2 = (prop) => !["color", "width"].includes(prop);
+    const Badge = styled__default.default.span.withConfig({
+        shouldForwardProp: shouldForwardProp$2
+    })`
+    display: inline-flex;
+    align-items: center;
+    justify-content: center;
+
+    width: ${(props) => props.width || "auto"};
+    height: ${(props) => props.height ? `${props.height}px` : "2rem"};
+    padding: 0 0.75rem;
+
+    font-size: 0.875rem;
+    font-weight: 400;
+    color: ${(props) => props.outline ? props.color : props.theme.colors.blue1};
+
+    background-color: ${(props) => props.outline ? props.theme.colors.blue1 : props.color};
+    border: 1px solid ${(props) => props.color};
+    border-radius: ${(props) => props.height ? `${props.height / 2}px` : "1rem"};
+`;
+    const Wrapper$7 = styled__default.default.div`
+    display: flex;
+    gap: 1rem;
+    align-items: center;
+    justify-content: center;
+
+    height: 100%;
+`;
+    const LoadingText = styled__default.default.span`
+    font-size: 1.2rem;
+    color: ${(props) => {
+    var _a3;
+    return (_a3 = props.color) !== null && _a3 !== void 0 ? _a3 : props.theme.colors.grey4;
+  }};
+`;
+    const Loader$1 = styled__default.default.span`
+    position: relative;
+    width: ${(props) => {
+    var _a3;
+    return (_a3 = props.size) !== null && _a3 !== void 0 ? _a3 : "2.5rem";
+  }};
+    height: ${(props) => {
+    var _a3;
+    return (_a3 = props.size) !== null && _a3 !== void 0 ? _a3 : "2.5rem";
+  }};
+    animation: sk-chase 2.5s infinite linear both;
+
+    .sk-chase-dot {
+        position: absolute;
+        top: 0;
+        left: 0;
+
+        width: 100%;
+        height: 100%;
+
+        animation: sk-chase-dot 2s infinite ease-in-out both;
+    }
+
+    .sk-chase-dot::before {
+        content: '';
+
+        display: block;
+
+        width: 25%;
+        height: 25%;
+
+        background-color: ${(props) => {
+    var _a3;
+    return (_a3 = props.color) !== null && _a3 !== void 0 ? _a3 : props.theme.colors.grey4;
+  }};
+        border-radius: 100%;
+
+        animation: sk-chase-dot-before 2s infinite ease-in-out both;
+    }
+
+    .sk-chase-dot:nth-child(1) {
+        animation-delay: -1.1s;
+    }
+
+    .sk-chase-dot:nth-child(2) {
+        animation-delay: -1s;
+    }
+
+    .sk-chase-dot:nth-child(3) {
+        animation-delay: -0.9s;
+    }
+
+    .sk-chase-dot:nth-child(4) {
+        animation-delay: -0.8s;
+    }
+
+    .sk-chase-dot:nth-child(5) {
+        animation-delay: -0.7s;
+    }
+
+    .sk-chase-dot:nth-child(6) {
+        animation-delay: -0.6s;
+    }
+
+    .sk-chase-dot:nth-child(1)::before {
+        animation-delay: -1.1s;
+    }
+
+    .sk-chase-dot:nth-child(2)::before {
+        animation-delay: -1s;
+    }
+
+    .sk-chase-dot:nth-child(3)::before {
+        animation-delay: -0.9s;
+    }
+
+    .sk-chase-dot:nth-child(4)::before {
+        animation-delay: -0.8s;
+    }
+
+    .sk-chase-dot:nth-child(5)::before {
+        animation-delay: -0.7s;
+    }
+
+    .sk-chase-dot:nth-child(6)::before {
+        animation-delay: -0.6s;
+    }
+
+    @keyframes sk-chase {
+        100% {
+            transform: rotate(360deg);
+        }
+    }
+
+    @keyframes sk-chase-dot {
+        80%,
+        100% {
+            transform: rotate(360deg);
+        }
+    }
+
+    @keyframes sk-chase-dot-before {
+        50% {
+            transform: scale(0.4);
+        }
+
+        100%,
+        0% {
+            transform: scale(1);
+        }
+    }
+`;
+
+    function Spinner(props) {
+        var _a3;
+        return jsxRuntime.exports.jsxs(Wrapper$7, {
+            className: props.className,
+            style: props.style,
+            children: [jsxRuntime.exports.jsxs(Loader$1, {
+                color: props.color,
+                size: props.size,
+                children: [jsxRuntime.exports.jsx("div", {
+                    className: "sk-chase-dot"
+                }), jsxRuntime.exports.jsx("div", {
+                    className: "sk-chase-dot"
+                }), jsxRuntime.exports.jsx("div", {
+                    className: "sk-chase-dot"
+                }), jsxRuntime.exports.jsx("div", {
+                    className: "sk-chase-dot"
+                }), jsxRuntime.exports.jsx("div", {
+                    className: "sk-chase-dot"
+                }), jsxRuntime.exports.jsx("div", {
+                    className: "sk-chase-dot"
+                })]
+            }), (props.showText || props.text) && jsxRuntime.exports.jsx(LoadingText, {
+                color: props.color,
+                children: (_a3 = props.text) !== null && _a3 !== void 0 ? _a3 : "LOADING"
+            })]
+        });
+    }
+    var __rest$b = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const BaseButton = styled__default.default.button`
+    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+    user-select: none;
+
+    display: flex;
+    align-items: center;
+    justify-content: center;
+
+    height: 2.5rem;
+    padding: ${(props) => props.$hasAnchor ? 0 : "0 1rem"};
+    padding: 0 1rem;
+
+    font-size: 1rem;
+    font-weight: 600;
+
+    border: none;
+    border-radius: 0.25rem;
+`;
+
+    function getOutlinedButtonStyle(buttonColor, disabled2, theme2) {
+        return `
+        color: ${disabled2 ? theme2.colors.grey2 : buttonColor};
+
+        background-color: transparent;
+        border: 1px solid
+            ${disabled2 ? theme2.colors.grey2 : buttonColor};
+
+        :hover:not(:disabled) {
+            background-color: ${theme2.themeType === "dark" ? curriedTransparentize$2(0.85, buttonColor) : curriedTransparentize$2(0.9, buttonColor)};
+        }
+
+        :active:not(:disabled) {
+            background-color: ${theme2.themeType === "dark" ? curriedTransparentize$2(0.7, buttonColor) : curriedTransparentize$2(0.8, buttonColor)};
+        }
+    `;
+    }
+
+    function getFilledButtonStyle(buttonColor, hoverColor, clickColor, disabled2, theme2, textColor) {
+        const color2 = textColor !== null && textColor !== void 0 ? textColor : theme2.colors.blue1;
+        return `
+        color: ${color2};
+
+        background-color: ${disabled2 ? theme2.colors.grey2 : buttonColor};
+
+        :hover:not(:disabled) {
+            background-color: ${hoverColor};
+        }
+
+        :active:not(:disabled) {
+            background-color: ${clickColor};
+        }
+    `;
+    }
+    const PrimaryButton = styled__default.default(BaseButton)`
+    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.primary, props.disabled, props.theme) : getFilledButtonStyle(props.theme.colors.primary, props.theme.colors.primaryHover, props.theme.colors.primaryDown, props.disabled, props.theme)}
+`;
+    const SecondaryButton = styled__default.default(BaseButton)`
+    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.secondary, props.disabled, props.theme) : getFilledButtonStyle(props.theme.colors.secondary, props.theme.colors.secondaryHover, props.theme.colors.secondaryDown, props.disabled, props.theme)}
+`;
+    const GhostButton = styled__default.default(BaseButton)`
+    ${(props) => getFilledButtonStyle("transparent", props.theme.colors.grey2, props.theme.colors.grey2, props.disabled, props.theme, props.theme.colors.grey4)}
+`;
+    const ErrorButton = styled__default.default(BaseButton)`
+    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.error, props.disabled, props.theme) : getFilledButtonStyle(props.theme.colors.error, props.theme.colors.errorHover, props.theme.colors.errorDown, props.disabled, props.theme)}
+`;
+    const PlainButton = styled__default.default(BaseButton)`
+    ${(props) => props.outline ? getOutlinedButtonStyle(props.theme.colors.grey6, props.disabled, props.theme) : getFilledButtonStyle("transparent", props.theme.colors.grey1, props.theme.colors.grey2, props.disabled, props.theme, props.theme.colors.grey6)}
+`;
+    const AnchorWrapper = styled__default.default.a`
+    display: flex;
+    align-items: center;
+    justify-content: center;
+
+    width: 100%;
+    height: 100%;
+    padding: 0 1rem;
+
+    color: inherit;
+
+    :hover,
+    :active {
+        color: inherit;
+        text-decoration: none;
+    }
+`;
+    const StyledLoading = styled__default.default(Spinner)`
+    padding: 1rem 2rem;
+`;
+    const stylingMap = {
+        error: ErrorButton,
+        ghost: GhostButton,
+        plain: PlainButton,
+        primary: PrimaryButton,
+        secondary: SecondaryButton
+    };
+
+    function Button(_a3, ref2) {
+        var {
+            autoFocus,
+            children: children2,
+            className,
+            disabled: disabled2,
+            download,
+            href,
+            loading,
+            id: id2,
+            onClick,
+            outline = false,
+            style: style2,
+            styling = "primary",
+            type: type2 = "button"
+        } = _a3, props = __rest$b(_a3, ["autoFocus", "children", "className", "disabled", "download", "href", "loading", "id", "onClick", "outline", "style", "styling", "type"]);
+        const currentTheme = useClTheme();
+        const Component = stylingMap[styling];
+        const content2 = loading ? jsxRuntime.exports.jsx(StyledLoading, {
+            color: outline ? currentTheme.colors.grey2 : currentTheme.colors.blue1
+        }) : children2;
+        const wrappedContent = href ? jsxRuntime.exports.jsx(AnchorWrapper, {
+            download,
+            href,
+            children: content2
+        }) : content2;
+        return jsxRuntime.exports.jsx(Component, Object.assign({
+            "$hasAnchor": !!href,
+            autoFocus,
+            className,
+            disabled: disabled2 || loading,
+            id: id2,
+            onClick,
+            outline,
+            style: style2,
+            type: type2
+        }, props, {
+            ref: ref2,
+            children: wrappedContent
+        }));
+    }
+    const Button$1 = React.forwardRef(Button);
+    styled__default.default.div`
+    overflow: hidden;
+    display: flex;
+    flex: 1 1 auto;
+
+    height: 2.5rem;
+
+    border: 1px solid ${(props) => {
+    var _a3;
+    return props.disabled ? props.theme.colors.grey2 : (_a3 = props.theme.colors) === null || _a3 === void 0 ? void 0 : _a3[props.styling];
+  }};
+    border-radius: 0.25rem;
+
+    button:not(:last-child) {
+        border-right: 1px solid
+            ${(props) => {
+    var _a3;
+    return props.disabled ? props.theme.colors.grey2 : (_a3 = props.theme.colors) === null || _a3 === void 0 ? void 0 : _a3[props.styling];
+  }};
+    }
+`;
+    const shouldForwardProp$1 = (prop) => !["selected"].includes(prop);
+
+    function getButtonStyle(buttonColor, disabled2, selected, theme2) {
+        let color2 = buttonColor;
+        let backgroundColor = "transparent";
+        if (selected) {
+            color2 = theme2.colors.background;
+            backgroundColor = buttonColor;
+        }
+        if (disabled2) {
+            color2 = theme2.colors.grey2;
+            backgroundColor = theme2.colors.blue1;
+        }
+        if (disabled2 && selected) {
+            color2 = theme2.colors.blue1;
+            backgroundColor = theme2.colors.grey2;
+        }
+        return `
+    flex: 1 1 auto;
+
+    margin: 0px;
+
+    color: ${color2};
+
+    background-color: ${backgroundColor};
+    border-radius: 0px;
+    height: 100%;
+
+    ${!selected && (theme2.themeType === "dark" ? `
+        :hover:not(:disabled) {
+            background-color: ${curriedTransparentize$2(0.8, buttonColor)};
+        }
+
+
+        :active:not(:disabled) {
+            background-color: ${curriedTransparentize$2(0.6, buttonColor)};
+        }
+    ` : `
+        :hover:not(:disabled) {
+            background-color: ${curriedTransparentize$2(0.9, buttonColor)};
+        }
+
+
+        :active:not(:disabled) {
+            background-color: ${curriedTransparentize$2(0.8, buttonColor)};
+        }
+    `)}
+    `;
+    }
+    styled__default.default(BaseButton).withConfig({
+        shouldForwardProp: shouldForwardProp$1
+    })`
+    ${(props) => getButtonStyle(props.theme.colors.primary, props.disabled, props.selected, props.theme)}
+`;
+    styled__default.default(BaseButton).withConfig({
+        shouldForwardProp: shouldForwardProp$1
+    })`
+    ${(props) => getButtonStyle(props.theme.colors.secondary, props.disabled, props.selected, props.theme)}
+`;
+    styled__default.default.div`
+    position: relative;
+
+    overflow: hidden;
+    display: flex;
+    flex: 1 1 auto;
+    flex-direction: column;
+    justify-content: center;
+
+    max-height: 100%;
+    padding: 0 0.5rem;
+`;
+    styled__default.default.div`
+    display: inline-flex;
+    max-height: calc(100% - 1.625rem);
+    white-space: nowrap;
+    transition: transform 0.3s;
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 1 0 auto;
+    justify-content: center;
+
+    width: 100%;
+    min-height: 5rem;
+    max-height: 100%;
+`;
+    styled__default.default.div`
+    display: flex;
+    gap: 0.2rem;
+    justify-content: center;
+`;
+    styled__default.default.button`
+    cursor: pointer;
+    user-select: none;
+
+    position: absolute;
+    z-index: 3;
+    top: calc(50% - 0.5rem);
+    transform: translateY(-50%);
+
+    display: flex;
+    align-items: center;
+
+    padding: 0;
+
+    color: ${(props) => props.theme.colors.grey4};
+
+    background-color: inherit;
+    border: none;
+
+    :hover {
+        color: ${(props) => props.theme.colors.grey5};
+    }
+`;
+    styled__default.default.button`
+    cursor: pointer;
+    user-select: none;
+
+    z-index: 3;
+
+    padding: 0;
+
+    color: ${(props) => props.selected ? props.theme.colors.grey4 : props.theme.colors.grey3};
+
+    background-color: inherit;
+    border: none;
+
+    :hover {
+        color: ${(props) => props.theme.colors.grey4};
+    }
+
+    svg {
+        width: 0.5rem;
+        height: 0.5rem;
+    }
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 0 0 auto;
+    align-items: center;
+    justify-content: center;
+`;
+    styled__default.default.div`
+    overflow: auto;
+    display: flex;
+    flex: 1 1 auto;
+    flex-direction: column;
+
+    box-sizing: border-box;
+    margin: 1rem 0;
+    padding: 0 1.5rem;
+
+    color: ${(props) => props.theme.colors.text};
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 0 0 auto;
+    font-weight: bold;
+    color: ${(props) => props.theme.colors.text};
+`;
+    styled__default.default.span`
+    display: flex;
+    flex-direction: column;
+
+    padding-left: 1rem;
+
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.error};
+`;
+    styled__default.default.textarea`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+
+    width: 100%;
+    height: 100%;
+    min-height: 3.6rem;
+    padding: 1rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    outline: 0;
+
+    :focus:not(:disabled) {
+        border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey3};
+    }
+
+    :hover:not(:disabled) {
+        border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey2};
+    }
+
+    :active:not(:disabled) {
+        border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey3};
+    }
+
+    :disabled {
+        cursor: not-allowed;
+    }
+
+    ::placeholder {
+        font-style: italic;
+    }
+`;
+    const TooltipWrapper = styled__default.default.div`
+    position: relative;
+
+    display: block;
+
+    max-width: 15rem;
+    padding: 0.75rem 1rem;
+
+    word-break: break-word;
+
+    border-radius: 0.25rem;
+
+    transition: opacity 150ms ease-in-out;
+
+    ${(props) => {
+    if (!props.$hidden) {
+      return `
+            color: ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.blue1};
+            font-size: ${props.theme.font.size};
+            border: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
+
+            background-color: ${props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error};
+            `;
+    }
+  }};
+`;
+    const Arrow = styled__default.default.span`
+    position: absolute;
+
+    ${(props) => {
+    switch (props.placement) {
+      case "top":
+        return "bottom: 3px; left: -3px !important;";
+      case "bottom":
+        return "top: -5px;";
+      case "left":
+        return "right: 3px;";
+      case "right":
+        return "left: -5px;";
+      default:
+        return "display: none;";
+    }
+  }}
+
+    ${(props) => {
+    if (props.$hidden) {
+      return "display: none;";
+    }
+  }}
+
+    &::before {
+        content: '';
+
+        position: absolute;
+
+        ${(props) => {
+    switch (props.placement) {
+      case "top":
+      case "bottom":
+        return "transform: rotate(45deg);";
+      case "left":
+        return "transform: rotate(135deg);";
+      case "right":
+        return "transform: rotate(-45deg);";
+      default:
+        return "display: none;";
+    }
+  }}
+
+        width: 0.5rem;
+        height: 0.5rem;
+
+        background: ${(props) => {
+    return props.styling === "default" ? props.theme.colors.grey2 : props.theme.colors.error;
+  }};
+        ${(props) => {
+    if (props.placement === "top") {
+      return `border-bottom: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};
+                        border-right: 1px solid ${props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown};`;
+    }
+    return `
+    border - top: 1 px solid $ {
+        props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
+    };
+    border - left: 1 px solid $ {
+        props.styling === "default" ? props.theme.colors.grey5 : props.theme.colors.errorDown
+    };
+    `;
+  }}
+    }
+`;
+
+    function Tooltip({
+        appendTo = document.body,
+        getReferenceClientRect,
+        children: children2,
+        className,
+        content: content2,
+        disabled: disabled2,
+        hideOnClick = true,
+        interactive,
+        visible,
+        placement = "auto",
+        styling = "default",
+        followCursor: followCursor$1 = false,
+        hidden = false,
+        style: style2,
+        delay = 0,
+        onClickOutside = () => false
+    }) {
+        return jsxRuntime.exports.jsx(Tippy, {
+            appendTo,
+            arrow: true,
+            delay,
+            disabled: disabled2,
+            followCursor: followCursor$1,
+            getReferenceClientRect,
+            hideOnClick: visible !== void 0 ? void 0 : hideOnClick,
+            interactive,
+            onClickOutside,
+            placement,
+            plugins: [followCursor],
+            render: (attrs2) => jsxRuntime.exports.jsxs(TooltipWrapper, Object.assign({
+                "$hidden": hidden,
+                className,
+                style: style2,
+                styling
+            }, attrs2, {
+                children: [content2, jsxRuntime.exports.jsx(Arrow, {
+                    "$hidden": hidden,
+                    "data-popper-arrow": "",
+                    placement: attrs2["data-placement"],
+                    styling
+                })]
+            })),
+            visible,
+            zIndex: 9998,
+            children: children2
+        });
+    }
+    const InteractiveIcons = styled__default.default.div`
+    position: absolute;
+    top: 0.75rem;
+    left: 236px;
+
+    display: none;
+    gap: 0.5rem;
+
+    padding: 0.3rem;
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+`;
+    styled__default.default.div`
+    position: relative;
+
+    gap: 0.5rem;
+
+    width: 100%;
+    padding: 1rem;
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+
+    :hover ${InteractiveIcons} {
+        display: flex;
+    }
+`;
+    styled__default.default.div`
+    display: flex;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 1.625rem;
+
+    font-size: 0.8rem;
+    color: ${(props) => props.theme.colors.grey5};
+`;
+    styled__default.default.span`
+    width: 100%;
+    color: ${(props) => props.theme.colors.text};
+    overflow-wrap: break-word;
+`;
+    styled__default.default.span`
+    font-size: 0.8rem;
+    color: ${(props) => props.theme.colors.grey4};
+`;
+    styled__default.default(Trash)`
+    height: 0.8rem;
+    color: ${(props) => props.theme.colors.secondary};
+
+    :hover {
+        color: ${(props) => props.theme.colors.secondaryHover}CC;
+    }
+
+    :active {
+        color: ${(props) => props.theme.colors.secondaryDown}99;
+    }
+`;
+    styled__default.default(PenToSquare)`
+    height: 0.8rem;
+    color: ${(props) => props.theme.colors.secondary};
+
+    :hover {
+        color: ${(props) => props.theme.colors.secondaryHover}CC;
+    }
+
+    :active {
+        color: ${(props) => props.theme.colors.secondaryDown}99;
+    }
+`;
+    styled__default.default.div`
+    display: flex;
+    gap: 1rem;
+    justify-content: flex-end;
+`;
+    styled__default.default.div`
+    overflow-y: auto;
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
+
+    width: 350px;
+    height: calc(100vh - 2rem);
+    margin: 1rem;
+    padding: 1.5rem;
+
+    background-color: ${(props) => props.theme.colors.background}e6;
+    border-radius: 0.4rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+`;
+    styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
+    justify-self: flex-end;
+
+    height: 8.6rem;
+    margin-top: auto;
+`;
+    styled__default.default.div`
+    display: flex;
+    gap: 1rem;
+    justify-content: flex-end;
+`;
+    styled__default.default.div`
+    overflow-y: auto;
+    display: flex;
+    flex-direction: column;
+    gap: 1rem;
+
+    max-height: calc(100% - 10.225rem);
+    margin: -0.25rem;
+    padding: 0.25rem;
+`;
+    styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 1.625rem;
+
+    font-size: 1.2rem;
+`;
+    styled__default.default(Xmark)`
+    height: 1.2rem;
+    color: ${(props) => props.theme.colors.grey4};
+
+    :hover {
+        color: ${(props) => props.theme.colors.grey5};
+    }
+
+    :active {
+        color: ${(props) => props.theme.colors.grey6};
+    }
+`;
+    const CheckboxWrapper$1 = styled__default.default.label`
+    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+    user-select: none;
+
+    position: relative;
+
+    display: flex;
+    align-items: center;
+
+    width: ${(props) => props.isListStyle ? "100%" : "fit-content"};
+    padding: 0.5625rem 0 0.5625rem 2rem;
+
+    font-size: 1rem;
+
+    border-radius: 0.25rem;
+
+    ${(props) => {
+    if (props.isListStyle && !props.disabled) {
+      return `
+                :hover {
+                    background-color: ${props.theme.colors.grey1};
+
+                    span {
+                        border: 1px solid ${props.theme.colors.grey4};
+                    }
+                }
+
+                :active {
+                    background-color: ${props.theme.colors.grey2};
+                }
+        `;
+    }
+  }}
+
+    /* sets checkmark indicator */
+    span::after {
+        top: 0.05rem;
+        left: 0.3rem;
+        transform: rotate(45deg);
+
+        width: 0.3125rem;
+        height: 0.625rem;
+
+        border: solid ${(props) => props.theme.colors.grey5};
+        border-width: 0 2px 2px 0;
+    }
+
+    /* Show the checkmark when checked */
+    input:checked ~ span::after {
+        display: block;
+    }
+
+    :hover {
+        span,
+        input:checked ~ span {
+            background-color: ${(props) => {
+    if (props.disabled) {
+      return props.theme.colors.grey3;
+    }
+    if (props.isListStyle) {
+      return props.theme.colors.blue1;
+    }
+    return props.theme.colors.grey1;
+  }};
+            border: 1px solid ${(props) => props.theme.colors.grey4};
+        }
+    }
+
+    /* stylelint-disable -- messy specificity ordering */
+    :active {
+        span,
+        input:checked ~ span {
+            background-color: ${(props) => {
+    if (props.disabled) {
+      return props.theme.colors.grey3;
+    }
+    if (props.isListStyle) {
+      return props.theme.colors.blue1;
+    }
+    return props.theme.colors.grey2;
+  }};
+        }
+    }
+`;
+    const StyledCheckbox = styled__default.default.input`
+    cursor: pointer;
+
+    /* Hide the browser's default checkbox */
+    position: absolute;
+
+    width: 0;
+    height: 0;
+
+    opacity: 0;
+
+    :checked ~ span {
+        background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
+    }
+`;
+    const StyledCheckmark = styled__default.default.span`
+    position: absolute;
+    left: 0.5rem;
+
+    width: 1rem;
+    height: 1rem;
+
+    background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue1};
+    border: 1px solid ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.grey4};
+    border-radius: 0.25rem;
+
+    // hidden checkmark indicator
+    :after {
+        content: '';
+        position: absolute;
+        display: none;
+    }
+`;
+
+    function Checkbox(props) {
+        const [checked, setChecked] = React.useState(props.selected || props.initialValue);
+        React.useEffect(() => {
+            if (props.selected !== void 0) {
+                setChecked(props.selected);
+            }
+        }, [props.selected]);
+        const onClick = (e3) => {
+            if (props.disabled) {
+                return;
+            }
+            if (props.selected === void 0) {
+                setChecked(!checked);
+            }
+            if (props.onChange) {
+                props.onChange(!checked, e3);
+            }
+        };
+        return jsxRuntime.exports.jsxs(CheckboxWrapper$1, {
+            className: props.className,
+            disabled: props.disabled,
+            isListStyle: props.isListStyle,
+            children: [props.label, jsxRuntime.exports.jsx(StyledCheckbox, {
+                "aria-disabled": props.disabled,
+                checked: props.selected,
+                disabled: props.disabled,
+                isListStyle: props.isListStyle,
+                onChange: (e3) => onClick(e3),
+                onClick: props.onClick,
+                type: "checkbox",
+                value: props.id
+            }), jsxRuntime.exports.jsx(StyledCheckmark, {
+                disabled: props.disabled,
+                isListStyle: props.isListStyle
+            })]
+        });
+    }
+    const CheckboxWrapper = styled__default.default.div`
+    user-select: none;
+    display: flex;
+    width: 100%;
+    border: none;
+`;
+    const CheckboxGroupWrapper = styled__default.default.div`
+    color: ${(props) => props.theme.colors.text};
+`;
+    const CheckboxInfo = styled__default.default.p`
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.grey4};
+`;
+
+    function getInitialValue$1(initialValue) {
+        if (Array.isArray(initialValue)) {
+            return initialValue;
+        }
+        if (initialValue) {
+            return [initialValue];
+        }
+        return [];
+    }
+
+    function getInitialCheckedState(items, initialValues) {
+        if (initialValues) {
+            return items.map((item) => ({
+                state: initialValues.includes(item.value),
+                value: item.value
+            }));
+        }
+        return items.map((item) => ({
+            state: initialValues.includes(item.value),
+            value: false
+        }));
+    }
+
+    function CheckboxGroup(props) {
+        const [values, setValues] = React.useState(() => getInitialValue$1(props.values || props.initialValue));
+        const [checkedState, setCheckedState] = React.useState(() => getInitialCheckedState(props.items, values));
+        const isSelectPermitted = React.useMemo(() => {
+            if (!props.selectMax || values.length < props.selectMax) {
+                return true;
+            }
+            return false;
+        }, [values, props.selectMax]);
+        const infoMessage = React.useMemo(() => {
+            if (props.selectMax && props.selectMin) {
+                return `You can select from ${props.selectMin} to ${props.selectMax} options`;
+            }
+            if (props.selectMax) {
+                return `You can select up to ${props.selectMax} options`;
+            }
+            if (props.selectMin) {
+                return `You should select at least ${props.selectMin} options`;
+            }
+        }, [props.selectMax, props.selectMin]);
+        const onChangeValue = (event2) => {
+            var _a3;
+            const target = event2.target;
+            const chosenIndex = Number(target.value);
+            const chosenValue = props.items[chosenIndex].value;
+            let newValues = [...values];
+            if (values.includes(chosenValue)) {
+                newValues = newValues.filter((value) => value !== chosenValue);
+            } else {
+                newValues.push(chosenValue);
+            }
+            if (newValues.length > props.selectMax && checkedState[chosenIndex] || newValues.length <= props.selectMax || !props.selectMax) {
+                const indexToUpdate = checkedState.findIndex((item) => item.value === chosenValue);
+                checkedState[indexToUpdate].state = !checkedState[indexToUpdate].state;
+                setCheckedState(checkedState);
+                setValues(newValues);
+                if (!props.selectMin || newValues.length >= props.selectMin) {
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, props.items.filter((item) => newValues.includes(item.value)), event2);
+                }
+            }
+        };
+        React.useEffect(() => {
+            if (props.values) {
+                const valuesArray = props.values.map((value) => value.value);
+                setCheckedState(props.items.map((item) => ({
+                    state: valuesArray.includes(item.value),
+                    value: item.value
+                })));
+                setValues(valuesArray);
+            }
+        }, [props.values, props.items]);
+        return jsxRuntime.exports.jsxs(CheckboxGroupWrapper, {
+            className: props.className,
+            style: props.style,
+            children: [(props.selectMax || props.selectMin) && jsxRuntime.exports.jsx(CheckboxInfo, {
+                children: infoMessage
+            }), props.items.map((item, index2) => {
+                var _a3, _b;
+                return jsxRuntime.exports.jsx(CheckboxWrapper, {
+                    "aria-disabled": props.disabled,
+                    children: jsxRuntime.exports.jsx(Checkbox, {
+                        disabled: isSelectPermitted ? props.disabled : ((_a3 = checkedState.find((option) => option.value === item.value)) === null || _a3 === void 0 ? void 0 : _a3.state) === false,
+                        id: index2,
+                        isListStyle: props.isListStyle,
+                        label: item.label ? item.label : item.value,
+                        onChange: (checked, e3) => onChangeValue(e3),
+                        selected: (_b = checkedState.find((option) => option.value === item.value)) === null || _b === void 0 ? void 0 : _b.state
+                    })
+                }, `item-${index2}`);
+            })]
+        });
+    }
+    var __rest$a = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const PrimaryInput = styled__default.default.input`
+    display: flex;
+    align-items: center;
+
+    width: 100%;
+    height: 100%;
+    padding: 0 1rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    outline: 0;
+
+    :active:not(:disabled),
+    :focus:not(:disabled) {
+        border: 1px solid ${(props) => props.isErrored ? props.theme.colors.error : props.theme.colors.grey3};
+    }
+
+    :hover:not(:disabled) {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    :disabled {
+        cursor: not-allowed;
+    }
+
+    ::placeholder {
+        font-style: italic;
+    }
+`;
+    const InputWrapper$3 = styled__default.default.div`
+    width: 22ch;
+    max-width: 100%;
+    height: 2.5rem;
+`;
+    const ErrorMessage$1 = styled__default.default.span`
+    margin-left: 1rem;
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.error};
+`;
+    const Input$1 = React.forwardRef((_a3, ref2) => {
+        var {
+            type: type2 = "text"
+        } = _a3, props = __rest$a(_a3, ["type"]);
+        const onChange2 = (e3) => {
+            const target = e3.target;
+            if (props.onChange) {
+                props.onChange(target.value, e3);
+            }
+        };
+        const onKeyDown = (e3) => {
+            if (props.onKeyDown) {
+                props.onKeyDown(e3);
+            }
+            if (props.keydownFilter && !props.keydownFilter(e3)) {
+                e3.preventDefault();
+            }
+            if (e3.key === Key.ENTER && props.onComplete) {
+                props.onComplete();
+            }
+        };
+        const addOptionalItems = () => {
+            const result = {};
+            if (props.minValue) {
+                result.minValue = props.minValue;
+            }
+            if (props.maxValue) {
+                result.maxValue = props.minValue;
+            }
+            return result;
+        };
+        return jsxRuntime.exports.jsxs(InputWrapper$3, {
+            className: props.className,
+            style: props.style,
+            children: [jsxRuntime.exports.jsx(PrimaryInput, Object.assign({
+                autoFocus: props.autoFocus,
+                defaultValue: props.initialValue,
+                disabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                maxLength: props.maxLength,
+                onBlur: props.onBlur,
+                onChange: onChange2,
+                onClick: props.onClick,
+                onKeyDown,
+                placeholder: props.placeholder,
+                ref: ref2,
+                type: type2,
+                value: props.value
+            }, addOptionalItems())), props.errorMsg && jsxRuntime.exports.jsxs(ErrorMessage$1, {
+                children: [props.errorMsg, " "]
+            })]
+        });
+    });
+    Input$1.displayName = "Input";
+    const Wrapper$6 = styled__default.default.div`
+    display: flex;
+    margin: 0 0.5rem;
+`;
+    const SearchBarComponent = styled__default.default(Input$1)`
+    input {
+        padding-right: 2.25rem;
+    }
+
+    :hover:not(:disabled) {
+        input {
+            border: 1px solid ${(props) => props.theme.colors.grey3};
+        }
+    }
+`;
+    const SearchBarIcon = styled__default.default(MagnifyingGlass)`
+    position: relative;
+    top: 0.625rem;
+    right: 1.75rem;
+
+    height: 1.25rem;
+
+    color: ${(props) => props.theme.colors.grey4};
+`;
+
+    function SearchBar(props) {
+        var _a3;
+        return jsxRuntime.exports.jsxs(Wrapper$6, {
+            children: [jsxRuntime.exports.jsx(SearchBarComponent, {
+                className: props.className,
+                disabled: props.disabled,
+                maxLength: props.maxLength,
+                onChange: props.onChange,
+                placeholder: (_a3 = props.placeholder) !== null && _a3 !== void 0 ? _a3 : "Search",
+                style: props.style,
+                value: props.value
+            }), jsxRuntime.exports.jsx(SearchBarIcon, {})]
+        });
+    }
+    const FilterWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 0.5rem;
+
+    width: 17.5rem;
+    padding: 1.25rem 0.5rem;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const StyledSearchBar = styled__default.default(SearchBar)`
+    width: 15.5rem;
+    background-color: ${(props) => props.theme.colors.blue1};
+    border: 1px solid ${(props) => props.theme.colors.blue1};
+    border-radius: 0.25rem;
+
+    input {
+        width: 15.5rem;
+        background-color: ${(props) => props.theme.colors.blue1};
+        border: none;
+
+        :active:not(:disabled),
+        :focus:not(:disabled) {
+            border: none;
+        }
+    }
+
+    :hover:not(:disabled) {
+        background-color: ${(props) => props.theme.colors.blue1};
+        border: 1px solid ${(props) => props.theme.colors.grey2};
+
+        input {
+            background-color: ${(props) => props.theme.colors.blue1};
+            border: none;
+        }
+    }
+`;
+    const FilterButtons = styled__default.default.button`
+    font-size: 0.75rem;
+    font-weight: 400;
+    color: ${(props) => props.theme.colors.primary};
+
+    background-color: inherit;
+    border: none;
+
+    :hover {
+        cursor: pointer;
+        color: ${(props) => props.theme.colors.primaryHover};
+    }
+
+    :active {
+        color: ${(props) => props.theme.colors.primaryDown};
+    }
+
+    :disabled {
+        cursor: not-allowed;
+        color: ${(props) => props.theme.colors.grey2};
+    }
+`;
+    const OptionsWrapper = styled__default.default.div`
+    overflow-y: auto;
+    height: 10rem;
+`;
+    const StyledCheckboxGroup = styled__default.default(CheckboxGroup)`
+    div {
+        height: 2rem;
+        padding: 0 0.75rem;
+    }
+
+    label {
+        font-size: 0.75rem;
+
+        :hover {
+            background: ${(props) => props.theme.colors.grey2} !important;
+        }
+
+        :active {
+            background: ${(props) => props.theme.colors.grey3} !important;
+        }
+    }
+`;
+    const ApplyButton = styled__default.default(FilterButtons)`
+    align-self: center;
+
+    width: fit-content;
+    height: 2rem;
+    padding: 0.5rem;
+
+    font-size: 0.875rem;
+`;
+
+    function CategoricalFilter(props) {
+        var _a3;
+        const [inputValue, setInputValue] = React.useState("");
+        const [filterValue, setFilterValue] = React.useState((_a3 = props.values) !== null && _a3 !== void 0 ? _a3 : []);
+        const [previousFilter, setPreviousFilter] = React.useState(props.values);
+        const filteredItems = props.items.filter((item) => {
+            var _a4;
+            return inputValue ? (_a4 = item.label) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase().includes(inputValue === null || inputValue === void 0 ? void 0 : inputValue.toLowerCase()) : true;
+        });
+        return jsxRuntime.exports.jsxs(FilterWrapper, {
+            className: props.className,
+            children: [jsxRuntime.exports.jsx(StyledSearchBar, {
+                onChange: (change) => setInputValue(change)
+            }), jsxRuntime.exports.jsxs("div", {
+                style: {
+                    display: "flex",
+                    height: "2rem",
+                    margin: "0rem 0.75rem -0.5rem 0.75rem"
+                },
+                children: [jsxRuntime.exports.jsx(FilterButtons, {
+                    onClick: () => setFilterValue(filteredItems),
+                    children: "Select all"
+                }), jsxRuntime.exports.jsx(FilterButtons, {
+                    onClick: () => setFilterValue([]),
+                    children: "Clear"
+                })]
+            }), jsxRuntime.exports.jsx(OptionsWrapper, {
+                children: jsxRuntime.exports.jsx(StyledCheckboxGroup, {
+                    isListStyle: true,
+                    items: filteredItems,
+                    onChange: (v2) => {
+                        var _a4, _b;
+                        const selectedFilteredItems = Array.isArray(v2) ? v2 : [v2];
+                        const unchecked = (_a4 = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => selectedFilteredItems.every((item) => !isEqual_1(value, item)) && filteredItems.some((item) => isEqual_1(value, item)))) !== null && _a4 !== void 0 ? _a4 : [];
+                        const newlyChecked = selectedFilteredItems.filter((value) => filterValue === null || filterValue === void 0 ? void 0 : filterValue.every((item) => !isEqual_1(value, item)));
+                        const stillChecked = (_b = filterValue === null || filterValue === void 0 ? void 0 : filterValue.filter((value) => !unchecked.some((item) => isEqual_1(value, item)))) !== null && _b !== void 0 ? _b : [];
+                        setFilterValue([...stillChecked, ...newlyChecked]);
+                    },
+                    values: filterValue
+                })
+            }), jsxRuntime.exports.jsx(ApplyButton, {
+                disabled: props.disabled || previousFilter === filterValue,
+                onClick: (e3) => {
+                    var _a4, _b;
+                    (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, filterValue, e3);
+                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filterValue || void 0);
+                    setPreviousFilter(filterValue);
+                },
+                children: "Apply"
+            })]
+        });
+    }
+    var fromEntries = function fromEntries2(entries) {
+        return entries.reduce(function(acc, _ref2) {
+            var key = _ref2[0],
+                value = _ref2[1];
+            acc[key] = value;
+            return acc;
+        }, {});
+    };
+    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
+    var EMPTY_MODIFIERS = [];
+    var usePopper = function usePopper2(referenceElement, popperElement, options) {
+        if (options === void 0) {
+            options = {};
+        }
+        var prevOptions = React__namespace.useRef(null);
+        var optionsWithDefaults = {
+            onFirstUpdate: options.onFirstUpdate,
+            placement: options.placement || "bottom",
+            strategy: options.strategy || "absolute",
+            modifiers: options.modifiers || EMPTY_MODIFIERS
+        };
+        var _React$useState = React__namespace.useState({
+                styles: {
+                    popper: {
+                        position: optionsWithDefaults.strategy,
+                        left: "0",
+                        top: "0"
+                    },
+                    arrow: {
+                        position: "absolute"
+                    }
+                },
+                attributes: {}
+            }),
+            state = _React$useState[0],
+            setState = _React$useState[1];
+        var updateStateModifier = React__namespace.useMemo(function() {
+            return {
+                name: "updateState",
+                enabled: true,
+                phase: "write",
+                fn: function fn2(_ref2) {
+                    var state2 = _ref2.state;
+                    var elements = Object.keys(state2.elements);
+                    ReactDOM__namespace.flushSync(function() {
+                        setState({
+                            styles: fromEntries(elements.map(function(element2) {
+                                return [element2, state2.styles[element2] || {}];
+                            })),
+                            attributes: fromEntries(elements.map(function(element2) {
+                                return [element2, state2.attributes[element2]];
+                            }))
+                        });
+                    });
+                },
+                requires: ["computeStyles"]
+            };
+        }, []);
+        var popperOptions = React__namespace.useMemo(function() {
+            var newOptions = {
+                onFirstUpdate: optionsWithDefaults.onFirstUpdate,
+                placement: optionsWithDefaults.placement,
+                strategy: optionsWithDefaults.strategy,
+                modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
+                    name: "applyStyles",
+                    enabled: false
+                }])
+            };
+            if (reactFastCompare(prevOptions.current, newOptions)) {
+                return prevOptions.current || newOptions;
+            } else {
+                prevOptions.current = newOptions;
+                return newOptions;
+            }
+        }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
+        var popperInstanceRef = React__namespace.useRef();
+        useIsomorphicLayoutEffect$1(function() {
+            if (popperInstanceRef.current) {
+                popperInstanceRef.current.setOptions(popperOptions);
+            }
+        }, [popperOptions]);
+        useIsomorphicLayoutEffect$1(function() {
+            if (referenceElement == null || popperElement == null) {
+                return;
+            }
+            var createPopper2 = options.createPopper || createPopper$1;
+            var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
+            popperInstanceRef.current = popperInstance;
+            return function() {
+                popperInstance.destroy();
+                popperInstanceRef.current = null;
+            };
+        }, [referenceElement, popperElement, options.createPopper]);
+        return {
+            state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
+            styles: state.styles,
+            attributes: state.attributes,
+            update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
+            forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
+        };
+    };
+    const Wrapper$5 = styled__default.default.div`
+    display: inline-flex;
+
+    width: 100%;
+    min-width: 4rem;
+    height: 2.5rem;
+
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey2};
+
+                svg {
+                    color: ${props.theme.colors.grey2};
+                }
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
+    };: hover {
+        border: 1 px solid $ {
+            props.theme.colors.grey3
+        };
+
+    }
+    `;
+  }}
+`;
+    const InputWrapper$2 = styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: calc(100% - 1rem);
+    height: 100%;
+    padding: 0 0.25rem 0 1rem;
+
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0px 0px" : "0.25rem"};
+
+    :hover {
+        background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+    }
+
+    svg {
+        height: 0.8rem;
+    }
+`;
+    const Input = styled__default.default.input`
+    overflow: hidden;
+    flex: 1 1 auto;
+
+    height: 100%;
+    margin-right: 0.5rem;
+    padding: 0;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+    color: ${(props) => props.theme.colors.text};
+    text-align: left;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: transparent;
+    border: none;
+    outline: 0;
+
+    :disabled {
+        cursor: not-allowed;
+        color: ${(props) => props.theme.colors.grey2};
+    }
+`;
+    const NoItemsLabel = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: center;
+
+    height: 2rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+`;
+    styled__default.default(List)`
+    margin-left: -1px;
+    border-radius: 0 0 0.25rem 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const ChevronButton = styled__default.default(Button$1).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
+        styling: "ghost"
+    }))`
+    min-width: 0;
+    height: auto;
+    margin: 0;
+    padding: 0 0.25rem;
+
+    background-color: transparent !important;
+`;
+    styled__default.default(List)`
+    overflow-y: auto;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    var __rest$9 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const {
+        stateChangeTypes: stateChangeTypes$1
+    } = useSelect;
+    const SelectedItem$1 = styled__default.default.div`
+    width: 100%;
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+`;
+    const Wrapper$4 = styled__default.default.div`
+    display: inline-flex;
+    width: 6.25rem;
+    height: 1.5rem;
+    border-radius: 0.25rem;
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey1};
+                cursor: not-allowed;
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.theme.colors.grey1
+    };
+    `;
+  }}
+`;
+    const SelectButton$1 = styled__default.default.button`
+    cursor: pointer;
+
+    display: inline-flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 100%;
+    padding: 0 0.5rem 0 1rem;
+
+    font-size: ${(props) => props.theme.font.size};
+
+    border: none;
+    outline: 0;
+
+    :not(:enabled) {
+        cursor: not-allowed;
+    }
+`;
+    const SelectButtonPrimary = styled__default.default(SelectButton$1)`
+    justify-content: start;
+
+    width: 100%;
+    padding: 0 0.25rem;
+
+    font-size: 0.875rem;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+
+    :hover:enabled {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    svg {
+        width: 1rem !important;
+        height: 0.8rem;
+        margin-left: 0.5rem !important;
+    }
+
+    :disabled {
+        color: ${(props) => props.theme.colors.grey2};
+
+        svg {
+            color: ${(props) => props.theme.colors.grey2};
+        }
+    }
+`;
+    const DatepickerListItem = styled__default.default.span`
+    cursor: pointer;
+    user-select: none;
+
+    overflow: hidden;
+    display: flex;
+    align-items: center;
+
+    width: 100%;
+    min-height: 2rem;
+    padding: 0.25rem 1.5rem;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+    color: ${(props) => props.isSelected ? "#FFF" : props.theme.colors.text};
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: ${(props) => {
+    if (props.isSelected) {
+      return props.theme.colors.primary;
+    }
+    if (props.hovered) {
+      return props.theme.colors.grey2;
+    }
+    return props.theme.colors.grey1;
+  }};
+
+    :active {
+        background-color: ${(props) => props.theme.colors.grey1};
+    }
+
+    &:last-child {
+        border-bottom: none;
+    }
+`;
+    const DropdownList$1 = styled__default.default.div`
+    overflow-y: auto;
+    display: ${(props) => props.isOpen ? "flex" : "none"};
+    flex-direction: column;
+    gap: 0.125rem;
+
+    max-height: calc(${(props) => (props.maxItems || 5) * 2}em + 2px);
+    margin-left: ${(props) => props.displacement}rem;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    outline: 0;
+`;
+
+    function DatepickerSelect(props) {
+        var _a3, _b, _c;
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier],
+            placement: props.placement || "bottom-start"
+        });
+        const [pendingHighlight, setPendingHighlight] = React.useState(null);
+        const {
+            isOpen,
+            selectedItem,
+            getToggleButtonProps,
+            getMenuProps,
+            highlightedIndex,
+            getItemProps,
+            setHighlightedIndex
+        } = useSelect(Object.assign({
+            initialSelectedItem: props.initialValue,
+            itemToString: (item) => item.label,
+            items: props.items,
+            onSelectedItemChange: (changes) => {
+                const selected = changes.selectedItem;
+                if (props.onSelect) {
+                    props.onSelect(selected);
+                }
+            },
+            stateReducer: (state, {
+                changes,
+                type: type2
+            }) => {
+                if (type2 === stateChangeTypes$1.ToggleButtonClick) {
+                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
+                }
+                return changes;
+            }
+        }, props.selectedItem && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && pendingHighlight !== null) {
+                setHighlightedIndex(pendingHighlight);
+                setPendingHighlight(null);
+            }
+        }, [isOpen, pendingHighlight, setHighlightedIndex]);
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
+            }
+        }, [isOpen, update2]);
+        const buttonProps = getToggleButtonProps({
+            disabled: props.disabled
+        });
+        const setButtonRef = buttonProps.ref;
+        delete buttonProps.ref;
+        const setButtonReference = (value) => {
+            setButtonRef(value);
+            referenceElement.current = value;
+        };
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            var _a4;
+            setMenuRef(value);
+            popperElement.current = value;
+            (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
+        };
+        return jsxRuntime.exports.jsx(Tooltip, {
+            content: props.errorMsg,
+            disabled: !props.errorMsg,
+            styling: "error",
+            children: jsxRuntime.exports.jsxs(Wrapper$4, {
+                className: props.className,
+                isDisabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                onClick: props.onClick,
+                style: props.style,
+                children: [jsxRuntime.exports.jsxs(SelectButtonPrimary, Object.assign({
+                    disabled: props.disabled
+                }, buttonProps, {
+                    ref: setButtonReference,
+                    type: "button",
+                    children: [jsxRuntime.exports.jsx(SelectedItem$1, {
+                        size: props.size,
+                        children: selectedItem ? selectedItem.label : "Select"
+                    }), jsxRuntime.exports.jsx(Chevron$2, {
+                        disabled: props.disabled,
+                        isOpen
+                    })]
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList$1, Object.assign({}, menuProps, attributes2.popper, {
+                    className: `${(_a3 = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _a3 !== void 0 ? _a3 : ""} ${(_c = (_b = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _b === void 0 ? void 0 : _b.className) !== null && _c !== void 0 ? _c : ""} ${props.itemClass}`,
+                    displacement: props.displacement,
+                    isOpen,
+                    maxItems: 7,
+                    ref: setMenuReference,
+                    style: Object.assign(Object.assign({}, styles2.popper), {
+                        marginTop: `0.8rem`,
+                        width: "16.25rem",
+                        zIndex: 9999
+                    }),
+                    children: props.items.map((item, index2) => {
+                        const _a4 = getItemProps({
+                                index: index2,
+                                item
+                            }),
+                            {
+                                itemClassName
+                            } = _a4,
+                            itemProps = __rest$9(_a4, ["itemClassName"]);
+                        return React.createElement(DatepickerListItem, Object.assign({}, itemProps, {
+                            "aria-selected": selectedItem.label === item.label,
+                            className: `${itemClassName} ${props.itemClass}`,
+                            hovered: index2 === highlightedIndex,
+                            isSelected: selectedItem.label === item.label,
+                            key: `item-${index2}`,
+                            size: props.size,
+                            title: item.label
+                        }), item.label);
+                    })
+                })), document.body)]
+            })
+        });
+    }
+
+    function getMonths() {
+        const months = [];
+        for (let i2 = 0; i2 < 12; i2++) {
+            months.push({
+                label: enGB.localize.month(i2),
+                value: i2
+            });
+        }
+        return months;
+    }
+
+    function getYears(minDate, maxDate) {
+        var _a3, _b;
+        const minYear = (_a3 = minDate === null || minDate === void 0 ? void 0 : minDate.getFullYear()) !== null && _a3 !== void 0 ? _a3 : 1900;
+        const maxYear = (_b = maxDate === null || maxDate === void 0 ? void 0 : maxDate.getFullYear()) !== null && _b !== void 0 ? _b : 2100;
+        return lodash$1.exports.range(minYear, maxYear + 1, 1).map((val) => ({
+            label: val.toString(),
+            value: val
+        }));
+    }
+    const IGNORE_CLASSNAME = "react-datepicker-ignore-onclickoutside";
+    const DatepickerWrapper$1 = styled__default.default.div`
+    /* stylelint-disable selector-class-pattern */
+    display: flex;
+    flex-direction: ${(props) => props.inline ? "column" : "row"};
+    align-items: ${(props) => props.inline ? "baseline" : "center"};
+
+    width: 8.5rem;
+
+    color: ${(props) => props.theme.colors.text};
+
+    .react-datepicker-popper {
+        z-index: 5;
+        width: 16.45rem;
+        height: 18.5rem;
+    }
+
+    .react-datepicker-wrapper {
+        width: auto;
+        margin-top: 1rem;
+        margin-left: -8.5rem;
+
+        ${(props) => {
+    if (props.showsRange && props.showsTime) {
+      return `margin-left: -19.045rem;
+                margin-top: 3rem;`;
+    }
+    if (props.showsRange) {
+      return `
+    margin - left: -19.045 rem;
+    `;
+    }
+    if (props.showsTime) {
+      return `
+    margin - left: -14 rem;
+    `;
+    }
+  }}
+    }
+
+    .react-datepicker {
+        width: 16.45rem;
+        height: 18.5rem;
+
+        font-family: Manrope, sans-serif;
+        font-size: 0.75rem;
+
+        background-color: ${(props) => props.theme.colors.grey1};
+        border: 1px solid ${(props) => props.theme.colors.grey1};
+        box-shadow: ${(props) => props.theme.shadow.light};
+
+        svg {
+            cursor: pointer;
+        }
+
+        .react-datepicker__triangle {
+            visibility: hidden;
+        }
+
+        .react-datepicker__input-time-container {
+            position: absolute;
+            top: -51px;
+            left: 150px;
+
+            float: none;
+
+            margin: 0;
+
+            color: ${(props) => props.theme.colors.text};
+
+            .react-datepicker-time__caption {
+                display: none;
+            }
+        }
+
+        .react-datepicker__month-container {
+            .react-datepicker__header {
+                margin-right: 3px;
+                margin-left: 3px;
+                padding: 1.25em 0.75em 0;
+
+                color: ${(props) => props.theme.colors.text};
+
+                background-color: ${(props) => props.theme.colors.grey1};
+                border: none;
+
+                .react-datepicker__day-names {
+                    display: flex;
+                    gap: 0.125rem;
+                    justify-content: space-around;
+                    margin-bottom: 0;
+
+                    .react-datepicker__day-name {
+                        width: 2rem;
+                        height: 2rem;
+                        margin: 0;
+
+                        line-height: 2rem;
+                        color: ${(props) => props.theme.colors.text};
+                    }
+                }
+            }
+
+            .react-datepicker__month {
+                display: grid;
+                gap: 0.125rem;
+
+                /* Switch default margin to padding so it applies background color completely */
+                margin: 0;
+                padding: 0.125rem 0.75rem 0;
+
+                color: ${(props) => props.theme.colors.text};
+
+                background-color: ${(props) => props.theme.colors.grey1};
+
+                .react-datepicker__week {
+                    display: flex;
+                    gap: 0.125rem;
+                }
+
+                .react-datepicker__day {
+                    width: 2rem;
+                    height: 2rem;
+                    margin: 0;
+
+                    line-height: 2rem;
+                    color: ${(props) => props.theme.colors.text};
+
+                    :hover {
+                        background-color: ${(props) => props.theme.colors.grey2};
+                    }
+
+                    &.react-datepicker__day--outside-month {
+                        color: ${(props) => props.theme.colors.grey4};
+                    }
+
+                    &.react-datepicker__day--selected {
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => props.theme.colors.primary};
+
+                        :hover {
+                            background-color: ${(props) => props.theme.colors.primaryHover};
+                        }
+                    }
+
+                    &.react-datepicker__day--keyboard-selected {
+                        color: ${(props) => props.theme.colors.text};
+                        background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primary)};
+                        border: 1px solid ${(props) => props.theme.colors.primary}
+
+                        :hover {
+                            background-color: ${(props) => curriedTransparentize$2(0.6, props.theme.colors.primary)};
+                        }
+                    }
+
+                    &.react-datepicker__day--in-range {
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => curriedTransparentize$2(0.2, props.theme.colors.primary)};
+                    }
+
+                    &.react-datepicker__day--in-selecting-range {
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => props.theme.colors.primary};
+                    }
+
+                    &.react-datepicker__day--selecting-range-end {
+                        font-weight: normal;
+                        color: ${(props) => props.theme.colors.blue1};
+                        background-color: ${(props) => props.theme.colors.primary};
+                    }
+
+                    &.react-datepicker__day--disabled {
+                        color: ${(props) => props.theme.colors.grey3};
+
+                        :hover {
+                            background-color: ${(props) => props.theme.colors.grey1};
+                        }
+                    }
+                }
+            }
+        }
+    }
+    /* stylelint-enable selector-class-pattern */
+`;
+    const DatepickerInputs = styled__default.default.div`
+    display: flex;
+    gap: 0.5rem;
+`;
+    const HeaderWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    align-items: center;
+    padding-bottom: 0.75rem;
+`;
+    const MonthNavigation = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+`;
+    const DropdownsWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
+`;
+    const MonthButton = styled__default.default(Button$1)`
+    min-width: 0;
+    height: 1.5rem;
+    margin: 0;
+    padding: 0.75rem 0.37rem;
+
+    svg {
+        width: 0.75rem;
+        height: 0.75rem;
+        color: ${(props) => props.theme.colors.grey5};
+    }
+
+    :hover:not(:disabled) {
+        svg {
+            color: ${(props) => props.theme.colors.text};
+        }
+    }
+`;
+    const MonthSelect = styled__default.default(DatepickerSelect)`
+    width: 6.25rem;
+    margin-right: 0.55em;
+    font-size: 0.875rem;
+`;
+    const YearSelect = styled__default.default(DatepickerSelect)`
+    width: 3.75rem;
+    margin-right: 0.8em;
+`;
+    const EndDateInputWrapper = styled__default.default.div`
+    display: flex;
+    gap: 0.5rem;
+    align-items: center;
+`;
+    const DateTimeWrapper = styled__default.default.div`
+    display: flex;
+    flex-direction: ${(props) => props.isRange ? "column" : "row"};
+    gap: ${(props) => props.isRange ? "none" : "0.5rem"};
+`;
+    const DateInput = styled__default.default.input`
+    display: flex;
+    align-items: center;
+
+    width: 8.5rem;
+    height: 2.5rem;
+    padding: 0 1rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.text};
+    text-align: center;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: 1px solid ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    border-radius: ${(props) => props.isTimeRange ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+    outline: 0;
+
+    :focus:not(:disabled) {
+        border: 1px solid ${(props) => props.theme.colors.grey3};
+    }
+
+    :hover:not(:disabled) {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    :disabled {
+        cursor: not-allowed;
+    }
+
+    ::placeholder {
+        font-style: italic;
+    }
+
+    ::-webkit-calendar-picker-indicator {
+        display: none;
+        background: none;
+    }
+`;
+    const TimeInput = styled__default.default(Input$1)`
+    width: ${(props) => props.isRange ? "8.5rem" : "5rem"};
+
+    input {
+        position: relative;
+
+        display: flex;
+        justify-content: center;
+
+        padding: 0.5rem;
+
+        font-size: 1rem;
+        color: ${(props) => props.theme.colors.text};
+        text-align: center;
+
+        border-radius: ${(props) => props.isRange ? "0rem 0rem 0.25rem 0.25rem" : "0.25rem"};
+
+        :focus:not(:disabled) {
+            border: 1px solid ${(props) => props.theme.colors.grey3};
+        }
+
+        ::-webkit-calendar-picker-indicator {
+            display: none;
+            background: none;
+        }
+
+        ::after {
+            content: '';
+
+            position: absolute;
+            top: 0;
+            left: 1.2rem;
+
+            display: block;
+
+            width: 6rem;
+
+            border-top: ${(props) => props.isRange ? `1px solid ${props.theme.colors.grey2}` : "none"};
+        }
+    }
+`;
+
+    function DatePickerHeader({
+        date,
+        changeMonth,
+        changeYear,
+        decreaseMonth,
+        increaseMonth,
+        selectItemClass,
+        portalsRef,
+        minDate,
+        maxDate
+    }) {
+        const months = React.useMemo(() => getMonths(), []);
+        const years = React.useMemo(() => getYears(minDate, maxDate), [minDate, maxDate]);
+        const selectedMonth = React.useMemo(() => {
+            return {
+                label: enGB.localize.month(date.getMonth()),
+                value: date.getMonth()
+            };
+        }, [date]);
+        const selectedYear = React.useMemo(() => ({
+            label: date.getFullYear().toString(),
+            value: date.getFullYear()
+        }), [date]);
+        return jsxRuntime.exports.jsx(HeaderWrapper, {
+            children: jsxRuntime.exports.jsxs(DropdownsWrapper, {
+                children: [jsxRuntime.exports.jsx(MonthSelect, {
+                    displacement: -1.1,
+                    dropdownRef: (element2) => {
+                        if (portalsRef) {
+                            portalsRef.current[0] = element2;
+                        }
+                    },
+                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
+                    items: months,
+                    onSelect: (item) => changeMonth(item.value),
+                    selectedItem: selectedMonth,
+                    size: 0.875
+                }), jsxRuntime.exports.jsx(YearSelect, {
+                    displacement: -7.8,
+                    dropdownRef: (element2) => {
+                        if (portalsRef) {
+                            portalsRef.current[1] = element2;
+                        }
+                    },
+                    itemClass: `${IGNORE_CLASSNAME} ${selectItemClass}`,
+                    items: years,
+                    onSelect: (item) => changeYear(item.value),
+                    selectedItem: selectedYear,
+                    size: 0.875
+                }), jsxRuntime.exports.jsxs(MonthNavigation, {
+                    children: [jsxRuntime.exports.jsx(MonthButton, {
+                        onClick: decreaseMonth,
+                        styling: "ghost",
+                        children: jsxRuntime.exports.jsx(ChevronLeft, {})
+                    }), jsxRuntime.exports.jsx(MonthButton, {
+                        onClick: increaseMonth,
+                        styling: "ghost",
+                        children: jsxRuntime.exports.jsx(ChevronRight, {})
+                    })]
+                })]
+            })
+        });
+    }
+
+    function getTimeFormatted(time) {
+        const timeString = String(time);
+        if (timeString.length > 1) {
+            return timeString;
+        }
+        return `0${timeString}`;
+    }
+
+    function getInitialTime(initialDate, isRange) {
+        if (!initialDate) {
+            if (isRange) {
+                return ["00:00", "00:00"];
+            }
+            return "00:00";
+        }
+        if (Array.isArray(initialDate)) {
+            return [
+                `${getTimeFormatted(initialDate[0].getHours())}:${getTimeFormatted(initialDate[0].getMinutes())}`,
+                `${getTimeFormatted(initialDate[1].getHours())}:${getTimeFormatted(initialDate[1].getMinutes())}`
+            ];
+        }
+        return `${getTimeFormatted(initialDate.getHours())}:${getTimeFormatted(initialDate.getMinutes())}`;
+    }
+
+    function getInitialDate(initialDate, formatToApply, isStart) {
+        let formattedDate = "";
+        if (initialDate) {
+            if (Array.isArray(initialDate)) {
+                formattedDate = format$2(initialDate[isStart ? 0 : 1], formatToApply);
+            } else {
+                formattedDate = format$2(initialDate, formatToApply);
+            }
+        }
+        return formattedDate;
+    }
+
+    function getNewDatetime(date, time) {
+        var _a3, _b, _c, _d, _e2;
+        if (!Array.isArray(date) && !Array.isArray(time)) {
+            const [hours, minutes] = (_a3 = time === null || time === void 0 ? void 0 : time.split(":")) !== null && _a3 !== void 0 ? _a3 : ["00", "00"];
+            const newDate = date ? new Date(date.setHours(Number(hours), Number(minutes))) : null;
+            return newDate;
+        }
+        const [startHours, startMinutes] = (_c = (_b = time[0]) === null || _b === void 0 ? void 0 : _b.split(":")) !== null && _c !== void 0 ? _c : ["00", "00"];
+        const [endHours, endMinutes] = (_e2 = (_d = time[1]) === null || _d === void 0 ? void 0 : _d.split(":")) !== null && _e2 !== void 0 ? _e2 : ["00", "00"];
+        const dates = date;
+        const startDate = dates[0] ? new Date(dates[0].setHours(Number(startHours), Number(startMinutes))) : null;
+        const endDate = dates[1] ? new Date(dates[1].setHours(Number(endHours), Number(endMinutes))) : null;
+        return [startDate, endDate];
+    }
+
+    function DatePicker(props) {
+        var _a3, _b, _c;
+        const value = (_a3 = props.value) !== null && _a3 !== void 0 ? _a3 : props.initialValue;
+        const [selectedDate, setSelectedDate] = React.useState(value || (props.selectsRange ? [null, null] : null));
+        const [selectedTime, setSelectedTime] = React.useState(() => getInitialTime(value, props.selectsRange));
+        const formatToApply = (_b = props.dateFormat) !== null && _b !== void 0 ? _b : "dd/MM/yyyy";
+        const [startDate, setStartDate] = React.useState(() => getInitialDate(value, formatToApply, true));
+        const [endDate, setEndDate] = React.useState(() => getInitialDate(value, formatToApply, false));
+        const [isSelectingStart, setIsSelectingStart] = React.useState(null);
+        const selectedDateRef = React.useRef(selectedDate);
+        selectedDateRef.current = selectedDate;
+        const datepickerRef = React.useRef(null);
+        const extraProps = React.useMemo(() => {
+            if (props.selectsRange) {
+                const selectedDates = selectedDate !== null && selectedDate !== void 0 ? selectedDate : [null, null];
+                let {
+                    minDate
+                } = props;
+                if (!isSelectingStart) {
+                    const [currentStartDate] = selectedDates;
+                    minDate = currentStartDate;
+                }
+                return {
+                    endDate: selectedDates[1],
+                    minDate,
+                    startDate: selectedDates[0]
+                };
+            }
+            let date = selectedDate;
+            if (Array.isArray(selectedDate)) {
+                [date] = selectedDate;
+            }
+            return {
+                selected: date
+            };
+        }, [selectedDate, isSelectingStart, props]);
+        const onChangeDate = (date) => {
+            var _a4;
+            if (props.shouldCloseOnSelect) {
+                (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(false);
+            }
+            if (props.selectsRange) {
+                let currentStartDate;
+                let currentEndDate;
+                if (isSelectingStart) {
+                    currentStartDate = date;
+                    currentEndDate = Array.isArray(selectedDate) ? selectedDate[1] : null;
+                    currentEndDate = currentEndDate && currentEndDate > date ? currentEndDate : date;
+                } else {
+                    currentStartDate = Array.isArray(selectedDate) ? selectedDate[0] : null;
+                    currentEndDate = date;
+                }
+                setStartDate(format$2(currentStartDate, formatToApply));
+                setEndDate(format$2(currentEndDate, formatToApply));
+                setSelectedDate([currentStartDate, currentEndDate]);
+            } else {
+                setSelectedDate(date);
+                setStartDate(format$2(date, formatToApply));
+            }
+        };
+        const onChangeDateInput = (isStartDate, e3) => {
+            var _a4;
+            const target = e3.target;
+            const newDate = parse$9(target.value, formatToApply, new Date());
+            if (newDate instanceof Date && !Number.isNaN(newDate.valueOf()) && !(newDate < props.minDate) && !(newDate > props.maxDate)) {
+                (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setState({
+                    preSelection: newDate
+                });
+                if (Array.isArray(selectedDate)) {
+                    if (isStartDate) {
+                        let end2 = selectedDate[1];
+                        if (newDate > end2) {
+                            end2 = newDate;
+                            setEndDate(target.value);
+                        }
+                        setSelectedDate([newDate, end2]);
+                        setStartDate(target.value);
+                        return;
+                    }
+                    let start2 = selectedDate[0];
+                    if (newDate < start2) {
+                        start2 = newDate;
+                        setStartDate(target.value);
+                    }
+                    setSelectedDate([start2, newDate]);
+                    setEndDate(target.value);
+                    return;
+                }
+                setSelectedDate(newDate);
+            }
+            if (!isStartDate) {
+                setEndDate(target.value);
+                return;
+            }
+            setStartDate(target.value);
+        };
+        const onChangeTime = (time, isStartTime) => {
+            if (time) {
+                if (Array.isArray(selectedTime)) {
+                    if (isStartTime) {
+                        setSelectedTime([time, selectedTime[1]]);
+                        return;
+                    }
+                    setSelectedTime([selectedTime[0], time]);
+                    return;
+                }
+                setSelectedTime(time);
+            }
+        };
+        React.useEffect(() => {
+            var _a4;
+            const newValue = (_a4 = props.value) !== null && _a4 !== void 0 ? _a4 : props.initialValue;
+            const newDate = newValue || (props.selectsRange ? [null, null] : null);
+            if (JSON.stringify(newDate) === JSON.stringify(selectedDateRef.current)) {
+                return;
+            }
+            setSelectedDate(newDate);
+            const newTime = getInitialTime(newValue, props.selectsRange);
+            setSelectedTime(newTime);
+            const newStartDate = getInitialDate(newValue, formatToApply, true);
+            setStartDate(newStartDate);
+            const newEndDate = getInitialDate(newValue, formatToApply, false);
+            setEndDate(newEndDate);
+        }, [props.value, props.initialValue]);
+        React.useEffect(() => {
+            var _a4;
+            let time = selectedTime;
+            if (props.selectsRange && !Array.isArray(selectedTime)) {
+                time = [selectedTime, "00:00"];
+                setSelectedTime([selectedTime, "00:00"]);
+            }
+            const newDateTime = getNewDatetime(selectedDate, time);
+            (_a4 = props.onChange) === null || _a4 === void 0 ? void 0 : _a4.call(props, newDateTime);
+        }, [selectedDate, selectedTime]);
+        return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
+            children: jsxRuntime.exports.jsx(Tooltip, {
+                content: props.errorMsg,
+                disabled: !props.errorMsg,
+                styling: "error",
+                children: jsxRuntime.exports.jsxs(DatepickerWrapper$1, {
+                    inline: props.inline,
+                    showsRange: props.selectsRange,
+                    showsTime: props.showTimeInput,
+                    children: [jsxRuntime.exports.jsxs(DatepickerInputs, {
+                        children: [jsxRuntime.exports.jsxs(DateTimeWrapper, {
+                            isRange: props.selectsRange,
+                            children: [jsxRuntime.exports.jsx(DateInput, {
+                                isTimeRange: props.selectsRange && props.showTimeInput,
+                                onChange: (e3) => {
+                                    onChangeDateInput(true, e3);
+                                },
+                                onClick: () => {
+                                    var _a4;
+                                    setIsSelectingStart(true);
+                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                },
+                                onFocus: () => {
+                                    var _a4;
+                                    setIsSelectingStart(true);
+                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                },
+                                onKeyDown: (e3) => {
+                                    var _a4;
+                                    (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
+                                },
+                                placeholder: formatToApply,
+                                value: startDate
+                            }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
+                                isRange: props.selectsRange,
+                                onChange: (e3) => {
+                                    onChangeTime(e3, true);
+                                },
+                                type: "time",
+                                value: Array.isArray(selectedTime) ? selectedTime[0] : selectedTime
+                            })]
+                        }), props.selectsRange && jsxRuntime.exports.jsxs(EndDateInputWrapper, {
+                            children: ["\u2192", jsxRuntime.exports.jsxs(DateTimeWrapper, {
+                                isRange: true,
+                                children: [jsxRuntime.exports.jsx(DateInput, {
+                                    isTimeRange: props.showTimeInput,
+                                    onChange: (e3) => {
+                                        onChangeDateInput(false, e3);
+                                    },
+                                    onClick: () => {
+                                        var _a4;
+                                        setIsSelectingStart(false);
+                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                    },
+                                    onFocus: () => {
+                                        var _a4;
+                                        setIsSelectingStart(false);
+                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.setOpen(true);
+                                    },
+                                    onKeyDown: (e3) => {
+                                        var _a4;
+                                        (_a4 = datepickerRef.current) === null || _a4 === void 0 ? void 0 : _a4.onInputKeyDown(e3);
+                                    },
+                                    placeholder: formatToApply,
+                                    value: endDate
+                                }), props.showTimeInput && jsxRuntime.exports.jsx(TimeInput, {
+                                    isRange: true,
+                                    onChange: (e3) => {
+                                        onChangeTime(e3, false);
+                                    },
+                                    type: "time",
+                                    value: selectedTime[1]
+                                })]
+                            })]
+                        })]
+                    }), jsxRuntime.exports.jsx(Wt$1, Object.assign({
+                        className: props.className,
+                        customInput: jsxRuntime.exports.jsx("div", {}),
+                        disabled: props.disabled,
+                        inline: props.inline,
+                        maxDate: props.maxDate,
+                        onChange: onChangeDate,
+                        ref: datepickerRef,
+                        selectsEnd: !isSelectingStart,
+                        selectsStart: isSelectingStart,
+                        shouldCloseOnSelect: props.shouldCloseOnSelect
+                    }, extraProps, {
+                        popperProps: {
+                            strategy: (_c = props.popperStrategy) !== null && _c !== void 0 ? _c : "absolute"
+                        },
+                        renderCustomHeader: (headerProps) => jsxRuntime.exports.jsx(DatePickerHeader, Object.assign({}, headerProps, {
+                            maxDate: props.maxDate,
+                            minDate: props.minDate,
+                            portalsRef: props.portalsRef,
+                            selectItemClass: props.selectItemClass
+                        }))
+                    }))]
+                })
+            })
+        });
+    }
+    styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: center;
+
+    margin-top: 20px;
+
+    color: ${(props) => props.theme.colors.text};
+
+    border: 1px dashed ${(props) => props.isDragActive ? props.theme.colors.primary : props.theme.colors.grey3};
+    border-radius: 0.25rem;
+
+    :hover {
+        background-color: ${(props) => props.theme.colors.grey1};
+    }
+
+    :active,
+    :focus {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+`;
+    styled__default.default.span`
+    max-width: 400px;
+    padding: 1.5rem;
+
+    font-family: Manrope, sans-serif;
+    font-weight: 300;
+    text-align: center;
+`;
+    styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+
+    width: 100%;
+    padding: 1rem;
+
+    color: ${(props) => props.theme.colors.error};
+
+    background-color: ${(props) => props.theme.colors.background};
+`;
+    styled__default.default.div`
+    overflow: scroll;
+    display: flex;
+    flex-direction: column;
+
+    width: 100%;
+    max-height: 125px;
+    margin: 2rem 0;
+    padding: 0.5rem;
+
+    color: ${(props) => props.theme.colors.background};
+
+    background-color: ${(props) => props.theme.colors.errorHover};
+`;
+    styled__default.default.p`
+    color: ${(props) => props.theme.colors.error};
+`;
+    styled__default.default.li`
+    margin-left: 0.35rem;
+    border-left: thin solid ${(props) => props.theme.colors.grey6};
+
+    &::before {
+        content: '';
+
+        display: inline-block;
+
+        width: 0.9rem;
+        height: 0.8rem;
+        margin-right: 0.1rem;
+
+        vertical-align: top;
+
+        border-bottom: thin solid ${(props) => props.theme.colors.grey6};
+    }
+
+    &:last-child {
+        border-left: none;
+
+        &::before {
+            border-left: thin solid ${(props) => props.theme.colors.grey6};
+        }
+    }
+`;
+    styled__default.default.span`
+    cursor: ${(props) => props.selectionAllowed ? "pointer" : "normal"};
+    font-weight: ${(props) => props.isLeaf ? 300 : 400};
+    color: ${(props) => {
+    if (props.selected) {
+      return props.theme.colors.primary;
+    }
+    return props.isLeaf ? props.theme.colors.grey6 : props.theme.colors.grey5;
+  }};
+`;
+    styled__default.default(Circle$1)`
+    width: 0.5rem;
+    height: 0.5rem;
+    margin-right: 0.4rem;
+
+    color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey6};
+    vertical-align: middle;
+`;
+    const grow = styled.keyframes`
+    0% {
+        transform: scaleY(0);
+        opacity: 0;
+    }
+    100% {
+        transform: scaleY(1);
+        opacity: 1;
+    }
+`;
+    const contract = styled.keyframes`
+    100% {
+        transform: scaleY(1);
+        opacity: 1;
+    }
+    0% {
+        transform: scaleY(0);
+        opacity: 0;
+    }
+`;
+    styled__default.default.ul`
+    transform-origin: top center;
+
+    display: ${(props) => props.open ? "block" : "none"};
+
+    margin: 0;
+    margin-left: 1rem;
+    padding: 0;
+    padding-bottom: 1rem;
+
+    list-style: none;
+
+    animation: ${(props) => props.open ? grow : contract} 300ms
+        ${(props) => props.open ? "ease-out forwards" : "ease-in forwards"};
+`;
+    styled__default.default.div`
+    overflow: scroll;
+`;
+    styled__default.default.div`
+    cursor: pointer;
+    margin-left: 1rem;
+`;
+    const Background$1 = styled__default.default.div`
+    position: fixed;
+    z-index: 2000;
+    top: 0;
+    left: 0;
+
+    display: flex;
+    align-items: center;
+    justify-content: center;
+
+    width: 100%;
+    height: 100%;
+
+    opacity: ${(props) => props.render ? 1 : 0};
+    background-color: ${(props) => props.theme.colors.modalBg};
+
+    transition: opacity ease-in 0.1s;
+`;
+    const ModalWrapper = styled__default.default.div`
+    overflow: hidden;
+    display: inline-flex;
+    flex-direction: column;
+
+    min-width: 20rem;
+    max-width: 80vw;
+    min-height: 10rem;
+    max-height: 80vh;
+    margin-top: ${(props) => props.render ? 0 : "-50px"};
+    padding: 1.75rem;
+
+    font-size: ${(props) => props.theme.font.size};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.medium};
+
+    transition: margin-top ease-in 0.1s;
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 0 0 auto;
+    justify-content: space-between;
+    margin-top: 1rem;
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 0 0 auto;
+    flex-direction: ${(props) => props.flexDirection || "column"};
+    justify-content: space-between;
+
+    margin-bottom: 1rem;
+`;
+
+    function Modal(props) {
+        var _a3;
+        const [mounted, setMounted] = React.useState(false);
+        const [renderModal, setRenderModal] = React.useState(false);
+        React.useEffect(() => {
+            setRenderModal(props.render);
+        }, [props.render]);
+        React.useEffect(() => {
+            if (renderModal) {
+                const keyHandler = (e3) => {
+                    if (e3.key === Key.ESCAPE && props.onAttemptClose) {
+                        props.onAttemptClose();
+                    }
+                };
+                document.addEventListener("keydown", keyHandler);
+                return () => {
+                    document.removeEventListener("keydown", keyHandler);
+                };
+            }
+        }, [renderModal, props.onAttemptClose]);
+        if (!props.render && !mounted) {
+            return null;
+        }
+        const onTransitionEnd = () => {
+            setMounted(props.render);
+            if (!props.render && props.onClosed) {
+                props.onClosed();
+            }
+        };
+        const stopPropagation = (e3) => {
+            e3.stopPropagation();
+        };
+        return ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(Background$1, {
+            id: props.id,
+            onClick: props.onAttemptClose,
+            onTransitionEnd,
+            render: renderModal,
+            children: jsxRuntime.exports.jsx(ModalWrapper, {
+                className: `cl-modal-content ${(_a3 = props.className) !== null && _a3 !== void 0 ? _a3 : ""}`,
+                onClick: stopPropagation,
+                render: renderModal,
+                style: props.style,
+                children: props.children
+            })
+        }), document.body);
+    }
+    globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const tagHeight = 2;
+    const tagTopMargin = 0.5;
+    styled__default.default.div`
+    display: inline-flex;
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                cursor: not-allowed;
+            `;
+    }
+  }}
+
+    width: 100%;
+    max-width: ${(props) => props.maxWidth};
+    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin)}rem;
+
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+`;
+    styled__default.default.div`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    min-width: 10rem;
+    min-height: 2.5rem;
+    margin-right: 0.25rem;
+    padding: 0.25rem 0.5rem 0.25rem 1rem;
+
+    color: ${(props) => props.isDisabled ? props.theme.colors.grey2 : props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+
+    :hover {
+        background-color: ${(props) => props.isDisabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+    }
+
+    svg {
+        height: 0.8rem;
+    }
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey1};
+
+                svg {
+                    color: ${props.theme.colors.grey2};
+                    cursor: not-allowed;
+                }
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
+    };: hover {
+        border: 1 px solid $ {
+            props.theme.colors.grey3
+        };
+
+    }
+    `;
+  }}
+`;
+    styled__default.default.input`
+    overflow: hidden;
+    flex: 1 1 auto;
+
+    margin-right: 0.5rem;
+    padding: 0;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : props.theme.font.size};
+    font-weight: 300;
+    color: ${(props) => props.theme.colors.grey6};
+    text-align: left;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+
+    background-color: transparent;
+    border: none;
+    outline: 0;
+
+    :disabled {
+        cursor: not-allowed;
+    }
+`;
+    styled__default.default.div`
+    overflow: auto;
+    display: flex;
+    flex-wrap: wrap;
+    gap: 0.5rem;
+    align-items: center;
+
+    width: 100%;
+    height: 100%;
+    max-height: ${(props) => props.maxRows * (tagHeight + tagTopMargin) - 0.25}rem;
+`;
+    styled__default.default.span`
+    overflow: hidden;
+    display: flex;
+    align-items: center;
+
+    height: ${tagHeight}rem;
+    padding: 0 0.75rem;
+
+    font-size: 0.875rem;
+    color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
+
+    background-color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.blue3};
+    border: 1px solid ${(props) => props.theme.colors.primary};
+    border-radius: 1rem;
+
+    svg {
+        width: 0.85rem;
+        height: 0.85rem;
+        margin-left: 0.25rem;
+        color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.text};
+
+        :hover {
+            color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.primary};
+        }
+    }
+`;
+    styled__default.default.span`
+    overflow: hidden;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: center;
+
+    height: 2rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.theme.colors.grey4};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+`;
+    styled__default.default(List)`
+    border-radius: 0 0 0.25rem 0.25rem;
+    outline: 0;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    styled__default.default(Button$1).attrs((attrs2) => Object.assign(Object.assign({}, attrs2), {
+        styling: "ghost"
+    }))`
+    min-width: 0;
+    height: auto;
+    margin: 0;
+    padding: 0 0.25rem;
+
+    background-color: transparent !important;
+`;
+    var __rest$8 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const SelectedItem = styled__default.default.div`
+    overflow: hidden;
+
+    /* The space available is that of the wrapper minus of the chevron */
+    width: calc(100% - 1rem);
+    margin-right: 0.5rem;
+
+    font-size: ${(props) => props.size ? `${props.size}rem` : "1rem"};
+    font-weight: 300;
+    text-align: left;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    const Wrapper$3 = styled__default.default.div`
+    display: inline-flex;
+
+    width: 100%;
+    min-width: 4rem;
+    height: 2.5rem;
+
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+
+    ${(props) => {
+    if (props.isDisabled) {
+      return `
+                border: 1px solid ${props.theme.colors.grey1};
+                cursor: not-allowed;
+            `;
+    }
+    if (props.isErrored) {
+      return `
+    border: 1 px solid $ {
+        props.theme.colors.error
+    };
+    `;
+    }
+    return `
+    border: 1 px solid $ {
+        props.isOpen ? props.theme.colors.grey3 : props.theme.colors.grey1
+    };: hover {
+        border: 1 px solid $ {
+            props.theme.colors.grey3
+        };
+
+    }
+    `;
+  }}
+`;
+    const SelectButton = styled__default.default.button`
+    display: inline-flex;
+    flex: 1 1 auto;
+    align-items: center;
+    justify-content: space-between;
+
+    width: 100%;
+    height: 100%;
+    padding: 0 0.5rem 0 1rem;
+
+    font-size: 1rem;
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: none;
+    border-radius: ${(props) => props.isOpen ? "0.25rem 0.25rem 0rem 0rem" : "0.25rem"};
+    outline: 0;
+
+    :not(:enabled) {
+        cursor: not-allowed;
+    }
+
+    :hover:enabled {
+        background-color: ${(props) => props.theme.colors.grey2};
+    }
+
+    svg {
+        width: 1rem !important;
+        height: 0.8rem;
+    }
+
+    :disabled {
+        color: ${(props) => props.theme.colors.grey2};
+        background-color: ${(props) => props.theme.colors.grey1};
+
+        svg {
+            color: ${(props) => props.theme.colors.grey2};
+        }
+    }
+`;
+    const DropdownList = styled__default.default(List)`
+    margin-left: -1px;
+    border-radius: 0 0 0.25rem 0.25rem;
+    outline: 0;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+
+    function Select(props) {
+        var _a3, _b, _c, _d, _e2, _f;
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper(referenceElement.current, popperElement.current, {
+            modifiers: props.applySameWidthModifier === false ? [] : [sameWidthModifier],
+            placement: props.placement || "bottom-start"
+        });
+        const {
+            isOpen,
+            selectedItem,
+            getToggleButtonProps,
+            getMenuProps,
+            highlightedIndex,
+            getItemProps
+        } = useSelect(Object.assign({
+            initialIsOpen: props.initialIsOpen,
+            initialSelectedItem: props.initialValue,
+            itemToString: (item) => item.label,
+            items: props.items,
+            onSelectedItemChange: (changes) => {
+                var _a4;
+                const selected = changes.selectedItem;
+                (_a4 = props.onSelect) === null || _a4 === void 0 ? void 0 : _a4.call(props, selected);
+            }
+        }, "selectedItem" in props && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
+            }
+        }, [isOpen, update2]);
+        const buttonProps = getToggleButtonProps({
+            disabled: props.disabled
+        });
+        const setButtonRef = buttonProps.ref;
+        delete buttonProps.ref;
+        const setButtonReference = (value) => {
+            setButtonRef(value);
+            referenceElement.current = value;
+        };
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            var _a4;
+            setMenuRef(value);
+            popperElement.current = value;
+            (_a4 = props.dropdownRef) === null || _a4 === void 0 ? void 0 : _a4.call(props, value);
+        };
+        return jsxRuntime.exports.jsx(Tooltip, {
+            content: props.errorMsg,
+            disabled: !props.errorMsg,
+            styling: "error",
+            children: jsxRuntime.exports.jsxs(Wrapper$3, {
+                className: props.className,
+                isDisabled: props.disabled,
+                isErrored: !!props.errorMsg,
+                isOpen,
+                onClick: props.onClick,
+                style: props.style,
+                children: [jsxRuntime.exports.jsxs(SelectButton, Object.assign({
+                    disabled: props.disabled,
+                    isOpen
+                }, buttonProps, {
+                    ref: setButtonReference,
+                    type: "button",
+                    children: [jsxRuntime.exports.jsx(SelectedItem, {
+                        size: props.size,
+                        children: (_b = (_a3 = selectedItem === null ? props.placeholder : selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _a3 !== void 0 ? _a3 : props.placeholder) !== null && _b !== void 0 ? _b : "Select"
+                    }), jsxRuntime.exports.jsx(Chevron$2, {
+                        disabled: props.disabled,
+                        isOpen
+                    })]
+                })), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(DropdownList, Object.assign({}, menuProps, attributes2.popper, {
+                    className: `${(_c = menuProps === null || menuProps === void 0 ? void 0 : menuProps.className) !== null && _c !== void 0 ? _c : ""} ${(_e2 = (_d = attributes2 === null || attributes2 === void 0 ? void 0 : attributes2.popper) === null || _d === void 0 ? void 0 : _d.className) !== null && _e2 !== void 0 ? _e2 : ""} ${props.itemClass}`,
+                    isOpen,
+                    maxItems: props.maxItems,
+                    ref: setMenuReference,
+                    style: Object.assign(Object.assign({}, styles2.popper), {
+                        width: props.applySameWidthModifier === false ? void 0 : parseFloat((_f = styles2.popper) === null || _f === void 0 ? void 0 : _f.width) + 2,
+                        zIndex: 9999
+                    }),
+                    children: props.items.map((item, index2) => {
+                        const _a4 = getItemProps({
+                                index: index2,
+                                item
+                            }),
+                            {
+                                itemClassName
+                            } = _a4,
+                            itemProps = __rest$8(_a4, ["itemClassName"]);
+                        return React.createElement(ListItem, Object.assign({}, itemProps, {
+                            className: `${itemClassName} ${props.itemClass}`,
+                            hovered: index2 === highlightedIndex,
+                            key: `item-${index2}`,
+                            size: props.size,
+                            title: item.label
+                        }), item.label);
+                    })
+                })), document.body)]
+            })
+        });
+    }
+    const StyledSelect$1 = styled__default.default(Select)`
+    margin: 1px solid ${(props) => props.theme.colors.background};
+
+    button {
+        background-color: ${(props) => props.theme.colors.background};
+
+        :hover:enabled {
+            background-color: ${(props) => props.theme.colors.background};
+        }
+    }
+`;
+    const InputsWrapper = styled__default.default.div`
+    display: flex;
+    gap: 5px;
+    align-items: center;
+`;
+    const FilterHeader = styled__default.default.div`
+    display: flex;
+    flex-direction: column;
+    gap: 0.25rem;
+    padding: 0 0.5rem;
+`;
+    const StyledInput$2 = styled__default.default(Input$1)`
+    width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
+
+    input {
+        width: ${(props) => props.showTwoInputs ? "106px" : "100%"};
+        background-color: ${(props) => props.theme.colors.background};
+        border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.background};
+
+        :hover:not(:disabled) {
+            background-color: ${(props) => props.theme.colors.background};
+            border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
+        }
+
+        :active:not(:disabled),
+        :focus:not(:disabled) {
+            border: 1px solid ${(props) => props.showError ? props.theme.colors.error : props.theme.colors.grey3};
+        }
+    }
+`;
+    const ErrorMessage = styled__default.default.span`
+    user-select: none;
+    font-size: 0.7rem;
+    color: ${(props) => props.theme.colors.error};
+`;
+    const NumericFilterItems = [{
+        label: "None",
+        value: "None"
+    }, {
+        label: "Greater than",
+        value: "Greater than"
+    }, {
+        label: "Less than",
+        value: "Less tha"
+    }, {
+        label: "Equal to",
+        value: "Equal to"
+    }, {
+        label: "Not equal to",
+        value: "Not equal to"
+    }, {
+        label: "Between",
+        value: "Between"
+    }];
+
+    function NumericFilter(props) {
+        const [selected, setSelected] = React.useState(null);
+        const [firstInput, setFirstInput] = React.useState(null);
+        const [secondInput, setSecondInput] = React.useState(null);
+        const filteredValues = React.useMemo(() => {
+            if ((selected === null || selected === void 0 ? void 0 : selected.label) === "None") {
+                return {
+                    selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                    value: null
+                };
+            }
+            if ((selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
+                return {
+                    selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                    value: [firstInput, secondInput]
+                };
+            }
+            return {
+                selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                value: firstInput
+            };
+        }, [firstInput, secondInput, selected]);
+        const [previousFilter, setPreviousFilter] = React.useState(filteredValues);
+        const showError = React.useMemo(() => {
+            if (secondInput && firstInput && secondInput < firstInput && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
+                return true;
+            }
+            return false;
+        }, [firstInput, secondInput, selected]);
+        const disableApply = React.useMemo(() => {
+            if (props.disabled || previousFilter === filteredValues || showError) {
+                return true;
+            }
+            if (firstInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None") {
+                return true;
+            }
+            if (secondInput === null && (selected === null || selected === void 0 ? void 0 : selected.label) === "Between") {
+                return true;
+            }
+            return false;
+        }, [props.disabled, firstInput, secondInput, previousFilter, filteredValues, showError, selected]);
+        return jsxRuntime.exports.jsxs(FilterWrapper, {
+            className: props.className,
+            children: [jsxRuntime.exports.jsxs(FilterHeader, {
+                children: [jsxRuntime.exports.jsx(StyledSelect$1, {
+                    dropdownRef: (element2) => {
+                        if (props.portalsRef) {
+                            props.portalsRef.current[0] = element2;
+                        }
+                    },
+                    initialValue: {
+                        label: "None",
+                        value: "None"
+                    },
+                    items: NumericFilterItems,
+                    maxItems: 6,
+                    onSelect: setSelected
+                }), selected && (selected === null || selected === void 0 ? void 0 : selected.label) !== "None" && jsxRuntime.exports.jsxs(InputsWrapper, {
+                    children: [jsxRuntime.exports.jsx(StyledInput$2, {
+                        onChange: (v2) => setFirstInput(Number(v2)),
+                        showError,
+                        showTwoInputs: (selected === null || selected === void 0 ? void 0 : selected.label) === "Between",
+                        type: "number"
+                    }), (selected === null || selected === void 0 ? void 0 : selected.label) === "Between" && jsxRuntime.exports.jsxs(InputsWrapper, {
+                        children: ["and", jsxRuntime.exports.jsx(StyledInput$2, {
+                            onChange: (v2) => setSecondInput(Number(v2)),
+                            showError,
+                            type: "number",
+                            value: String(secondInput)
+                        })]
+                    })]
+                })]
+            }), showError && jsxRuntime.exports.jsx(ErrorMessage, {
+                children: "Input range not valid"
+            }), jsxRuntime.exports.jsx(ApplyButton, {
+                disabled: disableApply,
+                onClick: (e3) => {
+                    var _a3, _b;
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
+                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
+                    setPreviousFilter(filteredValues);
+                },
+                children: "Apply"
+            })]
+        });
+    }
+    const StepperWrapper = styled__default.default.div`
+    cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+
+    display: flex;
+    flex-direction: column;
+    justify-content: space-around;
+
+    box-sizing: border-box;
+    padding: 0.25rem 0;
+
+    border-radius: 0 0.25rem 0.25rem 0;
+`;
+    const StepperButton = styled__default.default(Button$1)`
+    min-width: 0.75rem;
+    height: max-content;
+    padding: 0;
+    background-color: transparent !important;
+
+    svg {
+        cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
+        width: 0.75rem;
+        height: 0.75rem;
+        color: ${(props) => props.disabled ? props.theme.colors.grey3 : props.theme.colors.grey4};
+    }
+
+    :hover:not(:disabled) {
+        svg {
+            color: ${(props) => props.theme.colors.grey5};
+        }
+    }
+
+    :active:not(:disabled) {
+        svg {
+            transform: scale(0.75);
+        }
+    }
+`;
+    const InputStepper = ({
+        disabled: disabled2,
+        step: step2,
+        stepSkip
+    }) => {
+        const amountToStep = Math.abs(stepSkip !== null && stepSkip !== void 0 ? stepSkip : 1);
+        const stepUp = () => step2(amountToStep);
+        const stepDown = () => step2(amountToStep * -1);
+        return jsxRuntime.exports.jsxs(StepperWrapper, {
+            disabled: disabled2,
+            children: [jsxRuntime.exports.jsx(StepperButton, {
+                disabled: disabled2,
+                onClick: stepUp,
+                styling: "ghost",
+                tabIndex: -1,
+                children: jsxRuntime.exports.jsx(ChevronUp, {})
+            }), jsxRuntime.exports.jsx(StepperButton, {
+                disabled: disabled2,
+                onClick: stepDown,
+                styling: "ghost",
+                tabIndex: -1,
+                children: jsxRuntime.exports.jsx(ChevronDown, {})
+            })]
+        });
+    };
+    const InputWrapper$1 = styled__default.default.div`
+    display: flex;
+    flex-direction: row;
+
+    width: 22ch;
+    height: 2.5rem;
+    padding-right: 0.5rem;
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border: 1px solid ${(props) => props.errorMsg ? props.theme.colors.error : props.theme.colors.grey1};
+    border-radius: 0.25rem;
+
+    input {
+        height: calc(2.5rem - 2px);
+        border: none;
+        border-radius: 0.25rem;
+    }
+
+    div {
+        border: none;
+        border-radius: 0.25rem;
+
+        div {
+            border: none;
+            border-radius: 0.25rem;
+        }
+    }
+
+    :hover {
+        background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+        /* stylelint-disable -- fails to parse the statement */
+        border: 1px solid
+            ${(props) => {
+    if (props.disabled) {
+      return props.theme.colors.grey1;
+    }
+    if (props.errorMsg) {
+      return props.theme.colors.error;
+    }
+    return props.theme.colors.grey2;
+  }};
+        /* stylelint-enable */
+
+        input {
+            background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+        }
+
+        div {
+            background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.grey2};
+        }
+    }
+
+    :focus-within:not(:disabled) {
+        border: 1px solid ${(props) => props.errorMsg ? props.theme.colors.error : props.theme.colors.grey3};
+
+        input {
+            border: none;
+        }
+    }
+
+    /* Fix: Overrides the 22ch default width of the nested regular input */
+    > div:first-child {
+        width: 100%;
+        height: auto;
+    }
+`;
+    const numericFilter = (integerOnly) => (e3) => {
+        if (parseInt(e3.key) || parseInt(e3.key) === 0) {
+            return true;
+        }
+        if (CONTROL_KEYS.includes(e3.key)) {
+            return true;
+        }
+        const target = e3.target;
+        if (!integerOnly && e3.key === Key.PERIOD && !target.value.includes(Key.PERIOD)) {
+            return true;
+        }
+        if (e3.key === Key.MINUS && !e3.shiftKey && target.selectionStart === 0 && !target.value.includes(Key.MINUS)) {
+            return true;
+        }
+        return false;
+    };
+    const getInitialValue = (value, initialValue) => {
+        if (Number.isFinite(value)) {
+            return String(value);
+        }
+        if (Number.isFinite(initialValue)) {
+            return String(initialValue);
+        }
+        return "";
+    };
+    React__namespace.forwardRef((props, ref2) => {
+        const keydownFilter = React.useMemo(() => numericFilter(props.integerOnly), [props.integerOnly]);
+        const [input, setInput] = React.useState(getInitialValue(props.value, props.initialValue));
+        const step2 = (value) => {
+            var _a3;
+            if (!input || input === "-") {
+                return;
+            }
+            const isFloat = input.includes(".");
+            const parsedValue = isFloat ? parseFloat(input) : parseInt(input);
+            let nextValueNumber = parsedValue + value;
+            let nextValueStr = String(nextValueNumber);
+            if (isFloat) {
+                const decimals = input.split(".")[1];
+                if (decimals) {
+                    nextValueStr = (parsedValue + value / Math.pow(10, decimals.length)).toFixed(decimals.length);
+                    nextValueNumber = parseFloat(nextValueStr);
+                }
+            }
+            if (props.value !== void 0) {
+                (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, nextValueNumber, {
+                    target: {
+                        value: nextValueStr
+                    }
+                });
+            } else {
+                setInput(nextValueStr);
+            }
+        };
+        const onKeyDown = (e3) => {
+            var _a3, _b;
+            (_a3 = props.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(props, e3);
+            if (!props.stepper) {
+                return;
+            }
+            const stepSkip = Math.abs((_b = props.stepSkip) !== null && _b !== void 0 ? _b : 1);
+            if (e3.key === Key.UP) {
+                step2(stepSkip);
+            }
+            if (e3.key === Key.DOWN) {
+                step2(stepSkip * -1);
+            }
+        };
+        const onChange2 = React.useCallback(
+            (value, e3) => {
+                var _a3, _b;
+                const parsed = props.integerOnly ? parseInt(value) : parseFloat(value);
+                if (props.value === void 0) {
+                    setInput(value);
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, parsed, e3);
+                    return;
+                }
+                if (value.endsWith(".")) {
+                    setInput(value);
+                    return;
+                }
+                if (value.includes(".") && value.endsWith("0")) {
+                    setInput(value);
+                    return;
+                }
+                if (value === "-") {
+                    setInput(value);
+                    return;
+                }
+                (_b = props.onChange) === null || _b === void 0 ? void 0 : _b.call(props, parsed, e3);
+            },
+            [props.integerOnly, props.value, props.onChange]
+        );
+        React.useEffect(() => {
+            setInput(getInitialValue(props.value, props.initialValue));
+        }, [props.value]);
+        return jsxRuntime.exports.jsxs("div", {
+            children: [jsxRuntime.exports.jsxs(InputWrapper$1, {
+                disabled: props.disabled,
+                errorMsg: props.errorMsg,
+                stepper: props.stepper,
+                style: props.style,
+                children: [jsxRuntime.exports.jsx(Input$1, {
+                    autoFocus: props.autoFocus,
+                    className: props.className,
+                    disabled: props.disabled,
+                    keydownFilter,
+                    maxValue: props.maxValue,
+                    minValue: props.minValue,
+                    onBlur: props.onBlur,
+                    onChange: onChange2,
+                    onComplete: props.onComplete,
+                    onKeyDown,
+                    placeholder: props.placeholder,
+                    ref: ref2,
+                    value: input
+                }), props.stepper && jsxRuntime.exports.jsx(InputStepper, {
+                    disabled: props.disabled,
+                    step: step2,
+                    stepSkip: props.stepSkip
+                })]
+            }), props.errorMsg && jsxRuntime.exports.jsx(ErrorMessage$1, {
+                children: props.errorMsg
+            })]
+        });
+    });
+    Input$1.displayName = "NumericInput";
+    styled__default.default.div`
+    overflow: auto;
+    display: grid;
+    grid-template-columns: repeat(${(props) => props.itemsPerRow}, 1fr);
+
+    max-height: 100%;
+    margin: 2rem;
+    padding: 1rem;
+
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.grey1};
+    border-radius: 0.25rem;
+`;
+    styled__default.default.div`
+    cursor: pointer;
+
+    position: relative;
+
+    display: flex;
+    flex-direction: column;
+    align-items: center;
+    justify-content: center;
+
+    margin: 1rem;
+    padding: 1rem;
+
+    text-align: center;
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border: ${(props) => `2px solid ${props.selected ? props.theme.colors.primary : "transparent"}`};
+    border-radius: 0.25rem;
+
+    :hover {
+        border: ${(props) => `2px solid ${props.selected ? props.theme.colors.primary : props.theme.colors.grey3}`};
+    }
+`;
+    styled__default.default.h2`
+    margin-top: 1rem;
+`;
+    styled__default.default.h4`
+    margin-top: 1rem;
+    color: ${(props) => props.theme.colors.grey6};
+`;
+    styled__default.default(CheckSquare)`
+    cursor: pointer;
+
+    position: absolute;
+    z-index: 3;
+    top: 10px;
+    right: 10px;
+
+    color: ${(props) => props.theme.colors.primary};
+`;
+    styled__default.default.div`
+    cursor: pointer;
+    display: flex;
+    width: 100%;
+`;
+    styled__default.default.div`
+    position: relative;
+
+    overflow: hidden;
+    display: flex;
+
+    width: 100%;
+    height: ${(props) => props.small ? "0.5rem" : "1rem"};
+
+    background-color: ${(props) => props.theme.colors.grey2};
+    border-radius: ${(props) => props.small ? "0.25rem" : "0.5rem"};
+`;
+    styled__default.default.div`
+    position: absolute;
+
+    overflow: ${(props) => props.multi ? "hidden" : "visible"};
+
+    height: 100%;
+
+    background-color: ${(props) => props.color ? props.color : props.theme.colors.primary};
+    border-radius: ${(props) => props.small ? "0.25rem" : "0.5rem"};
+`;
+    styled__default.default.span`
+    position: absolute;
+    right: 0.5rem;
+    bottom: 0.05rem;
+    left: 0.5rem;
+
+    height: 100%;
+
+    font-size: 0.75rem;
+    color: ${(props) => props.theme.colors.blue1};
+    text-align: end;
+`;
+    styled__default.default.div`
+    display: ${(props) => props.isHorizontal ? "flex" : "block"};
+    gap: ${(props) => props.isHorizontal ? "1.25rem" : "0rem"};
+`;
+    styled__default.default.label`
+    cursor: ${(props) => props["aria-disabled"] ? "not-allowed" : "pointer"};
+    user-select: none;
+
+    display: flex;
+    gap: 0.5rem;
+    align-items: center;
+    justify-content: flex-start;
+
+    width: ${(props) => props.isListStyle ? "auto" : "fit-content"};
+    height: 2.5rem;
+    padding: 0 0.5rem;
+
+    color: ${(props) => props["aria-disabled"] ? props.theme.colors.grey3 : props.theme.colors.text};
+
+    border: none;
+    border-radius: 0.25rem;
+
+    /* sets checkmark indicator */
+    span::after {
+        top: calc(0.25rem - 1px);
+        left: calc(0.25rem - 1px);
+
+        width: 0.5rem;
+        height: 0.5rem;
+
+        background-color: ${(props) => props["aria-disabled"] ? props.theme.colors.grey3 : props.theme.colors.grey5};
+        border-radius: 50%;
+    }
+
+    /* Show the checkmark when checked */
+    input:checked ~ span::after {
+        display: block;
+    }
+
+    /* Controls background color change depending on style */
+    ${(props) => {
+    if (props.isListStyle) {
+      return `:hover {
+                        background-color: ${props["aria-disabled"] ? "none" : props.theme.colors.grey1}
+            }
+            :active {
+                background-color: ${props["aria-disabled"] ? "none" : props.theme.colors.grey2}
+    }`;
+    }
+    return `: hover {
+            span {
+                background - color: $ {
+                    props["aria-disabled"] ? "none" : props.theme.colors.grey1
+                };
+            }
+        }
+
+        : active {
+            span {
+                background - color: $ {
+                    props["aria-disabled"] ? "none" : props.theme.colors.grey2
+                };
+            }
+        }
+    `;
+  }}
+
+    /* Sets the outer rim color of radio button */
+    :hover {
+        span {
+            border: 1px solid
+                ${(props) => props["aria-disabled"] ? props.theme.colors.grey2 : props.theme.colors.grey4};
+        }
+    }
+
+    :active {
+        span {
+            border: 1px solid
+                ${(props) => props["aria-disabled"] ? props.theme.colors.grey2 : props.theme.colors.grey4};
+        }
+    }
+`;
+    styled__default.default.input`
+    position: absolute;
+    opacity: 0;
+`;
+    styled__default.default.span`
+    position: relative;
+    top: 0;
+    left: 0;
+
+    width: 1rem;
+    height: 1rem;
+
+    background-color: ${(props) => props.disabled ? props.theme.colors.grey1 : props.theme.colors.blue1};
+    border: 1px solid ${(props) => props.disabled ? props.theme.colors.grey2 : props.theme.colors.grey3};
+    border-radius: 50%;
+
+    ::after {
+        content: '';
+        position: relative;
+        display: none;
+    }
+`;
+    const {
+        stateChangeTypes
+    } = useCombobox;
+    const ListWrapper = styled__default.default(List)`
+    margin-left: -1px;
+    border-radius: 0 0 0.25rem 0.25rem;
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const getTextColor = (heading2, selected, theme2) => {
+        if (heading2) {
+            return theme2.colors.text;
+        }
+        if (selected) {
+            return theme2.colors.primary;
+        }
+        return theme2.colors.text;
+    };
+    const ListItemSpan = styled__default.default(ListItem)`
+    cursor: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "pointer"};
+    user-select: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "text" : "none"};
+
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+
+    padding: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) || !props.section ? "0 0.7rem" : "0 1.5rem"};
+    padding-right: 0.7rem;
+
+    font-weight: ${(props) => (props === null || props === void 0 ? void 0 : props.heading) ? "bold" : "normal"};
+    color: ${(props) => getTextColor(props === null || props === void 0 ? void 0 : props.heading, props.selected, props.theme)};
+
+    ${(props) => {
+    if (props.heading) {
+      return `
+                :hover {
+                    background-color: ${props.theme.colors.background};
+                    color: ${props.theme.colors.text};
+                }
+            `;
+    }
+  }}
+`;
+
+    function instanceOfSectionItem(item) {
+        return "items" in item;
+    }
+
+    function unpackSectionedList(listItems) {
+        return listItems.reduce((acc, item) => {
+            if (instanceOfSectionItem(item)) {
+                const sectionHeading = {
+                    heading: true,
+                    label: item.label,
+                    value: item.label
+                };
+                const sectionItems = item.items.map((sectionItem) => Object.assign(Object.assign({}, sectionItem), {
+                    section: item.label
+                }));
+                return [...acc, sectionHeading, ...sectionItems];
+            }
+            return [...acc, item];
+        }, []);
+    }
+
+    function SectionedList(props) {
+        var _a3, _b, _c, _d;
+        const theme2 = useClTheme();
+        const referenceElement = React.useRef(null);
+        const popperElement = React.useRef(null);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper(referenceElement.current, popperElement.current, {
+            modifiers: [sameWidthModifier],
+            placement: "bottom-start"
+        });
+        const unpackedItems = React.useMemo(() => unpackSectionedList(props.items), [props.items]);
+        const [pendingHighlight, setPendingHighlight] = React.useState(null);
+        const [items, setItems] = React.useState(unpackedItems);
+        const [inputValue, setInputValue] = React.useState((_b = (_a3 = props.selectedItem) === null || _a3 === void 0 ? void 0 : _a3.label) !== null && _b !== void 0 ? _b : "");
+        const {
+            selectedItem,
+            isOpen,
+            getMenuProps,
+            getInputProps,
+            getToggleButtonProps,
+            highlightedIndex,
+            getItemProps,
+            setHighlightedIndex
+        } = useCombobox(Object.assign({
+            initialIsOpen: false,
+            initialSelectedItem: (_c = props.initialValue) !== null && _c !== void 0 ? _c : props.selectedItem,
+            itemToString: (item) => item ? item.label : "",
+            items,
+            onInputValueChange: (change) => {
+                setInputValue(change.inputValue);
+                if (!change.inputValue) {
+                    setItems(unpackedItems);
+                    return;
+                }
+                const counts = {};
+                const filteredItems = unpackedItems.filter((item) => {
+                    const lowercaseInput = change.inputValue.toLowerCase();
+                    const lowercaseLabel = item.label.toLowerCase();
+                    if (!item.heading && lowercaseLabel.includes(lowercaseInput)) {
+                        counts[item.label] = counts[item.label] ? counts[item.label] + 1 : 1;
+                        return true;
+                    }
+                    if (item.heading) {
+                        const listSections = props.items.filter((propItem) => propItem.items.find((subItem) => subItem.label.toLowerCase().includes(lowercaseInput)));
+                        if (listSections.length) {
+                            listSections.forEach((section) => {
+                                counts[section.label] = counts[section.label] ? counts[section.label] + 1 : 1;
+                            });
+                            return true;
+                        }
+                    }
+                    return false;
+                });
+                setItems(filteredItems.filter((item) => counts[item.label] > 0));
+            },
+            onSelectedItemChange: (changes) => {
+                var _a4, _b2;
+                if (props.onSelect) {
+                    if (props.selectedItem && ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.value) !== ((_b2 = props.selectedItem) === null || _b2 === void 0 ? void 0 : _b2.value) || !props.selectedItem) {
+                        props.onSelect(changes.selectedItem);
+                    }
+                }
+            },
+            stateReducer: (state, {
+                changes,
+                type: type2
+            }) => {
+                var _a4, _b2, _c2;
+                if (type2 === stateChangeTypes.ControlledPropUpdatedSelectedItem) {
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ""
+                    });
+                }
+                if (type2 === stateChangeTypes.InputFocus || type2 === stateChangeTypes.ToggleButtonClick && changes.isOpen) {
+                    setPendingHighlight(changes.selectedItem ? props.items.findIndex((i2) => i2.value === changes.selectedItem.value) : 0);
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ""
+                    });
+                }
+                if ([
+                        stateChangeTypes.InputKeyDownEnter,
+                        stateChangeTypes.ItemClick,
+                        stateChangeTypes.InputBlur,
+                        stateChangeTypes.InputKeyDownEscape,
+                        stateChangeTypes.ToggleButtonClick
+                    ].includes(type2)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        inputValue: ((_a4 = changes.selectedItem) === null || _a4 === void 0 ? void 0 : _a4.label) || ""
+                    });
+                }
+                if (type2 === stateChangeTypes.InputKeyDownArrowUp && ((_b2 = items[changes.highlightedIndex]) === null || _b2 === void 0 ? void 0 : _b2.heading)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        highlightedIndex: changes.highlightedIndex - 1 < 0 ? items.length - 1 : changes.highlightedIndex - 1
+                    });
+                }
+                if (type2 === stateChangeTypes.InputKeyDownArrowDown && ((_c2 = items[changes.highlightedIndex]) === null || _c2 === void 0 ? void 0 : _c2.heading)) {
+                    return Object.assign(Object.assign({}, changes), {
+                        highlightedIndex: changes.highlightedIndex + 1 === items.length ? 0 : changes.highlightedIndex + 1
+                    });
+                }
+                return changes;
+            }
+        }, "selectedItem" in props && {
+            selectedItem: props.selectedItem
+        }));
+        React.useEffect(() => {
+            if (isOpen && pendingHighlight !== null) {
+                setHighlightedIndex(pendingHighlight);
+                setPendingHighlight(null);
+            }
+        }, [isOpen, pendingHighlight, setHighlightedIndex]);
+        React.useEffect(() => {
+            if (props.selectedItem === null) {
+                setInputValue("");
+            }
+        }, [props.selectedItem]);
+        React.useEffect(() => {
+            if (isOpen && update2) {
+                update2();
+            }
+        }, [isOpen, update2]);
+        const menuProps = getMenuProps();
+        const setMenuRef = menuProps.ref;
+        delete menuProps.ref;
+        const setMenuReference = (value) => {
+            setMenuRef(value);
+            popperElement.current = value;
+        };
+        return jsxRuntime.exports.jsxs(Wrapper$5, {
+            className: props.className,
+            isDisabled: props.disabled,
+            isErrored: false,
+            isOpen,
+            style: props.style,
+            children: [jsxRuntime.exports.jsxs(InputWrapper$2, {
+                disabled: props.disabled,
+                isOpen,
+                ref: referenceElement,
+                children: [jsxRuntime.exports.jsx(Input, Object.assign({}, getInputProps({
+                    value: inputValue
+                }))), jsxRuntime.exports.jsx(ChevronButton, Object.assign({}, getToggleButtonProps(), {
+                    children: jsxRuntime.exports.jsx(Chevron$2, {
+                        disabled: props.disabled,
+                        isOpen
+                    })
+                }))]
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsxs(ListWrapper, Object.assign({}, menuProps, attributes2.popper, {
+                isOpen,
+                ref: setMenuReference,
+                style: Object.assign(Object.assign({}, styles2.popper), {
+                    width: parseFloat((_d = styles2.popper) === null || _d === void 0 ? void 0 : _d.width) + 2,
+                    zIndex: 9999
+                }),
+                children: [items.length > 0 && items.map((item, index2) => {
+                    const itemProps = getItemProps({
+                        index: index2,
+                        item
+                    });
+                    if (item.heading) {
+                        delete itemProps.onClick;
+                    }
+                    return React.createElement(
+                        ListItemSpan,
+                        Object.assign({}, itemProps, {
+                            heading: item.heading,
+                            hovered: index2 === highlightedIndex,
+                            key: `item-${index2}`,
+                            section: item.section,
+                            selected: item.value === (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.value),
+                            title: item.label
+                        }),
+                        item.label || item.section,
+                        item.badge && jsxRuntime.exports.jsx(Badge, {
+                            color: item.badge.color || theme2.colors.primary,
+                            children: item.badge.label
+                        })
+                    );
+                }), items.length === 0 && jsxRuntime.exports.jsx(NoItemsLabel, {
+                    children: "No Items"
+                })]
+            })), document.body)]
+        });
+    }
+    styled__default.default.div`
+    position: relative;
+    display: flex;
+    flex: 1 1 auto;
+    height: 3rem;
+
+    div {
+        flex: 1 1 auto;
+    }
+
+    input {
+        height: 100%;
+
+        ::before {
+            content: ' ';
+
+            position: sticky;
+            top: 0;
+            left: 0;
+
+            width: ${(props) => !props.firstInputVisible ? "8px" : 0};
+            height: 2.5rem;
+        }
+
+        ::after {
+            content: '';
+
+            position: sticky;
+            top: 0;
+            right: 0;
+
+            width: ${(props) => !props.lastInputVisible ? "8px" : 0};
+            height: 2.5rem;
+        }
+    }
+`;
+    styled__default.default.div`
+    display: flex;
+    width: 100%;
+`;
+    styled__default.default.div`
+    overflow: hidden;
+    display: flex;
+    width: 100%;
+`;
+    styled__default.default(Slider$2)`
+    position: relative;
+
+    display: inline-flex;
+    flex-direction: column;
+    justify-content: center;
+
+    width: 100%;
+    height: 3rem;
+    margin: 0 1rem;
+`;
+    styled__default.default.div`
+    cursor: pointer;
+
+    width: 100%;
+    height: 0.25rem;
+    padding: 0 0.3rem;
+
+    background-color: ${(props) => props.theme.colors.grey2};
+    border-radius: 0.125rem;
+`;
+    styled__default.default.span`
+    cursor: pointer;
+
+    position: absolute;
+    z-index: 2;
+
+    width: 1rem;
+    height: 1rem;
+    margin-top: ${(props) => props.hasTicks ? "-0.5rem" : "0"};
+    margin-left: -0.6rem;
+
+    background-color: ${(props) => props.theme.colors.primary};
+    border-radius: 50%;
+`;
+    styled__default.default.span`
+    position: absolute;
+
+    height: 0.25rem;
+    margin-top: ${(props) => props.hasTicks ? "-0.5rem" : "0"};
+
+    background-color: ${(props) => props.theme.colors.primary};
+    border-radius: 0.125rem;
+`;
+    styled__default.default.span`
+    position: absolute;
+    z-index: 1;
+    top: -0.3rem;
+    color: ${(props) => props.theme.colors.grey6};
+`;
+    styled__default.default.span`
+    margin-left: -50%;
+    line-height: 1.5rem;
+`;
+    styled__default.default.div`
+    position: relative;
+    margin-top: 0.5rem;
+`;
+    styled__default.default.span`
+    position: absolute;
+    font-size: 0.875rem;
+    color: ${(props) => props.theme.colors.grey6};
+
+    &${(props) => props.showLine ? "" : ":not(:first-child):not(:last-child)"}::before {
+        content: '';
+
+        position: absolute;
+        z-index: 1;
+        left: 50%;
+
+        display: block;
+
+        width: 0.125rem;
+        height: 0.125rem;
+        margin-top: -0.685rem;
+
+        background-color: ${(props) => props.theme.colors.grey3};
+        border-radius: 50%;
+    }
+`;
+    styled__default.default.div`
+    display: flex;
+    height: fit-content;
+    margin-top: 0.3rem;
+`;
+
+    function Sun() {
+        const theme2 = useClTheme();
+        return jsxRuntime.exports.jsx("div", {
+            style: {
+                display: "flex",
+                height: "1rem",
+                width: "1rem"
+            },
+            children: jsxRuntime.exports.jsxs("svg", {
+                fill: "none",
+                viewBox: "0 0 200 200",
+                xmlns: "http://www.w3.org/2000/svg",
+                children: [jsxRuntime.exports.jsx("path", {
+                    d: "M138 100C138 120.987 120.987 138 100 138C79.0132 138 62 120.987 62 100C62 79.0132 79.0132 62 100 62C120.987 62 138 79.0132 138 100Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M87 13C87 5.8203 92.8203 0 100 0C107.18 0 113 5.8203 113 13V31C113 38.1797 107.18 44 100 44C92.8203 44 87 38.1797 87 31V13Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M87 169C87 161.82 92.8203 156 100 156C107.18 156 113 161.82 113 169V187C113 194.18 107.18 200 100 200C92.8203 200 87 194.18 87 187V169Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M169 113C161.82 113 156 107.18 156 100C156 92.8203 161.82 87 169 87H187C194.18 87 200 92.8203 200 100C200 107.18 194.18 113 187 113H169Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M13 113C5.8203 113 0 107.18 0 100C0 92.8203 5.8203 87 13 87H31C38.1797 87 44 92.8203 44 100C44 107.18 38.1797 113 31 113H13Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M28.1924 46.5772C23.1156 41.5003 23.1156 33.2692 28.1924 28.1924C33.2692 23.1156 41.5003 23.1156 46.5772 28.1924L59.3051 40.9203C64.3819 45.9971 64.3819 54.2283 59.3051 59.3051C54.2283 64.3819 45.9971 64.3819 40.9203 59.3051L28.1924 46.5772Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M159.579 59.3051C154.502 64.3819 146.271 64.3819 141.194 59.3051C136.118 54.2283 136.118 45.9972 141.194 40.9203L153.922 28.1924C158.999 23.1156 167.23 23.1156 172.307 28.1924C177.384 33.2692 177.384 41.5004 172.307 46.5772L159.579 59.3051Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M141.192 159.577C136.116 154.5 136.116 146.269 141.192 141.192C146.269 136.116 154.5 136.116 159.577 141.192L172.305 153.92C177.382 158.997 177.382 167.228 172.305 172.305C167.228 177.382 158.997 177.382 153.92 172.305L141.192 159.577Z",
+                    fill: theme2.colors.background
+                }), jsxRuntime.exports.jsx("path", {
+                    d: "M40.9209 141.192C45.9977 136.116 54.2289 136.116 59.3057 141.192C64.3825 146.269 64.3825 154.5 59.3057 159.577L46.5777 172.305C41.5009 177.382 33.2698 177.382 28.193 172.305C23.1162 167.228 23.1162 158.997 28.193 153.92L40.9209 141.192Z",
+                    fill: theme2.colors.background
+                })]
+            })
+        });
+    }
+    const SwitchWrapper = styled__default.default.div`
+    cursor: pointer;
+
+    position: relative;
+
+    display: flex;
+    align-items: center;
+    justify-content: ${(props) => props.enabled ? "flex-start" : "flex-end"};
+
+    width: max-content;
+    height: 1.5rem;
+    padding: 0;
+    padding-right: ${(props) => props.enabled ? "1.75rem" : "0.5rem"};
+    padding-left: ${(props) => props.enabled ? "0.5rem" : "1.75rem"};
+
+    font-size: ${(props) => props.theme.font.size};
+    color: ${(props) => props.theme.colors.blue1};
+
+    background-color: ${(props) => props.enabled ? props.theme.colors.primary : props.theme.colors.secondary};
+    border-radius: 12px;
+
+    svg {
+        color: ${(props) => props.theme.colors.blue1};
+    }
+`;
+    const SwitchHandle = styled__default.default.span`
+    position: absolute;
+    top: 2px;
+    left: ${(props) => props.enabled ? "calc(100% - 1.375rem)" : "0.125rem"};
+
+    display: inline-block;
+
+    width: 1.25rem;
+    height: 1.25rem;
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-radius: 0.625rem;
+
+    transition: left 100ms linear;
+`;
+
+    function Switch({
+        className,
+        initialValue = false,
+        labels = {
+            off: "OFF",
+            on: "ON"
+        },
+        lightDark = false,
+        onChange: onChange2,
+        style: style2,
+        value
+    }, ref2) {
+        const [enabled, setEnabled] = React.useState(value || initialValue);
+        const labelIconToShow = React.useMemo(() => {
+            if (lightDark) {
+                return enabled ? jsxRuntime.exports.jsx(Sun, {}) : jsxRuntime.exports.jsx(Moon, {});
+            }
+            return enabled ? labels.on : labels.off;
+        }, [labels, lightDark, enabled]);
+        React.useEffect(() => {
+            if (value !== void 0) {
+                setEnabled(value);
+            }
+        }, [value]);
+        const onClick = () => {
+            if (value === void 0) {
+                setEnabled(!enabled);
+            }
+            onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(!enabled);
+        };
+        return jsxRuntime.exports.jsxs(SwitchWrapper, {
+            className,
+            "data-testid": "wrapper",
+            enabled,
+            onClick,
+            ref: ref2,
+            style: style2,
+            children: [jsxRuntime.exports.jsx(SwitchHandle, {
+                "data-testid": "handle",
+                enabled
+            }), jsxRuntime.exports.jsx("div", {
+                style: {
+                    userSelect: "none"
+                },
+                children: labelIconToShow
+            })]
+        });
+    }
+    React.forwardRef(Switch);
+
+    function _objectWithoutPropertiesLoose$1(source, excluded) {
+        if (source == null)
+            return {};
+        var target = {};
+        var sourceKeys = Object.keys(source);
+        var key, i2;
+        for (i2 = 0; i2 < sourceKeys.length; i2++) {
+            key = sourceKeys[i2];
+            if (excluded.indexOf(key) >= 0)
+                continue;
+            target[key] = source[key];
+        }
+        return target;
+    }
+    var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
+    var now = hasNativePerformanceNow ? function() {
+        return performance.now();
+    } : function() {
+        return Date.now();
+    };
+
+    function cancelTimeout(timeoutID) {
+        cancelAnimationFrame(timeoutID.id);
+    }
+
+    function requestTimeout(callback, delay) {
+        var start2 = now();
+
+        function tick() {
+            if (now() - start2 >= delay) {
+                callback.call(null);
+            } else {
+                timeoutID.id = requestAnimationFrame(tick);
+            }
+        }
+        var timeoutID = {
+            id: requestAnimationFrame(tick)
+        };
+        return timeoutID;
+    }
+    var size = -1;
+
+    function getScrollbarSize(recalculate) {
+        if (recalculate === void 0) {
+            recalculate = false;
+        }
+        if (size === -1 || recalculate) {
+            var div2 = document.createElement("div");
+            var style2 = div2.style;
+            style2.width = "50px";
+            style2.height = "50px";
+            style2.overflow = "scroll";
+            document.body.appendChild(div2);
+            size = div2.offsetWidth - div2.clientWidth;
+            document.body.removeChild(div2);
+        }
+        return size;
+    }
+    var cachedRTLResult = null;
+
+    function getRTLOffsetType(recalculate) {
+        if (recalculate === void 0) {
+            recalculate = false;
+        }
+        if (cachedRTLResult === null || recalculate) {
+            var outerDiv = document.createElement("div");
+            var outerStyle = outerDiv.style;
+            outerStyle.width = "50px";
+            outerStyle.height = "50px";
+            outerStyle.overflow = "scroll";
+            outerStyle.direction = "rtl";
+            var innerDiv = document.createElement("div");
+            var innerStyle = innerDiv.style;
+            innerStyle.width = "100px";
+            innerStyle.height = "100px";
+            outerDiv.appendChild(innerDiv);
+            document.body.appendChild(outerDiv);
+            if (outerDiv.scrollLeft > 0) {
+                cachedRTLResult = "positive-descending";
+            } else {
+                outerDiv.scrollLeft = 1;
+                if (outerDiv.scrollLeft === 0) {
+                    cachedRTLResult = "negative";
+                } else {
+                    cachedRTLResult = "positive-ascending";
+                }
+            }
+            document.body.removeChild(outerDiv);
+            return cachedRTLResult;
+        }
+        return cachedRTLResult;
+    }
+    var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
+    var defaultItemKey$1 = function defaultItemKey(index2, data2) {
+        return index2;
+    };
+
+    function createListComponent(_ref2) {
+        var _class;
+        var getItemOffset = _ref2.getItemOffset,
+            getEstimatedTotalSize = _ref2.getEstimatedTotalSize,
+            getItemSize = _ref2.getItemSize,
+            getOffsetForIndexAndAlignment = _ref2.getOffsetForIndexAndAlignment,
+            getStartIndexForOffset = _ref2.getStartIndexForOffset,
+            getStopIndexForStartIndex = _ref2.getStopIndexForStartIndex,
+            initInstanceProps = _ref2.initInstanceProps,
+            shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
+            validateProps = _ref2.validateProps;
+        return _class = /* @__PURE__ */ function(_PureComponent) {
+            _inheritsLoose(List2, _PureComponent);
+
+            function List2(props) {
+                var _this;
+                _this = _PureComponent.call(this, props) || this;
+                _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized$2(_this));
+                _this._outerRef = void 0;
+                _this._resetIsScrollingTimeoutId = null;
+                _this.state = {
+                    instance: _assertThisInitialized$2(_this),
+                    isScrolling: false,
+                    scrollDirection: "forward",
+                    scrollOffset: typeof _this.props.initialScrollOffset === "number" ? _this.props.initialScrollOffset : 0,
+                    scrollUpdateWasRequested: false
+                };
+                _this._callOnItemsRendered = void 0;
+                _this._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
+                    return _this.props.onItemsRendered({
+                        overscanStartIndex,
+                        overscanStopIndex,
+                        visibleStartIndex,
+                        visibleStopIndex
+                    });
+                });
+                _this._callOnScroll = void 0;
+                _this._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
+                    return _this.props.onScroll({
+                        scrollDirection,
+                        scrollOffset,
+                        scrollUpdateWasRequested
+                    });
+                });
+                _this._getItemStyle = void 0;
+                _this._getItemStyle = function(index2) {
+                    var _this$props = _this.props,
+                        direction = _this$props.direction,
+                        itemSize = _this$props.itemSize,
+                        layout2 = _this$props.layout;
+                    var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout2, shouldResetStyleCacheOnItemSizeChange && direction);
+                    var style2;
+                    if (itemStyleCache.hasOwnProperty(index2)) {
+                        style2 = itemStyleCache[index2];
+                    } else {
+                        var _offset = getItemOffset(_this.props, index2, _this._instanceProps);
+                        var size2 = getItemSize(_this.props, index2, _this._instanceProps);
+                        var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+                        var isRtl = direction === "rtl";
+                        var offsetHorizontal = isHorizontal ? _offset : 0;
+                        itemStyleCache[index2] = style2 = {
+                            position: "absolute",
+                            left: isRtl ? void 0 : offsetHorizontal,
+                            right: isRtl ? offsetHorizontal : void 0,
+                            top: !isHorizontal ? _offset : 0,
+                            height: !isHorizontal ? size2 : "100%",
+                            width: isHorizontal ? size2 : "100%"
+                        };
+                    }
+                    return style2;
+                };
+                _this._getItemStyleCache = void 0;
+                _this._getItemStyleCache = memoizeOne(function(_2, __, ___) {
+                    return {};
+                });
+                _this._onScrollHorizontal = function(event2) {
+                    var _event$currentTarget = event2.currentTarget,
+                        clientWidth = _event$currentTarget.clientWidth,
+                        scrollLeft = _event$currentTarget.scrollLeft,
+                        scrollWidth = _event$currentTarget.scrollWidth;
+                    _this.setState(function(prevState) {
+                        if (prevState.scrollOffset === scrollLeft) {
+                            return null;
+                        }
+                        var direction = _this.props.direction;
+                        var scrollOffset = scrollLeft;
+                        if (direction === "rtl") {
+                            switch (getRTLOffsetType()) {
+                                case "negative":
+                                    scrollOffset = -scrollLeft;
+                                    break;
+                                case "positive-descending":
+                                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
+                                    break;
+                            }
+                        }
+                        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
+                        return {
+                            isScrolling: true,
+                            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
+                            scrollOffset,
+                            scrollUpdateWasRequested: false
+                        };
+                    }, _this._resetIsScrollingDebounced);
+                };
+                _this._onScrollVertical = function(event2) {
+                    var _event$currentTarget2 = event2.currentTarget,
+                        clientHeight = _event$currentTarget2.clientHeight,
+                        scrollHeight = _event$currentTarget2.scrollHeight,
+                        scrollTop = _event$currentTarget2.scrollTop;
+                    _this.setState(function(prevState) {
+                        if (prevState.scrollOffset === scrollTop) {
+                            return null;
+                        }
+                        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
+                        return {
+                            isScrolling: true,
+                            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
+                            scrollOffset,
+                            scrollUpdateWasRequested: false
+                        };
+                    }, _this._resetIsScrollingDebounced);
+                };
+                _this._outerRefSetter = function(ref2) {
+                    var outerRef = _this.props.outerRef;
+                    _this._outerRef = ref2;
+                    if (typeof outerRef === "function") {
+                        outerRef(ref2);
+                    } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
+                        outerRef.current = ref2;
+                    }
+                };
+                _this._resetIsScrollingDebounced = function() {
+                    if (_this._resetIsScrollingTimeoutId !== null) {
+                        cancelTimeout(_this._resetIsScrollingTimeoutId);
+                    }
+                    _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
+                };
+                _this._resetIsScrolling = function() {
+                    _this._resetIsScrollingTimeoutId = null;
+                    _this.setState({
+                        isScrolling: false
+                    }, function() {
+                        _this._getItemStyleCache(-1, null);
+                    });
+                };
+                return _this;
+            }
+            List2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
+                validateSharedProps$1(nextProps, prevState);
+                validateProps(nextProps);
+                return null;
+            };
+            var _proto = List2.prototype;
+            _proto.scrollTo = function scrollTo(scrollOffset) {
+                scrollOffset = Math.max(0, scrollOffset);
+                this.setState(function(prevState) {
+                    if (prevState.scrollOffset === scrollOffset) {
+                        return null;
+                    }
+                    return {
+                        scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
+                        scrollOffset,
+                        scrollUpdateWasRequested: true
+                    };
+                }, this._resetIsScrollingDebounced);
+            };
+            _proto.scrollToItem = function scrollToItem(index2, align) {
+                if (align === void 0) {
+                    align = "auto";
+                }
+                var _this$props2 = this.props,
+                    itemCount = _this$props2.itemCount,
+                    layout2 = _this$props2.layout;
+                var scrollOffset = this.state.scrollOffset;
+                index2 = Math.max(0, Math.min(index2, itemCount - 1));
+                var scrollbarSize = 0;
+                if (this._outerRef) {
+                    var outerRef = this._outerRef;
+                    if (layout2 === "vertical") {
+                        scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
+                    } else {
+                        scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
+                    }
+                }
+                this.scrollTo(getOffsetForIndexAndAlignment(this.props, index2, align, scrollOffset, this._instanceProps, scrollbarSize));
+            };
+            _proto.componentDidMount = function componentDidMount() {
+                var _this$props3 = this.props,
+                    direction = _this$props3.direction,
+                    initialScrollOffset = _this$props3.initialScrollOffset,
+                    layout2 = _this$props3.layout;
+                if (typeof initialScrollOffset === "number" && this._outerRef != null) {
+                    var outerRef = this._outerRef;
+                    if (direction === "horizontal" || layout2 === "horizontal") {
+                        outerRef.scrollLeft = initialScrollOffset;
+                    } else {
+                        outerRef.scrollTop = initialScrollOffset;
+                    }
+                }
+                this._callPropsCallbacks();
+            };
+            _proto.componentDidUpdate = function componentDidUpdate() {
+                var _this$props4 = this.props,
+                    direction = _this$props4.direction,
+                    layout2 = _this$props4.layout;
+                var _this$state = this.state,
+                    scrollOffset = _this$state.scrollOffset,
+                    scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
+                if (scrollUpdateWasRequested && this._outerRef != null) {
+                    var outerRef = this._outerRef;
+                    if (direction === "horizontal" || layout2 === "horizontal") {
+                        if (direction === "rtl") {
+                            switch (getRTLOffsetType()) {
+                                case "negative":
+                                    outerRef.scrollLeft = -scrollOffset;
+                                    break;
+                                case "positive-ascending":
+                                    outerRef.scrollLeft = scrollOffset;
+                                    break;
+                                default:
+                                    var clientWidth = outerRef.clientWidth,
+                                        scrollWidth = outerRef.scrollWidth;
+                                    outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
+                                    break;
+                            }
+                        } else {
+                            outerRef.scrollLeft = scrollOffset;
+                        }
+                    } else {
+                        outerRef.scrollTop = scrollOffset;
+                    }
+                }
+                this._callPropsCallbacks();
+            };
+            _proto.componentWillUnmount = function componentWillUnmount() {
+                if (this._resetIsScrollingTimeoutId !== null) {
+                    cancelTimeout(this._resetIsScrollingTimeoutId);
+                }
+            };
+            _proto.render = function render2() {
+                var _this$props5 = this.props,
+                    children2 = _this$props5.children,
+                    className = _this$props5.className,
+                    direction = _this$props5.direction,
+                    height = _this$props5.height,
+                    innerRef = _this$props5.innerRef,
+                    innerElementType = _this$props5.innerElementType,
+                    innerTagName = _this$props5.innerTagName,
+                    itemCount = _this$props5.itemCount,
+                    itemData = _this$props5.itemData,
+                    _this$props5$itemKey = _this$props5.itemKey,
+                    itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,
+                    layout2 = _this$props5.layout,
+                    outerElementType = _this$props5.outerElementType,
+                    outerTagName = _this$props5.outerTagName,
+                    style2 = _this$props5.style,
+                    useIsScrolling = _this$props5.useIsScrolling,
+                    width = _this$props5.width;
+                var isScrolling = this.state.isScrolling;
+                var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+                var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
+                var _this$_getRangeToRend = this._getRangeToRender(),
+                    startIndex = _this$_getRangeToRend[0],
+                    stopIndex = _this$_getRangeToRend[1];
+                var items = [];
+                if (itemCount > 0) {
+                    for (var _index = startIndex; _index <= stopIndex; _index++) {
+                        items.push(React.createElement(children2, {
+                            data: itemData,
+                            key: itemKey(_index, itemData),
+                            index: _index,
+                            isScrolling: useIsScrolling ? isScrolling : void 0,
+                            style: this._getItemStyle(_index)
+                        }));
+                    }
                 }
-            }
-        }
-        match(code2, pos, end2) {
-            let match2 = null;
-            for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
-                let index2 = this.matches[i2],
-                    keep = false;
-                if (this.query.charCodeAt(index2) == code2) {
-                    if (index2 == this.query.length - 1) {
-                        match2 = {
-                            from: this.matches[i2 + 1],
-                            to: end2
-                        };
-                    } else {
-                        this.matches[i2]++;
-                        keep = true;
+                var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
+                return React.createElement(outerElementType || outerTagName || "div", {
+                    className,
+                    onScroll,
+                    ref: this._outerRefSetter,
+                    style: _extends$1({
+                        position: "relative",
+                        height,
+                        width,
+                        overflow: "auto",
+                        WebkitOverflowScrolling: "touch",
+                        willChange: "transform",
+                        direction
+                    }, style2)
+                }, React.createElement(innerElementType || innerTagName || "div", {
+                    children: items,
+                    ref: innerRef,
+                    style: {
+                        height: isHorizontal ? "100%" : estimatedTotalSize,
+                        pointerEvents: isScrolling ? "none" : void 0,
+                        width: isHorizontal ? estimatedTotalSize : "100%"
+                    }
+                }));
+            };
+            _proto._callPropsCallbacks = function _callPropsCallbacks() {
+                if (typeof this.props.onItemsRendered === "function") {
+                    var itemCount = this.props.itemCount;
+                    if (itemCount > 0) {
+                        var _this$_getRangeToRend2 = this._getRangeToRender(),
+                            _overscanStartIndex = _this$_getRangeToRend2[0],
+                            _overscanStopIndex = _this$_getRangeToRend2[1],
+                            _visibleStartIndex = _this$_getRangeToRend2[2],
+                            _visibleStopIndex = _this$_getRangeToRend2[3];
+                        this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
                     }
                 }
-                if (!keep) {
-                    this.matches.splice(i2, 2);
-                    i2 -= 2;
+                if (typeof this.props.onScroll === "function") {
+                    var _this$state2 = this.state,
+                        _scrollDirection = _this$state2.scrollDirection,
+                        _scrollOffset = _this$state2.scrollOffset,
+                        _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
+                    this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
                 }
-            }
-            if (this.query.charCodeAt(0) == code2) {
-                if (this.query.length == 1)
-                    match2 = {
-                        from: pos,
-                        to: end2
-                    };
-                else
-                    this.matches.push(1, pos);
-            }
-            if (match2 && this.test && !this.test(match2.from, match2.to, this.buffer, this.bufferStart))
-                match2 = null;
-            return match2;
-        }
+            };
+            _proto._getRangeToRender = function _getRangeToRender() {
+                var _this$props6 = this.props,
+                    itemCount = _this$props6.itemCount,
+                    overscanCount = _this$props6.overscanCount;
+                var _this$state3 = this.state,
+                    isScrolling = _this$state3.isScrolling,
+                    scrollDirection = _this$state3.scrollDirection,
+                    scrollOffset = _this$state3.scrollOffset;
+                if (itemCount === 0) {
+                    return [0, 0, 0, 0];
+                }
+                var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
+                var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps);
+                var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
+                var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
+                return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
+            };
+            return List2;
+        }(React.PureComponent), _class.defaultProps = {
+            direction: "ltr",
+            itemData: void 0,
+            layout: "vertical",
+            overscanCount: 2,
+            useIsScrolling: false
+        }, _class;
     }
-    if (typeof Symbol != "undefined")
-        SearchCursor.prototype[Symbol.iterator] = function() {
-            return this;
-        };
-    const empty$1 = {
-        from: -1,
-        to: -1,
-        match: /* @__PURE__ */ /.*/.exec("")
+    var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
+        _ref2.children;
+        _ref2.direction;
+        _ref2.height;
+        _ref2.layout;
+        _ref2.innerTagName;
+        _ref2.outerTagName;
+        _ref2.width;
+        _ref3.instance;
     };
-    const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
-    class RegExpCursor {
-        constructor(text2, query, options, from = 0, to2 = text2.length) {
-            this.text = text2;
-            this.to = to2;
-            this.curLine = "";
-            this.done = false;
-            this.value = empty$1;
-            if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
-                return new MultilineRegExpCursor(text2, query, options, from, to2);
-            this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
-            this.test = options === null || options === void 0 ? void 0 : options.test;
-            this.iter = text2.iter();
-            let startLine = text2.lineAt(from);
-            this.curLineStart = startLine.from;
-            this.matchPos = toCharEnd(text2, from);
-            this.getLine(this.curLineStart);
-        }
-        getLine(skip) {
-            this.iter.next(skip);
-            if (this.iter.lineBreak) {
-                this.curLine = "";
-            } else {
-                this.curLine = this.iter.value;
-                if (this.curLineStart + this.curLine.length > this.to)
-                    this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
-                this.iter.next();
+    var FixedSizeList = /* @__PURE__ */ createListComponent({
+        getItemOffset: function getItemOffset(_ref2, index2) {
+            var itemSize = _ref2.itemSize;
+            return index2 * itemSize;
+        },
+        getItemSize: function getItemSize(_ref2, index2) {
+            var itemSize = _ref2.itemSize;
+            return itemSize;
+        },
+        getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
+            var itemCount = _ref3.itemCount,
+                itemSize = _ref3.itemSize;
+            return itemSize * itemCount;
+        },
+        getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index2, align, scrollOffset, instanceProps, scrollbarSize) {
+            var direction = _ref4.direction,
+                height = _ref4.height,
+                itemCount = _ref4.itemCount,
+                itemSize = _ref4.itemSize,
+                layout2 = _ref4.layout,
+                width = _ref4.width;
+            var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+            var size2 = isHorizontal ? width : height;
+            var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
+            var maxOffset2 = Math.min(lastItemOffset, index2 * itemSize);
+            var minOffset = Math.max(0, index2 * itemSize - size2 + itemSize + scrollbarSize);
+            if (align === "smart") {
+                if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset2 + size2) {
+                    align = "auto";
+                } else {
+                    align = "center";
+                }
             }
-        }
-        nextLine() {
-            this.curLineStart = this.curLineStart + this.curLine.length + 1;
-            if (this.curLineStart > this.to)
-                this.curLine = "";
-            else
-                this.getLine(0);
-        }
-        next() {
-            for (let off = this.matchPos - this.curLineStart;;) {
-                this.re.lastIndex = off;
-                let match2 = this.matchPos <= this.to && this.re.exec(this.curLine);
-                if (match2) {
-                    let from = this.curLineStart + match2.index,
-                        to2 = from + match2[0].length;
-                    this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
-                    if (from == this.curLineStart + this.curLine.length)
-                        this.nextLine();
-                    if ((from < to2 || from > this.value.to) && (!this.test || this.test(from, to2, match2))) {
-                        this.value = {
-                            from,
-                            to: to2,
-                            match: match2
-                        };
-                        return this;
+            switch (align) {
+                case "start":
+                    return maxOffset2;
+                case "end":
+                    return minOffset;
+                case "center": {
+                    var middleOffset = Math.round(minOffset + (maxOffset2 - minOffset) / 2);
+                    if (middleOffset < Math.ceil(size2 / 2)) {
+                        return 0;
+                    } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
+                        return lastItemOffset;
+                    } else {
+                        return middleOffset;
                     }
-                    off = this.matchPos - this.curLineStart;
-                } else if (this.curLineStart + this.curLine.length < this.to) {
-                    this.nextLine();
-                    off = 0;
-                } else {
-                    this.done = true;
-                    return this;
                 }
+                case "auto":
+                default:
+                    if (scrollOffset >= minOffset && scrollOffset <= maxOffset2) {
+                        return scrollOffset;
+                    } else if (scrollOffset < minOffset) {
+                        return minOffset;
+                    } else {
+                        return maxOffset2;
+                    }
             }
+        },
+        getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset2) {
+            var itemCount = _ref5.itemCount,
+                itemSize = _ref5.itemSize;
+            return Math.max(0, Math.min(itemCount - 1, Math.floor(offset2 / itemSize)));
+        },
+        getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
+            var direction = _ref6.direction,
+                height = _ref6.height,
+                itemCount = _ref6.itemCount,
+                itemSize = _ref6.itemSize,
+                layout2 = _ref6.layout,
+                width = _ref6.width;
+            var isHorizontal = direction === "horizontal" || layout2 === "horizontal";
+            var offset2 = startIndex * itemSize;
+            var size2 = isHorizontal ? width : height;
+            var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
+            return Math.max(0, Math.min(
+                itemCount - 1,
+                startIndex + numVisibleItems - 1
+            ));
+        },
+        initInstanceProps: function initInstanceProps(props) {},
+        shouldResetStyleCacheOnItemSizeChange: true,
+        validateProps: function validateProps(_ref7) {
+            _ref7.itemSize;
         }
-    }
-    const flattened = /* @__PURE__ */ new WeakMap();
-    class FlattenedDoc {
-        constructor(from, text2) {
-            this.from = from;
-            this.text = text2;
-        }
-        get to() {
-            return this.from + this.text.length;
-        }
-        static get(doc2, from, to2) {
-            let cached = flattened.get(doc2);
-            if (!cached || cached.from >= to2 || cached.to <= from) {
-                let flat = new FlattenedDoc(from, doc2.sliceString(from, to2));
-                flattened.set(doc2, flat);
-                return flat;
-            }
-            if (cached.from == from && cached.to == to2)
-                return cached;
-            let {
-                text: text2,
-                from: cachedFrom
-            } = cached;
-            if (cachedFrom > from) {
-                text2 = doc2.sliceString(from, cachedFrom) + text2;
-                cachedFrom = from;
+    });
+
+    function shallowDiffers(prev, next2) {
+        for (var attribute in prev) {
+            if (!(attribute in next2)) {
+                return true;
             }
-            if (cached.to < to2)
-                text2 += doc2.sliceString(cached.to, to2);
-            flattened.set(doc2, new FlattenedDoc(cachedFrom, text2));
-            return new FlattenedDoc(from, text2.slice(from - cachedFrom, to2 - cachedFrom));
-        }
-    }
-    class MultilineRegExpCursor {
-        constructor(text2, query, options, from, to2) {
-            this.text = text2;
-            this.to = to2;
-            this.done = false;
-            this.value = empty$1;
-            this.matchPos = toCharEnd(text2, from);
-            this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
-            this.test = options === null || options === void 0 ? void 0 : options.test;
-            this.flat = FlattenedDoc.get(text2, from, this.chunkEnd(from + 5e3));
-        }
-        chunkEnd(pos) {
-            return pos >= this.to ? this.to : this.text.lineAt(pos).to;
         }
-        next() {
-            for (;;) {
-                let off = this.re.lastIndex = this.matchPos - this.flat.from;
-                let match2 = this.re.exec(this.flat.text);
-                if (match2 && !match2[0] && match2.index == off) {
-                    this.re.lastIndex = off + 1;
-                    match2 = this.re.exec(this.flat.text);
-                }
-                if (match2) {
-                    let from = this.flat.from + match2.index,
-                        to2 = from + match2[0].length;
-                    if ((this.flat.to >= this.to || match2.index + match2[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to2, match2))) {
-                        this.value = {
-                            from,
-                            to: to2,
-                            match: match2
-                        };
-                        this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
-                        return this;
-                    }
-                }
-                if (this.flat.to == this.to) {
-                    this.done = true;
-                    return this;
-                }
-                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
+        for (var _attribute in next2) {
+            if (prev[_attribute] !== next2[_attribute]) {
+                return true;
             }
         }
+        return false;
     }
-    if (typeof Symbol != "undefined") {
-        RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
-            return this;
-        };
-    }
+    var _excluded$1 = ["style"],
+        _excluded2 = ["style"];
 
-    function validRegExp(source) {
-        try {
-            new RegExp(source, baseFlags);
-            return true;
-        } catch (_a3) {
-            return false;
-        }
+    function areEqual(prevProps, nextProps) {
+        var prevStyle = prevProps.style,
+            prevRest = _objectWithoutPropertiesLoose$1(prevProps, _excluded$1);
+        var nextStyle = nextProps.style,
+            nextRest = _objectWithoutPropertiesLoose$1(nextProps, _excluded2);
+        return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
     }
+    const GlobalStyle = styled.createGlobalStyle`
+    body {
+        /* stylelint-disable-next-line -- external classname */
+        .DatetimeFilterSelect {
+            background-color: ${(props) => props.theme.colors.grey1};
 
-    function toCharEnd(text2, pos) {
-        if (pos >= text2.length)
-            return pos;
-        let line = text2.lineAt(pos),
-            next2;
-        while (pos < line.to && (next2 = line.text.charCodeAt(pos - line.from)) >= 56320 && next2 < 57344)
-            pos++;
-        return pos;
-    }
+            span {
+                background-color: ${(props) => props.theme.colors.grey1};
+                border-bottom: 1px solid ${(props) => props.theme.colors.grey1};
 
-    function createLineDialog(view) {
-        let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
-        let input = crelt("input", {
-            class: "cm-textfield",
-            name: "line",
-            value: line
-        });
-        let dom2 = crelt("form", {
-            class: "cm-gotoLine",
-            onkeydown: (event2) => {
-                if (event2.keyCode == 27) {
-                    event2.preventDefault();
-                    view.dispatch({
-                        effects: dialogEffect.of(false)
-                    });
-                    view.focus();
-                } else if (event2.keyCode == 13) {
-                    event2.preventDefault();
-                    go2();
+                &[aria-selected="true"] {
+                    background-color: ${(props) => props.theme.colors.primary};
                 }
-            },
-            onsubmit: (event2) => {
-                event2.preventDefault();
-                go2();
-            }
-        }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
-            class: "cm-button",
-            type: "submit"
-        }, view.state.phrase("go")));
 
-        function go2() {
-            let match2 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
-            if (!match2)
-                return;
-            let {
-                state
-            } = view, startLine = state.doc.lineAt(state.selection.main.head);
-            let [, sign2, ln, cl, percent] = match2;
-            let col = cl ? +cl.slice(1) : 0;
-            let line2 = ln ? +ln : startLine.number;
-            if (ln && percent) {
-                let pc = line2 / 100;
-                if (sign2)
-                    pc = pc * (sign2 == "-" ? -1 : 1) + startLine.number / state.doc.lines;
-                line2 = Math.round(state.doc.lines * pc);
-            } else if (ln && sign2) {
-                line2 = line2 * (sign2 == "-" ? -1 : 1) + startLine.number;
-            }
-            let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
-            let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
-            view.dispatch({
-                effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, {
-                    y: "center"
-                })],
-                selection: selection2
-            });
-            view.focus();
-        }
-        return {
-            dom: dom2
-        };
-    }
-    const dialogEffect = /* @__PURE__ */ StateEffect.define();
-    const dialogField = /* @__PURE__ */ StateField.define({
-        create() {
-            return true;
-        },
-        update(value, tr2) {
-            for (let e3 of tr2.effects)
-                if (e3.is(dialogEffect))
-                    value = e3.value;
-            return value;
-        },
-        provide: (f2) => showPanel.from(f2, (val) => val ? createLineDialog : null)
-    });
-    const gotoLine = (view) => {
-        let panel = getPanel(view, createLineDialog);
-        if (!panel) {
-            let effects = [dialogEffect.of(true)];
-            if (view.state.field(dialogField, false) == null)
-                effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
-            view.dispatch({
-                effects
-            });
-            panel = getPanel(view, createLineDialog);
-        }
-        if (panel)
-            panel.dom.querySelector("input").select();
-        return true;
-    };
-    const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
-        ".cm-panel.cm-gotoLine": {
-            padding: "2px 6px 4px",
-            "& label": {
-                fontSize: "80%"
-            }
-        }
-    });
-    const selectWord = ({
-        state,
-        dispatch: dispatch2
-    }) => {
-        let {
-            selection: selection2
-        } = state;
-        let newSel = EditorSelection.create(selection2.ranges.map((range2) => state.wordAt(range2.head) || EditorSelection.cursor(range2.head)), selection2.mainIndex);
-        if (newSel.eq(selection2))
-            return false;
-        dispatch2(state.update({
-            selection: newSel
-        }));
-        return true;
-    };
+                :hover {
+                    background-color: ${(props) => props.theme.colors.grey3};
+                }
 
-    function findNextOccurrence(state, query) {
-        let {
-            main: main2,
-            ranges
-        } = state.selection;
-        let word = state.wordAt(main2.head),
-            fullWord = word && word.from == main2.from && word.to == main2.to;
-        for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
-            cursor.next();
-            if (cursor.done) {
-                if (cycled)
-                    return null;
-                cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
-                cycled = true;
-            } else {
-                if (cycled && ranges.some((r2) => r2.from == cursor.value.from))
-                    continue;
-                if (fullWord) {
-                    let word2 = state.wordAt(cursor.value.from);
-                    if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
-                        continue;
+                :active {
+                    background-color: ${(props) => props.theme.colors.grey4};
                 }
-                return cursor.value;
             }
         }
     }
-    const selectNextOccurrence = ({
-        state,
-        dispatch: dispatch2
-    }) => {
-        let {
-            ranges
-        } = state.selection;
-        if (ranges.some((sel) => sel.from === sel.to))
-            return selectWord({
-                state,
-                dispatch: dispatch2
-            });
-        let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
-        if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
-            return false;
-        let range2 = findNextOccurrence(state, searchedText);
-        if (!range2)
-            return false;
-        dispatch2(state.update({
-            selection: state.selection.addRange(EditorSelection.range(range2.from, range2.to), false),
-            effects: EditorView.scrollIntoView(range2.to)
-        }));
-        return true;
-    };
-    const searchConfigFacet = /* @__PURE__ */ Facet.define({
-        combine(configs) {
-            return combineConfig(configs, {
-                top: false,
-                caseSensitive: false,
-                literal: false,
-                regexp: false,
-                wholeWord: false,
-                createPanel: (view) => new SearchPanel(view),
-                scrollToMatch: (range2) => EditorView.scrollIntoView(range2)
-            });
-        }
-    });
-    class SearchQuery {
-        constructor(config2) {
-            this.search = config2.search;
-            this.caseSensitive = !!config2.caseSensitive;
-            this.literal = !!config2.literal;
-            this.regexp = !!config2.regexp;
-            this.replace = config2.replace || "";
-            this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
-            this.unquoted = this.unquote(this.search);
-            this.wholeWord = !!config2.wholeWord;
-        }
-        unquote(text2) {
-            return this.literal ? text2 : text2.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
-        }
-        eq(other) {
-            return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
-        }
-        create() {
-            return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
-        }
-        getCursor(state, from = 0, to2) {
-            let st2 = state.doc ? state : EditorState.create({
-                doc: state
-            });
-            if (to2 == null)
-                to2 = st2.doc.length;
-            return this.regexp ? regexpCursor(this, st2, from, to2) : stringCursor(this, st2, from, to2);
-        }
-    }
-    class QueryType {
-        constructor(spec) {
-            this.spec = spec;
-        }
-    }
+`;
+    const DatetimeFilterWrapper = styled__default.default(FilterWrapper)`
+    gap: 0;
+`;
+    const DatepickerWrapper = styled__default.default.div`
+    height: auto;
 
-    function stringCursor(spec, state, from, to2) {
-        return new SearchCursor(state.doc, spec.unquoted, from, to2, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
+    div:has(input) {
+        width: 6.7rem;
     }
 
-    function stringWordTest(doc2, categorizer) {
-        return (from, to2, buf, bufPos) => {
-            if (bufPos > from || bufPos + buf.length < to2) {
-                bufPos = Math.max(0, from - 2);
-                buf = doc2.sliceString(bufPos, Math.min(doc2.length, to2 + 2));
-            }
-            return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to2 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to2 - bufPos)) != CharCategory.Word);
-        };
-    }
-    class StringQuery extends QueryType {
-        constructor(spec) {
-            super(spec);
-        }
-        nextMatch(state, curFrom, curTo) {
-            let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
-            if (cursor.done)
-                cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
-            return cursor.done ? null : cursor.value;
-        }
-        prevMatchInRange(state, from, to2) {
-            for (let pos = to2;;) {
-                let start2 = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
-                let cursor = stringCursor(this.spec, state, start2, pos),
-                    range2 = null;
-                while (!cursor.nextOverlapping().done)
-                    range2 = cursor.value;
-                if (range2)
-                    return range2;
-                if (start2 == from)
-                    return null;
-                pos -= 1e4;
-            }
-        }
-        prevMatch(state, curFrom, curTo) {
-            return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
-        }
-        getReplacement(_result) {
-            return this.spec.unquote(this.spec.replace);
-        }
-        matchAll(state, limit) {
-            let cursor = stringCursor(this.spec, state, 0, state.doc.length),
-                ranges = [];
-            while (!cursor.next().done) {
-                if (ranges.length >= limit)
-                    return null;
-                ranges.push(cursor.value);
-            }
-            return ranges;
-        }
-        highlight(state, from, to2, add2) {
-            let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, state.doc.length));
-            while (!cursor.next().done)
-                add2(cursor.value.from, cursor.value.to);
-        }
-    }
+    input {
+        width: 6.7rem;
+        padding: 0;
+        background-color: ${(props) => props.theme.colors.background};
+        border: 1px solid ${(props) => props.theme.colors.background};
 
-    function regexpCursor(spec, state, from, to2) {
-        return new RegExpCursor(state.doc, spec.search, {
-            ignoreCase: !spec.caseSensitive,
-            test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
-        }, from, to2);
-    }
+        ::after {
+            width: 5rem;
+        }
 
-    function charBefore(str, index2) {
-        return str.slice(findClusterBreak(str, index2, false), index2);
+        :hover:not(:disabled) {
+            background-color: ${(props) => props.theme.colors.background};
+            border: 1px solid ${(props) => props.theme.colors.grey4};
+        }
     }
 
-    function charAfter(str, index2) {
-        return str.slice(index2, findClusterBreak(str, index2));
-    }
+    div:has(> button) {
+        border: 1px solid ${(props) => props.theme.colors.grey1};
 
-    function regexpWordTest(categorizer) {
-        return (_from, _to, match2) => !match2[0].length || (categorizer(charBefore(match2.input, match2.index)) != CharCategory.Word || categorizer(charAfter(match2.input, match2.index)) != CharCategory.Word) && (categorizer(charAfter(match2.input, match2.index + match2[0].length)) != CharCategory.Word || categorizer(charBefore(match2.input, match2.index + match2[0].length)) != CharCategory.Word);
-    }
-    class RegExpQuery extends QueryType {
-        nextMatch(state, curFrom, curTo) {
-            let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
-            if (cursor.done)
-                cursor = regexpCursor(this.spec, state, 0, curFrom).next();
-            return cursor.done ? null : cursor.value;
-        }
-        prevMatchInRange(state, from, to2) {
-            for (let size = 1;; size++) {
-                let start2 = Math.max(from, to2 - size * 1e4);
-                let cursor = regexpCursor(this.spec, state, start2, to2),
-                    range2 = null;
-                while (!cursor.next().done)
-                    range2 = cursor.value;
-                if (range2 && (start2 == from || range2.from > start2 + 10))
-                    return range2;
-                if (start2 == from)
-                    return null;
-            }
-        }
-        prevMatch(state, curFrom, curTo) {
-            return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
-        }
-        getReplacement(result) {
-            return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m2, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m2);
-        }
-        matchAll(state, limit) {
-            let cursor = regexpCursor(this.spec, state, 0, state.doc.length),
-                ranges = [];
-            while (!cursor.next().done) {
-                if (ranges.length >= limit)
-                    return null;
-                ranges.push(cursor.value);
-            }
-            return ranges;
+        :hover {
+            border: 1px solid ${(props) => props.theme.colors.grey1};
         }
-        highlight(state, from, to2, add2) {
-            let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to2 + 250, state.doc.length));
-            while (!cursor.next().done)
-                add2(cursor.value.from, cursor.value.to);
+
+        :focus-within {
+            border: 1px solid ${(props) => props.theme.colors.grey1};
         }
     }
-    const setSearchQuery = /* @__PURE__ */ StateEffect.define();
-    const togglePanel = /* @__PURE__ */ StateEffect.define();
-    const searchState = /* @__PURE__ */ StateField.define({
-        create(state) {
-            return new SearchState(defaultQuery(state).create(), null);
-        },
-        update(value, tr2) {
-            for (let effect2 of tr2.effects) {
-                if (effect2.is(setSearchQuery))
-                    value = new SearchState(effect2.value.create(), value.panel);
-                else if (effect2.is(togglePanel))
-                    value = new SearchState(value.query, effect2.value ? createSearchPanel : null);
-            }
-            return value;
-        },
-        provide: (f2) => showPanel.from(f2, (val) => val.panel)
-    });
-    class SearchState {
-        constructor(query, panel) {
-            this.query = query;
-            this.panel = panel;
+
+    button {
+        background-color: ${(props) => props.theme.colors.grey1};
+
+        :hover:enabled {
+            background-color: ${(props) => props.theme.colors.grey2};
         }
     }
-    const matchMark = /* @__PURE__ */ Decoration.mark({
-            class: "cm-searchMatch"
-        }),
-        selectedMatchMark = /* @__PURE__ */ Decoration.mark({
-            class: "cm-searchMatch cm-searchMatch-selected"
-        });
-    const searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
-        constructor(view) {
-            this.view = view;
-            this.decorations = this.highlight(view.state.field(searchState));
-        }
-        update(update2) {
-            let state = update2.state.field(searchState);
-            if (state != update2.startState.field(searchState) || update2.docChanged || update2.selectionSet || update2.viewportChanged)
-                this.decorations = this.highlight(state);
-        }
-        highlight({
-            query,
-            panel
-        }) {
-            if (!panel || !query.spec.valid)
-                return Decoration.none;
-            let {
-                view
-            } = this;
-            let builder = new RangeSetBuilder();
-            for (let i2 = 0, ranges = view.visibleRanges, l2 = ranges.length; i2 < l2; i2++) {
-                let {
-                    from,
-                    to: to2
-                } = ranges[i2];
-                while (i2 < l2 - 1 && to2 > ranges[i2 + 1].from - 2 * 250)
-                    to2 = ranges[++i2].to;
-                query.highlight(view.state, from, to2, (from2, to3) => {
-                    let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to3);
-                    builder.add(from2, to3, selected ? selectedMatchMark : matchMark);
-                });
-            }
-            return builder.finish();
-        }
-    }, {
-        decorations: (v2) => v2.decorations
-    });
 
-    function searchCommand(f2) {
-        return (view) => {
-            let state = view.state.field(searchState, false);
-            return state && state.query.spec.valid ? f2(view, state) : openSearchPanel(view);
-        };
-    }
-    const findNext = /* @__PURE__ */ searchCommand((view, {
-        query
-    }) => {
-        let {
-            to: to2
-        } = view.state.selection.main;
-        let next2 = query.nextMatch(view.state, to2, to2);
-        if (!next2)
-            return false;
-        let selection2 = EditorSelection.single(next2.from, next2.to);
-        let config2 = view.state.facet(searchConfigFacet);
-        view.dispatch({
-            selection: selection2,
-            effects: [announceMatch(view, next2), config2.scrollToMatch(selection2.main, view)],
-            userEvent: "select.search"
-        });
-        selectSearchInput(view);
-        return true;
-    });
-    const findPrevious = /* @__PURE__ */ searchCommand((view, {
-        query
-    }) => {
-        let {
-            state
-        } = view, {
-            from
-        } = state.selection.main;
-        let prev = query.prevMatch(state, from, from);
-        if (!prev)
-            return false;
-        let selection2 = EditorSelection.single(prev.from, prev.to);
-        let config2 = view.state.facet(searchConfigFacet);
-        view.dispatch({
-            selection: selection2,
-            effects: [announceMatch(view, prev), config2.scrollToMatch(selection2.main, view)],
-            userEvent: "select.search"
-        });
-        selectSearchInput(view);
-        return true;
-    });
-    const selectMatches = /* @__PURE__ */ searchCommand((view, {
-        query
-    }) => {
-        let ranges = query.matchAll(view.state, 1e3);
-        if (!ranges || !ranges.length)
-            return false;
-        view.dispatch({
-            selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
-            userEvent: "select.search.matches"
-        });
-        return true;
-    });
-    const selectSelectionMatches = ({
-        state,
-        dispatch: dispatch2
-    }) => {
-        let sel = state.selection;
-        if (sel.ranges.length > 1 || sel.main.empty)
-            return false;
-        let {
-            from,
-            to: to2
-        } = sel.main;
-        let ranges = [],
-            main2 = 0;
-        for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to2)); !cur.next().done;) {
-            if (ranges.length > 1e3)
-                return false;
-            if (cur.value.from == from)
-                main2 = ranges.length;
-            ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
-        }
-        dispatch2(state.update({
-            selection: EditorSelection.create(ranges, main2),
-            userEvent: "select.search.matches"
-        }));
-        return true;
-    };
-    const replaceNext = /* @__PURE__ */ searchCommand((view, {
-        query
-    }) => {
-        let {
-            state
-        } = view, {
-            from,
-            to: to2
-        } = state.selection.main;
-        if (state.readOnly)
-            return false;
-        let next2 = query.nextMatch(state, from, from);
-        if (!next2)
-            return false;
-        let changes = [],
-            selection2, replacement;
-        let effects = [];
-        if (next2.from == from && next2.to == to2) {
-            replacement = state.toText(query.getReplacement(next2));
-            changes.push({
-                from: next2.from,
-                to: next2.to,
-                insert: replacement
-            });
-            next2 = query.nextMatch(state, next2.from, next2.to);
-            effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
-        }
-        if (next2) {
-            let off = changes.length == 0 || changes[0].from >= next2.to ? 0 : next2.to - next2.from - replacement.length;
-            selection2 = EditorSelection.single(next2.from - off, next2.to - off);
-            effects.push(announceMatch(view, next2));
-            effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
-        }
-        view.dispatch({
-            changes,
-            selection: selection2,
-            effects,
-            userEvent: "input.replace"
-        });
-        return true;
-    });
-    const replaceAll$1 = /* @__PURE__ */ searchCommand((view, {
-        query
-    }) => {
-        if (view.state.readOnly)
-            return false;
-        let changes = query.matchAll(view.state, 1e9).map((match2) => {
-            let {
-                from,
-                to: to2
-            } = match2;
-            return {
-                from,
-                to: to2,
-                insert: query.getReplacement(match2)
-            };
-        });
-        if (!changes.length)
-            return false;
-        let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
-        view.dispatch({
-            changes,
-            effects: EditorView.announce.of(announceText),
-            userEvent: "input.replace.all"
-        });
-        return true;
-    });
+    .react-datepicker {
+        margin-bottom: -1rem;
+        margin-left: -0.5rem;
 
-    function createSearchPanel(view) {
-        return view.state.facet(searchConfigFacet).createPanel(view);
-    }
+        background-color: ${(props) => props.theme.colors.grey1};
+        border: none;
+        box-shadow: none;
 
-    function defaultQuery(state, fallback) {
-        var _a3, _b, _c, _d, _e2;
-        let sel = state.selection.main;
-        let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
-        if (fallback && !selText)
-            return fallback;
-        let config2 = state.facet(searchConfigFacet);
-        return new SearchQuery({
-            search: ((_a3 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a3 !== void 0 ? _a3 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
-            caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
-            literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
-            regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
-            wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config2.wholeWord
-        });
-    }
+        /* stylelint-disable -- external classnames */
+        .react-datepicker__month-container {
+            .react-datepicker__header {
+                background-color: ${(props) => props.theme.colors.grey1};
+            }
 
-    function getSearchInput(view) {
-        let panel = getPanel(view, createSearchPanel);
-        return panel && panel.dom.querySelector("[main-field]");
+            .react-datepicker__month {
+                background-color: ${(props) => props.theme.colors.grey1};
+            }
+        }
     }
+`;
+    const StyledSelect = styled__default.default(Select)`
+    margin-bottom: 0.25rem;
+    border: 1px solid ${(props) => props.theme.colors.background};
 
-    function selectSearchInput(view) {
-        let input = getSearchInput(view);
-        if (input && input == view.root.activeElement)
-            input.select();
-    }
-    const openSearchPanel = (view) => {
-        let state = view.state.field(searchState, false);
-        if (state && state.panel) {
-            let searchInput = getSearchInput(view);
-            if (searchInput && searchInput != view.root.activeElement) {
-                let query = defaultQuery(view.state, state.query.spec);
-                if (query.valid)
-                    view.dispatch({
-                        effects: setSearchQuery.of(query)
-                    });
-                searchInput.focus();
-                searchInput.select();
-            }
-        } else {
-            view.dispatch({
-                effects: [
-                    togglePanel.of(true),
-                    state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
-                ]
-            });
+    button {
+        background-color: ${(props) => props.theme.colors.background};
+
+        :hover:enabled {
+            background-color: ${(props) => props.theme.colors.background};
         }
-        return true;
-    };
-    const closeSearchPanel = (view) => {
-        let state = view.state.field(searchState, false);
-        if (!state || !state.panel)
-            return false;
-        let panel = getPanel(view, createSearchPanel);
-        if (panel && panel.dom.contains(view.root.activeElement))
-            view.focus();
-        view.dispatch({
-            effects: togglePanel.of(false)
-        });
-        return true;
-    };
-    const searchKeymap = [{
-        key: "Mod-f",
-        run: openSearchPanel,
-        scope: "editor search-panel"
-    }, {
-        key: "F3",
-        run: findNext,
-        shift: findPrevious,
-        scope: "editor search-panel",
-        preventDefault: true
-    }, {
-        key: "Mod-g",
-        run: findNext,
-        shift: findPrevious,
-        scope: "editor search-panel",
-        preventDefault: true
+    }
+`;
+    const StyledApply = styled__default.default(ApplyButton)`
+    width: 4rem;
+    height: 2rem;
+    padding: 0;
+`;
+    const DatetimeFilterItems = [{
+        label: "None",
+        value: "None"
     }, {
-        key: "Escape",
-        run: closeSearchPanel,
-        scope: "editor search-panel"
+        label: "Before",
+        value: "Before"
     }, {
-        key: "Mod-Shift-l",
-        run: selectSelectionMatches
+        label: "After",
+        value: "After"
     }, {
-        key: "Mod-Alt-g",
-        run: gotoLine
+        label: "On date",
+        value: "On date"
     }, {
-        key: "Mod-d",
-        run: selectNextOccurrence,
-        preventDefault: true
+        label: "Between",
+        value: "Between"
     }];
-    class SearchPanel {
-        constructor(view) {
-            this.view = view;
-            let query = this.query = view.state.field(searchState).query.spec;
-            this.commit = this.commit.bind(this);
-            this.searchField = crelt("input", {
-                value: query.search,
-                placeholder: phrase(view, "Find"),
-                "aria-label": phrase(view, "Find"),
-                class: "cm-textfield",
-                name: "search",
-                form: "",
-                "main-field": "true",
-                onchange: this.commit,
-                onkeyup: this.commit
-            });
-            this.replaceField = crelt("input", {
-                value: query.replace,
-                placeholder: phrase(view, "Replace"),
-                "aria-label": phrase(view, "Replace"),
-                class: "cm-textfield",
-                name: "replace",
-                form: "",
-                onchange: this.commit,
-                onkeyup: this.commit
-            });
-            this.caseField = crelt("input", {
-                type: "checkbox",
-                name: "case",
-                form: "",
-                checked: query.caseSensitive,
-                onchange: this.commit
-            });
-            this.reField = crelt("input", {
-                type: "checkbox",
-                name: "re",
-                form: "",
-                checked: query.regexp,
-                onchange: this.commit
-            });
-            this.wordField = crelt("input", {
-                type: "checkbox",
-                name: "word",
-                form: "",
-                checked: query.wholeWord,
-                onchange: this.commit
-            });
 
-            function button(name2, onclick, content2) {
-                return crelt("button", {
-                    class: "cm-button",
-                    name: name2,
-                    onclick,
-                    type: "button"
-                }, content2);
+    function DatetimeFilter(props) {
+        const [selected, setSelected] = React.useState(null);
+        const [dateValues, setDateValues] = React.useState(props.values);
+        const filteredValues = React.useMemo(() => {
+            let filterDate = dateValues;
+            if ((selected === null || selected === void 0 ? void 0 : selected.value) !== "Between" && Array.isArray(dateValues)) {
+                [filterDate] = dateValues;
             }
-            this.dom = crelt("div", {
-                onkeydown: (e3) => this.keydown(e3),
-                class: "cm-search"
-            }, [
-                this.searchField,
-                button("next", () => findNext(view), [phrase(view, "next")]),
-                button("prev", () => findPrevious(view), [phrase(view, "previous")]),
-                button("select", () => selectMatches(view), [phrase(view, "all")]),
-                crelt("label", null, [this.caseField, phrase(view, "match case")]),
-                crelt("label", null, [this.reField, phrase(view, "regexp")]),
-                crelt("label", null, [this.wordField, phrase(view, "by word")]),
-                ...view.state.readOnly ? [] : [
-                    crelt("br"),
-                    this.replaceField,
-                    button("replace", () => replaceNext(view), [phrase(view, "replace")]),
-                    button("replaceAll", () => replaceAll$1(view), [phrase(view, "replace all")])
-                ],
-                crelt("button", {
-                    name: "close",
-                    onclick: () => closeSearchPanel(view),
-                    "aria-label": phrase(view, "close"),
-                    type: "button"
-                }, ["\xD7"])
-            ]);
-        }
-        commit() {
-            let query = new SearchQuery({
-                search: this.searchField.value,
-                caseSensitive: this.caseField.checked,
-                regexp: this.reField.checked,
-                wholeWord: this.wordField.checked,
-                replace: this.replaceField.value
-            });
-            if (!query.eq(this.query)) {
-                this.query = query;
-                this.view.dispatch({
-                    effects: setSearchQuery.of(query)
-                });
+            return {
+                selected: selected === null || selected === void 0 ? void 0 : selected.label,
+                value: filterDate
+            };
+        }, [dateValues, selected]);
+        const [previousFilter, setPreviousFilter] = React.useState(filteredValues);
+        const disableApply = React.useMemo(() => {
+            if (props.disabled || previousFilter === filteredValues) {
+                return true;
             }
-        }
-        keydown(e3) {
-            if (runScopeHandlers(this.view, e3, "search-panel")) {
-                e3.preventDefault();
-            } else if (e3.keyCode == 13 && e3.target == this.searchField) {
-                e3.preventDefault();
-                (e3.shiftKey ? findPrevious : findNext)(this.view);
-            } else if (e3.keyCode == 13 && e3.target == this.replaceField) {
-                e3.preventDefault();
-                replaceNext(this.view);
+            if (!dateValues || selected.label === "Between" && Array.isArray(dateValues) && (!dateValues[0] || !dateValues[1]) || selected.label === "Between" && !Array.isArray(dateValues)) {
+                return true;
             }
-        }
-        update(update2) {
-            for (let tr2 of update2.transactions)
-                for (let effect2 of tr2.effects) {
-                    if (effect2.is(setSearchQuery) && !effect2.value.eq(this.query))
-                        this.setQuery(effect2.value);
-                }
-        }
-        setQuery(query) {
-            this.query = query;
-            this.searchField.value = query.search;
-            this.replaceField.value = query.replace;
-            this.caseField.checked = query.caseSensitive;
-            this.reField.checked = query.regexp;
-            this.wordField.checked = query.wholeWord;
-        }
-        mount() {
-            this.searchField.select();
-        }
-        get pos() {
-            return 80;
-        }
-        get top() {
-            return this.view.state.facet(searchConfigFacet).top;
-        }
+            return false;
+        }, [props.disabled, previousFilter, filteredValues, dateValues, selected]);
+        return jsxRuntime.exports.jsxs(DatetimeFilterWrapper, {
+            className: props.className,
+            children: [jsxRuntime.exports.jsx(GlobalStyle, {}), jsxRuntime.exports.jsxs(FilterHeader, {
+                children: [jsxRuntime.exports.jsx(StyledSelect, {
+                    dropdownRef: (element2) => {
+                        if (props.portalsRef) {
+                            props.portalsRef.current[2] = element2;
+                        }
+                    },
+                    initialValue: {
+                        label: "None",
+                        value: "None"
+                    },
+                    items: DatetimeFilterItems,
+                    onSelect: setSelected
+                }), jsxRuntime.exports.jsx(DatepickerWrapper, {
+                    children: selected && selected.label !== "None" && jsxRuntime.exports.jsx(DatePicker, {
+                        inline: true,
+                        onChange: setDateValues,
+                        portalsRef: props.portalsRef,
+                        selectItemClass: "DatetimeFilterSelect",
+                        selectsRange: (selected === null || selected === void 0 ? void 0 : selected.value) === "Between",
+                        shouldCloseOnSelect: false,
+                        showTimeInput: props.showTimeInput
+                    })
+                })]
+            }), jsxRuntime.exports.jsx(StyledApply, {
+                disabled: disableApply,
+                onClick: (e3) => {
+                    var _a3, _b;
+                    (_a3 = props.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, filteredValues, e3);
+                    (_b = props === null || props === void 0 ? void 0 : props.column) === null || _b === void 0 ? void 0 : _b.setFilter(filteredValues || void 0);
+                    setPreviousFilter(filteredValues);
+                },
+                children: "Apply"
+            })]
+        });
     }
+    var Action;
+    (function(Action2) {
+        Action2["COPY"] = "copy";
+        Action2["DELETE"] = "delete";
+        Action2["SELECT"] = "select";
+        Action2["SELECT_ALL"] = "select_all";
+        Action2["SWITCH"] = "switch";
+        Action2["UNSELECT_ALL"] = "unselect_all";
+    })(Action || (Action = {}));
+    const SelectCheck = styled__default.default(CheckSquare)`
+    color: ${(props) => props.theme.colors.primary};
+`;
 
-    function phrase(view, phrase2) {
-        return view.state.phrase(phrase2);
+    function getSelectIcon(row) {
+        return row.selected ? SelectCheck : Square;
     }
-    const AnnounceMargin = 30;
-    const Break = /[\s\.,:;?!]/;
+    const SwitchOn = styled__default.default(ToggleOn)`
+    color: ${(props) => props.theme.colors.primary};
+`;
 
-    function announceMatch(view, {
-        from,
-        to: to2
-    }) {
-        let line = view.state.doc.lineAt(from),
-            lineEnd = view.state.doc.lineAt(to2).to;
-        let start2 = Math.max(line.from, from - AnnounceMargin),
-            end2 = Math.min(lineEnd, to2 + AnnounceMargin);
-        let text2 = view.state.sliceDoc(start2, end2);
-        if (start2 != line.from) {
-            for (let i2 = 0; i2 < AnnounceMargin; i2++)
-                if (!Break.test(text2[i2 + 1]) && Break.test(text2[i2])) {
-                    text2 = text2.slice(i2);
-                    break;
-                }
-        }
-        if (end2 != lineEnd) {
-            for (let i2 = text2.length - 1; i2 > text2.length - AnnounceMargin; i2--)
-                if (!Break.test(text2[i2 - 1]) && Break.test(text2[i2])) {
-                    text2 = text2.slice(0, i2);
-                    break;
-                }
-        }
-        return EditorView.announce.of(`${view.state.phrase("current match")}. ${text2} ${view.state.phrase("on line")} ${line.number}.`);
+    function getSwitchIcon(row) {
+        return row.active ? SwitchOn : ToggleOff;
     }
-    const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
-        ".cm-panel.cm-search": {
-            padding: "2px 6px 4px",
-            position: "relative",
-            "& [name=close]": {
-                position: "absolute",
-                top: "0",
-                right: "4px",
-                backgroundColor: "inherit",
-                border: "none",
-                font: "inherit",
-                padding: 0,
-                margin: 0
-            },
-            "& input, & button, & label": {
-                margin: ".2em .6em .2em 0"
-            },
-            "& input[type=checkbox]": {
-                marginRight: ".2em"
-            },
-            "& label": {
-                fontSize: "80%",
-                whiteSpace: "pre"
-            }
+    const Actions = {
+        COPY: {
+            icon: Copy,
+            id: Action.COPY,
+            label: "Copy"
         },
-        "&light .cm-searchMatch": {
-            backgroundColor: "#ffff0054"
+        DELETE: {
+            icon: Trash,
+            id: Action.DELETE,
+            label: "Delete"
         },
-        "&dark .cm-searchMatch": {
-            backgroundColor: "#00ffff8a"
+        SELECT: {
+            getIcon: getSelectIcon,
+            id: Action.SELECT,
+            label: "Select Row"
         },
-        "&light .cm-searchMatch-selected": {
-            backgroundColor: "#ff6a0054"
+        SELECT_ALL: {
+            id: Action.SELECT_ALL,
+            label: "Select All Rows"
         },
-        "&dark .cm-searchMatch-selected": {
-            backgroundColor: "#ff00ff8a"
+        SWITCH: {
+            getIcon: getSwitchIcon,
+            id: Action.SWITCH,
+            label: "Switch On/Off"
+        },
+        UNSELECT_ALL: {
+            id: Action.UNSELECT_ALL,
+            label: "Unselect All Rows"
         }
-    });
-    const searchExtensions = [
-        searchState,
-        /* @__PURE__ */
-        Prec.low(searchHighlighter),
-        baseTheme
-    ];
-    const EditorRoot = styled__default.default.div`
-    overflow-y: scroll;
+    };
+    const ActionWrapper = styled__default.default.div`
     display: flex;
-    flex: 1 1 auto;
-    flex-direction: column;
+    align-items: center;
+    justify-content: flex-end;
 
-    border: 1px solid ${(props) => props.theme.colors.grey3};
-    .cm-wrap {
-        flex: 1 1 auto;
-        color: ${(props) => props.theme.colors.text};
+    width: 100%;
+    padding: 0 1rem;
+
+    svg:not(:last-of-type) {
+        margin-right: 0.7rem;
     }
-    .cm-gutters {
-        color: ${(props) => props.theme.colors.grey4};
-        background-color: ${(props) => props.theme.colors.grey2};
-        border-right-color: ${(props) => props.theme.colors.grey3};
+`;
+
+    function ActionCell(props) {
+        if (!props.column.actions) {
+            throw new Error("Must pass an array of actions to the column def when using the ActionCell");
+        }
+        return jsxRuntime.exports.jsx(ActionWrapper, {
+            className: "table-action-cell",
+            children: props.column.actions.map((action) => {
+                const Icon2 = action.getIcon ? action.getIcon(props.row.original) : action.icon;
+                if (Icon2 === void 0) {
+                    return;
+                }
+                const label = action.getLabel ? action.getLabel(props.row.original) : action.label;
+                const onClick = (e3) => {
+                    var _a3;
+                    e3.stopPropagation();
+                    (_a3 = props.onAction) === null || _a3 === void 0 ? void 0 : _a3.call(props, action.id, props.row.original);
+                };
+                return jsxRuntime.exports.jsx(Icon2, {
+                    asButton: true,
+                    onClick,
+                    title: label
+                }, action.label);
+            })
+        });
+    }
+
+    function DatetimeCell(fmt = "yyyy-MM-dd HH:mm") {
+        return ({
+            value
+        }) => {
+            if (!value) {
+                return "";
+            }
+            const parsed = parseISO$1(value);
+            if (Number.isNaN(parsed.getTime())) {
+                return "";
+            }
+            return format$2(parsed, fmt);
+        };
     }
+    const InputWrapper = styled__default.default.div`
+    display: flex;
+    width: calc(100% + 22px);
+    margin: 0 -1rem;
+`;
+    const ValueWrapper$1 = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    height: 100%;
 `;
 
-    function CodeEditor$1({
-        initialScript,
-        disabled: disabled2,
-        onChange: onChange2,
-        style: style2,
-        className
-    }) {
-        const editorRef = React.useRef();
-        React.useEffect(() => {
-            if (editorRef.current) {
-                const dispatchChanges = StateField.define({
-                    create() {
-                        return true;
-                    },
-                    update(value, tr2) {
-                        if (onChange2) {
-                            onChange2(tr2.state.doc.toString());
-                        }
-                        return true;
+    function EditInputCell() {
+        return function InputCell(props) {
+            const [value, setValue] = React.useState(props.value);
+            React.useEffect(() => {
+                setValue(props.value);
+            }, [props.value]);
+            if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
+                const onComplete = () => {
+                    if (props.onChange && value !== props.value) {
+                        props.onChange(value, props.rowIdx, props.column.id);
                     }
+                    props.onStopEdit();
+                };
+                const onChange2 = (val) => {
+                    setValue(val);
+                };
+                return jsxRuntime.exports.jsx(InputWrapper, {
+                    children: jsxRuntime.exports.jsx(Input$1, {
+                        autoFocus: true,
+                        initialValue: props.value,
+                        onBlur: onComplete,
+                        onChange: onChange2,
+                        onComplete,
+                        style: {
+                            maxWidth: "100%"
+                        }
+                    })
                 });
-                const startState = EditorState.create({
-                    doc: initialScript !== null && initialScript !== void 0 ? initialScript : "",
-                    extensions: [
-                        lineNumbers(),
-                        dispatchChanges,
-                        history(),
-                        python(),
-                        json(),
-                        bracketMatching(),
-                        closeBrackets(),
-                        syntaxHighlighting(defaultHighlightStyle),
-                        EditorState.tabSize.of(4),
-                        EditorView.editable.of(!disabled2),
-                        keymap.of([...defaultKeymap, ...searchKeymap, ...historyKeymap, indentWithTab])
-                    ]
-                });
-                const view = new EditorView({
-                    parent: editorRef.current,
-                    state: startState
-                });
-                return () => view.destroy();
             }
-        }, []);
-        return jsxRuntime.exports.jsx(EditorRoot, {
-            className,
-            ref: editorRef,
-            style: style2
-        });
+            return jsxRuntime.exports.jsx(ValueWrapper$1, {
+                "data-cell": [props.rowIdx, props.column.id],
+                onClick: props.onStartEdit,
+                children: props.value
+            });
+        };
     }
-    const StyledCodeEditor = core$2.injectCss(CodeEditor$1);
+    const SelectWrapper = styled__default.default.div`
+    display: flex;
+    width: calc(100% + 22px);
+    margin: 0 -1rem;
+`;
+    const ValueWrapper = styled__default.default.span`
+    display: flex;
+    flex: 1 1 auto;
+    align-items: center;
+    height: 100%;
+`;
 
-    function CodeEditor(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [script, setScript] = core$2.useVariable(props.script);
-        return /* @__PURE__ */ React__default.default.createElement(StyledCodeEditor, {
-            $rawCss: css2,
-            initialScript: script,
-            onChange: setScript,
-            style: style2
-        });
+    function EditSelectCell(items) {
+        return function SelectCell(props) {
+            const selectedItem = items.find((item) => item.value === props.value);
+            if (isEqual_1(props.currentEditCell, [props.rowIdx, props.column.id])) {
+                const onSelect = (item) => {
+                    if (props.onChange && item.value !== props.value) {
+                        props.onChange(item.value, props.rowIdx, props.column.id);
+                    }
+                    props.onStopEdit();
+                };
+                return jsxRuntime.exports.jsx(SelectWrapper, {
+                    children: jsxRuntime.exports.jsx(Select, {
+                        initialIsOpen: true,
+                        initialValue: selectedItem,
+                        items,
+                        onSelect,
+                        style: {
+                            flex: "1 1 auto"
+                        }
+                    })
+                });
+            }
+            return jsxRuntime.exports.jsx(ValueWrapper, {
+                "data-cell": [props.rowIdx, props.column.id],
+                onClick: props.onStartEdit,
+                children: selectedItem ? selectedItem.label : ""
+            });
+        };
     }
-    const ChatWrapper = styled__default.default.div`
-    pointer-events: auto;
-
-    position: fixed;
-    z-index: 999;
-    right: 1rem;
-    bottom: -0.1rem;
+    const FilterIcon = styled__default.default(FontAwesomeIcon)`
+    cursor: pointer;
+    color: ${(props) => props.$hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
 `;
-    const ChatButton = styled__default.default.button`
-    width: 3.5rem;
-    height: 3.5rem;
-    margin: 0 2rem 2rem 0;
-    padding-top: 0.5rem;
+    const HeaderIconWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
 
-    color: ${(props) => props.theme.colors.background};
+    width: 1.5rem;
+    height: 1.5rem;
 
-    background-color: ${(props) => props.theme.colors.primary};
-    border: none;
-    border-radius: 3rem;
+    border-radius: 0.25rem;
 
     :hover {
-        background-color: ${(props) => props.theme.colors.primaryHover};
+        background-color: ${(props) => curriedTransparentize$2(0.9, props.theme.colors.primaryHover)};
+
+        svg {
+            color: ${(props) => props.hasFilter ? props.theme.colors.primary : props.theme.colors.grey3};
+        }
     }
 
     :active {
-        background-color: ${(props) => props.theme.colors.primaryDown};
+        background-color: ${(props) => curriedTransparentize$2(0.8, props.theme.colors.primaryDown)};
     }
 `;
-    const StyledChat = core$2.injectCss(Chat$1);
+    var NumericOperator;
+    (function(NumericOperator2) {
+        NumericOperator2["BT"] = "Between";
+        NumericOperator2["EQ"] = "Equal to";
+        NumericOperator2["GT"] = "Greater than";
+        NumericOperator2["LT"] = "Less than";
+        NumericOperator2["NE"] = "Not equal to";
+    })(NumericOperator || (NumericOperator = {}));
+    var DateOperator;
+    (function(DateOperator2) {
+        DateOperator2["BT"] = "Between";
+        DateOperator2["EQ"] = "On date";
+        DateOperator2["GT"] = "After";
+        DateOperator2["LT"] = "Before";
+    })(DateOperator || (DateOperator = {}));
 
-    function Chat(props) {
-        const [style2, css2] = core$2.useComponentStyles(props);
-        const [value, setValue] = core$2.useVariable(props.value);
-        const [showChat, setShowChat] = React__namespace.useState(false);
-        const theme2 = useClTheme();
-        return /* @__PURE__ */ React__namespace.createElement(ChatWrapper, null, showChat && /* @__PURE__ */ React__namespace.createElement(
-            StyledChat, {
-                $rawCss: css2,
-                className: props.className,
-                onClose: () => setShowChat(false),
-                onUpdate: setValue,
-                style: style2,
-                value
-            }
-        ), !showChat && /* @__PURE__ */ React__namespace.createElement(ChatButton, {
-            onClick: () => setShowChat(true)
-        }, /* @__PURE__ */ React__namespace.createElement("svg", {
-            fill: "none",
-            height: "32",
-            viewBox: "0 0 32 32",
-            width: "32",
-            xmlns: "http://www.w3.org/2000/svg"
-        }, /* @__PURE__ */ React__namespace.createElement("rect", {
-            fill: "none",
-            height: "24",
-            rx: "3",
-            width: "30",
-            x: "1",
-            y: "1.33594"
-        }), /* @__PURE__ */ React__namespace.createElement(
-            "rect", {
-                height: "24",
-                rx: "3",
-                stroke: theme2.colors.background,
-                strokeWidth: "2",
-                width: "30",
-                x: "1",
-                y: "1.33594"
-            }
-        ), /* @__PURE__ */ React__namespace.createElement(
-            "path", {
-                d: "M8 8.33594H24",
-                stroke: theme2.colors.background,
-                strokeLinecap: "round",
-                strokeWidth: "2"
-            }
-        ), /* @__PURE__ */ React__namespace.createElement(
-            "path", {
-                d: "M8 13.3359H24",
-                stroke: theme2.colors.background,
-                strokeLinecap: "round",
-                strokeWidth: "2"
-            }
-        ), /* @__PURE__ */ React__namespace.createElement(
-            "path", {
-                d: "M8 18.3359H24",
-                stroke: theme2.colors.background,
-                strokeLinecap: "round",
-                strokeWidth: "2"
-            }
-        ), /* @__PURE__ */ React__namespace.createElement(
-            "path", {
-                d: "M18.5981 26.1641L16 30.6641L13.4019 26.1641L18.5981 26.1641Z",
-                fill: theme2.colors.background,
-                stroke: theme2.colors.background
-            }
-        ), /* @__PURE__ */ React__namespace.createElement("path", {
-            d: "M16 28.3359L13.4019 23.8359L18.5981 23.8359L16 28.3359Z",
-            fill: "none"
-        }))));
+    function isValidOperator(op) {
+        return Object.keys(NumericOperator).map((key) => NumericOperator[key]).includes(op);
     }
 
-    function noop$2() {}
-    var noop_1 = noop$2;
-    /*! *****************************************************************************
-        Copyright (c) Microsoft Corporation.
-  
-        Permission to use, copy, modify, and/or distribute this software for any
-        purpose with or without fee is hereby granted.
-  
-        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
-        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
-        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
-        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
-        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
-        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
-        PERFORMANCE OF THIS SOFTWARE.
-        ***************************************************************************** */
-    var extendStatics = function(d2, b2) {
-        extendStatics = Object.setPrototypeOf || {
-            __proto__: []
-        }
-        instanceof Array && function(d3, b3) {
-            d3.__proto__ = b3;
-        } || function(d3, b3) {
-            for (var p2 in b3)
-                if (b3.hasOwnProperty(p2))
-                    d3[p2] = b3[p2];
-        };
-        return extendStatics(d2, b2);
-    };
-
-    function __extends(d2, b2) {
-        extendStatics(d2, b2);
+    function isValidDatetimeOperator(op) {
+        return Object.keys(DateOperator).map((key) => DateOperator[key]).includes(op);
+    }
 
-        function __() {
-            this.constructor = d2;
+    function applyNumericOperator(operator2, value, filterValue) {
+        switch (operator2) {
+            case NumericOperator.EQ:
+                return value === filterValue;
+            case NumericOperator.GT:
+                if (Array.isArray(filterValue)) {
+                    throw new Error("Cannot use array for GT operator");
+                }
+                return value > filterValue;
+            case NumericOperator.LT:
+                if (Array.isArray(filterValue)) {
+                    throw new Error("Cannot use array for LT operator");
+                }
+                return value < filterValue;
+            case NumericOperator.NE:
+                return value !== filterValue;
+            case NumericOperator.BT:
+                if (Array.isArray(filterValue)) {
+                    return value <= filterValue[1] && value >= filterValue[0];
+                }
+                break;
+            default:
+                return true;
         }
-        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
     }
 
-    function isFunction(x2) {
-        return typeof x2 === "function";
-    }
-    var _enable_super_gross_mode_that_will_cause_bad_things = false;
-    var config = {
-        Promise: void 0,
-        set useDeprecatedSynchronousErrorHandling(value) {
-            if (value) {
-                var error2 = /* @__PURE__ */ new Error();
-                /* @__PURE__ */
-                console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error2.stack);
+    function applyDatetimeOperator(operator2, value, filterValue) {
+        const parsedValue = parseISO$1(value);
+        if (Array.isArray(filterValue)) {
+            if (operator2 === DateOperator.BT) {
+                return isWithinInterval$1(parsedValue, {
+                    end: filterValue[1],
+                    start: filterValue[0]
+                });
             }
-            _enable_super_gross_mode_that_will_cause_bad_things = value;
-        },
-        get useDeprecatedSynchronousErrorHandling() {
-            return _enable_super_gross_mode_that_will_cause_bad_things;
+            return true;
+        }
+        switch (operator2) {
+            case DateOperator.EQ:
+                return isEqual$3(parsedValue, filterValue);
+            case DateOperator.GT:
+                return isAfter$1(parsedValue, filterValue);
+            case DateOperator.LT:
+                return isBefore$1(parsedValue, filterValue);
+            default:
+                return true;
         }
-    };
-
-    function hostReportError(err) {
-        setTimeout(function() {
-            throw err;
-        }, 0);
     }
-    var empty = {
-        closed: true,
-        next: function(value) {},
-        error: function(err) {
-            if (config.useDeprecatedSynchronousErrorHandling) {
-                throw err;
-            } else {
-                hostReportError(err);
-            }
-        },
-        complete: function() {}
-    };
-    var isArray$9 = /* @__PURE__ */ function() {
-        return Array.isArray || function(x2) {
-            return x2 && typeof x2.length === "number";
-        };
-    }();
 
-    function isObject$5(x2) {
-        return x2 !== null && typeof x2 === "object";
+    function numeric(rows, columnIds, filterValue) {
+        const {
+            selected,
+            value
+        } = filterValue;
+        const [colId] = columnIds;
+        if (!isValidOperator(selected) || !value && value !== 0) {
+            return rows;
+        }
+        return rows.filter((row) => applyNumericOperator(selected, row.values[colId], value));
     }
-    var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
-        function UnsubscriptionErrorImpl2(errors) {
-            Error.call(this);
-            this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
-                return i2 + 1 + ") " + err.toString();
-            }).join("\n  ") : "";
-            this.name = "UnsubscriptionError";
-            this.errors = errors;
-            return this;
+
+    function datetime(rows, columnIds, filterValue) {
+        const {
+            selected,
+            value
+        } = filterValue;
+        const [colId] = columnIds;
+        if (!isValidDatetimeOperator(selected) || !value) {
+            return rows;
         }
-        UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
-        return UnsubscriptionErrorImpl2;
-    }();
-    var UnsubscriptionError = UnsubscriptionErrorImpl;
-    var Subscription = /* @__PURE__ */ function() {
-        function Subscription2(unsubscribe) {
-            this.closed = false;
-            this._parentOrParents = null;
-            this._subscriptions = null;
-            if (unsubscribe) {
-                this._unsubscribe = unsubscribe;
-            }
+        return rows.filter((row) => applyDatetimeOperator(selected, row.values[colId], value));
+    }
+
+    function categorical(rows, columnIds, filterItems) {
+        const [colId] = columnIds;
+        const filteredItems = filterItems.map((item) => item.value);
+        if (filteredItems.length === 0) {
+            return rows;
         }
-        Subscription2.prototype.unsubscribe = function() {
-            var errors;
-            if (this.closed) {
-                return;
-            }
-            var _a3 = this,
-                _parentOrParents = _a3._parentOrParents,
-                _unsubscribe = _a3._unsubscribe,
-                _subscriptions = _a3._subscriptions;
-            this.closed = true;
-            this._parentOrParents = null;
-            this._subscriptions = null;
-            if (_parentOrParents instanceof Subscription2) {
-                _parentOrParents.remove(this);
-            } else if (_parentOrParents !== null) {
-                for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
-                    var parent_1 = _parentOrParents[index2];
-                    parent_1.remove(this);
-                }
-            }
-            if (isFunction(_unsubscribe)) {
-                try {
-                    _unsubscribe.call(this);
-                } catch (e3) {
-                    errors = e3 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e3.errors) : [e3];
-                }
-            }
-            if (isArray$9(_subscriptions)) {
-                var index2 = -1;
-                var len = _subscriptions.length;
-                while (++index2 < len) {
-                    var sub = _subscriptions[index2];
-                    if (isObject$5(sub)) {
-                        try {
-                            sub.unsubscribe();
-                        } catch (e3) {
-                            errors = errors || [];
-                            if (e3 instanceof UnsubscriptionError) {
-                                errors = errors.concat(flattenUnsubscriptionErrors(e3.errors));
-                            } else {
-                                errors.push(e3);
-                            }
-                        }
-                    }
-                }
-            }
-            if (errors) {
-                throw new UnsubscriptionError(errors);
-            }
-        };
-        Subscription2.prototype.add = function(teardown) {
-            var subscription = teardown;
-            if (!teardown) {
-                return Subscription2.EMPTY;
-            }
-            switch (typeof teardown) {
-                case "function":
-                    subscription = new Subscription2(teardown);
-                case "object":
-                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
-                        return subscription;
-                    } else if (this.closed) {
-                        subscription.unsubscribe();
-                        return subscription;
-                    } else if (!(subscription instanceof Subscription2)) {
-                        var tmp = subscription;
-                        subscription = new Subscription2();
-                        subscription._subscriptions = [tmp];
-                    }
-                    break;
-                default: {
-                    throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
-                }
-            }
-            var _parentOrParents = subscription._parentOrParents;
-            if (_parentOrParents === null) {
-                subscription._parentOrParents = this;
-            } else if (_parentOrParents instanceof Subscription2) {
-                if (_parentOrParents === this) {
-                    return subscription;
-                }
-                subscription._parentOrParents = [_parentOrParents, this];
-            } else if (_parentOrParents.indexOf(this) === -1) {
-                _parentOrParents.push(this);
-            } else {
-                return subscription;
-            }
-            var subscriptions = this._subscriptions;
-            if (subscriptions === null) {
-                this._subscriptions = [subscription];
-            } else {
-                subscriptions.push(subscription);
-            }
-            return subscription;
-        };
-        Subscription2.prototype.remove = function(subscription) {
-            var subscriptions = this._subscriptions;
-            if (subscriptions) {
-                var subscriptionIndex = subscriptions.indexOf(subscription);
-                if (subscriptionIndex !== -1) {
-                    subscriptions.splice(subscriptionIndex, 1);
-                }
-            }
-        };
-        Subscription2.EMPTY = function(empty2) {
-            empty2.closed = true;
-            return empty2;
-        }(new Subscription2());
-        return Subscription2;
-    }();
+        return rows.filter((row) => filteredItems.includes(row.values[colId]));
+    }
 
-    function flattenUnsubscriptionErrors(errors) {
-        return errors.reduce(function(errs, err) {
-            return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
-        }, []);
+    function TextFilter(props) {
+        return jsxRuntime.exports.jsx(FilterWrapper, {
+            children: jsxRuntime.exports.jsx(StyledSearchBar, {
+                onChange: (val) => props.column.setFilter(val || void 0),
+                placeholder: "Rows containing value...",
+                value: props.column.filterValue || ""
+            })
+        });
     }
-    var rxSubscriber = /* @__PURE__ */ function() {
-        return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
-    }();
-    var Subscriber = /* @__PURE__ */ function(_super) {
-        __extends(Subscriber2, _super);
 
-        function Subscriber2(destinationOrNext, error2, complete) {
-            var _this = _super.call(this) || this;
-            _this.syncErrorValue = null;
-            _this.syncErrorThrown = false;
-            _this.syncErrorThrowable = false;
-            _this.isStopped = false;
-            switch (arguments.length) {
-                case 0:
-                    _this.destination = empty;
-                    break;
-                case 1:
-                    if (!destinationOrNext) {
-                        _this.destination = empty;
-                        break;
-                    }
-                    if (typeof destinationOrNext === "object") {
-                        if (destinationOrNext instanceof Subscriber2) {
-                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
-                            _this.destination = destinationOrNext;
-                            destinationOrNext.add(_this);
-                        } else {
-                            _this.syncErrorThrowable = true;
-                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
-                        }
-                        break;
-                    }
-                default:
-                    _this.syncErrorThrowable = true;
-                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error2, complete);
-                    break;
-            }
-            return _this;
-        }
-        Subscriber2.prototype[rxSubscriber] = function() {
-            return this;
-        };
-        Subscriber2.create = function(next2, error2, complete) {
-            var subscriber = new Subscriber2(next2, error2, complete);
-            subscriber.syncErrorThrowable = false;
-            return subscriber;
-        };
-        Subscriber2.prototype.next = function(value) {
-            if (!this.isStopped) {
-                this._next(value);
-            }
-        };
-        Subscriber2.prototype.error = function(err) {
-            if (!this.isStopped) {
-                this.isStopped = true;
-                this._error(err);
-            }
-        };
-        Subscriber2.prototype.complete = function() {
-            if (!this.isStopped) {
-                this.isStopped = true;
-                this._complete();
-            }
-        };
-        Subscriber2.prototype.unsubscribe = function() {
-            if (this.closed) {
-                return;
+    function FilterContainer(props) {
+        var _a3;
+        const [visible, setVisible] = React.useState(false);
+        const show = () => setVisible(true);
+        const hide2 = () => setVisible(false);
+        const hasFilter = !(props.col.filterValue === void 0 || ((_a3 = props.col.filterValue) === null || _a3 === void 0 ? void 0 : _a3.selected) === "None" || Array.isArray(props.col.filterValue) && props.col.filterValue.length === 0);
+        const items = React.useMemo(() => {
+            var _a4;
+            if ((_a4 = props.col) === null || _a4 === void 0 ? void 0 : _a4.uniqueItems) {
+                return props.col.uniqueItems.map((item) => ({
+                    label: item,
+                    value: item
+                }));
             }
-            this.isStopped = true;
-            _super.prototype.unsubscribe.call(this);
-        };
-        Subscriber2.prototype._next = function(value) {
-            this.destination.next(value);
-        };
-        Subscriber2.prototype._error = function(err) {
-            this.destination.error(err);
-            this.unsubscribe();
-        };
-        Subscriber2.prototype._complete = function() {
-            this.destination.complete();
-            this.unsubscribe();
-        };
-        Subscriber2.prototype._unsubscribeAndRecycle = function() {
-            var _parentOrParents = this._parentOrParents;
-            this._parentOrParents = null;
-            this.unsubscribe();
-            this.closed = false;
-            this.isStopped = false;
-            this._parentOrParents = _parentOrParents;
-            return this;
-        };
-        return Subscriber2;
-    }(Subscription);
-    var SafeSubscriber = /* @__PURE__ */ function(_super) {
-        __extends(SafeSubscriber2, _super);
+        }, [props.col]);
+        const portalsRef = React.useRef([]);
 
-        function SafeSubscriber2(_parentSubscriber, observerOrNext, error2, complete) {
-            var _this = _super.call(this) || this;
-            _this._parentSubscriber = _parentSubscriber;
-            var next2;
-            var context2 = _this;
-            if (isFunction(observerOrNext)) {
-                next2 = observerOrNext;
-            } else if (observerOrNext) {
-                next2 = observerOrNext.next;
-                error2 = observerOrNext.error;
-                complete = observerOrNext.complete;
-                if (observerOrNext !== empty) {
-                    context2 = Object.create(observerOrNext);
-                    if (isFunction(context2.unsubscribe)) {
-                        _this.add(context2.unsubscribe.bind(context2));
-                    }
-                    context2.unsubscribe = _this.unsubscribe.bind(_this);
+        function onClickOutside(instance2, event2) {
+            const target = event2.target;
+            for (const portal of portalsRef.current) {
+                if (portal === null || portal === void 0 ? void 0 : portal.contains(target)) {
+                    return;
                 }
             }
-            _this._context = context2;
-            _this._next = next2;
-            _this._error = error2;
-            _this._complete = complete;
-            return _this;
+            hide2();
         }
-        SafeSubscriber2.prototype.next = function(value) {
-            if (!this.isStopped && this._next) {
-                var _parentSubscriber = this._parentSubscriber;
-                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
-                    this.__tryOrUnsub(this._next, value);
-                } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
-                    this.unsubscribe();
-                }
-            }
-        };
-        SafeSubscriber2.prototype.error = function(err) {
-            if (!this.isStopped) {
-                var _parentSubscriber = this._parentSubscriber;
-                var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
-                if (this._error) {
-                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
-                        this.__tryOrUnsub(this._error, err);
-                        this.unsubscribe();
-                    } else {
-                        this.__tryOrSetError(_parentSubscriber, this._error, err);
-                        this.unsubscribe();
-                    }
-                } else if (!_parentSubscriber.syncErrorThrowable) {
-                    this.unsubscribe();
-                    if (useDeprecatedSynchronousErrorHandling) {
-                        throw err;
-                    }
-                    hostReportError(err);
-                } else {
-                    if (useDeprecatedSynchronousErrorHandling) {
-                        _parentSubscriber.syncErrorValue = err;
-                        _parentSubscriber.syncErrorThrown = true;
-                    } else {
-                        hostReportError(err);
-                    }
-                    this.unsubscribe();
-                }
-            }
-        };
-        SafeSubscriber2.prototype.complete = function() {
-            var _this = this;
-            if (!this.isStopped) {
-                var _parentSubscriber = this._parentSubscriber;
-                if (this._complete) {
-                    var wrappedComplete = function() {
-                        return _this._complete.call(_this._context);
-                    };
-                    if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
-                        this.__tryOrUnsub(wrappedComplete);
-                        this.unsubscribe();
-                    } else {
-                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
-                        this.unsubscribe();
+        return jsxRuntime.exports.jsx(Tooltip, {
+            content: props.col.render("Filter", {
+                items,
+                onChange: hide2,
+                portalsRef
+            }),
+            hidden: true,
+            interactive: true,
+            onClickOutside,
+            visible,
+            children: jsxRuntime.exports.jsx("span", {
+                children: jsxRuntime.exports.jsx(HeaderIconWrapper, {
+                    hasFilter,
+                    children: jsxRuntime.exports.jsx(FilterIcon, {
+                        "$hasFilter": hasFilter,
+                        icon: faFilter,
+                        onClick: show
+                    })
+                })
+            })
+        });
+    }
+    var CheckboxState;
+    (function(CheckboxState2) {
+        CheckboxState2["CHECKED"] = "checked";
+        CheckboxState2["INDETERMINATE"] = "indeterminate";
+        CheckboxState2["UNCHECKED"] = "unchecked";
+    })(CheckboxState || (CheckboxState = {}));
+    const StyledTriStateCheckbox = styled__default.default.div`
+    ${(props) => {
+    if (props.state === CheckboxState.INDETERMINATE) {
+      return `
+                    span:after {
+                        display: block ;
+                        left: 0.07rem;
+                        top: 0.4rem;
+                        width: 0.75rem;
+                        border-radius: 0.25rem;
+                        height: 0px;
+                        border: 1px solid ${props.theme.colors.grey6};
+                        transform: rotate(0deg)
                     }
-                } else {
-                    this.unsubscribe();
-                }
-            }
-        };
-        SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
-            try {
-                fn2.call(this._context, value);
-            } catch (err) {
-                this.unsubscribe();
-                if (config.useDeprecatedSynchronousErrorHandling) {
-                    throw err;
-                } else {
-                    hostReportError(err);
-                }
-            }
-        };
-        SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
-            if (!config.useDeprecatedSynchronousErrorHandling) {
-                throw new Error("bad call");
-            }
-            try {
-                fn2.call(this._context, value);
-            } catch (err) {
-                if (config.useDeprecatedSynchronousErrorHandling) {
-                    parent.syncErrorValue = err;
-                    parent.syncErrorThrown = true;
-                    return true;
-                } else {
-                    hostReportError(err);
-                    return true;
-                }
-            }
-            return false;
-        };
-        SafeSubscriber2.prototype._unsubscribe = function() {
-            var _parentSubscriber = this._parentSubscriber;
-            this._context = null;
-            this._parentSubscriber = null;
-            _parentSubscriber.unsubscribe();
-        };
-        return SafeSubscriber2;
-    }(Subscriber);
 
-    function canReportError(observer) {
-        while (observer) {
-            var _a3 = observer,
-                closed_1 = _a3.closed,
-                destination = _a3.destination,
-                isStopped = _a3.isStopped;
-            if (closed_1 || isStopped) {
-                return false;
-            } else if (destination && destination instanceof Subscriber) {
-                observer = destination;
-            } else {
-                observer = null;
-            }
-        }
-        return true;
+            `;
     }
+  }}
+`;
 
-    function toSubscriber(nextOrObserver, error2, complete) {
-        if (nextOrObserver) {
-            if (nextOrObserver instanceof Subscriber) {
-                return nextOrObserver;
-            }
-            if (nextOrObserver[rxSubscriber]) {
-                return nextOrObserver[rxSubscriber]();
-            }
-        }
-        if (!nextOrObserver && !error2 && !complete) {
-            return new Subscriber(empty);
+    function computeState(allSelected, noneSelected) {
+        if (noneSelected) {
+            return CheckboxState.UNCHECKED;
         }
-        return new Subscriber(nextOrObserver, error2, complete);
-    }
-    var observable = /* @__PURE__ */ function() {
-        return typeof Symbol === "function" && Symbol.observable || "@@observable";
-    }();
-
-    function identity$1(x2) {
-        return x2;
+        return allSelected ? CheckboxState.CHECKED : CheckboxState.INDETERMINATE;
     }
 
-    function pipeFromArray(fns) {
-        if (fns.length === 0) {
-            return identity$1;
+    function getControlledState(allSelected, noneSelected) {
+        if (allSelected) {
+            return allSelected;
         }
-        if (fns.length === 1) {
-            return fns[0];
+        if (noneSelected) {
+            return false;
         }
-        return function piped(input) {
-            return fns.reduce(function(prev, fn2) {
-                return fn2(prev);
-            }, input);
-        };
+        return void 0;
     }
-    var Observable = /* @__PURE__ */ function() {
-        function Observable2(subscribe) {
-            this._isScalar = false;
-            if (subscribe) {
-                this._subscribe = subscribe;
-            }
-        }
-        Observable2.prototype.lift = function(operator2) {
-            var observable2 = new Observable2();
-            observable2.source = this;
-            observable2.operator = operator2;
-            return observable2;
-        };
-        Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
-            var operator2 = this.operator;
-            var sink = toSubscriber(observerOrNext, error2, complete);
-            if (operator2) {
-                sink.add(operator2.call(sink, this.source));
-            } else {
-                sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
-            }
-            if (config.useDeprecatedSynchronousErrorHandling) {
-                if (sink.syncErrorThrowable) {
-                    sink.syncErrorThrowable = false;
-                    if (sink.syncErrorThrown) {
-                        throw sink.syncErrorValue;
-                    }
-                }
-            }
-            return sink;
-        };
-        Observable2.prototype._trySubscribe = function(sink) {
-            try {
-                return this._subscribe(sink);
-            } catch (err) {
-                if (config.useDeprecatedSynchronousErrorHandling) {
-                    sink.syncErrorThrown = true;
-                    sink.syncErrorValue = err;
-                }
-                if (canReportError(sink)) {
-                    sink.error(err);
+
+    function TriStateCheckbox(props) {
+        const [state, setState] = React.useState(computeState(props.allSelected, props.noneSelected));
+        React.useEffect(() => {
+            setState(computeState(props.allSelected, props.noneSelected));
+        }, [props.allSelected, props.noneSelected]);
+        const onClick = (checked, e3) => {
+            setState(checked ? CheckboxState.CHECKED : CheckboxState.UNCHECKED);
+            if (props.onChange) {
+                if (state === CheckboxState.UNCHECKED) {
+                    props.onChange(CheckboxState.CHECKED, e3);
                 } else {
-                    console.warn(err);
+                    props.onChange(CheckboxState.UNCHECKED, e3);
                 }
             }
         };
-        Observable2.prototype.forEach = function(next2, promiseCtor) {
-            var _this = this;
-            promiseCtor = getPromiseCtor(promiseCtor);
-            return new promiseCtor(function(resolve2, reject) {
-                var subscription;
-                subscription = _this.subscribe(function(value) {
-                    try {
-                        next2(value);
-                    } catch (err) {
-                        reject(err);
-                        if (subscription) {
-                            subscription.unsubscribe();
-                        }
-                    }
-                }, reject, resolve2);
-            });
-        };
-        Observable2.prototype._subscribe = function(subscriber) {
-            var source = this.source;
-            return source && source.subscribe(subscriber);
-        };
-        Observable2.prototype[observable] = function() {
-            return this;
-        };
-        Observable2.prototype.pipe = function() {
-            var operations = [];
-            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
-                operations[_i2] = arguments[_i2];
-            }
-            if (operations.length === 0) {
-                return this;
-            }
-            return pipeFromArray(operations)(this);
-        };
-        Observable2.prototype.toPromise = function(promiseCtor) {
-            var _this = this;
-            promiseCtor = getPromiseCtor(promiseCtor);
-            return new promiseCtor(function(resolve2, reject) {
-                var value;
-                _this.subscribe(function(x2) {
-                    return value = x2;
-                }, function(err) {
-                    return reject(err);
-                }, function() {
-                    return resolve2(value);
-                });
-            });
-        };
-        Observable2.create = function(subscribe) {
-            return new Observable2(subscribe);
-        };
-        return Observable2;
-    }();
-
-    function getPromiseCtor(promiseCtor) {
-        if (!promiseCtor) {
-            promiseCtor = config.Promise || Promise;
-        }
-        if (!promiseCtor) {
-            throw new Error("no Promise impl found");
-        }
-        return promiseCtor;
+        return jsxRuntime.exports.jsx(StyledTriStateCheckbox, {
+            state,
+            style: props.style,
+            children: jsxRuntime.exports.jsx(Checkbox, {
+                className: props.className,
+                disabled: props.disabled,
+                initialValue: state === CheckboxState.CHECKED,
+                onChange: (checked, event2) => {
+                    onClick(checked, event2);
+                },
+                selected: getControlledState(props.allSelected, props.noneSelected)
+            })
+        });
     }
-    var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
-        function ObjectUnsubscribedErrorImpl2() {
-            Error.call(this);
-            this.message = "object unsubscribed";
-            this.name = "ObjectUnsubscribedError";
-            return this;
-        }
-        ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
-        return ObjectUnsubscribedErrorImpl2;
-    }();
-    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
-    var SubjectSubscription = /* @__PURE__ */ function(_super) {
-        __extends(SubjectSubscription2, _super);
 
-        function SubjectSubscription2(subject, subscriber) {
-            var _this = _super.call(this) || this;
-            _this.subject = subject;
-            _this.subscriber = subscriber;
-            _this.closed = false;
-            return _this;
-        }
-        SubjectSubscription2.prototype.unsubscribe = function() {
-            if (this.closed) {
-                return;
-            }
-            this.closed = true;
-            var subject = this.subject;
-            var observers2 = subject.observers;
-            this.subject = null;
-            if (!observers2 || observers2.length === 0 || subject.isStopped || subject.closed) {
-                return;
-            }
-            var subscriberIndex = observers2.indexOf(this.subscriber);
-            if (subscriberIndex !== -1) {
-                observers2.splice(subscriberIndex, 1);
+    function SelectHeader(props) {
+        const allValues = props.rows.map((r2) => r2.original.selected);
+        const countSelected = allValues.filter(Boolean).length;
+        const allSelected = countSelected > 0 && countSelected === allValues.length;
+        const noneSelected = countSelected === 0;
+        const onChange2 = (state) => {
+            if (state === CheckboxState.UNCHECKED) {
+                props.onAction(Action.UNSELECT_ALL);
+            } else if (state === CheckboxState.CHECKED) {
+                props.onAction(Action.SELECT_ALL, props.rows.map((r2) => r2.original));
             }
         };
-        return SubjectSubscription2;
-    }(Subscription);
-    var SubjectSubscriber = /* @__PURE__ */ function(_super) {
-        __extends(SubjectSubscriber2, _super);
+        return jsxRuntime.exports.jsx(TriStateCheckbox, {
+            allSelected,
+            noneSelected,
+            onChange: onChange2,
+            style: {
+                display: "flex",
+                justifyContent: "center"
+            }
+        });
+    }
+    const HeaderOptionsIcon = styled__default.default(FontAwesomeIcon)`
+    cursor: pointer;
+    align-items: center;
+    color: ${(props) => props.theme.colors.grey5};
+`;
+    const HeaderOptions = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: center;
 
-        function SubjectSubscriber2(destination) {
-            var _this = _super.call(this, destination) || this;
-            _this.destination = destination;
-            return _this;
-        }
-        return SubjectSubscriber2;
-    }(Subscriber);
-    var Subject = /* @__PURE__ */ function(_super) {
-        __extends(Subject2, _super);
+    width: 12px;
 
-        function Subject2() {
-            var _this = _super.call(this) || this;
-            _this.observers = [];
-            _this.closed = false;
-            _this.isStopped = false;
-            _this.hasError = false;
-            _this.thrownError = null;
-            return _this;
-        }
-        Subject2.prototype[rxSubscriber] = function() {
-            return new SubjectSubscriber(this);
-        };
-        Subject2.prototype.lift = function(operator2) {
-            var subject = new AnonymousSubject(this, this);
-            subject.operator = operator2;
-            return subject;
+    background-color: ${(props) => props.theme.colors.grey3};
+`;
+    const OptionsDropdownList = styled__default.default(List)`
+    background-color: ${(props) => props.theme.colors.background};
+    box-shadow: ${(props) => props.theme.shadow.light};
+`;
+    const OptionsMenu = ({
+        allColumns,
+        allowColumnHiding,
+        numVisibleColumns,
+        resetResizing,
+        setAllFilters,
+        style: style2
+    }) => {
+        const [optionsElement, setOptionsElement] = React.useState(null);
+        const [popperElement, setPopperElement] = React.useState(null);
+        const [showOptions, setShowOptions] = React.useState(false);
+        const {
+            styles: styles2,
+            attributes: attributes2,
+            update: update2
+        } = usePopper(optionsElement, popperElement, {
+            placement: "left-end"
+        });
+        const toggleOptions = () => {
+            setShowOptions(!showOptions);
         };
-        Subject2.prototype.next = function(value) {
-            if (this.closed) {
-                throw new ObjectUnsubscribedError();
-            }
-            if (!this.isStopped) {
-                var observers2 = this.observers;
-                var len = observers2.length;
-                var copy2 = observers2.slice();
-                for (var i2 = 0; i2 < len; i2++) {
-                    copy2[i2].next(value);
-                }
-            }
+        const onOptionSelect = (option) => {
+            option.onClick();
         };
-        Subject2.prototype.error = function(err) {
-            if (this.closed) {
-                throw new ObjectUnsubscribedError();
-            }
-            this.hasError = true;
-            this.thrownError = err;
-            this.isStopped = true;
-            var observers2 = this.observers;
-            var len = observers2.length;
-            var copy2 = observers2.slice();
-            for (var i2 = 0; i2 < len; i2++) {
-                copy2[i2].error(err);
+        const clickOutsideOptionsHandler = () => {
+            if (showOptions) {
+                toggleOptions();
             }
-            this.observers.length = 0;
         };
-        Subject2.prototype.complete = function() {
-            if (this.closed) {
-                throw new ObjectUnsubscribedError();
-            }
-            this.isStopped = true;
-            var observers2 = this.observers;
-            var len = observers2.length;
-            var copy2 = observers2.slice();
-            for (var i2 = 0; i2 < len; i2++) {
-                copy2[i2].complete();
+        useOnClickOutside(popperElement, clickOutsideOptionsHandler);
+        React.useEffect(() => {
+            if (showOptions) {
+                update2();
             }
-            this.observers.length = 0;
-        };
-        Subject2.prototype.unsubscribe = function() {
-            this.isStopped = true;
-            this.closed = true;
-            this.observers = null;
-        };
-        Subject2.prototype._trySubscribe = function(subscriber) {
-            if (this.closed) {
-                throw new ObjectUnsubscribedError();
-            } else {
-                return _super.prototype._trySubscribe.call(this, subscriber);
+        }, [showOptions, update2]);
+        const resetFunctions = React.useMemo(() => {
+            const functions2 = {
+                items: [{
+                    label: "Reset Column Widths",
+                    onClick: resetResizing,
+                    value: "resetResizing"
+                }, {
+                    label: "Reset Filters",
+                    onClick: () => setAllFilters([]),
+                    value: "resetFilters"
+                }],
+                label: "Reset"
+            };
+            if (allowColumnHiding) {
+                functions2.items.push({
+                    label: "Show All Columns",
+                    onClick: () => {
+                        allColumns.forEach((column) => {
+                            if (!column.isVisible) {
+                                column.toggleHidden();
+                            }
+                        });
+                    },
+                    value: "showAllColumns"
+                });
             }
-        };
-        Subject2.prototype._subscribe = function(subscriber) {
-            if (this.closed) {
-                throw new ObjectUnsubscribedError();
-            } else if (this.hasError) {
-                subscriber.error(this.thrownError);
-                return Subscription.EMPTY;
-            } else if (this.isStopped) {
-                subscriber.complete();
-                return Subscription.EMPTY;
-            } else {
-                this.observers.push(subscriber);
-                return new SubjectSubscription(this, subscriber);
+            return functions2;
+        }, [resetResizing, setAllFilters, allColumns, allowColumnHiding]);
+        const columnToggles = React.useMemo(() => {
+            return {
+                items: allColumns.filter((column) => typeof column.Header === "string").map((column) => ({
+                    label: `${column.isVisible ? "Hide" : "Show"} ${String(column.Header)}`,
+                    onClick: () => !(column.isVisible && numVisibleColumns === 1) ? column.toggleHidden() : null,
+                    value: `${column.isVisible ? "hide" : "show"}${String(column.Header)}`
+                })),
+                label: "Columns"
+            };
+        }, [allColumns, allowColumnHiding, numVisibleColumns]);
+        return jsxRuntime.exports.jsxs(HeaderOptions, {
+            ref: setOptionsElement,
+            children: [jsxRuntime.exports.jsx(HeaderOptionsIcon, {
+                icon: faEllipsisV,
+                onClick: toggleOptions
+            }), ReactDOM__default.default.createPortal(jsxRuntime.exports.jsx(OptionsDropdownList, Object.assign({}, attributes2.popper, {
+                isOpen: showOptions,
+                ref: setPopperElement,
+                style: Object.assign(Object.assign(Object.assign({}, styles2.popper), {
+                    maxHeight: 800,
+                    minWidth: 150,
+                    zIndex: 9999
+                }), style2),
+                children: jsxRuntime.exports.jsx(SectionedList, {
+                    items: allowColumnHiding ? [resetFunctions, columnToggles] : [resetFunctions],
+                    onSelect: onOptionSelect
+                })
+            })), document.body)]
+        });
+    };
+    var __rest$7 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
             }
-        };
-        Subject2.prototype.asObservable = function() {
-            var observable2 = new Observable();
-            observable2.source = this;
-            return observable2;
-        };
-        Subject2.create = function(destination, source) {
-            return new AnonymousSubject(destination, source);
-        };
-        return Subject2;
-    }(Observable);
-    var AnonymousSubject = /* @__PURE__ */ function(_super) {
-        __extends(AnonymousSubject2, _super);
+        return t2;
+    };
+    const {
+        fontSize
+    } = window.getComputedStyle(document.documentElement);
+    const ROW_HEIGHT = parseFloat(fontSize) * 2.5;
+    const shouldForwardProp = (prop) => !["isSorted", "onClickRow"].includes(prop);
+    const Row = styled__default.default.div.withConfig({
+        shouldForwardProp
+    })`
+    cursor: ${(props) => props.onClickRow ? "pointer" : "default"};
+    display: flex;
 
-        function AnonymousSubject2(destination, source) {
-            var _this = _super.call(this) || this;
-            _this.destination = destination;
-            _this.source = source;
-            return _this;
+    :hover {
+        div {
+            background-color: ${(props) => props.theme.colors.grey1};
         }
-        AnonymousSubject2.prototype.next = function(value) {
-            var destination = this.destination;
-            if (destination && destination.next) {
-                destination.next(value);
-            }
-        };
-        AnonymousSubject2.prototype.error = function(err) {
-            var destination = this.destination;
-            if (destination && destination.error) {
-                this.destination.error(err);
-            }
-        };
-        AnonymousSubject2.prototype.complete = function() {
-            var destination = this.destination;
-            if (destination && destination.complete) {
-                this.destination.complete();
-            }
-        };
-        AnonymousSubject2.prototype._subscribe = function(subscriber) {
-            var source = this.source;
-            if (source) {
-                return this.source.subscribe(subscriber);
-            } else {
-                return Subscription.EMPTY;
-            }
-        };
-        return AnonymousSubject2;
-    }(Subject);
-    const NotificationWrapper$1 = styled__default.default.div`
-    pointer-events: auto;
+    }
+
+    :active,
+    :focus {
+        div {
+            background-color: ${(props) => props.theme.colors.grey2};
+        }
+    }
+`;
+    const RowPlaceholder = styled__default.default(Row)`
+    position: absolute;
+    left: 0;
 
     display: flex;
     align-items: center;
-    justify-content: space-between;
+    justify-content: center;
+`;
+    const CellPlaceholder = styled__default.default.div`
+    min-width: 80px;
+    height: 0.7rem;
+    margin: 0.5rem;
 
-    width: 22rem;
-    height: ${(props) => props.hasTitle ? "5.625rem" : "4.375rem"};
-    padding: 1rem;
+    background: ${(props) => `linear-gradient(to right, ${props.theme.colors.grey2}, ${curriedTransparentize$2(0.2, props.theme.colors.grey3)}, ${props.theme.colors.grey2});`};
+    background-size: 50%;
+    border-radius: 0.5rem;
 
-    color: ${(props) => getStatusColor(props.status, props.theme.colors)};
+    animation-name: ani-horizontal;
+    animation-duration: 3.5s;
+    animation-timing-function: linear;
+    animation-iteration-count: infinite;
 
-    background-color: ${(props) => mix$1$1(0.1, getStatusColor(props.status, props.theme.colors), props.theme.colors.background)};
-    border: 1px solid ${(props) => getStatusColor(props.status, props.theme.colors)};
-    border-radius: 0.25rem;
-    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
+    @keyframes ani-horizontal {
+        0% {
+            background-position: -100% 0;
+        }
+
+        100% {
+            background-position: 100% 0;
+        }
+    }
 `;
-    const Message = styled__default.default.div`
-    display: flex;
-    flex-direction: column;
+    const Cell = styled__default.default.div`
+    display: flex !important;
+    align-items: center;
 
-    width: 15.75rem;
+    min-width: 80px;
+    height: ${() => `${ROW_HEIGHT}px`};
 
-    font-size: 1rem;
-    line-height: 1.1875rem;
-`;
-    const Heading = styled__default.default.h2`
-    overflow: hidden;
-    display: -webkit-box; /* stylelint-disable-line value-no-vendor-prefix */
+    color: ${(props) => props.theme.colors.grey6};
 
-    font-size: 1rem;
-    font-weight: 700;
-    text-overflow: ellipsis;
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-bottom: 1px solid ${(props) => props.theme.colors.grey3};
 
-    -webkit-box-orient: vertical;
-    -webkit-line-clamp: 1;
+    :last-child {
+        border-right: 0;
+    }
 `;
-    const Body = styled__default.default.span`
+    const CellContent = styled__default.default.span`
     overflow: hidden;
-    display: -webkit-box; /* stylelint-disable-line value-no-vendor-prefix */
 
-    font-weight: 400;
-    line-height: 1.25rem;
-    text-overflow: ellipsis;
+    width: 100%;
+    padding: 0 1rem;
 
-    -webkit-box-orient: vertical;
-    -webkit-line-clamp: ${(props) => props.moreDetailsShown ? 1 : 2};
+    text-overflow: ellipsis;
+    white-space: nowrap;
 `;
-    const Icon = styled__default.default.div`
-    display: flex;
+    const arePropsEqual = (prevProps, nextProps) => {
+        var _a3;
+        return areEqual(prevProps, nextProps) && !(((_a3 = nextProps.data) === null || _a3 === void 0 ? void 0 : _a3.headerGroups) || []).some((headerGroup) => ((headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers) || []).some((header) => header.isResizing));
+    };
+    const RenderRow = React__namespace.memo(({
+        data: {
+            width,
+            currentEditCell,
+            headerGroups,
+            rows,
+            prepareRow,
+            getItem,
+            totalColumnsWidth,
+            onClickRow,
+            throttledClickRow,
+            backgroundColor,
+            mappedColumns
+        },
+        index: index2,
+        style: renderRowStyle
+    }) => {
+        let row = rows[index2];
+        if (getItem) {
+            const value = getItem(index2);
+            if (!value) {
+                row = null;
+            } else {
+                row.original = value;
+                row.values = value;
+            }
+        }
+        if (!row) {
+            return jsxRuntime.exports.jsx("div", {
+                children: headerGroups.map((headerGroup, gidx) => jsxRuntime.exports.jsx(RowPlaceholder, {
+                    style: {
+                        height: ROW_HEIGHT,
+                        top: (index2 + 1) * ROW_HEIGHT,
+                        width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
+                    },
+                    children: headerGroup === null || headerGroup === void 0 ? void 0 : headerGroup.headers.map((col, cidx) => {
+                        const headerProps = col.getHeaderProps();
+                        const headerWidth = headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width;
+                        return jsxRuntime.exports.jsx(CellPlaceholder, {
+                            style: {
+                                maxWidth: col.maxWidth,
+                                width: headerWidth
+                            }
+                        }, `col-${index2}-${cidx}`);
+                    })
+                }, `row-${gidx}`))
+            });
+        }
+        prepareRow(row);
+        const onClick = () => {
+            if (onClickRow) {
+                throttledClickRow(row.original);
+            }
+        };
+        const _a3 = row.getRowProps({
+                style: renderRowStyle
+            }),
+            {
+                style: rowStyle
+            } = _a3,
+            restRow = __rest$7(_a3, ["style"]);
+        return React.createElement(Row, Object.assign({}, restRow, {
+            key: `row-${index2}`,
+            onClick,
+            onClickRow,
+            style: Object.assign(Object.assign({}, rowStyle), {
+                top: (index2 + 1) * ROW_HEIGHT,
+                width: totalColumnsWidth > width ? totalColumnsWidth : "100%"
+            })
+        }), row.cells.map((cell, colIdx) => {
+            var _a4;
+            const cellProps = cell.getCellProps();
+            return React.createElement(
+                Cell,
+                Object.assign({}, cellProps, {
+                    key: `cell-${index2}-${colIdx}`,
+                    style: Object.assign(Object.assign({}, cellProps.style), {
+                        backgroundColor,
+                        justifyContent: mappedColumns[colIdx].align,
+                        maxWidth: (_a4 = cell.column) === null || _a4 === void 0 ? void 0 : _a4.maxWidth,
+                        width: cellProps.style.width === "NaNpx" ? mappedColumns[colIdx].width : cellProps.style.width
+                    })
+                }),
+                jsxRuntime.exports.jsx(CellContent, {
+                    children: cell.render("Cell", {
+                        colIdx,
+                        currentEditCell,
+                        rowIdx: index2
+                    })
+                })
+            );
+        }));
+    }, arePropsEqual);
+    var __rest$6 = globalThis && globalThis.__rest || function(s2, e3) {
+        var t2 = {};
+        for (var p2 in s2)
+            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
+                t2[p2] = s2[p2];
+        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
+            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
+                if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
+                    t2[p2[i2]] = s2[p2[i2]];
+            }
+        return t2;
+    };
+    const Wrapper$2 = styled__default.default.div`
+    display: inline-block;
+    width: 100%;
+    max-width: 100%;
+    padding: 1rem;
 
-    svg {
-        width: 1.5rem;
-        height: 1.3125rem;
-        color: ${(props) => getStatusColor(props.status, props.theme.colors)};
+    ${(props) => !props.$hasMaxRows && `flex: 1 1 auto;`}
+    &.sticky {
+        [data-sticky-td] {
+            position: sticky;
+        }
+
+        [data-sticky-last-left-td] {
+            box-shadow: 4px 0 4px -3px ${(props) => props.theme.colors.shadowMedium};
+        }
+
+        [data-sticky-first-right-td] {
+            box-shadow: -4px 0 4px -3px ${(props) => props.theme.colors.shadowMedium};
+        }
     }
 `;
-    const MoreDetailsButton = styled__default.default.button`
-    cursor: pointer;
+    const StyledFixedSizeList = styled__default.default(FixedSizeList)`
+    /* this adds a fixed box shadow underneath the header */
+    ::before {
+        content: '';
 
-    display: flex;
+        position: sticky;
+        z-index: 5;
+        inset: calc(2.5rem - 2px) 0 0 0;
 
-    padding-left: 0;
+        display: block;
 
-    color: ${() => theme$3.colors.grey4};
+        height: 1px;
 
-    background: transparent;
-    border: none;
-    :hover {
-        text-decoration: underline;
+        box-shadow: 0 3px 3px ${(props) => props.theme.colors.shadowLight};
     }
 `;
-    const CloseBtn = styled__default.default(Cross$1)`
-    height: 1.2rem;
-    color: ${(props) => getStatusColor(props.status, props.theme.colors)};
+    const Header = styled__default.default.div`
+    position: sticky;
+    z-index: 4;
+    top: 0;
+
+    flex-direction: column;
+
+    width: fit-content;
+    min-width: 80px;
+
+    /* needed as before box shadow pushes this dows by 1px */
+    margin-top: -1px;
+`;
+    const HeaderRow = styled__default.default.div`
+    display: flex;
 `;
+    const HeaderCell = styled__default.default.div`
+    user-select: none;
 
-    function getIcon(status2) {
-        if ([Status.ERROR, Status.FAILED].includes(status2)) {
-            return jsxRuntime.exports.jsx(CircleXmark, {});
-        }
-        if ([Status.CANCELED, Status.WARNING].includes(status2)) {
-            return jsxRuntime.exports.jsx(TriangleExclamation, {});
-        }
-        return status2 === Status.SUCCESS ? jsxRuntime.exports.jsx(CircleCheck, {}) : jsxRuntime.exports.jsx(CircleInfo, {});
+    display: flex !important;
+    align-items: center;
+    justify-content: space-between;
+
+    min-width: 80px;
+    height: ${ROW_HEIGHT}px;
+
+    color: ${(props) => props.theme.colors.text};
+
+    background-color: ${(props) => props.theme.colors.blue3};
+
+    :not(:last-child) {
+        border-right: 1px solid ${(props) => props.theme.colors.background};
     }
 
-    function Notification(props) {
-        const isOverflowing = props.notification.message.length > 30;
-        const showMoreDetails = props.onMoreDetailsClick && isOverflowing;
-        return jsxRuntime.exports.jsxs(NotificationWrapper$1, {
-            hasTitle: !!props.notification.title,
-            status: props.notification.status,
-            children: [jsxRuntime.exports.jsx(Icon, {
-                status: props.notification.status,
-                children: getIcon(props.notification.status)
-            }), jsxRuntime.exports.jsxs(Message, {
-                children: [jsxRuntime.exports.jsx(Heading, {
-                    children: props.notification.title
-                }), jsxRuntime.exports.jsx(Body, {
-                    moreDetailsShown: showMoreDetails,
-                    children: props.notification.message
-                }), showMoreDetails && jsxRuntime.exports.jsx(MoreDetailsButton, {
-                    onClick: (e3) => props.onMoreDetailsClick(e3, props.notification),
-                    type: "button",
-                    children: "Details >"
-                })]
-            }), jsxRuntime.exports.jsx(CloseBtn, {
-                asButton: true,
-                onClick: () => props.onDismiss(props.notification.key),
-                status: props.notification.status
-            })]
-        });
+    :hover {
+        /* stylelint-disable-next-line -- hard-coded classname */
+        .tableSortArrow {
+            color: ${(props) => props.theme.colors.grey3};
+        }
     }
-    styled__default.default.div`
-    pointer-events: none;
+`;
+    const HeaderContentWrapper = styled__default.default.span`
+    overflow: hidden;
+    flex: 1 1 auto;
 
-    position: fixed;
-    z-index: 6000;
-    right: 1rem;
+    padding-left: ${(props) => props.isPrimitiveHeader ? "1rem" : void 0};
 
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
+    const HeaderTooltipContainer = styled__default.default.div`
     display: flex;
-    flex-direction: column;
-    gap: 1rem;
+    gap: 0.5rem;
     align-items: center;
-    justify-content: flex-end;
+    justify-content: center;
 
-    width: 324px;
+    width: ${(props) => props.isPrimitiveHeader ? void 0 : "100%"};
+    max-width: ${(props) => props.isPrimitiveHeader ? "calc(100% - 3rem)" : void 0};
+`;
+    const HeaderCellButtonContainer = styled__default.default.div`
+    display: flex;
+    flex-direction: row;
     height: 100%;
-    padding: 0.75rem 0;
 `;
-    const baseNotifications$ = new Subject();
-    React__namespace.createContext({
-        notifications$: baseNotifications$,
-        onMoreDetailsClick: null,
-        push: (notification) => baseNotifications$.next(notification)
-    });
-    var WeakMap$1 = _WeakMap;
-    WeakMap$1 && new WeakMap$1();
-    var isObject$4 = isObject_1;
-    var objectCreate = Object.create;
-    var baseCreate$3 = function() {
-        function object2() {}
-        return function(proto2) {
-            if (!isObject$4(proto2)) {
-                return {};
+    const HeaderIconsWrapper = styled__default.default.div`
+    display: flex;
+    align-items: center;
+    justify-content: space-between;
+    justify-self: flex-end;
+`;
+    const ResizeBorder = styled__default.default.div`
+    /* prevents from scrolling while dragging on touch devices */
+    touch-action: none;
+    width: 10px;
+    height: 100%;
+`;
+    const SortIcon = styled__default.default(FontAwesomeIcon).withConfig({
+        shouldForwardProp
+    })`
+    color: ${(props) => props.isSorted ? props.theme.colors.grey3 : props.theme.colors.blue3};
+`;
+    const TooltipIcon = styled__default.default(FontAwesomeIcon)`
+    color: ${(props) => props.theme.colors.grey4};
+`;
+    const getSortIcon = (isSorted, isSortedDesc) => {
+        if (!isSorted) {
+            return faArrowUp;
+        }
+        return isSortedDesc ? faArrowDown : faArrowUp;
+    };
+    const getSortKey = (sortBy, columns) => {
+        return sortBy.map((sort) => {
+            var _a3;
+            return Object.assign(Object.assign({}, sort), {
+                id: ((_a3 = columns.find((col) => col.accessor === sort.id)) === null || _a3 === void 0 ? void 0 : _a3.sortKey) || sort.id
+            });
+        });
+    };
+    const orderStickyCols = (columns) => {
+        const leftStickyCols = [];
+        const nonStickyCols = [];
+        const rightStickyCols = [];
+        columns.forEach((col) => {
+            if (col.sticky === "left") {
+                leftStickyCols.push(col);
+            } else if (col.sticky === "right") {
+                rightStickyCols.push(col);
+            } else {
+                nonStickyCols.push(col);
             }
-            if (objectCreate) {
-                return objectCreate(proto2);
+        });
+        return [...leftStickyCols, ...nonStickyCols, ...rightStickyCols];
+    };
+    const filterComponentMap = {
+        categorical: CategoricalFilter,
+        datetime: DatetimeFilter,
+        numeric: NumericFilter,
+        text: TextFilter
+    };
+    const appendFilterComponents = (columns) => {
+        return columns.map((col) => {
+            if (!col.filter) {
+                return col;
             }
-            object2.prototype = proto2;
-            var result = new object2();
-            object2.prototype = void 0;
-            return result;
+            if (!(col.filter in filterComponentMap)) {
+                throw new Error(`Invalid filter ${col.filter} encountered in column ${col.id}, only ${Object.keys(filterComponentMap).join(",")} are supported`);
+            }
+            return Object.assign(Object.assign({}, col), {
+                Filter: filterComponentMap[col.filter]
+            });
+        });
+    };
+    const cells = {
+        DATETIME: DatetimeCell,
+        EDIT_INPUT: EditInputCell,
+        EDIT_SELECT: EditSelectCell
+    };
+    const createItemData = memoizeOne$1((width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns) => ({
+        backgroundColor,
+        currentEditCell,
+        getItem,
+        headerGroups,
+        mappedColumns,
+        onClickRow,
+        prepareRow,
+        rows,
+        throttledClickRow,
+        totalColumnsWidth,
+        width
+    }));
+    const Table = React.forwardRef(({
+        allowHiding,
+        backgroundColor,
+        className,
+        columns,
+        data: data2,
+        getItem,
+        initialSort = [],
+        itemCount,
+        maxRows,
+        onAction,
+        onChange: onChange2,
+        onClickRow,
+        onItemsRendered,
+        onFilter,
+        onSort,
+        showTableOptions,
+        style: style2,
+        tableOptionsStyle
+    }, ref2) => {
+        const [currentSortBy, setCurrentSortBy] = React.useState(initialSort);
+        React.useEffect(
+            () => {
+                setCurrentSortBy(initialSort);
+            },
+            useDeepCompare([initialSort])
+        );
+        if (!data2 && !getItem) {
+            throw new Error("One of data and getItem must be passed to the table component");
+        }
+        if (getItem && (!onItemsRendered || !Number.isFinite(itemCount))) {
+            throw new Error("itemCount and onItemsRendered must also be passed when using the table in infinite mode");
+        }
+        const [currentEditCell, throttledSetEditCell, immediateSetEditCell] = useThrottledState(void 0, 500);
+        const throttledClickRow = useThrottle(onClickRow, 500);
+        const onStopEdit = () => {
+            throttledSetEditCell(void 0);
         };
-    }();
-    var _baseCreate = baseCreate$3;
+        const onStartEdit = (e3) => {
+            var _a3, _b;
+            const cell = (_b = (_a3 = e3 === null || e3 === void 0 ? void 0 : e3.currentTarget) === null || _a3 === void 0 ? void 0 : _a3.getAttribute("data-cell")) === null || _b === void 0 ? void 0 : _b.split(",");
+            if (!cell || (cell === null || cell === void 0 ? void 0 : cell.length) !== 2) {
+                throttledSetEditCell(void 0);
+                return;
+            }
+            immediateSetEditCell([Number(cell[0]), cell[1]]);
+            throttledSetEditCell([Number(cell[0]), cell[1]]);
+        };
+        const infiniteData = React.useMemo(() => Array(itemCount).fill(0), [itemCount]);
+        const mappedColumns = React.useMemo(() => appendFilterComponents(orderStickyCols(columns)), [columns]);
+        const hasFixedColumns = React.useMemo(() => mappedColumns.some((column) => "sticky" in column), [mappedColumns]);
+        const totalColumnsWidth = React.useMemo(() => mappedColumns.reduce((acc, column) => acc + (parseInt(column.width) || 150), 0), [mappedColumns]);
+        const filterTypes = React.useMemo(() => ({
+            categorical,
+            datetime,
+            numeric
+        }), []);
+        const {
+            getTableProps,
+            getTableBodyProps,
+            headerGroups,
+            rows,
+            prepareRow,
+            state: {
+                sortBy,
+                filters: filters2
+            },
+            setAllFilters,
+            resetResizing,
+            allColumns
+        } = reactTable.exports.useTable({
+            columns: mappedColumns,
+            data: data2 || infiniteData,
+            filterTypes,
+            initialState: {
+                sortBy: currentSortBy.map((sort) => Object.assign(Object.assign({}, sort), {
+                    id: mappedColumns.find((col) => [col.sortKey, col.accessor].includes(sort.id)).accessor
+                }))
+            },
+            manualFilters: !data2,
+            manualSortBy: !!onSort,
+            onAction,
+            onChange: onChange2,
+            onStartEdit,
+            onStopEdit
+        }, reactTable.exports.useFilters, reactTable.exports.useFlexLayout, reactTable.exports.useSortBy, reactTable.exports.useResizeColumns, ...hasFixedColumns ? [build.useSticky] : []);
+        React.useImperativeHandle(ref2, () => ({
+            resetFilters() {
+                setAllFilters([]);
+            }
+        }));
+        React.useEffect(() => {
+            if (onSort) {
+                onSort(getSortKey(sortBy, mappedColumns));
+            } else {
+                setCurrentSortBy(sortBy);
+            }
+        }, [onSort, sortBy]);
+        React.useEffect(() => {
+            if (onFilter) {
+                onFilter(filters2);
+            }
+        }, [onFilter, filters2]);
+        const tableProps = getTableBodyProps();
+        const renderTable = React.useCallback(
+            (_a3) => {
+                var {
+                    children: children2,
+                    style: tableStyle
+                } = _a3, rest = __rest$6(_a3, ["children", "style"]);
+                return jsxRuntime.exports.jsxs("div", {
+                    children: [jsxRuntime.exports.jsx(Header, {
+                        style: {
+                            width: `max(${totalColumnsWidth}px, 100%)`
+                        },
+                        children: headerGroups.map((headerGroup, gidx) => React.createElement(HeaderRow, Object.assign({}, headerGroup.getHeaderGroupProps(), {
+                            key: `group-${gidx}`
+                        }), headerGroup.headers.map((col, cidx) => {
+                            const headerProps = col.getHeaderProps();
+                            const sortProps = col.getSortByToggleProps();
+                            const headerContent = col.render("Header");
+                            const resizerProps = col.getResizerProps();
+                            const numVisibleColumns = allColumns.filter((column) => column.isVisible).length;
+                            const showSort = !col.disableSortBy;
+                            const showFilter = col.canFilter && col.filter;
+                            const showOptions = cidx === numVisibleColumns - 1 && showTableOptions;
+                            const showHeaderCellButtonContainer = showSort || showFilter || showOptions;
+                            return React.createElement(
+                                HeaderCell,
+                                Object.assign({}, headerProps, {
+                                    key: `col-${gidx}-${cidx}`,
+                                    style: Object.assign(Object.assign({}, headerProps.style), {
+                                        maxWidth: col.maxWidth,
+                                        width: headerProps.style.width === "NaNpx" ? mappedColumns[cidx].width : headerProps.style.width
+                                    })
+                                }),
+                                jsxRuntime.exports.jsxs(HeaderTooltipContainer, {
+                                    isPrimitiveHeader: typeof headerContent === "string",
+                                    children: [jsxRuntime.exports.jsx(HeaderContentWrapper, Object.assign({}, sortProps, {
+                                        isPrimitiveHeader: typeof headerContent === "string",
+                                        title: typeof headerContent === "string" ? headerContent : "",
+                                        children: headerContent
+                                    })), col.tooltip && jsxRuntime.exports.jsx(Tooltip, {
+                                        content: col.tooltip,
+                                        children: jsxRuntime.exports.jsx(TooltipIcon, {
+                                            icon: faCircleQuestion
+                                        })
+                                    })]
+                                }),
+                                showHeaderCellButtonContainer && jsxRuntime.exports.jsxs(HeaderCellButtonContainer, {
+                                    children: [jsxRuntime.exports.jsxs(HeaderIconsWrapper, {
+                                        children: [showSort && jsxRuntime.exports.jsx(HeaderIconWrapper, {
+                                            children: jsxRuntime.exports.jsx(SortIcon, Object.assign({}, sortProps, {
+                                                className: "tableSortArrow",
+                                                icon: getSortIcon(col.isSorted, col.isSortedDesc),
+                                                isSorted: col.isSorted
+                                            }))
+                                        }), showFilter ? jsxRuntime.exports.jsx(FilterContainer, {
+                                            col
+                                        }) : null, showOptions && jsxRuntime.exports.jsx(OptionsMenu, {
+                                            allColumns,
+                                            allowColumnHiding: allowHiding,
+                                            numVisibleColumns,
+                                            resetResizing,
+                                            setAllFilters,
+                                            style: tableOptionsStyle
+                                        })]
+                                    }), jsxRuntime.exports.jsx(ResizeBorder, Object.assign({}, resizerProps))]
+                                })
+                            );
+                        })))
+                    }), React.createElement("div", Object.assign({}, tableProps, rest, {
+                        key: "table-body-inner",
+                        style: tableStyle
+                    }), children2)]
+                }, "table-inner");
+            },
+            useDeepCompare([tableProps, totalColumnsWidth, headerGroups])
+        );
+        return jsxRuntime.exports.jsx(Wrapper$2, Object.assign({}, getTableProps(), {
+            "$hasMaxRows": !!maxRows,
+            className: `${className} ${hasFixedColumns ? "sticky" : ""}`,
+            style: Object.assign({
+                height: maxRows ? (Math.min(rows.length, maxRows) + 1) * ROW_HEIGHT : "100%"
+            }, style2),
+            children: jsxRuntime.exports.jsx(AutoSizer, {
+                children: ({
+                    height,
+                    width
+                }) => {
+                    return jsxRuntime.exports.jsx(StyledFixedSizeList, {
+                        height,
+                        innerElementType: renderTable,
+                        itemCount: itemCount || rows.length,
+                        itemData: createItemData(width, currentEditCell, headerGroups, rows, prepareRow, getItem, totalColumnsWidth, onClickRow, throttledClickRow, backgroundColor, mappedColumns),
+                        itemSize: ROW_HEIGHT,
+                        onItemsRendered,
+                        style: {
+                            overflowX: width < totalColumnsWidth ? "auto" : "hidden",
+                            overflowY: height < (rows.length + 1) * ROW_HEIGHT ? "auto" : "hidden"
+                        },
+                        width,
+                        children: RenderRow
+                    }, "table-list");
+                }
+            })
+        }));
+    });
+    Table.displayName = "Table";
+    Table.ActionColumn = (actions, accessor, sticky, disableSelectAll = false) => {
+        const width = actions.includes(Actions.SELECT) ? 52 : actions.length * 24 + 24;
+        return {
+            Cell: ActionCell,
+            Header: actions.includes(Actions.SELECT) && !disableSelectAll ? SelectHeader : "",
+            accessor: accessor || "actions",
+            actions,
+            disableSortBy: true,
+            maxWidth: width,
+            minWidth: actions.includes(Actions.SELECT) ? 52 : 48,
+            sticky: sticky || null,
+            width
+        };
+    };
+    Table.Actions = Actions;
+    Table.cells = cells;
+    styled__default.default.div`
+    overflow: hidden;
+    display: flex;
 
-    function baseLodash$3() {}
-    var _baseLodash = baseLodash$3;
-    var baseCreate$2 = _baseCreate,
-        baseLodash$2 = _baseLodash;
-    var MAX_ARRAY_LENGTH = 4294967295;
+    /* This is needed as the content of a TabbedCard overflows for the wrapper to not shrink */
+    flex-shrink: 0;
 
-    function LazyWrapper$2(value) {
-        this.__wrapped__ = value;
-        this.__actions__ = [];
-        this.__dir__ = 1;
-        this.__filtered__ = false;
-        this.__iteratees__ = [];
-        this.__takeCount__ = MAX_ARRAY_LENGTH;
-        this.__views__ = [];
-    }
-    LazyWrapper$2.prototype = baseCreate$2(baseLodash$2.prototype);
-    LazyWrapper$2.prototype.constructor = LazyWrapper$2;
-    var _LazyWrapper = LazyWrapper$2;
-    var baseCreate$1 = _baseCreate,
-        baseLodash$1 = _baseLodash;
+    width: 100%;
 
-    function LodashWrapper$2(value, chainAll) {
-        this.__wrapped__ = value;
-        this.__actions__ = [];
-        this.__chain__ = !!chainAll;
-        this.__index__ = 0;
-        this.__values__ = void 0;
-    }
-    LodashWrapper$2.prototype = baseCreate$1(baseLodash$1.prototype);
-    LodashWrapper$2.prototype.constructor = LodashWrapper$2;
-    var _LodashWrapper = LodashWrapper$2;
+    border-radius: 1rem 1rem 0 0;
+`;
+    styled__default.default.span`
+    cursor: pointer;
+    user-select: none;
 
-    function copyArray$4(source, array2) {
-        var index2 = -1,
-            length = source.length;
-        array2 || (array2 = Array(length));
-        while (++index2 < length) {
-            array2[index2] = source[index2];
-        }
-        return array2;
-    }
-    var _copyArray = copyArray$4;
-    var LazyWrapper$1 = _LazyWrapper,
-        LodashWrapper$1 = _LodashWrapper,
-        copyArray$3 = _copyArray;
+    overflow: hidden;
+    display: flex;
+    flex: 1 1 0;
+    align-items: center;
+    justify-content: center;
 
-    function wrapperClone$1(wrapper) {
-        if (wrapper instanceof LazyWrapper$1) {
-            return wrapper.clone();
-        }
-        var result = new LodashWrapper$1(wrapper.__wrapped__, wrapper.__chain__);
-        result.__actions__ = copyArray$3(wrapper.__actions__);
-        result.__index__ = wrapper.__index__;
-        result.__values__ = wrapper.__values__;
-        return result;
-    }
-    var _wrapperClone = wrapperClone$1;
-    var LazyWrapper = _LazyWrapper,
-        LodashWrapper = _LodashWrapper,
-        baseLodash = _baseLodash,
-        isArray$8 = isArray_1,
-        isObjectLike$2 = isObjectLike_1,
-        wrapperClone = _wrapperClone;
-    var objectProto$3 = Object.prototype;
-    var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
+    box-sizing: border-box;
+    height: 2.5rem;
 
-    function lodash(value) {
-        if (isObjectLike$2(value) && !isArray$8(value) && !(value instanceof LazyWrapper)) {
-            if (value instanceof LodashWrapper) {
-                return value;
-            }
-            if (hasOwnProperty$4.call(value, "__wrapped__")) {
-                return wrapperClone(value);
-            }
-        }
-        return new LodashWrapper(value);
+    color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.grey3};
+
+    background-color: ${(props) => props.theme.colors.blue1};
+    border-bottom: ${(props) => props.selected ? `2px solid ${props.theme.colors.primary}` : `1px solid ${props.theme.colors.grey3}`};
+
+    :hover {
+        color: ${(props) => props.selected ? props.theme.colors.primary : props.theme.colors.text};
+        background-color: ${(props) => props.selected ? props.theme.colors.blue1 : props.theme.colors.grey1};
     }
-    lodash.prototype = baseLodash.prototype;
-    lodash.prototype.constructor = lodash;
-    var getNative = _getNative;
-    var defineProperty$1 = function() {
-        try {
-            var func = getNative(Object, "defineProperty");
-            func({}, "", {});
-            return func;
-        } catch (e3) {}
-    }();
-    var _defineProperty$k = defineProperty$1;
 
-    function arrayEach$1(array2, iteratee) {
-        var index2 = -1,
-            length = array2 == null ? 0 : array2.length;
-        while (++index2 < length) {
-            if (iteratee(array2[index2], index2, array2) === false) {
-                break;
-            }
-        }
-        return array2;
+    h2 {
+        font-weight: ${(props) => props.selected ? "700" : "400"};
     }
-    var _arrayEach = arrayEach$1;
+`;
+    styled__default.default.h2`
+    overflow: hidden;
+
+    width: 100%;
+    margin: 0;
+    padding: 0 1rem;
+
+    font-size: 1rem;
+    font-weight: 300;
+    text-align: center;
+    text-overflow: ellipsis;
+    white-space: nowrap;
+`;
 
     function useConfirmationModal(getMessage, confirm) {
         const [render2, setRender] = React.useState(false);
         const [canceledItem, setCanceledItem] = React.useState();
         const [message, setMessage] = React.useState("");
         const onConfirmation = (item) => {
             setMessage(getMessage(item));
@@ -337491,38 +345781,38 @@
             },
             onConfirmation
         };
     }
     const Wrapper$1 = styled__default.default.div`
     display: flex;
     flex-direction: column;
-    padding: 12px;
     width: 400px;
+    padding: 12px;
 `;
     const Footer = styled__default.default.div`
     display: flex;
     justify-content: space-between;
     margin-top: 12px;
 `;
 
     function ConfirmationModal(props) {
         var _a3;
-        return jsxRuntime.exports.jsx(Modal$1, {
+        return jsxRuntime.exports.jsx(Modal, {
             onAttemptClose: props.onCancel,
             render: props.render,
             style: props.style,
             children: jsxRuntime.exports.jsxs(Wrapper$1, {
                 children: [jsxRuntime.exports.jsx("h4", {
                     children: (_a3 = props.title) !== null && _a3 !== void 0 ? _a3 : "Confirm Cancellation"
                 }), props.message, jsxRuntime.exports.jsxs(Footer, {
-                    children: [jsxRuntime.exports.jsx(Button$3, {
+                    children: [jsxRuntime.exports.jsx(Button$1, {
                         onClick: props.onCancel,
                         styling: "secondary",
                         children: "Cancel"
-                    }), jsxRuntime.exports.jsx(Button$3, {
+                    }), jsxRuntime.exports.jsx(Button$1, {
                         onClick: props.onConfirm,
                         styling: "error",
                         children: "Confirm"
                     })]
                 })]
             })
         });
@@ -337668,15 +345958,15 @@
 
     margin: 0;
     padding: 0;
 
     font-weight: 400;
     color: ${(props) => props.theme.colors.text};
 `;
-    const SmallButton$1 = styled__default.default(Button$3)`
+    const SmallButton$1 = styled__default.default(Button$5)`
     width: 28px;
     min-width: 0;
     height: 28px;
     padding: 0 0.25rem;
 `;
 
     function PanelTitle(props) {
@@ -337816,15 +346106,15 @@
     function stringToSymbol(string2, position2) {
         const symbolMap = position2 === "head" ? headSymbolMap : tailSymbolMap;
         if (symbolMap[string2]) {
             return symbolMap[string2];
         }
         throw new Error(`Unrecognised symbol: ${string2}`);
     }
-    const FloatingButton = styled__default.default(Button$3).attrs((props) => {
+    const FloatingButton = styled__default.default(Button$5).attrs((props) => {
         var _a3;
         return Object.assign(Object.assign({}, props), {
             styling: (_a3 = props.styling) !== null && _a3 !== void 0 ? _a3 : "ghost"
         });
     })`
     pointer-events: ${(props) => props.disableEvents ? "none" : "all"};
     min-width: 0;
@@ -337843,15 +346133,15 @@
             editorMode,
             editable: editable2
         } = useSettings();
         const {
             disablePointerEvents
         } = React.useContext(pointerCtx);
         return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-            children: editable2 && editorMode !== EditorMode.EDGE_ENCODER && !disableLatentNodeAdd && jsxRuntime.exports.jsx(Tooltip$1, {
+            children: editable2 && editorMode !== EditorMode.EDGE_ENCODER && !disableLatentNodeAdd && jsxRuntime.exports.jsx(Tooltip$2, {
                 content: "Add Latent Node",
                 placement: "bottom",
                 children: jsxRuntime.exports.jsx(FloatingButton, {
                     "aria-label": "Add Latent Node",
                     disableEvents: disablePointerEvents,
                     fixedSize: true,
                     onClick: props.onAddNode,
@@ -337861,16 +346151,16 @@
         });
     }
 
     function CenterGraphButton(props) {
         const {
             disablePointerEvents
         } = React.useContext(pointerCtx);
-        const theme2 = useClTheme();
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        const theme2 = useClTheme$1();
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: "Center Graph",
             placement: "bottom",
             children: jsxRuntime.exports.jsx(FloatingButton, {
                 "aria-label": "Center Graph",
                 disableEvents: disablePointerEvents,
                 fixedSize: true,
                 onClick: props.onResetZoom,
@@ -337902,18 +346192,18 @@
             editable: editable2,
             disableEdgeAdd,
             allowNodeDrag
         } = useSettings();
         const {
             disablePointerEvents
         } = React.useContext(pointerCtx);
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const isMoveNode = props.dragMode === "move_node";
         return jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
-            children: editable2 && !disableEdgeAdd && allowNodeDrag && jsxRuntime.exports.jsx(Tooltip$1, {
+            children: editable2 && !disableEdgeAdd && allowNodeDrag && jsxRuntime.exports.jsx(Tooltip$2, {
                 content: `Drag behaviour: ${isMoveNode ? "Node Move" : "Edge Creation"}. Press and hold Command or Control to switch mode temporarily`,
                 placement: "bottom",
                 children: jsxRuntime.exports.jsx(FloatingButton, {
                     "aria-label": "Toggle drag behaviour",
                     disableEvents: disablePointerEvents,
                     fixedSize: true,
                     onClick: () => props.setDragMode(isMoveNode ? "create_edge" : "move_node"),
@@ -337926,15 +346216,15 @@
         });
     }
 
     function RecalculateLayoutButton(props) {
         const {
             disablePointerEvents
         } = React.useContext(pointerCtx);
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: "Recalculate Layout",
             placement: "bottom",
             children: jsxRuntime.exports.jsx(FloatingButton, {
                 "aria-label": "Recalculate Layout",
                 disableEvents: disablePointerEvents,
                 fixedSize: true,
                 onClick: props.onResetLayout,
@@ -337966,47 +346256,47 @@
                 cy: "13.4344",
                 fill: "currentColor",
                 r: "1.16733"
             })]
         });
     }
     const constraintItems = [{
-        label: jsxRuntime.exports.jsx(Tooltip$1, {
+        label: jsxRuntime.exports.jsx(Tooltip$2, {
             content: "Hard Directed",
             children: jsxRuntime.exports.jsx("span", {
                 children: jsxRuntime.exports.jsx(ArrowRightLong, {
                     size: "lg"
                 })
             })
         }),
         value: EdgeConstraintType.HARD_DIRECTED
     }, {
-        label: jsxRuntime.exports.jsx(Tooltip$1, {
+        label: jsxRuntime.exports.jsx(Tooltip$2, {
             content: "Soft Directed",
             children: jsxRuntime.exports.jsx("span", {
                 style: {
                     alignItems: "center",
                     display: "flex"
                 },
                 children: jsxRuntime.exports.jsx(SoftEdgeArrowButton, {})
             })
         }),
         value: EdgeConstraintType.SOFT_DIRECTED
     }, {
-        label: jsxRuntime.exports.jsx(Tooltip$1, {
+        label: jsxRuntime.exports.jsx(Tooltip$2, {
             content: "Undirected",
             children: jsxRuntime.exports.jsx("span", {
                 children: jsxRuntime.exports.jsx(ArrowsHorizontal, {
                     size: "lg"
                 })
             })
         }),
         value: EdgeConstraintType.UNDIRECTED
     }, {
-        label: jsxRuntime.exports.jsx(Tooltip$1, {
+        label: jsxRuntime.exports.jsx(Tooltip$2, {
             content: "Forbidden",
             children: jsxRuntime.exports.jsx("span", {
                 children: jsxRuntime.exports.jsx(Ban, {
                     size: "lg"
                 })
             })
         }),
@@ -338128,26 +346418,26 @@
     (function(exports3) {
         var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,
             MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,
             MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
         var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,
             MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,
             MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
-        exports3.getPointerArray = function(size) {
-            var maxIndex = size - 1;
+        exports3.getPointerArray = function(size2) {
+            var maxIndex = size2 - 1;
             if (maxIndex <= MAX_8BIT_INTEGER)
                 return Uint8Array;
             if (maxIndex <= MAX_16BIT_INTEGER)
                 return Uint16Array;
             if (maxIndex <= MAX_32BIT_INTEGER)
                 return Uint32Array;
             throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
         };
-        exports3.getSignedPointerArray = function(size) {
-            var maxIndex = size - 1;
+        exports3.getSignedPointerArray = function(size2) {
+            var maxIndex = size2 - 1;
             if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
                 return Int8Array;
             if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
                 return Int16Array;
             if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
                 return Int32Array;
             return Float64Array;
@@ -338701,15 +346991,15 @@
                 graphClone.dropEdge(props.source, props.target);
                 const invalidForward = newSymbol === EdgeType.DIRECTED_EDGE && willCreateCycle(graphClone, [props.source, props.target]);
                 const invalidBackward = newSymbol === EdgeType.BACKWARDS_DIRECTED_EDGE && willCreateCycle(graphClone, [props.target, props.source]);
                 if (invalidForward || invalidBackward) {
                     onNotify === null || onNotify === void 0 ? void 0 : onNotify({
                         key: "edge-type-change-cycle",
                         message: `Edge type "${newTail}${newHead}" not allowed as it would create a cycle`,
-                        status: Status.WARNING,
+                        status: Status$1.WARNING,
                         title: "Cycle detected"
                     });
                     return;
                 }
             }
             props.api.updateEdgeType([props.source, props.target], newTail + newHead);
         }
@@ -338763,15 +347053,15 @@
             "$fillHeight": true,
             "$gap": 2,
             children: editorMode === EditorMode.RESOLVER && !(props.edge["meta.rendering_properties.accepted"] || props.edge["meta.rendering_properties.forced"]) && jsxRuntime.exports.jsx("div", {
                 style: {
                     display: "flex",
                     justifyContent: "center"
                 },
-                children: jsxRuntime.exports.jsx(Button$3, {
+                children: jsxRuntime.exports.jsx(Button$5, {
                     disabled: props.edge.edge_type !== EdgeType.DIRECTED_EDGE,
                     onClick: () => props.api.acceptEdge([props.source, props.target]),
                     style: {
                         width: "max-content"
                     },
                     children: "Accept Edge"
                 })
@@ -338859,15 +347149,15 @@
 `;
     const ArrowsWrapper = styled__default.default.div`
     display: flex;
     flex-direction: column;
     width: 10%;
     color: ${(props) => props.theme.colors.text};
 `;
-    const ArrowButton = styled__default.default(Button$3)`
+    const ArrowButton = styled__default.default(Button$5)`
     width: 1rem;
     min-width: 0;
     height: 1rem;
     margin: 0;
     padding: 0;
 
     color: ${(props) => props.theme.colors.grey3};
@@ -338962,15 +347252,15 @@
                     source,
                     state: props.state,
                     target
                 }), props.extraSections]
             })]
         });
     }
-    const StyledInput$1 = styled__default.default(Input$3)`
+    const StyledInput$1 = styled__default.default(Input$5)`
     width: 100%;
 
     input {
         width: 100%;
     }
 `;
     const LabelEditorWrapper$1 = styled__default.default.div`
@@ -339128,15 +347418,15 @@
     position: absolute;
     z-index: 2;
     top: 0;
     right: 0;
 
     transition: opacity 0.3s;
 `;
-    const InsideButton = styled__default.default(Button$3)`
+    const InsideButton = styled__default.default(Button$5)`
     position: absolute;
     top: 10px;
 
     min-width: 0;
     height: 20px;
     margin: 0;
     padding: 0 0.25rem;
@@ -339147,15 +347437,15 @@
 `;
     const OpenSearchWrapper = styled__default.default.div`
     position: relative;
     transform-origin: right;
     overflow: hidden;
     transition: opacity 0.3s, width 0.3s;
 `;
-    const SearchInput = styled__default.default(Input$3)`
+    const SearchInput = styled__default.default(Input$5)`
     position: relative;
     width: 300px;
     height: 40px;
 
     input {
         width: 100%;
         height: 100%;
@@ -339185,15 +347475,15 @@
         const debouncedOnChange = debounce_1((val, e3) => {
             props.onChange(val, e3);
         }, inputDebounceValue);
         useUpdateEffect(() => {
             debouncedOnChange(searchInput);
         }, [searchInput]);
         const wrapperRef = React.useRef(null);
-        useOnClickOutside(wrapperRef.current, () => {
+        useOnClickOutside$1(wrapperRef.current, () => {
             if (!showResultCount) {
                 setShowSearchBar(false);
             }
         });
 
         function onEnter() {
             if (props.totalNumberOfResults) {
@@ -339255,15 +347545,15 @@
             });
         }
         return jsxRuntime.exports.jsxs("div", {
             ref: wrapperRef,
             style: {
                 position: "relative"
             },
-            children: [jsxRuntime.exports.jsx(Tooltip$1, {
+            children: [jsxRuntime.exports.jsx(Tooltip$2, {
                 content: "Search Nodes",
                 placement: "bottom",
                 children: jsxRuntime.exports.jsx(OpenSearchButton, {
                     disableEvents: disablePointerEvents,
                     fixedSize: true,
                     onClick: onOpenSearch,
                     style: {
@@ -339291,15 +347581,15 @@
                     "aria-label": "Close search bar",
                     onClick: onClose,
                     style: {
                         opacity: showSearchBar ? 1 : 0,
                         right: "0.75rem"
                     },
                     styling: "ghost",
-                    children: jsxRuntime.exports.jsx(Cross$1, {})
+                    children: jsxRuntime.exports.jsx(Cross$2, {})
                 })]
             })]
         });
     }
 
     function useSearch({
         graph,
@@ -339469,15 +347759,15 @@
         none: null,
         normal: Chevron,
         soft: HalfCircle
     };
 
     function LegendSymbol(props) {
         var _a3, _b, _c, _d, _e2, _f;
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         if (props.type === "node") {
             const fillColor = (_a3 = props === null || props === void 0 ? void 0 : props.color) !== null && _a3 !== void 0 ? _a3 : theme2.colors.blue4;
             const borderColor = (_b = props === null || props === void 0 ? void 0 : props.highlight_color) !== null && _b !== void 0 ? _b : theme2.colors.primary;
             return jsxRuntime.exports.jsx("svg", {
                 height: "16px",
                 viewBox: "-40 0 100 25",
                 children: jsxRuntime.exports.jsx("circle", {
@@ -339575,691 +347865,69 @@
 
     function Legend(props) {
         const [showLegend, setShowLegend] = React.useState(false);
         const {
             disablePointerEvents
         } = React.useContext(pointerCtx);
         const panelRef = React.useRef(null);
-        useOnClickOutside(panelRef.current, () => setShowLegend(false));
+        useOnClickOutside$1(panelRef.current, () => setShowLegend(false));
         if (!props.listItems || props.listItems.length === 0) {
             return null;
         }
         return jsxRuntime.exports.jsxs("div", {
             style: {
                 position: "relative"
             },
-            children: [jsxRuntime.exports.jsx(Tooltip$1, {
+            children: [jsxRuntime.exports.jsx(Tooltip$2, {
                 content: "Legend",
                 placement: "top",
                 children: jsxRuntime.exports.jsx(LegendOpenButton, {
                     fixedSize: true,
                     onClick: () => setShowLegend(true),
                     style: {
                         opacity: showLegend ? 0 : 1,
                         pointerEvents: showLegend || disablePointerEvents ? "none" : "all"
                     },
-                    children: jsxRuntime.exports.jsx(List$1, {})
+                    children: jsxRuntime.exports.jsx(List$2, {})
                 })
             }), jsxRuntime.exports.jsxs(LegendWrapper, {
                 ref: panelRef,
                 style: {
                     minWidth: "13rem",
                     opacity: showLegend ? 1 : 0,
                     pointerEvents: !showLegend || disablePointerEvents ? "none" : "all",
                     transform: showLegend ? "scale(1)" : "scale(0)"
                 },
-                children: [jsxRuntime.exports.jsx(Button$3, {
+                children: [jsxRuntime.exports.jsx(Button$5, {
                     style: {
                         height: "12px",
                         margin: 0,
                         minWidth: 0,
                         padding: 0,
                         position: "absolute",
                         right: "1rem",
                         top: "1rem",
                         width: "12px"
                     },
                     styling: "ghost",
-                    children: jsxRuntime.exports.jsx(Cross$1, {
+                    children: jsxRuntime.exports.jsx(Cross$2, {
                         onClick: () => setShowLegend(false)
                     })
                 }), jsxRuntime.exports.jsx(LegendList, {
                     listItems: props.listItems
                 })]
             })]
         });
     }
 
     function getLegendData(defaultLegends, editorMode, additionalLegend) {
         var _a3;
         const modeData = (_a3 = defaultLegends === null || defaultLegends === void 0 ? void 0 : defaultLegends[editorMode]) !== null && _a3 !== void 0 ? _a3 : [];
         return [...modeData, ...(additionalLegend !== null && additionalLegend !== void 0 ? additionalLegend : []).filter(Boolean)];
     }
-    var PolishedError = /* @__PURE__ */ function(_Error) {
-        _inheritsLoose$2(PolishedError2, _Error);
-
-        function PolishedError2(code2) {
-            var _this;
-            {
-                _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code2 + " for more information.") || this;
-            }
-            return _assertThisInitialized$3(_this);
-        }
-        return PolishedError2;
-    }( /* @__PURE__ */ _wrapNativeSuper$1(Error));
-
-    function colorToInt(color2) {
-        return Math.round(color2 * 255);
-    }
-
-    function convertToInt(red, green, blue) {
-        return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
-    }
-
-    function hslToRgb(hue, saturation, lightness, convert2) {
-        if (convert2 === void 0) {
-            convert2 = convertToInt;
-        }
-        if (saturation === 0) {
-            return convert2(lightness, lightness, lightness);
-        }
-        var huePrime = (hue % 360 + 360) % 360 / 60;
-        var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
-        var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
-        var red = 0;
-        var green = 0;
-        var blue = 0;
-        if (huePrime >= 0 && huePrime < 1) {
-            red = chroma;
-            green = secondComponent;
-        } else if (huePrime >= 1 && huePrime < 2) {
-            red = secondComponent;
-            green = chroma;
-        } else if (huePrime >= 2 && huePrime < 3) {
-            green = chroma;
-            blue = secondComponent;
-        } else if (huePrime >= 3 && huePrime < 4) {
-            green = secondComponent;
-            blue = chroma;
-        } else if (huePrime >= 4 && huePrime < 5) {
-            red = secondComponent;
-            blue = chroma;
-        } else if (huePrime >= 5 && huePrime < 6) {
-            red = chroma;
-            blue = secondComponent;
-        }
-        var lightnessModification = lightness - chroma / 2;
-        var finalRed = red + lightnessModification;
-        var finalGreen = green + lightnessModification;
-        var finalBlue = blue + lightnessModification;
-        return convert2(finalRed, finalGreen, finalBlue);
-    }
-    var namedColorMap = {
-        aliceblue: "f0f8ff",
-        antiquewhite: "faebd7",
-        aqua: "00ffff",
-        aquamarine: "7fffd4",
-        azure: "f0ffff",
-        beige: "f5f5dc",
-        bisque: "ffe4c4",
-        black: "000",
-        blanchedalmond: "ffebcd",
-        blue: "0000ff",
-        blueviolet: "8a2be2",
-        brown: "a52a2a",
-        burlywood: "deb887",
-        cadetblue: "5f9ea0",
-        chartreuse: "7fff00",
-        chocolate: "d2691e",
-        coral: "ff7f50",
-        cornflowerblue: "6495ed",
-        cornsilk: "fff8dc",
-        crimson: "dc143c",
-        cyan: "00ffff",
-        darkblue: "00008b",
-        darkcyan: "008b8b",
-        darkgoldenrod: "b8860b",
-        darkgray: "a9a9a9",
-        darkgreen: "006400",
-        darkgrey: "a9a9a9",
-        darkkhaki: "bdb76b",
-        darkmagenta: "8b008b",
-        darkolivegreen: "556b2f",
-        darkorange: "ff8c00",
-        darkorchid: "9932cc",
-        darkred: "8b0000",
-        darksalmon: "e9967a",
-        darkseagreen: "8fbc8f",
-        darkslateblue: "483d8b",
-        darkslategray: "2f4f4f",
-        darkslategrey: "2f4f4f",
-        darkturquoise: "00ced1",
-        darkviolet: "9400d3",
-        deeppink: "ff1493",
-        deepskyblue: "00bfff",
-        dimgray: "696969",
-        dimgrey: "696969",
-        dodgerblue: "1e90ff",
-        firebrick: "b22222",
-        floralwhite: "fffaf0",
-        forestgreen: "228b22",
-        fuchsia: "ff00ff",
-        gainsboro: "dcdcdc",
-        ghostwhite: "f8f8ff",
-        gold: "ffd700",
-        goldenrod: "daa520",
-        gray: "808080",
-        green: "008000",
-        greenyellow: "adff2f",
-        grey: "808080",
-        honeydew: "f0fff0",
-        hotpink: "ff69b4",
-        indianred: "cd5c5c",
-        indigo: "4b0082",
-        ivory: "fffff0",
-        khaki: "f0e68c",
-        lavender: "e6e6fa",
-        lavenderblush: "fff0f5",
-        lawngreen: "7cfc00",
-        lemonchiffon: "fffacd",
-        lightblue: "add8e6",
-        lightcoral: "f08080",
-        lightcyan: "e0ffff",
-        lightgoldenrodyellow: "fafad2",
-        lightgray: "d3d3d3",
-        lightgreen: "90ee90",
-        lightgrey: "d3d3d3",
-        lightpink: "ffb6c1",
-        lightsalmon: "ffa07a",
-        lightseagreen: "20b2aa",
-        lightskyblue: "87cefa",
-        lightslategray: "789",
-        lightslategrey: "789",
-        lightsteelblue: "b0c4de",
-        lightyellow: "ffffe0",
-        lime: "0f0",
-        limegreen: "32cd32",
-        linen: "faf0e6",
-        magenta: "f0f",
-        maroon: "800000",
-        mediumaquamarine: "66cdaa",
-        mediumblue: "0000cd",
-        mediumorchid: "ba55d3",
-        mediumpurple: "9370db",
-        mediumseagreen: "3cb371",
-        mediumslateblue: "7b68ee",
-        mediumspringgreen: "00fa9a",
-        mediumturquoise: "48d1cc",
-        mediumvioletred: "c71585",
-        midnightblue: "191970",
-        mintcream: "f5fffa",
-        mistyrose: "ffe4e1",
-        moccasin: "ffe4b5",
-        navajowhite: "ffdead",
-        navy: "000080",
-        oldlace: "fdf5e6",
-        olive: "808000",
-        olivedrab: "6b8e23",
-        orange: "ffa500",
-        orangered: "ff4500",
-        orchid: "da70d6",
-        palegoldenrod: "eee8aa",
-        palegreen: "98fb98",
-        paleturquoise: "afeeee",
-        palevioletred: "db7093",
-        papayawhip: "ffefd5",
-        peachpuff: "ffdab9",
-        peru: "cd853f",
-        pink: "ffc0cb",
-        plum: "dda0dd",
-        powderblue: "b0e0e6",
-        purple: "800080",
-        rebeccapurple: "639",
-        red: "f00",
-        rosybrown: "bc8f8f",
-        royalblue: "4169e1",
-        saddlebrown: "8b4513",
-        salmon: "fa8072",
-        sandybrown: "f4a460",
-        seagreen: "2e8b57",
-        seashell: "fff5ee",
-        sienna: "a0522d",
-        silver: "c0c0c0",
-        skyblue: "87ceeb",
-        slateblue: "6a5acd",
-        slategray: "708090",
-        slategrey: "708090",
-        snow: "fffafa",
-        springgreen: "00ff7f",
-        steelblue: "4682b4",
-        tan: "d2b48c",
-        teal: "008080",
-        thistle: "d8bfd8",
-        tomato: "ff6347",
-        turquoise: "40e0d0",
-        violet: "ee82ee",
-        wheat: "f5deb3",
-        white: "fff",
-        whitesmoke: "f5f5f5",
-        yellow: "ff0",
-        yellowgreen: "9acd32"
-    };
-
-    function nameToHex(color2) {
-        if (typeof color2 !== "string")
-            return color2;
-        var normalizedColorName = color2.toLowerCase();
-        return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color2;
-    }
-    var hexRegex = /^#[a-fA-F0-9]{6}$/;
-    var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
-    var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
-    var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
-    var rgbRegex = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i;
-    var rgbaRegex = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
-    var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
-    var hslaRegex = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
-
-    function parseToRgb(color2) {
-        if (typeof color2 !== "string") {
-            throw new PolishedError(3);
-        }
-        var normalizedColor = nameToHex(color2);
-        if (normalizedColor.match(hexRegex)) {
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
-                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
-                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
-            };
-        }
-        if (normalizedColor.match(hexRgbaRegex)) {
-            var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
-                green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
-                blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
-                alpha
-            };
-        }
-        if (normalizedColor.match(reducedHexRegex)) {
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
-                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
-                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
-            };
-        }
-        if (normalizedColor.match(reducedRgbaHexRegex)) {
-            var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
-            return {
-                red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
-                green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
-                blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
-                alpha: _alpha
-            };
-        }
-        var rgbMatched = rgbRegex.exec(normalizedColor);
-        if (rgbMatched) {
-            return {
-                red: parseInt("" + rgbMatched[1], 10),
-                green: parseInt("" + rgbMatched[2], 10),
-                blue: parseInt("" + rgbMatched[3], 10)
-            };
-        }
-        var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));
-        if (rgbaMatched) {
-            return {
-                red: parseInt("" + rgbaMatched[1], 10),
-                green: parseInt("" + rgbaMatched[2], 10),
-                blue: parseInt("" + rgbaMatched[3], 10),
-                alpha: parseFloat("" + rgbaMatched[4]) > 1 ? parseFloat("" + rgbaMatched[4]) / 100 : parseFloat("" + rgbaMatched[4])
-            };
-        }
-        var hslMatched = hslRegex.exec(normalizedColor);
-        if (hslMatched) {
-            var hue = parseInt("" + hslMatched[1], 10);
-            var saturation = parseInt("" + hslMatched[2], 10) / 100;
-            var lightness = parseInt("" + hslMatched[3], 10) / 100;
-            var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
-            var hslRgbMatched = rgbRegex.exec(rgbColorString);
-            if (!hslRgbMatched) {
-                throw new PolishedError(4, normalizedColor, rgbColorString);
-            }
-            return {
-                red: parseInt("" + hslRgbMatched[1], 10),
-                green: parseInt("" + hslRgbMatched[2], 10),
-                blue: parseInt("" + hslRgbMatched[3], 10)
-            };
-        }
-        var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));
-        if (hslaMatched) {
-            var _hue = parseInt("" + hslaMatched[1], 10);
-            var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
-            var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
-            var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
-            var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
-            if (!_hslRgbMatched) {
-                throw new PolishedError(4, normalizedColor, _rgbColorString);
-            }
-            return {
-                red: parseInt("" + _hslRgbMatched[1], 10),
-                green: parseInt("" + _hslRgbMatched[2], 10),
-                blue: parseInt("" + _hslRgbMatched[3], 10),
-                alpha: parseFloat("" + hslaMatched[4]) > 1 ? parseFloat("" + hslaMatched[4]) / 100 : parseFloat("" + hslaMatched[4])
-            };
-        }
-        throw new PolishedError(5);
-    }
-
-    function rgbToHsl(color2) {
-        var red = color2.red / 255;
-        var green = color2.green / 255;
-        var blue = color2.blue / 255;
-        var max2 = Math.max(red, green, blue);
-        var min2 = Math.min(red, green, blue);
-        var lightness = (max2 + min2) / 2;
-        if (max2 === min2) {
-            if (color2.alpha !== void 0) {
-                return {
-                    hue: 0,
-                    saturation: 0,
-                    lightness,
-                    alpha: color2.alpha
-                };
-            } else {
-                return {
-                    hue: 0,
-                    saturation: 0,
-                    lightness
-                };
-            }
-        }
-        var hue;
-        var delta = max2 - min2;
-        var saturation = lightness > 0.5 ? delta / (2 - max2 - min2) : delta / (max2 + min2);
-        switch (max2) {
-            case red:
-                hue = (green - blue) / delta + (green < blue ? 6 : 0);
-                break;
-            case green:
-                hue = (blue - red) / delta + 2;
-                break;
-            default:
-                hue = (red - green) / delta + 4;
-                break;
-        }
-        hue *= 60;
-        if (color2.alpha !== void 0) {
-            return {
-                hue,
-                saturation,
-                lightness,
-                alpha: color2.alpha
-            };
-        }
-        return {
-            hue,
-            saturation,
-            lightness
-        };
-    }
-
-    function parseToHsl(color2) {
-        return rgbToHsl(parseToRgb(color2));
-    }
-    var reduceHexValue = function reduceHexValue2(value) {
-        if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
-            return "#" + value[1] + value[3] + value[5];
-        }
-        return value;
-    };
-    var reduceHexValue$1 = reduceHexValue;
-
-    function numberToHex(value) {
-        var hex2 = value.toString(16);
-        return hex2.length === 1 ? "0" + hex2 : hex2;
-    }
-
-    function colorToHex(color2) {
-        return numberToHex(Math.round(color2 * 255));
-    }
-
-    function convertToHex(red, green, blue) {
-        return reduceHexValue$1("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
-    }
-
-    function hslToHex(hue, saturation, lightness) {
-        return hslToRgb(hue, saturation, lightness, convertToHex);
-    }
-
-    function hsl(value, saturation, lightness) {
-        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number") {
-            return hslToHex(value, saturation, lightness);
-        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0) {
-            return hslToHex(value.hue, value.saturation, value.lightness);
-        }
-        throw new PolishedError(1);
-    }
-
-    function hsla$1(value, saturation, lightness, alpha) {
-        if (typeof value === "number" && typeof saturation === "number" && typeof lightness === "number" && typeof alpha === "number") {
-            return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
-        } else if (typeof value === "object" && saturation === void 0 && lightness === void 0 && alpha === void 0) {
-            return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
-        }
-        throw new PolishedError(2);
-    }
-
-    function rgb(value, green, blue) {
-        if (typeof value === "number" && typeof green === "number" && typeof blue === "number") {
-            return reduceHexValue$1("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
-        } else if (typeof value === "object" && green === void 0 && blue === void 0) {
-            return reduceHexValue$1("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
-        }
-        throw new PolishedError(6);
-    }
-
-    function rgba$1(firstValue, secondValue, thirdValue, fourthValue) {
-        if (typeof firstValue === "string" && typeof secondValue === "number") {
-            var rgbValue = parseToRgb(firstValue);
-            return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
-        } else if (typeof firstValue === "number" && typeof secondValue === "number" && typeof thirdValue === "number" && typeof fourthValue === "number") {
-            return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
-        } else if (typeof firstValue === "object" && secondValue === void 0 && thirdValue === void 0 && fourthValue === void 0) {
-            return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
-        }
-        throw new PolishedError(7);
-    }
-    var isRgb = function isRgb2(color2) {
-        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
-    };
-    var isRgba = function isRgba2(color2) {
-        return typeof color2.red === "number" && typeof color2.green === "number" && typeof color2.blue === "number" && typeof color2.alpha === "number";
-    };
-    var isHsl = function isHsl2(color2) {
-        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && (typeof color2.alpha !== "number" || typeof color2.alpha === "undefined");
-    };
-    var isHsla = function isHsla2(color2) {
-        return typeof color2.hue === "number" && typeof color2.saturation === "number" && typeof color2.lightness === "number" && typeof color2.alpha === "number";
-    };
-
-    function toColorString(color2) {
-        if (typeof color2 !== "object")
-            throw new PolishedError(8);
-        if (isRgba(color2))
-            return rgba$1(color2);
-        if (isRgb(color2))
-            return rgb(color2);
-        if (isHsla(color2))
-            return hsla$1(color2);
-        if (isHsl(color2))
-            return hsl(color2);
-        throw new PolishedError(8);
-    }
-
-    function curried(f2, length, acc) {
-        return function fn2() {
-            var combined = acc.concat(Array.prototype.slice.call(arguments));
-            return combined.length >= length ? f2.apply(this, combined) : curried(f2, length, combined);
-        };
-    }
-
-    function curry(f2) {
-        return curried(f2, f2.length, []);
-    }
-
-    function adjustHue(degree, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            hue: hslColor.hue + parseFloat(degree)
-        }));
-    }
-    curry(adjustHue);
-
-    function guard(lowerBoundary, upperBoundary, value) {
-        return Math.max(lowerBoundary, Math.min(upperBoundary, value));
-    }
-
-    function darken(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
-        }));
-    }
-    curry(darken);
-
-    function desaturate(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
-        }));
-    }
-    curry(desaturate);
-
-    function lighten(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
-        }));
-    }
-    curry(lighten);
-
-    function mix(weight, color2, otherColor) {
-        if (color2 === "transparent")
-            return otherColor;
-        if (otherColor === "transparent")
-            return color2;
-        if (weight === 0)
-            return otherColor;
-        var parsedColor1 = parseToRgb(color2);
-        var color1 = _extends$3({}, parsedColor1, {
-            alpha: typeof parsedColor1.alpha === "number" ? parsedColor1.alpha : 1
-        });
-        var parsedColor2 = parseToRgb(otherColor);
-        var color22 = _extends$3({}, parsedColor2, {
-            alpha: typeof parsedColor2.alpha === "number" ? parsedColor2.alpha : 1
-        });
-        var alphaDelta = color1.alpha - color22.alpha;
-        var x2 = parseFloat(weight) * 2 - 1;
-        var y2 = x2 * alphaDelta === -1 ? x2 : x2 + alphaDelta;
-        var z2 = 1 + x2 * alphaDelta;
-        var weight1 = (y2 / z2 + 1) / 2;
-        var weight2 = 1 - weight1;
-        var mixedColor = {
-            red: Math.floor(color1.red * weight1 + color22.red * weight2),
-            green: Math.floor(color1.green * weight1 + color22.green * weight2),
-            blue: Math.floor(color1.blue * weight1 + color22.blue * weight2),
-            alpha: color1.alpha * parseFloat(weight) + color22.alpha * (1 - parseFloat(weight))
-        };
-        return rgba$1(mixedColor);
-    }
-    var curriedMix = curry(mix);
-    var mix$1 = curriedMix;
-
-    function opacify(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var parsedColor = parseToRgb(color2);
-        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
-        var colorWithAlpha = _extends$3({}, parsedColor, {
-            alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)
-        });
-        return rgba$1(colorWithAlpha);
-    }
-    curry(opacify);
-
-    function saturate(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var hslColor = parseToHsl(color2);
-        return toColorString(_extends$3({}, hslColor, {
-            saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))
-        }));
-    }
-    curry(saturate);
-
-    function setHue(hue, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return toColorString(_extends$3({}, parseToHsl(color2), {
-            hue: parseFloat(hue)
-        }));
-    }
-    curry(setHue);
-
-    function setLightness(lightness, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return toColorString(_extends$3({}, parseToHsl(color2), {
-            lightness: parseFloat(lightness)
-        }));
-    }
-    curry(setLightness);
-
-    function setSaturation(saturation, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return toColorString(_extends$3({}, parseToHsl(color2), {
-            saturation: parseFloat(saturation)
-        }));
-    }
-    curry(setSaturation);
-
-    function shade(percentage, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return mix$1(parseFloat(percentage), "rgb(0, 0, 0)", color2);
-    }
-    curry(shade);
-
-    function tint(percentage, color2) {
-        if (color2 === "transparent")
-            return color2;
-        return mix$1(parseFloat(percentage), "rgb(255, 255, 255)", color2);
-    }
-    curry(tint);
-
-    function transparentize(amount, color2) {
-        if (color2 === "transparent")
-            return color2;
-        var parsedColor = parseToRgb(color2);
-        var alpha = typeof parsedColor.alpha === "number" ? parsedColor.alpha : 1;
-        var colorWithAlpha = _extends$3({}, parsedColor, {
-            alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
-        });
-        return rgba$1(colorWithAlpha);
-    }
-    curry(transparentize);
     const PromptWrapper = styled__default.default.div`
     padding: 0.25rem 0.5rem;
     background-color: ${({ theme: theme2 }) => mix$1(0.1, theme2.colors.primary, theme2.colors.blue1)};
     border: 1px solid ${({ theme: theme2 }) => mix$1(0.5, theme2.colors.primary, theme2.colors.blue1)};
     color: ${({ theme: theme2 }) => theme2.colors.primary};
     flex-shrink: 1;
     min-width: 0;
@@ -340274,15 +347942,15 @@
 `;
     const DismissText = styled__default.default.span`
     overflow: hidden;
     text-overflow: ellipsis;
     white-space: nowrap;
     min-width: 5ch;
 `;
-    const DismissButton = styled__default.default(Button$3)`
+    const DismissButton = styled__default.default(Button$5)`
     background-color: transparent;
     font-size: 0.875rem;
     padding: 0.25rem;
     height: auto;
     color: ${({ theme: theme2 }) => theme2.colors.primary};
 
     &:hover:not(:disabled) {
@@ -340291,15 +347959,15 @@
     }
 `;
     const DismissButtonText = styled__default.default.span`
     overflow: hidden;
     text-overflow: ellipsis;
     white-space: nowrap;
 `;
-    const CloseButton = styled__default.default(Button$3)`
+    const CloseButton = styled__default.default(Button$5)`
     padding: 0.25rem;
     height: auto;
     color: ${({ theme: theme2 }) => theme2.colors.primary};
 
     &:hover:not(:disabled) {
         background-color: ${({ theme: theme2 }) => mix$1(0.3, theme2.colors.primary, theme2.colors.blue1)};
     }
@@ -340338,18 +348006,18 @@
             },
             children: [jsxRuntime.exports.jsx(CloseButton, {
                 onClick: () => {
                     onPanelExit();
                     props.onClose();
                 },
                 styling: "ghost",
-                children: jsxRuntime.exports.jsx(Xmark, {
+                children: jsxRuntime.exports.jsx(Xmark$1, {
                     size: "lg"
                 })
-            }), jsxRuntime.exports.jsx(Tooltip$1, {
+            }), jsxRuntime.exports.jsx(Tooltip$2, {
                 content: textContent,
                 disabled: !showTooltip,
                 children: jsxRuntime.exports.jsx(DismissText, {
                     ref: textRef,
                     children: textContent
                 })
             }), jsxRuntime.exports.jsx(DismissButton, {
@@ -342295,21 +349963,21 @@
     }
 
     function compareX(a2, b2) {
         return a2.x - b2.x;
     }
 
     function eliminateHole(hole, outerNode) {
-        var bridge2 = findHoleBridge(hole, outerNode);
-        if (!bridge2) {
+        var bridge = findHoleBridge(hole, outerNode);
+        if (!bridge) {
             return outerNode;
         }
-        var bridgeReverse = splitPolygon(bridge2, hole);
+        var bridgeReverse = splitPolygon(bridge, hole);
         filterPoints(bridgeReverse, bridgeReverse.next);
-        return filterPoints(bridge2, bridge2.next);
+        return filterPoints(bridge, bridge.next);
     }
 
     function findHoleBridge(hole, outerNode) {
         var p2 = outerNode,
             hx = hole.x,
             hy = hole.y,
             qx = -Infinity,
@@ -343957,17 +351625,17 @@
         return "Object(" + str + ")";
     }
 
     function weakCollectionOf(type2) {
         return type2 + " { ? }";
     }
 
-    function collectionOf(type2, size, entries, indent2) {
+    function collectionOf(type2, size2, entries, indent2) {
         var joinedEntries = indent2 ? indentedJoin(entries, indent2) : $join.call(entries, ", ");
-        return type2 + " (" + size + ") {" + joinedEntries + "}";
+        return type2 + " (" + size2 + ") {" + joinedEntries + "}";
     }
 
     function singleLineValues(xs) {
         for (var i2 = 0; i2 < xs.length; i2++) {
             if (indexOf(xs[i2], "\n") >= 0) {
                 return false;
             }
@@ -346669,16 +354337,16 @@
     }
     const premultiplyBlendMode = mapPremultipliedBlendModes();
 
     function correctBlendMode(blendMode, premultiplied) {
         return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
     }
 
-    function createIndicesForQuads(size, outBuffer = null) {
-        const totalIndices = size * 6;
+    function createIndicesForQuads(size2, outBuffer = null) {
+        const totalIndices = size2 * 6;
         outBuffer = outBuffer || new Uint16Array(totalIndices);
         if (outBuffer.length !== totalIndices) {
             throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
         }
         for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
             outBuffer[i2 + 0] = j2 + 0;
             outBuffer[i2 + 1] = j2 + 1;
@@ -347635,21 +355303,21 @@
             if (!baseTexture) {
                 baseTexture = new _BaseTexture(source, options);
                 baseTexture.cacheId = cacheId;
                 _BaseTexture.addToCache(baseTexture, cacheId);
             }
             return baseTexture;
         }
-        static fromBuffer(buffer2, width, height, options) {
-            buffer2 = buffer2 || new Float32Array(width * height * 4);
-            const resource = new BufferResource(buffer2, {
+        static fromBuffer(buffer, width, height, options) {
+            buffer = buffer || new Float32Array(width * height * 4);
+            const resource = new BufferResource(buffer, {
                 width,
                 height
             });
-            const type2 = buffer2 instanceof Float32Array ? TYPES$1.FLOAT : TYPES$1.UNSIGNED_BYTE;
+            const type2 = buffer instanceof Float32Array ? TYPES$1.FLOAT : TYPES$1.UNSIGNED_BYTE;
             return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, {
                 type: type2
             }, options));
         }
         static addToCache(baseTexture, id2) {
             if (id2) {
                 if (!baseTexture.textureCacheIds.includes(id2)) {
@@ -347739,29 +355407,29 @@
             if (data2 instanceof Array) {
                 data2 = new Float32Array(data2);
             }
             return new Buffer$1(data2);
         }
     }
     class Attribute {
-        constructor(buffer2, size = 0, normalized = false, type2 = TYPES$1.FLOAT, stride, start2, instance2, divisor = 1) {
-            this.buffer = buffer2;
-            this.size = size;
+        constructor(buffer, size2 = 0, normalized = false, type2 = TYPES$1.FLOAT, stride, start2, instance2, divisor = 1) {
+            this.buffer = buffer;
+            this.size = size2;
             this.normalized = normalized;
             this.type = type2;
             this.stride = stride;
             this.start = start2;
             this.instance = instance2;
             this.divisor = divisor;
         }
         destroy() {
             this.buffer = null;
         }
-        static from(buffer2, size, normalized, type2, stride) {
-            return new Attribute(buffer2, size, normalized, type2, stride);
+        static from(buffer, size2, normalized, type2, stride) {
+            return new Attribute(buffer, size2, normalized, type2, stride);
         }
     }
     const map$1 = {
         Float32Array,
         Uint32Array,
         Int32Array,
         Uint8Array
@@ -347771,33 +355439,33 @@
         let outSize = 0;
         let stride = 0;
         const views = {};
         for (let i2 = 0; i2 < arrays.length; i2++) {
             stride += sizes[i2];
             outSize += arrays[i2].length;
         }
-        const buffer2 = new ArrayBuffer(outSize * 4);
+        const buffer = new ArrayBuffer(outSize * 4);
         let out = null;
         let littleOffset = 0;
         for (let i2 = 0; i2 < arrays.length; i2++) {
-            const size = sizes[i2];
+            const size2 = sizes[i2];
             const array2 = arrays[i2];
             const type2 = getBufferType(array2);
             if (!views[type2]) {
-                views[type2] = new map$1[type2](buffer2);
+                views[type2] = new map$1[type2](buffer);
             }
             out = views[type2];
             for (let j2 = 0; j2 < array2.length; j2++) {
-                const indexStart = (j2 / size | 0) * stride + littleOffset;
-                const index2 = j2 % size;
+                const indexStart = (j2 / size2 | 0) * stride + littleOffset;
+                const index2 = j2 % size2;
                 out[indexStart + index2] = array2[j2];
             }
-            littleOffset += size;
+            littleOffset += size2;
         }
-        return new Float32Array(buffer2);
+        return new Float32Array(buffer);
     }
     const byteSizeMap$1 = {
         5126: 4,
         5123: 2,
         5121: 1
     };
     let UID$3 = 0;
@@ -347816,57 +355484,57 @@
             this.glVertexArrayObjects = {};
             this.id = UID$3++;
             this.instanced = false;
             this.instanceCount = 1;
             this.disposeRunner = new Runner("disposeGeometry");
             this.refCount = 0;
         }
-        addAttribute(id2, buffer2, size = 0, normalized = false, type2, stride, start2, instance2 = false) {
-            if (!buffer2) {
+        addAttribute(id2, buffer, size2 = 0, normalized = false, type2, stride, start2, instance2 = false) {
+            if (!buffer) {
                 throw new Error("You must pass a buffer when creating an attribute");
             }
-            if (!(buffer2 instanceof Buffer$1)) {
-                if (buffer2 instanceof Array) {
-                    buffer2 = new Float32Array(buffer2);
+            if (!(buffer instanceof Buffer$1)) {
+                if (buffer instanceof Array) {
+                    buffer = new Float32Array(buffer);
                 }
-                buffer2 = new Buffer$1(buffer2);
+                buffer = new Buffer$1(buffer);
             }
             const ids = id2.split("|");
             if (ids.length > 1) {
                 for (let i2 = 0; i2 < ids.length; i2++) {
-                    this.addAttribute(ids[i2], buffer2, size, normalized, type2);
+                    this.addAttribute(ids[i2], buffer, size2, normalized, type2);
                 }
                 return this;
             }
-            let bufferIndex = this.buffers.indexOf(buffer2);
+            let bufferIndex = this.buffers.indexOf(buffer);
             if (bufferIndex === -1) {
-                this.buffers.push(buffer2);
+                this.buffers.push(buffer);
                 bufferIndex = this.buffers.length - 1;
             }
-            this.attributes[id2] = new Attribute(bufferIndex, size, normalized, type2, stride, start2, instance2);
+            this.attributes[id2] = new Attribute(bufferIndex, size2, normalized, type2, stride, start2, instance2);
             this.instanced = this.instanced || instance2;
             return this;
         }
         getAttribute(id2) {
             return this.attributes[id2];
         }
         getBuffer(id2) {
             return this.buffers[this.getAttribute(id2).buffer];
         }
-        addIndex(buffer2) {
-            if (!(buffer2 instanceof Buffer$1)) {
-                if (buffer2 instanceof Array) {
-                    buffer2 = new Uint16Array(buffer2);
-                }
-                buffer2 = new Buffer$1(buffer2);
-            }
-            buffer2.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
-            this.indexBuffer = buffer2;
-            if (!this.buffers.includes(buffer2)) {
-                this.buffers.push(buffer2);
+        addIndex(buffer) {
+            if (!(buffer instanceof Buffer$1)) {
+                if (buffer instanceof Array) {
+                    buffer = new Uint16Array(buffer);
+                }
+                buffer = new Buffer$1(buffer);
+            }
+            buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
+            this.indexBuffer = buffer;
+            if (!this.buffers.includes(buffer)) {
+                this.buffers.push(buffer);
             }
             return this;
         }
         getIndex() {
             return this.indexBuffer;
         }
         interleave() {
@@ -347874,16 +355542,16 @@
                 return this;
             const arrays = [];
             const sizes = [];
             const interleavedBuffer = new Buffer$1();
             let i2;
             for (i2 in this.attributes) {
                 const attribute = this.attributes[i2];
-                const buffer2 = this.buffers[attribute.buffer];
-                arrays.push(buffer2.data);
+                const buffer = this.buffers[attribute.buffer];
+                arrays.push(buffer.data);
                 sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);
                 attribute.buffer = 0;
             }
             interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
             for (i2 = 0; i2 < this.buffers.length; i2++) {
                 if (this.buffers[i2] !== this.indexBuffer) {
                     this.buffers[i2].destroy();
@@ -347894,16 +355562,16 @@
                 this.buffers.push(this.indexBuffer);
             }
             return this;
         }
         getSize() {
             for (const i2 in this.attributes) {
                 const attribute = this.attributes[i2];
-                const buffer2 = this.buffers[attribute.buffer];
-                return buffer2.data.length / (attribute.stride / 4 || attribute.size);
+                const buffer = this.buffers[attribute.buffer];
+                return buffer.data.length / (attribute.stride / 4 || attribute.size);
             }
             return 0;
         }
         dispose() {
             this.disposeRunner.emit(this, false);
         }
         destroy() {
@@ -347998,57 +355666,57 @@
     function compileShader(gl2, type2, src) {
         const shader = gl2.createShader(type2);
         gl2.shaderSource(shader, src);
         gl2.compileShader(shader);
         return shader;
     }
 
-    function booleanArray(size) {
-        const array2 = new Array(size);
+    function booleanArray(size2) {
+        const array2 = new Array(size2);
         for (let i2 = 0; i2 < array2.length; i2++) {
             array2[i2] = false;
         }
         return array2;
     }
 
-    function defaultValue(type2, size) {
+    function defaultValue(type2, size2) {
         switch (type2) {
             case "float":
                 return 0;
             case "vec2":
-                return new Float32Array(2 * size);
+                return new Float32Array(2 * size2);
             case "vec3":
-                return new Float32Array(3 * size);
+                return new Float32Array(3 * size2);
             case "vec4":
-                return new Float32Array(4 * size);
+                return new Float32Array(4 * size2);
             case "int":
             case "uint":
             case "sampler2D":
             case "sampler2DArray":
                 return 0;
             case "ivec2":
-                return new Int32Array(2 * size);
+                return new Int32Array(2 * size2);
             case "ivec3":
-                return new Int32Array(3 * size);
+                return new Int32Array(3 * size2);
             case "ivec4":
-                return new Int32Array(4 * size);
+                return new Int32Array(4 * size2);
             case "uvec2":
-                return new Uint32Array(2 * size);
+                return new Uint32Array(2 * size2);
             case "uvec3":
-                return new Uint32Array(3 * size);
+                return new Uint32Array(3 * size2);
             case "uvec4":
-                return new Uint32Array(4 * size);
+                return new Uint32Array(4 * size2);
             case "bool":
                 return false;
             case "bvec2":
-                return booleanArray(2 * size);
+                return booleanArray(2 * size2);
             case "bvec3":
-                return booleanArray(3 * size);
+                return booleanArray(3 * size2);
             case "bvec4":
-                return booleanArray(4 * size);
+                return booleanArray(4 * size2);
             case "mat2":
                 return new Float32Array([
                     1,
                     0,
                     0,
                     1
                 ]);
@@ -349118,25 +356786,25 @@
             } = this.renderer;
             const drawCalls = _BatchRenderer._drawCallPool;
             let curTexArray = null;
             for (let i2 = 0; i2 < dcCount; i2++) {
                 const {
                     texArray,
                     type: type2,
-                    size,
+                    size: size2,
                     start: start2,
                     blend
                 } = drawCalls[i2];
                 if (curTexArray !== texArray) {
                     curTexArray = texArray;
                     this.bindAndClearTexArray(texArray);
                 }
                 this.state.blendMode = blend;
                 stateSystem.set(this.state);
-                gl2.drawElements(type2, size, gl2.UNSIGNED_SHORT, start2 * 2);
+                gl2.drawElements(type2, size2, gl2.UNSIGNED_SHORT, start2 * 2);
             }
         }
         flush() {
             if (this._vertexCount === 0) {
                 return;
             }
             this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
@@ -349176,39 +356844,39 @@
             this._indexBuffer = null;
             if (this._shader) {
                 this._shader.destroy();
                 this._shader = null;
             }
             super.destroy();
         }
-        getAttributeBuffer(size) {
-            const roundedP2 = nextPow2(Math.ceil(size / 8));
+        getAttributeBuffer(size2) {
+            const roundedP2 = nextPow2(Math.ceil(size2 / 8));
             const roundedSizeIndex = log2$1(roundedP2);
             const roundedSize = roundedP2 * 8;
             if (this._aBuffers.length <= roundedSizeIndex) {
                 this._iBuffers.length = roundedSizeIndex + 1;
             }
-            let buffer2 = this._aBuffers[roundedSize];
-            if (!buffer2) {
-                this._aBuffers[roundedSize] = buffer2 = new ViewableBuffer(roundedSize * this.vertexSize * 4);
+            let buffer = this._aBuffers[roundedSize];
+            if (!buffer) {
+                this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
             }
-            return buffer2;
+            return buffer;
         }
-        getIndexBuffer(size) {
-            const roundedP2 = nextPow2(Math.ceil(size / 12));
+        getIndexBuffer(size2) {
+            const roundedP2 = nextPow2(Math.ceil(size2 / 12));
             const roundedSizeIndex = log2$1(roundedP2);
             const roundedSize = roundedP2 * 12;
             if (this._iBuffers.length <= roundedSizeIndex) {
                 this._iBuffers.length = roundedSizeIndex + 1;
             }
-            let buffer2 = this._iBuffers[roundedSizeIndex];
-            if (!buffer2) {
-                this._iBuffers[roundedSizeIndex] = buffer2 = new Uint16Array(roundedSize);
+            let buffer = this._iBuffers[roundedSizeIndex];
+            if (!buffer) {
+                this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
             }
-            return buffer2;
+            return buffer;
         }
         packInterleavedGeometry(element2, attributeBuffer, indexBuffer, aIndex, iIndex) {
             const {
                 uint32View,
                 float32View
             } = attributeBuffer;
             const packedVertices = aIndex / this.vertexSize;
@@ -350110,16 +357778,16 @@
             }, options), false);
             const resource = texture.baseTexture.resource;
             if (texture.baseTexture.valid) {
                 return Promise.resolve(texture);
             }
             return resource.load().then(() => Promise.resolve(texture));
         }
-        static fromBuffer(buffer2, width, height, options) {
-            return new Texture(BaseTexture.fromBuffer(buffer2, width, height, options));
+        static fromBuffer(buffer, width, height, options) {
+            return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
         }
         static fromLoader(source, imageUrl, name2, options) {
             const baseTexture = new BaseTexture(source, Object.assign({
                 scaleMode: BaseTexture.defaultOptions.scaleMode,
                 resolution: getResolutionOfUrl(imageUrl)
             }, options));
             const {
@@ -350358,33 +358026,33 @@
                             textures[j2].destroy(true);
                         }
                     }
                 }
             }
             this.texturePool = {};
         }
-        setScreenSize(size) {
-            if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
+        setScreenSize(size2) {
+            if (size2.width === this._pixelsWidth && size2.height === this._pixelsHeight) {
                 return;
             }
-            this.enableFullScreen = size.width > 0 && size.height > 0;
+            this.enableFullScreen = size2.width > 0 && size2.height > 0;
             for (const i2 in this.texturePool) {
                 if (!(Number(i2) < 0)) {
                     continue;
                 }
                 const textures = this.texturePool[i2];
                 if (textures) {
                     for (let j2 = 0; j2 < textures.length; j2++) {
                         textures[j2].destroy(true);
                     }
                 }
                 this.texturePool[i2] = [];
             }
-            this._pixelsWidth = size.width;
-            this._pixelsHeight = size.height;
+            this._pixelsWidth = size2.width;
+            this._pixelsHeight = size2.height;
         }
     }
     RenderTexturePool.SCREEN_KEY = -1;
     class Quad extends Geometry {
         constructor() {
             super();
             this.addAttribute("aVertexPosition", new Float32Array([
@@ -351226,16 +358894,16 @@
         reset() {
             this.unbind();
         }
         updateBuffers() {
             const geometry = this._activeGeometry;
             const bufferSystem = this.renderer.buffer;
             for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
-                const buffer2 = geometry.buffers[i2];
-                bufferSystem.update(buffer2);
+                const buffer = geometry.buffers[i2];
+                bufferSystem.update(buffer);
             }
         }
         checkCompatibility(geometry, program) {
             const geometryAttributes = geometry.attributes;
             const shaderAttributes = program.attributeData;
             for (const j2 in shaderAttributes) {
                 if (!geometryAttributes[j2]) {
@@ -351300,18 +358968,18 @@
                     attribute.start = tempStart[attribute.buffer];
                     tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
                 }
             }
             vao = gl2.createVertexArray();
             gl2.bindVertexArray(vao);
             for (let i2 = 0; i2 < buffers.length; i2++) {
-                const buffer2 = buffers[i2];
-                bufferSystem.bind(buffer2);
+                const buffer = buffers[i2];
+                bufferSystem.bind(buffer);
                 if (incRefCount) {
-                    buffer2._glBuffers[CONTEXT_UID].refCount++;
+                    buffer._glBuffers[CONTEXT_UID].refCount++;
                 }
             }
             this.activateVao(geometry, program);
             vaoObjectHash[program.id] = vao;
             vaoObjectHash[signature] = vao;
             gl2.bindVertexArray(null);
             bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);
@@ -351369,19 +359037,19 @@
             const attributes2 = geometry.attributes;
             if (geometry.indexBuffer) {
                 bufferSystem.bind(geometry.indexBuffer);
             }
             let lastBuffer = null;
             for (const j2 in attributes2) {
                 const attribute = attributes2[j2];
-                const buffer2 = buffers[attribute.buffer];
-                const glBuffer = buffer2._glBuffers[CONTEXT_UID];
+                const buffer = buffers[attribute.buffer];
+                const glBuffer = buffer._glBuffers[CONTEXT_UID];
                 if (program.attributeData[j2]) {
                     if (lastBuffer !== glBuffer) {
-                        bufferSystem.bind(buffer2);
+                        bufferSystem.bind(buffer);
                         lastBuffer = glBuffer;
                     }
                     const location2 = program.attributeData[j2].location;
                     gl2.enableVertexAttribArray(location2);
                     gl2.vertexAttribPointer(location2, attribute.size, attribute.type || gl2.FLOAT, attribute.normalized, attribute.stride, attribute.start);
                     if (attribute.instance) {
                         if (this.hasInstance) {
@@ -351389,35 +359057,35 @@
                         } else {
                             throw new Error("geometry error, GPU Instancing is not supported on this device");
                         }
                     }
                 }
             }
         }
-        draw(type2, size, start2, instanceCount) {
+        draw(type2, size2, start2, instanceCount) {
             const {
                 gl: gl2
             } = this;
             const geometry = this._activeGeometry;
             if (geometry.indexBuffer) {
                 const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
                 const glType = byteSize === 2 ? gl2.UNSIGNED_SHORT : gl2.UNSIGNED_INT;
                 if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
                     if (geometry.instanced) {
-                        gl2.drawElementsInstanced(type2, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize, instanceCount || 1);
+                        gl2.drawElementsInstanced(type2, size2 || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize, instanceCount || 1);
                     } else {
-                        gl2.drawElements(type2, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize);
+                        gl2.drawElements(type2, size2 || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize);
                     }
                 } else {
                     console.warn("unsupported index buffer type: uint32");
                 }
             } else if (geometry.instanced) {
-                gl2.drawArraysInstanced(type2, start2, size || geometry.getSize(), instanceCount || 1);
+                gl2.drawArraysInstanced(type2, start2, size2 || geometry.getSize(), instanceCount || 1);
             } else {
-                gl2.drawArrays(type2, start2, size || geometry.getSize());
+                gl2.drawArrays(type2, start2, size2 || geometry.getSize());
             }
             return this;
         }
         unbind() {
             this.gl.bindVertexArray(null);
             this._activeVao = null;
             this._activeGeometry = null;
@@ -352329,16 +359997,16 @@
                 value: defaultValue(data2.type, data2.size)
             };
         }
         const glProgram = new GLProgram(webGLProgram, uniformData);
         return glProgram;
     }
 
-    function uboUpdate(_ud, _uv, _renderer, _syncData, buffer2) {
-        _renderer.buffer.update(buffer2);
+    function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
+        _renderer.buffer.update(buffer);
     }
     const UBO_TO_SINGLE_SETTERS = {
         float: `
         data[offset] = v;
     `,
         vec2: `
         data[offset] = v[0];
@@ -352408,38 +360076,38 @@
     function createUBOElements(uniformData) {
         const uboElements = uniformData.map((data2) => ({
             data: data2,
             offset: 0,
             dataLen: 0,
             dirty: 0
         }));
-        let size = 0;
+        let size2 = 0;
         let chunkSize = 0;
         let offset2 = 0;
         for (let i2 = 0; i2 < uboElements.length; i2++) {
             const uboElement = uboElements[i2];
-            size = GLSL_TO_STD40_SIZE[uboElement.data.type];
+            size2 = GLSL_TO_STD40_SIZE[uboElement.data.type];
             if (uboElement.data.size > 1) {
-                size = Math.max(size, 16) * uboElement.data.size;
+                size2 = Math.max(size2, 16) * uboElement.data.size;
             }
-            uboElement.dataLen = size;
-            if (chunkSize % size !== 0 && chunkSize < 16) {
-                const lineUpValue = chunkSize % size % 16;
+            uboElement.dataLen = size2;
+            if (chunkSize % size2 !== 0 && chunkSize < 16) {
+                const lineUpValue = chunkSize % size2 % 16;
                 chunkSize += lineUpValue;
                 offset2 += lineUpValue;
             }
-            if (chunkSize + size > 16) {
+            if (chunkSize + size2 > 16) {
                 offset2 = Math.ceil(offset2 / 16) * 16;
                 uboElement.offset = offset2;
-                offset2 += size;
-                chunkSize = size;
+                offset2 += size2;
+                chunkSize = size2;
             } else {
                 uboElement.offset = offset2;
-                chunkSize += size;
-                offset2 += size;
+                chunkSize += size2;
+                offset2 += size2;
             }
         }
         offset2 = Math.ceil(offset2 / 16) * 16;
         return {
             uboElements,
             size: offset2
         };
@@ -352462,15 +360130,15 @@
                 size: 0,
                 syncFunc: uboUpdate
             };
         }
         const usedUniformDatas = getUBOData(group.uniforms, uniformData);
         const {
             uboElements,
-            size
+            size: size2
         } = createUBOElements(usedUniformDatas);
         const funcFragments = [`
     var v = null;
     var v2 = null;
     var cv = null;
     var t = 0;
     var gl = renderer.gl
@@ -352488,17 +360156,17 @@
                     funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j2].codeUbo(uboElement.data.name, uniform));
                     parsed = true;
                     break;
                 }
             }
             if (!parsed) {
                 if (uboElement.data.size > 1) {
-                    const size2 = mapSize(uboElement.data.type);
+                    const size22 = mapSize(uboElement.data.type);
                     const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
-                    const elementSize = size2 / rowSize;
+                    const elementSize = size22 / rowSize;
                     const remainder = (4 - elementSize % 4) % 4;
                     funcFragments.push(`
                 cv = ud.${name2}.value;
                 v = uv.${name2};
                 offset = ${uboElement.offset / 4};
 
                 t = 0;
@@ -352524,15 +360192,15 @@
                 }
             }
         }
         funcFragments.push(`
        renderer.buffer.update(buffer);
     `);
         return {
-            size,
+            size: size2,
             syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
         };
     }
     let UID = 0;
     const defaultSyncData = {
         textureCount: 0,
         uboCount: 0
@@ -353390,40 +361058,40 @@
                 renderer: renderer2,
                 CONTEXT_UID
             } = this;
             const glTransformFeedback = gl2.createTransformFeedback();
             tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
             gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, glTransformFeedback);
             for (let i2 = 0; i2 < tf.buffers.length; i2++) {
-                const buffer2 = tf.buffers[i2];
-                if (!buffer2)
+                const buffer = tf.buffers[i2];
+                if (!buffer)
                     continue;
-                renderer2.buffer.update(buffer2);
-                buffer2._glBuffers[CONTEXT_UID].refCount++;
-                gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, i2, buffer2._glBuffers[CONTEXT_UID].buffer || null);
+                renderer2.buffer.update(buffer);
+                buffer._glBuffers[CONTEXT_UID].refCount++;
+                gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, i2, buffer._glBuffers[CONTEXT_UID].buffer || null);
             }
             gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, null);
             tf.disposeRunner.add(this);
             return glTransformFeedback;
         }
         disposeTransformFeedback(tf, contextLost) {
             const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
             const gl2 = this.gl;
             tf.disposeRunner.remove(this);
             const bufferSystem = this.renderer.buffer;
             if (bufferSystem) {
                 for (let i2 = 0; i2 < tf.buffers.length; i2++) {
-                    const buffer2 = tf.buffers[i2];
-                    if (!buffer2)
+                    const buffer = tf.buffers[i2];
+                    if (!buffer)
                         continue;
-                    const buf = buffer2._glBuffers[this.CONTEXT_UID];
+                    const buf = buffer._glBuffers[this.CONTEXT_UID];
                     if (buf) {
                         buf.refCount--;
                         if (buf.refCount === 0 && !contextLost) {
-                            bufferSystem.dispose(buffer2, contextLost);
+                            bufferSystem.dispose(buffer, contextLost);
                         }
                     }
                 }
             }
             if (!glTF) {
                 return;
             }
@@ -353980,16 +361648,16 @@
     }
     MultisampleSystem.extension = {
         type: ExtensionType.RendererSystem,
         name: "_multisample"
     };
     extensions$2.add(MultisampleSystem);
     class GLBuffer {
-        constructor(buffer2) {
-            this.buffer = buffer2 || null;
+        constructor(buffer) {
+            this.buffer = buffer || null;
             this.updateID = -1;
             this.byteLength = -1;
             this.refCount = 0;
         }
     }
     class BufferSystem {
         constructor(renderer2) {
@@ -354001,98 +361669,98 @@
             this.renderer = null;
         }
         contextChange() {
             this.disposeAll(true);
             this.gl = this.renderer.gl;
             this.CONTEXT_UID = this.renderer.CONTEXT_UID;
         }
-        bind(buffer2) {
+        bind(buffer) {
             const {
                 gl: gl2,
                 CONTEXT_UID
             } = this;
-            const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
-            gl2.bindBuffer(buffer2.type, glBuffer.buffer);
+            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
+            gl2.bindBuffer(buffer.type, glBuffer.buffer);
         }
         unbind(type2) {
             const {
                 gl: gl2
             } = this;
             gl2.bindBuffer(type2, null);
         }
-        bindBufferBase(buffer2, index2) {
+        bindBufferBase(buffer, index2) {
             const {
                 gl: gl2,
                 CONTEXT_UID
             } = this;
-            if (this.boundBufferBases[index2] !== buffer2) {
-                const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
-                this.boundBufferBases[index2] = buffer2;
+            if (this.boundBufferBases[index2] !== buffer) {
+                const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
+                this.boundBufferBases[index2] = buffer;
                 gl2.bindBufferBase(gl2.UNIFORM_BUFFER, index2, glBuffer.buffer);
             }
         }
-        bindBufferRange(buffer2, index2, offset2) {
+        bindBufferRange(buffer, index2, offset2) {
             const {
                 gl: gl2,
                 CONTEXT_UID
             } = this;
             offset2 = offset2 || 0;
-            const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
+            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
             gl2.bindBufferRange(gl2.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset2 * 256, 256);
         }
-        update(buffer2) {
+        update(buffer) {
             const {
                 gl: gl2,
                 CONTEXT_UID
             } = this;
-            const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
-            if (buffer2._updateID === glBuffer.updateID) {
+            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
+            if (buffer._updateID === glBuffer.updateID) {
                 return;
             }
-            glBuffer.updateID = buffer2._updateID;
-            gl2.bindBuffer(buffer2.type, glBuffer.buffer);
-            if (glBuffer.byteLength >= buffer2.data.byteLength) {
-                gl2.bufferSubData(buffer2.type, 0, buffer2.data);
+            glBuffer.updateID = buffer._updateID;
+            gl2.bindBuffer(buffer.type, glBuffer.buffer);
+            if (glBuffer.byteLength >= buffer.data.byteLength) {
+                gl2.bufferSubData(buffer.type, 0, buffer.data);
             } else {
-                const drawType = buffer2.static ? gl2.STATIC_DRAW : gl2.DYNAMIC_DRAW;
-                glBuffer.byteLength = buffer2.data.byteLength;
-                gl2.bufferData(buffer2.type, buffer2.data, drawType);
+                const drawType = buffer.static ? gl2.STATIC_DRAW : gl2.DYNAMIC_DRAW;
+                glBuffer.byteLength = buffer.data.byteLength;
+                gl2.bufferData(buffer.type, buffer.data, drawType);
             }
         }
-        dispose(buffer2, contextLost) {
-            if (!this.managedBuffers[buffer2.id]) {
+        dispose(buffer, contextLost) {
+            if (!this.managedBuffers[buffer.id]) {
                 return;
             }
-            delete this.managedBuffers[buffer2.id];
-            const glBuffer = buffer2._glBuffers[this.CONTEXT_UID];
+            delete this.managedBuffers[buffer.id];
+            const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
             const gl2 = this.gl;
-            buffer2.disposeRunner.remove(this);
+            buffer.disposeRunner.remove(this);
             if (!glBuffer) {
                 return;
             }
             if (!contextLost) {
                 gl2.deleteBuffer(glBuffer.buffer);
             }
-            delete buffer2._glBuffers[this.CONTEXT_UID];
+            delete buffer._glBuffers[this.CONTEXT_UID];
         }
         disposeAll(contextLost) {
             const all2 = Object.keys(this.managedBuffers);
             for (let i2 = 0; i2 < all2.length; i2++) {
                 this.dispose(this.managedBuffers[all2[i2]], contextLost);
             }
         }
-        createGLBuffer(buffer2) {
+        createGLBuffer(buffer) {
             const {
                 CONTEXT_UID,
                 gl: gl2
             } = this;
-            buffer2._glBuffers[CONTEXT_UID] = new GLBuffer(gl2.createBuffer());
-            this.managedBuffers[buffer2.id] = buffer2;
-            buffer2.disposeRunner.add(this);
-            return buffer2._glBuffers[CONTEXT_UID];
+            buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl2.createBuffer());
+            this.managedBuffers[buffer.id] = buffer;
+            buffer.disposeRunner.add(this);
+            return buffer._glBuffers[CONTEXT_UID];
         }
     }
     BufferSystem.extension = {
         type: ExtensionType.RendererSystem,
         name: "buffer"
     };
     extensions$2.add(BufferSystem);
@@ -354708,20 +362376,20 @@
                 canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
                 this._resolve();
                 this._resolve = null;
             };
         }
         static getSize(svgString) {
             const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
-            const size = {};
+            const size2 = {};
             if (sizeMatch) {
-                size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
-                size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
+                size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
+                size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
             }
-            return size;
+            return size2;
         }
         dispose() {
             super.dispose();
             this._resolve = null;
             this._crossorigin = null;
         }
         static test(source, extension2) {
@@ -362408,28 +370076,28 @@
             } else if (format2 >= 36196) {
                 return "etc1";
             } else if (format2 >= 35986 && format2 <= 34798) {
                 return "atc";
             }
             throw new Error("Invalid (compressed) texture format given!");
         }
-        static _createLevelBuffers(buffer2, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
+        static _createLevelBuffers(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
             const buffers = new Array(levels);
-            let offset2 = buffer2.byteOffset;
+            let offset2 = buffer.byteOffset;
             let levelWidth = imageWidth;
             let levelHeight = imageHeight;
             let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
             let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
             let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
             for (let i2 = 0; i2 < levels; i2++) {
                 buffers[i2] = {
                     levelID: i2,
                     levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
                     levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
-                    levelBuffer: new Uint8Array(buffer2.buffer, offset2, levelSize)
+                    levelBuffer: new Uint8Array(buffer.buffer, offset2, levelSize)
                 };
                 offset2 += levelSize;
                 levelWidth = levelWidth >> 1 || 1;
                 levelHeight = levelHeight >> 1 || 1;
                 alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
                 alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
                 levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
@@ -362556,15 +370224,15 @@
                 }
                 let imageOffset = dataOffset;
                 for (let i2 = 0; i2 < arraySize; i2++) {
                     imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
                     imageOffset += imageSize;
                 }
             }
-            return imageBuffers.map((buffer2) => new CompressedTextureResource(buffer2, {
+            return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
                 format: internalFormat,
                 width,
                 height,
                 levels: mipmapCount
             }));
         }
         if (formatFlags & DDPF_RGB) {
@@ -362701,27 +370369,27 @@
             alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
             alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
             mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
         }
         if (glType !== 0) {
             return {
                 uncompressed: imageBuffers.map((levelBuffers) => {
-                    let buffer2 = levelBuffers[0].levelBuffer;
+                    let buffer = levelBuffers[0].levelBuffer;
                     let convertToInt2 = false;
                     if (glType === TYPES$1.FLOAT) {
-                        buffer2 = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
+                        buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
                     } else if (glType === TYPES$1.UNSIGNED_INT) {
                         convertToInt2 = true;
-                        buffer2 = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
+                        buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
                     } else if (glType === TYPES$1.INT) {
                         convertToInt2 = true;
-                        buffer2 = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
+                        buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
                     }
                     return {
-                        resource: new BufferResource(buffer2, {
+                        resource: new BufferResource(buffer, {
                             width: levelBuffers[0].levelWidth,
                             height: levelBuffers[0].levelHeight
                         }),
                         type: glType,
                         format: convertToInt2 ? convertFormatToInteger(glFormat) : glFormat
                     };
                 }),
@@ -362986,31 +370654,31 @@
             const renderer2 = this.renderer;
             if (!renderer2) {
                 throw new Error("The Extract has already been destroyed");
             }
             let resolution;
             let flipY = false;
             let renderTexture;
-            let generated2 = false;
+            let generated = false;
             if (target) {
                 if (target instanceof RenderTexture) {
                     renderTexture = target;
                 } else {
                     renderTexture = renderer2.generateTexture(target, {
                         resolution: renderer2.resolution,
                         multisample: renderer2.multisample
                     });
-                    generated2 = true;
+                    generated = true;
                 }
             }
             if (renderTexture) {
                 resolution = renderTexture.baseTexture.resolution;
                 frame2 = frame2 != null ? frame2 : renderTexture.frame;
                 flipY = false;
-                if (!generated2) {
+                if (!generated) {
                     renderer2.renderTexture.bind(renderTexture);
                     const fbo = renderTexture.framebuffer.glFramebuffers[renderer2.CONTEXT_UID];
                     if (fbo.blitFramebuffer) {
                         renderer2.framebuffer.bind(fbo.blitFramebuffer);
                     }
                 }
             } else {
@@ -363024,15 +370692,15 @@
                 renderer2.renderTexture.bind();
             }
             const width = Math.round(frame2.width * resolution);
             const height = Math.round(frame2.height * resolution);
             const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
             const gl2 = renderer2.gl;
             gl2.readPixels(Math.round(frame2.x * resolution), Math.round(frame2.y * resolution), width, height, gl2.RGBA, gl2.UNSIGNED_BYTE, pixels);
-            if (generated2) {
+            if (generated) {
                 renderTexture == null ? void 0 : renderTexture.destroy(true);
             }
             return {
                 pixels,
                 width,
                 height,
                 flipY
@@ -363995,28 +371663,28 @@
                     const attribIndex = this.points.length / 2;
                     nextTexture.wrapMode = WRAP_MODES.REPEAT;
                     if (j2 === 0) {
                         this.processFill(data2);
                     } else {
                         this.processLine(data2);
                     }
-                    const size = this.points.length / 2 - attribIndex;
-                    if (size === 0)
+                    const size2 = this.points.length / 2 - attribIndex;
+                    if (size2 === 0)
                         continue;
                     if (batchPart && !this._compareStyles(currentStyle, style2)) {
                         batchPart.end(index22, attribIndex);
                         batchPart = null;
                     }
                     if (!batchPart) {
                         batchPart = BATCH_POOL$1.pop() || new BatchPart$1();
                         batchPart.begin(style2, index22, attribIndex);
                         this.batches.push(batchPart);
                         currentStyle = style2;
                     }
-                    this.addUvs(this.points, uvs, style2.texture, attribIndex, size, style2.matrix);
+                    this.addUvs(this.points, uvs, style2.texture, attribIndex, size2, style2.matrix);
                 }
             }
             const index2 = this.indices.length;
             const attrib = this.points.length / 2;
             if (batchPart) {
                 batchPart.end(index2, attrib);
             }
@@ -364218,52 +371886,52 @@
             for (let i2 = 0; i2 < points.length / 2; i2++) {
                 const x2 = points[i2 * 2];
                 const y2 = points[i2 * 2 + 1];
                 points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
                 points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
             }
         }
-        addColors(colors2, color2, alpha, size, offset2 = 0) {
+        addColors(colors2, color2, alpha, size2, offset2 = 0) {
             const bgr = Color.shared.setValue(color2).toLittleEndianNumber();
             const result = Color.shared.setValue(bgr).toPremultiplied(alpha);
-            colors2.length = Math.max(colors2.length, offset2 + size);
-            for (let i2 = 0; i2 < size; i2++) {
+            colors2.length = Math.max(colors2.length, offset2 + size2);
+            for (let i2 = 0; i2 < size2; i2++) {
                 colors2[offset2 + i2] = result;
             }
         }
-        addTextureIds(textureIds, id2, size, offset2 = 0) {
-            textureIds.length = Math.max(textureIds.length, offset2 + size);
-            for (let i2 = 0; i2 < size; i2++) {
+        addTextureIds(textureIds, id2, size2, offset2 = 0) {
+            textureIds.length = Math.max(textureIds.length, offset2 + size2);
+            for (let i2 = 0; i2 < size2; i2++) {
                 textureIds[offset2 + i2] = id2;
             }
         }
-        addUvs(verts2, uvs, texture, start2, size, matrix = null) {
+        addUvs(verts2, uvs, texture, start2, size2, matrix = null) {
             let index2 = 0;
             const uvsStart = uvs.length;
             const frame2 = texture.frame;
-            while (index2 < size) {
+            while (index2 < size2) {
                 let x2 = verts2[(start2 + index2) * 2];
                 let y2 = verts2[(start2 + index2) * 2 + 1];
                 if (matrix) {
                     const nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
                     y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
                     x2 = nx;
                 }
                 index2++;
                 uvs.push(x2 / frame2.width, y2 / frame2.height);
             }
             const baseTexture = texture.baseTexture;
             if (frame2.width < baseTexture.width || frame2.height < baseTexture.height) {
-                this.adjustUvs(uvs, texture, uvsStart, size);
+                this.adjustUvs(uvs, texture, uvsStart, size2);
             }
         }
-        adjustUvs(uvs, texture, start2, size) {
+        adjustUvs(uvs, texture, start2, size2) {
             const baseTexture = texture.baseTexture;
             const eps = 1e-6;
-            const finish = start2 + size * 2;
+            const finish = start2 + size2 * 2;
             const frame2 = texture.frame;
             const scaleX = frame2.width / baseTexture.width;
             const scaleY = frame2.height / baseTexture.height;
             let offsetX = frame2.x / frame2.width;
             let offsetY = frame2.y / frame2.height;
             let minX = Math.floor(uvs[start2] + eps);
             let minY = Math.floor(uvs[start2 + 1] + eps);
@@ -364714,22 +372382,22 @@
                 this._renderDrawCallDirect(renderer2, geometry.drawCalls[i2]);
             }
         }
         _renderDrawCallDirect(renderer2, drawCall) {
             const {
                 texArray,
                 type: type2,
-                size,
+                size: size2,
                 start: start2
             } = drawCall;
             const groupTextureCount = texArray.count;
             for (let j2 = 0; j2 < groupTextureCount; j2++) {
                 renderer2.texture.bind(texArray.elements[j2], j2);
             }
-            renderer2.geometry.draw(type2, size, start2);
+            renderer2.geometry.draw(type2, size2, start2);
         }
         _resolveDirectShader(renderer2) {
             let shader = this.shader;
             const pluginName = this.pluginName;
             if (!shader) {
                 if (!DEFAULT_SHADERS$1[pluginName]) {
                     const {
@@ -365178,18 +372846,18 @@
             }
             if (this.uvMatrix.update()) {
                 this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
             }
         }
     }
     class ParticleBuffer {
-        constructor(properties, dynamicPropertyFlags, size) {
+        constructor(properties, dynamicPropertyFlags, size2) {
             this.geometry = new Geometry();
             this.indexBuffer = null;
-            this.size = size;
+            this.size = size2;
             this.dynamicProperties = [];
             this.staticProperties = [];
             for (let i2 = 0; i2 < properties.length; ++i2) {
                 let property = properties[i2];
                 property = {
                     attributeName: property.attributeName,
                     size: property.size,
@@ -365347,32 +373015,32 @@
                 let amount = totalChildren - i2;
                 if (amount > batchSize) {
                     amount = batchSize;
                 }
                 if (j2 >= buffers.length) {
                     buffers.push(this._generateOneMoreBuffer(container));
                 }
-                const buffer2 = buffers[j2];
-                buffer2.uploadDynamic(children2, i2, amount);
+                const buffer = buffers[j2];
+                buffer.uploadDynamic(children2, i2, amount);
                 const bid = container._bufferUpdateIDs[j2] || 0;
-                updateStatic = updateStatic || buffer2._updateID < bid;
+                updateStatic = updateStatic || buffer._updateID < bid;
                 if (updateStatic) {
-                    buffer2._updateID = container._updateID;
-                    buffer2.uploadStatic(children2, i2, amount);
+                    buffer._updateID = container._updateID;
+                    buffer.uploadStatic(children2, i2, amount);
                 }
-                renderer2.geometry.bind(buffer2.geometry);
+                renderer2.geometry.bind(buffer.geometry);
                 gl2.drawElements(gl2.TRIANGLES, amount * 6, gl2.UNSIGNED_SHORT, 0);
             }
         }
         generateBuffers(container) {
             const buffers = [];
-            const size = container._maxSize;
+            const size2 = container._maxSize;
             const batchSize = container._batchSize;
             const dynamicPropertyFlags = container._properties;
-            for (let i2 = 0; i2 < size; i2 += batchSize) {
+            for (let i2 = 0; i2 < size2; i2 += batchSize) {
                 buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
             }
             return buffers;
         }
         _generateOneMoreBuffer(container) {
             const batchSize = container._batchSize;
             const dynamicPropertyFlags = container._properties;
@@ -368131,27 +375799,27 @@
             if (this._autoResolution && this._resolution !== renderer2.resolution) {
                 this._resolution = renderer2.resolution;
                 this.dirty = true;
             }
             const {
                 distanceFieldRange,
                 distanceFieldType,
-                size
+                size: size2
             } = BitmapFont.available[this._fontName];
             if (distanceFieldType !== "none") {
                 const {
                     a: a2,
                     b: b2,
                     c: c2,
                     d: d2
                 } = this.worldTransform;
                 const dx = Math.sqrt(a2 * a2 + b2 * b2);
                 const dy = Math.sqrt(c2 * c2 + d2 * d2);
                 const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
-                const fontScale = this.fontSize / size;
+                const fontScale = this.fontSize / size2;
                 const resolution = renderer2._view.resolution;
                 for (const mesh of this._activePagesMeshData) {
                     mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
                 }
             }
             super._render(renderer2);
         }
@@ -368888,20 +376556,20 @@
     HTMLText.defaultMaxHeight = 2024;
     HTMLText.defaultAutoResolution = true;
     class GraphLayoutBuilder {
         constructor() {
             this._nodeSize = 64;
             this._nodeFontSize = 16;
         }
-        nodeSize(size) {
-            this._nodeSize = size;
+        nodeSize(size2) {
+            this._nodeSize = size2;
             return this;
         }
-        nodeFontSize(size) {
-            this._nodeFontSize = size;
+        nodeFontSize(size2) {
+            this._nodeFontSize = size2;
             return this;
         }
     }
     class GraphLayout {
         constructor(builder) {
             this.nodeSize = builder._nodeSize;
             this.nodeFontSize = builder._nodeFontSize;
@@ -374336,16 +382004,16 @@
         if (graph.size === 0)
             return [];
         if (type2 === "mixed" || type2 === graph.type) {
             if (typeof Array.from === "function")
                 return Array.from(graph._edges.keys());
             return take(graph._edges.keys(), graph._edges.size);
         }
-        const size = type2 === "undirected" ? graph.undirectedSize : graph.directedSize;
-        const list2 = new Array(size),
+        const size2 = type2 === "undirected" ? graph.undirectedSize : graph.directedSize;
+        const list2 = new Array(size2),
             mask = type2 === "undirected";
         const iterator2 = graph._edges.values();
         let i2 = 0;
         let step2, data2;
         while (step2 = iterator2.next(), step2.done !== true) {
             data2 = step2.value;
             if (data2.undirected === mask)
@@ -378374,15 +386042,15 @@
     var PPN$3 = 10;
     var PPE$1 = 3;
     var PPR = 9;
     var MAX_FORCE = 10;
     var iterate$3 = function iterate2(options, NodeMatrix, EdgeMatrix) {
         var l2, r2, n2, n1, n22, rn2, e3, w2, g2, s2;
         var order2 = NodeMatrix.length,
-            size = EdgeMatrix.length;
+            size2 = EdgeMatrix.length;
         var adjustSizes = options.adjustSizes;
         var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;
         var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;
         var RegionMatrix = [];
         for (n2 = 0; n2 < order2; n2 += PPN$3) {
             NodeMatrix[n2 + NODE_OLD_DX] = NodeMatrix[n2 + NODE_DX];
             NodeMatrix[n2 + NODE_OLD_DY] = NodeMatrix[n2 + NODE_DY];
@@ -378666,15 +386334,15 @@
                 if (distance > 0)
                     factor = coefficient * NodeMatrix[n2 + NODE_MASS] * g2 / distance;
             }
             NodeMatrix[n2 + NODE_DX] -= xDist * factor;
             NodeMatrix[n2 + NODE_DY] -= yDist * factor;
         }
         coefficient = 1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);
-        for (e3 = 0; e3 < size; e3 += PPE$1) {
+        for (e3 = 0; e3 < size2; e3 += PPE$1) {
             n1 = EdgeMatrix[e3 + EDGE_SOURCE];
             n22 = EdgeMatrix[e3 + EDGE_TARGET];
             w2 = EdgeMatrix[e3 + EDGE_WEIGHT];
             ewc = Math.pow(w2, options.edgeWeightInfluence);
             xDist = NodeMatrix[n1 + NODE_X$1] - NodeMatrix[n22 + NODE_X$1];
             yDist = NodeMatrix[n1 + NODE_Y$1] - NodeMatrix[n22 + NODE_Y$1];
             if (adjustSizes === true) {
@@ -378833,19 +386501,19 @@
             return {
                 message: "the `barnesHutTheta` setting should be a number >= 0."
             };
         return null;
     };
     helpers$3.graphToByteArrays = function(graph, getEdgeWeight) {
         var order2 = graph.order;
-        var size = graph.size;
+        var size2 = graph.size;
         var index2 = {};
         var j2;
         var NodeMatrix = new Float32Array(order2 * PPN$2);
-        var EdgeMatrix = new Float32Array(size * PPE);
+        var EdgeMatrix = new Float32Array(size2 * PPE);
         j2 = 0;
         graph.forEachNode(function(node2, attr) {
             index2[node2] = j2;
             NodeMatrix[j2] = attr.x;
             NodeMatrix[j2 + 1] = attr.y;
             NodeMatrix[j2 + 2] = 0;
             NodeMatrix[j2 + 3] = 0;
@@ -379011,32 +386679,32 @@
     }
     var iterate$1 = function iterate2(options, NodeMatrix) {
         var margin = options.margin;
         var ratio = options.ratio;
         var expansion = options.expansion;
         var gridSize = options.gridSize;
         var speed = options.speed;
-        var i2, j2, x2, y2, l2, size;
+        var i2, j2, x2, y2, l2, size2;
         var converged = true;
         var length = NodeMatrix.length;
         var order2 = length / PPN$1 | 0;
         var deltaX = new Float32Array(order2);
         var deltaY = new Float32Array(order2);
         var xMin = Infinity;
         var yMin = Infinity;
         var xMax = -Infinity;
         var yMax = -Infinity;
         for (i2 = 0; i2 < length; i2 += PPN$1) {
             x2 = NodeMatrix[i2 + NODE_X];
             y2 = NodeMatrix[i2 + NODE_Y];
-            size = NodeMatrix[i2 + NODE_SIZE] * ratio + margin;
-            xMin = Math.min(xMin, x2 - size);
-            xMax = Math.max(xMax, x2 + size);
-            yMin = Math.min(yMin, y2 - size);
-            yMax = Math.max(yMax, y2 + size);
+            size2 = NodeMatrix[i2 + NODE_SIZE] * ratio + margin;
+            xMin = Math.min(xMin, x2 - size2);
+            xMax = Math.max(xMax, x2 + size2);
+            yMin = Math.min(yMin, y2 - size2);
+            yMax = Math.max(yMax, y2 + size2);
         }
         var width = xMax - xMin;
         var height = yMax - yMin;
         var xCenter = (xMin + xMax) / 2;
         var yCenter = (yMin + yMax) / 2;
         xMin = xCenter - expansion * width / 2;
         xMax = xCenter + expansion * width / 2;
@@ -379049,19 +386717,19 @@
             grid[c2] = [];
         var nxMin, nxMax, nyMin, nyMax;
         var xMinBox, xMaxBox, yMinBox, yMaxBox;
         var col, row;
         for (i2 = 0; i2 < length; i2 += PPN$1) {
             x2 = NodeMatrix[i2 + NODE_X];
             y2 = NodeMatrix[i2 + NODE_Y];
-            size = NodeMatrix[i2 + NODE_SIZE] * ratio + margin;
-            nxMin = x2 - size;
-            nxMax = x2 + size;
-            nyMin = y2 - size;
-            nyMax = y2 + size;
+            size2 = NodeMatrix[i2 + NODE_SIZE] * ratio + margin;
+            nxMin = x2 - size2;
+            nxMax = x2 + size2;
+            nyMin = y2 - size2;
+            nyMax = y2 + size2;
             xMinBox = Math.floor(gridSize * (nxMin - xMin) / (xMax - xMin));
             xMaxBox = Math.floor(gridSize * (nxMax - xMin) / (xMax - xMin));
             yMinBox = Math.floor(gridSize * (nyMin - yMin) / (yMax - yMin));
             yMaxBox = Math.floor(gridSize * (nyMax - yMin) / (yMax - yMin));
             for (col = xMinBox; col <= xMaxBox; col++) {
                 for (row = yMinBox; row <= yMaxBox; row++) {
                     grid[col * gridSize + row].push(i2);
@@ -379300,31 +386968,31 @@
             this.outboundAttractionDistribution = builder._outboundAttractionDistribution;
             this.scalingRatio = builder._scalingRatio;
             this.strongGravityMode = builder._strongGravityMode;
         }
         applyLayout(graph) {
             const firstNodeAttrs = graph.getNodeAttributes(graph.nodes()[0]);
             const graphClone = graph.copy();
-            const size = graphClone.getAttribute("size");
+            const size2 = graphClone.getAttribute("size");
             if (!firstNodeAttrs.x) {
                 const randomMapping = random(graph, {
                     center: 1e3,
                     scale: 2e3
                 });
                 graphClone.updateEachNodeAttributes((n2, attrs2) => Object.assign(Object.assign({}, attrs2), randomMapping[n2]));
                 const noverlapMapping = graphologyLayoutNoverlap(graphClone, {
                     maxIterations: 100,
                     settings: {
-                        margin: size
+                        margin: size2
                     }
                 });
                 graphClone.updateEachNodeAttributes((n2, attrs2) => Object.assign(Object.assign({}, attrs2), noverlapMapping[n2]));
             }
             graphClone.updateEachNodeAttributes((n2, attrs2) => Object.assign(Object.assign({}, attrs2), {
-                size
+                size: size2
             }));
             const newLayout = graphologyLayoutForceatlas2(graphClone, {
                 getEdgeWeight: 1,
                 iterations: this.iterations,
                 settings: {
                     adjustSizes: true,
                     barnesHutOptimize: this.barnesHutOptimize,
@@ -381569,19 +389237,19 @@
         for (var _i22 = 0; _i22 < nodeMap.length; _i22++) {
             if (nodeMap[_i22] === partition2) {
                 nodeMap[_i22] = partition1;
             }
         }
         return newEdges;
     };
-    var contractUntil = function contractUntil2(metaNodeMap, remainingEdges, size, sizeLimit) {
-        while (size > sizeLimit) {
+    var contractUntil = function contractUntil2(metaNodeMap, remainingEdges, size2, sizeLimit) {
+        while (size2 > sizeLimit) {
             var edgeIndex = Math.floor(Math.random() * remainingEdges.length);
             remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
-            size--;
+            size2--;
         }
         return remainingEdges;
     };
     var elesfn$p = {
         kargerStein: function kargerStein() {
             var _this = this;
             var _this$byGroup = this.byGroup(),
@@ -385923,57 +393591,57 @@
         }
         return true;
     };
     var toString = function toString2() {
         if (this.toStringCache != null) {
             return this.toStringCache;
         }
-        var clean2 = function clean3(obj) {
+        var clean = function clean2(obj) {
             if (obj == null) {
                 return "";
             } else {
                 return obj;
             }
         };
         var cleanVal = function cleanVal2(val) {
             if (string(val)) {
                 return '"' + val + '"';
             } else {
-                return clean2(val);
+                return clean(val);
             }
         };
         var space2 = function space3(val) {
             return " " + val + " ";
         };
         var checkToString = function checkToString2(check, subject) {
             var type2 = check.type,
                 value = check.value;
             switch (type2) {
                 case Type.GROUP: {
-                    var group = clean2(value);
+                    var group = clean(value);
                     return group.substring(0, group.length - 1);
                 }
                 case Type.DATA_COMPARE: {
                     var field = check.field,
                         operator2 = check.operator;
-                    return "[" + field + space2(clean2(operator2)) + cleanVal(value) + "]";
+                    return "[" + field + space2(clean(operator2)) + cleanVal(value) + "]";
                 }
                 case Type.DATA_BOOL: {
                     var _operator = check.operator,
                         _field = check.field;
-                    return "[" + clean2(_operator) + _field + "]";
+                    return "[" + clean(_operator) + _field + "]";
                 }
                 case Type.DATA_EXIST: {
                     var _field2 = check.field;
                     return "[" + _field2 + "]";
                 }
                 case Type.META_COMPARE: {
                     var _operator2 = check.operator,
                         _field3 = check.field;
-                    return "[[" + _field3 + space2(clean2(_operator2)) + cleanVal(value) + "]]";
+                    return "[[" + _field3 + space2(clean(_operator2)) + cleanVal(value) + "]]";
                 }
                 case Type.STATE: {
                     return value;
                 }
                 case Type.ID: {
                     return "#" + value;
                 }
@@ -388689,15 +396357,15 @@
                 end2 = thisSize + end2;
             }
             for (var i2 = start2; i2 >= 0 && i2 < end2 && i2 < thisSize; i2++) {
                 array2.push(this[i2]);
             }
             return this.spawn(array2);
         },
-        size: function size() {
+        size: function size2() {
             return this.length;
         },
         eq: function eq2(i2) {
             return this[i2] || this.spawn();
         },
         first: function first() {
             return this[0] || this.spawn();
@@ -394509,15 +402177,15 @@
                 zoom: 1
             });
             return this;
         },
         invalidateSize: function invalidateSize() {
             this._private.sizeCache = null;
         },
-        size: function size() {
+        size: function size2() {
             var _p = this._private;
             var container = _p.container;
             var cy = this;
             return _p.sizeCache = _p.sizeCache || (container ? function() {
                 var style2 = cy.window().getComputedStyle(container);
                 var val = function val2(name2) {
                     return parseFloat(style2.getPropertyValue(name2));
@@ -396643,40 +404311,40 @@
         jpg: throwImgErr
     };
     var BRp$f = {};
     BRp$f.arrowShapeWidth = 0.3;
     BRp$f.registerArrowShapes = function() {
         var arrowShapes = this.arrowShapes = {};
         var renderer2 = this;
-        var bbCollide = function bbCollide2(x2, y2, size, angle, translation, edgeWidth, padding) {
-            var x1 = translation.x - size / 2 - padding;
-            var x22 = translation.x + size / 2 + padding;
-            var y1 = translation.y - size / 2 - padding;
-            var y22 = translation.y + size / 2 + padding;
+        var bbCollide = function bbCollide2(x2, y2, size2, angle, translation, edgeWidth, padding) {
+            var x1 = translation.x - size2 / 2 - padding;
+            var x22 = translation.x + size2 / 2 + padding;
+            var y1 = translation.y - size2 / 2 - padding;
+            var y22 = translation.y + size2 / 2 + padding;
             var inside2 = x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
             return inside2;
         };
-        var transform = function transform2(x2, y2, size, angle, translation) {
+        var transform = function transform2(x2, y2, size2, angle, translation) {
             var xRotated = x2 * Math.cos(angle) - y2 * Math.sin(angle);
             var yRotated = x2 * Math.sin(angle) + y2 * Math.cos(angle);
-            var xScaled = xRotated * size;
-            var yScaled = yRotated * size;
+            var xScaled = xRotated * size2;
+            var yScaled = yRotated * size2;
             var xTranslated = xScaled + translation.x;
             var yTranslated = yScaled + translation.y;
             return {
                 x: xTranslated,
                 y: yTranslated
             };
         };
-        var transformPoints = function transformPoints2(pts2, size, angle, translation) {
+        var transformPoints = function transformPoints2(pts2, size2, angle, translation) {
             var retPts = [];
             for (var i2 = 0; i2 < pts2.length; i2 += 2) {
                 var x2 = pts2[i2];
                 var y2 = pts2[i2 + 1];
-                retPts.push(transform(x2, y2, size, angle, translation));
+                retPts.push(transform(x2, y2, size2, angle, translation));
             }
             return retPts;
         };
         var pointsToArr = function pointsToArr2(pts2) {
             var ret = [];
             for (var i2 = 0; i2 < pts2.length; i2++) {
                 var p2 = pts2[i2];
@@ -396690,22 +404358,22 @@
         var defineArrowShape = function defineArrowShape2(name2, defn) {
             if (string(defn)) {
                 defn = arrowShapes[defn];
             }
             arrowShapes[name2] = extend({
                 name: name2,
                 points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
-                collide: function collide2(x2, y2, size, angle, translation, padding) {
-                    var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
+                collide: function collide2(x2, y2, size2, angle, translation, padding) {
+                    var points = pointsToArr(transformPoints(this.points, size2 + 2 * padding, angle, translation));
                     var inside2 = pointInsidePolygonPoints(x2, y2, points);
                     return inside2;
                 },
                 roughCollide: bbCollide,
-                draw: function draw(context2, size, angle, translation) {
-                    var points = transformPoints(this.points, size, angle, translation);
+                draw: function draw(context2, size2, angle, translation) {
+                    var points = transformPoints(this.points, size2, angle, translation);
                     renderer2.arrowShapeImpl("polygon")(context2, points);
                 },
                 spacing: function spacing(edge) {
                     return 0;
                 },
                 gap: standardGap
             }, defn);
@@ -396721,51 +404389,51 @@
             points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
         });
         defineArrowShape("arrow", "triangle");
         defineArrowShape("triangle-backcurve", {
             points: arrowShapes["triangle"].points,
             controlPoint: [0, -0.15],
             roughCollide: bbCollide,
-            draw: function draw(context2, size, angle, translation, edgeWidth) {
-                var ptsTrans = transformPoints(this.points, size, angle, translation);
+            draw: function draw(context2, size2, angle, translation, edgeWidth) {
+                var ptsTrans = transformPoints(this.points, size2, angle, translation);
                 var ctrlPt = this.controlPoint;
-                var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
+                var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size2, angle, translation);
                 renderer2.arrowShapeImpl(this.name)(context2, ptsTrans, ctrlPtTrans);
             },
             gap: function gap(edge) {
                 return standardGap(edge) * 0.8;
             }
         });
         defineArrowShape("triangle-tee", {
             points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
             pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
-            collide: function collide2(x2, y2, size, angle, translation, edgeWidth, padding) {
-                var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
-                var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
+            collide: function collide2(x2, y2, size2, angle, translation, edgeWidth, padding) {
+                var triPts = pointsToArr(transformPoints(this.points, size2 + 2 * padding, angle, translation));
+                var teePts = pointsToArr(transformPoints(this.pointsTee, size2 + 2 * padding, angle, translation));
                 var inside2 = pointInsidePolygonPoints(x2, y2, triPts) || pointInsidePolygonPoints(x2, y2, teePts);
                 return inside2;
             },
-            draw: function draw(context2, size, angle, translation, edgeWidth) {
-                var triPts = transformPoints(this.points, size, angle, translation);
-                var teePts = transformPoints(this.pointsTee, size, angle, translation);
+            draw: function draw(context2, size2, angle, translation, edgeWidth) {
+                var triPts = transformPoints(this.points, size2, angle, translation);
+                var teePts = transformPoints(this.pointsTee, size2, angle, translation);
                 renderer2.arrowShapeImpl(this.name)(context2, triPts, teePts);
             }
         });
         defineArrowShape("circle-triangle", {
             radius: 0.15,
             pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
-            collide: function collide2(x2, y2, size, angle, translation, edgeWidth, padding) {
+            collide: function collide2(x2, y2, size2, angle, translation, edgeWidth, padding) {
                 var t2 = translation;
-                var circleInside = Math.pow(t2.x - x2, 2) + Math.pow(t2.y - y2, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
-                var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
+                var circleInside = Math.pow(t2.x - x2, 2) + Math.pow(t2.y - y2, 2) <= Math.pow((size2 + 2 * padding) * this.radius, 2);
+                var triPts = pointsToArr(transformPoints(this.points, size2 + 2 * padding, angle, translation));
                 return pointInsidePolygonPoints(x2, y2, triPts) || circleInside;
             },
-            draw: function draw(context2, size, angle, translation, edgeWidth) {
-                var triPts = transformPoints(this.pointsTr, size, angle, translation);
-                renderer2.arrowShapeImpl(this.name)(context2, triPts, translation.x, translation.y, this.radius * size);
+            draw: function draw(context2, size2, angle, translation, edgeWidth) {
+                var triPts = transformPoints(this.pointsTr, size2, angle, translation);
+                renderer2.arrowShapeImpl(this.name)(context2, triPts, translation.x, translation.y, this.radius * size2);
             },
             spacing: function spacing(edge) {
                 return renderer2.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.radius;
             }
         });
         defineArrowShape("triangle-cross", {
             points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
@@ -396775,50 +404443,50 @@
                 -0.15,
                 -0.4,
                 0.15,
                 -0.4,
                 0.15,
                 -0.4
             ],
-            crossLinePts: function crossLinePts(size, edgeWidth) {
+            crossLinePts: function crossLinePts(size2, edgeWidth) {
                 var p2 = this.baseCrossLinePts.slice();
-                var shiftFactor = edgeWidth / size;
+                var shiftFactor = edgeWidth / size2;
                 var y0 = 3;
                 var y1 = 5;
                 p2[y0] = p2[y0] - shiftFactor;
                 p2[y1] = p2[y1] - shiftFactor;
                 return p2;
             },
-            collide: function collide2(x2, y2, size, angle, translation, edgeWidth, padding) {
-                var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
-                var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
+            collide: function collide2(x2, y2, size2, angle, translation, edgeWidth, padding) {
+                var triPts = pointsToArr(transformPoints(this.points, size2 + 2 * padding, angle, translation));
+                var teePts = pointsToArr(transformPoints(this.crossLinePts(size2, edgeWidth), size2 + 2 * padding, angle, translation));
                 var inside2 = pointInsidePolygonPoints(x2, y2, triPts) || pointInsidePolygonPoints(x2, y2, teePts);
                 return inside2;
             },
-            draw: function draw(context2, size, angle, translation, edgeWidth) {
-                var triPts = transformPoints(this.points, size, angle, translation);
-                var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
+            draw: function draw(context2, size2, angle, translation, edgeWidth) {
+                var triPts = transformPoints(this.points, size2, angle, translation);
+                var crossLinePts = transformPoints(this.crossLinePts(size2, edgeWidth), size2, angle, translation);
                 renderer2.arrowShapeImpl(this.name)(context2, triPts, crossLinePts);
             }
         });
         defineArrowShape("vee", {
             points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
             gap: function gap(edge) {
                 return standardGap(edge) * 0.525;
             }
         });
         defineArrowShape("circle", {
             radius: 0.15,
-            collide: function collide2(x2, y2, size, angle, translation, edgeWidth, padding) {
+            collide: function collide2(x2, y2, size2, angle, translation, edgeWidth, padding) {
                 var t2 = translation;
-                var inside2 = Math.pow(t2.x - x2, 2) + Math.pow(t2.y - y2, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
+                var inside2 = Math.pow(t2.x - x2, 2) + Math.pow(t2.y - y2, 2) <= Math.pow((size2 + 2 * padding) * this.radius, 2);
                 return inside2;
             },
-            draw: function draw(context2, size, angle, translation, edgeWidth) {
-                renderer2.arrowShapeImpl(this.name)(context2, translation.x, translation.y, this.radius * size);
+            draw: function draw(context2, size2, angle, translation, edgeWidth) {
+                renderer2.arrowShapeImpl(this.name)(context2, translation.x, translation.y, this.radius * size2);
             },
             spacing: function spacing(edge) {
                 return renderer2.getArrowWidth(edge.pstyle("width").pfValue, edge.pstyle("arrow-scale").value) * this.radius;
             }
         });
         defineArrowShape("tee", {
             points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
@@ -398704,15 +406372,15 @@
         var cache2 = r2.labelDimCache || (r2.labelDimCache = []);
         var existingVal = cache2[cacheKey];
         if (existingVal != null) {
             return existingVal;
         }
         var padding = 0;
         var fStyle = ele.pstyle("font-style").strValue;
-        var size = ele.pstyle("font-size").pfValue;
+        var size2 = ele.pstyle("font-size").pfValue;
         var family = ele.pstyle("font-family").strValue;
         var weight = ele.pstyle("font-weight").strValue;
         var canvas = this.labelCalcCanvas;
         var c2d = this.labelCalcCanvasContext;
         if (!canvas) {
             canvas = this.labelCalcCanvas = document.createElement("canvas");
             c2d = this.labelCalcCanvasContext = canvas.getContext("2d");
@@ -398720,23 +406388,23 @@
             ds.position = "absolute";
             ds.left = "-9999px";
             ds.top = "-9999px";
             ds.zIndex = "-1";
             ds.visibility = "hidden";
             ds.pointerEvents = "none";
         }
-        c2d.font = "".concat(fStyle, " ").concat(weight, " ").concat(size, "px ").concat(family);
+        c2d.font = "".concat(fStyle, " ").concat(weight, " ").concat(size2, "px ").concat(family);
         var width = 0;
         var height = 0;
         var lines = text2.split("\n");
         for (var i2 = 0; i2 < lines.length; i2++) {
             var line = lines[i2];
             var metrics = c2d.measureText(line);
             var w2 = Math.ceil(metrics.width);
-            var h2 = size;
+            var h2 = size2;
             width = Math.max(w2, width);
             height += h2;
         }
         width += padding;
         height += padding;
         return cache2[cacheKey] = {
             width,
@@ -402901,15 +410569,15 @@
         var path2;
         var canvasContext = context2;
         var translation = {
             x: x2,
             y: y2
         };
         var scale = edge.pstyle("arrow-scale").value;
-        var size = this.getArrowWidth(edgeWidth, scale);
+        var size2 = this.getArrowWidth(edgeWidth, scale);
         var shapeImpl = r2.arrowShapes[shape];
         if (usePaths) {
             var cache2 = r2.arrowPathCache = r2.arrowPathCache || [];
             var key = hashString(shape);
             var cachedPath = cache2[key];
             if (cachedPath != null) {
                 path2 = context2 = cachedPath;
@@ -402925,44 +410593,44 @@
             }
             if (usePaths) {
                 shapeImpl.draw(context2, 1, 0, {
                     x: 0,
                     y: 0
                 }, 1);
             } else {
-                shapeImpl.draw(context2, size, angle, translation, edgeWidth);
+                shapeImpl.draw(context2, size2, angle, translation, edgeWidth);
             }
             if (context2.closePath) {
                 context2.closePath();
             }
         }
         context2 = canvasContext;
         if (usePaths) {
             context2.translate(x2, y2);
             context2.rotate(angle);
-            context2.scale(size, size);
+            context2.scale(size2, size2);
         }
         if (fill === "filled" || fill === "both") {
             if (usePaths) {
                 context2.fill(path2);
             } else {
                 context2.fill();
             }
         }
         if (fill === "hollow" || fill === "both") {
-            context2.lineWidth = shapeWidth / (usePaths ? size : 1);
+            context2.lineWidth = shapeWidth / (usePaths ? size2 : 1);
             context2.lineJoin = "miter";
             if (usePaths) {
                 context2.stroke(path2);
             } else {
                 context2.stroke();
             }
         }
         if (usePaths) {
-            context2.scale(1 / size, 1 / size);
+            context2.scale(1 / size2, 1 / size2);
             context2.rotate(-angle);
             context2.translate(-x2, -y2);
         }
     };
     var CRp$7 = {};
     CRp$7.safeDrawImage = function(context2, img, ix, iy, iw, ih, x2, y2, w2, h2) {
         if (iw <= 0 || ih <= 0 || w2 <= 0 || h2 <= 0) {
@@ -403829,25 +411497,25 @@
         }
         if (pieSize.units === "%") {
             radius = radius * pieSize.pfValue;
         } else if (pieSize.pfValue !== void 0) {
             radius = pieSize.pfValue / 2;
         }
         for (var i2 = 1; i2 <= cyStyle.pieBackgroundN; i2++) {
-            var size = node2.pstyle("pie-" + i2 + "-background-size").value;
+            var size2 = node2.pstyle("pie-" + i2 + "-background-size").value;
             var color2 = node2.pstyle("pie-" + i2 + "-background-color").value;
             var opacity = node2.pstyle("pie-" + i2 + "-background-opacity").value * nodeOpacity;
-            var percent = size / 100;
+            var percent = size2 / 100;
             if (percent + lastPercent > 1) {
                 percent = 1 - lastPercent;
             }
             var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent;
             var angleDelta = 2 * Math.PI * percent;
             var angleEnd = angleStart + angleDelta;
-            if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
+            if (size2 === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
                 continue;
             }
             context2.beginPath();
             context2.moveTo(x2, y2);
             context2.arc(x2, y2, radius, angleStart, angleEnd);
             context2.closePath();
             this.colorFillStyle(context2, color2[0], color2[1], color2[2], opacity);
@@ -404511,18 +412179,18 @@
                 }
             }
         }
         context2.closePath();
     };
     var CRp$2 = {};
     CRp$2.createBuffer = function(w2, h2) {
-        var buffer2 = document.createElement("canvas");
-        buffer2.width = w2;
-        buffer2.height = h2;
-        return [buffer2, buffer2.getContext("2d")];
+        var buffer = document.createElement("canvas");
+        buffer.width = w2;
+        buffer.height = h2;
+        return [buffer, buffer.getContext("2d")];
     };
     CRp$2.bufferCanvasImage = function(options) {
         var cy = this.cy;
         var eles = cy.mutableElements();
         var bb = eles.boundingBox();
         var ctrRect = this.findContainerClientCoords();
         var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
@@ -405460,28 +413128,28 @@
                         var LGraphObject = __webpack_require__(2);
                         var Integer = __webpack_require__(10);
                         var RectangleD = __webpack_require__(13);
                         var LayoutConstants = __webpack_require__(0);
                         var RandomSeed = __webpack_require__(16);
                         var PointD = __webpack_require__(5);
 
-                        function LNode(gm, loc, size, vNode) {
-                            if (size == null && vNode == null) {
+                        function LNode(gm, loc, size2, vNode) {
+                            if (size2 == null && vNode == null) {
                                 vNode = loc;
                             }
                             LGraphObject.call(this, vNode);
                             if (gm.graphManager != null)
                                 gm = gm.graphManager;
                             this.estimatedSize = Integer.MIN_VALUE;
                             this.inclusionTreeDepth = Integer.MAX_VALUE;
                             this.vGraphObject = vNode;
                             this.edges = [];
                             this.graphManager = gm;
-                            if (size != null && loc != null)
-                                this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);
+                            if (size2 != null && loc != null)
+                                this.rect = new RectangleD(loc.x, loc.y, size2.width, size2.height);
                             else
                                 this.rect = new RectangleD();
                         }
                         LNode.prototype = Object.create(LGraphObject.prototype);
                         for (var prop in LGraphObject) {
                             LNode[prop] = LGraphObject[prop];
                         }
@@ -406062,25 +413730,25 @@
                         LGraph.prototype.getEstimatedSize = function() {
                             if (this.estimatedSize == Integer.MIN_VALUE) {
                                 throw "assert failed";
                             }
                             return this.estimatedSize;
                         };
                         LGraph.prototype.calcEstimatedSize = function() {
-                            var size = 0;
+                            var size2 = 0;
                             var nodes = this.nodes;
                             var s2 = nodes.length;
                             for (var i2 = 0; i2 < s2; i2++) {
                                 var lNode = nodes[i2];
-                                size += lNode.calcEstimatedSize();
+                                size2 += lNode.calcEstimatedSize();
                             }
-                            if (size == 0) {
+                            if (size2 == 0) {
                                 this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;
                             } else {
-                                this.estimatedSize = size / Math.sqrt(this.nodes.length);
+                                this.estimatedSize = size2 / Math.sqrt(this.nodes.length);
                             }
                             return this.estimatedSize;
                         };
                         LGraph.prototype.updateConnected = function() {
                             var self2 = this;
                             if (this.nodes.length == 0) {
                                 this.isConnected = true;
@@ -406095,16 +413763,16 @@
                             childrenOfNode.forEach(function(node2) {
                                 queue.push(node2);
                                 visited.add(node2);
                             });
                             while (queue.length !== 0) {
                                 currentNode = queue.shift();
                                 neighborEdges = currentNode.getEdges();
-                                var size = neighborEdges.length;
-                                for (var i2 = 0; i2 < size; i2++) {
+                                var size2 = neighborEdges.length;
+                                for (var i2 = 0; i2 < size2; i2++) {
                                     var neighborEdge = neighborEdges[i2];
                                     currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);
                                     if (currentNeighbor != null && !visited.has(currentNeighbor)) {
                                         var childrenOfNeighbor = currentNeighbor.withChildren();
                                         childrenOfNeighbor.forEach(function(node2) {
                                             queue.push(node2);
                                             visited.add(node2);
@@ -406909,15 +414577,15 @@
                                     vals.forEach(function(v2) {
                                         return _this.push(v2);
                                     });
                                 }
                             }
                             _createClass2(LinkedList2, [{
                                 key: "size",
-                                value: function size() {
+                                value: function size2() {
                                     return this.length;
                                 }
                             }, {
                                 key: "insertBefore",
                                 value: function insertBefore2(val, otherNode) {
                                     return add2(otherNode.prev, nodeFrom(val), otherNode, this);
                                 }
@@ -408031,16 +415699,16 @@
                         }
                         module3.exports = FDLayoutEdge;
                     },
                     function(module3, exports4, __webpack_require__) {
                         var LNode = __webpack_require__(3);
                         var FDLayoutConstants = __webpack_require__(4);
 
-                        function FDLayoutNode(gm, loc, size, vNode) {
-                            LNode.call(this, gm, loc, size, vNode);
+                        function FDLayoutNode(gm, loc, size2, vNode) {
+                            LNode.call(this, gm, loc, size2, vNode);
                             this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;
                             this.springForceX = 0;
                             this.springForceY = 0;
                             this.repulsionForceX = 0;
                             this.repulsionForceY = 0;
                             this.gravitationForceX = 0;
                             this.gravitationForceY = 0;
@@ -409738,17 +417406,17 @@
                                     }
                                 }
                             };
                             CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {
                                 var nodeList = [];
                                 var graph;
                                 var graphs = this.graphManager.getGraphs();
-                                var size = graphs.length;
+                                var size2 = graphs.length;
                                 var i2;
-                                for (i2 = 0; i2 < size; i2++) {
+                                for (i2 = 0; i2 < size2; i2++) {
                                     graph = graphs[i2];
                                     graph.updateConnected();
                                     if (!graph.isConnected) {
                                         nodeList = nodeList.concat(graph.getNodes());
                                     }
                                 }
                                 return nodeList;
@@ -410563,16 +418231,16 @@
                             };
                             module3.exports = CoSELayout;
                         },
                         991: (module3, __unused_webpack_exports, __webpack_require__2) => {
                             var FDLayoutNode = __webpack_require__2(551).FDLayoutNode;
                             var IMath = __webpack_require__2(551).IMath;
 
-                            function CoSENode(gm, loc, size, vNode) {
-                                FDLayoutNode.call(this, gm, loc, size, vNode);
+                            function CoSENode(gm, loc, size2, vNode) {
+                                FDLayoutNode.call(this, gm, loc, size2, vNode);
                             }
                             CoSENode.prototype = Object.create(FDLayoutNode.prototype);
                             for (var prop in FDLayoutNode) {
                                 CoSENode[prop] = FDLayoutNode[prop];
                             }
                             CoSENode.prototype.calculateDisplacement = function() {
                                 var layout2 = this.graphManager.getLayout();
@@ -411923,16 +419591,16 @@
                                     return opt(ele);
                                 } else {
                                     return opt;
                                 }
                             };
                             var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);
                             var processChildrenList = function processChildrenList2(parent, children2, layout2, options2) {
-                                var size = children2.length;
-                                for (var i2 = 0; i2 < size; i2++) {
+                                var size2 = children2.length;
+                                for (var i2 = 0; i2 < size2; i2++) {
                                     var theChild = children2[i2];
                                     var children_of_children = null;
                                     if (theChild.intersection(parentsWithoutChildren).length == 0) {
                                         children_of_children = theChild.children();
                                     }
                                     var theNode = void 0;
                                     var dimensions2 = theChild.layoutDimensions({
@@ -413032,24 +420700,24 @@
         }
         get requiresPosition() {
             return false;
         }
         applyLayout(graph) {
             return new Promise((resolve2) => {
                 const hasPositions = graph.getNodeAttribute(graph.nodes()[0], "x");
-                const size = graph.getAttribute("size");
+                const size2 = graph.getAttribute("size");
                 const tiersPlacement = this.tiers ? getTieredLayoutProperties(graph, this.tiers, this.orientation, this.tierSeparation) : {
                     alignmentConstraint: void 0,
                     relativePlacementConstraint: void 0
                 };
                 const elements = [
                     ...graph.mapNodes((id2, attrs2) => ({
                         data: Object.assign(Object.assign({}, attrs2), {
-                            height: size,
-                            width: size
+                            height: size2,
+                            width: size2
                         }),
                         group: "nodes",
                         position: {
                             x: attrs2.x,
                             y: attrs2.y
                         }
                     })),
@@ -413069,15 +420737,15 @@
                             horizontal: this.orientation === "vertical" ? tiersPlacement.alignmentConstraint : void 0,
                             vertical: this.orientation === "horizontal" ? tiersPlacement.alignmentConstraint : void 0
                         },
                         animate: false,
                         edgeElasticity: this.edgeElasticity,
                         gravity: this.gravity,
                         gravityRange: this.gravityRange,
-                        idealEdgeLength: size * this.edgeLength,
+                        idealEdgeLength: size2 * this.edgeLength,
                         initialEnergyOnIncremental: this.energy,
                         name: "fcose",
                         nodeRepulsion: this.nodeRepulsion,
                         nodeSeparation: this.nodeSeparation,
                         numIters: this.iterations,
                         quality: this.highQuality ? "proof" : "default",
                         randomize: !hasPositions,
@@ -413091,17 +420759,17 @@
                             });
                         },
                         uniformNodeDimensions: true
                     },
                     style: [{
                         selector: "node",
                         style: {
-                            height: size * 2,
+                            height: size2 * 2,
                             shape: "ellipse",
-                            width: size * 2
+                            width: size2 * 2
                         }
                     }],
                     styleEnabled: true
                 });
             });
         }
         static get Builder() {
@@ -414607,22 +422275,22 @@
             }
             const {
                 strideFloats,
                 packer,
                 buildData,
                 batches
             } = this;
-            const buffer2 = this._buffer;
+            const buffer = this._buffer;
             const index2 = this._indexBuffer;
             const floatsSize = vertexSize * strideFloats;
-            if (buffer2.data.length !== floatsSize) {
+            if (buffer.data.length !== floatsSize) {
                 const arrBuf = new ArrayBuffer(floatsSize * 4);
                 this._bufferFloats = new Float32Array(arrBuf);
                 this._bufferUint = new Uint32Array(arrBuf);
-                buffer2.data = this._bufferFloats;
+                buffer.data = this._bufferFloats;
             }
             if (index2.data.length !== indexSize) {
                 if (vertexSize > 65535 && this.pack32index) {
                     index2.data = new Uint32Array(indexSize);
                 } else {
                     index2.data = new Uint16Array(indexSize);
                 }
@@ -414652,15 +422320,15 @@
                         data2.strokeLen,
                         data2.triangles,
                         batches[j2].styleId,
                         batches[j2].rgba
                     );
                 }
             }
-            buffer2.update();
+            buffer.update();
             index2.update();
             this.packSize = vertexSize;
         }
         _compareStyles(styleA, styleB) {
             if (!styleA || !styleB) {
                 return false;
             }
@@ -415785,15 +423453,15 @@
                             shader.uniforms.tint[3] = uniforms.tint[3];
                         }
                     }
                 }
                 const {
                     texArray,
                     styleArray,
-                    size,
+                    size: size2,
                     start: start2
                 } = drawCall;
                 const groupTextureCount = texArray.count;
                 const shaderHere = shader || directShader;
                 const texs = shaderHere.uniforms.styleTextureId;
                 const mats = shaderHere.uniforms.styleMatrix;
                 const lines = shaderHere.uniforms.styleLine;
@@ -415817,15 +423485,15 @@
                 renderer2.shader.bind(shaderHere);
                 if (shaderChange) {
                     renderer2.geometry.bind(geometry);
                 }
                 for (let j2 = 0; j2 < groupTextureCount; j2++) {
                     renderer2.texture.bind(texArray.elements[j2], j2);
                 }
-                renderer2.geometry.draw(DRAW_MODES.TRIANGLES, size, start2);
+                renderer2.geometry.draw(DRAW_MODES.TRIANGLES, size2, start2);
             }
         }
         _resolveDirectShader(_renderer) {
             let shader = this.shader;
             const pluginName = this.pluginName;
             if (!shader) {
                 if (!DEFAULT_SHADERS[pluginName]) {
@@ -416384,21 +424052,21 @@
         var root2 = _root;
         var freeExports = exports3 && !exports3.nodeType && exports3;
         var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
         var moduleExports = freeModule && freeModule.exports === freeExports;
         var Buffer2 = moduleExports ? root2.Buffer : void 0,
             allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
 
-        function cloneBuffer2(buffer2, isDeep) {
+        function cloneBuffer2(buffer, isDeep) {
             if (isDeep) {
-                return buffer2.slice();
+                return buffer.slice();
             }
-            var length = buffer2.length,
-                result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
-            buffer2.copy(result);
+            var length = buffer.length,
+                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
+            buffer.copy(result);
             return result;
         }
         module2.exports = cloneBuffer2;
     })(_cloneBuffer, _cloneBuffer.exports);
     var copyObject$1 = _copyObject,
         getSymbols$1 = _getSymbols;
 
@@ -416458,16 +424126,16 @@
         new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
         return result;
     }
     var _cloneArrayBuffer = cloneArrayBuffer$3;
     var cloneArrayBuffer$2 = _cloneArrayBuffer;
 
     function cloneDataView$1(dataView, isDeep) {
-        var buffer2 = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
-        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
+        var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
+        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
     }
     var _cloneDataView = cloneDataView$1;
     var reFlags = /\w*$/;
 
     function cloneRegExp$1(regexp) {
         var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
         result.lastIndex = regexp.lastIndex;
@@ -416481,16 +424149,16 @@
     function cloneSymbol$1(symbol) {
         return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
     }
     var _cloneSymbol = cloneSymbol$1;
     var cloneArrayBuffer$1 = _cloneArrayBuffer;
 
     function cloneTypedArray$1(typedArray, isDeep) {
-        var buffer2 = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
-        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
+        var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
+        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
     }
     var _cloneTypedArray = cloneTypedArray$1;
     var cloneArrayBuffer = _cloneArrayBuffer,
         cloneDataView = _cloneDataView,
         cloneRegExp = _cloneRegExp,
         cloneSymbol = _cloneSymbol,
         cloneTypedArray = _cloneTypedArray;
@@ -416596,15 +424264,15 @@
         getAllKeys = _getAllKeys,
         getAllKeysIn = _getAllKeysIn,
         getTag = _getTag,
         initCloneArray = _initCloneArray,
         initCloneByTag = _initCloneByTag,
         initCloneObject = _initCloneObject,
         isArray = isArray_1,
-        isBuffer = isBuffer$5.exports,
+        isBuffer = isBuffer$4.exports,
         isMap = isMap_1,
         isObject$1 = isObject_1,
         isSet = isSet_1,
         keys = keys_1,
         keysIn = keysIn_1;
     var CLONE_DEEP_FLAG$1 = 1,
         CLONE_FLAT_FLAG = 2,
@@ -419134,24 +426802,24 @@
             }
             [edgeLineSprite.tint] = colorToPixi(edgeStyle.color);
             if (edgeStyle.state.hover || edgeStyle.state.selected) {
                 edgeLineSprite.alpha = 1;
             } else {
                 edgeLineSprite.alpha = (_d = (_c = edgeStyle.strength) === null || _c === void 0 ? void 0 : _c.opacity) !== null && _d !== void 0 ? _d : 0.5;
             }
-            const buffer2 = 6;
+            const buffer = 6;
             const yOffset = edgeLineSprite.height / 2;
             edgeGfx.hitArea.points = [
-                edgeLineSprite.position.x - buffer2,
+                edgeLineSprite.position.x - buffer,
                 edgeLineSprite.position.y - yOffset,
-                edgeLineSprite.position.x - buffer2,
+                edgeLineSprite.position.x - buffer,
                 edgeLineSprite.position.y + yOffset,
-                edgeLineSprite.position.x + buffer2,
+                edgeLineSprite.position.x + buffer,
                 edgeLineSprite.position.y + yOffset,
-                edgeLineSprite.position.x + buffer2,
+                edgeLineSprite.position.x + buffer,
                 edgeLineSprite.position.y - yOffset
             ];
             if (edgeStyle.isEdgeSelected && !edgeStyle.state.selected && !edgeStyle.state.hover) {
                 edgeLineSprite.alpha = 0.3;
             }
         }
         static updateEdgeSymbolsStyle(edgeGfx, edgeSymbolsGfx, edgeStyle, textureCache) {
@@ -419391,22 +427059,22 @@
         light: {
             shadowHover: "rgba(0, 0, 0, 0.5)",
             shadowNormal: "rgba(0, 0, 0, 0.25)"
         }
     };
     const FONT_FAMILY = "Manrope";
 
-    function getTextStyle(size) {
+    function getTextStyle(size2) {
         return new TextStyle({
             align: "center",
             fill: 16777215,
             fontFamily: FONT_FAMILY,
-            fontSize: size,
+            fontSize: size2,
             fontWeight: "normal",
-            lineHeight: 1.2 * size,
+            lineHeight: 1.2 * size2,
             whiteSpace: "normal",
             wordWrap: true
         });
     }
 
     function trimToFit(text2, maxSize, textStyle) {
         const {
@@ -419473,17 +427141,17 @@
             case "latent":
                 return [theme2.colors.blue1, theme2.colors.text];
             default:
                 return [theme2.colors.blue4, theme2.colors.text];
         }
     }
 
-    function getNodeSize(size, group) {
+    function getNodeSize(size2, group) {
         const sizeMultiplier = group === "target" ? 1.25 : 1;
-        return size * sizeMultiplier;
+        return size2 * sizeMultiplier;
     }
     const NODE_CIRCLE = "NODE_CIRCLE";
     const NODE_BORDER = "NODE_BORDER";
     const NODE_LABEL = "NODE_LABEL";
     class NodeObject extends EventEmitter$1 {
         constructor() {
             super();
@@ -419813,19 +427481,23 @@
             const minY = Math.min(...nodesY);
             const maxY = Math.max(...nodesY);
             const graphWidth = Math.abs(maxX - minX);
             const graphHeight = Math.abs(maxY - minY);
             const graphCenter = new Point$1(minX + graphWidth / 2, minY + graphHeight / 2);
             const worldWidth = graphWidth + WORLD_PADDING * 2;
             const worldHeight = graphHeight + WORLD_PADDING * 2;
-            this.viewport.resize(this.container.clientWidth, this.container.clientHeight, worldWidth, worldHeight);
-            this.viewport.setZoom(1);
-            this.viewport.center = graphCenter;
-            this.viewport.fit(true);
-            this.updateGraphVisibility();
+            try {
+                this.viewport.resize(this.container.clientWidth, this.container.clientHeight, worldWidth, worldHeight);
+                this.viewport.setZoom(1);
+                this.viewport.center = graphCenter;
+                this.viewport.fit(true);
+                this.updateGraphVisibility();
+            } catch (err) {
+                console.error("Error resetting viewport", err);
+            }
         }
         searchNodes(ids) {
             const newNodes = ids.filter((newId2) => !this.searchResults.includes(newId2));
             const removedNodes = this.searchResults.filter((oldId) => !ids.includes(oldId));
             for (const nodeId of newNodes) {
                 const node2 = this.nodeMap.get(nodeId);
                 if (node2) {
@@ -420376,15 +428048,15 @@
                 const edge = this.edgeMap.get(edgeKey);
                 if (edge) {
                     edge.updateVisibility(zoomState, edgeAttributes.points !== void 0);
                     this.updateEdgeStyleByKey(edgeKey);
                 }
             });
         }
-        updateLayout() {
+        updateLayout(retry = false) {
             var _a3;
             return __awaiter(this, void 0, void 0, function*() {
                 (_a3 = this.onCleanup) === null || _a3 === void 0 ? void 0 : _a3.call(this);
                 try {
                     const {
                         layout: layout2,
                         edgePoints: edgePoints2,
@@ -420399,33 +428071,37 @@
                     this.onAddEdge = onAddEdge;
                     this.onStartDrag = onStartDrag;
                     this.onEndDrag = onEndDrag;
                     this.onCleanup = onCleanup;
                     this.onMove = onMove;
                     this.setLayout(layout2, edgePoints2);
                 } catch (e3) {
+                    if (retry) {
+                        console.error("Layout failed even after retrying", e3);
+                        return;
+                    }
                     console.error(e3);
                     this.errorHandler({
                         key: "LayoutError",
                         message: e3.message,
-                        status: Status.WARNING,
+                        status: Status$1.WARNING,
                         title: "Defaulting to Fcose Layout"
                     });
                     let tiers;
                     let orientation;
                     if (isGraphLayoutWithTiers(this.layout)) {
                         tiers = this.layout.tiers;
                         orientation = this.layout.orientation;
                     }
                     this.layout = FcoseLayout.Builder.nodeSize(this.layout.nodeSize).nodeFontSize(this.layout.nodeFontSize).build();
                     if (tiers !== void 0) {
                         this.layout.tiers = tiers;
                         this.layout.orientation = orientation;
                     }
-                    this.updateLayout();
+                    this.updateLayout(true);
                 }
             });
         }
         updateNodeStyle(id2, attributes2) {
             const node2 = this.nodeMap.get(id2);
             if (node2) {
                 const nodePosition = {
@@ -420464,15 +428140,15 @@
         editorMode,
         constraints,
         errorHandler,
         processEdgeStyle,
         zoomThresholds,
         requireFocusToZoom
     }) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const engine = React__namespace.useRef(null);
         const listeners = React__namespace.useRef({});
         if (!engine.current) {
             engine.current = new Engine(graph, layout2, editable2, editorMode, theme2, constraints, zoomThresholds, errorHandler, processEdgeStyle, requireFocusToZoom);
         }
         React__namespace.useEffect(() => {
             engine.current.start(parentRef.current).then(() => {
@@ -420723,15 +428399,15 @@
         const draft = Object.assign({}, state);
         switch (action.type) {
             case GraphActionType.ACCEPT_EDGE: {
                 draft.graph.setEdgeAttribute(action.source, action.target, "meta.rendering_properties.accepted", true);
                 break;
             }
             case GraphActionType.ADD_EDGE: {
-                const edgeType = [EditorMode.DEFAULT, EditorMode.RESOLVER].includes(draft.editorMode) ? EdgeType.DIRECTED_EDGE : EdgeType.UNDIRECTED_EDGE;
+                const edgeType = [EditorMode.DEFAULT, EditorMode.RESOLVER].includes(state.editorMode) ? EdgeType.DIRECTED_EDGE : EdgeType.UNDIRECTED_EDGE;
                 const attributes2 = {
                     edge_type: edgeType,
                     originalMeta: {}
                 };
                 draft.graph.addEdge(action.source, action.target, attributes2);
                 break;
             }
@@ -420752,14 +428428,15 @@
                     x: action.position.x,
                     y: action.position.y
                 } : {}));
                 break;
             }
             case GraphActionType.INIT_GRAPH: {
                 draft.graph = action.graph;
+                draft.editorMode = action.editorMode;
                 break;
             }
             case GraphActionType.REMOVE_EDGE: {
                 const [source, target] = action.edge;
                 draft.graph.dropEdge(source, target);
                 break;
             }
@@ -420868,19 +428545,21 @@
         updateNode
     };
     const actionNames = Object.keys(GraphActionCreators);
 
     function useCausalGraphEditor(graphData, editorMode, graphLayout, availableInputs) {
         const newNodesRequirePosition = graphLayout.requiresPosition;
         const [state, dispatch2] = React.useReducer(GraphReducer, {
-            editorMode,
             newNodesRequirePosition
         }, (initState) => {
+            const parsedGraph = causalGraphParser(graphData, availableInputs);
+            const newEditorMode = editorMode !== null && editorMode !== void 0 ? editorMode : isDag(parsedGraph) ? EditorMode.DEFAULT : EditorMode.PAG_VIEWER;
             return Object.assign(Object.assign({}, initState), {
-                graph: causalGraphParser(graphData, availableInputs)
+                editorMode: newEditorMode,
+                graph: parsedGraph
             });
         });
         const api2 = React.useMemo(() => {
             return actionNames.reduce((acc, actionName) => {
                 const actionCreator = GraphActionCreators[actionName];
                 acc[actionName] = (...args) => dispatch2(actionCreator.apply(null, args));
                 return acc;
@@ -420900,15 +428579,18 @@
                 };
             }
             return newLayout;
         }, [isTimeSeriesCausalGraph, graphLayout]);
         const lastParentData = React.useRef(graphData);
         React.useEffect(() => {
             if (!isEqual_1(lastParentData.current.nodes, graphData.nodes) || !isEqual_1(lastParentData.current.edges, graphData.edges)) {
+                const parsedGraph = causalGraphParser(graphData, availableInputs, state.graph);
+                const newEditorMode = editorMode !== null && editorMode !== void 0 ? editorMode : isDag(parsedGraph) ? EditorMode.DEFAULT : EditorMode.PAG_VIEWER;
                 dispatch2({
+                    editorMode: newEditorMode,
                     graph: causalGraphParser(graphData, availableInputs, state.graph),
                     type: GraphActionType.INIT_GRAPH
                 });
             }
             lastParentData.current = graphData;
         }, [graphData]);
         return {
@@ -421162,25 +428844,21 @@
 `;
 
     function CausalGraphEditor(_a3) {
         var _b, _c;
         var {
             requireFocusToZoom = true
         } = _a3, props = __rest$1(_a3, ["requireFocusToZoom"]);
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const canvasParentRef = React__namespace.useRef(null);
         const {
             state,
             api: api2,
             layout: layout2
         } = useCausalGraphEditor(props.graphData, props.editorMode, props.graphLayout, props.availableInputs);
-        const [editorMode] = React.useState(() => {
-            var _a4;
-            return (_a4 = props.editorMode) !== null && _a4 !== void 0 ? _a4 : isDag(state.graph) ? EditorMode.DEFAULT : EditorMode.PAG_VIEWER;
-        });
         const [error2, setError] = React.useState(null);
         const handleError = (e3) => {
             setError(e3);
         };
         const {
             getCenterPosition,
             useEngineEvent,
@@ -421191,15 +428869,15 @@
             onEdgeSelected,
             onSearchResults,
             onUpdateConstraints,
             onSetFocus
         } = useRenderEngine({
             constraints: props.initialConstraints,
             editable: props.editable,
-            editorMode,
+            editorMode: state.editorMode,
             errorHandler: handleError,
             graph: state.graph,
             layout: layout2,
             parentRef: canvasParentRef,
             processEdgeStyle: props.processEdgeStyle,
             requireFocusToZoom,
             zoomThresholds: props.zoomThresholds
@@ -421215,15 +428893,15 @@
         }
         const [hasFocus, setHasFocus] = React.useState(false);
 
         function onPaneFocus(focus) {
             setHasFocus(focus);
             onSetFocus(focus);
         }
-        useOnClickOutside(paneRef.current, () => onPaneFocus(false));
+        useOnClickOutside$1(paneRef.current, () => onPaneFocus(false));
         const [selectedEdge, setSelectedEdge] = React.useState(null);
         const [selectedNode, setSelectedNode] = React.useState(null);
         const [highlightedNode, setHighlightedNode] = React.useState();
         useUpdateEffect(() => {
             onNodeSelected(highlightedNode);
         }, [highlightedNode]);
         useUpdateEffect(() => {
@@ -421255,31 +428933,31 @@
             constraints,
             addConstraint,
             updateConstraint,
             removeConstraint,
             reverseConstraint
         } = useEdgeConstraintEncoder(props.initialConstraints, props.onEdgeConstraintsUpdate);
         const selectedConstraint = React.useMemo(() => {
-            if (editorMode === EditorMode.EDGE_ENCODER && selectedEdge) {
+            if (state.editorMode === EditorMode.EDGE_ENCODER && selectedEdge) {
                 const [source, target] = selectedEdge;
                 return constraints.find((c2) => c2.source === source && c2.target === target || c2.source === target && c2.target === source);
             }
-        }, [editorMode, selectedEdge, constraints]);
+        }, [state.editorMode, selectedEdge, constraints]);
 
         function onRemoveNode() {
             api2.removeNode(selectedNode);
             setSelectedNode(null);
         }
 
         function onRemoveConstraint() {
             removeConstraint(selectedConstraint.id);
         }
 
         function onConfirmRemoveEdge() {
-            if (editorMode === EditorMode.EDGE_ENCODER) {
+            if (state.editorMode === EditorMode.EDGE_ENCODER) {
                 onRemoveConstraint();
             }
             api2.removeEdge(selectedEdge);
             setSelectedEdge(null);
         }
         const {
             onConfirmation: askToRemoveEdge,
@@ -421306,20 +428984,20 @@
 
         function onAddEdge(edge) {
             var _a4;
             if (willCreateCycle(state.graph, edge)) {
                 (_a4 = props.onNotify) === null || _a4 === void 0 ? void 0 : _a4.call(props, {
                     key: "create-edge-cycle",
                     message: "Could not create an edge as it would create a cycle",
-                    status: Status.WARNING,
+                    status: Status$1.WARNING,
                     title: "Cycle detected"
                 });
                 return;
             }
-            if (editorMode === EditorMode.EDGE_ENCODER) {
+            if (state.editorMode === EditorMode.EDGE_ENCODER) {
                 const [source, target] = edge;
                 addConstraint(source, target);
             }
             api2.addEdge(edge);
             setSelectedNode(null);
             setSelectedEdge(edge);
         }
@@ -421334,15 +429012,15 @@
             const [source, target] = selectedEdge;
             const graphCopy = state.graph.copy();
             graphCopy.dropEdge(source, target);
             if (willCreateCycle(graphCopy, selectedEdge)) {
                 (_a4 = props.onNotify) === null || _a4 === void 0 ? void 0 : _a4.call(props, {
                     key: "reverse-edge-cycle",
                     message: "Could not reverse the edge as it would create a cycle",
-                    status: Status.WARNING,
+                    status: Status$1.WARNING,
                     title: "Cycle detected"
                 });
                 return;
             }
             api2.reverseEdge(selectedEdge);
             setSelectedEdge([target, source]);
         }
@@ -421351,15 +429029,15 @@
             setSelectedEdge(null);
             reverseConstraint(selectedConstraint);
         }
 
         function confirmDirection(reverse) {
             api2.updateEdgeType(selectedEdge, EdgeType.DIRECTED_EDGE);
             if (reverse) {
-                if (editorMode === EditorMode.EDGE_ENCODER) {
+                if (state.editorMode === EditorMode.EDGE_ENCODER) {
                     onReverseConstraint();
                 }
                 onReverseEdge();
             }
         }
         const tooltipRef = React__namespace.useRef(null);
         const {
@@ -421402,15 +429080,15 @@
             const edgeAttributes = state.graph.getEdgeAttributes(edgeKey);
             const sourceNodeKey = state.graph.source(edgeKey);
             const targetNodeKey = state.graph.target(edgeKey);
             const sourceNodeAttributes = state.graph.getNodeAttributes(sourceNodeKey);
             const targetNodeAttributes = state.graph.getNodeAttributes(targetNodeKey);
             const sourceLabel = (_a4 = sourceNodeAttributes["meta.rendering_properties.label"]) !== null && _a4 !== void 0 ? _a4 : sourceNodeAttributes.id;
             const targetLabel = (_b2 = targetNodeAttributes["meta.rendering_properties.label"]) !== null && _b2 !== void 0 ? _b2 : targetNodeAttributes.id;
-            const tooltipArrow = editorMode === EditorMode.DEFAULT ? "\u279C" : "-";
+            const tooltipArrow = state.editorMode === EditorMode.DEFAULT ? "\u279C" : "-";
             const edgeTooltipContent = getTooltipContent(`${sourceLabel} ${tooltipArrow} ${targetLabel}`, edgeAttributes["meta.rendering_properties.tooltip"], theme2, null, props.tooltipSize);
             tooltipRef.current = () => ({
                 bottom: event2.clientY,
                 height: 0,
                 left: event2.clientX,
                 right: event2.clientX,
                 top: event2.clientY,
@@ -421534,15 +429212,15 @@
             setDragMode
         } = useDragMode(props.editable, !props.disableEdgeAdd, layout2.supportsDrag, onSetDragMode);
         let contentSelected = false;
         let panelTitle = "";
         if (selectedEdge) {
             contentSelected = state.graph.hasEdge(selectedEdge[0], selectedEdge[1]);
             panelTitle = "Edge";
-        } else if (selectedNode && editorMode !== EditorMode.EDGE_ENCODER) {
+        } else if (selectedNode && state.editorMode !== EditorMode.EDGE_ENCODER) {
             contentSelected = state.graph.hasNode(selectedNode);
             panelTitle = "Node";
         }
         if (Object.keys((_c = props.graphData) === null || _c === void 0 ? void 0 : _c.nodes).length === 0) {
             return jsxRuntime.exports.jsx(Wrapper, {
                 style: props.style,
                 children: jsxRuntime.exports.jsx(Center, {
@@ -421557,15 +429235,15 @@
             settings: {
                 allowNodeDrag: layout2.supportsDrag,
                 allowSelectionWhenNotEditable: props.allowSelectionWhenNotEditable,
                 disableEdgeAdd: props.disableEdgeAdd,
                 disableLatentNodeAdd: props.disableLatentNodeAdd,
                 disableNodeRemoval: props.disableNodeRemoval,
                 editable: props.editable,
-                editorMode,
+                editorMode: state.editorMode,
                 onNotify: props.onNotify,
                 verboseDescriptions: props.verboseDescriptions
             },
             children: jsxRuntime.exports.jsx(pointerCtx.Provider, {
                 value: {
                     disablePointerEvents: isDragging,
                     onPanelEnter,
@@ -421577,15 +429255,15 @@
                     ref: paneRef,
                     style: props.style,
                     children: jsxRuntime.exports.jsxs(Graph, {
                         onMouseEnter,
                         onMouseLeave,
                         children: [jsxRuntime.exports.jsx(EditorOverlay, {
                             bottomLeft: jsxRuntime.exports.jsx(Legend, {
-                                listItems: getLegendData(props.defaultLegends, editorMode, props.additionalLegends)
+                                listItems: getLegendData(props.defaultLegends, state.editorMode, props.additionalLegends)
                             }),
                             onDelete,
                             onNext,
                             onPrev,
                             showFrameButtons: !isDragging && (showFrameButtons || hasFocus),
                             title: panelTitle,
                             topCenter: jsxRuntime.exports.jsx(jsxRuntime.exports.Fragment, {
@@ -421649,15 +429327,15 @@
                             })
                         }), jsxRuntime.exports.jsx("div", {
                             ref: canvasParentRef,
                             style: {
                                 height: "100%",
                                 width: "100%"
                             }
-                        }), jsxRuntime.exports.jsx(Tooltip$1, {
+                        }), jsxRuntime.exports.jsx(Tooltip$2, {
                             content: tooltipContent,
                             followCursor: true,
                             getReferenceClientRect: tooltipRef.current,
                             visible: !isInPanel && !!tooltipContent
                         }), jsxRuntime.exports.jsx(ConfirmationModal, Object.assign({
                             title: "Confirm Removal"
                         }, removeEdgeProps))]
@@ -425619,16 +433297,16 @@
         }, {
             key: "beginDrag",
             value: function beginDrag() {
                 return this.item;
             }
         }, {
             key: "isDragging",
-            value: function isDragging(monitor, handle) {
-                return handle === monitor.getSourceId();
+            value: function isDragging(monitor, handle2) {
+                return handle2 === monitor.getSourceId();
             }
         }, {
             key: "endDrag",
             value: function endDrag() {}
         }]);
         return NativeDragSource2;
     }();
@@ -426416,15 +434094,15 @@
                 "data-testid": "divider-button",
                 onClick
             }), jsxRuntime.exports.jsx(DividerButton, {
                 children: jsxRuntime.exports.jsx(Plus, {})
             }), jsxRuntime.exports.jsx(LayerBorder, {})]
         });
     }
-    const StyledInput = styled__default.default(Input$3)`
+    const StyledInput = styled__default.default(Input$5)`
     width: 100%;
 
     input {
         width: 100%;
         padding: 0 0.5rem;
     }
 `;
@@ -426468,15 +434146,15 @@
 `;
 
     function LayerLabelEditor(props) {
         var _a3;
         const [editEnabled, setEditEnabled] = React.useState(false);
         const [label, setLabel] = React.useState(null);
         const ref2 = React.useRef(null);
-        useOnClickOutside(ref2.current, () => setEditEnabled(false));
+        useOnClickOutside$1(ref2.current, () => setEditEnabled(false));
         const debouncedUpdateLabel = React.useMemo(() => debounce_1(props.onChange, 300), [props.onChange]);
 
         function onLabelChange(val) {
             setLabel(val);
             debouncedUpdateLabel(val);
         }
 
@@ -426618,28 +434296,28 @@
     user-select: none;
     overflow: hidden;
     font-size: ${(props) => props.$labelSize ? `${props.$labelSize}px` : props.theme.font.size};
 `;
 
     function Node$1(props) {
         var _a3, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o2, _p;
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [{
             isDragging
         }, dragRef] = useDrag({
             canDrag: !props.viewOnly,
             collect: (monitor) => ({
                 isDragging: !!monitor.isDragging()
             }),
             item: () => Object.assign(Object.assign({}, props.node), {
                 index: props.index
             }),
             type: NODE
         });
-        return jsxRuntime.exports.jsx(Tooltip$1, {
+        return jsxRuntime.exports.jsx(Tooltip$2, {
             content: getTooltipContent((_a3 = props.node) === null || _a3 === void 0 ? void 0 : _a3.name, (_c = (_b = props.node) === null || _b === void 0 ? void 0 : _b.meta) === null || _c === void 0 ? void 0 : _c.tooltip, theme2, (_e2 = (_d = props.node) === null || _d === void 0 ? void 0 : _d.meta) === null || _e2 === void 0 ? void 0 : _e2.label),
             children: jsxRuntime.exports.jsx(NodeCircle, {
                 "$isDragging": isDragging,
                 "$isMatch": props.node.selected,
                 "$nodeSize": props.nodeSize,
                 "$viewOnly": props.viewOnly,
                 ref: dragRef,
@@ -426703,26 +434381,26 @@
     grid-template-columns: ${(props) => `repeat(${props.$nodeNumber}, minmax(0, 1fr))`};
     gap: 0.25rem;
 
     min-width: 0;
     max-width: 85%;
     padding: 2rem 0;
 `;
-    const StyledChevron = styled__default.default(Chevron$2)`
+    const StyledChevron = styled__default.default(Chevron$4)`
     cursor: pointer;
 `;
-    const SmallButton = styled__default.default(Button$3)`
+    const SmallButton = styled__default.default(Button$5)`
     width: 28px;
     min-width: 0;
     height: 28px;
     padding: 0 0.25rem;
 `;
 
     function Layer(props, ref2) {
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [isCollapsed, setIsCollapsed] = React.useState(true);
         const [{
             canDrop,
             isOver
         }, dropRef] = useDrop({
             accept: NODE,
             canDrop: (item) => {
@@ -426950,15 +434628,15 @@
         return jsxRuntime.exports.jsx(DndProvider, {
             backend: HTML5Backend,
             children: jsxRuntime.exports.jsx(BuilderBox, {
                 className: props.className,
                 style: props.style,
                 children: jsxRuntime.exports.jsxs(BuilderWrapper, {
                     children: [jsxRuntime.exports.jsx(SearchWrapper, {
-                        children: jsxRuntime.exports.jsx(Input$3, {
+                        children: jsxRuntime.exports.jsx(Input$5, {
                             onChange: (val) => setSearchInput(val),
                             placeholder: "Search for nodes...",
                             value: searchInput
                         })
                     }), jsxRuntime.exports.jsx(NodesWrapper, {
                         ref: layersWrapperRef,
                         children: hierarchyData.map((layer, idx) => jsxRuntime.exports.jsx(React.Fragment, {
@@ -427140,15 +434818,15 @@
     const StyledGraphViewer = core$2.injectCss(CausalGraphEditor);
 
     function CausalGraphViewer(props) {
         const {
             pushNotification
         } = core$2.Notifications.useNotifications();
         const [style2, css2] = core$2.useComponentStyles(props);
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [graphData, setCausalGraphVariable] = core$2.useVariable(props.causal_graph);
         const [onClickNode] = core$2.useAction(props.on_click_node);
         const [onClickEdge] = core$2.useAction(props.on_click_edge);
         const [onUpdate] = core$2.useAction(props.on_update);
         const graphLayout = React.useMemo(() => parseLayoutDefinition(props.graph_layout), [props.graph_layout]);
         const formattedDefaultLegends = React.useMemo(() => {
             return Object.fromEntries(
@@ -427269,15 +434947,15 @@
     function VisualEdgeEncoder(props) {
         const {
             pushNotification
         } = core$2.Notifications.useNotifications();
         const [style2, css2] = core$2.useComponentStyles(props);
         const [nodes] = core$2.useVariable(props.nodes);
         const parsedNodes = React.useMemo(() => parseNodes(nodes), [nodes]);
-        const theme2 = useClTheme();
+        const theme2 = useClTheme$1();
         const [initialConstraints] = core$2.useVariable(props.initial_constraints);
         const parsedConstraints = React.useMemo(() => parseConstraints(initialConstraints), [initialConstraints]);
         const graphLayout = React.useMemo(() => parseLayoutDefinition(props.graph_layout), []);
         const [onClickEdge] = core$2.useAction(props.on_click_edge);
         const [onClickNode] = core$2.useAction(props.on_click_node);
         const [onUpdate] = core$2.useAction(props.on_update);
         const formattedDefaultLegends = React.useMemo(() => {
@@ -427333,60 +435011,60 @@
             }
         );
     }
     exports2.Accordion = Accordion;
     exports2.Anchor = Anchor;
     exports2.Bokeh = Bokeh;
     exports2.BulletList = BulletList;
-    exports2.Button = Button;
+    exports2.Button = Button$2;
     exports2.ButtonBar = ButtonBar;
     exports2.Card = Card$1;
     exports2.Carousel = Carousel;
     exports2.CausalGraphViewer = CausalGraphViewer;
     exports2.Chat = Chat;
-    exports2.CheckboxGroup = CheckboxGroup;
+    exports2.CheckboxGroup = CheckboxGroup$1;
     exports2.Code = Code;
     exports2.CodeEditor = CodeEditor;
     exports2.Column = Column;
     exports2.ComponentSelectList = ComponentSelectList;
     exports2.DataSlicerFilter = DataSlicerFilter;
     exports2.Datepicker = Datepicker;
     exports2.FilterStatusButton = FilterStatusButton;
     exports2.Form = Form;
     exports2.FormPage = FormPage;
     exports2.Grid = Grid;
     exports2.Heading = Heading$1;
     exports2.HierarchySelector = HierarchySelector;
     exports2.HierarchyViewer = HierarchyViewer;
     exports2.HtmlRaw = HtmlRaw;
-    exports2.Icon = Icon$1;
+    exports2.Icon = Icon$2;
     exports2.If = If;
     exports2.Image = Image$1;
-    exports2.Input = Input;
+    exports2.Input = Input$2;
     exports2.Label = Label;
     exports2.Markdown = Markdown;
     exports2.Matplotlib = Matplotlib;
-    exports2.Modal = Modal;
+    exports2.Modal = Modal$1;
     exports2.NodeHierarchyBuilder = NodeHierarchyBuilder;
     exports2.Overlay = Overlay;
     exports2.Paragraph = Paragraph;
     exports2.Plotly = Plotly;
     exports2.ProgressBar = ProgressBar;
     exports2.RadioGroup = RadioGroup;
-    exports2.Row = Row;
-    exports2.Select = Select;
+    exports2.Row = Row$1;
+    exports2.Select = Select$1;
     exports2.Slider = Slider;
     exports2.Spacer = Spacer;
     exports2.Stack = Stack$3;
-    exports2.Switch = Switch;
+    exports2.Switch = Switch$1;
     exports2.TabbedCard = TabbedCard;
-    exports2.Table = Table;
+    exports2.Table = Table$1;
     exports2.Text = Text$2;
     exports2.Textarea = Textarea;
-    exports2.Tooltip = Tooltip;
+    exports2.Tooltip = Tooltip$1;
     exports2.UploadDropzone = UploadDropzone;
     exports2.VisualEdgeEncoder = VisualEdgeEncoder;
     exports2.parseLayoutDefinition = parseLayoutDefinition;
     exports2.transformLegendColor = transformLegendColor;
     Object.defineProperties(exports2, {
         __esModule: {
             value: true
```

## Comparing `dara_components-1.7.6.dist-info/LICENSE` & `dara_components-1.7.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dara_components-1.7.6.dist-info/METADATA` & `dara_components-1.7.7.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,37 +1,37 @@
 Metadata-Version: 2.1
 Name: dara-components
-Version: 1.7.6
+Version: 1.7.7
 Summary: Components for the Dara Framework
 Home-page: https://dara.causalens.com/
 License: Apache-2.0
 Author: Patricia Jacob
 Author-email: patricia@causalens.com
 Requires-Python: >=3.8.0,<3.12.0
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Requires-Dist: bokeh (>=3.1.0,<3.2.0)
 Requires-Dist: cai-causal-graph (>=0.3.6)
-Requires-Dist: dara-core (==1.7.6)
+Requires-Dist: dara-core (==1.7.7)
 Requires-Dist: dill (>=0.3.0,<0.4.0)
 Requires-Dist: matplotlib (>=2.0.0)
 Requires-Dist: pandas (>=1.1.0,<3.0.0)
 Requires-Dist: plotly (>=5.14.0,<5.15.0)
 Requires-Dist: scipy
 Requires-Dist: seaborn (>=0.11.0)
 Project-URL: Repository, https://github.com/causalens/dara
 Description-Content-Type: text/markdown
 
 # Dara Components
 
-<img src="https://github.com/causalens/dara/blob/VERSION-1.7.6/img/dara_light.svg?raw=true">
+<img src="https://github.com/causalens/dara/blob/VERSION-1.7.7/img/dara_light.svg?raw=true">
 
 ![Master tests](https://github.com/causalens/dara/actions/workflows/tests.yml/badge.svg?branch=master)
 [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
 [![PyPI](https://img.shields.io/pypi/v/dara-components.svg?color=dark-green)](https://pypi.org/project/dara-components/)
 [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/dara-components.svg?color=dark-green)](https://pypi.org/project/dara-components/)
 [![NPM](https://img.shields.io/npm/v/@darajs/components.svg?color=dark-green)](https://www.npmjs.com/package/@darajs/components)
```

## Comparing `dara_components-1.7.6.dist-info/RECORD` & `dara_components-1.7.7.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 dara/components/__init__.py,sha256=69KqZ7BIpLkRVumyRBxcv5pEmtCvDtH1NvosOPlKTuE,808
 dara/components/common/__init__.py,sha256=FSBBYlKyqWOBjDu05iMX2dmuQrxI2xgrw7CO-NbMd8s,3866
 dara/components/common/accordion.py,sha256=8VRksGmbDvOrEzwv7mrYKK6kuiKyMPCHuRzEMqgTOvk,9487
 dara/components/common/anchor.py,sha256=IkumpwbrGdW4UMrFTkGaT0t6KtZQhdBYp1HS5IHPxoM,2869
 dara/components/common/base_component.py,sha256=TQfhpXYDH7ItM9hnhdActjzHM1NzT_yqGUdpLB8ZVqM,4707
 dara/components/common/bullet_list.py,sha256=yk4lFAn6Bzx9UByp27P7ioVidAfsTPl5d4hIkG7MRkQ,1433
-dara/components/common/button.py,sha256=CkOts6VnlcJIbTFpcjBJEojRFYOqK3PR0p8jRzkfH_k,4548
+dara/components/common/button.py,sha256=uBzKKChuan3CPidfYsm9Nstqvi0J3zF9l-1EeEy5ots,4549
 dara/components/common/button_bar.py,sha256=8PwjddFnp6dC_DfBCnBSmFSItgo8Sp1LNSl-rO3w0tY,3600
 dara/components/common/card.py,sha256=PiYlkBc0JRpuuQiHHHGZBft5w3dLtLIEqP9Fo-1kyjs,1999
 dara/components/common/carousel.py,sha256=K1scewjOFHLb4bAXvirlVSzujuU3lK4jsi6eHk2JUH0,5369
 dara/components/common/checkbox_group.py,sha256=0CnkBEV6bFHOC7N5k8Zjed2sBwvJ1qbCgk6x2Ow4jVc,4156
 dara/components/common/code.py,sha256=GzR9d3FnluagsYNW8OzcMV2L4_qRUj0YLXBbT6s02lw,2266
 dara/components/common/component_select_list.py,sha256=oaWP43FVdgOap4PKJbuniV5vR2tldR52xwtdfaYnx4U,2750
 dara/components/common/datepicker.py,sha256=X8DmIkNjkedSo0tvOw8j4wRIJJRUvb9pFRkg-KOWFfI,3613
@@ -71,13 +71,13 @@
 dara/components/smart/data_slicer/data_slicer_modal.py,sha256=t7NywA5DiFiUiUnuFQbTAAVm6PM7Qjd6LGzd9OWA0QE,4120
 dara/components/smart/data_slicer/extension/data_slicer_filter.py,sha256=2wdWn3gcrewrhUZ4tGNwAh1JURpcLmeDKIP7c5j9_sI,1616
 dara/components/smart/data_slicer/extension/filter_status_button.py,sha256=02CgqHEBgkZg1E9v9HGrnRYvEiMNhYpajyOwGuPNV1M,1345
 dara/components/smart/data_slicer/utils/core.py,sha256=6BrmG-iwQCuwUAKQ-y9zFKLeinnzhXIaUOB58UxCYbc,8656
 dara/components/smart/data_slicer/utils/data_preview.py,sha256=OAphjMrm3F76XmJ09X7sZSeOeKqGJFwN5ooo3qcyrG4,1722
 dara/components/smart/data_slicer/utils/plotting.py,sha256=JYzdQLXdAD0A8k2W-764xUr7zN0Ri5nf3OQ2Nb_iuiY,3313
 dara/components/smart/hierarchy.py,sha256=STkgyZiVB1c6KJtcKnn1r8lnjZAIrWkTCpZ_WCyCI1c,2877
-dara/components/umd/dara.components.umd.js,sha256=N5iEvLLamO16tGa28yAwaLtawjmWF2Hx8RTnqOVMvec,16835276
+dara/components/umd/dara.components.umd.js,sha256=xIcAQy6JT1qioCbGLuywuLN5wH87QNtCMjbIye7PuOU,17065436
 dara/components/umd/style.css,sha256=cvNU48TRRp73QxBrE9awB-zm3YURFnFlASafeLTNa_U,23576
-dara_components-1.7.6.dist-info/LICENSE,sha256=r9u1w2RvpLMV6YjuXHIKXRBKzia3fx_roPwboGcLqCc,10944
-dara_components-1.7.6.dist-info/METADATA,sha256=EVTdjNftYCQUl1Br3rX-b1sAHZ4aNNzFQEdJRzoLT7c,2710
-dara_components-1.7.6.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
-dara_components-1.7.6.dist-info/RECORD,,
+dara_components-1.7.7.dist-info/LICENSE,sha256=r9u1w2RvpLMV6YjuXHIKXRBKzia3fx_roPwboGcLqCc,10944
+dara_components-1.7.7.dist-info/METADATA,sha256=nXbXiNs7Sv8UY6Z14BVYbjcGw596QsjEIsTOFl23aC4,2710
+dara_components-1.7.7.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
+dara_components-1.7.7.dist-info/RECORD,,
```

